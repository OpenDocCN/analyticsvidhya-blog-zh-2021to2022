<html>
<head>
<title>Scikit-Learn Pipeline Transformers — The hassle of transforming target variables (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">sci kit-学习管道转换器——转换目标变量的麻烦(第2部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scikit-learn-pipeline-transformers-the-hassle-of-transforming-target-variables-part-2-ec8546c33ac6?source=collection_archive---------3-----------------------#2021-06-25">https://medium.com/analytics-vidhya/scikit-learn-pipeline-transformers-the-hassle-of-transforming-target-variables-part-2-ec8546c33ac6?source=collection_archive---------3-----------------------#2021-06-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="26ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文的第1部分中，我们学习了如何使用Scikit-Learn Pipelines transformers从我们的目标变量创建特性。第二部分更侧重于这种管道的实际实现以及一个简单的ML模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/612d1b5252a549565bc67f933e1da0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YyI68OQMVGqu-mB_Z5k-tw.png"/></div></div></figure><p id="9b3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为一个例子，我们将使用一个简单的单变量数据集，称为<a class="ae jc" href="https://raw.githubusercontent.com/jbrownlee/Datasets/master/monthly-sunspots.csv" rel="noopener ugc nofollow" target="_blank">月黑子</a>，我希望你记住，这里我只做一些简单的转换，出于教学的原因，因此我不会进入EDA的细节，只是一些基本的时间序列建模概念。</p><p id="88c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，让我们开始吧！</p><h2 id="31c1" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">1.我们的转变</h2><p id="7fde" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">首先，对于我们简单的ML模型，我们需要定义我们想要从数据集创建什么特征。如果您以前从未看过这些数据，让我快速展示一下，并展示一下我们将要做的一些基本功能。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/d7e5e3990a96dc5649fedc43018b47bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fPje8jfezqztbEojMClqHA.png"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">历史时间序列</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/d4cbcc60baa318e9d59bf3f27791420d.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/1*i0EoMzksDLgw5fCYlEdtXA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">数据集描述</figcaption></figure><p id="0056" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在这里我们可以注意到，我们有一个很好的季节性定义，但是，我们也有一个季节性成分的幅度显着变化。出于这个原因，太阳黑子的11年移动平均值(近似太阳的长期周期)是很有趣的。</p><p id="d3c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对历史数据使用移动平均线时必须非常小心，如果在计算移动平均线之前没有移动目标变量，将会导致<strong class="ig hi"> <em class="kv">数据泄漏，</em>因为某个点的移动平均线考虑了该点本身。</strong></p><p id="905f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/23524c9363086ed1fe975fe32bf42cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eLVJzY94iTpyh1rV0bCGrA.png"/></div></div></figure><p id="fcdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，另一个非常好的特征是我们处于季节周期的哪个部分。然而，这一特征并不特别容易提取，因为周期并不正好是11年。出于这个原因，我们将采取一种更天真的方法，仅仅因为这种检测本身就是一个主题。在本例中，我们将提取它作为当前年份1750(第一个峰值)除以11年的余数，将其置于0的中心，并将其归一化(类似于从0到1的saw函数)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/2513572d5a3425dfbece670f91b880e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P3-DaRHloP0eiZeD_d0Kug.png"/></div></div></figure><p id="8686" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一个特性将是简单的滞后目标特性(在这个例子中我们将使用12个滞后)，因为我们将使用我在第1部分中介绍的函数的一个微小变化:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1b39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个函数的作用很简单:获取一个序列并移动它，将其记录在一个名为<variable> _lag的新列中</variable></p><p id="add4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们有了转换集:</p><p id="6c02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">1-移动平均线:</strong>最近11年周期(132个月)的移动平均线。它将被称为我们的<em class="kv">毫安_变压器</em></p><p id="26a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">2-季节性周期:</strong>变量范围从0到1，取决于我们离理论周期峰值有多近。这将是<em class="kv">季_变形金刚</em></p><p id="e893" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3-Lags: </strong>来自我们的时间序列的12个先前观察值，将被称为<em class="kv"> Lag_Transformer </em></p><h2 id="ea2b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">2.我们的数据对象</h2><p id="9baa" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">如前一篇文章所示，我们需要一个可以存储两者的对象:我们的特性数据框架和我们的目标值系列。这里我们将使用我们之前使用的同一个对象，<strong class="ig hi"> Hacky_Object，</strong>但是有一点小小的变化，我们也将在这里存储目标变量的名称，因为我们处理的是数据帧而不是数组。</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="87c2" class="jp jq hh kz b fi ld le l lf lg">class Hacky_Object():<br/>    def __init__(self,X=None,y=None,target=None):<br/>        #store X and Y<br/>        self.X=X<br/>        self.y=y<br/>        self.target=target</span></pre><p id="a5e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，现在让我们创建一些代码来加载我们的数据集，索引它并把它放在我们的Hacky_Object上</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h2 id="0674" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.我们的变形金刚</h2><p id="b19d" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">好了，现在我们需要一些转换器来接收我们的对象并进行我们需要的转换。为此，我们将使用sklearn中的基类创建上面提到的3个变形金刚。</p><p id="4bb0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将对我们上次使用的转换器做一点小小的改变，我将为每个转换器添加一个调试属性，以使我们的生活更容易，以防我们需要跟踪出错的特定转换。</p><h2 id="aba4" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated"><em class="lh">如果你正在处理非常大的数据集，这可能会给你的内存分配带来一点麻烦… </em></h2><p id="f309" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">为了保持代码的简单性和可读性，我们的转换器将直接调用一个函数，其中的代码将只用于执行以下操作:</p><p id="6ca3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获取数据对象属性-&gt;运行一个函数来转换它-&gt;将结果赋回对象</p><p id="adb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，首先，让我们定义我们的辅助转换函数:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="f5b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了这些定义的函数，我们就可以创建我们的转换器，直接调用它们。</p><p id="93cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，我们可以使用一个<code class="du li lj lk kz b">FunctionTransformer()</code>来构建我们的管道，但是我将使用定制的转换器来保持数据血统并提供一些灵活性。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="686b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，现在我们把它们放在一起，运行一个简单的管道转换来查看结果(如果您已经加载了您的数据对象，您可以运行下面的代码片段)</p><pre class="je jf jg jh fd ky kz la lb aw lc bi"><span id="47a4" class="jp jq hh kz b fi ld le l lf lg">from sklearn.pipeline import Pipeline</span><span id="4c67" class="jp jq hh kz b fi ll le l lf lg">#Build Pipeline<br/>My_Pipeline=Pipeline([<br/>('MovingAverage',MA_Transformer(months=12*11)),                ('Season',Season_Transformer(start_year=1750,seasonal_period=11)),<br/>('Lags',Lag_Transformer(lag=12))])</span><span id="4c82" class="jp jq hh kz b fi ll le l lf lg">#Transform your data</span><span id="1fd9" class="jp jq hh kz b fi ll le l lf lg">Data_Obj=My_Pipeline.transform(Data_Obj)<br/>Data_Obj.X.head(50)</span></pre><p id="e9a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果运行该命令，您将得到与此非常相似的结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/de878c0ccd62e1a805b1f95e99539986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O5EqbeCRg4jm2UeC4bkzKQ.png"/></div></div></figure><p id="6c6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如我们所见，数据帧上有几个NaN值。不幸的是，并不是所有的型号都能处理这个问题。我们将创建另一个非常简单的转换器来删除X和y的所有NaN值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="d400" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们有了完整的预处理流水线。下一步是创建一个接受我们的数据对象作为输入的模型。</p><h2 id="1742" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">4.我们的模型</h2><p id="0d2e" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">这是我们将遇到十字路口的代码点。在这一点上，你们中的一些人可能更喜欢简单地将转换后的X<em class="kv">和y</em>分配给新的独立变量，并在那里使用标准建模。</p><p id="363f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将展示的是一个简单的技巧，使用Sk-learn基本估计器mixin来使我们的简明数据对象适合您想要的任何模型。</p><h2 id="6f8e" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">小观察:为了简单起见，我们的模型将只实现fit和predict方法，但是您可以继续对其他方法进行同样的操作。</h2><p id="7b0a" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">现在，我们创建一个简单的模型类，它接受我们的数据对象。需要注意的是，我将手动进行训练和测试分割，但是您总是可以使用定制的转换器来完成。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="44e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如你所看到的，我们所做的唯一的事情就是把我们分开的X和y输入到模型中。好处是我们可以将它整齐地放入我们的管道中。</p><p id="0883" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您也可以使用相同的方法进行网格搜索，因为网格搜索类实际上是一个估计器。如果您要实现网格搜索，请确保在管道末端将其作为您的模型传递，不要在网格搜索中包装您的管道，因为这将导致数据折叠由于滞后和移动平均转换器而不完整。</p><p id="47c4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在的最后一步是创建适合模型的代码并预测值。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1444" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如前所述，我在管道外分离了训练和测试数据，但是，您可以创建一个转换器来完成这项工作。</p><p id="eea0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您运行此代码并检查预测值，您应该会得到类似如下的结果:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/2d1382cc43052da74b7b9876231888f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nOgLXB7LmqVA159VZyI_Pw.png"/></div></div></figure><p id="6323" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，预测实际上相当不错，但请记住，我们是在1个观察值的预测范围内进行预测。指标如下所示:</p><p id="b2f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> R2 —火车:</strong> 0.902 | | | <strong class="ig hi">梅—火车:</strong> 8.809 | | | <strong class="ig hi"> RMSE —火车:</strong> 11.88</p><p id="b5c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> R2 —检验:</strong> 0.876 | | | <strong class="ig hi">梅—检验:</strong> 13.96 | | | <strong class="ig hi"> RMSE —检验:</strong> 19.25</p><p id="4e16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以注意到，即使在很少的特征工程和绝对没有超参数调整的情况下，我们也获得了非常好的预测，甚至可以与相同数据集的RNN ka ggle基准相比(从MAE的12到18，取决于神经网络架构)。</p><h2 id="edd7" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">5.最后的想法</h2><p id="8cdf" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">有了本文和本文第1部分中展示的所有内容，您现在有能力创建任意复杂的涉及目标变量转换的管道，更重要的是，您现在能够将所有内容组装到一个管道中以供将来使用。</p><p id="a348" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在可追溯性和可维护性至关重要的MLOps环境中，这种管道标准化非常重要。您可以进一步扩展这个概念，并创建标准的数据转换库来与您的组织共享。</p><p id="5a10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi ln translated">这里最后一个想法，甚至作为对周围新数据科学家的建议，是关于预测结果的:</p><p id="0b3b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预测结果在神经网络基准值范围内，但是我们使用了一个非常简单的梯度推进回归器，没有超参数调整，我可以说即使是线性回归也可以获得类似的结果。</p><p id="cdfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个非常明确的提醒，一个我在ML项目中一直牢记在心的提醒:你的模型结果更依赖于你如何执行你的特征工程，而不是模型本身。机器学习模型就像非常熟练的语言学家，可以破译任何语言的任何文本。然而，如果你递给他们一堆潦草的字迹或模糊的文字，那就没有什么用了。请，<strong class="ig hi">不要跳过EDA </strong>，一个彻底的EDA和特征工程过程占一个好模型90%的结果。</p><p id="63a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">故事笔记本链接:【https://github.com/carlos-schwabe/Medium_Pipelines T2】</p></div></div>    
</body>
</html>