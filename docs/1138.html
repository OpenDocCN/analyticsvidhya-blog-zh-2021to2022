<html>
<head>
<title>Wheat Disease Detection using Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Keras的小麦病害检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/wheat-disease-detection-using-keras-48ae78990502?source=collection_archive---------5-----------------------#2021-02-16">https://medium.com/analytics-vidhya/wheat-disease-detection-using-keras-48ae78990502?source=collection_archive---------5-----------------------#2021-02-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es et"><img src="../Images/18b1ebb961486cce9a5cd22326e23cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dOfwtoagyc4nZ2hRgBEjEw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">来源:<a class="ae it" href="https://www.wallpaperflare.com/wheat-field-low-angle-photography-of-wheats-sunset-macro-depth-of-field-wallpaper-tjn" rel="noopener ugc nofollow" target="_blank">壁纸信号弹</a></figcaption></figure><h1 id="1cad" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">目录</h1><ol class=""><li id="7b82" class="js jt hi ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">介绍</li><li id="94b3" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">资料组</li><li id="ee03" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">图书馆</li><li id="606a" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">数据预处理</li><li id="093e" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">数据扩充</li><li id="3f57" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">模型</li><li id="6e48" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">培养</li><li id="e2c2" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">估价</li><li id="5148" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">测试</li></ol><h1 id="97e5" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="0df7" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">印度不仅在文化上是一个多样化的地区，在食物上也是如此。印度是一个农业国家，75%的印度人口依靠农业为生。小麦是硒和镁等矿物质的重要来源。一些营养素对身体健康是必要的。叶锈病对小麦叶片的伤害最大。真菌性疾病，病毒性疾病，并有如此普遍。</p><p id="6d16" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">小麦病害的特征，已经观察到小麦病害本质上集中在小麦叶片上，并且可以通过深度学习和计算机视觉技术来识别。</p><h1 id="126f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">资料组</h1><p id="4394" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">使用的数据集是<a class="ae it" href="https://drive.google.com/drive/folders/1OHKtwD1UrdmhqxrpQEeF_X_pqKotxRGD?usp=sharing" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj"> <em class="lj">大型小麦病害分类数据集(LWDCD2020) </em> </strong> </a>。它由三类小麦病害和一类正常病害的大约4500幅图像组成。这些图像是为了尺寸的一致性而精心制作的。</p><p id="b303" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">数据集总共包含4个<strong class="ju hj">类</strong>，如下所示:</p><ol class=""><li id="586d" class="js jt hi ju b jv le jx lf jz lk kb ll kd lm kf kg kh ki kj bi translated">叶锈病</li><li id="7d28" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">冠根腐烂病</li><li id="f00b" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">健康小麦</li><li id="43a4" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">小麦散黑穗病</li></ol><blockquote class="ln lo lp"><p id="c223" class="kp kq lj ju b jv le kr ks jx lf kt ku lq lg kw kx lr lh kz la ls li lc ld kf hb bi translated"><strong class="ju hj">注<em class="hi"> : </em> </strong> <em class="hi">数据集图像</em>包括复杂的背景、各种不同的捕获条件、对疾病演变的不同阶段(疾病的早期、中期和晚期)的各种表征，以及不同小麦疾病之间的相似特征。</p></blockquote><h1 id="7a6c" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">图书馆</h1><p id="876f" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">我们导入处理数据和构建分类模型所需的所有库。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="799e" class="mc iv hi ly b fi md me l mf mg">from keras.preprocessing.image import ImageDataGenerator<br/>from sklearn.model_selection import train_test_split<br/>from keras.layers.pooling import AveragePooling2D<br/>from keras.layers.core import Dropout<br/>from keras.layers.core import Flatten<br/>from keras.layers.core import Dense<br/>from sklearn.preprocessing import LabelBinarizer<br/>from keras.layers import Input<br/>from keras.models import Model<br/>from keras.optimizers import Adam<br/>from keras.models import load_model<br/>from sklearn.metrics import classification_report<br/>from keras.applications import VGG19<br/>from imutils import paths<br/>from collections import deque<br/>import matplotlib.pyplot as plt<br/>import numpy as np<br/>import cv2<br/>import os<br/>import pickle</span></pre><ul class=""><li id="29d8" class="js jt hi ju b jv le jx lf jz lk kb ll kd lm kf mh kh ki kj bi translated"><strong class="ju hj">Matplotlib</strong>:Python编程语言的绘图库。它设置后端，这样我们就可以将我们的训练图输出到一个. png图像文件。</li><li id="f4c5" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated"><strong class="ju hj"> Keras </strong> : Keras是用Python编写的开源神经网络库，运行在机器学习平台TensorFlow之上。</li><li id="cefc" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated">Sklearn :从scikit-learn，我们将使用他们实现的LabelBinarizer对我们的类标签进行一次性编码。train_test_split函数将我们的数据集分割成训练和测试两部分。我们还将以传统格式打印一份分类报告。</li><li id="f950" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated">Numpy:由多维数组对象和处理这些数组的例程集合组成的库。</li><li id="a04f" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated"><strong class="ju hj"> Pickle </strong>:用于序列化我们的标签二进制到磁盘。这个想法是，这个字符流包含在另一个python脚本中重建对象所需的所有信息。</li><li id="9e17" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated">cv2 (OpenCV)  : OpenCV是一个绑定库，旨在解决计算机视觉问题</li><li id="c41f" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf mh kh ki kj bi translated"><strong class="ju hj"> os </strong>:操作系统模块将用于确保我们获取正确的文件/路径分隔符，这是依赖于操作系统的。</li></ul><h1 id="79c7" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">数据预处理</h1><p id="2313" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">让我们继续初始化标签并加载数据:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="f62b" class="mc iv hi ly b fi md me l mf mg">LABELS = set(["Crown and Root Rot", "Healthy Wheat", "Leaf Rust", "Wheat Loose Smut"])</span><span id="d61f" class="mc iv hi ly b fi mi me l mf mg">imagePaths = list(paths.list_images(dataset))<br/>data = []<br/>labels = []</span><span id="087e" class="mc iv hi ly b fi mi me l mf mg"># loop over the image paths<br/>for imagePath in imagePaths:<br/> # extract the class label from the filename<br/> label = imagePath.split(os.path.sep)[-2]</span><span id="cc59" class="mc iv hi ly b fi mi me l mf mg"># if the label of the current image is not part of the labels<br/> # are interested in, then ignore the image<br/> if label not in LABELS:<br/> continue</span><span id="de5f" class="mc iv hi ly b fi mi me l mf mg"># load the image, convert it to RGB channel ordering, and resize<br/> # it to be a fixed 224x224 pixels, ignoring aspect ratio<br/> image = cv2.imread(imagePath)<br/> image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)<br/> image = cv2.resize(image, (224, 224))</span><span id="f977" class="mc iv hi ly b fi mi me l mf mg"># update the data and labels lists, respectively<br/> data.append(image)<br/> labels.append(label)</span></pre><ol class=""><li id="9a80" class="js jt hi ju b jv le jx lf jz lk kb ll kd lm kf kg kh ki kj bi translated">它包括我们的数据集将包含的一组类标签。不存在于该集合中的每个标签<em class="lj">将被<em class="lj">排除</em>成为我们数据集的一部分。为了节省训练时间，我们的数据集将只包含冠腐病和根腐病、健康小麦和叶锈病。通过对集合进行更改，您可以随意使用其他类。</em></li><li id="30d1" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">我们初始化数据和标签列表，然后开始遍历所有的imagePaths。在循环中，首先，我们从imagePaths中提取类标签。</li><li id="dc15" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">然后加载并预处理图像。预处理包括为OpenCV交换颜色通道以兼容Keras，以及调整大小为<em class="lj"> 224×224 </em> px。</li><li id="1714" class="js jt hi ju b jv kk jx kl jz km kb kn kd ko kf kg kh ki kj bi translated">然后，图像和标签被添加到数据标签列表中。</li></ol><p id="d86a" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">我们将对标签进行一次性编码，并对数据进行分区:</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="b44f" class="mc iv hi ly b fi md me l mf mg"># convert the data and labels to NumPy arrays<br/>data = np.array(data)<br/>labels = np.array(labels)</span><span id="6fd3" class="mc iv hi ly b fi mi me l mf mg"># perform one-hot encoding on the labels<br/>lb = LabelBinarizer()<br/>labels = lb.fit_transform(labels)</span><span id="fc3b" class="mc iv hi ly b fi mi me l mf mg"># partition the data into training and testing splits using 75% of<br/># the data for training and the remaining 25% for testing<br/>(trainX, testX, trainY, testY) = train_test_split(data, labels,<br/> test_size=0.25, stratify=labels, random_state=42)</span></pre><h1 id="ba6d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">数据扩充</h1><p id="da3b" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">图像数据扩充是一种可用于通过在数据集中创建图像的修改版本来人为扩展训练数据集的大小的技术。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="fac6" class="mc iv hi ly b fi md me l mf mg"># initialize the training data augmentation object<br/>trainAug = ImageDataGenerator(<br/> rotation_range=30,<br/> zoom_range=0.15,<br/> width_shift_range=0.2,<br/> height_shift_range=0.2,<br/> shear_range=0.15,<br/> horizontal_flip=True,<br/> fill_mode="nearest")</span><span id="08ec" class="mc iv hi ly b fi mi me l mf mg"># initialize the validation/testing data augmentation object (which<br/># we'll be adding mean subtraction to)<br/>valAug = ImageDataGenerator()</span><span id="b739" class="mc iv hi ly b fi mi me l mf mg"># define the ImageNet mean subtraction (in RGB order) and set the<br/># the mean subtraction value for each of the data augmentation<br/># objects<br/>mean = np.array([123.68, 116.779, 103.939], dtype="float32")<br/>trainAug.mean = mean<br/>valAug.mean = mean</span></pre><blockquote class="ln lo lp"><p id="a4b5" class="kp kq lj ju b jv le kr ks jx lf kt ku lq lg kw kx lr lh kz la ls li lc ld kf hb bi translated"><strong class="ju hj">注意:</strong><em class="hi">train aug对象对我们的数据执行随机旋转、缩放、移动、剪切和翻转。</em></p></blockquote><h1 id="563f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">模型</h1><p id="6f91" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">VGG19在大型数据集(ImageNet)上进行预训练，以构建图像表示。该模型在ImageNet中达到了大约92.7%的top-5测试准确率。与更复杂的网络相比，它实现了有竞争力的分类精度，即使以更慢的评估速度和更大的网络大小为代价。它的重要之处在于其惊人的基本结构，所有卷积层的核大小为3×3，步长为1。有五组conv层，其中两组具有64个滤波器，下一组具有两个具有128个滤波器的conv层，下一组具有四个具有256个滤波器的conv层，下两组各具有四个具有512个滤波器的conv层。每组conv图层中都有最大池化图层。Max-pooling层具有跨度为2(像素)的2x2滤镜。最后一个池层的输出被展平，并被馈送到完全连接的层，该层用于利用4096个神经元进行分类。输出到另一个具有4096个神经元的全连接层，其输出被馈送到另一个具有1000个神经元的全连接层。所有这些层都被重新激活。最后是softmax层。大约有138，357，544个参数，其中可训练参数是138，357，544，不可训练参数是0。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="a99b" class="mc iv hi ly b fi md me l mf mg"># load the VGG19 network, ensuring the head FC layer sets are left<br/># off<br/>headmodel = VGG19(weights="imagenet", include_top=False,<br/>                  input_tensor=Input(shape=(224, 224, 3)))</span><span id="948b" class="mc iv hi ly b fi mi me l mf mg"># construct the head of the model that will be placed on top of the<br/># the base model<br/>model = headmodel.output<br/>model = AveragePooling2D(pool_size=(5, 5))(model)<br/>model = Flatten(name="flatten")(model)<br/>model = Dense(512, activation="relu")(model)<br/>model = Dropout(0.4)(model)<br/>model = Dense(len(lb.classes_), activation="softmax")(model)</span><span id="68a3" class="mc iv hi ly b fi mi me l mf mg"># place the head FC model on top of the base model (this will become<br/># the actual model we will train)<br/>moodel = Model(inputs=headmodel.input, outputs=model)</span><span id="61c1" class="mc iv hi ly b fi mi me l mf mg"># loop over all layers in the base model and freeze them so they will<br/># *not* be updated during the training process<br/>for layer in headmodel.layers:<br/>    layer.trainable = False</span></pre><h1 id="199d" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">培养</h1><p id="a8d8" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">我们用学习率1e-3和学习率衰减来初始化我们的优化器。我们选择了<strong class="ju hj"> Adam优化</strong>技术，因为与其他优化技术相比，它几乎总是工作得更快，更好地全局最小收敛。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="94a7" class="mc iv hi ly b fi md me l mf mg"># compile our model (this needs to be done after our setting our<br/># layers to being non-trainable)<br/>opt = Adam(lr=1e-3)<br/>moodel.compile(loss="categorical_crossentropy", optimizer=opt,<br/>               metrics=["accuracy"])</span><span id="2c5f" class="mc iv hi ly b fi mi me l mf mg"># train the head of the network for a few epochs (all other layers<br/># are frozen) -- this will allow the new FC layers to start to become<br/># initialized with actual "learned" values versus pure random<br/>H = moodel.fit(<br/>    trainAug.flow(trainX, trainY, batch_size=64),<br/>    steps_per_epoch=len(trainX) // 64,<br/>    validation_data=valAug.flow(testX, testY),<br/>    validation_steps=len(testX) // 64,<br/>    epochs=30)</span></pre><h1 id="ce3f" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">估价</h1><p id="ca49" class="pw-post-body-paragraph kp kq hi ju b jv jw kr ks jx jy kt ku jz kv kw kx kb ky kz la kd lb lc ld kf hb bi translated">我们绘制了一个图表来比较模型获得的最大精度，同时减少了训练期间的损失。</p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="4dfc" class="mc iv hi ly b fi md me l mf mg"># evaluate the network<br/>predictions = moodel.predict(testX, batch_size=64)<br/>print(classification_report(testY.argmax(axis=1),<br/>                            predictions.argmax(axis=1), target_names=lb.classes_))</span><span id="0520" class="mc iv hi ly b fi mi me l mf mg"># plot the training loss and accuracy<br/>N = 30<br/>plt.plot(np.arange(0, N), H.history['accuracy'], label="Training Accuracy")<br/>plt.plot(np.arange(0, N), H.history['val_accuracy'], label="Test Accuracy")<br/>plt.title('VGG19 Model Train vs Test Accuracy')<br/>plt.ylabel('Accuracy')<br/>plt.xlabel('Epoch')<br/>plt.legend(loc='lower right')<br/>plt.show()<br/>plt.savefig(r"E:\Wheat Disease Detection\Accuracy_Plot.png")</span><span id="0b1c" class="mc iv hi ly b fi mi me l mf mg">plt.plot(H.history['loss'], label="Training Loss")<br/>plt.plot(H.history['val_loss'], label="Test Loss")<br/>plt.title('VGG19 Model Train vs Test Loss')<br/>plt.ylabel('Loss')<br/>plt.xlabel('Epoch')<br/>plt.legend(loc='upper right')<br/>plt.show()<br/>plt.savefig(r"E:\Wheat Disease Detection\Loss_Plot.png")</span></pre><div class="lt lu lv lw fd ab cb"><figure class="mj ii mk ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/49effe623b59b99691bb04bdf6b742b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*mq-ujxEaOISW43X5PiEpbQ.png"/></div></figure><figure class="mj ii mp ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/52f165334c16f6a504bde0d0393c7868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*TiaCSVNKkKzrrBzrqDuMPg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx mq di mr ms translated">准确度和损耗图</figcaption></figure></div><p id="6572" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">通过阅读上面的图表，我们看到随着训练精度的增加，验证精度也增加。同样，随着训练损失的减少，验证损失也会减少。</p><p id="58cd" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">我们可以通过调整<strong class="ju hj">学习速率</strong>，或者通过对更多图像进行训练，或者只是简单地对更多时期的模型进行训练，来获得更好的结果。</p><p id="4d8f" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">我们使用evaluate()方法，得到了一个<strong class="ju hj">测试准确率</strong>的<strong class="ju hj"> 97.85%！！</strong></p><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="c55a" class="mc iv hi ly b fi md me l mf mg">#Save the Model and label file to Disk<br/>moodel.save("E:\Wheat Disease Detection\activity_model.h5")</span><span id="0e3f" class="mc iv hi ly b fi mi me l mf mg">f = open("label", "wb")<br/>f.write(pickle.dumps(lb))<br/>f.close()</span></pre><h1 id="bb09" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">测试</h1><pre class="lt lu lv lw fd lx ly lz ma aw mb bi"><span id="8bab" class="mc iv hi ly b fi md me l mf mg">model_path = "E:\Wheat Disease Detection\activity_model.h5"<br/>input = "E:\Wheat Disease Detection\input_image.png"<br/>label = "E:\Wheat Disease Detection\lb.pickle"</span><span id="d461" class="mc iv hi ly b fi mi me l mf mg"># load the trained model and label binarizer from disk<br/>moodel = load_model(model_path)<br/>lb = pickle.loads(open("label", "rb").read())</span><span id="234f" class="mc iv hi ly b fi mi me l mf mg"># initialize the image mean for mean subtraction along with the<br/># predictions queue<br/>mean = np.array([123.68, 116.779, 103.939][::1], dtype="float32")<br/>Q = deque(maxlen=128)</span><span id="ce5c" class="mc iv hi ly b fi mi me l mf mg">vs = cv2.VideoCapture(input)</span><span id="f8e4" class="mc iv hi ly b fi mi me l mf mg">(W, H) = (None, None)</span><span id="c9cd" class="mc iv hi ly b fi mi me l mf mg">while True:<br/>   (grabbed, frame) = vs.read()</span><span id="90f9" class="mc iv hi ly b fi mi me l mf mg">if not grabbed:<br/>      break</span><span id="cac0" class="mc iv hi ly b fi mi me l mf mg">if W is None or H is None:<br/>      (H, W) = frame.shape[:2]</span><span id="8b06" class="mc iv hi ly b fi mi me l mf mg">output = frame.copy()<br/>   frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)<br/>   frame = cv2.resize(frame, (224, 224)).astype("float32")<br/>   frame -= mean</span><span id="ff37" class="mc iv hi ly b fi mi me l mf mg">preds = moodel.predict(np.expand_dims(frame, axis=0))[0]<br/>   Q.append(preds)</span><span id="3c74" class="mc iv hi ly b fi mi me l mf mg">results = np.array(Q).mean(axis=0)<br/>   i = np.argmax(results)<br/>   label = lb.classes_[i]</span><span id="7023" class="mc iv hi ly b fi mi me l mf mg">text = "PREDICTION: {}".format(label.upper())<br/>   cv2.putText(output, text, (4, 4), cv2.FONT_HERSHEY_SIMPLEX,<br/>      0.25, (200,255,155), 2)</span><span id="d80d" class="mc iv hi ly b fi mi me l mf mg"># show the output image<br/>   cv2.imshow("Output",output)<br/>   key = cv2.waitKey(10) &amp; 0xFF<br/> <br/>   # if the `q` key was pressed, break from the loop<br/>   if key == ord("q"):<br/>      break</span><span id="3099" class="mc iv hi ly b fi mi me l mf mg">vs.release()</span></pre><p id="e87a" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">为了测试，我们随机选择图像，并尝试预测小麦图像的类别或疾病。</p><div class="lt lu lv lw fd ab cb"><figure class="mj ii mt ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/ff643030df10cd7c96268a4e56301e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*XfpT7JhMLWbVx8wHJkGA5g.jpeg"/></div></figure><figure class="mj ii mu ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/67f5164632db0466e4004c49605afeb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*Hlx46GJgtQMelwaD5GT7Mg.jpeg"/></div></figure><figure class="mj ii mv ml mm mn mo paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/b92e4d789912d6cde9646f6036a33ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:704/format:webp/1*ct4MKgyu9BO3RZb-sYzmBA.png"/></div></figure></div><p id="0524" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated">这个项目的完整源代码可以在<a class="ae it" href="https://github.com/lakshaygoyal425/Wheat-Disease-Detection" rel="noopener ugc nofollow" target="_blank"> <strong class="ju hj"> GitHub </strong> </a>上找到</p></div><div class="ab cl mw mx gp my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="hb hc hd he hf"><p id="d9ad" class="pw-post-body-paragraph kp kq hi ju b jv le kr ks jx lf kt ku jz lg kw kx kb lh kz la kd li lc ld kf hb bi translated"><strong class="ju hj"> <em class="lj">如有任何建议或疑问，欢迎随时评论。<br/>感谢您的阅读！</em> </strong></p></div></div>    
</body>
</html>