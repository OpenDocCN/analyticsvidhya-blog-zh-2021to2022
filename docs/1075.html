<html>
<head>
<title>Applied Computational Thinking Using Python — Multigrid Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的应用计算思维——多重网格方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/applied-computational-thinking-using-python-multigrid-methods-64c86113e60b?source=collection_archive---------3-----------------------#2021-02-13">https://medium.com/analytics-vidhya/applied-computational-thinking-using-python-multigrid-methods-64c86113e60b?source=collection_archive---------3-----------------------#2021-02-13</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="67f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象一下，你被要求解决一个复杂的问题，让事情变得更具挑战性的是，你不能使用你通常使用的工具，这有助于解决问题。听起来很有挑战性，对吧？如果没有这一战略，它肯定会失败。在本文中，我们将讨论解决复杂问题的一般过程，即计算思维。</p><p id="7591" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算思维是用计算机、人类或机器能够有效地执行的方式来表述问题和表达其解决方案的思维过程。</p><p id="8aa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">计算思维包括4个基本步骤，</p><ol class=""><li id="caf4" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">分解</strong>——把一个复杂的问题分解成一个更小的问题。</li><li id="60b7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">模式识别</strong>——寻找问题之间和问题内部的相似性。</li><li id="344a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">抽象— </strong>只关注我们真正需要的东西，忽略无关的信息。</li><li id="a263" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">算法</strong>——开发计算机代码来解决问题。</li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es jr"><img src="../Images/cd9f3112d27714e7a42b70fed8a077ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rr2dugDcOJ-X-l6lzpGV5A.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图1:计算思维</figcaption></figure><p id="d402" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你不只是在寻找问题的答案，而是寻找问题的最佳答案时，这种计算思维的方法将会很有用。</p><h1 id="0ce6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">多重网格方法</strong></h1><p id="13aa" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在本文中，为了理解计算思维的方法，我们将介绍多重网格方法的概念。我们将使用多重网格方法以非常简单的方式解决拉普拉斯问题。</p><p id="ceef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从单一网格开始，然后我们将移动到多重网格</p><h1 id="b5e8" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">物理问题</strong></h1><p id="9377" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">让我们考虑图1所示的2D物理问题，我们想解决这个问题的拉普拉斯方程。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lk"><img src="../Images/09b6a2b83fb495971ca767516ce4a25a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7iyyMAMWLBG3klhJx8G7w.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图2:物理问题</figcaption></figure><p id="7a31" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拉普拉斯方程由下式给出:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ll"><img src="../Images/c3a234db1c3b90a195649a87bc2dc391.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*AUTp_Z6k2M8O5hqbIMXEyg.png"/></div></figure><p id="677f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设置，</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lm"><img src="../Images/89e7e44fda77c99797a905e995a28eeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*2mt9el9Yt3kiuZCBK2MYew.png"/></div></figure><p id="ab8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">拉普拉斯方程的离散化将看起来像，</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ln"><img src="../Images/d5f778f0c9c75988c8851f20a72f6c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*snhh2YLS7ycbv1-_vox7xg.png"/></div></figure><p id="daf6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决上述问题的雅可比迭代方法采用以下形式，</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lo"><img src="../Images/501386e521583f4dc7e793759e152a9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ORhYfcPy7t38ODuevKCkfQ.png"/></div></div></figure><h1 id="b303" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">让我们用Python编码</strong></h1><p id="3de5" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated"><strong class="ih hj">边界条件</strong></p><p id="9be2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将在(n×n)网格中离散化区域，并应用边界条件。对于我们的示例，我们将在四个不同的网格(32 x 32)、(64 x 64)、(128 x 128)和(256 x 256)上进行模拟。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lp"><img src="../Images/9be1c5c19d0254deece2933a0bb01517.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*IvgkxMpr_jis2aTiRSg2KQ.png"/></div></figure><p id="b879" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用热图进行可视化。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es lq"><img src="../Images/13d2f4e712ce51b3928256c432da03b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*8PhVYRbuk60MxFutsxjv3Q.png"/></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图3:带边界条件的网格</figcaption></figure><p id="f693" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们编码雅可比步骤，</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lr"><img src="../Images/36a4be7975cded8be571dbf6472f6230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9gEeGoXqQFZxofhGOV8SNw.png"/></div></div></figure><p id="bc09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">允许对四个不同的网格进行模拟(雅可比步骤),直到满足模拟标准。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ls"><img src="../Images/9eb6dd6298b69365cf74c7b3164239ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJIc-MqtRViAU1zmnjQo-g.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图32x32网格(左)和64x64网格(右)的模拟结果</figcaption></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lt"><img src="../Images/5cea33018105220e453e702ce38871a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kO_1QMI7xY625DW7QHHKig.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图128x128网格(左)和256x256网格(右)的模拟结果</figcaption></figure><p id="99e5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果如下:</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lu"><img src="../Images/c7fba9109b7718eb437f6156e898f8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B7sFreaQq_QKyIPgbTZDyQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">表1:模拟结果</figcaption></figure><p id="9ba1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从图4和图5中我们可以清楚地看到，随着网格越来越细，解决方案变得越来越平滑，但这是以计算时间为代价的。同样清楚的是，与较细的网格相比，模拟在较粗的网格上收敛得更快。<strong class="ih hj">因此，现在的问题是，我们有没有什么方法可以减少计算时间，并且仍然可以得到精确的结果，就像我们在更精细的网格上得到的结果一样</strong>？<strong class="ih hj">这不过是计算思维</strong>。要回答这个问题，如果我们在较粗的网格上运行模拟，然后在较细的网格上映射结果，会怎么样？那能行吗？让我们看看！</p><h1 id="6850" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">多重网格方法</strong></h1><p id="2fbb" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">在数值分析中，<strong class="ih hj">多重网格法</strong> ( <strong class="ih hj"> MG法</strong>)是一种使用离散化层次来求解微分方程的算法。多重网格的主要思想是加速基本迭代法的收敛。多重网格方法有多种选择，在求解单次迭代的速度和所述迭代的收敛速度之间有不同的折衷。三种主要类型是V型循环、F型循环和W型循环。在本文中，我们将使用V-Cycle。</p><p id="4514" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是多重网格方法的基本步骤，</p><ol class=""><li id="f57e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">用更细的网格离散化区域。</li><li id="ec69" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">运行几次Jacobi迭代。(预平滑)</li><li id="3087" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">将细网格的结果插值到粗网格中。(限制)</li><li id="f628" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">运行模拟直到收敛。</li><li id="041a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">将结果插值回更精细的网格。(延长)</li><li id="b3ee" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">再次运行Jacobi几次迭代(平滑后)</li></ol><p id="0df5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们看看限制和延长的python代码是什么样子的，</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lv"><img src="../Images/29319c14ab4ff14c58cd955d8c362210.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yn7RVCkLTFaKp4Z-eoVE8A.png"/></div></div></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lw"><img src="../Images/15ed04b6836f53d9b7816c09c30b05eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lcd8Lb6S2YMb3H0uoLnWLQ.png"/></div></div></figure><p id="3aed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于我们的2D离散问题，我们将从用(256 x 256)网格离散化区域开始，运行模拟几次迭代，将结果插值到较粗的网格(128 x 128)，运行模拟直到收敛，将结果插值回较细的网格(256 x 256)，最后再次运行模拟几次迭代。</p><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lx"><img src="../Images/f7cd6f92f233c915d81ce60d9b264855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4CVqRrfeVdFx9Eaa7g--w.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图6:多重网格垂直循环</figcaption></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es ly"><img src="../Images/8f75345e5027cadd43c6661c1fdb3838.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*smxhedHLSHFeZ_lNSo35QA.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">图7:单一网格(左)和多重网格(右)的模拟结果</figcaption></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div role="button" tabindex="0" class="jx jy di jz bf ka"><div class="er es lz"><img src="../Images/51005198c9c34c699b08da61362de7b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fFu_YfBp6llk2M-ysngwAw.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">表2:模拟结果</figcaption></figure><p id="1b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从表2中看到，模拟运行时间是如何减少的。在本文中，我们看到了如何使用计算思维来加速计算运行时间，同时我们也看到了求解微分方程的多重网格方法的工作原理。</p><p id="d92d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章的灵感来自麻省理工学院的计算思维课程。</p><p id="20e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你更有兴趣看看详细的代码，请到我的GitHub <a class="ae ma" href="https://github.com/sanghvirajit19/Laplacian_Problem/tree/working" rel="noopener ugc nofollow" target="_blank">上查看https://GitHub . com/sanghvirajit 19/Laplacian _ Problem/tree/working</a></p><h1 id="b4d1" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">结论</strong></h1><p id="4262" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">因此，作为计算思想家，我们掌握着如何通过使用较少的计算资源来解决任何复杂的问题，从而获得最佳结果。</p><h1 id="5cc6" class="kh ki hi bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated"><strong class="ak">参考</strong></h1><p id="0eb2" class="pw-post-body-paragraph if ig hi ih b ii lf ik il im lg io ip iq lh is it iu li iw ix iy lj ja jb jc hb bi translated">[1] <a class="ae ma" href="https://computationalthinking.mit.edu/Fall20/lecture18/" rel="noopener ugc nofollow" target="_blank">第18讲——分层思维、贪婪算法、雅可比方法和多重网格</a></p></div></div>    
</body>
</html>