<html>
<head>
<title>How to Build a Visual Search Engine</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何构建可视化搜索引擎</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-a-visual-search-engine-64046e58ad2f?source=collection_archive---------10-----------------------#2021-06-24">https://medium.com/analytics-vidhya/how-to-build-a-visual-search-engine-64046e58ad2f?source=collection_archive---------10-----------------------#2021-06-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/577f1de05f13f323ecdb92fd3c302596.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atABDNgAUi9UEWPtITFnAA.jpeg"/></div></div></figure><h1 id="d14f" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="fd0e" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">视觉搜索是一种相似性搜索，其中要搜索的实体是图像或图像中的对象。常见的用例包括在购物网站上搜索类似的产品，以及搜索罕见的场景来训练自动驾驶汽车。使视觉搜索变得困难和活跃的研究领域是，用户通常对结果的视觉相似性不感兴趣，而是对语义相似性感兴趣。这意味着，如果我搜索一只狗的图像，我希望我的结果是狗的其他图像，而不是具有相同颜色的最多像素的图像。</p><h1 id="66a4" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">视觉搜索如何工作</h1><p id="8bc0" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了建立一个可视化的搜索引擎，我们必须首先建立一个索引。索引是搜索引擎用来将搜索查询映射到搜索结果的数据结构。搜索引擎将遍历该索引以找到与搜索查询最相似的结果。</p><p id="39db" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">由于视觉搜索是一种相似性搜索，我们必须定义如何在感兴趣的对象(在这种情况下是图像)之间测量相似性。我们通过将图像转换为代表不同特征的数值向量来实现这一点，称为嵌入向量。这通常是使用启发式或使用计算机视觉的特征提取模型来完成的。相似性可以定义为这些嵌入向量之间的内积。</p><p id="f7d6" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在搜索时，搜索引擎将种子图像转换成嵌入向量，并且它遍历索引以寻找最相似的其他嵌入向量(即，与种子的嵌入向量的最大内积)。精确搜索随着索引中实体数量的增加而线性增加，这对于要搜索数十亿个实体的可视化搜索问题来说是不可扩展的。因此，我们将重点关注<strong class="jp hi">近似最近邻搜索(ANNS) </strong>，这提供了延迟和准确性的良好权衡。</p><p id="09bd" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">构建一个可视化搜索引擎涉及几个组件，我们将在接下来的章节中详细介绍每个组件:</p><ol class=""><li id="cef4" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">嵌入提取</li><li id="d164" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">索引工作流</li><li id="14d2" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">搜索服务</li></ol><h1 id="0b1a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">嵌入提取</h1><p id="bda2" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">想象一个D维空间，其中每个维度都表示可以从图像中提取的特征，例如直线的存在或白色像素的数量。一幅图像可以表示为这个D维空间上的一个点，这个空间上两点之间的距离可以解释为两幅图像有多相似(或者有多不同)。这个D维空间称为<strong class="jp hi">嵌入空间</strong>，嵌入空间上各点坐标的D维向量称为<strong class="jp hi">嵌入向量</strong>。</p><p id="c234" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">视觉搜索的质量很大程度上取决于如何从图像中提取嵌入内容。提取这些嵌入的一种方式是通过手动定义试探法，这对于特定领域的视觉搜索可能是可行的，但是随着时间的推移很难概括和改进。一种更具可扩展性的方法是使用计算机视觉模型进行嵌入提取。卷积神经网络(CNN)可以用于从图像中提取特征，并且任何给定层的节点都可以被解释为图像的嵌入向量。该CNN模型也可以容易地从预先训练的模型中获得，例如对象分类模型或对象检测模型。</p><p id="6ef5" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">以用于对象分类的CNN模型为例，该CNN模型的最后一层采用表示图像的数值向量，并为其分配类别。这意味着这个向量包含了足够的关于它所代表的底层图像的信息，从而能够判断出它是什么类型的对象。如果我们通过这个CNN模型馈送一个图像，那么我们就可以把层的向量作为这个图像的嵌入向量。这种简单的方法对于通常寻找某一类对象的搜索问题是有效的(例如，从一堆水果图像中搜索苹果)，但是需要做更多的工作来为更细粒度的问题训练更好的嵌入模型(例如，搜索特定风格的椅子)。</p><h1 id="6185" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">索引工作流</h1><p id="96ce" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">为了构建一个可视化的搜索引擎，我们需要一个图像索引来进行搜索，因此我们需要一个将图像插入到可搜索索引中的工作流。该工作流程通常包括以下步骤:</p><ol class=""><li id="9799" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">查找要索引的图像</li><li id="d7ac" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">预处理图像</li><li id="e74c" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">从图像中提取嵌入内容</li><li id="f8bb" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">压缩嵌入</li><li id="3c4a" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">将嵌入插入到索引中</li></ol><h2 id="995a" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">查找要索引的图像</h2><p id="2d7f" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">搜索索引中包含哪些图片很大程度上取决于我们试图通过视觉搜索解决的问题。以自动驾驶用例为例，我们可以使用视觉搜索来找到罕见的场景，以便标记它们并训练更好的感知模型。在这种情况下，我们希望索引道路上的对象图像，比如不同类型的车辆、行人和交通标志。</p><p id="e5b7" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们可以通过自动驾驶汽车上的摄像头获取图像，但这些图像可能不适合索引，因为单个摄像头图像中包含了太多的信息。相反，我们想要做的是从这些图像中提取单个对象的图像碎片，我们可以使用对象检测模型来实现这一点。我们甚至可以通过对象检测模型分配的类别来进一步过滤这些对象，这有助于减少搜索结果中的噪声并提高精确度。</p><h2 id="d377" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">预处理图像</h2><p id="daec" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">如有必要，应对图像进行预处理，以符合嵌入提取模型的输入要求。这可能包括图像大小调整、颜色校正、几何变换等。这一步的计算量可能非常大，因此应该尽可能避免。</p><h2 id="09a8" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">从图像中提取嵌入内容</h2><p id="6745" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这个步骤使用上一节中描述的嵌入提取方法。目标是从输入图像中提取嵌入向量，以便我们可以将它们存储在索引中，而不是存储图像本身。</p><h2 id="84e9" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">压缩嵌入</h2><p id="d795" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">就搜索时间和存储空间而言，通过嵌入向量的索引进行搜索是昂贵的。通常将嵌入向量压缩到更紧凑的数据结构中，这样可以将更多的实体放入内存中，从而加快搜索速度。压缩嵌入有两种常见的方法:基于二进制的和基于PQ的。这两种方法是互补的:基于二进制的压缩在计算距离上更快，而基于PQ的压缩实现了更高的精度。</p><p id="e1eb" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">基于二进制的压缩</strong>将嵌入向量转换成二进制字符串。保证两个二进制字符串之间的汉明距离是原始嵌入向量之间距离的单调函数。换句话说，基于二进制的转换保留了索引中实体之间的相对距离。</p><p id="8171" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi">乘积量化(PQ) </strong>是一种将嵌入向量压缩成短码的方法，称为PQ码，搜索是在这个码上进行的，而不是在原始嵌入向量上。这带来了一些好处:</p><ol class=""><li id="c43e" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">一个大得多的索引现在可以放入内存中(大约10亿个实体)</li><li id="6599" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">嵌入向量和PQ码之间的距离计算比两个嵌入向量之间的距离计算更有效。它仍然是两个原始嵌入向量之间的欧几里德距离的良好估计。</li><li id="5697" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">它与其他索引数据结构配合得很好，我们将在下面讨论。</li></ol><p id="c327" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">PQ的工作方式如下:</p><ol class=""><li id="7fc0" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">对于每个要索引的<em class="ls"> N </em>个实体，将其<em class="ls"> D </em>维嵌入向量切割成<em class="ls"> M </em>个子向量</li><li id="8b16" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">对于<em class="ls"> {1，…，M} </em>中的每一个<em class="ls"> m </em>，对每个实体的第<em class="ls">M</em>子向量对应的所有<em class="ls"> N </em>子向量进行k-means聚类</li><li id="60df" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">每个子向量被给予一个对应于最近簇的整数标识符，并且对于每个嵌入向量，这些标识符被连接，从而将每个嵌入向量编码为一个<em class="ls"> M </em>维向量</li></ol><p id="a8f7" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">子向量的聚类平均值到它们的标识符的映射被称为<strong class="jp hi">码本</strong>。</p><h2 id="0ea9" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">将嵌入插入到索引中</h2><p id="9497" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">索引是一个可搜索的数据结构，它包含了可以作为搜索结果返回的每个实体的嵌入。代替嵌入，PQ代码也可以被插入到这个数据结构中，以减少运行搜索服务的等待时间和存储需求。</p><p id="0f66" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><strong class="jp hi"> k维树(k-d tree) </strong>是一棵二叉树，其中每个节点都是k维空间中的一个点。整个k维空间被树的每个非叶节点迭代分裂，将其分成越来越小的子空间。整组点同时被插入到树中，并且分裂被选择为k维空间中特定轴上的点的中值。在搜索时，遍历k-d树以找到代表包含查询的子空间的叶节点，并且进一步反向递归遍历该树以通过搜索附近的子空间来找到查询的<em class="ls"> K </em>个最近邻居。</p><p id="d680" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">K-d树是一种精确的最近邻搜索算法，在嵌入空间维数较低时表现良好。然而，当嵌入空间维数较高时，其搜索复杂度随着实体数量的增加而线性增加。</p><p id="0cd1" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">人工神经网络的当前技术水平使用一种被称为<strong class="jp hi">可导航小世界</strong>的图形数据结构。这是一个图，其中顶点是存储的实体，边是相似实体之间的链接。插入索引和运行搜索查询是几乎相同的过程:两者都使用相同的方法来查找实体的最近邻居，前者向图中添加新的顶点，并添加边来将其连接到其最近的邻居。插入和搜索都可以并行化，数据结构可以分布。</p><p id="a42a" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">可导航小世界的插入和搜索算法工作如下:</p><ol class=""><li id="024c" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk kv kw kx ky bi translated">从任意顶点开始</li><li id="d5fa" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">使用贪婪搜索算法遍历图，到达最接近查询的邻居，当节点比其任何邻居都更接近查询时停止</li><li id="ec4e" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">重复这个<em class="ls"> K </em>次，每次选择一个随机的起点，并且只选择以前没有被访问过的节点</li><li id="16d7" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">既然找到了一组<em class="ls"> K </em>最近邻居，继续迭代并用新找到的最近邻居替换最远的<em class="ls"> K </em>节点</li><li id="1d65" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">当在一次迭代中不能改进K个节点时停止</li><li id="66e7" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk kv kw kx ky bi translated">在搜索时，只需返回最近的邻居。在插入时，将查询节点添加到图中，并将来自该节点的边添加到第<em class="ls"> K个</em>最近邻居</li></ol><h1 id="8284" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">搜索服务</h1><h2 id="bdc8" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">搜索算法</h2><p id="5b27" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">由于带有倒排索引的产品量化是人工神经网络的当前技术水平，我们将在这里集中讨论它。在搜索时，查询图像的嵌入向量和索引中的PQ代码之间的距离可以使用<strong class="jp hi">不对称距离计算(ADC) </strong>来有效地计算，该距离近似于嵌入向量之间的距离。这种方法仍然使用线性扫描，因此它不能很好地适应大索引。</p><p id="3848" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">为了处理更大的(十亿级)索引，通常使用带有倒排索引的搜索系统。在索引时，将<em class="ls"> N </em>个实体放入<em class="ls"> J </em>个桶中，并为每个桶计算一个代表向量。我们实际上可以对每个嵌入向量和其对应的代表向量之间的残差向量执行PQ，而不是对每个嵌入向量执行PQ。</p><p id="e828" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在搜索时，我们在称为<strong class="jp hi">粗量化</strong>的过程中为查询向量选择最近的桶，然后我们使用ADC执行距离计算。因为我们只需要在选择桶中搜索PQ代码，所以我们确保搜索时间不会随着索引中实体数量的增加而线性增加。</p><p id="42c2" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">使用这种称为<strong class="jp hi">倒排文件系统和非对称距离计算(IVFADC) </strong>的方法，对于十亿个索引大小，可以实现10-100毫秒的搜索时间。</p><h2 id="598c" class="le iq hh bd ir lf lg lh iv li lj lk iz jy ll lm jd kc ln lo jh kg lp lq jl lr bi translated">服务基础设施</h2><p id="a299" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">可视搜索服务可以部署为简单的web服务，使用单个API端点来执行搜索。对此端点的请求需要提供一个或多个种子图像和边界框，以及用于搜索的任何定制配置。要考虑的一些基础设施问题包括:</p><ul class=""><li id="e897" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk lt kw kx ky bi translated">索引的内存约束和加载时间</li><li id="818d" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk lt kw kx ky bi translated">图像的预处理和后处理</li><li id="ef70" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk lt kw kx ky bi translated">索引中实体数量的可伸缩性</li><li id="b7bf" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk lt kw kx ky bi translated">返回结果数量方面的可伸缩性</li></ul><h1 id="3e37" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">进一步阅读</h1><p id="1482" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">视觉搜索是一个广阔的领域，有很多活跃的研究正在进行。从用于计算嵌入的计算机视觉算法到用于搜索索引的人工神经网络算法，技术水平在不断发展。本文试图涵盖构建可视化搜索引擎方面的所有内容，但它并不是所有方法的详尽指南。为了更深入地了解视觉搜索，我鼓励您阅读以下领域的一些研究论文:</p><ul class=""><li id="95a4" class="kq kr hh jp b jq kl ju km jy ks kc kt kg ku kk lt kw kx ky bi translated">计算机视觉(尤其是物体检测)</li><li id="1c3d" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk lt kw kx ky bi translated">神经网络嵌入</li><li id="681a" class="kq kr hh jp b jq kz ju la jy lb kc lc kg ld kk lt kw kx ky bi translated">近似最近邻搜索</li></ul></div></div>    
</body>
</html>