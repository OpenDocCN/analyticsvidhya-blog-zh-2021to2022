<html>
<head>
<title>Multilevel thresholding for image segmentation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">图像分割的多阈值方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multilevel-thresholding-for-image-segmentation-d5805ad596b7?source=collection_archive---------6-----------------------#2021-09-07">https://medium.com/analytics-vidhya/multilevel-thresholding-for-image-segmentation-d5805ad596b7?source=collection_archive---------6-----------------------#2021-09-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/d0669a44de39476abe9ae89e9db66c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*eQz9o4eKEh3wfqEZjr6LuQ.jpeg"/></div></figure><p id="3412" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">根据图像分割的数量，阈值分割技术可以分为二级和多级两类。在二值阈值分割中，图像被分割成两个不同的区域。灰度值大于某个值T的像素被分类为目标像素，而灰度值小于T的其他像素被分类为背景像素。</p><p id="4b03" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">多阈值分割是将灰度图像分割成几个不同区域的过程。这种技术为给定的图像确定一个以上的阈值，并将图像分割成对应于一个背景和几个对象的特定亮度区域。该方法对于具有彩色或复杂背景的对象非常有效，在这些对象上，二级阈值化不能产生令人满意的结果。</p></div><div class="ab cl jk jl gp jm" role="separator"><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp jq"/><span class="jn bw bk jo jp"/></div><div class="hb hc hd he hf"><p id="628b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">全文可以在<a class="ae jr" href="https://people.ece.cornell.edu/acharya/papers/mlt_thr_img.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在这里，作者使用图像的均值和方差来寻找将图像分割成多个层次的最佳阈值。该算法被递归地应用于根据前一步骤计算的子范围，以便为下一步骤找到阈值和新的子范围。</p><p id="843b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">下面给出了上述n阈值方法的Python (&gt;3.0)代码:</p><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="5c66" class="kb kc hi jx b fi kd ke l kf kg">import cv2<br/>import numpy as np<br/>import math<br/><br/>img = cv2.imread('path-to-image')<br/>img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br/>a = 0<br/>b = 255<br/>n = 6 # number of thresholds (better choose even value)<br/>k = 0.7 # free variable to take any positive value<br/>T = [] # list which will contain 'n' thresholds<br/><br/>def multiThresh(img, a, b):<br/>    if a&gt;b:<br/>        s=-1<br/>        m=-1<br/>        return m,s<br/><br/>    img = np.array(img)<br/>    t1 = (img&gt;=a)<br/>    t2 = (img&lt;=b)<br/>    X = np.multiply(t1,t2)<br/>    Y = np.multiply(img,X)<br/>    s = np.sum(X)<br/>    m = np.sum(Y)/s<br/>    return m,s<br/><br/>for i in range(int(n/2-1)):<br/>    img = np.array(img)<br/>    t1 = (img&gt;=a)<br/>    t2 = (img&lt;=b)<br/>    X = np.multiply(t1,t2)<br/>    Y = np.multiply(img,X)<br/>    mu = np.sum(Y)/np.sum(X)<br/><br/>    Z = Y - mu<br/>    Z = np.multiply(Z,X)<br/>    W = np.multiply(Z,Z)<br/>    sigma = math.sqrt(np.sum(W)/np.sum(X))<br/><br/>    T1 = mu - k*sigma<br/>    T2 = mu + k*sigma<br/><br/>    x, y = multiThresh(img, a, T1)<br/>    w, z = multiThresh(img, T2, b)<br/><br/>    T.append(x)<br/>    T.append(w)<br/><br/>    a = T1+1<br/>    b = T2-1<br/>    k = k*(i+1)<br/><br/>T1 = mu<br/>T2 = mu+1<br/>x, y = multiThresh(img, a, T1)<br/>w, z = multiThresh(img, T2, b)    <br/>T.append(x)<br/>T.append(w)<br/>T.sort()<br/>print(T)</span></pre><p id="29f3" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">你可以通过scikit-image library找到另一种方法，<a class="ae jr" href="https://scikit-image.org/docs/dev/auto_examples/segmentation/plot_multiotsu.html" rel="noopener ugc nofollow" target="_blank">多Otsu阈值法</a>。还有其他几种方法。谢谢大家！！！</p></div></div>    
</body>
</html>