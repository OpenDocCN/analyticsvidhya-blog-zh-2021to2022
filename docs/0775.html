<html>
<head>
<title>Deep Dive into Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深入研究逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-dive-into-logistic-regression-26a495baa0de?source=collection_archive---------18-----------------------#2021-01-30">https://medium.com/analytics-vidhya/deep-dive-into-logistic-regression-26a495baa0de?source=collection_archive---------18-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="a57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">读者警告:伙计们，请坐好，因为这将是一篇涵盖逻辑回归所有本质细节的长篇综合文章。</p><p id="eea0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将首先讨论所需的所有要素，然后看看这些要素是如何组合起来准备一个令人敬畏的算法的。</p><p id="ce27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，不浪费任何时间，让我们开始我们的文章。</p><p id="210c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">什么时候使用逻辑回归？</strong></p><p id="13f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你们一定听说过经典的机器学习问题，比如猫和狗，贝宁病毒和恶性肿瘤，或者基本上，我们可以说，我们需要在两个类别之间进行分类，即二进制分类问题，其中输出类别属于0或1。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3f2fc64af25b667c4163820f425ae438.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bY28AO25KKL3Rt388dOIOA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">识别猫和狗(图1)</figcaption></figure><h2 id="50d6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd iq ke kf kg iu kh ki kj iy kk kl km kn bi translated">数学课</h2><p id="d70b" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">为了便于理解逻辑回归。我们将获取一个包含一个要素和两个输出类的数据集。一般的等式是</p><p id="36c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="kt"> z = w.x + b，其中w为权重，x为特征，b为偏项。</em></p><p id="760a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们用w和b的任意值求解上述方程时，它应该给出我们的类输出。但是上面的等式有一个小问题。二进制分类中的类标签可以是0，也可以是1，但是上面的等式可以给我们任何实数。但是，别担心，我们有解决这个问题的办法。</p><p id="775d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">乙状结肠功能拯救</strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ku"><img src="../Images/269f88b55ca3ac6a9cd150ab4bb88310.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*arc2k1bBbxesOfu4PV1WwQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Sigmoid函数(图2)</figcaption></figure><p id="05f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们来讨论一下sigmoid函数。sigmoid函数将任何实数作为输入，并将0到1之间的值作为输出。这些值可以被视为概率。正如您在sigmoid图中看到的，x-&gt;∞，y-&gt;1的值和x-&gt; -∞，y-&gt; 0的值。因此，y的值保持在0和1之间。当z为零时，s形图在0.5处切割y轴。</p><p id="2087" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么，我们如何在逻辑回归中使用它呢？实际上，正是乙状结肠给了逻辑回归这个名字。等式z= w.x +b给出的输出可以是任何实数，现在如果我们将z传递给sigmoid函数，我们将得到0到1之间的输出，这是我们的类概率。</p><p id="9918" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">成本函数</strong></p><p id="e9a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们已经有了方程，但是我们如何知道我们的方程是否如预期的那样工作。为此，我们需要一种机制来计算实际y值和预测y值有多接近。成本函数有助于估计这种差异。我们将使用的成本函数是对数损失函数</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/144ffb7f12fbdd1c4259729e2e32dec0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90qLt3vge7Vojf9DTeGcLA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">对数损失函数(图3)</figcaption></figure><p id="d29a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的损失函数中，<em class="kt"> y </em>代表实际值，<em class="kt"> p </em>代表我们假设方程中的预测值或输出值(z)。</p><p id="a943" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们将试着把上面的等式分解成两部分来解释。</p><p id="164e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当实际标签(y)为零时，成本函数变成-log(1-p)并且-log(1-p)的图形是</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kw"><img src="../Images/2f2ad022e640d5930b5bc2a8c0896cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/1*gcwpvC_DRdMATufoTJHP9w.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">对数图(1-p)。y轴上的成本函数和x轴上的假设</figcaption></figure><p id="1e04" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上图中可以看出，如果p(或假设等式中的z)的值给出的输出为零，则误差为零(因为实际值和预测值相同)，如果预测值为1，则给出的实际值为0。成本函数上升到一个大值。</p><p id="e599" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">给你做个小作业</strong>:试着画出y=1时的代价函数对数图，推导出你的结论。</p><p id="11c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你们中的一些人一定在想，为什么我们不使用均方差函数，这背后有一个合理的原因，我们将在下一部分讨论。</p><p id="1bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们有了成本函数，但现在我们需要一种机制来以某种方式降低成本函数值，为此，我们需要在等式中找到“w”和“b”的优化值，这将为我们提供最准确的预测。</p><p id="78aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们如何找到“w”和“b”的最优值。我们的数学研究人员早就找到了解决方法。</p><p id="b5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用梯度下降进行优化</strong></p><p id="88aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度下降是机器学习领域中最重要的算法之一。梯度下降将帮助我们找到“w”和“b”的值，这样我们的成本函数值变得最小，我们将借助图表来查看这一点</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kx"><img src="../Images/e2df0fb50374151a2a41e470416dc553.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*9POvY_ejs5Vjiz5j-I0MpA.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">我们的参数w和b的成本函数图(图4)</figcaption></figure><p id="3e66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单回顾一下，我们之前讨论过，我们不会使用均方误差进行逻辑回归，原因是它不会给出如上所述的碗形或凸形图形。这个图的好处是只有一个全局极小值(底部红点)，没有局部极小值，所以不管我们的w和b的初始值是什么，都会收敛到全局极小点。</p><p id="26b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">梯度下降方程给出如下</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/24ea5e5c33b05941b53e2b9dc84fe05c.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*PGzygNav4Klv_WSxsXFLDA.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">参数Qj的梯度下降方程(图5)</figcaption></figure><p id="6f1c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来理解这个等式</p><ol class=""><li id="86a3" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">Qj代表我们假设中的任何参数。在我们的例子中，我们有“w”和“b”</li><li id="dca4" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated"><strong class="ih hj"> α </strong>代表学习率，即您希望更新参数的快慢。</li><li id="7ac6" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">∂J(Q)/∂Qj导数是为了发现当我们稍微改变我们的参数时，成本函数是如何变化的(也称为该点切线的斜率)。</li></ol><p id="e2c4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们看看为什么梯度下降有效</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ln"><img src="../Images/c3efa502304c73c68cfcde18f7c76010.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AZzu43KoxDamVpWMVW0zfw.png"/></div></div></figure><p id="56e1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来理解上面的图表。假设我们计算梯度，结果是正的。现在，在我们的梯度下降方程中(参见图5)，如果梯度为正，那么Q值(这里是w，将减少或移动到较小的正值)，反之亦然。用纸和笔检查一下，试着解决这个问题。</p><p id="a045" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们介绍了所有的配料。让我们现在准备食谱。</p><ol class=""><li id="e730" class="kz la hi ih b ii ij im in iq lb iu lc iy ld jc le lf lg lh bi translated">首先，我们将看看问题是否是二进制分类。如果是，那么我们知道我们可以使用逻辑回归。</li><li id="ca18" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">我们将决定一个假设，即z = w*x+b</li><li id="ec61" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">现在，我们将使用sigmoid激活函数，并将z传递给它，以获得{0，1}范围内的输出</li><li id="c0fb" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">我们现在定义我们的成本函数，在我们的例子中是对数损失。</li><li id="35d7" class="kz la hi ih b ii li im lj iq lk iu ll iy lm jc le lf lg lh bi translated">最后，我们将使用我们的梯度下降算法，并继续迭代，直到我们得到w和b的值，使损失最小。</li></ol><p id="25d1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，我们准备好了逻辑回归的方法。幕后有很多数学计算超出了本文的范围。如果你想了解更多，你可以看看计算图是如何在梯度下降中使用的，或者微积分是如何在我们的算法中计算梯度的。</p><p id="c055" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想用代码弄脏你的手，你可以参考我在github上的代码，我在里面从零开始实现了逻辑回归。</p><div class="lo lp ez fb lq lr"><a href="https://github.com/iamarpan/logistic_regression2" rel="noopener  ugc nofollow" target="_blank"><div class="ls ab dw"><div class="lt ab lu cl cj lv"><h2 class="bd hj fi z dy lw ea eb lx ed ef hh bi translated">iamarpan/logistic_regression2</h2><div class="ly l"><h3 class="bd b fi z dy lw ea eb lx ed ef dx translated">逻辑回归的改进实现。为iamarpan/logistic_regression2开发做出贡献，创建一个…</h3></div><div class="lz l"><p class="bd b fp z dy lw ea eb lx ed ef dx translated">github.com</p></div></div><div class="ma l"><div class="mb l mc md me ma mf jn lr"/></div></div></a></div></div></div>    
</body>
</html>