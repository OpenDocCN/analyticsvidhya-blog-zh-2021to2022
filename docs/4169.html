<html>
<head>
<title>Fundamentals of MLOps — Part 2 | Data &amp; Model Management with DVC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MLOps基础知识—第2部分| Data数据和模型管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4?source=collection_archive---------3-----------------------#2021-09-05">https://medium.com/analytics-vidhya/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4?source=collection_archive---------3-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b3c855d69b97a0a3c25faccc2472575e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dn8xbG6VO1DxgevlK3z6Jg.png"/></div></div></figure><p id="ee52" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这个由4篇博客组成的系列文章的第1部分<a class="ae jo" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8">中，我们了解了采用MLOps实践背后的动机&amp;也了解了MLOps的一些基本原则。我们还浏览了用于在ML工作流生命周期的不同阶段实现MLOps的工具库&amp;框架。从这个博客开始，我们将更深入地研究这些工具&amp;学习如何在我们自己的项目中实际使用它们，以获得更好的可重复性&amp;协作。</a></p><h1 id="671a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">内容</h1><ul class=""><li id="4921" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated">ML项目中的版本控制</li><li id="f176" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">什么是数据版本控制(DVC)？</li><li id="f6e5" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">探索DVC的基本功能</li><li id="d00d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">初始化</li><li id="9173" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">使用DVC跟踪文件</li><li id="3b79" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">远程存储数据</li><li id="ab3a" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">检索远程存储的数据</li><li id="1fde" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">对数据进行修改</li><li id="7d65" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在数据版本之间切换</li><li id="04ae" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">访问DVC追踪的数据</li><li id="908b" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">DVC Python API</li><li id="0773" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在共享服务器上使用DVC</li><li id="755d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">结束语</li><li id="0036" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">附加参考</li></ul><h1 id="47d9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">ML项目中的版本控制</h1><p id="7530" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">软件开发包括记录和维护源代码、修改源代码和与其他开发人员合作的连续过程；版本控制系统(如Git &amp; Mercurial)使这项任务变得更加容易。类似地，在ML和数据科学中，创建ML模型并将其部署到生产中是一个迭代的过程，需要大量的版本控制来维护和再现。这样的项目与通常的软件开发项目形成了鲜明的对比，因为ML需要代码和数据——因此，这里的版本控制不限于代码，还涉及数据、超参数和其他元数据的版本控制。</p><p id="feb6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们都熟悉<a class="ae jo" href="https://git-scm.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> <em class="lg"> Git </em> </strong> </a>作为一种众所周知的&amp;有用的版本控制工具，广泛应用于软件开发中。那么，尽管它是版本控制的圣杯，为什么只使用<em class="lg">的</em> Git用于版本控制ML项目是不可取的(或者说是没有效率的)？</p><ul class=""><li id="5882" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated">ML/DL项目通常涉及大量数据，达到数百MB(有时也有数GB和数TB)，而Git允许推入GitHub repo的文件大小上限仅为<strong class="is hj"> <em class="lg"> 100MB </em> </strong>。<em class="lg">注意，解决方案像</em><code class="du lk ll lm ln b"><em class="lg">git-lfs</em></code><em class="lg"/><a class="ae jo" href="https://git-lfs.github.com/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj"><em class="lg">(Git大文件存储)</em> </strong> </a> <em class="lg">避免了这样的问题，但是它们不够灵活。</em></li><li id="806e" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在组织中的人之间的协作期间，可能需要将对数据(或管道的某个其他部分)的访问仅限于某一组人。如果数据与GitHub repo中的其他代码一起被直接跟踪，可能很难提供这种不同级别的访问。</li><li id="cae8" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">此外，用于训练模型的实际数据可能已经远程存在于一些存储服务中(如亚马逊S3、Azure Blob存储等)。)&amp;将所有这些数据复制到GitHub repo中并单独跟踪是一种浪费。</li></ul><p id="f2bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些都需要一些特定的工具和框架来解决ML工件的版本化问题，如数据、超参数和模型，它们与现有的版本控制工具一起工作，为ML项目管理提供无缝的体验。<em class="lg">进入</em> <strong class="is hj"> <em class="lg">数据版本控制！</em> </strong></p><h2 id="c66e" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">为什么数据和模型会改变？</h2><p id="56dc" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在深入研究数据版本控制之前，我们将首先尝试列举一些关于ML系统中数据和模型为什么会改变的原因:</p><ul class=""><li id="2681" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated">数据可以跨多个平台传播</li><li id="d9ff" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">数据可能会频繁变化，需要定期更新我们的模型才能运行良好<em class="lg">(想想构建推荐系统的点击率数据)</em></li><li id="d28b" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">模型可以用这些新数据重新训练&amp;也许是更新的训练技术</li><li id="5308" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">模型可能会随着时间而退化</li><li id="fd35" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">表现不佳的模型可以迅速恢复到较早的服务版本</li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="0dd2" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">什么是<a class="ae jo" href="https://dvc.org/" rel="noopener ugc nofollow" target="_blank">数据版本控制(DVC) </a>？</h1><p id="97ff" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">数据版本控制<em class="lg">(概念，不是具体工具！)</em>是一个工具和程序的集合，试图使版本控制过程适应数据世界。帮助数据科学家管理他们的数据和模型并运行可重复实验的工具之一是<strong class="is hj"> DVC </strong>或<strong class="is hj">数据版本控制</strong>。</p><blockquote class="mo mp mq"><p id="6da7" class="iq ir lg is b it iu iv iw ix iy iz ja mr jc jd je ms jg jh ji mt jk jl jm jn hb bi translated">DVC，由<a class="ae jo" href="https://iterative.ai/" rel="noopener ugc nofollow" target="_blank">迭代开发。AI </a>是一个用Python编写的开源命令行工具，用于数据科学&amp; ML项目管理&amp;版本控制。为了利用大多数开发人员熟悉的现有工具集，它模拟了Git命令和工作流，以便他们可以快速将其集成到他们通常的Git实践中。</p></blockquote><p id="f21b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">DVC使用远程存储库(包括支持所有主要的云提供商)来存储项目的所有数据和模型。在实际的代码存储库中，存储了一个指向这个远程位置的指针，以访问实际的工件。</p><h2 id="8d5c" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">DVC的特色</h2><p id="c880" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">使用DVC可以为您现有的数据科学工作流带来敏捷性、可再现性和协作性。DVC的一些核心特征是:</p><ul class=""><li id="e544" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated"><strong class="is hj"> Git兼容:</strong>它运行在任何Git存储库之上，并且兼容任何标准的Git服务器或提供商(GitHub、GitLab等)。)</li><li id="b247" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">简单化的数据版本化:</strong>通过替换大文件、数据集目录、ML模型等来维护多个版本的数据&amp;模型。带有包含指向原始数据的指针的小元文件(作为占位符)</li><li id="f54a" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">存储无关:</strong>它可以使用<a class="ae jo" href="https://aws.amazon.com/s3/" rel="noopener ugc nofollow" target="_blank">亚马逊S3 </a>、<a class="ae jo" href="https://azure.microsoft.com/en-in/services/storage/blobs/" rel="noopener ugc nofollow" target="_blank">微软Azure Blob存储</a>、<a class="ae jo" href="https://www.google.com/intl/en_in/drive/" rel="noopener ugc nofollow" target="_blank"> Google Drive </a>、<a class="ae jo" href="https://cloud.google.com/storage" rel="noopener ugc nofollow" target="_blank">谷歌云存储</a>、<a class="ae jo" href="https://www.alibabacloud.com/product/oss" rel="noopener ugc nofollow" target="_blank">阿里云OSS </a>、SSH/SFTP、HDFS、HTTP、附网存储或磁盘作为远程存储数据</li><li id="4467" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">可复制:</strong>它通过使用隐式依赖图创建轻量级管道，并通过编码所涉及的数据和工件，使得ML项目可复制</li><li id="94cc" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">语言- &amp;框架无关:</strong>它独立于项目中使用的编程语言(Python、R、Julia、shell脚本等等)或机器学习库(Keras、Tensorflow、PyTorch、Scipy等等)</li><li id="b49d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><strong class="is hj">低摩擦分支:</strong>它支持即时Git分支，即使是大文件&amp;也能防止实验间的数据重复</li><li id="b559" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">易于使用:安装速度快，不需要特殊的基础设施</li></ul><p id="6805" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lg">注:</em></strong><em class="lg"/><strong class="is hj"><em class="lg">DVC不代替饭桶！</em> </strong> <em class="lg">远程保存原始数据和模型引用的元文件在项目过程中会随着数据的变化而变化&amp;需要Git进行版本控制。</em></p><h2 id="7a1d" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">将DVC与其他解决方案进行比较</h2><p id="7c2b" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">除了DVC之外，还有其他几个顶级的数据版本控制工具，可以帮助自动化工作和优化流程。下面是DVC和其他一些工具的快速比较:</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/5af3aaa275885f30f177bd363414432c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*25h3VBKkxM94Ru4G"/></div></div><figcaption class="mz na et er es nb nc bd b be z dx translated"><strong class="bd jr"> <em class="nd">图片来源:</em> </strong> <em class="nd"> </em> <a class="ae jo" href="https://dagshub.com/blog/data-version-control-tools/" rel="noopener ugc nofollow" target="_blank"> <em class="nd">对比数据版本控制工具</em> </a></figcaption></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="40fa" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">探索DVC的基本功能</h1><p id="ab99" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">有了DVC的基本概述，让我们直接使用DVC来开发我们自己的ML项目，以理解它提供的各种功能。在本教程中，我们将学习如何:</p><ul class=""><li id="16c0" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated">安装DVC并初始化项目</li><li id="c16b" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">将文件添加到远程存储库(亚马逊S3)并在以后检索它们</li><li id="8501" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">在不同版本之间切换</li><li id="0fcb" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">从DVC存储库中搜索和导入文件</li></ul><p id="eed3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">稍后，我们还将研究如何使用DVC作为Python包。</p><h2 id="91a7" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">装置</h2><p id="496b" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">DVC可以根据用户的操作系统从其存储库或二进制包中安装，其步骤可以在<a class="ae jo" href="https://dvc.org/doc/install" rel="noopener ugc nofollow" target="_blank">文档</a>中找到。</p><p id="ce3f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然而，由于DVC也可以用作Python库(我们将在后面探讨)，它可以简单地使用像<code class="du lk ll lm ln b">pip</code>或<code class="du lk ll lm ln b">conda</code>这样的包管理器来安装。根据项目中使用的远程存储类型，可能需要安装可选的依赖项。</p><p id="8843" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">使用此类软件包管理器时，建议在安装软件包之前创建&amp;启用虚拟环境。</em></p><p id="ac70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">基于我们首选的软件包管理器，我们将安装DVC(与亚马逊S3远程)如下:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="62a5" class="lo jq hi ln b fi ni nj l nk nl">$ pip install "dvc[s3]"                   # Using pip</span><span id="2490" class="lo jq hi ln b fi nm nj l nk nl">$ conda install -c conda-forge dvc-s3     # Using conda</span></pre><p id="527d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">在这种情况下，它会随DVC一起安装</em> <code class="du lk ll lm ln b"><a class="ae jo" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"><em class="lg">boto3</em></a></code> <em class="lg">库。</em></p><p id="c1aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">请随意查看DVC文档<a class="ae jo" href="https://dvc.org/doc" rel="noopener ugc nofollow" target="_blank">来安装你可能想要使用的其他遥控器的依赖项。</a></p><p id="3aa3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，您可以键入<code class="du lk ll lm ln b">dvc --help</code>来查看所有可以与DVC一起使用的命令。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="5432" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">初始化</h1><p id="e6cf" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">安装DVC后，我们创建一个项目目录&amp;将其初始化为Git repo。创建一个相应的GitHub repo &amp;将其设置为Git repo的<code class="du lk ll lm ln b">origin</code>遥控器。稍后，我们使用<code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/init" rel="noopener ugc nofollow" target="_blank">dvc init</a></code>将其初始化为DVC回购。这是我们的<strong class="is hj"> <em class="lg">工作区</em> </strong>。</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="61b1" class="lo jq hi ln b fi ni nj l nk nl">$ mkdir mlops_dvc<br/>$ cd mlops_dvc</span><span id="b286" class="lo jq hi ln b fi nm nj l nk nl">$ git init<br/>$ git remote add origin &lt;github-repo-link&gt;<br/>$ git branch -M main</span><span id="3120" class="lo jq hi ln b fi nm nj l nk nl">$ dvc init</span></pre><p id="db67" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将创建一个具有下面提到的结构的内部<code class="du lk ll lm ln b">.dvc</code>文件夹，保存DVC操作所需的内部目录和文件。</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="3b0a" class="lo jq hi ln b fi ni nj l nk nl">mlops_dvc<br/>├── .dvc<br/>│   ├── .gitignore<br/>│   ├── config <br/>│   ├── plots  <br/>│   │   ├── confusion.json<br/>│   │   ├── confusion_normalized.json<br/>│   │   ├── default.json<br/>│   │   ├── linear.json<br/>│   │   ├── scatter.json<br/>│   │   └── smooth.json<br/>│   └── tmp<br/>│       ├── links<br/>│       │   └── cache.db<br/>│       └── md5s<br/>│           └── cache.db<br/>├── .dvcignore<br/>└── .git</span></pre><ul class=""><li id="34c3" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">config</code>:配置文件，使用<code class="du lk ll lm ln b">dvc config</code>编辑</li><li id="f146" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">plots/</code>:绘图模板目录</li><li id="e558" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">tmp/</code>:杂项临时文件目录</li><li id="c05b" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">links/</code> : SQLite DB存储从缓存到工作区的文件链接</li><li id="a09d" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">md5s/</code> : SQLite数据库存储被跟踪文件的MD5哈希</li><li id="94f2" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><code class="du lk ll lm ln b">.dvcignore</code>:遍历DVC项目时排除的文件和目录</li></ul><p id="1f2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些包括配置文件、本地缓存、绘图模板和临时文件<a class="ae jo" href="https://dvc.org/doc/user-guide/project-structure/internal-files" rel="noopener ugc nofollow" target="_blank"> <em class="lg">(更多信息)</em> </a> <em class="lg">。</em>它类似于Git repo初始化时创建的<code class="du lk ll lm ln b">.git/</code>文件夹。<code class="du lk ll lm ln b">dvc init</code>命令还创建了一个<code class="du lk ll lm ln b">.dvcignore</code>文件(类似于<code class="du lk ll lm ln b">.gitignore</code>)来包含DVC要忽略的路径列表。</p><p id="136c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们使用<code class="du lk ll lm ln b">git commit -m "Initialize DVC in repo"</code>将这些内部文件提交给Git repo。</p><p id="6d5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从现在开始，我们将创建和管理不同的DVC文件，并在使用DVC和处理ML项目时填充缓存。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="86a1" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">使用DVC跟踪文件</h1><p id="a916" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">一旦我们的DVC回购被初始化，我们就可以开始向我们的Git回购添加数据和代码，正如我们的ML项目所要求的那样。为您的ML项目维护一个好的目录结构来分离数据、代码、模型、度量等是很好的。下面是一个非常通用的目录结构，可以用于大多数ML项目:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="2be3" class="lo jq hi ln b fi ni nj l nk nl">project_dir<br/>├── data/             # Directory with raw and intermediate data<br/>│   └── prepared/     # Processed dataset<br/>├── metrics/          # Plots &amp; logs with performance metrics<br/>├── models/           # Trained models<br/>└── src/              # Files for processing, training, evaluation</span></pre><p id="0870" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lk ll lm ln b">data/</code>目录通常会有文件形式的训练数据(如XML、CSV、TSV等。)或可能非常大的文件夹(如属于不同类别的图像)中。对于本教程，我们将下载<a class="ae jo" href="https://www.kaggle.com/razamh/pubg-dataset" rel="noopener ugc nofollow" target="_blank">这个玩具数据集</a> ( <code class="du lk ll lm ln b">data.csv</code> ) &amp;放在<code class="du lk ll lm ln b">mlops_dvc/data/</code>文件夹中。现在，在终端中键入以下命令来启用对<code class="du lk ll lm ln b">data.csv</code>文件的跟踪:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="81b3" class="lo jq hi ln b fi ni nj l nk nl">$ dvc add data/data.csv     # To start tracking a file or directory</span></pre><p id="fa70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，DVC将有关新添加文件(或目录)的信息保存在一个名为<code class="du lk ll lm ln b">data/data.csv.dvc</code>的特殊<code class="du lk ll lm ln b">.dvc</code>文件中(一个可读格式的小文本文件)。这个元数据文件充当实际数据的占位符，可以很容易地使用Git进行版本控制，就像源代码一样。其内容如下:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="fd45" class="lo jq hi ln b fi ni nj l nk nl">outs:<br/>- md5: 97edcee3524b1675ab68790ad35e80e9<br/>  size: 158375420<br/>  path: data.csv<br/>  isexec: true</span></pre><p id="3e96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">在后台，</em> <code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/add" rel="noopener ugc nofollow" target="_blank"><em class="lg">dvc add</em></a></code> <em class="lg">将数据移动到项目的缓存中，并链接回我们的工作区。您可以验证</em> <code class="du lk ll lm ln b"><em class="lg">.dvc/cache/</em></code> <em class="lg">文件夹包含一个子文件夹</em> <code class="du lk ll lm ln b"><em class="lg">97</em></code> <em class="lg">，有一个名为</em> <code class="du lk ll lm ln b"><em class="lg">edcee3524b1675ab68790ad35e80e9</em></code> <em class="lg">的文件。我们刚刚添加的</em> <code class="du lk ll lm ln b"><em class="lg">data.csv</em></code> <em class="lg">文件(</em> <code class="du lk ll lm ln b"><em class="lg">97ecdce...</em></code> <em class="lg">)的</em> <a class="ae jo" href="https://en.wikipedia.org/wiki/MD5" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> MD5哈希值</em> </a> <em class="lg">决定了这个缓存路径。</em></p><p id="39b0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们使用Git跟踪<code class="du lk ll lm ln b">data.csv.dvc</code>文件，而忽略实际的<code class="du lk ll lm ln b">data.csv</code>文件。</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="f6a9" class="lo jq hi ln b fi ni nj l nk nl">$ git add data/data.csv.dvc data/.gitignore  # Adds the actual data/data.csv file to .gitignore so that it is ignored by Git tracking<br/>$ git commit -m "Add raw data"               # Commit the data/data.csv.dvc for Git tracking</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="eaab" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">远程存储数据</h1><p id="42ab" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">一旦使用DVC跟踪数据，就可以安全地远程存储数据(如前所述，DVC支持多种远程存储选项)。</p><h2 id="4245" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">设置亚马逊S3存储桶</h2><p id="5c67" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">由于我们计划将数据存储在亚马逊S3，我们首先必须设置我们的S3存储桶，它将存储我们的数据，如下所示:</p><p id="a398" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤1: </strong>登录您的AWS控制台</p><p id="2901" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二步:</strong>在搜索框中搜索“s3”&amp;选择S3服务</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/a4a0c1b9e693a179f62d2a5b3a1f09d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l9ow9-XxwABGxvYq"/></div></div></figure><p id="bb5e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第3步:</strong>单击S3仪表盘中的“创建时段”</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/ac9685e3ef1a5d609a8e0a8ec2744c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZIZeCNoBaIUaWKSE"/></div></div></figure><p id="a222" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤4: </strong>输入一个存储段名称&amp;选择“亚太(孟买)AP-south-1”AWS区域。例如，我已经将bucket名称设置为<code class="du lk ll lm ln b">mlopsdvc170100035</code>。<em class="lg">(这是因为S3存储桶名称在一个分区-一组区域内必须是唯一的)</em>保留所有其他设置默认&amp;点击“创建存储桶”按钮。</p><p id="2ed5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤5: </strong>现在我们需要创建我们的<em class="lg">访问键</em>，它将使DVC(在我们的本地系统上)能够与Bucket通信。为此，展开您的配置文件名&amp;下的菜单，单击“我的安全凭证”。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/a32949bae2ba8219cdd1aff56c39d72a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ysUoQ4o66pUetxzJ"/></div></div></figure><p id="bb1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤6: </strong>点击“访问密钥(访问密钥ID和秘密访问密钥)”&amp;然后点击“创建新的访问密钥”按钮。这将为您创建一个唯一的访问密钥对。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/9151e420abfc9ab2486cf66301208641.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*d7cQAzDyCvq6Dtqx"/></div></div></figure><p id="d589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你应该下载密钥文件并保存好它，因为这是你唯一一次看到你的<strong class="is hj"> <em class="lg">秘密访问密钥</em> </strong>。</p><p id="3a60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤7: </strong>现在，创建两个名为<code class="du lk ll lm ln b">AWS_ACCESS_KEY_ID</code> &amp; <code class="du lk ll lm ln b">AWS_SECRET_ACCESS_KEY</code>的环境变量，分别包含您的访问密钥&amp;秘密访问密钥，当我们试图从我们的S3桶上传/下载数据时，这些变量将被<code class="du lk ll lm ln b">boto3</code>库获取。同样，创建&amp;将<code class="du lk ll lm ln b">AWS_DEFAULT_REGION</code>变量设置为<code class="du lk ll lm ln b">ap-south-1</code>。<br/> <a class="ae jo" href="https://kb.wisc.edu/cae/page.php?id=24500" rel="noopener ugc nofollow" target="_blank">供Windows用户参考</a> <br/> <a class="ae jo" href="https://phoenixnap.com/kb/linux-set-environment-variable#ftoc-heading-9" rel="noopener ugc nofollow" target="_blank">供Linux用户参考</a></p><p id="d9e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们就建立了我们的AWS凭证&amp; Amazon S3 bucket来使用DVC远程存储我们的数据。</p><h2 id="be2d" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">将数据推送到远程存储</h2><p id="6d48" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">要远程存储DVC跟踪的数据和模型文件，我们首先需要如下配置远程存储位置:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="3ac0" class="lo jq hi ln b fi ni nj l nk nl">$ dvc remote add -d storage s3://mlopsdvc170100035/dvcstore  <br/># Enter your respective bucket name</span><span id="916a" class="lo jq hi ln b fi nm nj l nk nl">$ git add .dvc/config<br/>$ git commit -m "Configure remote storage"</span></pre><p id="30c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一个命令创建一个名为<code class="du lk ll lm ln b">storage</code> &amp;的遥控器，将它链接到我们的S3桶中的一个(新创建的)文件夹<code class="du lk ll lm ln b">dvcstore</code>。<code class="du lk ll lm ln b">-d</code>标志确保该遥控器是用于上传&amp;下载数据的默认遥控器。</p><p id="bf03" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我们将数据推送到远程存储<em class="lg"> ( </em> <code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/push" rel="noopener ugc nofollow" target="_blank"><em class="lg">dvc push</em></a></code> <em class="lg">将本地缓存的数据复制到远程存储)</em> &amp;稍后推送到我们的GitHub repo:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="0bc0" class="lo jq hi ln b fi ni nj l nk nl">$ dvc push<br/>$ git push origin main</span></pre><p id="c33e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成上述步骤后，您可以检查您的亚马逊S3控制台，发现数据已被推送到您的桶中。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/6a2c9264bd065db49f85fc00ac4824d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tIiTD4AzyH-UtCH0"/></div></div></figure><p id="a1b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在检查您的GitHub repo时，您应该注意到<code class="du lk ll lm ln b">data/</code>文件夹只包含<code class="du lk ll lm ln b">.gitignore</code> &amp; <code class="du lk ll lm ln b">data.csv.dvc</code>文件，而实际的<code class="du lk ll lm ln b">data.csv</code>文件并不存储在GitHub上。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nq"><img src="../Images/b879917aeb4d38f92e0d824ab3a39624.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tdAKDzehmPz1nyOj"/></div></div></figure></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="c4ad" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">检索远程存储的数据</h1><p id="54a5" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">根据需要，可使用<code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/pull" rel="noopener ugc nofollow" target="_blank">dvc pull</a></code>检索DVC跟踪的数据和模型，并在本项目的其他版本中使用。经常在<code class="du lk ll lm ln b">git clone</code> &amp; <code class="du lk ll lm ln b">git pull</code>之后执行。</p><p id="8f12" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了在本教程中模拟这种情况，需要删除<code class="du lk ll lm ln b">.dvc/cache/</code>文件夹中的&amp; <code class="du lk ll lm ln b">data/data.csv</code>文件，然后我们从DVC遥控器中拉出。</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="dfec" class="lo jq hi ln b fi ni nj l nk nl">$ rm -rf .dvc/cache<br/>$ rm -f data/data.csv</span><span id="7bc5" class="lo jq hi ln b fi nm nj l nk nl">$ dvc pull</span></pre><p id="b861" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以很容易地验证<code class="du lk ll lm ln b">data.csv</code>文件(大约150MB)已经从我们的远程设备下载到我们的工作区。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="3877" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">对数据进行修改</h1><p id="8898" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在现实世界的ML项目中，我们可能在各种实验中使用多个版本的数据和模型。这种情况的一些潜在原因可能是:</p><ul class=""><li id="cb03" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated">不同的预处理技术用于不同的实验</li><li id="fca2" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">新数据不时从外部来源流入系统</li><li id="c84f" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated">用不同超参数训练的新模型</li></ul><p id="aebd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这种情况下，DVC帮助有效地跟踪这些变化。为了模拟这种情况，我们将原始数据集加倍，如下所示:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="4ea8" class="lo jq hi ln b fi ni nj l nk nl"># Copy the contents of data.csv to a temporary location<br/>$ cp data/data.csv /tmp/data.csv<br/></span><span id="524a" class="lo jq hi ln b fi nm nj l nk nl"># Append contents from this location to the end of data.csv<br/>$ cat /tmp/data.csv &gt;&gt; data/data.csv</span></pre><p id="a66c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们可以通过注意到这个新的<code class="du lk ll lm ln b">data.csv</code>文件的大小是旧文件的两倍来验证这个修改。现在，我们准备跟踪这个变化&amp;上传新文件到我们的S3桶:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="a0e4" class="lo jq hi ln b fi ni nj l nk nl">$ dvc add data/data.csv<br/>$ git add data/data.csv.dvc<br/>$ git commit -m "Update dataset"<br/>$ dvc push</span></pre><p id="d8cb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">很明显，由于文件大小的增加，推送这个新文件花费的时间几乎是之前推送的两倍</em></p><p id="acce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您可以验证推送，检查更新的<code class="du lk ll lm ln b">data/data.csv.dvc</code>文件(<code class="du lk ll lm ln b">7663219...</code>)中的MD5哈希是否对应于S3存储桶中的文件路径。</p><p id="76c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在你也可以推送到GitHub来跟踪新的变化。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="73dd" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">在数据版本之间切换</h1><p id="601d" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">一旦我们有了数据和模型的几个版本，很明显我们可能需要在这些版本之间切换。正如Git使用<code class="du lk ll lm ln b">checkout</code>命令在不同版本的代码之间切换一样，DVC提供了<code class="du lk ll lm ln b">checkout</code>命令来根据<code class="du lk ll lm ln b">.dvc</code>文件同步数据&amp;模型。通常的做法是运行<code class="du lk ll lm ln b">git checkout &lt;...&gt;</code> <em class="lg">(切换一个分支或者签出一个</em> <code class="du lk ll lm ln b"><em class="lg">.dvc</em></code> <em class="lg">文件版本)</em>，后面跟着<code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/checkout" rel="noopener ugc nofollow" target="_blank">dvc checkout</a></code>。</p><p id="ece2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了获得数据集的先前版本&amp; commit，我们执行以下操作:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="5d9d" class="lo jq hi ln b fi ni nj l nk nl">$ git checkout HEAD~1 data/data.csv.dvc<br/>$ dvc checkout<br/>$ git commit data/data.csv.dvc -m "Revert updates"</span></pre><p id="9194" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lg">注意，我们不需要再次执行</em> <code class="du lk ll lm ln b"><em class="lg">dvc push</em></code> <em class="lg">，因为这个版本的数据集已经存储在我们的亚马逊S3存储桶中。因此，我们可以说DVC甚至不是一个严格意义上的版本控制系统！数据文件版本由</em> <code class="du lk ll lm ln b"><em class="lg">.dvc</em></code> <em class="lg">文件的内容定义，版本控制通过Git提供。然后，DVC生成这些</em> <code class="du lk ll lm ln b"><em class="lg">.dvc</em></code> <em class="lg">文件，更改它们，并有效地同步工作区中DVC跟踪的数据以匹配它们。</em></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="c2da" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">访问DVC追踪的数据</h1><p id="0d18" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">一旦我们能够有效地跟踪我们的数据和模型，下一个想法就是我们如何访问这些被跟踪的工件来重用数据集或部署模型？在这一节中，我们将讨论在DVC跟踪的存储库中查找相关文件并从中下载数据的方法。</p><h2 id="9fc4" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">使用DVC搜索文件/目录</h2><p id="07b0" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">为了下载数据和模型，我们首先需要找到它们的位置&amp;如果它们是可访问的。要探索托管在任何Git服务器上的DVC存储库，可以使用命令<code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/list" rel="noopener ugc nofollow" target="_blank">dvc list</a></code>。它列出了项目内容，包括DVC Git跟踪的文件、模型和目录。该命令的语法如下:<code class="du lk ll lm ln b">dvc list &lt;repo-url&gt; [&lt;file-path&gt;]</code> <em class="lg"> ( </em> <code class="du lk ll lm ln b"><em class="lg">[...]</em></code> <em class="lg">暗示</em> <code class="du lk ll lm ln b"><em class="lg">&lt;file-path&gt;</em></code> <em class="lg">是可选的)</em></p><p id="a59d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">例如，在您在本教程中使用的各自的GitHub repo上运行<code class="du lk ll lm ln b">dvc list</code>(在其他目录中)会产生:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="747f" class="lo jq hi ln b fi ni nj l nk nl">$ dvc list &lt;https://github.com/&gt;&lt;your-username&gt;/&lt;repo-name&gt;<br/>.dvcignore<br/>data<br/></span><span id="9508" class="lo jq hi ln b fi nm nj l nk nl">$ dvc list &lt;https://github.com/&gt;&lt;your-username&gt;/&lt;repo-name&gt; data<br/>.gitignore<br/>data.csv<br/>data.csv.dvc</span></pre><h2 id="7992" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated">下载相关文件和目录</h2><p id="7e4a" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">两个<code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/get" rel="noopener ugc nofollow" target="_blank">dvc get</a></code> &amp; <code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/command-reference/import" rel="noopener ugc nofollow" target="_blank">dvc import</a></code>都可以用来从DVC跟踪的存储库中下载文件或目录。然而，<code class="du lk ll lm ln b">dvc get</code>下载文件时不会保留任何将它连接到项目的元数据，而<code class="du lk ll lm ln b">dvc import</code>也会创建相应的<code class="du lk ll lm ln b">.dvc</code>文件保存到项目中。</p><p id="6a96" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lk ll lm ln b"><em class="lg">dvc import</em></code> <em class="lg">本质上是</em><code class="du lk ll lm ln b"><em class="lg">dvc get</em></code><em class="lg">&amp;</em><code class="du lk ll lm ln b"><em class="lg">dvc add</em></code><em class="lg">的组合运用在一起。</em></p><p id="c35e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些命令的语法如下:<code class="du lk ll lm ln b">dvc get/import &lt;repo-url&gt; &lt;file-path&gt; -o &lt;output-file-path&gt;</code></p><p id="97ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lk ll lm ln b">data/data.csv.dvc</code>文件跟踪的<code class="du lk ll lm ln b">data.csv</code>文件存放在我们的S3 &amp;中，可以下载到如下任意项目中:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="6055" class="lo jq hi ln b fi ni nj l nk nl">$ dvc get https://github.com/&lt;your-username&gt;/&lt;repo-name&gt; data/data.csv -o data_downloaded/data.csv</span><span id="5cb4" class="lo jq hi ln b fi nm nj l nk nl">$ dvc import https://github.com/&lt;your-username&gt;/&lt;repo-name&gt; data/data.csv -o data_downloaded/data.csv</span></pre><p id="709c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="lg">注意:</em> </strong> <em class="lg"> </em> <code class="du lk ll lm ln b"><em class="lg">dvc get</em></code> <em class="lg">可以从任何地方调用，但是</em> <code class="du lk ll lm ln b"><em class="lg">dvc import</em></code> <em class="lg">必须从DVC跟踪的存储库中调用。</em></p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="33be" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">DVC Python API</h1><p id="2eef" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">如前所述，通过使用<code class="du lk ll lm ln b">import dvc.api</code>导入任何其他Python模块，DVC也可以用作Python库。这个API的目标是给开发人员一些对DVC跟踪库中版本化的数据或模型的编程访问。我们将讨论的两个库函数是:</p><h2 id="e514" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated"><code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/api-reference/get_url" rel="noopener ugc nofollow" target="_blank">get_url()</a></code></h2><p id="5aeb" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">给定DVC跟踪的GitHub存储库URL ( <code class="du lk ll lm ln b">repo</code> ) &amp;文件路径(<code class="du lk ll lm ln b">path</code>)，它返回实际文件存储在DVC遥控器中的存储位置的URL字符串。</p><p id="c588" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">例如:</strong></p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="4154" class="lo jq hi ln b fi ni nj l nk nl">import dvc.api</span><span id="067b" class="lo jq hi ln b fi nm nj l nk nl">x = dvc.api.get_url(repo="https://github.com/&lt;your-username&gt;/&lt;repo-name&gt;", path="data/data.csv")<br/># x stores the URL of the corresponding file in your S3 bucket <br/># (like s3://mlopsdvc&lt;your-roll-number&gt;/dvcstore/&lt;path-to-file&gt;)</span></pre><h2 id="d12e" class="lo jq hi bd jr lp lq lr jv ls lt lu jz jb lv lw kd jf lx ly kh jj lz ma kl mb bi translated"><code class="du lk ll lm ln b"><a class="ae jo" href="https://dvc.org/doc/api-reference/open" rel="noopener ugc nofollow" target="_blank">open()</a></code></h2><p id="7762" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">给定DVC跟踪的GitHub库URL ( <code class="du lk ll lm ln b">repo</code>)、文件路径(<code class="du lk ll lm ln b">path</code> ) &amp;)文件打开的模式(<code class="du lk ll lm ln b">mode</code>)，它打开数据/模型文件&amp;生成相应的文件对象。</p><p id="a1ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">示例:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="01d3" class="lo jq hi ln b fi ni nj l nk nl">import dvc.api<br/>import pandas</span><span id="a42e" class="lo jq hi ln b fi nm nj l nk nl">with dvc.api.open(<br/>    repo="https://github.com/&lt;your-username&gt;/&lt;repo-name&gt;", <br/>    path="data/data.csv", <br/>    mode="r"<br/>) as fd:<br/>    df = pandas.read_csv(fd)</span></pre></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="1ecc" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">在共享服务器上使用DVC</h1><p id="1a1f" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">通常，在许多学术和专业环境中，个人笔记本电脑不用于计算密集型工作，因为它们的功能不足以处理大量数据或密集处理。相反，团队依赖于云或内部工作站，其中多人经常在同一个开发服务器上协作。虽然这样可以更好地利用资源，如GPU访问和集中数据存储，但如果管理不当，很有可能会在几个用户和存储库中不必要地重复相同的数据。</p><p id="5f19" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴于这种设置，DVC可以在维护开发服务器上的共享缓存方面发挥关键作用，这样所有用户只需使用<code class="du lk ll lm ln b">dvc checkout</code>命令就可以获得近乎即时的工作空间恢复和切换速度。</p><p id="7625" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在用<code class="du lk ll lm ln b">dvc init</code>初始化DVC存储库之后，默认情况下，DVC将缓存放在存储库的<code class="du lk ll lm ln b">.dvc/cache</code>文件夹中。要在服务器上创建&amp;使用共享缓存，必须为外部缓存创建一个目录，并配置适当的权限&amp;链接。</p><figure class="mv mw mx my fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nr"><img src="../Images/59ebb342fd5355b4e5d180d48d81b110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_XbQ8OeLl4F2Uoej"/></div></div><figcaption class="mz na et er es nb nc bd b be z dx translated"><strong class="bd jr"> <em class="nd">图片来源:</em> </strong> <em class="nd">作者创作</em></figcaption></figure><p id="86fc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面给出了在服务器上设置共享DVC缓存的分步示例&amp;在DVC跟踪的存储库中使用它:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="3738" class="lo jq hi ln b fi ni nj l nk nl"># Create a folder to behave as external cache<br/>$ mkdir -p /home/shared/dvc-cache         </span><span id="4823" class="lo jq hi ln b fi nm nj l nk nl"># Move cache from current repo to external cache (optional)<br/>$ mv .dvc/cache/* /home/shared/dvc-cache  </span><span id="90d3" class="lo jq hi ln b fi nm nj l nk nl"># Set cache of  DVC-tracked repository as folder made above<br/>$ dvc cache dir /home/shared/dvc-cache    </span><span id="93a0" class="lo jq hi ln b fi nm nj l nk nl"># Set group permissions on new cache files<br/>$ dvc config cache.shared group           </span><span id="d601" class="lo jq hi ln b fi nm nj l nk nl"># Enable <a class="ae jo" href="https://devdojo.com/devdojo/what-is-a-symlink" rel="noopener ugc nofollow" target="_blank">symlinks</a> to avoid copies from cache to workspace<br/>$ dvc config cache.type symlink</span></pre><p id="509f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在检查存储库中的<code class="du lk ll lm ln b">.dvc/config</code>文件时，出现以下部分:</p><pre class="mv mw mx my fd ne ln nf ng aw nh bi"><span id="d608" class="lo jq hi ln b fi ni nj l nk nl">[cache]<br/>    dir = /home/shared/dvc-cache<br/>    shared = group<br/>    type = symlink</span></pre><p id="b96e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du lk ll lm ln b">cache.type</code>可以是<code class="du lk ll lm ln b">reflink</code>、<code class="du lk ll lm ln b">hardlink</code>或<code class="du lk ll lm ln b">copies</code>。一旦对<code class="du lk ll lm ln b">cache.type</code>做了任何更改，在更改发生之前，需要使用<code class="du lk ll lm ln b">dvc checkout --relink</code>明确告知DVC。</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="5565" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">结束语</h1><p id="75be" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">在这篇文章中，我们通过使用DVC有效地管理我们的数据和模型，开始将一些MLOps原则付诸实践。正如我们所看到的，DVC是一个强大而灵活的工具，我们刚刚介绍了它提供的一些基本特性。尽管在创建可复制的ML管道方面，DVC还有很多内容，但我选择不在本系列中讨论这些内容，因为在接下来的博客中，我将介绍更多的工具和框架，用于更有效地创建和管理端到端的ML管道。尽管如此，感兴趣的人可以随意翻阅DVC文档来了解DVC的能力。</p><p id="9ab9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你觉得DVC很有趣，并鼓励你今后在ML &amp; Data Science项目中使用它来保持一个干净的工作空间。此外，请随意查看将Google Drive用作DVC远程存储的步骤。</p><p id="caee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在下一篇博客中，我们将把注意力从版本控制转移到使用数据&amp;使用一个有趣而强大的Python库PyCaret创建端到端的ML管道来执行各种实验。</p><p id="e638" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是MLOps基础系列的其他部分:</p><ul class=""><li id="303b" class="kn ko hi is b it iu ix iy jb lh jf li jj lj jn ku kv kw kx bi translated"><a class="ae jo" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8"> <strong class="is hj">第一部分:</strong>MLOps的温柔介绍</a></li><li id="6251" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-3-ml-experimentation-using-pycaret-747f14e4c28d"> <strong class="is hj">第三部分:</strong>使用PyCaret的ML实验</a></li><li id="fcb1" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-4-model-tracking-with-mlflow-deployment-with-fastapi-61614115436"> <strong class="is hj">第4部分:</strong>使用MLFlow进行模型跟踪&amp;使用FastAPI进行部署</a></li></ul><p id="1cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢&amp;快乐编码！</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="4428" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">附加参考</h1><ul class=""><li id="be8e" class="kn ko hi is b it kp ix kq jb kr jf ks jj kt jn ku kv kw kx bi translated"><a class="ae jo" href="https://towardsdatascience.com/comparing-data-version-control-tools-2020-c11ef1c80ea7" rel="noopener" target="_blank">对比数据版本控制工具</a></li><li id="da8e" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" href="https://dvc.org/doc" rel="noopener ugc nofollow" target="_blank"> DVC文档</a></li><li id="672e" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" href="https://katacoda.com/dvc" rel="noopener ugc nofollow" target="_blank">练习DVC的片尾环境</a></li><li id="bc98" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" href="https://realpython.com/python-data-version-control/#share-a-development-machine" rel="noopener ugc nofollow" target="_blank">用Python和DVC实现数据版本控制</a></li><li id="52f6" class="kn ko hi is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx bi translated"><a class="ae jo" rel="noopener" href="/qonto-way/using-dvc-to-create-an-efficient-version-control-system-for-data-projects-96efd94355fe">使用DVC为数据项目创建高效的版本控制系统</a></li></ul></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="4142" class="jp jq hi bd jr js mj ju jv jw mk jy jz ka ml kc kd ke mm kg kh ki mn kk kl km bi translated">关于作者</h1><p id="4b8c" class="pw-post-body-paragraph iq ir hi is b it kp iv iw ix kq iz ja jb ld jd je jf le jh ji jj lf jl jm jn hb bi translated">嘿伙计们！我是Tezan Sahu，微软的数据和应用科学家。我在孟买的IIT大学获得了学士学位，主修机械工程，辅修计算机科学与工程。我对NLP、深度学习和区块链有浓厚的兴趣，喜欢使用前沿技术开发有趣的产品。</p><p id="26b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">网址:</strong> <a class="ae jo" href="https://tezansahu.github.io/" rel="noopener ugc nofollow" target="_blank">特赞萨胡|微软</a><br/><strong class="is hj">LinkedIn:</strong><a class="ae jo" href="https://www.linkedin.com/in/tezan-sahu/" rel="noopener ugc nofollow" target="_blank">特赞萨胡| LinkedIn </a> <br/> <strong class="is hj">邮箱ID:</strong><a class="ae jo" href="mailto:tezansahu@gmail.com" rel="noopener ugc nofollow" target="_blank">tezansahu@gmail.com</a></p></div></div>    
</body>
</html>