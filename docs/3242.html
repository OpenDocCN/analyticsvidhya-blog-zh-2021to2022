<html>
<head>
<title>Principal Component Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">主成分分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/principal-component-analysis-754781cfb30f?source=collection_archive---------15-----------------------#2021-06-20">https://medium.com/analytics-vidhya/principal-component-analysis-754781cfb30f?source=collection_archive---------15-----------------------#2021-06-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a18b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一部分，我将详细介绍Niraj维尔马在Kaggle上发布的PCA代码。<a class="ae jc" href="https://www.kaggle.com/nirajvermafcb/d/nsrose7224/crowdedness-at-the-campus-gym/principal-component-analysis-with-scikit-learn" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/nirajvermafcb/d/nsrose 7224/crowded ness-at-the-campus-gym/principal-component-analysis-with-sci kit-learn</a></p><h1 id="c65d" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">第一步:导入必要的库</strong></h1><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b177" class="kk je hh kg b fi kl km l kn ko">import numpy as np <br/>import pandas as pd <br/>import matplotlib as mpl<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>%matplotlib inline</span></pre><p id="dfc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们了解每个导入库的重要性</p><p id="fa5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">Numpy:</strong>Numpy通常被称为Numpy，是一个用于处理数组的Python库。它还具有线性代数，傅立叶变换和矩阵领域的工作功能。</p><p id="8b63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Pandas: </strong> Python数据分析库Pandas，来源于术语“Panel data”，这是一个计量经济学术语，用于多维结构化数据集。Pandas是一个有用的数据分析库。它可用于执行数据操作和分析。Pandas提供了强大且易于使用的数据结构，以及在这些结构上快速执行操作的方法。</p><p id="cdf2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Matplotlib:  Matplotlib是一个全面的库，用于在Python中创建静态、动画和交互式可视化。Matplotlib让简单的事情变得简单，让困难的事情变得可能。它基于NumPy数组构建，旨在与更广泛的SciPy堆栈一起工作。</p><p id="39f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Matplotlib.pyplot: </strong>大部分Matplotlib实用程序位于名为pyplot的子模块下，通常在<strong class="ig hi"> plt </strong>别名下导入。pyplot是使Matplotlib像MATLAB一样工作的函数集合。每个pyplot函数都会对图形进行一些更改。例如，创建图形、在图形中创建绘图区域、在绘图区域中绘制一些线、用标签装饰绘图等。,</p><p id="0a63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Seaborn: </strong> Seaborn是一个基于Matplotlib的Python数据可视化库。它提供了一个高层次的界面来绘制有吸引力的和信息丰富的统计图形。</p><p id="68c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> %Matplotlib inline: </strong>将Matplotlib的后端设置为‘inline’后端。有了这个后端，绘图命令的输出在前端内联显示，就像Jupyter Notebook一样，直接显示在产生它的代码单元的下面。生成的图也将存储在笔记本文档中。</p><h1 id="53b8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">步骤2:加载数据集</h1><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="6395" class="kk je hh kg b fi kl km l kn ko">df=pd.read_csv('input file path')<br/>df.head()</span></pre><p id="6183" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Read_csv </strong>是一个重要的Pandas函数，用于读取文件并对其执行操作。用户不仅可以在本地读取csv文件，还可以通过read_csv从url读取。此外，您可以选择需要导出哪些列，这样我们就不必在以后编辑数组。</p><p id="8a38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> df.head() </strong>打印数据帧的前5行。默认情况下，当你使用<strong class="ig hi"> print(df)，</strong>打印一个数据帧时，你只会得到第一行和最后5行。可以使用<strong class="ig hi"> to_string()打印整个数据帧。</strong>例如，print(df.to_string())</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kp"><img src="../Images/bcdf089baf1123a48f6c9b5e98828ceb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7X4adYX4KPM0EscWraROEw.jpeg"/></div></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="9c15" class="kk je hh kg b fi kl km l kn ko">df.shape</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es kx"><img src="../Images/d17442a0f91fc151fd4a43da2c5c204d.png" data-original-src="https://miro.medium.com/v2/resize:fit:300/format:webp/1*Gg5VjYoSLqJ8NhfjZrc0Yw.jpeg"/></div></figure><p id="49bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> df.shape </strong>返回表示数据帧维度的元组。如您所见，我们的df中有62184行和11列。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="1674" class="kk je hh kg b fi kl km l kn ko">df.describe()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ky"><img src="../Images/d7408db8112ad663b91321ba390dc87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8X3GaaU5R0n6LiPReU0JIA.jpeg"/></div></div></figure><p id="8896" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> df.describe() </strong>用于计算一些统计数据，如系列或数据帧的数值的百分位数、平均值和标准差。它既分析对象和数字序列，也分析各种数据类型的Dataframe列集。我们的describe()方法返回了列值的总数、平均值、标准差、最小值、最大值以及各种百分比(25、50和75)</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es kz"><img src="../Images/7c058261605e13304b8272cc22d82318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K0F90H1gigFr4dKZqdALOw.jpeg"/></div></div></figure><p id="5388" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> df.corr() </strong>用于查找数据帧中所有列的成对相关性。自动排除任何<strong class="ig hi"> NA </strong>值。此外，daraframe中的任何非数字列都会被忽略。</p><p id="577a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们使用Seaborn为这种相关性绘制一张热图。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es la"><img src="../Images/684153ce5ab4728becd21b1f001271f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TCxnn5ZU4tP7TOeMQVs1Qw.jpeg"/></div></figure><p id="b469" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> figure() </strong>方法用于创建新图形或激活现有图形。参数<strong class="ig hi"> figsize </strong>采用宽度和高度(以英寸为单位)来创建图形。默认情况下，figsize采用[6.4，4.8]值。从<a class="ae jc" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.figure.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib . org/stable/API/_ as _ gen/matplotlib . py plot . figure . html</a>了解更多关于<strong class="ig hi"> plt.figure() </strong>及其参数的信息</p><p id="d24e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> sns.heatmap() </strong>用于数据的图形化表示，使用颜色来可视化矩阵的值。它将dataframe作为输入参数之一。<strong class="ig hi"> Vmax </strong>用于锚定颜色图，否则从数据和其他关键字参数中推断值。<strong class="ig hi">正方形</strong>将轴的纵横比设置为“相等”,因此每个单元格都是正方形。<strong class="ig hi">不能</strong>将数据值写入每个单元格。最后，<strong class="ig hi"> Cmap </strong>是从数据值到色彩空间的映射。</p><p id="73c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> plt.title() </strong>是我们绘制的地图的标题。要了解更多关于热图的细节，请参考<a class="ae jc" href="https://seaborn.pydata.org/generated/seaborn.heatmap.html" rel="noopener ugc nofollow" target="_blank">https://seaborn.pydata.org/generated/seaborn.heatmap.html</a></p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lb"><img src="../Images/59e458a9009197a20a91512647faadb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*uTXvPjXJOwyFwcaSIFvMyw.jpeg"/></div></figure><p id="58ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以观察到，热图用亮色表示更常见的值，用暗色表示不太常见的值。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="988f" class="kk je hh kg b fi kl km l kn ko">x=df['number_people']<br/>y=df['month']<br/>plt.xlabel('Number of people')<br/>plt.ylabel('Month of year')<br/>plt.scatter(x,y)</span></pre><p id="2ac2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> plt.scatter() </strong>用于观察变量之间的关系，用点来表示变量之间的关系。散点图广泛用于表示变量之间的关系以及一个变量的变化如何影响另一个变量。点击<a class="ae jc" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.scatter.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib . org/stable/API/_ as _ gen/matplotlib . py plot . scatter . html</a>了解散点图及其参数的更多信息。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lc"><img src="../Images/779cbfcba2bcbddb1446220ef940ab86.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*5GZXjH2bj7M311bKuslGjA.jpeg"/></div></figure><p id="2b38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的散点图代表了<strong class="ig hi">人数</strong>和一年中的月份之间的关系。正如我们所观察到的，随着时间的推移，到第7个月，参加健身房的人数逐渐减少。并且在第8个月有一个激增，可能是因为学期的开始。</p><p id="7289" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你已经观察到，在我们的数据中，温度是用华氏温度表示的。让我们用公式<strong class="ig hi">将它转换成摄氏度=(华氏-32度)* (5/9) </strong></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="b675" class="kk je hh kg b fi kl km l kn ko">Farenheit=df['temperature']<br/>F=Farenheit.tolist()<br/>C=map(lambda x: (float(5)/9)*(x-32), F)<br/>Celsius=(list(c))<br/>temperature_celsius=pd.series(Celsius)<br/>df['temperature']=temperature_celsius<br/>df.head()</span></pre><p id="6f9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，在应用实际公式之前，我将温度列转换为列表。再次使用<strong class="ig hi"> pd将结果列表转换成一维数组。系列()。</strong>看一看新数据和新特性之间的相关性。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es ld"><img src="../Images/48d6837593f87ab2c06ef1421af6725f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZTPELHGXqzzcRvDh_LKH8A.jpeg"/></div></div></figure><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es le"><img src="../Images/39a501c659c4d4695f929b9a14857532.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WXeJMK_edb8G-ft7H5y1Vg.jpeg"/></div></div></figure><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lf"><img src="../Images/ad0dbda107734c42d711ec329e605a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-P00QE14ExZh-9L9utW6SQ.jpeg"/></div></div></figure><h1 id="4489" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">步骤3:标准化数据</h1><p id="a34f" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">数据标准化是重新调整一个或多个属性的过程，使它们的平均值为0，标准差为1。为此，我们可以使用python预处理库<strong class="ig hi"> StandardScaler。</strong>了解更多关于StandardScaler的信息，请访问<a class="ae jc" href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-Learn . org/stable/modules/generated/sk Learn . preprocessing . standard scaler . html</a></p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="68ed" class="kk je hh kg b fi kl km l kn ko">X=df.iloc[:,1:8]<br/>Y=df.iloc[:, 0]</span><span id="991c" class="kk je hh kg b fi ll km l kn ko">from sklearn.preprocessing import StandardScaler<br/>scaler=StandardScaler()<br/>X=scaler.fit_transform()<br/>X</span></pre><p id="7cc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们首先通过将标签和行分别分配给X和y来分离它们。X是包含所有行、特征但不包含标签的数据帧。y是只包含标签的数据帧。</p><p id="7510" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> fit_transform(): </strong>在深入了解fit_transform()对我们有什么帮助之前。我们先来学习一下<strong class="ig hi">拟合</strong>和<strong class="ig hi">变换</strong>的概念。为了使数据标准化，我们减去平均值，然后将结果除以标准差。我们对数据的训练集进行所有这些计算。但是，我们必须将相同的转换应用于我们的测试集，或者就此而言，在预测之前任何新获得的示例。因此，我们必须使用来自训练集的相同的平均值和标准偏差值。因此，scikit-learn的<strong class="ig hi"> fit() </strong>只是计算参数(表示一个标准差。StandardScaler情况下的偏差)并将它们保存为内部对象的状态。稍后，我们可以调用<strong class="ig hi"> transform() </strong>方法将转换应用于任何特定的示例集。<strong class="ig hi"> fit_transform() </strong>通过首先调用fit()然后调用transform()方法来组合这两个步骤。看看我们的fit_transform()方法的结果。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lm"><img src="../Images/007b1e1b5426bdfa0188d690431e9454.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*a6eCt0ezA2pL6IspgT0nLw.jpeg"/></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">使用fit_transform()标准化数据</figcaption></figure><h1 id="09e4" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">第四步:主成分分析</h1><p id="7c0f" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">主成分分析(PCA)是一种降维技术，通常用于通过将一大组变量转换成仍包含大组中大多数信息的较小变量来降低大型数据集的维数。</p><p id="8446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它是这样工作的:PCA识别最接近数据的超平面，然后将数据投影到其上，保持方差。PCA选择在训练集中保持最大方差的轴。PCA找到与维数一样多的轴，使得每个轴彼此正交。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="fae0" class="kk je hh kg b fi kl km l kn ko">from sklearn.decomposition import PCA<br/>pca=PCA()<br/>pca.fit_transform(X)</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lr"><img src="../Images/eb3ee13c6fe63b4478a76844f853ace0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*TVei949M5VBj8P47xq82nw.jpeg"/></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="3fe4" class="kk je hh kg b fi kl km l kn ko">pca.get_covariance()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es ls"><img src="../Images/2141436e3a9257fd11dde09c49403eb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*aNcmyY-R17OH3tDmZkiWYA.jpeg"/></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="09e5" class="kk je hh kg b fi kl km l kn ko">explained_variance=pca.explained_variance_ratio_<br/>explained_variance</span></pre><p id="66aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">总方差</strong>是各个主成分的所有方差的总和。</p><p id="6170" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主成分的<strong class="ig hi">解释方差</strong>的分数是该主成分的方差与总方差之比。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lt"><img src="../Images/378c09eae2a07f5ac84024f3c8eb9fe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*Q8kdHuHDqbR63TEdTbFCtw.jpeg"/></div></figure><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="8e9e" class="kk je hh kg b fi kl km l kn ko">with plt.style.context('dark_background'):<br/>    plt.figure(figsize=(6, 4))<br/>    plt.bar(range(7),explained_variance, alpha=0.5,align='center', label='individual explained variance' )<br/>    plt.xlabel('Principal components')<br/>    plt.ylabel('Explained variance ratio')<br/>    plt.legend()<br/>    plt.tight_layout()</span></pre><p id="a7f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<strong class="ig hi"> plt.bar()的帮助下，我们将解释的差异绘制在条形图上。</strong>你可以在<a class="ae jc" href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.bar.html" rel="noopener ugc nofollow" target="_blank">https://matplotlib . org/stable/API/_ as _ gen/matplotlib . py plot . bar . html</a>找到更多关于plt.bar()的信息</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lu"><img src="../Images/5da213999040efcd6bccd1c0e10a00e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*VzGs3zSs5wGOZ8pfZemenw.jpeg"/></div></figure><p id="3e85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以得出结论，前两个主成分贡献了高达45%的方差。类似地，第三和第四分量总共有30%的方差。如果你注意到，第7个分量与其他分量相比，差异很小，所以我们可以去掉这个分量。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="er es lv"><img src="../Images/54a357ff4af805b02c5afbd9efec596e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQzV1uZFpypMfCe1DfpaMg.jpeg"/></div></div></figure><p id="6dbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述命令将主成分设置为6，这将自动删除最后一个成分。</p><p id="029a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获得新的协方差，并计算所有成分的解释方差比。</p><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lw"><img src="../Images/6c5dc2b2d19358cbee205dd9509b6a48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*FWOf4AW8GR9s7mhVLmYzHA.jpeg"/></div></figure><p id="28bc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，看看6个主成分的解释方差比。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="f5ff" class="kk je hh kg b fi kl km l kn ko">with plt.style.context('dark_background'):<br/>    plt.figure(figsize=(6,4))<br/>    plt.bar(range(6),explained_variance, alpha=0.5,align='center', label='individual explained variance' )<br/>    plt.xlabel('Principal components')<br/>    plt.ylabel('Explained variance ratio')<br/>    plt.legend()<br/>    plt.tight_layout()</span></pre><figure class="kb kc kd ke fd kq er es paragraph-image"><div class="er es lx"><img src="../Images/38e4489c5fc397d6bb1d900856758611.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*t4GrrJ4Y-7VGBfEgFHw4dQ.jpeg"/></div></figure><p id="ae70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在确定了主要组件之后，我们使用新的数据框架(在我们的例子中是X_new)进行数据建模。</p><p id="62c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就把我们带到了本文的结尾。对于庞大的数据分析世界，我是个新手。我只是试图用已经存在的资源来探索这个世界，来自学，让我理解编码的细微差别。万一，如果我错过了提及任何应得的学分，请让我知道:)</p></div></div>    
</body>
</html>