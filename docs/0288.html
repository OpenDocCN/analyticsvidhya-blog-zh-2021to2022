<html>
<head>
<title>Image Classification with tf.keras (Introductory Tutorial)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用tf.keras进行影像分类(入门教程)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-classification-with-tf-keras-introductory-tutorial-7e0ebb73d044?source=collection_archive---------7-----------------------#2021-01-11">https://medium.com/analytics-vidhya/image-classification-with-tf-keras-introductory-tutorial-7e0ebb73d044?source=collection_archive---------7-----------------------#2021-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="b37c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">了解用于图像分类的tf.keras的基础知识</h2></div><p id="71d8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">TensorFlow是最受欢迎的开源机器学习框架之一，它在机器学习的兴起中发挥了至关重要的作用，特别是在工业中，这要归功于它丰富的生态系统，从用于在手机中部署模型的<em class="js"> TensorFlow Lite、</em>，到用于在生产中服务TensorFlow模型的<em class="js"> TensorFlow Serving、</em>。它是由Google开发和支持的。<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras" rel="noopener ugc nofollow" target="_blank"> <em class="js"> tf.keras </em> </a>是一个建立在TensorFlow之上的高级框架，它的设计方式使得我们可以只使用几行代码来开发和训练机器学习模型。</p><p id="c99c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本教程中，我们使用的是<em class="js"> tf.keras </em>。</p><p id="645f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，让我们导入相关的库、子包、模块和类。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="fdf9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们从数据集URL下载花的数据集(3700左右)。花的数据集有五个不同的类，每种花一个，每种类型的花保存在不同的文件夹中，其名称作为文件夹的名称。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="26f5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们通过进入<em class="js"> roses </em>文件夹来看一张样本图片。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kb"><img src="../Images/37e6d5e8795023fc7dc476f8fc151d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/1*vccT_8bHj-dqGAUIf3rLOw.png"/></div></figure><p id="6a61" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">难怪，我们这里有一朵美丽的玫瑰，花瓣上滴着水珠。:)</p><p id="ca26" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在回到机器学习。让我们为训练创建参数。批次大小是一批中要拍摄的图像数量。图像高度和宽度给出了用于训练和预测的图像尺寸。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="24dc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里，我们使用了80%的数据进行训练，20%的数据进行验证。<em class="js"> tf.keras </em>使得使用其API创建训练和验证数据集变得更加容易。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="4243" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="js">数据集的class_names </em>属性(训练或验证)给出了类名列表，该列表稍后用于根据最大索引值(<em class="js"> z </em>值或<em class="js">概率</em>值)识别类。让我们看看花卉分类示例中的所有类。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ke"><img src="../Images/5c26bf083df893db04671a04e3d6bf45.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*VyHaiRCv9Fc6u7_gcZBtfg.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">类别名称</figcaption></figure><p id="0b5c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们用一个3x3的拼贴画来想象这些图像。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kj"><img src="../Images/1a7968caa378630b21c0fe2597c42a6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*z4cjLoo5qITMhdCwPVsySQ.png"/></div></figure><p id="2424" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们在加载数据时使用两种方法—缓存和预取。在训练的第一个时期将图像加载到内存中之后，缓存会将图像保存在内存中。这确保了数据集在训练模型时不会成为瓶颈。训练时预取重叠数据预处理和模型执行。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="23b1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们在范围[0，1]内标准化RGB值，因为神经网络更喜欢使用重新调整层的较小值。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="3685" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们使用<em class="js"> keras </em>的<em class="js">顺序</em> API创建模型。API按顺序添加这些层，因为我们只是将这些层一层一层地堆叠起来，所以<em class="js">顺序</em> API服务于我们的目的。我们使用卷积层和池层组，然后是完全连接的层。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="e632" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们编译模型，看看我们模型的总结。该概要给出了所使用的层的类型、所使用的层数、可训练参数的数量以及中间输出的形状。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kk"><img src="../Images/a3d2ace005b86dadf61e6cef5d71d81e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*9rnZSRcBsbyrIoPONxNirg.png"/></div></figure><p id="ecff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有了10个纪元，我们来训练模型。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kl"><img src="../Images/633713b1a5d03fb55088b1aa5ce59bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Yef1sVjTWrQpzQEm2ktqQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">普通图像识别模型的历史</figcaption></figure><p id="c02e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们在这里看到的，训练精度线性增加并接近完美值，而验证精度徘徊在0.6左右。因此，训练和验证准确性之间的差距正在扩大。这是过度拟合的标志。当模型非常适合训练数据，但无法概括我们试图建立的模式时，就会发生过度拟合。让我们用一对图表来直观地展示培训和验证指标。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kq"><img src="../Images/149ee287a0750fe7de46cf2f90391aef.png" data-original-src="https://miro.medium.com/v2/resize:fit:928/format:webp/1*b7ktnfx2yiGEM0Kcmdwuiw.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">10个时期的培训和验证指标</figcaption></figure><p id="7024" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们想要对看不见的数据进行很好的概括，则需要减小训练准确度和验证准确度之间的巨大差距，这是过度拟合的标志。为了最小化过拟合，我们使用两种方法——数据扩充和剔除。</p><p id="2ec3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">过拟合的原因之一是训练数据数量少。当数据集很小时，模型从明显的噪声(在现实世界中经常看到)中学习。扩充数据集的一种方法是使用不同的变换技术(如旋转、翻转、移动、缩放、裁剪等)来变换现有数据。</p><p id="4c2b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">数据扩充代码:</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">使用tf.keras进行数据扩充</figcaption></figure><p id="a031" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看几个变换图像的例子。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kr"><img src="../Images/6943ca01acc2cede9013957669fc77eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/1*IEcId5Yxh5eXtmx_51LBxQ.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">随机变换的图像</figcaption></figure><p id="2600" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们在模型中使用辍学技术。Dropout在定义它的层中随机删除节点。我们删除了20%的节点<em class="js"/>，所以我们使用<em class="js"> 0.2 </em>作为<em class="js">删除</em>层的参数。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="38dd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用数据增加和减少的模型创建已经完成。让我们编译模型并训练它。正如我们在模型摘要中看到的，增加了增强层和下降层。由于培训需要10/15分钟，具体取决于培训的硬件，我们何不在此期间喝杯茶呢？</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ks"><img src="../Images/fa675360afcd497d74d5e4632cea5071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*xZGYw8E9A7U-UP8MZzXj-Q.png"/></div></figure><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kt"><img src="../Images/bdadef9aaecc8875aaec5f2be53692e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zaiHaZ23gajdNl5yR1423w.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">应用数据扩充和删除后的培训历史</figcaption></figure><p id="a2ca" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从历史上可以看出，在进行数据扩充和应用剔除后，过拟合有所减少。精度差距的缩小表明过度拟合的减少。让我们绘制类似的度量图。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ku"><img src="../Images/b692c484d451eeae32c9680c8d8233fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:898/format:webp/1*NtVHZumpJI4grn0rJ-NQaw.png"/></div></figure><p id="8a62" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看到训练图和验证图一起出现是一个幸福的时刻。开心，开心:)</p><p id="8ce9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个关于使用<em class="js"> tf.keras. </em>创建机器学习模型的温和介绍</p><p id="8f99" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">创建模型后，我们需要在现实世界的数据中测试它。让我们从网上随机获取一幅向日葵的图像(你可以自己搜索并用你的url替换<em class="js"> image_url </em>)并测试我们的模型是否预测正确。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kv"><img src="../Images/6049651aeaf9f386121c0ec7db970e88.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*-UW0e5GQPcdOlJEu_CXrRA.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">我们用来测试模型的向日葵图片</figcaption></figure><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kw"><img src="../Images/45a7e9dfa99965b38c7cbaa5ae6be29a.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*3cKhakfI8YLpRrqBf2xf3A.png"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">预测及其概率</figcaption></figure><p id="cd2f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">耶，我们的模型预测它为“<strong class="iy hi">向日葵</strong>”，概率约为95%。很酷，不是吗？</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><p id="13ba" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">谢谢你坚持到最后。本文之后将会有其他关于计算机视觉的TensorFlow教程。敬请期待！</p></div></div>    
</body>
</html>