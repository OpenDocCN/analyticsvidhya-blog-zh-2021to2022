<html>
<head>
<title>Pointers in Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">戈兰语的指针</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pointers-in-golang-1a679b464849?source=collection_archive---------1-----------------------#2021-05-30">https://medium.com/analytics-vidhya/pointers-in-golang-1a679b464849?source=collection_archive---------1-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9f01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指针是一个非常基本但非常强大的工具，但在编程时，它常常被误解并认为是一个困难或令人沮丧的概念。创建指针是为了帮助在代码中传递数据，而不必创建变量的副本，因此不会使用额外的内存。</p><p id="d076" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有些语言回避这个概念，有些语言部分地接受它，但是在Go中我们有了它们应该有的指针:̶a̶n̶̶i̶n̶s̶t̶r̶u̶m̶e̶n̶t̶̶o̶f̶̶t̶o̶r̶t̶u̶r̶̶e是优化性能的伟大工具。</p><p id="a1af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指针是一个变量，它引用内存中某个存储值的位置，所以你取一个变量，把它放在内存中，然后不是读取实际的值，你只是得到那个值所在的地址；当您在代码中传递它时，由于它只是一个“数字”，所以移动它比实际值更便宜，实际值可能比地址长得多(这在文章的最后将很重要)。</p><p id="78f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从一些代码开始:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="5ace" class="jm jn hi ji b fi jo jp l jq jr">package main<br/><br/>import (<br/>   "fmt"<br/>)<br/><br/>func main(){<br/>   myString := "a string value"<br/>   fmt.Println(myString)<br/><br/>   myInteger := 1<br/>   fmt.Println(myInteger)<br/>}</span></pre><p id="1e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们定义了两个变量并打印出来，还没有奇怪的行为</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es js"><img src="../Images/5aad7c868b22540c152d1ef2d004e682.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*vPFd-zc6r0haSjigsgCFIg.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">暂时没有指针</figcaption></figure><p id="237f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们将一个变量发送给一个函数，那么语言将创建该参数的副本，并在函数中使用它，如下所示:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="9596" class="jm jn hi ji b fi jo jp l jq jr">func myFunction(s string){<br/>   fmt.Println(s)<br/>}</span><span id="97b8" class="jm jn hi ji b fi ka jp l jq jr">func main() {<br/>   myOtherString := "another message here"<br/>   myFunction(myOtherString)<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kb"><img src="../Images/24ab728b21f06fac300f8d218840999a.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*x3YBNK4xgu-EuhJxY1FBVQ.png"/></div></figure><p id="1365" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你这样做的时候，<em class="kc"> myFunction，</em>接收一个字符串，它将把这个字符串赋给变量“s”，然后把它打印在屏幕上，Go(和大多数语言)将创建一个最初发送的值的副本，并在函数内部使用它，一旦函数到达末尾，垃圾收集器将获取这些变量并处理掉它们。</p><p id="6715" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们使用一个指针来实现相同的行为:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="50af" class="jm jn hi ji b fi jo jp l jq jr">func myFunctionWithPointers(s *string){<br/>   fmt.Println(s, *s)<br/>}</span><span id="5e8a" class="jm jn hi ji b fi ka jp l jq jr">func main() {<br/>   myOtherString := "another message here"<br/>   myFunctionWithPointers(&amp;myOtherString)<br/>}</span></pre><p id="e180" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这次我们用一些奇怪的字符来装饰变量:</p><p id="9a80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">main():与号(&amp;)会告诉Go，这个变量将会是一个指向这个变量的指针，Go会查看这个变量，找出数据类型，并找出它在内存中的位置，一旦它有了那个地址，它就会把内存中的地址发送给函数。</p><p id="b651" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在myFunctionWithPointers上:星号/星号(*)，将告诉Go:我们将接收一个数据类型为string的指针，注意指针需要类型、指向int的指针、指向string的指针、指向slice的指针等等，这一点非常重要。一旦参数的数据类型被定义，我们将在函数体中打印它几次，首先我们将“s”作为一个指向字符串的指针，然后我们将在它前面添加一个开始，这将告诉Go获取该指针，然后获取存储在该位置的实际值:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kd"><img src="../Images/a2e6cd3cf3911900a73a71e0e0d1ebf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*7bfs1OP3PyBqOUN5fXbIxQ.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">0xc000010200是内存地址，您的会有所不同</figcaption></figure><p id="1588" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们第一次使用变量“s”时，它是一个指针，所以我们得到了地址，第二次我们“解引用”了它，取地址，然后取那个位置的值。</p><p id="4a7a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们尝试使用一个结构:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8de1" class="jm jn hi ji b fi jo jp l jq jr">type myStructure struct {<br/>   Name string<br/>}<br/><br/>func main() {<br/>   structure := myStructure{Name: "MyName"}<br/>   structureFunction(&amp;structure)<br/>}<br/><br/>func structureFunction(e *myStructure){<br/>   fmt.Println(e, *e, e.Name, (e).Name)<br/>}</span></pre><p id="153e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会打印出以下内容:</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es ke"><img src="../Images/ead76643713fe247826fd8060a75fc83.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*iWKq-QI8_Cx8zG-l35JJiw.png"/></div></figure><p id="89da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们打印出结构值，但前缀是&amp;符号，这意味着它是一个指向包含这些内容的结构的指针。</p><p id="9384" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用星号时，我们告诉它获取值，因此我们得到了<em class="kc"> {MyName} </em>，这是格式化的结构值。</p><p id="e551" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你访问一个指向一个结构的指针的字段时，Go会为你处理这个解引用，你会得到一个值，就好像它是一个结构而不是一个指向结构的指针。</p><p id="5d73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一种用法是将结构放在括号内，这是为了指定解引用，在这种情况下这是多余的，因为Go会像上面看到的那样处理它。</p><p id="ae1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想更新函数中的变量:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8e6f" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>   sliceValues := []string{"a","b", "c"}<br/>   appendToSlice(sliceValues)<br/>   fmt.Println(sliceValues)<br/>}<br/><br/>func appendToSlice(c []string){<br/>   fmt.Println(c)<br/>   c = append(c, "d")<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kf"><img src="../Images/880ed2be7e6062b9a498c2c5117a8bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/format:webp/1*lIYH045zQuPFlyEr4Bpc1g.png"/></div></figure><p id="1020" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不使用指针将导致不更新函数上下文之外的变量。</p><p id="43bf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们到处添加指针:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="dc25" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>   sliceValues := []string{"a","b", "c"}<br/>   appendToSliceWithPointer(&amp;sliceValues)<br/>   fmt.Println(sliceValues)<br/>}<br/><br/>func appendToSliceWithPointer(c *[]string){<br/>   fmt.Println(*c)<br/>   *c = append(*c, "d")<br/>}</span></pre><p id="f8ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当调用函数时，这次我们将使用指针符号，当在函数中接收参数时，当我们打印值时，我们将告诉它遵从它，这样我们就可以获得切片的实际值，而不是内存位置，可能看起来令人困惑的部分是当我们追加到我们的切片时，因为追加需要一个切片，所以我们必须取消引用“c”， 添加“d”的值，然后append的返回值，将必须存储为“c”的值，而不是指针(我们将试图在预期的内存位置存储一个片)。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kg"><img src="../Images/acae62c3e0d0a2251f55d9aced604398.png" data-original-src="https://miro.medium.com/v2/resize:fit:290/format:webp/1*04nF_Vx3cD0vb5bkcl262g.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">这一次，操作的寿命超过了函数的作用域</figcaption></figure><p id="20ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">好的，这看起来很简单，但是当我们尝试绘制地图时会发生什么呢</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b8db" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>   myMap := map[string]int{<br/>      "a": 1,<br/>      "b": 2,<br/>      "c": 3,<br/>   }<br/>   maps(myMap)<br/>   fmt.Println(myMap)<br/>}<br/><br/>func maps(c map[string]int){<br/>   c["d"] = 4<br/>   fmt.Println(c)<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kh"><img src="../Images/7520f09432b81b6e44d08de84bb1c56b.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*-LrVNCgw0qy_51Mqr1DVQA.png"/></div></figure><p id="aafa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个例子中，对地图的更改表现不同，它在函数内部被更新，并成为原始地图的实际值，而不仅仅是副本，这是因为地图实际上是指针，所以我们真的不需要对地图做任何事情(少了一件需要担心的事情)。</p><p id="d855" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">猜猜看，函数也是指针:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="05ab" class="jm jn hi ji b fi jo jp l jq jr">func main() {<br/>   f := &amp;myFunc<br/>}<br/> <br/>func myFunc(){<br/>   <br/>}</span></pre><p id="2187" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以这是行不通的，因为myFunc已经是一个指针了(2个了，还有几个……)</p><p id="9399" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于指针实际上是一种数据类型，函数接收器将获得类似的行为:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c86d" class="jm jn hi ji b fi jo jp l jq jr">type myStructure struct {<br/>   Name string<br/>}<br/><br/>func (ms myStructure) noPointer(){<br/>   ms.Name = "xxxx"<br/>   fmt.Println(ms.Name)<br/>}<br/><br/>func (ms *myStructure) withPointer(){<br/>   ms.Name = "yyyy"<br/>   fmt.Println(ms.Name)<br/>}<br/><br/>func main() {<br/>   theStructure := myStructure{Name: "MyName"}<br/>   theStructure.noPointer()<br/>   fmt.Println(theStructure.Name)<br/><br/>   theStructure.withPointer()<br/>   fmt.Println(theStructure.Name)<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es ki"><img src="../Images/08ee33e1f226a6bd46299b73d81b4a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*MIsZu00tUrHKrkBMF08Q0g.png"/></div></figure><p id="e361" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当接收器用作结构时，该值在该功能之外不受影响。</p><p id="a440" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当接收器作为指针处理时，该值的行为将与我们现在预期的一样。</p><p id="db45" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是，如果您尝试直接调用该方法:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6896" class="jm jn hi ji b fi jo jp l jq jr">func (ms myStructure) noPointer(){<br/>   fmt.Println("Not a pointer")<br/>}<br/><br/>func (ms *myStructure) withPointer(){<br/>   fmt.Println("a pointer")<br/>}<br/><br/>func main() {<br/>   myStructure{}.noPointer()<br/>   myStructure{}.withPointer()<br/>}</span></pre><p id="ba8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个函数“withPointer”不会运行，“withPointer”是一个链接到“指向myStructure的指针”数据类型的接收器，myStructure{}是myStructure的一个实例；我们可以通过实例化该结构，然后添加一个指向它的指针来解决这个问题:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="b296" class="jm jn hi ji b fi jo jp l jq jr">type myStructure struct {<br/>   Name string<br/>}<br/><br/>func (ms myStructure) noPointer(){<br/>   fmt.Println("Not a pointer")<br/>}<br/><br/>func (ms *myStructure) withPointer(){<br/>   fmt.Println("a pointer")<br/>}<br/><br/>func main() {<br/>   myStructure{}.noPointer()<br/>   ms := &amp;myStructure{}<br/>   ms.withPointer()<br/>}</span></pre><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kj"><img src="../Images/fbd3ed0090690016fb4a0009dba54b67.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*DBb0nQ0zqrUXAH4RDXkO8w.png"/></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">好多了</figcaption></figure><p id="5638" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是你开始使用指针所需要的全部内容:)</p><p id="d222" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就引出了一个问题:那么我什么时候使用指针呢？总是吗？</p><figure class="jd je jf jg fd jt er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kk"><img src="../Images/2512738f0299a2bfe2c8309642428712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YIXv1UC65v56dAV7.jpg"/></div></div><figcaption class="jw jx et er es jy jz bd b be z dx translated">不知何故，这成了我最喜欢的迷因</figcaption></figure><p id="1c3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">指针可以让我们在正确传递值时节省一些内存，因为这听起来是最优的，那么我们应该总是这样做，这样我们就总是节省内存。</p><p id="32e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">除非…从没人记得的文章开头提示反派…</p><p id="412b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">….Go的收垃圾的走进来…</p><p id="a320" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你传递指向函数的指针，并且该函数的作用域结束时，垃圾收集器不知道它是否应该杀死该变量(看看这篇文章以获得更详细的解释:<a class="ae kp" href="https://blog.gopheracademy.com/advent-2018/avoid-gc-overhead-large-heaps/" rel="noopener ugc nofollow" target="_blank">https://blog . gopheracademy . com/advent-2018/avoid-GC-overhead-large-heaps/</a>)，然后我们最终得到的原始数据比我们希望的要多。</p><p id="9197" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会对我们产生如此大的影响以至于指针变得毫无意义吗？不尽然，GC移除它所花费的时间会稍长一些，但在大多数情况下，它仍然是可管理的/不明显的，如果你正在考虑压缩最后一点性能，那么你将有可能尝试并优化你的指针使用，否则它将属于糟糕应用的微优化范畴。</p></div></div>    
</body>
</html>