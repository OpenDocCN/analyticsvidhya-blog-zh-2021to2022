<html>
<head>
<title>Time Series Classification with Convolutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积时间序列分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-classification-with-convolutions-ed5cb33b1e3b?source=collection_archive---------5-----------------------#2021-04-30">https://medium.com/analytics-vidhya/time-series-classification-with-convolutions-ed5cb33b1e3b?source=collection_archive---------5-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/753d2b1ea34948ec992b25542ec96ec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4HZo_IaMN3BqOivW"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">卢卡·布拉沃在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="8eec" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">时间序列可能很难。时间序列可能需要大量的特性工程来完成工作。即便如此，就模型的复杂性而言，结果可能看起来有点平淡无奇。在这篇博文中，我想展示如何用1D卷积神经网络来处理时间序列，以及结果是多么令人印象深刻。所以系好安全带上路吧！</p><p id="19e7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，我将使用意大利电力需求数据集。分类任务是区分10月到3月(含)和4月到9月。数据集可以在这里找到<a class="ae it" href="http://www.timeseriesclassification.com/description.php?Dataset=ItalyPowerDemand" rel="noopener ugc nofollow" target="_blank">。目前为止，网页上显示的最佳准确率为97%。让我们看看我们能走多近。</a></p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/18031621747b2b3f80665584d86b8877.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gf6tvKuViKYNDidXv4vmvg.png"/></div></div></figure><p id="21de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是数据集的样子。第一列代表我们应该预测的类。接下来的24列是代表意大利不同地区电力需求的数据。接下来的任务是正确分类，这个月是冬天还是夏天。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jx"><img src="../Images/c46084e756b57bb91950698f82c3a86d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHJuVS2MN4tHWB5OeiY4Lg.png"/></div></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jy"><img src="../Images/eb3d9df7f1147042884056cbb10f463e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DBchRKoXXkufIWkF6lwXtA.png"/></div></div></figure><p id="3623" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是两个不同地区不同月份的电力需求的例子。上半部分是1类，代表冬天的一个月，下半部分代表2类的情况，代表夏天的一个月。</p><p id="9c94" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我将使用PyTorch实现这个模型，它提供了很大的灵活性和方便的助手类，如dataset和dataloaders。有了这些类，我们可以很容易地批量训练我们的模型，我们也可以利用CUDA(如果我们想的话)。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="c5c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们的数据加载器中已经有了数据，我们就可以开始构建模型了。这篇文章是关于动手操作的，我将把数学留到另一篇文章中。所以让我们检查模型，首先我们创建1D卷积层。</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="3a6c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于卷积，我们可以自由选择输出维数，但是，卷积后新创建的张量的长度是预定义的，计算如下:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kb"><img src="../Images/7c3fe216dbe30600350ed8769c5f08c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*54YYXdgBf_1YJt3woqTTxw.png"/></div></div></figure><p id="cf27" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的卷积之后，我们希望L维等于1，所以我们可以把它展平。我们有一个24的序列。根据该公式，我们可以计算当相应地设置kernel_size、padding和exploation时卷积L如何变化。或者，我们可以手动检查:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kc"><img src="../Images/a5d631caaee894c017f40624b9974f8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQnh-PRT4UhKuVIKvreqGw.png"/></div></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kd"><img src="../Images/d037e5efd488d9bfb0952bf80b06f7a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*02SNyoKRzlVxaFzEHwAZkg.png"/></div></div></figure><p id="e0e6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你愿意，你可以随便摆弄这些数字。我们希望最终L的值是1。手动网格搜索后，我想出了一个模型，其中我们只使用一个卷积，内核大小为时间帧(至少差不多)。之后，我应用一个max_pooling层。现在我们知道如何建立模型:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><p id="b3fc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这看起来并不复杂，对吗？请记住，没有特征工程，没有额外的模型来找到任何时间相关的模式，简单明了的1D卷积，然后是max_pooling，然后是完全连接的层。由于这是一个二元结果变量，我们对损失函数和标准Adam优化器使用交叉熵。让我们来训练这个:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="jz ka l"/></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ke"><img src="../Images/bcb1c10e263bebdd20807873043cd124.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_xJeFIN748qncEsLvSY4WA.png"/></div></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kf"><img src="../Images/0d7214f691fcbdf7a67708b7484ec3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4z9dEnkaGjdELMdaOXn26A.png"/></div></div></figure><p id="bf02" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的模型正在学习，它在验证集上做得很好。然而，这个数据集只有67个训练案例(我将其分为60个用于训练，7个用于验证)。真正的测试还在等待，测试集。这套包含1000多个案例。所以让我们来看看结果。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kg"><img src="../Images/b417bee46a63b328533c48bb18a5f4fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mxaPDP6PPme5gk2h3jU_A.png"/></div></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kh"><img src="../Images/a3bfe5b22ee17e4ff5b69ce08c650beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIPXPwKgCwLM3YV9lXbApw.png"/></div></div></figure><p id="52c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">光荣！我们达到了97%的准确率！这是该数据集目前的最佳结果。让我们来看看错误分类的时间序列。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ki"><img src="../Images/4d459556ae40b250e2159dcea0eeef8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ih0ST-kdSiGffMZx5rZqaQ.png"/></div></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kj"><img src="../Images/152edbc0ae5205b4dabf3fe87697ce55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qa0hH7u5Qq9Nhuu4nsKvQ.png"/></div></div></figure><p id="e598" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到这些案例很难正确分类。尤其是第一种情况看起来几乎像是贴错标签。</p><p id="04c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种非常实用的方法之后，在下一篇博客中，我将讲述一维卷积的工作方式及其背后的数学原理，敬请关注！</p><p id="318c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">拉塞</p><p id="216b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">(本帖最初发布于此:<a class="ae it" href="https://lschmiddey.github.io/fastpages_/2021/04/30/Timeseries_Classification_with_ConvolutionalNeuralNet.html" rel="noopener ugc nofollow" target="_blank">https://lschmiddey . github . io/fast pages _/2021/04/30/time series _ class ification _ with _ convolutionalneuralnet . html</a></p></div></div>    
</body>
</html>