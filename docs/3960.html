<html>
<head>
<title>Gesture Control of your FireTV with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python实现FireTV的手势控制</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/gesture-control-of-your-firetv-with-python-7d3d6c9a503b?source=collection_archive---------6-----------------------#2021-08-13">https://medium.com/analytics-vidhya/gesture-control-of-your-firetv-with-python-7d3d6c9a503b?source=collection_archive---------6-----------------------#2021-08-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/6a06adc58fddae09547c4ed11dd5e487.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*99gr_4ni24fjr687HwZDDw.jpeg"/></div></figure><p id="c606" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这篇文章是我关于FireTV的python控制的文章的延续。使用手势控制是一种有趣的方式来激活一个远程免费的消防棒按钮！因此，在本文中，我将介绍如何使用OpenCV和mediapipe设置一个基本的手部检测器，然后如何将它集成到第一篇文章中显示的fire-stick控制器类中。</p></div><div class="ab cl jj jk go jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="ha hb hc hd he"><p id="7dc5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，我们想在一个新的类中初始化一个基本的手检测器。为此，我们需要导入mediapipe、OpenCV和数学库。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="cc49" class="jz ka hh jv b fi kb kc l kd ke">import mediapipe as mp<br/>import cv2<br/>import math</span></pre><p id="dc62" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们需要定义一个可以调用的手检测对象，并初始化mediapipe参数，以便在图像/视频流中进行手检测。mediapipe中的手部检测需要几个参数，我们将重点关注的是:模式、要找到的最大手部、检测置信度和跟踪置信度。所以开始的代码看起来会像这样:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="24e2" class="jz ka hh jv b fi kb kc l kd ke">class handDetector():<br/>   def __init__(self,mode=False,maxHands=2,<br/>                detectCon=0.8,trackCon=0.5):<br/>      self.mode=mode<br/>      self.maxHands=maxHands<br/>      self.detectCon=detectCon<br/>      self.trackCon=trackCon</span><span id="8296" class="jz ka hh jv b fi kf kc l kd ke">      self.mpHands = mp.solutions.hands<br/>      self.hands = self.mpHands.Hands(self.mode,self.maxHands,<br/>                                      self.detectCon,self.trackCon)<br/>      self.mpDraw = mp.solutions.drawing_utils  <br/>      (Draws mediapipes hand landmarks on the image)</span></pre><p id="ca4d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们需要添加一个方法来处理和检测手的图像。做到这一点非常简单，但有几个要点需要记住。Mediapipe需要RGB格式的图像颜色数据，而OpenCV摄像机的输入是BGR格式，因此我们称之为“手动处理器”的新方法的第一部分将如下开始:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="0d98" class="jz ka hh jv b fi kb kc l kd ke">def handProcessor(self,img):<br/>   imgRGB = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span></pre><p id="7204" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以现在我们有了图像的RGB版本。下一点是使用mediapipes处理功能，并将手的扫描标志绘制到我们的图像上，这意味着我们将在我们的方法中添加以下行:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="fa81" class="jz ka hh jv b fi kb kc l kd ke">self.results = self.results = self.hands.process(imgRGB)</span><span id="35b0" class="jz ka hh jv b fi kf kc l kd ke">if self.results.multi_hand_landmarks:<br/>   for self.landmarks in self.results.multi_hand_landmarks:<br/>      self.mpDraw.draw_landmarks(img,self.landmarks,<br/>                                 self.mpHands.HAND_CONNECTIONS)<br/>return img</span></pre><p id="7f94" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">目前，我们在图像中找到的地标不能被打印，因为它们是它们自己的对象，所以如果我们想要获得数字坐标值，这些对象需要被解压缩。为此，我们将添加另一个方法调用“findCoords ”,它将返回地标的坐标列表，以及手周围边界框的坐标，这在以后可能会派上用场。完整的方法看起来像:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="5ce5" class="jz ka hh jv b fi kb kc l kd ke">def findCoords(self,img,handNo):<br/>   self.lMarkList = []<br/>   xList = []<br/>   yList = []<br/>   bbox = []</span><span id="cf39" class="jz ka hh jv b fi kf kc l kd ke">   if self.results.multi_hand_landmarks:<br/>      myHand = self.results.multi_hand_landmarks[handNo]<br/>      for ID,LM in enumerate(myHand.landmark):<br/>         h,w,c = img.shape<br/>         cx,cy = int(LM.x*w),int(LM.y*h)<br/>         self.lMarkList.append([ID,cx,cy])<br/>         xList.append(cx)<br/>         yList.append(cy)<br/>         cv2.circle(img,(cx,cy),0,(255,0,255),cv2.FILLED)<br/>      <br/>      xmin,xmax = min(xList),max(xList)<br/>      ymin,ymax = min(yList),max(yList)<br/>      bbox = xmin,ymin,xmax,ymax<br/>      cv2.rectangle(img,(bbox[0],bbox[1]),(bbox[2],bbox[3]),<br/>                    (0,255,0),2)<br/>   return self.lMarkList,bbox</span></pre><p id="cb0f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当调用这个方法时，输出是手部标志的x和y坐标列表，然后是手部周围边界框的角坐标。边界框对于缩放坐标以标准化点之间的距离非常有用，尤其是当手与相机的距离变化时。不过，这不是我在这篇文章中要讨论的内容。</p><p id="d66e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，我们将添加到手部检测器类的最后一个有用的方法是digitStatus方法。这将做的是返回一个0或1的列表，分别表示手指/拇指是向上还是向下，这非常容易。主要要注意的是，每个指尖的地标id都是[4，8，12，16，20]。</p><p id="05e9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了确定手指是向上还是向下，我们将获取每个手指的指尖的位置，并且如果指尖的y坐标大于相关联的指节界标的坐标，那么我们将声明手指向下。我们正在检查y坐标是否更大，因为图像的顶部是y=0，底部是更高的y坐标(图像的最大尺寸)。由于角度的原因，拇指是使用不同的标志完成的，但几乎是相同的，所以看看这里的方法:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="ed64" class="jz ka hh jv b fi kb kc l kd ke">def digitStatus(self):<br/>   fingers = []<br/>   self.fingerTips = [4,8,12,16,20]</span><span id="3f98" class="jz ka hh jv b fi kf kc l kd ke">   #thumb<br/>   if self.lMarkList[self.fingerTips[0]][2]&lt; self.lMarkList[self.fingerTips[0]-1][2]:<br/>      fingers.append(1)<br/>   else:<br/>      fingers.append(0)</span><span id="c64f" class="jz ka hh jv b fi kf kc l kd ke"><br/>   #fingers<br/>   for ID in range(1,5):<br/>      if self.lMarkList[self.fingerTips[ID]][2] &lt; self.lMarkList[self.fingerTips[ID]-2][2]:<br/>         fingers.append(1)<br/>      else:<br/>         fingers.append(0)<br/>   return fingers</span></pre><p id="7db4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们的手部检测课程到此结束！下一步是从网络摄像头打开一个视频流，应用我们的手部探测器，并将其与我们在上一篇文章中制作的荧光棒控制器相连接。</p></div><div class="ab cl jj jk go jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="ha hb hc hd he"><p id="e9ff" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您已经编写了fire-stick控制器类的代码，那么您可以将它粘贴到这个文档中，或者导入包含它的文件，只要最适合您就行。我们想写我们的“main”函数来保存现在的主要进程，所以首先我们需要打开我们的网络摄像头，并创建一个手部探测器和消防棒控制器的实例。</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="2e23" class="jz ka hh jv b fi kb kc l kd ke">def main():<br/>   cap = cv2.VideoCapture(0)<br/>   detector = handDetector()<br/>   fireStick = FireStickController()<br/>   fireStick.addDevice(fireStickIP)  #Define your fire-stick IP here</span></pre><p id="4533" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们需要一个连续的循环，检查网络摄像头的饲料和处理图像。因此，我们可以使用while循环来实现这一点，要么使用“while True”，要么使用“while cap.isOpened()”。这个循环中最基本的要素是:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="fd83" class="jz ka hh jv b fi kb kc l kd ke">while True:<br/>   success,img = cap.read()<br/>   img = cv2.flip(img,flipCode=1) #this just flips the video in the y-axis and is not necessary if you dont want to</span><span id="8703" class="jz ka hh jv b fi kf kc l kd ke">   img = detector.handProcessor(img)<br/>   lMarkList,bbox = detector.findCoords(img)</span></pre><p id="28ce" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是获得连续进料和不断手工处理进料所需要的一切。为了能够查看提要，您只需要在while循环的末尾添加以下内容:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="8221" class="jz ka hh jv b fi kb kc l kd ke">cv2.imshow('Feed',img)<br/>cv2.waitKey(1)</span></pre><p id="6fa2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后在while循环之外添加:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="8e96" class="jz ka hh jv b fi kb kc l kd ke">cap.release()<br/>cv2.destroyAllWindows()</span></pre><p id="51b2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以这是你可以用手势添加所有火棒控制的部分。在while循环的中间，您将需要一个IF语句来检查地标列表是否为空。如果它不是空的，那么你知道它在检测指针，所以看起来像这样:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="08f7" class="jz ka hh jv b fi kb kc l kd ke">while True:<br/>   success,img = cap.read()<br/>   img = cv2.flip(img,flipCode=1) #this just flips the video in the y-axis and is not necessary if you dont want to</span><span id="f87e" class="jz ka hh jv b fi kf kc l kd ke">img = detector.handProcessor(img)<br/>   lMarkList,bbox = detector.findCoords(img)</span><span id="b86a" class="jz ka hh jv b fi kf kc l kd ke">   if len(lMarkList)!=0:<br/>      <br/>      ###CONTROLLING CODE###</span><span id="e6c6" class="jz ka hh jv b fi kf kc l kd ke">   cv2.imshow('Feed',img)<br/>   cv2.waitKey(1)<br/>cv2.release()<br/>cv2.destroyAllWindows()</span></pre><p id="fb1e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于我们的火棒控制器代码，它对你是完全开放的，你想用什么手势控制哪个遥控按钮。我将介绍一个非常简单的示例，并让您尝试其余的部分！</p><p id="4a3f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以当我用食指在手掌上轻点时，我想暂停/播放我正在看的任何东西，而这只需要两行代码。我们需要添加到控制代码部分的是:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="cacb" class="jz ka hh jv b fi kb kc l kd ke">if detector.digitStatus()==[1,0,1,1,1]:<br/>   fireStick.playPause()</span></pre><p id="ff76" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">其中playPause方法是我在上一篇文章中添加到fire-stick控制器类中的一个方法。IF语句所做的只是检查是否只有食指按下，然后通过adb服务器向fire-stick发送播放/暂停命令。</p><p id="1f2a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">最后一步是在底部添加常用的代码:</p><pre class="jq jr js jt fd ju jv jw jx aw jy bi"><span id="ac58" class="jz ka hh jv b fi kb kc l kd ke">if __name__=='__main__':<br/>   main()</span></pre></div><div class="ab cl jj jk go jl" role="separator"><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo jp"/><span class="jm bw bk jn jo"/></div><div class="ha hb hc hd he"><p id="13a7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">就是这样！你可以添加各种不同的手势来控制不同的功能，这完全取决于你的想象力。我希望你能从这段代码中得到一些乐趣，并根据你的需要修改它，或者只是为了修改它而修改它！</p><p id="2ff6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下是上一篇关于用python基本控制火棍的文章的链接，以防你错过:<a class="ae kg" rel="noopener" href="/@tomaclarke16/controlling-you-fire-tv-with-python-d5e102669066">https://medium . com/@ toma Clarke 16/controlling-you-fire-TV-with-python-d5e 102669066</a></p></div></div>    
</body>
</html>