<html>
<head>
<title>Write Better Python Functions (Using Type Dispatch)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更好的Python函数(使用类型分派)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/write-better-python-functions-using-type-dispatch-94b550f5dde8?source=collection_archive---------6-----------------------#2021-04-10">https://medium.com/analytics-vidhya/write-better-python-functions-using-type-dispatch-94b550f5dde8?source=collection_archive---------6-----------------------#2021-04-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="ae1e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">用python写一个函数很容易，但是写一个好的函数却不那么容易。大多数python程序员经常不知道如何编写清晰简洁的函数，更不用说使用类型调度了。让我们看看如何使用类型调度在python中编写更好的函数。</h2></div><h1 id="ff1c" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">入门指南</h1><p id="2a2b" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">在我们进入什么是类型调度之前？或者类型调度如何让你成为更好的python程序员，让我们先了解一些基本知识，比如<em class="kk">什么是好的Python函数？</em>老实说，我宁愿让<a class="ae kl" rel="noopener" href="/hackernoon/write-better-python-functions-c3a9a36382a6">杰夫·克努普</a>来解释。</p><p id="eb35" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我真的相信，真正理解一个东西如何工作的唯一方法是把它分成一个个小块，然后把它们重新组合在一起，或者从头开始构建。让我们以一个定义非常明确的用例为例，从头开始为它编写一个函数。我所说的从头开始，是指从伪代码到python代码的一对一转换开始，而不考虑任何最佳实践。</p><p id="1060" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">然后通过<em class="kk">分析什么可行&amp;什么不可行</em>，我们可以在此基础上进行构建。我们将重复这个过程，直到我们用尽改进代码的方法。所以这篇文章不是一个版本，而是同一个用例的多个版本。</p><p id="48cf" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">如果你想知道为什么？因为我们将忘记我们所知道的关于编写函数的一切，并在编写时质疑每一行代码。这样，我们就可以清楚地看到每一块是如何贴合的。我们将创建自己的清单，而不是盲目地遵循关于编写函数的项目清单。如果这篇文章遗漏了一些有价值的东西，请告诉我，我会很乐意更新它。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/c81444460e8843bb108e1d84f9cc2669.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*KVoWyha6VfWv8rPv.jpeg"/></div></div></figure><p id="664b" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们将尝试在4次迭代中为特定用例编写最好的或者至少是我最好的python函数。每一次迭代都将是对上一次的改进，并在前面声明一个明确的目标。变得更好是一个迭代的过程，取决于你在python熟练程度谱中的位置，4个迭代中的一个会比其他的更能引起你的共鸣。这篇文章的下一步是理解用例。系好安全带，这将是一次非常有趣的旅行。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="041a" class="iw ix hh bd iy iz lk jb jc jd ll jf jg in lm io ji iq ln ir jk it lo iu jm jn bi translated">用例</h1><h2 id="be9e" class="lp ix hh bd iy lq lr ls jc lt lu lv jg jx lw lx ji kb ly lz jk kf ma mb jm mc bi translated">简报</h2><p id="9a61" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">将给定的图像输入转换成PyTorch张量。对，就是这样。很简单，对吧？</p><p id="aeaa" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">具有数据科学背景的人可以跳过这一部分，跳到下一节，因为我将简要介绍这个用例所需的python库。</p><ol class=""><li id="3541" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mi mj mk ml bi translated"><a class="ae kl" href="https://pillow.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hi"> Pillow </strong> </a>是一款，增加了对打开、操作和保存多种不同图像文件格式的支持。</li><li id="332f" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><a class="ae kl" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hi"> Numpy </strong> </a>代表数值Python。Numpy是Python中科学计算的核心库。它为处理这些数组提供了高性能的对象和工具。</li><li id="be9a" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><a class="ae kl" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hi"> PyTorch </strong> </a>是开源的，它提供了两个主要的功能，即通过&amp;建立在基于磁带的自动微分系统上的深度神经网络提供强大加速的计算(如NumPy)。如果没有CUDA支持的GPU可用，Pytorch可以使用CPU运行代码，但这对于训练ML模型来说会慢得多。</li></ol><p id="ab48" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">如果您想知道这个用例为什么有用或者对谁有用？大多数以图像数据作为输入的机器学习应用程序(人脸检测，OCR)都在使用这些库。这个用例被认为是ML世界中的数据预处理。</p><h2 id="cf5c" class="lp ix hh bd iy lq lr ls jc lt lu lv jg jx lw lx ji kb ly lz jk kf ma mb jm mc bi translated">我们该怎么做？</h2><p id="28e5" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">所涉及的步骤非常简单。使用Pillow library打开图像，并将其转换为NumPy数组&amp;在转换为张量之前对其进行转置。顺便提醒一下，这篇文章是关于编写更好的python函数，而不是深度学习的数据预处理教程，所以如果它令人生畏，不要担心。一旦我们开始编码，你会感觉更舒服。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mr"><img src="../Images/2daeb2f6af778f1d2d3bf159396cda8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kHmyI5138YEUPfEd.png"/></div></div></figure><p id="8d4b" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">在我们继续之前，有几点需要注意。</p><ol class=""><li id="21f4" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mi mj mk ml bi translated">PIL图像当转换为Numpy数组时，它会成形—(高度、宽度和通道数)。在Pytorch中，图像传感器的形状必须是——(通道数、高度、宽度)，所以我们在将数组转换为张量之前，先对其进行处理。</li><li id="8ab8" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated">对于有经验的Pytorch用户来说，他们想知道，为什么我们不使用torch函数，比如<code class="du ms mt mu mv b">ToTensor</code>或transform方法，而跳过Numpy？是的，你是对的，我们绝对可以做到这一点，但为了更好地理解这篇文章的观点，我有意识地决定走更长的路线。</li></ol><h2 id="6242" class="lp ix hh bd iy lq lr ls jc lt lu lv jg jx lw lx ji kb ly lz jk kf ma mb jm mc bi translated">打嗝</h2><p id="5075" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">不好意思，用例没那么简单。有个小嗝嗝，函数要支持多种输入数据类型，分别是<code class="du ms mt mu mv b">str/Path</code>、<code class="du ms mt mu mv b">Pillow(Image)</code>和<code class="du ms mt mu mv b">Numpy(Ndarray)</code>。</p><p id="1a3a" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">上图中定义的流程步骤仅支持数据类型<code class="du ms mt mu mv b">str/Path</code>作为输入。因此，我们需要添加对<code class="du ms mt mu mv b">Pillow(Image)</code>和<code class="du ms mt mu mv b">Numpy(Ndarray)</code>类型的支持，但是如果我们仔细想想，这些数据类型是将图像文件转换为torch张量的中间步骤。因此，上图中实际上没有额外的步骤，我们只需重复为<code class="du ms mt mu mv b">str/Path</code>数据类型定义的步骤，并修改一些初始步骤，以支持<code class="du ms mt mu mv b">Pillow(Image)</code>和<code class="du ms mt mu mv b">Numpy(Ndarray)</code>数据类型作为我们函数的输入。</p><p id="6f52" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">两个额外工作流程的流程步骤如下。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mr"><img src="../Images/182a31f97c51ae90d0dc4982b5cb7797.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cC6k9XtNwSvEFFK_.png"/></div></div></figure><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es mr"><img src="../Images/09b4484c424a3483bcff6d7e15fa7251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_8ItlbUVoo0uQCci.png"/></div></div></figure><p id="624a" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">在比较了3幅图像后，很明显:</p><ul class=""><li id="c0e9" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mw mj mk ml bi translated">图像数据类型的处理步骤是原始处理步骤的子集。</li><li id="8588" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mw mj mk ml bi translated">数组数据类型的处理步骤是图像数据类型处理步骤的子集。</li></ul><h1 id="ca02" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">解决办法</h1><p id="e61e" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">该函数的前两次迭代将是关于<strong class="jq hi">行为实现</strong>，而最后两次迭代都是关于代码<strong class="jq hi">耐火</strong>。如果你是那种喜欢先看一本书的结局的读者(我不是在评判)，可以直接跳到有标题的章节——<em class="kk">迭代4 </em>。</p><h1 id="10c5" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">迭代1</h1><p id="0531" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><strong class="jq hi">目标:</strong></p><p id="1276" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">让它工作。就这么简单，因为我们是从零开始，所以最好只关注基本特性或功能的工作。我们不需要那些花里胡哨的东西。对于这个迭代，我们将只关注实现<em class="kk">使用流程步骤</em>，而不担心<em class="kk">的停顿。</em></p><p id="53f2" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">代号:</strong></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="3cc0" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Import required libraries</em><br/><strong class="mv hi">import</strong> <strong class="mv hi">numpy</strong> <strong class="mv hi">as</strong> <strong class="mv hi">np</strong><br/><strong class="mv hi">import</strong> <strong class="mv hi">torch</strong><br/><strong class="mv hi">from</strong> <strong class="mv hi">PIL</strong> <strong class="mv hi">import</strong> Image <strong class="mv hi">as</strong> PILImage<br/><br/><em class="kk"># Set Torch device to GPU if CUDA supported GPU is available</em><br/>device = torch.device('cuda' <strong class="mv hi">if</strong> torch.cuda.is_available() <strong class="mv hi">else</strong> 'cpu')<br/><br/><em class="kk"># Function to convert image to Torch tensor</em><br/><strong class="mv hi">def</strong> Tensor(inp):<br/>    <br/>    <em class="kk"># Read image from disk using PIL Image</em><br/>    img = PILImage.open(inp).convert('RGB')<br/>    <br/>    <em class="kk"># Convert the image to numpy ndarray</em><br/>    imgArr = np.asarray(img, np.uint8)<br/>    <br/>    <em class="kk"># Rearrange the shape of the array so that it is pytorch compatible</em><br/>    imgArr = imgArr.transpose(2, 0, 1)<br/>    <br/>    <em class="kk"># Convert Numpy array to Torch Tensor and move it to device</em><br/>    <strong class="mv hi">return</strong> torch.from_numpy(imgArr).to(device)</span></pre><p id="30a7" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们做了什么？</p><p id="2915" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们设法将<em class="kk">流程步骤</em>翻译成代码。代码中的行数几乎与图中的方框数相匹配。</p><h2 id="4460" class="lp ix hh bd iy lq lr ls jc lt lu lv jg jx lw lx ji kb ly lz jk kf ma mb jm mc bi translated">快速检查:</h2><p id="5c6a" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我们需要一个样本图像来测试我们的功能，所以我们将下载一个。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="e5f4" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Download a sample image to disk</em><br/><strong class="mv hi">import</strong> <strong class="mv hi">urllib.request</strong> <br/><br/>url = "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/200px-Python-logo-notext.svg.png"<br/>filename = "sample.png"<br/>urllib.request.urlretrieve(url, filename)</span></pre><p id="baf1" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">现在，让我们测试一下我们的功能。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="c748" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Pass the sample image through our function</em><br/>imgTensor = Tensor(filename)<br/><br/><em class="kk"># Check whether the output of the function is a Tensor</em><br/><strong class="mv hi">assert</strong> isinstance(imgTensor, torch.Tensor), "Not a Tensor"</span></pre><p id="f8be" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">看起来我们成功地实现了基本功能。厉害！</p><p id="51d1" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们可以改进什么？</p><ul class=""><li id="0519" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mw mj mk ml bi translated">我们还没有实现多种数据类型输入功能，即支持像<code class="du ms mt mu mv b">PIL Image</code>，<code class="du ms mt mu mv b">Ndarray</code>的数据类型。</li><li id="8dee" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mw mj mk ml bi translated">此外，我们肯定应该改进函数的名称，它并没有真正说明函数的任何内容。</li></ul></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="8dfe" class="iw ix hh bd iy iz lk jb jc jd ll jf jg in lm io ji iq ln ir jk it lo iu jm jn bi translated">迭代2</h1><p id="39bb" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><strong class="jq hi">目标:</strong></p><p id="5ffe" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">当我们添加对多种数据类型的支持时，我们需要非常小心，因为如果没有适当的验证，事情可能会很快变糟，从最终用户的角度来看，错误消息没有任何意义。因此，在这次迭代中，我们将:</p><ol class=""><li id="a0a0" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mi mj mk ml bi translated">为这些类型实现多种数据类型支持和验证。</li><li id="fccd" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated">让函数名更有用。</li></ol><p id="f0ad" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">代码:</strong></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="4e07" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Import Libraries</em><br/><strong class="mv hi">import</strong> <strong class="mv hi">numpy</strong> <strong class="mv hi">as</strong> <strong class="mv hi">np</strong><br/><strong class="mv hi">import</strong> <strong class="mv hi">torch</strong><br/><strong class="mv hi">from</strong> <strong class="mv hi">PIL</strong> <strong class="mv hi">import</strong> Image <strong class="mv hi">as</strong> PILImage<br/><strong class="mv hi">from</strong> <strong class="mv hi">pathlib</strong> <strong class="mv hi">import</strong> Path, PurePath</span><span id="2306" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Set Torch device to GPU if CUDA supported GPU is available</em><br/>device = torch.device('cuda' <strong class="mv hi">if</strong> torch.cuda.is_available() <strong class="mv hi">else</strong> 'cpu')<br/></span><span id="03c0" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Function to convert image to Torch tensor</em><br/><strong class="mv hi">def</strong> from_multiInput_toTensor(inp):<br/>    <br/>    <em class="kk"># Input type - str/ Path, then read from disk &amp; convert to array</em><br/>    <strong class="mv hi">if</strong> isinstance(inp, (str, PurePath)):<br/>        <strong class="mv hi">try</strong>: <br/>            image = PILImage.open(inp).convert('RGB')<br/>            imageArray = np.asarray(image.copy(), np.uint8)<br/>        <strong class="mv hi">except</strong> <strong class="mv hi">Exception</strong> <strong class="mv hi">as</strong> error:<br/>            <strong class="mv hi">raise</strong> error<br/>            <br/>    <em class="kk"># Input type - PIL Image, then we convert it to array      </em><br/>    <strong class="mv hi">elif</strong> isinstance(inp, PILImage.Image):<br/>        imageArray = np.asarray(inp, np.uint8)<br/>        <br/>    <em class="kk"># Input type - ndarray, then assign it to imageArray variable  </em><br/>    <strong class="mv hi">elif</strong> isinstance(inp, np.ndarray):<br/>        imageArray = inp<br/>        <br/>    <em class="kk"># Raise TypeError with input type is not supported</em><br/>    <strong class="mv hi">else</strong>: <br/>        <strong class="mv hi">raise</strong> <strong class="mv hi">TypeError</strong>("Input must be of Type - String or Path or PIL Image or Numpy array")<br/>        <br/>    <em class="kk"># Rearrange shape of the array so that it is pytorch compatible</em><br/>    <strong class="mv hi">if</strong> imageArray.ndim == 3: imageArray = imageArray.transpose(2, 0, 1)<br/>        <br/>    <em class="kk"># Convert Numpy array to Torch Tensor and move it to device</em><br/>    <strong class="mv hi">return</strong> torch.from_numpy(imageArray).to(device)</span></pre><p id="5b88" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">我们做了什么？</strong></p><p id="de1e" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们已经成功实现了这个用例所需的所有功能。由于<code class="du ms mt mu mv b">ndarray</code>是输出数据类型<code class="du ms mt mu mv b">tensor</code>之前的最后一个数据类型，我们首先将输入转换为每种支持的数据类型的<code class="du ms mt mu mv b">ndarray</code>，并在转换为<code class="du ms mt mu mv b">tensor</code>之前转置它。通过采用这种编码风格，我们能够避免将输入转换为每种支持的数据类型的值<code class="du ms mt mu mv b">tensor</code> &amp; <code class="du ms mt mu mv b">return</code>。相反，我们只在最后做一次。</p><p id="6278" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">在<code class="du ms mt mu mv b">isinstance</code>函数的帮助下，我们能够识别输入的数据类型，如果传递了任何不支持的数据类型，我们可以通过发出适当的错误消息<code class="du ms mt mu mv b">TypeError</code>来通知用户。io操作经常容易出错，所以如果数据类型是<code class="du ms mt mu mv b">str</code>或<code class="du ms mt mu mv b">Path</code>，我们读取<code class="du ms mt mu mv b">try</code> &amp; <code class="du ms mt mu mv b">except</code>块中的图像文件，让用户知道错误(如果有的话)。</p><p id="05fb" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">快速检查:</strong></p><p id="3db8" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">在我们继续之前，我们将编写一个助手函数来检查两个张量是否相同。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="7c61" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Test if two torch tensors are same or not</em><br/><strong class="mv hi">def</strong> is_same_tensor(tensor1, tensor2):<br/>    <strong class="mv hi">assert</strong> torch.eq(tensor1, tensor2).all(), "The Tensors are not equal!"<br/>    <strong class="mv hi">return</strong> <strong class="mv hi">True</strong></span></pre><p id="7f30" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">当编写一个测试函数时，最好抛出一个适当的错误，而不是简单的打印函数，它可能会隐藏在其他消息中。我们还将检查几件事情，并确保更新版本都是好的。</p><ol class=""><li id="7d4a" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mi mj mk ml bi translated"><em class="kk">最后两次迭代的函数输出是否相同？</em></li></ol><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="7c2a" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Verify that the output of two versions are same or not</em><br/>is_same_tensor(Tensor(filename), from_multiInput_toTensor(filename))</span></pre><p id="9513" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><em class="kk"> 2。对多种数据类型的支持有效吗？</em></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="1ce6" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Check the support for Path</em><br/>path = Path(Path.cwd(), filename).resolve()<br/>is_same_tensor(Tensor(filename), from_multiInput_toTensor(path))</span><span id="183f" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Check the support for PIL Image</em><br/>image = PILImage.open(filename).convert('RGB')<br/>is_same_tensor(Tensor(filename), from_multiInput_toTensor(image))</span><span id="0499" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Check the support for Ndarray</em><br/>imageArray = np.asarray(image, np.uint8)<br/>is_same_tensor(Tensor(filename), from_multiInput_toTensor(imageArray))</span></pre><p id="cf19" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><em class="kk"> 3。验证有效吗？</em></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="fc09" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Validate whether an error is thrown when user passes wrong file</em><br/>from_multiInput_toTensor('test.png')</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es ng"><img src="../Images/ddeb6ba23c05bc59f5811a2e5b819575.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*vv3sCO3krUCJYvVRJzBQMw.png"/></div></figure><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="7d7e" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Validate whether an error is thrown when input type is list</em><br/>from_multiInput_toTensor([filename])</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nh"><img src="../Images/0e838f6e4ad0502a7e176833d41d0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*c3xLGWCVlpc3PQnW-J6BXw.png"/></div></figure><p id="2f57" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">太好了！我们没有打碎任何东西。现在让我们像完成行为实现一样继续进行耐火化。</p><p id="ef84" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们可以改进什么？</p><ul class=""><li id="c38d" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mw mj mk ml bi translated">为了增加对多种数据类型的支持，我们写了一段类似意大利面条的代码。至少变量<code class="du ms mt mu mv b">imageArray</code>的生命周期是混乱的，这种类型的代码设计不是很直观，会让维护这个代码库的人生活在地狱里。当然，对于我们的简单用例来说这不是case，但本着编写更好的函数的精神，让我们避免这种类型的编码风格。</li><li id="4b88" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mw mj mk ml bi translated">函数名好了很多但还是不理想。为什么？因为它仍然没有清楚地说明函数的输入类型是什么。让用户用<code class="du ms mt mu mv b">TypeError</code>玩trail &amp; error肯定不是正确的编码方式。</li><li id="46e0" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mw mj mk ml bi translated">正如这个函数的名字所暗示的，它需要很多输入，这意味着我们在一个函数中有很多活动的部分。从长远来看，这可能会导致许多意想不到的副作用。</li></ul></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="5525" class="iw ix hh bd iy iz lk jb jc jd ll jf jg in lm io ji iq ln ir jk it lo iu jm jn bi translated">迭代3</h1><p id="0ee1" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><strong class="jq hi">目标:</strong></p><p id="7d5a" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">仔细研究了上一节的要点后，很明显我们需要将函数分成3个更小的函数。即每种数据类型一个函数。</p><p id="eea4" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">代码:</strong></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="cd06" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Import Libraries</em><br/><strong class="mv hi">import</strong> <strong class="mv hi">numpy</strong> <strong class="mv hi">as</strong> <strong class="mv hi">np</strong><br/><strong class="mv hi">import</strong> <strong class="mv hi">torch</strong><br/><strong class="mv hi">from</strong> <strong class="mv hi">PIL</strong> <strong class="mv hi">import</strong> Image <strong class="mv hi">as</strong> PILImage<br/><strong class="mv hi">from</strong> <strong class="mv hi">pathlib</strong> <strong class="mv hi">import</strong> Path, PurePath</span><span id="745c" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Change numpy array to torch tensor</em><br/><strong class="mv hi">def</strong> numpy_ToImageTensor(imageArray):<br/>    <br/>    <em class="kk"># if not type - ndarray then raise error</em><br/>    <strong class="mv hi">if</strong> <strong class="mv hi">not</strong> isinstance(imageArray, np.ndarray):<br/>        <strong class="mv hi">raise</strong> <strong class="mv hi">TypeError</strong>("Input must be of Type - Numpy array")<br/>    <br/>    <em class="kk"># Set Torch device to GPU if CUDA supported GPU is available</em><br/>    device = torch.device('cuda' <strong class="mv hi">if</strong> torch.cuda.is_available() <strong class="mv hi">else</strong> 'cpu')</span><span id="13ec" class="lp ix hh mv b fi nf nc l nd ne">    <em class="kk"># Transpose the numpy array before converting it to Tensor</em><br/>    <strong class="mv hi">if</strong> imageArray.ndim == 3: imageArray = imageArray.transpose(2, 0, 1)<br/>    <strong class="mv hi">return</strong> torch.from_numpy(imageArray).to(device)</span><span id="4bfb" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Change image to torch tensor</em><br/><strong class="mv hi">def</strong> pil_ToImageTensor(image):<br/>    <br/>    <em class="kk"># if not type - PIL Image then raise error</em><br/>    <strong class="mv hi">if</strong> <strong class="mv hi">not</strong> isinstance(image, PILImage.Image):<br/>        <strong class="mv hi">raise</strong> <strong class="mv hi">TypeError</strong>("Input must be of Type - PIL image")<br/>        <br/>    <em class="kk"># Convert the image to numpy </em><br/>    imageArray = np.array(image)<br/>    <br/>    <em class="kk"># Return output of numpy_ToImageTensor function</em><br/>    <strong class="mv hi">return</strong> numpy_ToImageTensor(imageArray)</span><span id="fea4" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Change image file to torch tensor</em><br/><strong class="mv hi">def</strong> file_ToImageTensor(file):<br/>    <br/>    <em class="kk"># if not input - string or Path then raise error</em><br/>    <strong class="mv hi">if</strong> <strong class="mv hi">not</strong> isinstance(file, (str, PurePath)):<br/>        <strong class="mv hi">raise</strong> <strong class="mv hi">TypeError</strong>("Input must be of Type - String or Path")<br/>        <br/>    <em class="kk"># Read the image from disk and raise error (if any)</em><br/>    <strong class="mv hi">try</strong>: <br/>        image = PILImage.open(file).convert('RGB')<br/>    <strong class="mv hi">except</strong> <strong class="mv hi">Exception</strong> <strong class="mv hi">as</strong> error:<br/>        <strong class="mv hi">raise</strong> error<br/>    <br/>    <em class="kk"># Return output of pil_ToImageTensor function</em><br/>    <strong class="mv hi">return</strong> pil_ToImageTensor(image)</span></pre><p id="3438" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们做了什么？</p><p id="2685" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">这是一个很好的进步，我们去掉了意大利面条式的代码，增加了模块化。现在就好像我们有一个三个函数的线性链，其中两个函数调用另一个函数，这样更容易理解和维护。</p><p id="75d2" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><code class="du ms mt mu mv b">file_ToImageTensor</code>-&gt;-<code class="du ms mt mu mv b">pil_ToImageTensor</code>-&gt;-<code class="du ms mt mu mv b">numpy_ToImageTensor</code></p><p id="f534" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">模块化使得添加新功能变得非常简单，并且易于测试，因为我们只需要修改一个特定的功能。为假设特征请求修改的函数的一些例子:</p><ol class=""><li id="f94e" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mi mj mk ml bi translated"><code class="du ms mt mu mv b">file_ToImageTensor</code> -也能读取黑色&amp;白色图像。</li><li id="ae0c" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><code class="du ms mt mu mv b">pil_ToImageTensor</code> -在将图像转换为张量之前调整其大小。</li></ol><p id="e416" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">请注意，即使您没有接触上述示例的其余代码，也最好测试其他函数，以避免任何意外。</p><p id="e960" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">随着输入类型变得更加具体，模块化设计也为更好的函数名和参数名铺平了道路。</p><p id="136d" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><code class="du ms mt mu mv b">from_multiInput_toTensor</code>-&gt;<code class="du ms mt mu mv b">file_ToImageTensor</code>-<br/><code class="du ms mt mu mv b">inp</code>-&gt;-<code class="du ms mt mu mv b">file</code></p><p id="4525" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">这些细微的变化可以使代码更加用户友好。老实说，在这一点上，我觉得我是在说教，所以我会尽快结束这个话题。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="ni nj l"/></div></figure></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><p id="fa87" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">快速检查:</strong></p><p id="beb0" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">这篇文章对我来说太长了，所以我不打算再测试负面的或不同的数据类型场景，只检查原始用例。耐火后你真的不应该跳过测试。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="acb4" class="lp ix hh mv b fi nb nc l nd ne">is_same_tensor(from_multiInput_toTensor(filename), file_ToImageTensor(filename))</span></pre><p id="2efd" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们可以改进什么？</p><ul class=""><li id="79f6" class="md me hh jq b jr km ju kn jx mf kb mg kf mh kj mw mj mk ml bi translated">看起来我们正在遵循相同的模式，用<code class="du ms mt mu mv b">isinstance</code>函数检查数据类型，并为每个函数引发<code class="du ms mt mu mv b">TypeError</code>，这也是一种代码重复。</li><li id="d8d2" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mw mj mk ml bi translated">好的，我们必须对函数名做些什么。我很确定没有人会记得这些名字，绝对不是未来的我。</li></ul></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="a38e" class="iw ix hh bd iy iz lk jb jc jd ll jf jg in lm io ji iq ln ir jk it lo iu jm jn bi translated">迭代4</h1><p id="a761" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><strong class="jq hi">目标:</strong></p><p id="34bf" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">借助类型调度改进文档并避免代码重复。</p><p id="5069" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">类型调度:</strong></p><p id="55d6" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">类型调度允许您根据函数接收的输入类型来改变函数的行为方式。这是Julia &amp; Swift等一些编程语言的突出特点。我们所要做的就是在函数前添加一个装饰器<code class="du ms mt mu mv b">typedispatch</code>。大概，论证容易解释难。</p><p id="57d3" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">类型调度示例:</strong></p><p id="d8a0" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">函数定义:</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="ded1" class="lp ix hh mv b fi nb nc l nd ne"><strong class="mv hi">from</strong> <strong class="mv hi">fastcore.all</strong> <strong class="mv hi">import</strong> *<br/><strong class="mv hi">from</strong> <strong class="mv hi">typing</strong> <strong class="mv hi">import</strong> List</span><span id="da41" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Function to multiply two ndarrays</em><br/>@typedispatch<br/><strong class="mv hi">def</strong> multiple(x:np.ndarray, y:np.ndarray ): <br/>    <strong class="mv hi">return</strong> x * y</span><span id="31a0" class="lp ix hh mv b fi nf nc l nd ne"><em class="kk"># Function to multiply a List by an integer</em><br/>@typedispatch<br/><strong class="mv hi">def</strong> multiple(lst:List, x:int): <br/>    <strong class="mv hi">return</strong> [ x*val <strong class="mv hi">for</strong> val <strong class="mv hi">in</strong> lst]</span></pre><p id="e9d1" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">调用第一个函数:</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="41ef" class="lp ix hh mv b fi nb nc l nd ne">x = np.arange(1,3)<br/>print(f'x is <strong class="mv hi">{</strong>x<strong class="mv hi">}</strong>')</span><span id="ad61" class="lp ix hh mv b fi nf nc l nd ne">y = np.array(10)<br/>print(f'y is <strong class="mv hi">{</strong>y<strong class="mv hi">}</strong>')</span><span id="f650" class="lp ix hh mv b fi nf nc l nd ne">print(f'Result of multiplying two numpy arrays: <strong class="mv hi">{</strong> multiple(x, y)<strong class="mv hi">}</strong>')</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es nk"><img src="../Images/b8400c5eecbce8f178cb2c328c06f63f.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*9RasySIQv3C98EeZYWU9Xw.png"/></div></div></figure><p id="3d68" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">调用第二个函数:</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="7fa3" class="lp ix hh mv b fi nb nc l nd ne">x = [1, 2]<br/>print(f'x is <strong class="mv hi">{</strong>x<strong class="mv hi">}</strong>')</span><span id="881a" class="lp ix hh mv b fi nf nc l nd ne">y = 10<br/>print(f'y is <strong class="mv hi">{</strong>y<strong class="mv hi">}</strong>')</span><span id="6890" class="lp ix hh mv b fi nf nc l nd ne">print(f'Result of multiplying a List of integers by an integer: <strong class="mv hi">{</strong>multiple(x, y)<strong class="mv hi">}</strong>')</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nl"><img src="../Images/bd1e51f5cd8e5cb3b7e4190d07067a1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*g7FDRFfmU4cFGfIkCoqVUQ.png"/></div></figure><p id="efa0" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">如果程序员不必在目的不变的情况下(针对各种数据类型)想出不同的函数名，他们的生活会好得多。如果这还不能鼓励你尽可能使用类型调度，那么我不知道还有什么可以🤷</p><p id="df1a" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们将使用<a class="ae kl" href="https://fastcore.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fastcore </a>包来实现<a class="ae kl" href="https://fastcore.fast.ai/dispatch.html#TypeDispatch" rel="noopener ugc nofollow" target="_blank">类型的分派</a>到我们的用例。有关fastcore和Type Dispatch的更多详细信息，请查看Hamel husa in<a class="ae kl" href="https://twitter.com/hamelhusain" rel="noopener ugc nofollow" target="_blank">的博客</a>。也可以看看<a class="ae kl" href="https://docs.fast.ai/" rel="noopener ugc nofollow" target="_blank"> fastai </a>，它启发了我写这篇文章。</p><p id="e68f" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">代码:</strong></p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="3f54" class="lp ix hh mv b fi nb nc l nd ne"><em class="kk"># Import Libraries</em><br/><strong class="mv hi">import</strong> <strong class="mv hi">numpy</strong> <strong class="mv hi">as</strong> <strong class="mv hi">np</strong><br/><strong class="mv hi">import</strong> <strong class="mv hi">torch</strong><br/><strong class="mv hi">from</strong> <strong class="mv hi">PIL</strong> <strong class="mv hi">import</strong> Image <strong class="mv hi">as</strong> PILImage<br/><strong class="mv hi">from</strong> <strong class="mv hi">pathlib</strong> <strong class="mv hi">import</strong> Path, PurePath<br/><strong class="mv hi">from</strong> <strong class="mv hi">fastcore.all</strong> <strong class="mv hi">import</strong> *<br/></span><span id="f516" class="lp ix hh mv b fi nf nc l nd ne">@typedispatch<br/><strong class="mv hi">def</strong> to_imageTensor(arr: np.ndarray) -&gt; torch.Tensor:<br/>    <em class="kk">"""Change ndarray to torch tensor.</em><br/><em class="kk">    </em><br/><em class="kk">    The ndarray would be of the shape (Height, Width, # of Channels)</em><br/><em class="kk">    but pytorch tensor expects the shape as </em><br/><em class="kk">    (# of Channels, Height, Width) before putting </em><br/><em class="kk">    the Tensor on GPU if it's available.</em><br/><em class="kk">    </em><br/><em class="kk">    Args:</em><br/><em class="kk">        arr[ndarray]: Ndarray which needs to be </em><br/><em class="kk">        converted to torch tensor</em><br/><em class="kk">    </em><br/><em class="kk">    Returns:</em><br/><em class="kk">        Torch tensor on GPU (if it's available)   </em><br/><em class="kk">    """</em><br/>    <br/>    <em class="kk"># Set Torch device to GPU if CUDA supported GPU is available</em><br/>    device = torch.device('cuda' <strong class="mv hi">if</strong> torch.cuda.is_available() <strong class="mv hi">else</strong> 'cpu')<br/>    <br/>    <em class="kk"># Transpose the array before converting to tensor</em><br/>    imgArr = arr.transpose(2, 0, 1) <strong class="mv hi">if</strong> arr.ndim == 3 <strong class="mv hi">else</strong> arr<br/>    <strong class="mv hi">return</strong> torch.Tensor(imgArr).to(device)<br/></span><span id="7a4c" class="lp ix hh mv b fi nf nc l nd ne">@typedispatch<br/><strong class="mv hi">def</strong> to_imageTensor(image: PILImage.Image) -&gt; torch.Tensor:<br/>    <em class="kk">"""Change image to torch tensor.</em><br/><em class="kk">    </em><br/><em class="kk">    The PIL image cast as numpy array with dtype as uint8,</em><br/><em class="kk">    and then passed to to_imageTensor(arr: np.ndarray) function</em><br/><em class="kk">    for converting numpy array to torch tensor.</em><br/><em class="kk">    </em><br/><em class="kk">    Args:</em><br/><em class="kk">        image[PILImage.Image]: PIL Image which </em><br/><em class="kk">        needs to be converted to torch tensor</em><br/><em class="kk">    </em><br/><em class="kk">    Returns:</em><br/><em class="kk">        Torch tensor on GPU (if it's available)   </em><br/><em class="kk">    </em><br/><em class="kk">    """</em><br/>    <strong class="mv hi">return</strong> to_imageTensor(np.asarray(image, np.uint8))<br/></span><span id="98c5" class="lp ix hh mv b fi nf nc l nd ne">@typedispatch<br/><strong class="mv hi">def</strong> to_imageTensor(file: (str, PurePath)) -&gt; torch.Tensor:<br/>    <em class="kk">"""Change image file to torch tensor.</em><br/><em class="kk">    </em><br/><em class="kk">    Read the image from disk as 3 channels (RGB) using PIL, </em><br/><em class="kk">    and passed on to to_imageTensor(image: PILImage.Image)</em><br/><em class="kk">    function for converting Image to torch tensor.</em><br/><em class="kk">    </em><br/><em class="kk">    Args:</em><br/><em class="kk">        file[str, PurePath]: Image file name which needs to</em><br/><em class="kk">        be converted to torch tensor</em><br/><em class="kk">    </em><br/><em class="kk">    Returns:</em><br/><em class="kk">        Torch tensor on GPU (if it's available)</em><br/><em class="kk">    </em><br/><em class="kk">    Raises:</em><br/><em class="kk">        Any error thrown while reading the image file,</em><br/><em class="kk">        Mostly FileNotFoundError will be raised.</em><br/><em class="kk">    </em><br/><em class="kk">    """</em><br/>    <strong class="mv hi">try</strong>: <br/>        img = PILImage.open(file).convert('RGB')<br/>    <strong class="mv hi">except</strong> <strong class="mv hi">Exception</strong> <strong class="mv hi">as</strong> error:<br/>        <strong class="mv hi">raise</strong> error<br/>    <strong class="mv hi">return</strong> to_imageTensor(img)<br/></span><span id="c9f6" class="lp ix hh mv b fi nf nc l nd ne">@typedispatch<br/><strong class="mv hi">def</strong> to_imageTensor(x:object) -&gt; <strong class="mv hi">None</strong>:<br/>    <em class="kk">"""For unsupported data types, raise TypeError. """</em><br/>    <strong class="mv hi">raise</strong> <strong class="mv hi">TypeError</strong>('Input must be of Type - String or Path or PIL Image or Numpy array')</span></pre><p id="0bc0" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">我们做了什么？</strong></p><p id="95f4" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">通过利用类型分派功能，我们成功地对所有3个函数使用了相同的名称，并且每一个函数的行为都因其输入类型而有所不同。随着输入类型的删除，函数名也缩短了。这使得函数名更容易记住。</p><p id="b288" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">通过调用函数名，我们可以看到该函数支持哪些不同的输入类型。默认情况下，Fastcore 需要两个输入参数，因为我们只将第二个参数指定为对象。第二个参数对函数行为没有任何影响。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="843f" class="lp ix hh mv b fi nb nc l nd ne">to_imageTensor</span><span id="227e" class="lp ix hh mv b fi nf nc l nd ne"># OUTPUT<br/>(ndarray,object) -&gt; to_imageTensor<br/>(Image,object) -&gt; to_imageTensor<br/>(str,object) -&gt; to_imageTensor<br/>(PurePath,object) -&gt; to_imageTensor<br/>(object,object) -&gt; to_imageTensor</span></pre><p id="8cab" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">在inspect模块的帮助下，我们可以访问特定函数的输入和输出类型。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="0326" class="lp ix hh mv b fi nb nc l nd ne"><strong class="mv hi">import</strong> <strong class="mv hi">inspect</strong><br/>inspect.signature(to_imageTensor[np.ndarray])</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nm"><img src="../Images/1d8b2623e88019bb26ab57d07efa17b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*KEYbtJU1owzFgKiEkS4-8A.png"/></div></figure><p id="4ac9" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">该迭代中实现的docstrings使代码更具可读性。特定输入类型的docstring可以通过调用<strong class="jq hi"> doc </strong>和输入类型来访问。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="3442" class="lp ix hh mv b fi nb nc l nd ne">print(to_imageTensor[np.ndarray].__doc__)</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nn"><img src="../Images/7f0121c50e306ad35a064ee71efb2e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*BViklpQzTP01a4Uqmj5Z5Q.png"/></div></figure><p id="cce3" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">正如上一节所讨论的，我们设法将<code class="du ms mt mu mv b">TypeError</code>消息移动到一个单独的函数中，其输入类型为<code class="du ms mt mu mv b">object</code>。</p><p id="2e8b" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><strong class="jq hi">快速检查:</strong></p><p id="050f" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">还在工作！</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="5861" class="lp ix hh mv b fi nb nc l nd ne">is_same_tensor(file_ToImageTensor(filename), to_imageTensor(filename))</span></pre><p id="abee" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">将不支持的数据类型传递给函数时验证错误消息。</p><pre class="ks kt ku kv fd mx mv my mz aw na bi"><span id="7282" class="lp ix hh mv b fi nb nc l nd ne">to_imageTensor([filename])</span></pre><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nh"><img src="../Images/0e838f6e4ad0502a7e176833d41d0b69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*c3xLGWCVlpc3PQnW-J6BXw.png"/></div></figure><p id="7089" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">我们可以改进什么？</p><p id="682e" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">这就是了。我想我们到此为止了。</p></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><h1 id="cf5e" class="iw ix hh bd iy iz lk jb jc jd ll jf jg in lm io ji iq ln ir jk it lo iu jm jn bi translated">结束语</h1><p id="a04f" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我们真的为这个用例编写了<em class="kk">最佳函数</em>吗？我想是的，但是不要相信我的话。你可以在这里找到本帖<a class="ae kl" href="https://github.com/6aravind/tidbits/blob/main/base/Write%20better%20python%20functions%20using%20type%20dispatch.ipynb" rel="noopener ugc nofollow" target="_blank">的笔记本版本</a>。如果你想给这篇文章添加什么，请随时通过<a class="ae kl" href="https://twitter.com/@6aravind" rel="noopener ugc nofollow" target="_blank">推特</a>或评论区联系我。我很乐意根据你的评论更新这篇文章。</p><p id="283a" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated">尽管当我开始写这篇文章时，类型调度是重点，但很快我意识到代码进化过程也同样重要。所以我决定把它也包括进去。我希望您喜欢这段编写python函数的旅程。</p><h1 id="2997" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">信用</h1><ol class=""><li id="c3b7" class="md me hh jq b jr js ju jv jx no kb np kf nq kj mi mj mk ml bi translated"><a class="ae kl" href="https://www.iconbros.com/icons/ib-b-video-card" rel="noopener ugc nofollow" target="_blank">显卡</a>图标由<a class="ae kl" href="https://iconbros.com/" rel="noopener ugc nofollow" target="_blank"> IconBros </a></li><li id="b581" class="md me hh jq b jr mm ju mn jx mo kb mp kf mq kj mi mj mk ml bi translated"><a class="ae kl" href="https://www.zwicon.com/" rel="noopener ugc nofollow" target="_blank">兹维康</a></li></ol></div><div class="ab cl ld le go lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="ha hb hc hd he"><p id="d926" class="pw-post-body-paragraph jo jp hh jq b jr km ii jt ju kn il jw jx ko jz ka kb kp kd ke kf kq kh ki kj ha bi translated"><em class="kk">原载于2021年4月10日https://www.analyticsvidhya.com</em><a class="ae kl" href="https://www.analyticsvidhya.com/blog/2021/04/write-better-python-functions-using-type-dispatch/" rel="noopener ugc nofollow" target="_blank"><em class="kk"/></a><em class="kk">。</em></p></div></div>    
</body>
</html>