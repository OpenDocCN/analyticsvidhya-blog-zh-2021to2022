<html>
<head>
<title>A comprehensive introduction to GNNs — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GNNs综合介绍—第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-comprehensive-introduction-to-gnns-part-2-8d8941a39b44?source=collection_archive---------1-----------------------#2021-10-22">https://medium.com/analytics-vidhya/a-comprehensive-introduction-to-gnns-part-2-8d8941a39b44?source=collection_archive---------1-----------------------#2021-10-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fc00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么是GNNs？</p><h1 id="db63" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">在你开始阅读之前</h1><p id="14de" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如标题所示，这是旨在向您介绍GNNs的系列出版物的第二部分。因此，我强烈推荐你看一下<a class="ae kf" href="https://nicolasraymond.medium.com/a-comprehensive-introduction-to-gnns-part-1-c07396fa3b91" rel="noopener">的第一部分</a>，其中我讨论了关于<strong class="ig hi">图</strong>、<strong class="ig hi">有向图</strong>和<strong class="ig hi">信息网络</strong>。</p><h1 id="8dba" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">我们在哪里？</h1><p id="42d7" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">该系列出版物旨在涵盖以下主题:</p><ul class=""><li id="82b9" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">图表</li><li id="ed36" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">有向图</li><li id="3e1c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">信息网络</li><li id="7fe6" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">【GNNs背后的动机</li><li id="bb58" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">节点嵌入</li><li id="6c67" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">香草GNN</li><li id="0fd4" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">图形卷积网络</li><li id="7e46" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">图形注意网络</li><li id="c571" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">异构图上的学习</li></ul><p id="83e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这部分将完全集中于第四个主题，GNNs背后的<strong class="ig hi">动机。</strong></p><h1 id="6c40" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">GNNs背后的动机</h1><p id="7bd7" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为什么是GNNs？我认为没有比用动机案例来介绍他们的目的更好的方法了！一旦动机案例成立，我将向你介绍解决问题的不同方法，并分析它们的优缺点。剧透警报！第一种方法可能有GNNs解决的缺点。</p><p id="8aba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面列出了将要讨论的方法:</p><ul class=""><li id="fd43" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><a class="ae kf" rel="noopener" href="/p/8d8941a39b44#86a0">基于特征的方法</a></li><li id="b29a" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><a class="ae kf" rel="noopener" href="/p/8d8941a39b44#6c4e">基于图形的方法</a></li><li id="fe0e" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><a class="ae kf" rel="noopener" href="/p/8d8941a39b44#6df9">表象学习方法</a></li><li id="9a70" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><a class="ae kf" rel="noopener" href="/p/8d8941a39b44#d8d2"> GNNs </a></li></ul><h1 id="e680" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">动机案例</h1><p id="658b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">你在这里，做一些关于社交网络的分析。这个网络非常简单，因为它只由通过友谊链接互相联系的用户组成。换句话说，它是一个<strong class="ig hi">同质信息网络</strong>，其中可能的对象类型(<strong class="ig hi">草书A </strong>)的集合中的唯一元素是“<strong class="ig hi">用户”</strong>，可能的链接类型(<strong class="ig hi">草书R </strong> ) <strong class="ig hi"> </strong>的集合中的唯一元素是“<strong class="ig hi">友谊”</strong>。除此之外，您知道每个用户有两个数字事实描述他们(一个<strong class="ig hi">向量</strong>和两个数字<strong class="ig hi">特征</strong>)。</p><p id="610c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你的一个讨厌的同事正在同一个社交网络上做分析，当你喝咖啡的时候，他过来打断你，说:“我刚刚给所有用户发了一份调查，问他们是否喜欢狗。除了第四个，大家都回答了。你知道我们如何预测他的答案吗？”。出于对狗的热爱和对研究的热情，你决定开始新的探索，回答你同事的问题。</p><p id="6bfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">知道图的结构、用户的特征以及用户<strong class="ig hi"> 1 </strong>和<strong class="ig hi"> 5 </strong>不喜欢狗(<strong class="ig hi"> t1 = t5 = 0 </strong>)而用户<strong class="ig hi"> 3 </strong>和<strong class="ig hi"> 2 </strong>喜欢狗(<strong class="ig hi"> t3 = t2 = 1 </strong>)的事实，有什么可能的方法来解决这个问题？</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/eca1a64fa0a35a0f57dee88dc2b5d9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qrbjkH2o1LjNX7dYdb_13g.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">动机案例。</figcaption></figure><h2 id="a7ba" class="lk jd hh bd je ll lm ln ji lo lp lq jm ip lr ls jq it lt lu ju ix lv lw jy lx bi translated">基于特征的方法</h2><p id="86a0" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这种情况的一个选择是考虑我称之为“基于<strong class="ig hi">特征的</strong> <strong class="ig hi">方法</strong>”。对于基于特征的方法，我的意思是只考虑与图中对象相关的特征，从而抽象出它们之间的联系的解决方案。</p><p id="1ff6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仅列举其中一些，您可以考虑以下方法:</p><ul class=""><li id="81ce" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">K-最近邻算法(<strong class="ig hi"> KNN </strong>)</li><li id="3445" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">训练前馈神经网络(<strong class="ig hi"> FNN </strong>)</li></ul><p id="3b5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在动机的情况下，使用KNN算法，你可以简单地找到与用户<strong class="ig hi"> 4 </strong>最近的k个用户，这是根据你使用他们的数字特征和你喜欢的度量(例如欧几里德距离、马氏距离、余弦相似性等)计算出的他们之间的距离。).然后，你可以让这些回答调查的k个最近的用户投票决定这个用户是否喜欢狗。在0和1的计数中的大多数将会赢！</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/085eebbe4f2683c55185bd0ac05bba22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gk0FoYSc3tgEdS9eFCjXSA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">基于特征的方法的思想。</figcaption></figure><p id="d5a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果你熟悉神经网络的主题，你可能会想为什么我建议训练一个FNN作为我们问题的潜在解决方案，因为考虑到缺乏训练数据，这样的模型(例如多层感知器)在我们的玩具问题中不是一个真正方便的选择。</p><p id="bc65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为这个解决方案在有更多用户的环境中是可行的，我想花一点时间从一个你可能从未见过的角度向你展示FNN的想法。后面和GNNs做更深层次的比较也会有帮助。</p><p id="b44c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我喜欢把FNN分成两部分。第一部分是一个函数(<strong class="ig hi"> f </strong>)，它将原始特征(<strong class="ig hi"> x </strong>)作为输入，并通过一系列线性和非线性变换层对其进行处理。第二部分是另一个函数(<strong class="ig hi"> g </strong>)，它采用处理后的特征(<strong class="ig hi"> f </strong> ( <strong class="ig hi"> x </strong>))，并使用它们来预测与原始输入特征相关联的<strong class="ig hi">标签</strong>。这里，<strong class="ig hi">标签</strong>指的是与输入相关联的<strong class="ig hi">目标</strong>。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/f240060829543180757564da65e2e9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sQzoqAH1mFkLr0nV1sEpSw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">组成FNN的函数的定义。</figcaption></figure><p id="6685" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，两个部分一起训练和工作，以便做出最好的预测。函数<strong class="ig hi"> f </strong>将努力对输入的<strong class="ig hi">丰富版本进行编码，而函数<strong class="ig hi"> g </strong>将尽最大努力使用它们来做出最准确的预测。</strong></p><p id="f590" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，在当前上下文中，<strong class="ig hi"> f </strong>将学习如何获取每个用户的两个特征向量(2D向量),并将其转换为对描述用户可能更有意义的另一个向量(不一定具有相同的长度)。从这个新的表示中，<strong class="ig hi"> g </strong>将学习如何预测0和1之间的值，该值表示用户喜欢狗的概率。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/852158968f3f03067e56d53b88d30db4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xsp0LCsMrRBygNTr8EMEw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">将FNN可视化为函数的组合。</figcaption></figure><p id="3034" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对数学领域不感兴趣，你可以看看下图，我在一个只有一个隐层的简单神经网络中指出了编码函数<strong class="ig hi"> f </strong>和预测函数<strong class="ig hi"> g </strong>。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/f070b22148b2420be257bb4ba0af7f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lo80Yg5wobGQKBSA5w56g.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">简单FNN结构的可视化。</figcaption></figure><p id="7c9f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为本节的总结，让我们来看看当我们将基于特征的方法应用于数据采用信息网络形式的问题时，其中每个对象/节点都具有特征的主要优点和缺点。</p><p id="fafc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优势:</p><ul class=""><li id="ec9a" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">它们在网上有很好的记录。您可以很容易地找到代码片段来帮助您完成您想要的任务。</li><li id="d8d0" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">当需要推断与新输入相关联的标签时，它们是有效的。如果我们有狗的特征，我们可以很快预测第6个用户是否喜欢狗。</li></ul><p id="1a92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缺点:</p><ul class=""><li id="fdf6" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">它们不考虑图中对象之间的现有关系。</li></ul><h2 id="1f2f" class="lk jd hh bd je ll lm ln ji lo lp lq jm ip lr ls jq it lt lu ju ix lv lw jy lx bi translated">基于图形的方法</h2><p id="6c4e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们动机案例的第二个选项是采用<strong class="ig hi">“基于图表的方法”</strong>。这意味着，我们可以假设连接的用户更可能有相同的标签，并且只关心我们网络背后的图形结构。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/c8c6755bd29b6f6bb61fc3c7056835bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wfzrTCQNJAJOnjwGaly0hQ.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">基于图的方法的思想。</figcaption></figure><p id="531b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一节中，我们将完全专注于一种叫做<strong class="ig hi">标签传播</strong>的技术。这种技术背后的思想是简单地通过传播周围带标签邻居的标签来推断图中缺失的标签。在当前的动机案例中，我们有很多方法可以做到这一点。然而，由于标签传播不是这篇文章的主题，我将只关注一个食谱。</p><p id="2811" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设社交网络中每个用户关联的标签代表了其喜欢狗的概率。这是有意义的，因为我们用0来标识不喜欢狗的人，否则用1。我们的第一步可以是为所有没有回答调查的用户设置相同的<strong class="ig hi">临时标签</strong> ( <strong class="ig hi"> delta </strong>)。例如，在这里，我们会说，没有回答调查的每个人都有同样多的机会不喜欢或喜欢狗，并给他们0.5分。尽管如此，如果您有先验知识，认为不同的数字更准确，您可以在0和1之间设置另一个值。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/5593b73100ce7e003b80abd6d3c8e933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AU_jxduS4UZszrlPTTXRbw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">临时标签分配。</figcaption></figure><p id="7dda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，从这个图我们可以计算出<strong class="ig hi">转移矩阵</strong> ( <strong class="ig hi"> M </strong>)。</p><p id="0763" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如下图所示，有向图的<strong class="ig hi">转移矩阵</strong>是<strong class="ig hi">出度矩阵</strong>和<strong class="ig hi">邻接矩阵</strong>的逆的乘积。换句话说，转移矩阵就像邻接矩阵，我们将每一行标准化，使它们的元素总和为1。</p><p id="df45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更好地理解其含义，您可以将转移矩阵的第I行和第j列的每个元素解释为在节点I的邻居中随机选取节点j的概率。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/2b142437ec402ad75d6e6dbe04e6e618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B9WImAxSN2BddIHm7kX4dw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">转移矩阵的定义和可视化。</figcaption></figure><p id="7a52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，有了所有这些要素，我们可以继续下面的迭代标签传播过程。该算法的思想是通过对<strong class="ig hi">他们自己的原始标签</strong>和<strong class="ig hi">他们邻居标签</strong>的当前平均进行加权平均来连续更新用户的标签。当来自两次连续迭代的标签之间的绝对差低于某个阈值时，可以预先定义迭代的次数，或者可以停止该过程。对于加权平均，也可以使用不同的<strong class="ig hi">α</strong>值来增加或减少原始标签的重要性。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/ebaae6e0ae9b0f624f98f77d38052374.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Znvc3GJ8ZrYp66TbHbw2WQ.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">标签传播算法的一个例子。</figcaption></figure><p id="ed68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦算法完成，您将能够在生成的列矩阵中找到您正在寻找的丢失的标签。</p><p id="7d85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里你可以看到两次迭代后得到的结果。在这种情况下，我们期望第4个用户喜欢狗，因为29/50 &gt; 0.5。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/91b47ac57ebc18ff09db975cd9048a24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*347-RGYnQnjZfJSXqPxC0A.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">标签传播执行。</figcaption></figure><p id="7dbc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了总结这一节，让我来指出基于图的方法的主要优点和缺点。</p><p id="be89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优势:</p><ul class=""><li id="3334" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">他们考虑图的结构属性。</li></ul><p id="7cc1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缺点:</p><ul class=""><li id="6205" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">他们不考虑与图形中的对象相关的特征。</li><li id="2b21" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">如果以后有新的不可见节点加入图中，标签传播模型将不再可用。我们将不得不再次运行整个事情。</li></ul><h2 id="4fe3" class="lk jd hh bd je ll lm ln ji lo lp lq jm ip lr ls jq it lt lu ju ix lv lw jy lx bi translated">表征学习方法</h2><p id="6df9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">解决动机案例问题和回答你同事问题的第三种方法是使用<strong class="ig hi">表征学习方法</strong>。</p><p id="7091" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法背后的思想是，对于每个节点，学习一个低维矢量表示(一个嵌入的<strong class="ig hi"> z </strong>)，它同时捕获图形的结构属性和来自特征的信息。换句话说，这些方法旨在找到一种用一系列数字(嵌入的<strong class="ig hi"> z </strong>)来表示每个用户的方式，这些数字结合了关于其特征及其在图中位置的有意义的信息。</p><p id="6b62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我喜欢将表征学习方法分为两大类:</p><p id="a26c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1图自动编码器</p><p id="bea7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于2-skip程序的算法</p><p id="5cbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一类包含专注于学习节点表示(<strong class="ig hi">θ</strong>)的策略，只考虑图形结构。然后，这些表示可以连接到原始特征，以便最终嵌入(<strong class="ig hi"> z </strong>)，可以使用我们前面介绍过的基于特征的方法进行管理。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/f23455c5c63aa220711cb5d8bcc05cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L7A1zXWvpibOceqnV3Z6TA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">FNN嵌入的用法。</figcaption></figure><p id="26b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二类包含使用名为Skipgram的语言模型改编的策略，以便同时考虑图形结构和特性来产生节点的表示。</p><p id="909f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管最后一类真的很有趣，我强烈建议您阅读DeepWalk和Node2Vec之类的方法，但在本节的剩余部分，我将只解释<strong class="ig hi">图形自动编码器</strong>的功能。</p><p id="6a89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图形自动编码器由两部分组成，分别是<strong class="ig hi">编码器</strong>和<strong class="ig hi">解码器</strong>。编码器是一种功能，其目的是将每个节点映射到矢量表示。解码器是一种功能，其目的是从节点的矢量表示中恢复图形的邻接矩阵中最初与其相关联的完整行。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/bfb1c654b3d1a546dcf3eef1e343fbb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkE0Cw51wcnbASXeZvELiw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">图形自动编码器的编码器和解码器。</figcaption></figure><p id="f128" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图形自动编码器的一个很好的例子是结构化深度网络嵌入(SDNE ),其中编码器和解码器是神经网络。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/cd0db011d315f7933cd7d29fded41a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DUluQJrF2QueTSXiVaEypA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">SDNE编解码器的可视化。</figcaption></figure><p id="d59e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了一起训练两个神经网络，损失函数由下面给出的两部分构成。</p><p id="49d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一部分允许模型以<strong class="ig hi">两个连接的节点必须从编码器</strong>给出相似的输出为目标进行训练。第二部分允许模型以<strong class="ig hi">解码器必须能够从编码中找到最准确的邻接矩阵行</strong>为目标进行训练。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/5a5fbb05e794add2113eb8a8d09e4a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cybWo_nO_oRQCAfITRENEQ.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">SDNE损失函数的第一部分。</figcaption></figure><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/fd7aca4d348d012d1c6526688a6cdbe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NKUzRcVqoZceucwvWgLBUw.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">SDNE损失函数的第二部分。</figcaption></figure><p id="2473" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，正如我对其他方法所做的一样，我将展示表征学习方法的优点和缺点。</p><p id="185b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优势:</p><ul class=""><li id="369c" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">结合原始特征和网络结构信息。</li><li id="5aa8" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">生成潜在表示的函数的训练独立于任务，并且新的嵌入(<strong class="ig hi"> z </strong>)可以被重新用于不同的目的。</li></ul><p id="df32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缺点:</p><ul class=""><li id="4a56" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">他们没有学习到一种嵌入方法，这种方法可以推广到加入图中的新的看不见的节点。</li><li id="f817" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">如果这些嵌入是为我们的任务而精确学习的，那么它们会更有意义。</li></ul><h2 id="a46e" class="lk jd hh bd je ll lm ln ji lo lp lq jm ip lr ls jq it lt lu ju ix lv lw jy lx bi translated">GNNs</h2><p id="d8d2" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">既然我们已经看到了许多可以用来处理动机案例的方法，也看到了它们的优缺点，我们现在可以列出一系列我们的梦想模型应该遵守的标准。嗯，也许不是你的梦想，但仍然是你喜欢的模式，让你通过这个旅程！</p><p id="b78f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些标准是:</p><ul class=""><li id="716d" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">该模型应该考虑特征和网络，以便当我们预测节点的标签时，我们可以从相似/连接的其他节点的信息中受益。</li><li id="1741" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">一旦经过训练，模型应该能够推广到其他看不见的节点，而无需再次训练整个系统。</li><li id="46fa" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">模型应该有一个名字，当你在会议上讨论它时，这个名字听起来很酷。</li></ul><p id="d6e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们怎么做呢？如下图所示，我们可以将表征学习方法的嵌入思想提升到另一个层次，从而得到一个完美的配方！</p><p id="7d95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一步可能是构建一个函数(<strong class="ig hi"> q </strong>)，该函数创建节点嵌入，这些嵌入封装了来自它们自己的特征以及它们邻居的特征的信息。因此，<strong class="ig hi"> q </strong>将同时考虑特征和图的结构属性。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/1d442f6beed1374d6c3cfea446f192d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coHMQfwu3VaSfFSBARiIXA.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">来自GNN嵌入函数的期望。</figcaption></figure><p id="3e55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，第二步是将这个奇妙的功能连接到前面介绍的原始FNN框架，以便可以训练<strong class="ig hi"> q </strong>来生成特定于任务的嵌入。</p><figure class="kv kw kx ky fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ku"><img src="../Images/11d9d22772ecf20325a2de1224c07df6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GoaTSTDDEa7_EIwT05w6XQ.jpeg"/></div></div><figcaption class="lg lh et er es li lj bd b be z dx translated">将GNN可视化为函数的组合。</figcaption></figure><p id="9a6a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">嗯，我有个好消息告诉你。这个美味的食谱是存在的，叫做<strong class="ig hi">图形神经网络</strong> ( <strong class="ig hi"> GNN </strong>)！</p><p id="c69d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然你已经意识到GNNs背后的动机，我邀请你阅读我的下一篇文章，我们将探索不同的GNN模型，从香草GNN开始，然后进入图形注意力网络(GAT)。</p><h1 id="86f5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">在你走之前</h1><p id="aa09" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">感谢您的阅读！请随意访问我的LinkedIn页面。</p><h1 id="d0b4" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><p id="1bce" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">王、、、<em class="ly">。2016.</em>结构化深层网络嵌入<em class="ly">。第22届ACM SIGKDD知识发现和数据挖掘国际会议论文集(KDD '16)。</em>计算机械协会，美国纽约州纽约市，1225–1234。DOI:https://DOI . org/10.1145/29395363637</p><p id="7e36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">格罗弗，阿迪亚和朱尔·莱斯科维奇。" Node2vec:网络的可扩展特征学习."<em class="ly">ArXiv:1607.00653【Cs，Stat】</em>，2016年7月，<a class="ae kf" href="http://arxiv.org/abs/1607.00653." rel="noopener ugc nofollow" target="_blank">http://arxiv.org/abs/1607.00653.</a></p><p id="46d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结合标签传播和简单模型优于图形神经网络。<em class="ly">ArXiv:2010.13993【Cs】</em>2020年11月<a class="ae kf" href="http://arxiv.org/abs/2010.13993." rel="noopener ugc nofollow" target="_blank">http://arxiv.org/abs/2010.13993.</a></p><p id="76dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">《深度行走:社会表征的在线学习》第20届ACM SIGKDD知识发现和数据挖掘国际会议论文集—KDD’14，ACM出版社，2014年，第701–10页，doi:10.11145/2624063647</p></div></div>    
</body>
</html>