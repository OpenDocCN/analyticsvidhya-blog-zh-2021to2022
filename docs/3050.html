<html>
<head>
<title>Introduction to MapReduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MapReduce简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-mapreduce-a98f3c80febc?source=collection_archive---------8-----------------------#2021-05-31">https://medium.com/analytics-vidhya/introduction-to-mapreduce-a98f3c80febc?source=collection_archive---------8-----------------------#2021-05-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/95456e450315ef784ecd80289ff669d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*319QX7YquIiHcl-m-Alh7g.jpeg"/></div></div></figure><h1 id="1a5c" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是MapReduce？</h1><p id="ce86" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">MapReduce是一个用于大型作业的分布式并行处理的编程框架。它最初是由Google在2004年推出的，并由Hadoop推广开来。MapReduce的主要动机是，分布在大型机器集群上的计算密集型作业需要一种简单的方法来以并行、可扩展和容错的方式管理它们。</p><p id="4ede" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">MapReduce的主要思想是，通过使用map和Reduce阶段将一个复杂的作业拆分为多个任务，可以将该作业进行分布式并行处理。每个阶段将使用许多工作线程，每个工作线程将执行一个用户定义的map函数或reduce函数。</p><h1 id="ec8a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是Map和Reduce函数？</h1><p id="6956" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">一个<strong class="jp hi">映射函数</strong>获取一大块作业输入，并执行一些用户定义的逻辑来输出一个键值对列表。</p><p id="3640" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">一个<strong class="jp hi"> reduce函数</strong>接受一组共享同一个键的键-值对，并执行一些用户定义的逻辑来输出该键的单个值。</p><h1 id="30eb" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">例子</h1><p id="e368" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">下面是一个简单的MapReduce示例，其中map函数计算输入字符串中每个字母的出现次数，Reduce函数计算特定字母的总出现次数。</p><p id="9756" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">每个灰色框表示map和reduce任务的输入或输出数据。在MapReduce中，这种中间数据通常存储在分布式文件系统中，如HDFS。</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/d7ce2c0ea714abc273790e965b93f6cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1348/format:webp/1*oKHlh8zINKTqhSosUqpgrw.png"/></div></figure><p id="9fce" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">请注意初始输入的拆分，以及map函数的输出到reduce函数的输入的混合和排序。这些步骤由MapReduce框架自动完成。</p><h1 id="f9d3" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">容错</h1><p id="f3e8" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">使用MapReduce最大的优势之一就是容错性。每个map和reduce任务都是独立执行的，如果一个任务失败，它会自动重试几次，而不会导致整个作业失败。这样，如果出现硬件故障等暂时问题，或者有意停止任务以释放资源用于更重要的任务，MapReduce任务可以使用相同的输入数据轻松重试。</p><p id="1d2b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">为了确保重试不会产生任何意外的后果，MapReduce函数必须在不改变输入的情况下产生输出，并且不能有任何副作用。如果实现正确，有失败任务但重试后最终成功的MapReduce作业应该与成功执行且没有任何失败任务的作业产生完全相同的输出。</p></div></div>    
</body>
</html>