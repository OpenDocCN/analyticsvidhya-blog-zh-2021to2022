# 行方式操作的多列输出。

> 原文：<https://medium.com/analytics-vidhya/multiple-column-output-from-row-wise-operations-422921ae5dbf?source=collection_archive---------22----------------------->

我想谈谈在熊猫身上做大量数据工程和分析时经常出现的一个场景。

我们都知道，Pandas 的一大优势是能够向整个数据阵列广播功能，并轻松转换大量数据。除了像 mean()、sum()等内置函数之外，pandas 还允许您在几行代码中对整个数组应用自定义函数。这是通过对数据帧应用()方法来实现的。

我们已经通过对现有列应用函数生成了新的 pandas 列。我发现自己不止一次地想要从一个函数中生成多个列。这样，我可以一次完成多个计算或操作。

我举个具体的例子。最近，我发现自己在做一个项目，涉及评估“新闻”文章，以确定它们的准确性、政治倾向以及它们是否包含仇恨言论。针对仇恨言论，我使用 CountVectorizer 将我的数据集中每篇文章中已知的仇恨词汇和短语的数量制成表格。

如果您还记得的话，CountVectorizer 会生成一个术语矩阵，以及它们在输入到其中的每个文本体中的出现次数(然后您可以将其连接回原始数据集)。我想接下来做一些事情。我想将每个短语的点击数乘以与仇恨言论相关的已知概率，然后将这些相加，得出一个“仇恨得分”。我还想要一个点击总数，以及一个包含每个找到的短语和它被找到的次数的字典。

我的最终数据集将有三个新列:“仇恨得分”、“仇恨计数”和“仇恨术语”。最好的方法是在数据帧上使用 apply 函数，并让它逐行运行。我发现最好的方法是在 apply 方法中使用 lambda 函数和自定义函数。

这是应用函数的样子:

> df _ vectors = df _ vectors . apply(*lambda*row:tally _ counts _ doc(row)，axis=1，result_type='expand ')

这是如何工作的。如果您将一个 lambda 函数传递给 apply()，它会将它逐个应用到行中。传递给 lambda 函数的是整行，它是作为熊猫系列传递的。此序列的索引是原始表中的列名，值是这些列中每一列的行中的值。然后，您可以对该系列进行切片、读取和修改。注意，我们必须将 apply 方法中的“axis”参数指定为“1”。这是为了确保它逐行通过。如果我们想遍历列，我们可以将 axis 指定为“0 ”,这将把列作为一个序列返回。

我发现这是一个强大的功能。尤其是与在行序列上操作的自定义函数结合使用时。例如，在上面的代码中，lambda 函数将行(作为一个序列)传递给“tally_counts_doc”。让我们来看看这个函数:

> *def* tally_counts_doc( *行*):
> 
> row2 = row[row > 0]
> 
> 分数= 0
> 
> 点击数= {}
> 
> 对于 index，row2.items()中的 val:
> 
> 点击数[索引]=值
> 
> hit = dict _ hate weights[index]* val
> 
> 得分+=命中
> 
> row['仇恨分数'] =分数
> 
> row['仇恨 _ 点击'] =点击
> 
> 返回行

如我们所料，这个函数接受一行作为输入(同样，以序列的形式)。回想一下，这个数据框架由原始文章和短语计数向量矩阵组成。因此，大多数列都是 0 或 null，毕竟我们是从稀疏矩阵中得到这部分 DF 的。我们只对那些值大于 0 的列感兴趣。多亏了 lambda 函数，这很容易，因为我们可以简单地将整行作为一个序列，然后用基本的序列过滤语法(row2 = row[row > 0])对其进行过滤。

但是，一旦我们将行作为一个系列获得，回想一下我们想要对它执行多个操作并获得多个输出，我们想要将每个输出添加为第二列。由于在 apply 方法中使用了 lambda 函数，这就像向 row-Series 添加一个新项目一样简单。序列中代表原始行的新行，例如:

> row['仇恨分数'] =分数
> 
> row['仇恨 _ 点击'] =点击

一旦函数对行执行了操作并向其中添加了“列”(实际上是表示原始行的序列的行)，它就可以简单地将新行返回给 lambda 函数，然后 lambda 函数将它传递回原始数据帧。这里再说明一点；除了 apply 方法中的 axis 参数之外，还必须将关键字参数“result_type”指定为“expanded”。这给了 Pandas 一个提示，它将获得一个包含新列的行，并需要将它们添加到原始数据帧中。

简单。通过这种方式，您可以一次对一行运行多个操作，而不是重复地将它加载到内存中。希望这将有助于更快更干净的代码。

我希望你觉得这有用！