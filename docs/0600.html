<html>
<head>
<title>Identify people through their Google Search based on typing behaviour</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">根据打字行为通过谷歌搜索识别用户</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-extract-keystroke-biometrics-from-encrypted-google-search-traffic-2772aaa47ed9?source=collection_archive---------16-----------------------#2021-01-23">https://medium.com/analytics-vidhya/how-to-extract-keystroke-biometrics-from-encrypted-google-search-traffic-2772aaa47ed9?source=collection_archive---------16-----------------------#2021-01-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0c47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如何从加密的谷歌搜索流量中提取击键生物特征？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/644c3c0f2c9cadd0890b7f41b43685e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VwkEnYRtjM0Xz8nhvj_mcQ.png"/></div></div></figure><h1 id="b655" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">简介</strong></h1><p id="8e41" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">个人资料的概念是一般资料保护条例的基本要素。它包括与已识别或可识别的自然人有关的所有信息。在GDPR的框架内，试图特别保护这些数据。而且通过所谓的元数据，也可以得出关于个人身份的结论，而元数据并没有受到GDPR的明确保护。搜索引擎的搜索建议功能(SSF)提供了从结果元数据中分配信息的可能性。</p><blockquote class="kr ks kt"><p id="1d38" class="ie if ku ig b ih ii ij ik il im in io kv iq ir is kw iu iv iw kx iy iz ja jb ha bi translated">搜索引擎的搜索建议功能(SSF)是基于已经输入的键入序列自动建议和完成可能的搜索查询。</p></blockquote><p id="6aae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该功能通过在输入搜索查询时记录网络数据流以及相关网络数据包的标识，使得当用户基于这些数据包输入键盘时测量生成的打字生物测定成为可能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ky"><img src="../Images/499423bbe07696b0724505895a1967b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mScXNMldiWyOjJaHx2oQg.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated"><a class="ae ld" href="https://doi.org/10.1186/s13635-020-0100-8" rel="noopener ugc nofollow" target="_blank">资料来源</a>:加密领域的击键生物测定学:由Nicholas Whiskerd、Nicklas Kö rtge、Kris Jürgens、Kevin lamshft、Salatiel Ezennaya-Gomez、Claus Vielhauer、Jana Dittmann和Mario Hildebrandt编写的关于网络搜索引擎的搜索建议功能的首次研究，<a class="ae ld" href="https://creativecommons.org/licenses/by/4.0/" rel="noopener ugc nofollow" target="_blank"> CC BY 4.0 </a></figcaption></figure><p id="f59b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该图显示了单词“天气”的输入和击键生物测定之间的关系。击键间时间(这些是表示两次击键之间经过时间的时间值)可以根据打字序列的包的时间戳来计算和评估。</p><p id="a1d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文描述了如何从网络流量的快照中提取这些相关的数据包。</p><p id="3980" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更多的理论背景，请看这篇<a class="ae ld" href="https://jis-eurasipjournals.springeropen.com/articles/10.1186/s13635-020-0100-8" rel="noopener ugc nofollow" target="_blank">论文</a>。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="2b7d" class="jo jp hh bd jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh lp kj kk kl bi translated"><strong class="ak">接近</strong></h1><p id="35a1" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">实现提取生物特征信息的功能的技术途径是，将解决方案划分到不同的组件上。首先，Wireshark会嗅探网络流量。为了向我们自己的应用程序提供捕获的流量，数据将被存储到一个PCAP文件中。开发的软件将访问这些数据，并对其应用过滤器。过滤器包含一组值，模式算法使用这些值提取每个击键序列的相关数据包。由此，击键间时间可以被计算为击键生物测定的可测量表示。</p><ul class=""><li id="b207" class="lq lr hh ig b ih ii il im ip ls it lt ix lu jb lv lw lx ly bi translated"><strong class="ig hi">网络流量:</strong> <a class="ae ld" href="https://www.wireshark.org/" rel="noopener ugc nofollow" target="_blank"> Wireshark </a>用于捕获网络流量。结果将导出为PCAP文件(Wireshark/tcpdump/…-pcap)。</li><li id="1004" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">过滤器:</strong>为了配置算法的不同参数，为每个不同的环境创建一个额外的过滤器。</li><li id="283f" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">击键生物特征:</strong>击键生物特征将以<a class="ae ld" href="https://www.cs.waikato.ac.nz/ml/weka/arff.html" rel="noopener ugc nofollow" target="_blank"> ARFF </a>格式导出为击键间时间。</li></ul></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="cd30" class="jo jp hh bd jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh lp kj kk kl bi translated"><strong class="ak">实现</strong></h1><p id="96d7" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">前言:本文仅涵盖并解释了应用程序的主要逻辑。完整的程序可在<a class="ae ld" href="https://github.com/n1ckl0sk0rtge/KeystrokeExtractor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</p><p id="24d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了捕获在PC上使用Firefox的用户的击键，配置文件如下所示:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="bd28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该文件包含五个不同的部分和一些子部分:</p><ul class=""><li id="1120" class="lq lr hh ig b ih ii il im ip ls it lt ix lu jb lv lw lx ly bi translated"><strong class="ig hi"> IP版本</strong> : IP版本:此处最初指定IP版本。由于可能会自动检测使用的IP版本，此选项在未来版本中可能会过时。目前，所使用的IP版本必须通过配置文件提供。</li><li id="d008" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">端口</strong>:该值指定目的端口，通过该端口过滤网络流量。</li><li id="06a7" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">输入短语:</strong>输入短语值可配置为将识别的击键与输入短语的实际预期字母进行比较。该选项是开发过程中质量检查的一部分，仅在网络流量被解密且盲模式关闭时可用。</li><li id="dd87" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">系统:</strong>这个字符串值定义了生成搜索查询的系统。不同的设备类型和操作系统会影响哪种模式算法可用于检测网络流量中的数据包。Web浏览器只影响窗口大小(下一个要点)，但对搜索正确网络数据包的逻辑过程没有影响。</li><li id="4e55" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi"> Windows: </strong>这部分配置最重要。它定义了模式算法将从击键流中检测不同类型的包的范围，例如序列的第一个(开始)包。有关不同值的更详细解释，请参见模式算法的解释。</li><li id="2d53" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">错误流计数器:</strong>该值规定了在模式算法返回当前打字序列结束且可能开始新序列之前，检测到的不属于击键流的数据包的最大数量。</li></ul><h2 id="98a8" class="mg jp hh bd jq mh mi mj ju mk ml mm jy ip mn mo kc it mp mq kg ix mr ms kk mt bi translated">模式算法</h2><p id="adc3" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">模式算法构成了这个应用程序的主要逻辑。下面的代码是通过不断的测试创建和改进的，直到结果足够好。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es mu"><img src="../Images/efc40d4161fb189c85900b9253436660.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FHuVwIu_vftT9P66NUJkvQ.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">在PC上使用firefox时，从输入序列中检测到的软件包模式。</figcaption></figure><p id="408e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开发从击键流中识别数据包的模式算法之前，必须首先定义实际的模式。用于搜索和键入。在PC上使用Firefox的Google搜索引擎中，模式看起来如上图所示。对应于输入的第一次键击的第一分组的大小在220和350字节的范围内。为了识别这是击键流的第一个包，下一个包(来自按目的地端口、目的地IP和TCP有效载荷预过滤的包序列)的大小在200和270字节之间。作为该击键序列的一部分的任何其他传入分组的大小在200到280字节的范围内，并且不大于或小于前一分组的大小加或减25字节。如果在最后一个有效包之后，检测到超过10个(错误流计数器)包不满足作为键击流一部分的包的要求(大小在200和280之间，与前一个相比+/- 25字节),则键击序列终止。</p><p id="e414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在模式算法的实现中，网络流首先通过以下方式过滤:</p><ul class=""><li id="d901" class="lq lr hh ig b ih ii il im ip ls it lt ix lu jb lv lw lx ly bi translated"><strong class="ig hi">目的端口</strong>:检查目的端口是否为443</li><li id="be38" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">目的IP </strong>:检查数据包的目的IP地址是否是来自Google的地址</li><li id="ee91" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated"><strong class="ig hi">有效载荷</strong>:检查包装中是否包含有效载荷</li></ul><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="5687" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果网络流的数据包满足所有三个要求，则调用<code class="du mv mw mx my b">lookup_for_new_stream()</code>函数，通过调用<code class="du mv mw mx my b">is_new_stream</code>来检查该数据包是否可能是击键流的开始。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="176d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果至少检测到一个流的开始，则为每个通过过滤器的新包调用<code class="du mv mw mx my b">lookup_for_new_packages_of_current_stream()</code>函数。在这个函数中，如果当前选择的流只包含一个包，则调用<code class="du mv mw mx my b">is_second_package_of_stream</code>来检查当前包是否满足第二个包的属性。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="6378" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样的，每次<code class="du mv mw mx my b">is_second_package_of_stream</code>返回false时<code class="du mv mw mx my b">lookup_for_new_packages_of_current_stream()</code>内部的<code class="du mv mw mx my b">is_next_package</code>函数被调用。对于同一个选中的包，该函数检查它是否有资格成为击键流的下一个包。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="me mf l"/></div></figure><p id="911c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">围绕这种用于检测网络流中击键序列模式的逻辑，必须实现用于管理信息的其他功能。</p><blockquote class="kr ks kt"><p id="dade" class="ie if ku ig b ih ii ij ik il im in io kv iq ir is kw iu iv iw kx iy iz ja jb ha bi translated">完整代码可通过<a class="ae ld" href="https://github.com/n1ckl0sk0rtge/KeystrokeExtractor" rel="noopener ugc nofollow" target="_blank"> Github </a>获得。</p></blockquote></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="3155" class="jo jp hh bd jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh lp kj kk kl bi translated">结果</h1><p id="6128" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">通过从给定个体收集足够数量的击键间时间，生物测定打字行为可以被映射为所有数据点上的频率分布</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mz"><img src="../Images/ce2e620926de4d033fbabcf4a4ab5b8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*H-DJ6x96lgDRd2Od_lRLeg.png"/></div></figure><p id="83fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该图可视化了通过捕获加密的Google搜索流量(x轴:相对频率，y轴:以秒为单位的击键间隔时间)收集的两个不同个人的生物特征打字行为。</p><blockquote class="kr ks kt"><p id="8723" class="ie if ku ig b ih ii ij ik il im in io kv iq ir is kw iu iv iw kx iy iz ja jb ha bi translated">通过<!-- -->比较不同的打字行为分布，仅仅通过观察加密的网络流量就有可能检测和识别一个人！</p></blockquote></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h1 id="67a6" class="jo jp hh bd jq jr ll jt ju jv lm jx jy jz ln kb kc kd lo kf kg kh lp kj kk kl bi translated">质量</h1><p id="6217" class="pw-post-body-paragraph ie if hh ig b ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb ha bi translated">为了描述模式算法的质量和正确性，可以使用两种类型的错误类。</p><p id="e08b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">假阴性:</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es na"><img src="../Images/7ebb0253a2f500bfbfe0e133272fce5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iIGF9xzrV2m2k1VJ4AZnvg.png"/></div></div></figure><p id="1c47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">误报:</strong></p><ul class=""><li id="07a0" class="lq lr hh ig b ih ii il im ip ls it lt ix lu jb lv lw lx ly bi translated">在不使用谷歌搜索的情况下捕获网络流量</li><li id="b10e" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated">Wireshark检测到大约11000个包</li><li id="1bdf" class="lq lr hh ig b ih lz il ma ip mb it mc ix md jb lv lw lx ly bi translated">如果不检查ip和端口，模式算法将检测不到击键序列</li></ul></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><div class="jd je jf jg fd nb"><a href="https://github.com/n1ckl0sk0rtge/KeystrokeExtractor" rel="noopener  ugc nofollow" target="_blank"><div class="nc ab dw"><div class="nd ab ne cl cj nf"><h2 class="bd hi fi z dy ng ea eb nh ed ef hg bi translated">n1 ckl 0 sk 0 rtge/KeystrokeExtractor</h2><div class="ni l"><h3 class="bd b fi z dy ng ea eb nh ed ef dx translated">在GitHub上创建一个帐户，为n1 ckl 0 sk 0 rtge/KeystrokeExtractor的开发做出贡献。</h3></div><div class="nj l"><p class="bd b fp z dy ng ea eb nh ed ef dx translated">github.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jm nb"/></div></div></a></div></div></div>    
</body>
</html>