<html>
<head>
<title>Digit Classification Using Convolution Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于卷积神经网络的数字分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/digit-classification-using-convolution-neural-networks-38e7b0d81e59?source=collection_archive---------13-----------------------#2021-09-06">https://medium.com/analytics-vidhya/digit-classification-using-convolution-neural-networks-38e7b0d81e59?source=collection_archive---------13-----------------------#2021-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="e821" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="ca50" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在这篇文章中，我将解释我们如何使用Keras库开发卷积神经网络(CNN)来分类手写数字。我将写另一篇文章讨论CNN是如何工作的，因此在这篇文章中不会讨论。这个模型将帮助您在测试数据上达到98%的准确率。github上提供了数据集和完整的笔记本，下面提供了链接。</p><p id="5c5f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">出于本文的目的，我们将使用Kaggle上提供的数据，并使用训练图像数据集。我们将把这个数据集分成训练集和测试集，分别包含37800和4200条记录，两者都包含784个属性。</p><p id="d206" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> Github链接:</strong><a class="ae kf" href="https://github.com/RiyanPahuja-ops/MNIST-digit-recognition.git" rel="noopener ugc nofollow" target="_blank">https://Github . com/RiyanPahuja-ops/MNIST-digit-recognition . git</a></p><p id="ada2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> Kaggle笔记本</strong>:<a class="ae kf" href="https://www.kaggle.com/riyanpahuja04/digit-recognizer-using-cnn-98" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/riyanpahuja 04/digit-recognizer-using-CNN-98</a></p><h1 id="4475" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">探索数据</h1><p id="cb2c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">让我们首先导入所有必要的库并加载数据集</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">库和数据加载</figcaption></figure><p id="f33d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们看看数据的前几行。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/0a747159f4d4de2eb3b66cc162ee9f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i83xftnD2FZecNTKSRrp1Q.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">列车数据的前5行</figcaption></figure><p id="cc6e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这是我们数据的前5行。第一列label表示我们的输出，将被称为目标列。它包含图像中显示哪个数字的信息。这就是我们要预测的！</p><p id="50dd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">注意到其他列中的所有0了吗？这些是特定像素的亮度值。事件虽然我们只能在显示的前5行和几列中看到0，但我们会注意到强度范围将在0和255之间，其中0表示黑色，255表示白色。因为这个数据集只包含灰度图像，所以我们只需要处理一个这样的通道。在RGB图像的情况下，我们将有三个这样的通道，每个通道代表特定像素的红色、绿色和蓝色的强度等级。</p></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="ea15" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在让我们看看每个数字有多少个例子。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lf"><img src="../Images/f1ffae20198fd98b920340024e51ccef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*V4EhCQboXwbSDgmZG_AvBQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">数据集中每个数字的计数</figcaption></figure><p id="c646" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这里我们可以看到，我们有几乎相同数量的每个数字的例子。因此，我们可以说这些阶级是平衡的。</p><p id="a851" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">以下是数据集中出现的数字的示例图像。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lg"><img src="../Images/d152650f57efb1a445b1567e21ac35d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*18dBAt94tcMj56tM417Hkw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">数字图像示例</figcaption></figure><h1 id="1c67" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">预处理数据</h1><p id="6b39" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在让我们把数据变成我们需要的形式。在这种情况下，我们需要对数据进行预处理，以便将数据转换成适合模型的格式。</p><p id="b5e8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们首先将数据分为训练数据和测试数据。我们将从<em class="lh"> sklearn的模型选择模块</em>导入一个名为<em class="lh"> train_test_split的库。</em>该模块帮助我们将数据随机分为训练和测试数据集。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="f3e1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">splitting函数有5个参数。前两个参数是输入和输出数组。测试大小参数用于告诉函数测试集的大小，这里0.1表示整个数据集的10%将用于测试。最后，random state参数用于设置随机生成器的状态。这是必要的，这样我们每次都可以复制相同的训练和测试集。</p><p id="02a9" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们需要对数据进行整形，将图像转换成28x28的大小。我们可以通过下面的代码片段实现这一点。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="92d8" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们正在将所有图像转换成<em class="lh"> 28x28x1 </em>矢量，其中<em class="lh"> 1 </em>表示图像为灰度格式。我们还将所有集合转换为数组，以使它们适合模型。此外，我们对训练和测试“x”集进行标准化，以加速模型的训练。最后，我们对标签进行一次性编码。该模型将返回每个标签的概率，我们将把概率最高的标签作为最终输出。</p><h1 id="0c26" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建模型</h1><p id="86bf" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将在此模型中使用顺序模型，这允许我们逐层构建模型。我们将使用以下层:</p><p id="029d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">卷积层</strong>:该层从输入数据中提取高级输入特征，并将这些特征以特征图的形式传递给下一层。</p><p id="eee5" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">汇集层</strong>:通过汇集特征地图来创建新的更小维度的特征地图，从而降低数据的维度。在一个跨度内，池图层采用旧要素地图的最大值或平均值。</p><p id="4f35" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">展平层:</strong>该层将输入的多维数组展平为一维数组。这不会影响批量大小。</p><p id="daa7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">致密层</strong>:最终的分类任务由<em class="lh">致密层</em>完成。使用<em class="lh"> softmax </em>函数计算每个类别的最终概率。</p><p id="d5bb" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">脱落层</strong>:我们要使用的另一层是<em class="lh">脱落层</em>。在训练期间，Dropout层以每一步的速率频率将输入单位随机设置为0，这有助于防止过拟合。未设置为0的输入按1/(1 - rate)的比例放大，因此所有输入的总和保持不变。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div></figure><p id="1cec" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们添加了两个卷积层，将输入图像视为2D矩阵。两个卷积层分别由64和32个节点组成。这些是根据数据的大小决定的，需要根据每个问题进行调整。在这种情况下，结果是这些数字工作得很好。内核大小设置为3。这是滤波器矩阵的大小(3x3)。激活功能已设置为<em class="lh"> ReLu </em>，代表整流线性单元。这种激活函数已被证明在大多数情况下对神经网络最有效，胜过tanh和sigmoid函数。第一卷积层也是指定输入图像形状的输入形状参数。</p><p id="bff4" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来，我们添加了一个池层。要了解更多有关其功能的信息，请参阅本节开头部分。池大小已被设置为(2，2)，这意味着它将在2x2池窗口内取最大值。我们在中间添加了一个密集层，用于收集附加信息。在最后一个输出层之前添加下降层，以防止过拟合。最后，添加了具有10个输出节点的密集层，每个节点对应于数据集中的一个类。它有<em class="lh"> softmax </em>激活功能，将所有输出相加为一，这样我们就可以根据哪个预测来计算概率。</p><h1 id="250b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">编译和拟合模型</h1><p id="7d6a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们的模型终于做好了！！我们只需要编译它，然后就可以开始了。但是等等！！我们首先需要决定3件大事。优化器、损失函数和指标。</p><p id="e5b6" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">优化器</strong>:优化器是用于改变神经网络属性的算法或方法，例如权重和学习速率，以最小化损失。通过最小化函数，优化器被用来解决优化问题。在这个模型中，我们将使用Adam作为我们的优化器，因为它是所有其他算法中收敛最快的。但是，您应该尝试不同的优化器，以检查哪一个最适合您的问题。</p><p id="d0f5" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">损失:</strong>损失只不过是神经网络的预测误差。损失越低，模型的预测能力就越强。计算损失的方法称为损失函数。我们将使用<em class="lh">分类交叉熵</em>作为我们的损失函数。当使用这个损失函数时，应该记住输出节点的数量应该等于类的数量，并且激活函数应该被设置为“softmax ”,以便每个节点输出0和1之间的概率值。</p><p id="a7a3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">度量</strong>:度量只不过是一种了解你的模型在它应该做的任务上有多好的方法，在这种情况下就是分类。我们将在模型中使用精确度百分比。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kl km l"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">编译和拟合模型</figcaption></figure><p id="7df1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">时期指的是模型将看到相同数据的次数。我们将其设置为35，但这因情况而异。你可以画一个图表，看看你的损失是如何随着时代的数量减少，以选择最佳的拟合。</p><h1 id="bb1b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="d3ff" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">该模型验证数据的准确度为0.9907。然而，当该模型应用于Kaggle上也提供的测试数据时，这可能会减少。然而，你需要提交你的预测来获得一个正确的分数。这个模型会让你在实际测试数据上得到98%的分数。这是一个相当简单的模型。除了其他技术，您还可以使用数据扩充来增加训练数据的大小。如果你能想出一个方法来改善这个模型，请告诉我:)</p></div></div>    
</body>
</html>