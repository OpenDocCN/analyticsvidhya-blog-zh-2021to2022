<html>
<head>
<title>Identifying Vacant Shelf Spaces Using Template Matching in OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV中使用模板匹配识别空闲货架空间</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/identifying-empty-shelf-spaces-using-template-matching-in-opencv-6be8d4caa80e?source=collection_archive---------5-----------------------#2021-03-26">https://medium.com/analytics-vidhya/identifying-empty-shelf-spaces-using-template-matching-in-opencv-6be8d4caa80e?source=collection_archive---------5-----------------------#2021-03-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="d25a" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">查找丢失产品的位置:</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/47c2aee836ac98fb026c2e4446d0a548.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p6ITD4SytRoiivrd22Nkzw.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">图片来自<a class="ae jn" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3105629" rel="noopener ugc nofollow" target="_blank"> Pixabay </a>的Igor Ovsyannykov </figcaption></figure><p id="bb75" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">假设你是一名在Trader Joe's工作的员工，被要求在商店里走动，检查需要重新进货的货架。不幸的是，你不能简单地使用你的手持库存扫描仪来查看一个被购买的产品是从哪里被取走的。超市有时会有多个区域存放特定的产品，因此很难跟踪购物者从哪个位置取走产品。最重要的是，报告库存的空货架空间可能很耗时，并且总是存在人为缺陷的可能性。这就是通过计算机视觉识别空货架空间可能派上用场的地方。</p><h1 id="74b5" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">TL；速度三角形定位法(dead reckoning)</h1><p id="c57b" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">我们创建两个唯一的模板，遍历图像以找到足够相似的多维数组。相似性基于我们的可配置阈值。<a class="ae jn" href="https://sicara.ai/blog/en/author/jean-rovani" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj"> Jean Rovani </strong> </a> <strong class="jq hj">的</strong> <a class="ae jn" href="https://www.sicara.ai/blog/en/object-detection-template-matching" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">模板匹配</strong> </a> <strong class="jq hj">博客和代码在这个项目中对我帮助很大，让我可以实现OpenCV的<em class="lh"> matchTemplate </em>函数的模板。</strong></p><h1 id="2e79" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">模板匹配</h1><p id="32fd" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">有几种方法可以通过计算机视觉来实现这一点，其中一些比另一些更好，然而，对于这个博客，我们将尝试使用<em class="lh">模板匹配</em>。以下是OpenCV自己对它的定义:</p><blockquote class="li lj lk"><p id="27f9" class="jo jp lh jq b jr js ij jt ju jv im jw ll jy jz ka lm kc kd ke ln kg kh ki kj hb bi translated">模板匹配是一种在更大的图像中搜索和找到模板图像的位置的方法。OpenCV为此提供了一个函数<a class="ae jn" href="https://docs.opencv.org/master/df/dfb/group__imgproc__object.html#ga586ebfb0a7fb604b35a23d85391329be" rel="noopener ugc nofollow" target="_blank"><strong class="jq hj">cv . match template()</strong></a>。它简单地在输入图像上滑动模板图像(如在2D卷积中)，并在模板图像下比较输入图像的模板和补片。</p></blockquote><p id="9d9c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">模板匹配的第一步是创建我们的模板。</p><p id="3980" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">当看上面的照片时，我们可以立即识别出中间顶部2个货架有空的空间。在最上面的货架上，我们可以确定有3-5件白色袋子产品需要重新进货。在第二个货架上，我们可以看到大约有2种产品需要重新进货。</p><p id="f484" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><strong class="jq hj">注意:</strong>由于阴影和不同的背景颜色，空的顶层搁板看起来与第二层搁板不同。因此，我们将使用2个模板。</p><p id="4770" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">首先，让我们用Python加载下图:</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="8c05" class="lt kl hi lp b fi lu lv l lw lx">import cv2<br/>import matplotlib.pyplot as plt<br/>import numpy as np</span><span id="efea" class="lt kl hi lp b fi ly lv l lw lx">img = cv2.imread("/content/drive/MyDrive/Computer Vision/new_shelf.jpg")<br/>plt.figure(figsize = (20,15))<br/>plt.imshow(img)</span></pre><p id="3056" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">下面是创建我们特定模板的代码(注意<em class="lh"> template_2 </em>由于更小的空白区域而变得更窄):</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="e92d" class="lt kl hi lp b fi lu lv l lw lx">template_1 = img[60:270, 1890:2010]<br/>plt.imshow(template_1)</span><span id="13d6" class="lt kl hi lp b fi ly lv l lw lx">template_2 = img[300:500, 1825:1905]<br/>plt.imshow(template_2)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es lz"><img src="../Images/a826ef6bb662fdcfceba09827c928695.png" data-original-src="https://miro.medium.com/v2/resize:fit:328/format:webp/1*IUVfrPHZwM0f8cPWwmjmjA.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">模板1(顶部中间搁板)</figcaption></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ma"><img src="../Images/945403fcc9e29810e2495c6b6a0c9b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/1*_fd0_Uig_GURRPNunBjOug.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">模板2(第二个中间搁板)</figcaption></figure><p id="2ff4" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">如果你愿意，你可以试试模板的大小，我发现这些最合适。此外，如果你想知道为什么模板颜色看起来与原始图像不同，这是因为<em class="lh"> CV2 </em>将图像加载为<em class="lh"> BGR </em>而不是<em class="lh"> RGB。</em></p><h1 id="5055" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">匹配过程</h1><p id="8930" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">现在我们有了模板，我们可以开始匹配过程。为此，我们首先将模板存储为一个具有不同属性的类，如label (1，2)和color(以区分我们为不同模板绘制的矩形框)。<strong class="jq hj">又来了，巨大的喊单</strong> <a class="ae jn" href="https://sicara.ai/blog/en/author/jean-rovani" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">让·罗瓦尼</strong> </a> <strong class="jq hj">齐</strong> <a class="ae jn" href="https://www.sicara.ai/blog/en/object-detection-template-matching" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hj">模板匹配</strong> </a> <strong class="jq hj">博客及代码:</strong></p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="e3e6" class="lt kl hi lp b fi lu lv l lw lx">*******************************************************************/<br/>* Title: template_defenition.py<br/>* Author: Jean Rovani<br/>* Date: 2020<br/>* Code version: 3rd revision<br/>* Availability: <a class="ae jn" href="https://gist.github.com/jrovani/012f0c6e66647b4e7b844797fa6ded22#file-template_definition-py" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jrovani/012f0c6e66647b4e7b844797fa6ded22#file-template_definition-py</a><br/>*******************************************************************/</span><span id="6e6e" class="lt kl hi lp b fi ly lv l lw lx">DEFAULT_TEMPLATE_MATCHING_THRESHOLD = 0.85</span><span id="93b1" class="lt kl hi lp b fi ly lv l lw lx">class Template:<br/>    def __init__(self, label, template, color, matching_threshold=DEFAULT_TEMPLATE_MATCHING_THRESHOLD):<br/>        self.label = label<br/>        self.color = color<br/>        self.template = template<br/>        self.template_height, self.template_width = self.template.shape[:2]<br/>        self.matching_threshold = matching_threshold</span><span id="e5af" class="lt kl hi lp b fi ly lv l lw lx">image = cv2.imread("/content/drive/MyDrive/Computer Vision/shelf_new.jpg")</span><span id="4988" class="lt kl hi lp b fi ly lv l lw lx">templates = [<br/>    Template(label="1", template = template_1, color=(0, 0, 255)),<br/>    Template(label="2", template = template_2, color=(0, 255, 0))<br/>]</span></pre><p id="1783" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">接下来，我们遍历我们的图像，并存储每个满足或超过阈值要求(本例中为0.85)的数组的数据。</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="46e8" class="lt kl hi lp b fi lu lv l lw lx">*******************************************************************/<br/>* Title: plot_bounding_boxes.py<br/>* Author: Jean Rovani<br/>* Date: 2020<br/>* Code version: 6th revision<br/>* Availability: <a class="ae jn" href="https://gist.github.com/jrovani/099f80a5ee75657ff7aa6ed491568f04#file-plot_bounding_boxes-py" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/jrovani/099f80a5ee75657ff7aa6ed491568f04#file-plot_bounding_boxes-py</a><br/>*******************************************************************/</span><span id="ab8f" class="lt kl hi lp b fi ly lv l lw lx">detections_1 = []<br/>detections_2 = []<br/>for template in templates:<br/>    template_matching = cv2.matchTemplate(<br/>        template.template, image, cv2.TM_CCOEFF_NORMED<br/>    )<br/>match_locations = np.where(template_matching &gt;= template.matching_threshold)<br/>for (x, y) in zip(match_locations[1], match_locations[0]):<br/>        match = {<br/>            "TOP_LEFT_X": x,<br/>            "TOP_LEFT_Y": y,<br/>            "BOTTOM_RIGHT_X": x + template.template_width,<br/>            "BOTTOM_RIGHT_Y": y + template.template_height,<br/>            "MATCH_VALUE": template_matching[y, x],<br/>            "LABEL": template.label,<br/>            "COLOR": template.color<br/>        }<br/>        if match['LABEL'] == '1':<br/>          detections_1.append(match)<br/>        else:<br/>          detections_2.append(match)</span></pre><p id="e312" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经有了检测的所有数据，让我们使用<em class="lh"> cv2.rectangle </em>函数来看看它们在原始图像上的样子:</p><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="a0a0" class="lt kl hi lp b fi lu lv l lw lx">image_with_detections = image.copy()<br/>for temp_d in [detections_1, detections_2]:<br/>  for detection in temp_d:<br/>      cv2.rectangle(<br/>          image_with_detections,<br/>          (detection["TOP_LEFT_X"], detection["TOP_LEFT_Y"]),<br/>          (detection["BOTTOM_RIGHT_X"], detection["BOTTOM_RIGHT_Y"]),<br/>          detection["COLOR"],<br/>          2,<br/>      )<br/>plt.figure(figsize = (20,15))<br/>plt.imshow(image_with_detections)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/cb50b4d374101ad4596b06e3b1c887b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cP4tHpB0scp3K-ZAzAUidg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">模板匹配重复</figcaption></figure><p id="b8ee" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们有发现了。这里的问题是<em class="lh">检测</em>列表存储了重复项。要解决这个问题，我们只需确保只使用不与另一个矩形重叠的矩形:</p><h2 id="694b" class="lt kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">消除重复检测</h2><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="92ae" class="lt kl hi lp b fi lu lv l lw lx">#Sorting detections by BOTTOM_RIGHT_X coordinate<br/>detections_1 = sorted(detections_1, key = lambda i: i['BOTTOM_RIGHT_X'])<br/>detections_2 = sorted(detections_2, key = lambda i: i['BOTTOM_RIGHT_X'])</span><span id="295b" class="lt kl hi lp b fi ly lv l lw lx">det_wo_dupl_1 = [detections_1[0]]<br/>det_wo_dupl_2 = [detections_2[0]]<br/>check = 1<br/>min_x_1 = templates[0].template.shape[1]<br/>min_x_2 = templates[1].template.shape[1]</span><span id="1f53" class="lt kl hi lp b fi ly lv l lw lx">for d in range(1, len(detections_1)):<br/>  min_x_check = detections_1[d]["BOTTOM_RIGHT_X"] - detections_1[d-check]["BOTTOM_RIGHT_X"]<br/>  if min_x_check &gt; min_x_1:<br/>    det_wo_dupl_1.append(detections_1[d])<br/>    check = 1<br/>  else:<br/>    check += 1</span><span id="ed26" class="lt kl hi lp b fi ly lv l lw lx">check = 1<br/>for d in range(1, len(detections_2)):<br/>  min_x_check = detections_2[d]["BOTTOM_RIGHT_X"] - detections_2[d-check]["BOTTOM_RIGHT_X"]<br/>  if min_x_check &gt; min_x_2:<br/>    det_wo_dupl_2.append(detections_2[d])<br/>    check = 1<br/>  else:<br/>    check += 1</span><span id="9473" class="lt kl hi lp b fi ly lv l lw lx">det_wo_dupl = det_wo_dupl_1 + det_wo_dupl_2<br/>print(len(det_wo_dupl))</span></pre><h2 id="1db6" class="lt kl hi bd km mc md me kq mf mg mh ku jx mi mj kw kb mk ml ky kf mm mn la mo bi translated">绘制过滤的检测</h2><pre class="iy iz ja jb fd lo lp lq lr aw ls bi"><span id="ab49" class="lt kl hi lp b fi lu lv l lw lx">image_with_detections = image.copy()<br/>min_x = templates[0].template.shape[1]</span><span id="7e5c" class="lt kl hi lp b fi ly lv l lw lx">for detection in det_wo_dupl:<br/>    cv2.rectangle(<br/>        image_with_detections,<br/>        (detection["TOP_LEFT_X"], detection["TOP_LEFT_Y"]),<br/>        (detection["BOTTOM_RIGHT_X"], detection["BOTTOM_RIGHT_Y"]),<br/>        detection["COLOR"],<br/>        20,<br/>    )<br/>plt.figure(figsize = (20,15))<br/>plt.imshow(image_with_detections)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/3b0269ee3ccdcb34a483017880e98bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ji_2oOIh70DA-dOehvyy6w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">无重复的模板匹配</figcaption></figure><p id="9624" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">绝对看起来好多了。</p><h1 id="ed23" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">模板匹配缺点</h1><ol class=""><li id="e13e" class="mp mq hi jq b jr lc ju ld jx mr kb ms kf mt kj mu mv mw mx bi translated">有人可能会争辩说，实际上应该有5个矩形显示在顶层货架上，因为其中一个袋子似乎有点倾斜/移动。使用模板匹配，很难发现这一点。</li><li id="33f0" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">我们需要不同大小的多个模板来捕捉这个图像中所有的空货架区域。</li><li id="0bc8" class="mp mq hi jq b jr my ju mz jx na kb nb kf nc kj mu mv mw mx bi translated">如果只有模板匹配，我们将如何处理下面的空白？</li></ol><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es nd"><img src="../Images/27b58f76e940d82779f6cca21f3fa76b.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*IjBKfQ0GcBglE2HoPaqaFw.jpeg"/></div></figure><h1 id="7da6" class="kk kl hi bd km kn ko kp kq kr ks kt ku io kv ip kw ir kx is ky iu kz iv la lb bi translated">结论</h1><p id="bd44" class="pw-post-body-paragraph jo jp hi jq b jr lc ij jt ju ld im jw jx le jz ka kb lf kd ke kf lg kh ki kj hb bi translated">尽管模板匹配对于我们的用例来说工作得很好，对于许多其他用例来说也是一个很好的计算机视觉过程，但它可能不是这个场景的最佳选择。对于这样的问题，我们需要一种算法来学习理解一个空白区域的周围产品。这将允许更大的灵活性，因为它将能够处理不同大小/颜色的空白区域。</p><p id="bc1b" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Ronel Sylvester是Predmatic的ML工程师，在音频分类、深度学习、计算机视觉/图像处理和预测方面拥有丰富的经验。Predmatic是一家基于数据科学和人工智能的咨询公司，提供高影响力和可扩展的业务解决方案。</p></div></div>    
</body>
</html>