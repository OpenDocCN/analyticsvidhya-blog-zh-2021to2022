<html>
<head>
<title>A Beginner’s Guide to Multivariate Imputation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多元插补初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-beginners-guide-to-multivariate-imputation-fe4ae5591544?source=collection_archive---------11-----------------------#2021-03-21">https://medium.com/analytics-vidhya/a-beginners-guide-to-multivariate-imputation-fe4ae5591544?source=collection_archive---------11-----------------------#2021-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bc418056c6eb74190dfc024f5086edcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xaOjbNkvX2gr7QtbrzwjAg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://atrium.ai/resources/learn-from-the-experts-the-consequences-of-missing-data/" rel="noopener ugc nofollow" target="_blank">https://atrium . ai/resources/learn-from-the-expert-the-constructions-of-missing-data/</a></figcaption></figure><p id="e6a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">缺失数据是数据科学家在数据分析中最常遇到的问题之一。处理缺失值的几种快速解决方案是“从数据集中移除具有缺失值的观测值”或“用平均值、中值或众数填充缺失值”。然而，这些快速解决方案有多好呢？我们能做得更好吗？在本文中，我将(1)快速介绍不同类型的缺失值，(2)可视化缺失值，(3)使用scikit-learn实现多元插补，(4)测试插补数据集，以及(5)得出结论。</p><h1 id="b6df" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">分类丢失的数据</h1><p id="7c15" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">缺失值可分为三类(1) <strong class="ix hj"> m </strong>缺失<strong class="ix hj"> c </strong>完全缺失<strong class="ix hj">a</strong>t<strong class="ix hj">r</strong>andom(<strong class="ix hj">mcar</strong>)、<strong class="ix hj"> m </strong>缺失<strong class="ix hj">a</strong>t<strong class="ix hj">r</strong>andom(<strong class="ix hj">mar</strong>)、<strong class="ix hj"> m </strong>缺失<strong class="ix hj">我认为，当值为mcar时，缺失值与观察值或缺失值没有关系。例如，病人由于他们自己不同的原因而错过了他们的预约，例如忘记了预约时间，不得不去接孩子等等。当值被标记时，缺失值与观察到的数据有关，但与数据集中的缺失数据无关。换句话说，丢失槽的理论值不会导致它们丢失。例如，由于该地区的暴风雪，多个患者可能会错过他们的预约。最后，当值为mnar时，缺失值与其理论值或另一个未观察到的变量相关。例如，患者可能会错过后续的预约，因为最初的治疗引起了副作用，使他们感觉太虚弱而不能去预约，因此副作用对于一些患者来说是不存在的。</strong></p><p id="d06c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在mcar和mar的情况下，我们可以删除或估算缺失值，但没有好的方法来处理mnar。假设我们已经研究了数据缺失的原因，并得出结论，我们正在处理的缺失值属于前两种情况，我们应该删除它们还是用平均值、中值或众数对它们进行估算？或者有没有更好的方法来填充缺失的值？</p><p id="9cc2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们只是从数据集中删除丢失的值，我们就会丢失有价值的信息。当数据集很大时(数百个观察值和缺失值只占很小一部分)，这可能不是问题，但是当您处理小数据集时(例如我使用的iris数据集，它有150个观察值)，这可能会有问题。用同一个变量的均值、中值或众数来估算一个变量的缺失值怎么样(这里的技术术语是单变量估算)？假设你有一个关于房价的数据集，数据集中的两个变量是平方英尺的大小和卧室的数量。如果平均来说，房子的面积是1500平方英尺，卧室的数量是两个。在一栋5000平方英尺的豪宅里用两个房间来填卧室的数量，不觉得奇怪吗？事实证明，我们可以选择根据数据集中其他变量的信息来填充缺失值(多变量插补)。这可以通过scikit-learn的IterativeImputer轻松完成。</p><h1 id="ebbd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated"><strong class="ak">可视化丢失的数据(是的，即使它们丢失了，我们也能看到)</strong></h1><p id="f300" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了演示插补过程，我使用了来自scikit-learn的虹膜数据集。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="e6f9" class="lf ju hi lb b fi lg lh l li lj">iris = load_iris() <br/>df = pd.DataFrame(data = np.c_[iris[“data”], iris[“target”]],\   columns = iris[“feature_names”] + [“species”])</span></pre><p id="f76a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个小数据集，包含150个观察值和四个变量，包括萼片长度、萼片宽度、花瓣长度和花瓣宽度。目标变量是鸢尾的种类。数据集没有缺失值，所以我随机选择在萼片长度和花瓣宽度中引入15和10个缺失值。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="cc1f" class="lf ju hi lb b fi lg lh l li lj">np.random.seed(123)<br/>mask = np.random.randint(0, 150, size = 15)<br/>mask2 = np.random.randint(0, 150, size = 10)</span><span id="61c9" class="lf ju hi lb b fi lk lh l li lj">df_miss["sepal length (cm)"][mask] = np.nan<br/>df_miss["petal width (cm)"][mask2] = np.nan</span></pre><p id="9ea3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了可视化数据集中的缺失值，我们可以使用missingno模块中的矩阵函数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8f18" class="lf ju hi lb b fi lg lh l li lj">import missingno as msno<br/>msno.matrix(df_miss, figsize=(10, 6))</span></pre><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/4b7f0ef90849b9c5a0fce316a64b1f8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7V5isTpYUDgOoY1RZzaQVA.png"/></div></div></figure><p id="0e5a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">五个黑色矩形块中的每一个都代表数据集中的一个变量，第一个和第四个块中的白色条代表变量的缺失值。missingno的热图函数显示了变量的缺失值之间的相关性。它有助于我们理解不同变量的缺失值是否相互关联，以及关联到什么程度。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/74cac8d6d6f674e84395fa81d8c45ae1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tFhdGPDV3wbueKTGW7YRxQ.png"/></div></div></figure><h1 id="d825" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用迭代输入器输入缺失数据</h1><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="2bf7" class="lf ju hi lb b fi lg lh l li lj">from sklearn.experimental import enable_iterative_imputer<br/>from sklearn.impute import IterativeImputer</span><span id="4302" class="lf ju hi lb b fi lk lh l li lj">imputer = IterativeImputer(max_iter=10, random_state=123)<br/><em class="ln"># pull out non-target variables for imputation</em><br/>df.iloc[:, 0:4] = imputer.fit_transform(df_miss.iloc[:, 0:4])</span></pre><p id="f8d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当我们估算缺失值时，我们首先需要从数据集中移除目标变量。特别是在虹膜数据集中，是虹膜的种类。原因是我们不想用目标变量来估计其他变量的缺失值，然后在建立我们的分类模型时用估算的数据集来预测目标。仅使用几行代码(如前面的代码块所示)，我们现在就有了一个完整的数据集，缺失的值由数据集中非目标变量的回归估计。我想指出的一点是，IterativeImputer的默认回归量是BayesianRidge，但是您可以轻松地指定您感兴趣的回归量，我将在下一个代码块中展示这一点。迭代输入器的更多细节可以在<a class="ae iu" href="https://scikit-learn.org/stable/modules/generated/sklearn.impute.IterativeImputer.html#sklearn.impute.IterativeImputer" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="8181" class="lf ju hi lb b fi lg lh l li lj"><em class="ln"># initialize the RandomForest regressor</em><br/>from sklearn.ensemble import RandomForestRegressor<br/>rf = RandomForestRegressor(n_estimators=10, random_state=123)</span><span id="022c" class="lf ju hi lb b fi lk lh l li lj"><em class="ln"># specify estimator to be rf</em> <br/>rf_imputer = IterativeImputer(<strong class="lb hj">estimator=rf</strong>, random_state=123)<br/>df.iloc[:, 0:4] = rf_imputer.fit_transform(df_miss.iloc[:, 0:4])</span></pre><h1 id="543d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试估算数据集</h1><p id="a2b1" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">现在我们有了两个估算数据集，一个是原始数据集(直接从scikit-learn导入，没有缺失值)，另一个是删除了缺失值的数据集，我们可以看到这些数据集在模型拟合中的表现。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="db83" class="lf ju hi lb b fi lg lh l li lj">from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import train_test_split</span><span id="c086" class="lf ju hi lb b fi lk lh l li lj">datasets = [df, drop_missing, df_br, df_rf]<br/>dfnames = ["original", "drop missing", "BayesianRidge imputed", "RandomForest imputed"]</span><span id="e572" class="lf ju hi lb b fi lk lh l li lj">logit = LogisticRegression(C = 0.9, max_iter=200)<br/>for i in range(len(datasets)):<br/>    X_train, X_test, y_train, y_test = \ train_test_split(datasets[i].iloc[:, 0:4], datasets[i]["species"], \ test_size=0.3, random_state=123)<br/>    logit.fit(X_train, y_train)<br/>    print(f"Scores for the {dfnames[i]} dataset are")<br/>    print("Training: {:6.2f}%".format(100*logit.score(X_train, y_train)))<br/>    print("Test: {:6.2f}%".format(100*logit.score(X_test, y_test)))</span></pre><p id="cd03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我用所有的数据集做了一个简单的训练测试分割，然后拟合了一个逻辑回归模型来对鸢尾物种进行分类。结果如下:</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lo"><img src="../Images/e46e6ac804becff2370d3367729b67a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tuy6lRUNIFaUYSwb8oEZkg.png"/></div></div></figure><p id="5912" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从结果可以看出，模型在原始数据集和两个估算数据集上的性能是相同的，训练准确率为98.10%，测试准确率为93.33%。然而，当我们简单地删除缺失值时，我们的训练准确率为96.63%，测试准确率为97.44%。这里的重点不是精度有多高/低，而是数据集在建模上是否有相似的表现。在这个例子中很明显，估算的数据集与原始数据集具有更相似的性能。</p><h1 id="cc61" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="eb7b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">从上面的例子中，我们可以看出多元插补是处理缺失数据的一种简单有效的方法。我希望这篇文章对你有所帮助，如果你的数据分析程序中还没有多元插补的话，你可以试着实现多元插补。</p><p id="915f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您通读这篇文章！我很想听到你的反馈。这篇文章的代码可以在<a class="ae iu" href="https://github.com/sarazong/investigation_missing_data" rel="noopener ugc nofollow" target="_blank">这里</a>找到。我的Github的链接可以在<a class="ae iu" href="https://github.com/sarazong" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p></div></div>    
</body>
</html>