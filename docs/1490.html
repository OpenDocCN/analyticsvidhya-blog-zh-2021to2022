<html>
<head>
<title>Serverless with OpenFaas, Kubernetes, and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenFaas、Kubernetes和Python的无服务器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/serverless-with-openfaas-kubernetes-and-python-9934e4a80de5?source=collection_archive---------5-----------------------#2021-03-04">https://medium.com/analytics-vidhya/serverless-with-openfaas-kubernetes-and-python-9934e4a80de5?source=collection_archive---------5-----------------------#2021-03-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/45fed178048b448dcd5478a17a0c19c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAVqFFV2-JVHXBB68akXcg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">带OpenFaas的无服务器</figcaption></figure><p id="4833" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在本教程中，我们将学习如何在<a class="ae js" href="https://github.com/openfaas/faas" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> OpenFaas </strong> </a>中将<strong class="iw hj"> Flask微服务</strong>部署为<strong class="iw hj">无服务器功能</strong>。在我之前的一个教程中，我们已经看到了如何创建一个<a class="ae js" rel="noopener" href="/analytics-vidhya/building-rest-apis-using-flask-restplus-sqlalchemy-marshmallow-cff76b202bfb"> Flask微服务</a>。我们将把那个微服务作为参考，作为一个功能部署在OpenFaas上。</p><h2 id="daa8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">什么是无服务器？</h2><p id="e309" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">无服务器是一种架构模式，其中业务逻辑被编写为可以以无状态方式执行的功能。无服务器并不意味着在没有服务器的情况下执行代码。这仅仅意味着我们不必在编写代码的同时提供硬件和基础设施。该应用程序仍然运行在由第三方服务管理的服务器上。</p><h2 id="8827" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">FaaS开放机场</h2><p id="2094" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">功能即服务(FaaS)是一种无服务器模型，能够开发、运行和管理应用功能，而无需构建和部署微服务应用所需的复杂基础设施。按照这种模型构建应用程序是实现无服务器架构的一种方式，通常在构建微服务应用程序时使用。</p><h2 id="eebb" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">Docker和Kubernetes</h2><p id="1f48" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">Docker是一个平台，它使用操作系统级虚拟化来交付被称为容器的软件包中的软件。每个容器都捆绑了自己的软件、库和配置文件。虽然它们彼此隔离，但是它们可以通过明确定义的通道相互通信。容器是开发和部署微服务的好方法。</p><p id="c266" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Kubernetes是一个可移植的、可扩展的开源平台，它促进了跨主机集群的应用程序容器(这里是Docker容器)的部署、伸缩和操作的自动化。</p><p id="4f9c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有关Kubernetes的更多详细信息，请查看:<a class="ae js" href="https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/" rel="noopener ugc nofollow" target="_blank">https://Kubernetes . io/docs/concepts/overview/what-is-Kubernetes/</a></p><h2 id="97c4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">OpenFaas</h2><p id="94ee" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">OpenFaaS是一个开源框架，它使用Docker容器来存储和运行函数，支持在Kubernetes上实现无服务器架构。<a class="ae js" href="https://docs.openfaas.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> OpenFaaS </strong> </a>让开发者可以轻松地将事件驱动的功能和微服务部署到Kubernetes，而无需重复的、铁板一块的编码。它允许您将您的代码或现有的二进制文件打包到Docker映像中，以获得具有自动缩放和度量的高度可伸缩的端点。</p><p id="37f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有关OpenFaas的更多信息，请查看:<a class="ae js" href="https://docs.openfaas.com/" rel="noopener ugc nofollow" target="_blank">https://docs.openfaas.com/</a></p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="1314" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将使用以下步骤在OpenFaas中将Flask微服务部署为无服务器功能:</p><ol class=""><li id="c6da" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">设置Kubernetes和OpenFaas</li><li id="feb1" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">对接烧瓶应用</li><li id="d1a3" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">创建自定义函数</li><li id="5229" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">部署功能</li><li id="08b5" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lf lg lh li bi translated">测试功能</li></ol><h2 id="71d8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">先决条件</h2><ul class=""><li id="5401" class="la lb hi iw b ix ko jb kp jf lo jj lp jn lq jr lr lg lh li bi translated">Kubernetes集群:我们需要一个正在运行的Kubernetes集群。如果Kubernetes集群不可用，则按照<a class="ae js" href="https://kubernetes.io/docs/setup/" rel="noopener ugc nofollow" target="_blank"> <em class="ls">的说明建立一个Kubernetes集群</em> </a> <em class="ls">。</em></li><li id="e555" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj"> Docker Hub帐户:</strong>Docker Hub上的一个帐户，用于存储我们将在本教程中创建的Docker图像。有关创建新账户的详细信息，请参考<a class="ae js" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>页面。</li><li id="f25c" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj"> kubectl: </strong>关于安装<code class="du lt lu lv lw b">kubectl</code>的详细信息，请参见<a class="ae js" href="https://kubernetes.io/docs/tasks/tools/install-kubectl/" rel="noopener ugc nofollow" target="_blank">安装并设置kubectl </a>页面。</li></ul><h2 id="efa2" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">1.设置Kubernetes和OpenFaas</h2><p id="0278" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">OpenFaaS可以在任何本地或远程Kubernetes集群上工作。部署本地或远程Kubernetes集群有许多选择。这里，我们将使用<strong class="iw hj"> Docker Desktop </strong>独立的Kubernetes集群来部署OpenFaas。我们可以使用头盔或阿卡德部署OpenFaaS。</p><p id="e802" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj">掌舵人</strong> </a>是Kubernetes包和运营经理。借助Helm，用户可以通过Chart发布自己的应用配置集，然后使用Helm或第三方自动化工具发现、安装、升级和管理这些配置。</p><p id="fa32" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/alexellis/arkade" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hj"> arkade </strong> </a>是一个用Go编写的开源CLI，有助于轻松管理应用。<code class="du lt lu lv lw b">arkade</code>在内部使用<a class="ae js" href="https://helm.sh/" rel="noopener ugc nofollow" target="_blank"> helm </a>图表和<code class="du lt lu lv lw b">kubectl</code>将应用程序安装到Kubernetes集群。arkade为舵图的各种流行选项公开了强类型标志，可以通过<code class="du lt lu lv lw b">arkade install --help</code>或<code class="du lt lu lv lw b">arkade install APP --help</code>发现。</p><p id="9dfd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在这里，我们将使用<code class="du lt lu lv lw b">arkade</code>来安装OpenFaas，因为使用它安装应用程序非常简单快捷。</p><h2 id="7fb8" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">1.1安装arkade</h2><p id="afa8" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">使用以下命令安装arkade。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="3336" class="jt ju hi lw b fi mf mg l mh mi"># For MacOS / Linux: <br/>curl -SLsf https://dl.get-arkade.dev/ | sudo sh</span><span id="c883" class="jt ju hi lw b fi mj mg l mh mi"># For Windows (using Git Bash) <br/>curl -SLsf https://dl.get-arkade.dev/ | sh</span></pre><h2 id="4a50" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">1.2安装OpenFaas</h2><p id="539b" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">因为我们使用本地Kubernetes集群，所以我们将使用下面的arkade命令来安装OpenFaas。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="7906" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">arkade install openfaas --basic-auth-password password123 --set=faasIdler.dryRun=false</strong></span></pre><p id="e475" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">arkade install命令使用其官方舵图安装OpenFaaS。在这里，我们用自己的<strong class="iw hj">密码</strong>安装了OpenFass，并且禁用了<code class="du lt lu lv lw b">faasIdler.dryRun</code>。<code class="du lt lu lv lw b">faasIdler.dryRun</code>是自动缩放所必需的，我们稍后会谈到。</p><p id="899c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要检查安装<code class="du lt lu lv lw b">OpenFaas</code>的所有可用选项，我们可以使用以下命令。</p><p id="7508" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lt lu lv lw b">arkade install openFaas --help</code></p><p id="a42f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要验证安装是否成功，我们可以执行以下命令。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="aa14" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl get deploy --namespace openfaas</strong></span></pre><p id="dad6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">安装完成后，输出应该如下所示:</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/2c49381d196f2325450bec45c6b37762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*226DZhRyysksMAchVt8n-g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">open FAAS-部署</figcaption></figure><p id="32ec" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要检查OpenFaas中所有核心容器的状态，我们可以执行下面的命令。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="ff13" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl rollout status -n openfaas deploy/gateway</strong></span></pre><p id="ddcb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下面的示例输出显示了<code class="du lt lu lv lw b">gateway</code>部署已经成功推出。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="d61d" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">deployment "gateway" successfully rolled out</strong></span></pre><p id="38a7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们将使用kubectl port-forward命令将对<a class="ae js" href="http://localhost:8080" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>的所有请求转发到运行网关服务的pod。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="04c1" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl port-forward -n openfaas svc/gateway 8080:8080</strong></span></pre><p id="9c73" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">只要流程在运行，从本地机器到网关服务的连接将保持打开。如果它断开连接，我们可以再次运行该命令。或者，我们也可以在最后使用<code class="du lt lu lv lw b">&amp;</code>在后台运行它。</p><h2 id="9a8e" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">1.3安装faas-cli</h2><p id="0a10" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">一旦安装了OpenFaas，我们就必须安装<code class="du lt lu lv lw b">faas-cli</code>。需要使用<code class="du lt lu lv lw b">faas-cli</code>来部署和测试OpenFaas的功能。执行以下命令安装<code class="du lt lu lv lw b">faas-cli</code>。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="8a7f" class="jt ju hi lw b fi mf mg l mh mi"># MacOS and Linux users</span><span id="6490" class="jt ju hi lw b fi mj mg l mh mi"># If you run the script as a normal non-root user then the script<br/># will download the faas-cli binary to the current folder<br/>$ curl -sL <a class="ae js" href="https://cli.openfaas.com" rel="noopener ugc nofollow" target="_blank">https://cli.openfaas.com</a> | sudo sh</span><span id="b747" class="jt ju hi lw b fi mj mg l mh mi"># Windows users with (Git Bash)<br/>$ curl -sL <a class="ae js" href="https://cli.openfaas.com" rel="noopener ugc nofollow" target="_blank">https://cli.openfaas.com</a> | sh</span></pre><p id="aafa" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OpenFass现在准备好了。我们可以使用<code class="du lt lu lv lw b">faas-cli</code>或UI登录OpenFass，如下所示:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="5f71" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">faas-cli login --username admin --password password123</strong></span></pre><p id="51df" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，默认用户名是<strong class="iw hj"> admin </strong>，密码是我们之前在步骤<code class="du lt lu lv lw b">1.2 Install OpenFaas</code>中安装OpenFaas时指定的。</p><p id="5150" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要打开UI，请在网络浏览器中导航至<a class="ae js" href="http://127.0.0.1:8080" rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">http://127 . 0 . 0 . 1:8080</strong></a>。</p><h2 id="3b63" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">2.对接烧瓶应用</h2><p id="1a01" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">简单地说，dockerizing意味着使用docker容器来打包、部署和运行应用程序。我们将对之前在我的一个教程中创建的示例Flask应用程序进行dockerize。</p><h2 id="60bd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">2.1准备应用程序</h2><p id="b6b9" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">在任何目录中使用以下命令克隆我的示例Flask应用程序项目。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="c5af" class="jt ju hi lw b fi mf mg l mh mi">git clone <a class="ae js" href="https://github.com/sumanentc/python-sample-flask-application.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sumanentc/python-sample-flask-application.git</a></span></pre><p id="5a7d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">你可以查看<a class="ae js" rel="noopener" href="/analytics-vidhya/building-rest-apis-using-flask-restplus-sqlalchemy-marshmallow-cff76b202bfb">样品瓶应用</a>了解详情，瓶子应用如何工作，文件夹结构和文件。我们将使用这个Flask应用程序打包成一个docker映像。</p><h2 id="107a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">2.2创建Dockerfile文件</h2><p id="73f8" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">Docker文件基本上是一个文本文件，它有关于如何为我们的项目构建Docker图像的精确说明。</p><p id="f483" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">打开项目文件夹，添加包含以下内容的docker文件:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="c689" class="jt ju hi lw b fi mf mg l mh mi">FROM python:3.7-slim-buster<br/><br/>WORKDIR /home/app<br/><br/>COPY requirements.txt requirements.txt<br/>RUN pip install -r requirements.txt<br/><br/>COPY . .<br/><br/>CMD python app.py</span></pre><p id="a3d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前面文件中的每一行都是以线性自顶向下方式执行的命令。</p><ul class=""><li id="d973" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lr lg lh li bi translated"><strong class="iw hj"> FROM </strong>指定了基础容器映像，我们的应用程序容器的新映像将在这个基础容器映像上构建。在这里，我们将基本映像作为python:3.7-slim-buster，这是一个官方的slim变体python映像。</li><li id="a20a" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj"> WORKDIR </strong>表示安装应用程序的默认目录。我已经设置为/home/app了。在此之后运行的任何命令都将从该文件夹中执行。</li><li id="6ded" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj"> COPY </strong>简单地将本地机器上指定的文件复制到容器文件系统中。我已经把requirements.txt复制到/home/app了。</li><li id="3b83" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">随后是<strong class="iw hj">运行</strong>，执行所提供的命令。这里，我们使用pip命令安装requirements.txt中的所有依赖项。</li><li id="5e11" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">然后，我们简单地将当前本地文件夹中的所有文件复制到/home/app，该文件夹实际上是我们的应用程序根文件夹。</li><li id="6526" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">最后，我们使用<strong class="iw hj"> CMD </strong>通过运行python app.py来运行应用程序。</li></ul><p id="c208" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们需要在前面克隆项目时下载的<code class="du lt lu lv lw b">app.py</code>文件中添加主机参数。这允许在Docker容器之外访问应用程序。app.py中所需的更改突出显示如下:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="887f" class="jt ju hi lw b fi mf mg l mh mi">if __name__ == '__main__':<br/>    db.init_app(app)<br/>    ma.init_app(app)<br/>    app.run(port=5000, debug=True,<strong class="lw hj">host='0.0.0.0'</strong>)</span></pre><h2 id="8005" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">2.2创建Docker容器映像</h2><p id="72c2" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">创建Dockerfile之后，使用docker build命令构建Docker容器映像。这将首先读取编写指令的Dockerfile文件，然后自动构建映像，然后可以运行该映像。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="1007" class="jt ju hi lw b fi mf mg l mh mi">$ docker build -t sumand/python-sample-flask .</span></pre><p id="eae3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们要求Docker在相同的位置使用Docker文件构建一个映像。t参数为将要构建的图像设置名称/标签。最后一个参数是一个点(。)，这表示当前文件夹中的所有内容都需要打包到构建中。</p><p id="e3ce" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用以下命令检查创建的映像:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="569b" class="jt ju hi lw b fi mf mg l mh mi">$ docker images</span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/88aefa611a4857118098028e97f5d4a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qf_pqiy_pSH_Cq7UsZ-16Q.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">docker图像</figcaption></figure><h2 id="3b70" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">2.3将映像推送到Docker Hub</h2><p id="927c" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">接下来，我们需要将docker映像推送到Docker Hub，这将允许我们创建、测试、存储和分发容器映像。Docker映像通过docker push命令推送到Docker Hub，如下所示:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="617e" class="jt ju hi lw b fi mf mg l mh mi">$ docker push sumand/python-sample-flask:latest</span></pre><p id="9e43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，docker映像已经创建，我们可以使用这个docker映像从任何地方运行Flask应用程序。</p><h2 id="70aa" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">3.创建自定义函数</h2><p id="f1a6" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">在前面的步骤中，我们使用arkade CLI将OpenFaaS部署到Kubernetes集群。现在，让我们使用OpenFaas模板创建一个函数，我们可以在OpenFaas中部署它。</p><p id="d0f4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我们有一个dockerized Flask应用程序，所以我们将使用OpenFaas的<code class="du lt lu lv lw b">dockerfile</code> <a class="ae js" href="https://github.com/openfaas/templates" rel="noopener ugc nofollow" target="_blank">模板</a>来创建我们的函数，如下所示:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="283e" class="jt ju hi lw b fi mf mg l mh mi">export OPENFAAS_PREFIX=sumand<br/>faas-cli new --lang dockerfile <!-- -->sample-flask-service</span></pre><p id="55d3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">OpenFaas函数存储为一个容器映像。这里，我们将使用DockerHub来存储我们的图像。因此，我们用DockerHub用户名设置环境变量<code class="du lt lu lv lw b">OPENFAAS_PREFIX</code>。</p><p id="3959" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><code class="du lt lu lv lw b">faas-cli<em class="ls"> new</em></code>使我们能够在当前目录下通过dockerfile模板创建一个新函数</p><p id="ef2a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，我们使用<code class="du lt lu lv lw b">OpenFaas</code>模板dockerfile创建了一个名为<code class="du lt lu lv lw b">sample-flask-service</code>的函数。</p><p id="ce29" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">执行上述命令后，我们会发现创建了以下文件:</p><ul class=""><li id="1d07" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lr lg lh li bi translated">样本-烧瓶-服务. yml</li><li id="0ba7" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">样品瓶服务/文档</li></ul><figure class="lx ly lz ma fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/4134c71f3cd1883673bd08d0783b9e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*r3YFXsm4GYw23vQecXBOTw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">功能文件</figcaption></figure><p id="1c0d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们必须根据我们的要求更新上述文件。</p><h2 id="e15f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">3.1更新sample-flask-service.yml</h2><p id="99a9" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated"><strong class="iw hj">sample-flask-service . yml</strong>包含有关如何构建和部署函数的信息。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mn mo l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">样本-烧瓶-服务. yml</figcaption></figure><p id="8769" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代码行解释如下:</p><ul class=""><li id="dc51" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lr lg lh li bi translated">第1到4行包含关于OpenFaas和Gateway的信息。我们不需要做任何改变，因为我们使用本地OpenFass，否则我们需要更新网关URL。</li><li id="1e36" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">第6行包含我们之前创建的函数的名称。</li><li id="4cdc" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">第7行指定了我们在创建函数时使用的模板。</li><li id="cf25" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">第8行指定了我们的函数代码所在的文件夹(不是文件)。</li><li id="6b25" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">第9行指定了函数的Docker图像名，它将使用适当的前缀来构建。</li><li id="446e" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj">环境变量:</strong>第10到14行包含环境值，我们已经根据我们的需求覆盖了这些值。<br/>将环境变量<code class="du lt lu lv lw b">RAW_BODY</code>设置为<code class="du lt lu lv lw b">true</code>需要将<code class="du lt lu lv lw b">context.body</code>设置为原始请求体，而不是将其解析为JSON的默认行为。<br/>此外，我们还更新了超时值，因为当这些值设置得太低时，会导致功能过早退出。</li><li id="f2c0" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated"><strong class="iw hj">自动缩放:</strong>需要第15到18行来启用<code class="du lt lu lv lw b">autoscaling</code>。默认情况下，OpenFaas将至少维护我们函数的一个副本，以便它是热的，随时准备以最小的延迟提供流量。因为我们需要我们的函数是<strong class="iw hj">无服务器</strong>的，我们需要设置<code class="du lt lu lv lw b">com.openfaas.scale.zero:true</code>和<code class="du lt lu lv lw b">faasIdler.dryRun=false</code>，我们在前面的步骤<strong class="iw hj"> 1.2 </strong>中已经做了。</li></ul><h2 id="eda1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">3.2更新Dockerfile</h2><p id="9266" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">现在，为我们的函数更新docker文件。</p><figure class="lx ly lz ma fd ij"><div class="bz dy l di"><div class="mn mo l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">DockerFile文件</figcaption></figure><p id="f098" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">代码行解释如下:</p><ul class=""><li id="28f9" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lr lg lh li bi translated">第1行指定of-watchdog:0.8.0作为基本映像。<code class="du lt lu lv lw b">of-watchdog</code>实现一个HTTP服务器监听端口8080，作为运行函数和微服务的反向代理。它可以用于将请求转发给我们的应用程序。</li><li id="31bc" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">第2行指定了我们在<strong class="iw hj">步骤2 </strong>中创建的样品瓶应用程序的图像。</li><li id="cf82" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">在第6–7行，我们从基本映像安装看门狗。</li><li id="8777" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">从第9行到第19行，我们设置了非根用户以及访问权限。</li><li id="53c9" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">从第21-27行开始，我们将watchdog设置为启动进程，将upsteam _ url设置为flask应用程序的url。</li></ul><h2 id="9af5" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">4.部署功能</h2><p id="9850" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">我们的定制功能现在可以部署了。执行以下命令来部署该功能。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="6e7b" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">faas-cli up -f sample-flask-service.yml</strong></span></pre><p id="0019" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述命令在内部执行以下操作:</p><ul class=""><li id="1c7e" class="la lb hi iw b ix iy jb jc jf lc jj ld jn le jr lr lg lh li bi translated">创建函数的本地容器图像</li><li id="78e4" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">将映像推送到远程注册中心，在我们的例子中是docker hub</li><li id="fb6a" class="la lb hi iw b ix lj jb lk jf ll jj lm jn ln jr lr lg lh li bi translated">使用OpenFaas REST API，在Kubernetes集群内部创建一个部署和一个新的Pod来服务流量</li></ul><p id="3a2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们的Flask应用程序已经被部署为OpenFaaS的一个功能。</p><h2 id="41d6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">5.测试功能</h2><p id="5562" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">我们已经在OpenFaas中将我们的函数部署为启用了自动缩放的无服务器函数。在继续测试我们的功能之前，我们必须设置对进程的监控，以了解无服务器实际上是如何工作的。出于监控目的，我们可以使用<strong class="iw hj"> Grafana </strong>。</p><p id="edac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以使用下面的命令轻松地将<strong class="iw hj"> Grafana </strong>部署为Kubernetes集群中的一个pod。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="12f5" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl -n openfaas run --image=stefanprodan/faas-grafana:4.6.3 \<br/>--port=3000 grafana</strong></span></pre><p id="0956" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">接下来，从我们的本地计算机使用端口转发来访问Grafana，而不将其暴露给互联网。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="5ace" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl port-forward deployment/grafana 3000:3000 -n openfaas</strong></span></pre><p id="1e03" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从<a class="ae js" href="http://127.0.0.1:3000/." rel="noopener ugc nofollow" target="_blank"><strong class="iw hj">http://127 . 0 . 0 . 1:3000/</strong></a><strong class="iw hj">打开OpenFaas Grafana仪表板。</strong>输入<strong class="iw hj"/>Grafana的默认密码，即<strong class="iw hj"> admin: admin。</strong>open FAAS Grafana仪表盘如下所示:</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mp"><img src="../Images/95c4e92fb7009a417655f58035f29761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p3XGniylLVMH_aefzRKeJw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">OpenFaas Grafana仪表板</figcaption></figure><p id="3f81" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从仪表板中，我们可以看到没有运行的函数实例。这是因为我们在<strong class="iw hj">步骤3 </strong>中启用了自动缩放和<code class="du lt lu lv lw b">com.openfaas.scale.zero:true</code>。这意味着如果我们在一段时间内没有处理任何请求，那么所有的功能都将停止。这将有助于我们节约成本。</p><p id="4fdd" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们向flask应用程序发送一个请求，并检查输出。</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="9c39" class="jt ju hi lw b fi mf mg l mh mi">curl <a class="ae js" href="http://127.0.0.1:8080/function/sample-flask-service/api/items" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8080/function/sample-flask-service/api/items</a></span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/9ecd03fda983b50192bf625e18ee2beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pGgtx6E20QUIRendj8bZNg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">测试我们的Flask应用程序公开的一个API</figcaption></figure><p id="239f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我们的示例请求成功执行，请再次检查Grafana仪表板。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mr"><img src="../Images/f8199c85569ff13c98af098202fbc751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WVpedqKqB0CwuUz96M_pfQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">显示自动缩放的Grafana仪表板</figcaption></figure><p id="554f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从控制面板中，我们可以看到副本的数量从0增加到了1，以满足请求。该副本计数将根据负载进一步增加，直到<strong class="iw hj">步骤3.1更新sample-flask-service.yml </strong>中指定的<code class="du lt lu lv lw b">com.openfaas.scale.max</code>。</p><p id="8b56" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">自动缩放在后台工作的方式是阻塞请求，直到达到所需的副本数量。我们可以从如下网关日志中验证这一点:</p><pre class="lx ly lz ma fd mb lw mc md aw me bi"><span id="de29" class="jt ju hi lw b fi mf mg l mh mi"><strong class="lw hj">kubectl logs -n openfaas deploy/gateway -c gateway -f</strong></span></pre><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/2df51be80f2a852a58fbea77016f7b4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cKm4V5ZndKy1b9vqZ2ZNSw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">副本计数的网关日志</figcaption></figure><p id="7917" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因为我们在函数中启用了<code class="du lt lu lv lw b">com.openfaas.scale.zero:true</code>，所以不用的时候会自动缩小。我们可以在仪表板中验证这一点。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/e2e5c6e32103ed2862e276a72c09e51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fif4YqTmYjrmj1DUN27mWg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">缩小到0</figcaption></figure><p id="5bf2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们的示例Flask应用程序的所有API都可以在OpenFaas中获得，并且可以以无服务器的方式执行。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/37fc41d188ccec4e10cc4d00e7183544.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f3PH2MorTxo6wIMcRsyqjw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">烧瓶API Swagger</figcaption></figure><p id="fa5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面显示的大摇大摆的图像来自我们的示例Flask应用程序，作为参考。</p><div class="mv mw ez fb mx my"><a href="https://github.com/sumanentc/python-sample-flask-application" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">suman entc/python-样品-烧瓶-应用</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">进入项目文件夹并执行下面的命令。我们将使用Pipenv来设置VirtualEnv。管道外壳…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">github.com</p></div></div><div class="nh l"><div class="ni l nj nk nl nh nm io my"/></div></div></a></div><p id="d6e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">要在OpenFaas中调用上面的任何API，只需在开头加上<code class="du lt lu lv lw b">http://127.0.0.1.:8080/function/sample-flask-service/api/</code>，后跟端点。例如，调用<code class="du lt lu lv lw b">/stores</code> API使用<code class="du lt lu lv lw b">http://127.0.0.1:8080/function/sample-flask-service/api/stores</code>。</p><p id="d867" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果您想参考完整的代码，请检查:</p><p id="80f5" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><a class="ae js" href="https://github.com/sumanentc/openfaas-sample-function.git" rel="noopener ugc nofollow" target="_blank">https://github.com/sumanentc/openfaas-sample-function.git</a></p><h2 id="8f09" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">结论</h2><p id="0759" class="pw-post-body-paragraph iu iv hi iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">使用OpenFass模板，我们可以轻松地将现有的Flask应用程序移植到OpenFass，并以无服务器的方式执行。</p><h2 id="3f74" class="jt ju hi bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">参考资料和有用的读物</h2><div class="mv mw ez fb mx my"><a href="https://docs.openfaas.com/deployment/kubernetes/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">库伯内特斯-奥本法斯</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">在部署OpenFaaS之前，您应该提供一个Kubernetes集群。部署本地或…有许多选择</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">docs.openfaas.com</p></div></div><div class="nh l"><div class="nn l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://helm.sh/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">舵</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Helm是查找、共享和使用为Kubernetes构建的软件的最佳方式。Helm帮助您管理Kubernetes…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">helm.sh</p></div></div><div class="nh l"><div class="no l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://github.com/alexellis/arkade" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">alexellis/arkade</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">arkade提供了一个便携式市场，可以下载您最喜欢的devops CLIs和安装舵图，并带有一个…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">github.com</p></div></div><div class="nh l"><div class="np l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://github.com/openfaas/templates" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">open FAAS/模板</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">要了解更多关于OpenFaaS模板的信息，请访问faas-cli。注意:模板是完全可定制的-所以如果…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">github.com</p></div></div><div class="nh l"><div class="nq l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://www.openfaas.com/blog/zero-scale/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">使用OpenFaaS扩展到零，然后再返回</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">在这篇文章中，我将解释如何通过让OpenFaaS自动将函数缩放到零来节省资源…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.openfaas.com</p></div></div><div class="nh l"><div class="nr l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://docs.openfaas.com/architecture/watchdog/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">看门狗</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">OpenFaaS看门狗负责启动和监控OpenFaaS中的函数。任何二进制文件都可以成为…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">docs.openfaas.com</p></div></div><div class="nh l"><div class="ns l nj nk nl nh nm io my"/></div></div></a></div><div class="mv mw ez fb mx my"><a href="https://www.openfaas.com/blog/openfaas-flask/" rel="noopener  ugc nofollow" target="_blank"><div class="mz ab dw"><div class="na ab nb cl cj nc"><h2 class="bd hj fi z dy nd ea eb ne ed ef hh bi translated">用OpenFaaS构建Flask微服务</h2><div class="nf l"><h3 class="bd b fi z dy nd ea eb ne ed ef dx translated">Flask和无服务器风格的Python函数哪个更好？为什么不两者兼得呢？OpenFaaS有几个流行的Python…</h3></div><div class="ng l"><p class="bd b fp z dy nd ea eb ne ed ef dx translated">www.openfaas.com</p></div></div><div class="nh l"><div class="nt l nj nk nl nh nm io my"/></div></div></a></div></div></div>    
</body>
</html>