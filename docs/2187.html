<html>
<head>
<title>Build and Test High-Performance web app in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python构建和测试高性能web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/build-and-test-high-performance-web-app-in-python-916a63d4df4e?source=collection_archive---------7-----------------------#2021-04-11">https://medium.com/analytics-vidhya/build-and-test-high-performance-web-app-in-python-916a63d4df4e?source=collection_archive---------7-----------------------#2021-04-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="9d24" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在本文中，我们使用Uvicorn构建了一个简单的应用程序，并使用locust框架执行了负载测试</h2></div><blockquote class="iw ix iy"><p id="3bd2" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">留在最后，获得如何扩展服务器以在多核上运行的奖励</strong></p></blockquote><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es jw"><img src="../Images/0c9858e0e8a885cc5781535b902233a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HR65iAGT5uc2piVk"/></div></div></figure><h1 id="82b4" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">紫玉米</h1><p id="23d6" class="pw-post-body-paragraph iz ja hh jc b jd la ii jf jg lb il ji lc ld jl jm le lf jp jq lg lh jt ju jv ha bi translated">Uvicorn是一个快如闪电的ASGI服务器实现，使用了<a class="ae li" href="https://github.com/MagicStack/uvloop" rel="noopener ugc nofollow" target="_blank"> uvloop </a>和<a class="ae li" href="https://github.com/MagicStack/httptools" rel="noopener ugc nofollow" target="_blank"> httptools </a>。</p><h1 id="60ea" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">蝗虫</h1><p id="76c8" class="pw-post-body-paragraph iz ja hh jc b jd la ii jf jg lb il ji lc ld jl jm le lf jp jq lg lh jt ju jv ha bi translated">开源负载测试工具。用<strong class="jc hi"> Python </strong>代码定义用户行为，让数百万用户同时涌入你的系统。</p><p id="5232" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated"><strong class="jc hi">设置</strong></p><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="af2b" class="lo kj hh lk b fi lp lq l lr ls">|Application<br/>   -&gt;| -server.py<br/>   -&gt;| -test.py<br/>   -&gt;| -User1.py<br/>   -&gt;| -USer2.py</span><span id="53d1" class="lo kj hh lk b fi lt lq l lr ls">Server.py will contain our server code<br/>test.py will contain locust test configuration<br/>User1 and User2.py are to simulate dummy users</span><span id="c7f0" class="lo kj hh lk b fi lt lq l lr ls">Install required Libraries<br/>pip install uvicorn<br/>pip install locust</span></pre><p id="c389" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">继续将这段代码粘贴到server.py中</p><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="05ec" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">这可能看起来比通常的python代码要大，但是不要担心，让我们来分解它</p><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="ce3c" class="lo kj hh lk b fi lp lq l lr ls">we have two methods<br/>fastFact() =&gt; returns result imdeitaly<br/>slowfactFact() =&gt; returns result 5 sec later<br/>This are the methods will be invoked by client</span><span id="1936" class="lo kj hh lk b fi lt lq l lr ls">app() =&gt; is the starting point of our program which handels request from client and send response back to client</span><span id="deaa" class="lo kj hh lk b fi lt lq l lr ls">here most of the thing is boilerplate code<br/>Important lines are:<br/>line (18-19) we geting request body and converting into dict.<br/>line(20) geting result from factorial method (slow/fast)<br/>line (30) converting result into bytes and sending them back to client.</span><span id="8482" class="lo kj hh lk b fi lt lq l lr ls">Run this program using <br/>uvicorn server:app </span></pre><p id="a891" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">现在我们的服务器正在运行，让我们用客户端打开user1.py测试一下，然后粘贴下面的代码</p><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="ee5a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">这里没有什么特别的，我们只是发送get请求并检查响应，你可以改变方法为慢或快。打开新的终端/cmd运行</p><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="23ff" class="lo kj hh lk b fi lp lq l lr ls">python user1.py</span></pre><p id="71eb" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">现在我们的客户端和服务器已经设置好了，让我们为负载测试设置一个locust框架，打开test.py并粘贴下面的代码</p><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="lu lv l"/></div></figure><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="7809" class="lo kj hh lk b fi lp lq l lr ls">locust framework will spawn n user and execute callFast() for all those users for us</span><span id="5783" class="lo kj hh lk b fi lt lq l lr ls">Start two cmd<br/>In first cmd run command it will start our server<br/>uvicorn server:app --no-access-log</span><span id="db82" class="lo kj hh lk b fi lt lq l lr ls">--no-access-log =&gt; will disable logging in console other wise server console will be filled with logs</span><span id="ef07" class="lo kj hh lk b fi lt lq l lr ls">in second terminal run<br/>locust -f test.py </span><span id="9af5" class="lo kj hh lk b fi lt lq l lr ls">It will start locust framework<br/>open browser and go to localhost:8089 <br/>you will see you like below</span></pre><figure class="jx jy jz ka fd kb er es paragraph-image"><div class="er es lw"><img src="../Images/c2874493eefa5649fcaace2fbee40a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*5yh5pBkhvdxvpzHgx7_7IA.png"/></div></figure><p id="1a50" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">这里，locust框架从100个用户开始负载测试，在我们的主机服务器上每秒产生10个用户。之后，点击开始蜂拥而至</p><figure class="jx jy jz ka fd kb er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es lx"><img src="../Images/2c4760985dd5cdd42c193cfc603759e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkWxK2S1srusssP64g_5Dg.png"/></div></div></figure><p id="ef3b" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">你会看到这样的东西，这是服务器上的负载测试报告。单击图表，它将以图形格式显示其他详细信息</p><h1 id="db83" class="ki kj hh bd kk kl km kn ko kp kq kr ks in kt io ku iq kv ir kw it kx iu ky kz bi translated">奖金</h1><blockquote class="iw ix iy"><p id="d131" class="iz ja jb jc b jd je ii jf jg jh il ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="jc hi">如何扩展服务器以在多核上运行？</strong></p></blockquote><p id="12db" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">为了理解为什么我们需要我们的服务器在多核上运行</p><p id="6805" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated"><strong class="jc hi">执行以下步骤:</strong></p><p id="665d" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">打开User2.py并粘贴到代码下方</p><figure class="jx jy jz ka fd kb"><div class="bz dy l di"><div class="lu lv l"/></div></figure><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="1dec" class="lo kj hh lk b fi lp lq l lr ls">Open 3 terminal/cmd</span><span id="fa2c" class="lo kj hh lk b fi lt lq l lr ls">In first cmd<br/>run server <br/>uvicorn server:app </span><span id="4933" class="lo kj hh lk b fi lt lq l lr ls">In second cmd<br/>run second client this will invoke slow calculation method<br/>python User2.py</span><span id="6bf6" class="lo kj hh lk b fi lt lq l lr ls">In third cmd<br/>run first client this will invoke fastcalculation method<br/>python USer1.py</span></pre><p id="0e9c" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">您会注意到，运行User2后，结果在5秒钟后返回，如slow方法中所述，但是User1也必须等待5秒钟，因为服务器正忙于执行User2任务。这是我们不想要的。</p><p id="2b37" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">为了解决这个问题，我们将利用系统中可用的多个内核，以便服务器可以并行执行多个请求。幸运的是，使用Uvicorn很容易实现，我们只需要在启动服务器时传递worker参数</p><pre class="jx jy jz ka fd lj lk ll lm aw ln bi"><span id="350c" class="lo kj hh lk b fi lp lq l lr ls">So now the server invocation command looks like this <br/>uvicorn server:app --workers 4 (no of avilable cores in system) </span></pre><p id="468f" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">再次尝试上述场景，你会注意到用户1立即得到回复，用户2在5秒后得到回复。</p><h2 id="755d" class="lo kj hh bd kk ly lz ma ko mb mc md ks lc me mf ku le mg mh kw lg mi mj ky mk bi translated">结论</h2><p id="3569" class="pw-post-body-paragraph iz ja hh jc b jd la ii jf jg lb il ji lc ld jl jm le lf jp jq lg lh jt ju jv ha bi translated">在本文中，我们学习了如何使用Uvicorn sever框架在python中设置ASGI服务器，并对应用程序执行真实测试，以及如何在多个内核上扩展应用程序。</p><p id="9c3a" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">敬请关注未来的帖子，我们将看到更多这方面的高级用例，如如何正确实现async/await以使服务器更加健壮和无阻塞，以及使用celery框架进行后台处理等。</p><p id="28bc" class="pw-post-body-paragraph iz ja hh jc b jd je ii jf jg jh il ji lc jk jl jm le jo jp jq lg js jt ju jv ha bi translated">谢谢你，快乐编码</p></div></div>    
</body>
</html>