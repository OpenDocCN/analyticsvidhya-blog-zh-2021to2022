<html>
<head>
<title>Complete Guide to Data Cleaning with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python数据清理完整指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/complete-guide-to-data-cleaning-with-python-8c686104686c?source=collection_archive---------0-----------------------#2022-03-25">https://medium.com/analytics-vidhya/complete-guide-to-data-cleaning-with-python-8c686104686c?source=collection_archive---------0-----------------------#2022-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="3dab" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">了解如何逐步进行数据清理</h2></div><p id="3e43" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我很确定你听过这句著名的数据科学名言:</p><blockquote class="jt ju jv"><p id="e2aa" class="ix iy jw iz b ja jb ij jc jd je im jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated">在数据科学项目中，数据清理需要花费90%的时间。</p></blockquote><p id="efb7" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您还没有，那么请记住，数据清理是数据科学工作流程的基础。正如人们吃什么就是什么(另一句名言)，机器学习模型根据你给它提供的数据来执行。长话短说，杂乱的数据会导致糟糕的性能，而干净的数据是良好模型性能的先决条件。当然，干净的数据并不意味着始终有好的性能，正确选择模型(剩余的10%)也很重要，但是没有干净的数据，即使是理想的模型也无法在理想的水平上执行。</p><p id="acf4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">在这篇博客</strong>中，我将列出<strong class="iz hj">数据清理</strong>中解决的<strong class="iz hj">问题</strong>，并展示可能的<strong class="iz hj">解决方案。</strong></p><p id="adf9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">希望你会喜欢！</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ka"><img src="../Images/5de73a863387c7e72266c19600bc22d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QJe_yTA_C8J0UudBRGbYlg.png"/></div></div></figure><h1 id="32f1" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">缺失数据</h1><p id="eb03" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">当数据集中存在缺失数据时，最好不要急于去填补。因为空细胞这个地方本身就能告诉你一些有用的东西。例如:</p><ul class=""><li id="041c" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">NA值仅在数据集的尾部或中部背靠背。这意味着，在数据收集过程中可能存在技术问题。然后，您分析特定样本序列的数据收集过程，并尝试找到问题的根源。</li><li id="b0de" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">如果70–80%以上的列为NA，您可以删除该列。</li><li id="e773" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">如果NA值在表格中的可选问题列中，则该列可以像用户回答(1)或未回答(0)那样解码。</li></ul><p id="04eb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用python库来检查上述情况，该库的<code class="du lx ly lz ma b"><a class="ae mb" href="https://github.com/ResidentMario/missingno" rel="noopener ugc nofollow" target="_blank">missingno</a>.</code> <code class="du lx ly lz ma b">matrix </code>函数对于这种方式非常方便。图中的白线是NAs:</p><pre class="kb kc kd ke fd mc ma md me aw mf bi"><span id="6e95" class="mg kn hi ma b fi mh mi l mj mk">import missingno as msno<br/>msno.matrix(df)</span></pre><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ml"><img src="../Images/230ed50282a0f0c66a7c35f3035f01e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9EhMnZvK4Ilu4u5MUPiFA.png"/></div></div></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="9193" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">说到插补，有很多方法，比如:</p><ul class=""><li id="8fc7" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">均值、中值、众数；</li><li id="a3de" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">kNN</li><li id="a575" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">零或常数等。</li></ul><p id="761a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不同的方法各有优缺点，也没有适合所有情况的“最佳”技术。以下文章是插补技术的理论和代码实现的最佳资源之一:</p><div class="mt mu ez fb mv mw"><a href="https://towardsdatascience.com/6-different-ways-to-compensate-for-missing-values-data-imputation-with-examples-6022d9ca0779" rel="noopener follow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">弥补缺失数据的6种不同方法(数据插补，附实例)</h2><div class="nd l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kk mw"/></div></div></a></div><h1 id="52f4" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">极端值</h1><p id="0d39" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">异常值是相对于数据集的其他点而言非常大或非常小的值。它们的存在极大地影响了数学模型的性能。让我们通过这个简单的例子来了解性能下降的原因:</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nk"><img src="../Images/687e29745c8ce1cde3c58d5867bc4a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fsxpWMVknUxkAH0VhnzO5A.png"/></div></div></figure><p id="94da" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在左图中，没有异常值，直线与数据点非常吻合。然而，在右图中，存在一个异常值，当线试图覆盖数据集的所有点时，一个异常值的存在会改变线的位置，并且它不适合至少一半的点。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="1278" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们知道为什么离群值对数据集有害，让我们继续讨论一些数学概念。首先，有必要定义什么是“极大”或“极小”。</p><p id="d0e2" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">高于/小于Q3/Q1 1.5倍IQR(四分位间距)的值称为异常值。IQR是Q3和Q1的差值(IQR = Q3-Q1)。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="0459" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我编写了下面的函数来检查数据集中异常值的数量:</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="nl nm l"/></div></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="b906" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">处理异常值的一种方法是让它们等于Q3或Q1。通过使用pandas和numpy库，下面的函数完成了这个任务。给你。<code class="du lx ly lz ma b">lower_upper_range</code>函数查找外部为异常值的范围。然后使用<a class="ae mb" href="https://numpy.org/doc/stable/reference/generated/numpy.clip.html" rel="noopener ugc nofollow" target="_blank"> numpy clip </a>功能将数值剪切到范围内。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="nl nm l"/></div></figure><h1 id="d6a1" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">不一致的数据</h1><p id="1798" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">离群值问题是关于数值特征的，现在来说说字符串列。不一致的数据意味着一列的不同类有不同的表示。比如性别一栏，男/女和M / F都有，这种情况下会有4个班，但实际上有两个班。</p><p id="82ff" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如您所预测的，这个任务没有自动化，因此我们需要手动分析这些类。<code class="du lx ly lz ma b"><a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.unique.html" rel="noopener ugc nofollow" target="_blank">unique</a></code> <a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.unique.html" rel="noopener ugc nofollow" target="_blank">熊猫的功能</a>就是为了这个目的。我们以<a class="ae mb" href="https://www.kaggle.com/code/goyalshalini93/car-price-prediction-linear-regression-rfe/data" rel="noopener ugc nofollow" target="_blank">车价预测数据</a>的名称列为例来看。</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="nl nm l"/></div></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nn"><img src="../Images/e21f6da98a67eddc5c09a3528b41cf1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x13nroSNy3Em3Lxn8_525Q.png"/></div></div></figure><p id="a797" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有马自达、日产、保时捷、丰田等等。说明了不一致数据问题。我更喜欢用<a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html" rel="noopener ugc nofollow" target="_blank">熊猫loc函数</a>来解决:</p><figure class="kb kc kd ke fd kf"><div class="bz dy l di"><div class="nl nm l"/></div></figure><h1 id="b9c0" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">无效数据</h1><p id="a042" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">此类别包含逻辑上不正确的值。举个例子，</p><ul class=""><li id="d6a0" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js lo lp lq lr bi translated">某人年龄560；</li><li id="622d" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">花费的时间为-8小时；</li><li id="b309" class="lj lk hi iz b ja ls jd lt jg lu jk lv jo lw js lo lp lq lr bi translated">一个人的身高是1200厘米-秒等等。</li></ul><p id="39ca" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于数值列<a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.describe.html" rel="noopener ugc nofollow" target="_blank">，熊猫描述函数</a>可用于识别此类错误:</p><pre class="kb kc kd ke fd mc ma md me aw mf bi"><span id="842d" class="mg kn hi ma b fi mh mi l mj mk">df.describe()</span></pre><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es no"><img src="../Images/17aa853cb45661fb799c229ac5074173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q6If4L15g3Urm8-mbbaQrQ.png"/></div></div></figure></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="730f" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">导致无效数据的原因有两种:</p><ol class=""><li id="60ef" class="lj lk hi iz b ja jb jd je jg ll jk lm jo ln js np lp lq lr bi translated">数据收集错误</li></ol><p id="3256" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据工程师可以为高度列键入1799而不是179。这种随机错误可以被视为空值，并与其他n as一起进行估算。</p><p id="a86d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">2.数据操作错误</p><p id="cb5d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数据集的一些列可以是由开发人员编码的函数的输出。例如，一个函数根据出生日期计算年龄，结果是负数。这意味着方程是不正确的。</p><h1 id="bac0" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">重复数据</h1><p id="5981" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">当数据集中有相同的行时，就是重复数据问题。这可能是因为数据组合错误(同一行来自多个来源)，用户可能提交他或她的答案两次，等等。处理这个问题的理想方法是删除复制行。</p><p id="ec3a" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要检查是否有重复行，可以使用<a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.duplicated.html" rel="noopener ugc nofollow" target="_blank">熊猫重复功能</a>:</p><pre class="kb kc kd ke fd mc ma md me aw mf bi"><span id="0f56" class="mg kn hi ma b fi mh mi l mj mk">df.loc[df.duplicated()]</span></pre><p id="bb61" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">识别出重复项存在后，<a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.drop_duplicates.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>T0】的功能是删除重复行:</p><pre class="kb kc kd ke fd mc ma md me aw mf bi"><span id="93e3" class="mg kn hi ma b fi mh mi l mj mk">df.drop_duplicates()</span></pre><h1 id="1abd" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">数据类型</h1><p id="4c4f" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">使用年龄列时，您是否遇到过奇怪的字符串错误？这是因为列的数据类型分配不正确。因此，使用<a class="ae mb" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.dtypes.html" rel="noopener ugc nofollow" target="_blank"> pandas dtype函数</a>检查所有列的数据类型是一个很好的做法。</p><p id="aebf" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，我强烈建议您看看这篇关于不同数据类型的内存使用的文章，并通过选择正确的类型来加快进程。</p><div class="mt mu ez fb mv mw"><a href="https://www.linkedin.com/pulse/reducing-memory-usage-do-before-you-start-any-data-vusal-k-kamalzada/" rel="noopener  ugc nofollow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">减少内存使用:在开始任何数据科学项目之前这样做</h2><div class="nd l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">www.linkedin.com</p></div></div><div class="ne l"><div class="nq l ng nh ni ne nj kk mw"/></div></div></a></div><h1 id="5f3d" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">额外收获:数据泄露问题</h1><p id="f0bc" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">在建立模型之前，数据集被分成训练集和测试集。测试集是看不见的数据，用于评估模型性能。如果测试集在数据清理或数据预处理步骤中被模型以某种方式“看到”，则称为<strong class="iz hj">数据泄漏</strong>。这就是为什么应该在清理和预处理步骤之前拆分数据:</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nr"><img src="../Images/62dd212113f938a24f4889c4d9d7457f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Oy7RDF7hIPT_-X33aS6EBg.png"/></div></div></figure><p id="44cb" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以缺失值插补为例。数字栏中有NAs，用平均值法估算。当在分割前<em class="jw">完成时，使用整个数据集的平均值，但如果在</em>分割后<em class="jw">完成，将分别使用训练和测试的平均值。</em></p><p id="4cf4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一种情况的问题是，测试集中的估算值将与训练集相关，因为平均值是整个数据集的平均值。因此，当使用训练集构建模型时，它也会“看到”测试集。但是我们分割的目标是保持测试集完全新鲜，并像新数据一样用于性能评估。这就是为什么数据集必须在操作前分割。</p><p id="dd2b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">正如我们讨论为什么第二个场景是正确的，现在让我们继续讨论它将如何在代码中实现。根据第一印象，你可以说，这是没有效率的，也可能是正确的。但是由于数据泄露问题非常重要，而且是首要问题，所以这是您应该采取的方式。为了让它高效，sklearn库提供了<a class="ae mb" href="https://scikit-learn.org/stable/modules/generated/sklearn.pipeline.Pipeline.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hj">管道</strong> </a>。简单地说，管道是您将数据作为输入发送到的所有操作步骤的组合，输出是干净的数据。关于建设管道的细节，你可以参考这个博客:</p><div class="mt mu ez fb mv mw"><a href="https://towardsdatascience.com/how-to-use-sklearn-pipelines-for-ridiculously-neat-code-a61ab66ca90d" rel="noopener follow" target="_blank"><div class="mx ab dw"><div class="my ab mz cl cj na"><h2 class="bd hj fi z dy nb ea eb nc ed ef hh bi translated">如何将Sklearn管道用于极其简洁的代码</h2><div class="nd l"><p class="bd b fp z dy nb ea eb nc ed ef dx translated">towardsdatascience.com</p></div></div><div class="ne l"><div class="ns l ng nh ni ne nj kk mw"/></div></div></a></div><h1 id="3d2f" class="km kn hi bd ko kp kq kr ks kt ku kv kw io kx ip ky ir kz is la iu lb iv lc ld bi translated">谢谢你</h1><p id="03c1" class="pw-post-body-paragraph ix iy hi iz b ja le ij jc jd lf im jf jg lg ji jj jk lh jm jn jo li jq jr js hb bi translated">对于交流:</p><p id="bf3d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">【https://www.linkedin.com/in/anar-abiyev-224a45196】T4/</p></div></div>    
</body>
</html>