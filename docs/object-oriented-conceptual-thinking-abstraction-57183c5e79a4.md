# 面向对象的思维:抽象和封装

> 原文：<https://medium.com/analytics-vidhya/object-oriented-conceptual-thinking-abstraction-57183c5e79a4?source=collection_archive---------10----------------------->

在面向对象的海洋中平静地游泳

![](img/7cd32dd3a885257539307d52f6a2a378.png)

抽象，关注必要的东西，来自 ideelart.com 的形象

# 面向对象的思维:抽象和封装

在之前的[文章](https://arvindhhp.medium.com/object-oriented-thinking-multiple-inheritance-c782c1d64b8)中，我已经介绍了继承背后的思想过程以及简单、多层次和多重继承的实现细节。

在这本笔记本中，我已经谈到了 Python 中抽象和封装的 OOPs 概念的基本实现。在接下来的文章中，我们将深入探讨其他一些糟糕的事情

请注意，文章中所有代码的要点都是使用 Github 要点嵌入的。要查看输出，请参考 Jupyter notebook @ [Github 链接](https://github.com/arvindhhp/PyPro_ahhp/blob/main/Part_016_OOP_Abstraction_Encapsulation.ipynb)

快乐的哎呀(:

# 抽象和封装思想

抽象背后的思想来自于这样一个事实:根据需求，只有相关的数据需要共享。考虑到这种情况，一些客人要回家了，我打算给大家做些甜点。我需要一些额外的糖，所以我想把这个送到我家。店主只需要知道糖的数量和我家的地址。他无权知道我为什么需要这么多糖，也无权知道我是如何估算出这个数字的。在这里，我只是传达了什么是必要的和相关的店主。这是抽象的概念。敏感信息、后台工作方法、特定执行过程中产生的无关数据等。不需要暴露给用户。我们可以实现抽象的想法来实现这一点。

在实现抽象时，我们创建一个公共的模板对象作为接口，确保只有特定的一组信息被传送到下游。就像上面的例子一样，接口是店主和我之间的职业关系，共享的数据只是糖的数量和送货地址。抽象也涉及到代码的可重用性。与上述情况类似，即使是 Swiggy 食品配送、亚马逊配送和日常乳制品供应也需要完全相同类型的投入。这只是意味着，一个通用的模板适用于所有人。

当一个应用程序由不同层次的多个用户开发时，抽象成为 OOP 中的一部分。一个人不可能记住这个大类的所有细节，因此确保只允许访问需要传输的相关信息。我已经在猜测，抽象的概念现在在我们的头脑中已经很清晰了。在 Python 中，我们可以使用一个非常简单直观的抽象类概念来实现抽象。我们将很快讨论这个问题。

精神食粮，让我们试着思考这个事实:**我们真的都知道一个简单的印刷体(“Hello”)是如何工作的吗？？除了 0 和 1 之外，计算机什么也不懂。一些聪明的人已经确保，这种印刷(“你好”)能被计算机很好地理解，并确保我们不需要通过将我们暴露在铺天盖地的信息中来经历所有这些困难。这是一个“抽象实现”的经典例子**

另一方面，将属性和方法包装在类中并只显示相关和必要的信息的概念被称为封装。这里的想法是将属性，即数据和要在该数据上实现的方法保持在同一屋檐下，即一个类。基本上，当我们使用一个类/对象时，我们就进入了封装阶段。

隐藏的细节是，作为开发人员，我们可能已经定义了某些属性，这些属性的值在代码执行期间会动态更新。我们真的不希望任何外部代理人不小心弄乱了这些信息。但同时，我们也不能让这些数据完全不可访问。如果有人真的需要更新一个这样的属性怎么办。

**将所有属性及其方法包装在一个类中，然后保护它们免受意外访问，并允许附加机制访问同一屋檐下的受限成员的整个过程称为封装。**

属性安全性可以通过根据需求将变量设为公共、受保护或私有来实现。为了允许访问受限成员，我们可以使用 setter()和 getter()函数。我们将在文章的后面讨论这些。

# 抽象类

一个抽象类可以被认为是其他类的蓝图。它允许您创建一组方法，这些方法必须在从抽象类构建的任何子类中创建。

抽象类只定义空方法(也称为抽象方法)，它只是为其子类提供模板来定义它们的实现。例如，基于上面的例子“产品类型”、“数量”和“地址”，抽象类将只定义空函数来获取这些输入，它不会实现如何以及从哪里获取这些输入。它必须只在子类中定义。这样做是为了使任何下游定义中的任何模块化变化都不会影响其他对象。例如，如果 Swiggy 除了地址之外还需要到你家的 Google 地图位置的附加信息，但其他人不需要它，我们可以只在 SWIGGY 类中修改实现。

创建抽象类时要记住几点:

1)需要关键字 ABC(代表抽象基类)

2)抽象方法的空实现需要从 **decorator @abstractmethod** 开始

3)继承抽象基类的子类必须强制定义所有抽象方法的实现

4) ABC 不能实例化。Python 否认 ABC 对象创建。

如果一个对象是为一个 ABC 创建的，我们将有机会访问定义的空抽象方法。因此，Python 确保了 ABC 不能被实例化。

让我们试着复制上述交货的例子来封闭我们的理解。

请注意，本文不讨论装饰者的细节。目前，让我们从语法的角度记住这一点。

更多关于装修工的信息，请参考:【https://www.geeksforgeeks.org/decorators-in-python/

抽象类定义

抽象方法实现

抽象实现

# 包装

我们已经讨论了意识形态。我们将逐步理解可以应用于类属性的不同类型的访问限制。我们将以一个简单的类来结束本文，该类实现了用于访问和修改私有变量的类中的 setter()和 getter()。

# 公共、受保护和私有变量

Public、Protected 和 Private 是可以应用于类中定义其可访问性的任何属性的限制。

公共属性/变量是那些可以在任何地方使用点符号访问的属性/变量(显然)受保护的属性/变量只能在包内访问私有属性/变量只能在类内访问通常，在 OOP 语言中，我们使用像 Public 或 Private 这样的关键字来定义作用域。但是在 Python 中，我们在属性名前面使用单下划线和双下划线，分别表示属性是受保护的还是私有的。在 Python 中，抽象不像在其他 OOP 语言中那样严格。Python 的创始人认为，每个人都有权访问所有的变量，因此，私有变量也可以在类之外被访问。我们将在下面的代码片段中看到这是如何实现的。

具有受保护和私有变量的类定义

封装类对象创建

以通常的方式访问私有和公共变量

![](img/f6d7fdfaa95f3fdcd6fd7b43ade59c79.png)

私有属性访问问题

# 私有变量的注释

我们可以看到，内置的 **str** ()能够访问私有属性，但是当从类外部使用点符号访问私有属性时，我们会遇到访问属性错误异常。这是因为私有变量被隐藏了。

# 访问类外的私有变量

访问可以通过在调用私有变量时以点符号寻址类以及类的对象来实现。

以正确的方式访问私有变量

# 在类外修改私有变量

从类外的区域修改私有变量可以通过使用 setter 函数来实现。

# 使用 getter()和 setter()函数

需要在类中定义一个单独的方法，该方法使用一个参数从类中提取一个新值或将该值赋给私有变量。

定义为从类外部提取所需私有变量的方法称为 getter()

定义为从类外部更新私有变量的值的方法称为 setter()

记住，setter()和 getter()是用户定义的函数。而且这些都不是关键词，我们可以用任何名字。这里的重点是关于达到私有属性的目的。因为私有属性可以很容易地从类中访问，所以我们在类本身中定义了这样的方法。

Setter 和 Getter 函数定义

Setter 和 Getter 函数的用法

![](img/91b58749f4dc63e6df7224f0d1349f1e.png)

封装输出

这就结束了我们对使用 Python 进行抽象和封装的基本讨论。

代码可从@ [Github](https://github.com/arvindhhp/PyPro_ahhp/blob/main/Part_016_OOP_Abstraction_Encapsulation.ipynb) 获得