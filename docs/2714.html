<html>
<head>
<title>Segmentation Analysis with K-means Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于K-均值聚类的分割分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/segmentation-analysis-with-kmeans-clustering-93d05565a9f8?source=collection_archive---------11-----------------------#2021-05-14">https://medium.com/analytics-vidhya/segmentation-analysis-with-kmeans-clustering-93d05565a9f8?source=collection_archive---------11-----------------------#2021-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7ef181c1ede8693c37f60a5d02f9d508.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jI88owqnZk4ekuvt.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">来源:bluetext.com</figcaption></figure><p id="b535" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">聚类是将相似的客户放入互斥的组中的过程；这些组被称为“段”，而分组的行为被称为分段。细分使企业能够识别他们所服务的客户/市场的不同类型和偏好。这是制定高效营销、产品和商业战略的关键信息。</p><p id="cba2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">集群的一些常见应用包括:</p><ul class=""><li id="beb8" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">识别购买模式</li><li id="e721" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">给新客户的建议</li><li id="60ab" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">欺诈检测</li><li id="267a" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">识别客户群</li><li id="2272" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">保险事故</li><li id="e6ae" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">自动分类内容</li><li id="d939" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">识别生物联系的遗传标记</li><li id="0319" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">表征患者行为</li><li id="e851" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">离群点检测</li><li id="7ee4" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">汇总生成</li><li id="ffdf" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">探索性数据分析</li></ul><p id="3053" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇文章中，你将学习如何使用Kaggle的<a class="ae it" href="https://www.kaggle.com/arjunbhasin2013/ccdata" rel="noopener ugc nofollow" target="_blank">信用卡数据集</a>进行客户细分分析。目标是开发客户细分，以确定营销策略。我们得到了9000名活跃信用卡持有者的数据，每个人有18个行为变量。</p><p id="694a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是对数据集中给出的变量的描述:</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kg"><img src="../Images/a150a02e35cd4ab4d3298f327cca36bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rzyc7eDTSO1AS56Fvj3T3Q.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">来源:www.kaggle.com<a class="ae it" href="https://www.kaggle.com/arjunbhasin2013/ccdata" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="a6a7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将用来执行分段分析的算法是K均值聚类。K-Means是一种基于分区的算法，在中型/大型数据集上表现良好。该算法是一种无监督学习算法，利用数据中的相似性来创建无标签的组。分割指的是分成不重叠的k个子集。目标是使每个分类中的数据尽可能相似，同时使每个分类尽可能不同于其他分类。从技术角度来说，我们寻求最小化集群内的距离，同时最大化集群间的差异。</p><p id="07d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以使用各种距离度量来最小化簇内距离和最大化簇间距离，例如欧几里德、余弦相似度等。度量标准的选择在很大程度上取决于您的领域问题，最好对多维数据集的要素进行归一化。其他类型的聚类算法包括层次聚类和基于密度的聚类。</p><h2 id="e6d6" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">K-表示步骤:</strong></h2><ul class=""><li id="79f6" class="js jt hh iw b ix lg jb lh jf li jj lj jn lk jr jx jy jz ka bi translated">分配k个质心-质心用于表示簇的“中心”</li><li id="040a" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">计算每个物体到每个质心的距离</li><li id="94d8" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">将最靠近质心的数据点分配到一个聚类中</li><li id="b18c" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">重新计算k个质心的位置以最小化簇内距离和最大化簇间距离</li><li id="7e0e" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">重复这些步骤，直到质心不再改变</li></ul><p id="b276" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们将构建程序。首先，我们将导入必要的库并定义一些辅助函数。(提示:设计助手功能来自于计划阶段，但也来自于在开始构建时识别模式和重构代码)</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ll"><img src="../Images/ccafddeb5dcd97174d0a850566675ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uK625x55P_61XsIVu_rtBA.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/64e6b912be1e6422b8b243eb8710ab2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*_-_jbV3e9iAYr3PbkyZwHg.png"/></div></figure><h2 id="f2c1" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">检查数据类型</strong></h2><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es ln"><img src="../Images/f5919d7e6da797fc774ac7a1463361a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*Mb4F4AUOPH1K3MLeNoCvrQ.png"/></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/d42abb0166a529115d1e5d198e72e19c.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*EbuB5TtjhQYyy86RkvhyBQ.png"/></div></figure><h1 id="a299" class="lp km hh bd kn lq lr ls kr lt lu lv kv lw lx ly ky lz ma mb lb mc md me le mf bi translated"><strong class="ak">检查缺失值</strong></h1><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/89162fd34dec51c2165f0e2d74dfdb2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JRnjTEUdId8amRAlYzTwjA.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/b7c5f747a9f37280976896b2074e300a.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*k7ejzo9gFxQG2XCh2LOxJw.png"/></div></figure><p id="6816" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以看到MINIMUM_PAYMENTS和CREDIT_LIMIT字段缺少值。</p><p id="af78" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将研究这些值，以了解它们的分布情况，并决定如何处理它们。</p><h2 id="dd07" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">探索带有缺失值的数据</strong></h2><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mi"><img src="../Images/7c7b3f37e87af3acce529e748d3ad171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6SHcAx6bVHAH2ipdhHMXQ.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es mj"><img src="../Images/79b4566e86f43ce77756582fd2dc300a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsjPHlwHfyPBSd_SqYG-aA.png"/></div></figure><p id="22e7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如您所见，它们都有显著的异常值。用中位数或平均值进行估算会导致我们的数据出现偏差。我们将利用回归和我们在开始时定义的帮助函数</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/c29976e6fa1d0a910e004b46a0c93177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-53UOb6rMVERgDXOOAN1ug.png"/></div></div></figure><p id="90fb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们将使用我们定义的另一个辅助函数来可视化异常值和所有特征的总体分布。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/0fc3aa1bd401c8d03b5400786f50fd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y35GPeahLcZbqbMkk0CFNQ.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/6cf1abb490df9288502c6f62b0231e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5yDJZ8JpWAIb_gB0oY6kqA.png"/></div></div></figure><p id="16a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的许多要素在其分布中存在显著差异，下一步将是在我们的要素缩放步骤中对数据集进行归一化。我们将通过使用我们定义的另一个助手函数来实现StandardScaler()</p><p id="131c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mn">简要概述:标准缩放器移除平均值并缩放至单位方差。其计算方式为:</em></p><p id="310a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> <em class="mn"> Z=(x-u)/s </em> </strong></p><ul class=""><li id="2fe1" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><em class="mn"> x =特征值</em></li><li id="92af" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><em class="mn"> u =平均值</em></li><li id="2ecb" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><em class="mn"> s =标准偏差</em></li></ul><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mo"><img src="../Images/d7a8d705084806b1579d0884250b0467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgMfrbsv8Ce3O40JRPZmGw.png"/></div></div></figure><p id="b132" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经完成了一些基本的EDA和预处理，我们将建立我们的模型。我们要做的第一件事是选择集群的数量。</p><h2 id="538c" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">选择集群数量</strong></h2><p id="3136" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf mp jh ji jj mq jl jm jn mr jp jq jr ha bi translated">常见的技术是对不同的K值进行聚类。然后，我们确定不同类型K的误差变化。增加K值总是会减少误差，但是，这不是我们想要建立模型的方式；最终，k等于数据集中的数据点数。</p><p id="fe43" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以将不同k的不同错误分数可视化，并选择“拐点”作为我们选择的k的数量。</p><p id="3565" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">拐点是k值急剧下降的地方。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/482ce46822be921db8b6c95134bbba38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDxNeE5RZyxWhtcPRmApHg.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div class="er es mt"><img src="../Images/b0eafce3beec17018db551b0a326565a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*Bwtoa4tJCOxRukhVQzLPFw.png"/></div></figure><p id="90b4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于可视化，我们将选择4来表示k簇。首先，我们将执行主成分分析。</p><h2 id="eb99" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">主成分分析</strong></h2><p id="fe22" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf mp jh ji jj mq jl jm jn mr jp jq jr ha bi translated">PCA是一种常用于大型数据集的降维方法。PCA将一个大的变量集转换成较小的变量集，同时保留原始信息。</p><p id="45c4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">精度和降维带来的简单性之间存在固有的权衡。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/64a581af3ffbb76cacbbd7906d391fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6aZBRGe8YtRh9R_nelnJQ.png"/></div></div></figure><h2 id="411d" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">聚类解释</strong></h2><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/6e220770dfa74e0e02a6e3a83d04feee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxgcMx-AN1WUDScFxn5zTA.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/49f1a2856914e88a289b76c685448a04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ab9pYk9rCGGzgUo6JPEgnw.png"/></div></div></figure><p id="a1b8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是每个分类的第一个要素的片段，为每个要素生成一个可视化。这将告诉您所有4个集群的平衡变量的特征。要查看每个特性的完整可视化，请在此处查看<a class="ae it" href="https://colab.research.google.com/drive/13elIO8mlMAV-_4G4WAZgq-MKr73wiX2w?usp=sharing" rel="noopener ugc nofollow" target="_blank">源代码</a></p><h2 id="8971" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">集群可视化</strong></h2><p id="dba3" class="pw-post-body-paragraph iu iv hh iw b ix lg iz ja jb lh jd je jf mp jh ji jj mq jl jm jn mr jp jq jr ha bi translated">现在，我们将最终从整个数据集可视化我们的集群。</p><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/aaefef8ece75d8c97b0b922096f2d369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zSRnwuPfZxIPLvbJj5R8Q.png"/></div></div></figure><figure class="kh ki kj kk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/ea25f2c8d2093875da49d7a1d2b506fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ct34ic3SuAm-Hvzol2oKpA.png"/></div></div></figure><p id="17aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要查看整个项目，请在这里查看<a class="ae it" href="https://colab.research.google.com/drive/13elIO8mlMAV-_4G4WAZgq-MKr73wiX2w?usp=sharing" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div></div>    
</body>
</html>