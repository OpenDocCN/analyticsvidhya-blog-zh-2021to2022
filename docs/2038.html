<html>
<head>
<title>Write your own Custom Callback for TensorFlow Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为TensorFlow Keras编写您自己的自定义回调</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/write-your-own-custom-callback-for-tensorflow-keras-f768b4264b8d?source=collection_archive---------5-----------------------#2021-04-02">https://medium.com/analytics-vidhya/write-your-own-custom-callback-for-tensorflow-keras-f768b4264b8d?source=collection_archive---------5-----------------------#2021-04-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/76cc21fb70549073b3bb6b8c6b8cefc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mfb6zJ_P_j3rw7CJ"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">查尔斯·德鲁维奥在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b180" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">什么是回调？为什么需要复试？你的模特培训有什么必要写回拨？何时以及如何使用它们？最后，如何定制回调函数？希望从这个博客来回答这一切。:')</p><h1 id="72d4" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">什么是回调函数？</h1><p id="7403" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">Mozilla 将回调函数解释为:</p><blockquote class="kv kw kx"><p id="5bbc" class="iu iv ky iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated">回调函数是作为参数传递给另一个函数的函数，然后在外部函数中调用该函数来完成某种例程或操作。</p></blockquote><p id="e326" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果函数<code class="du lc ld le lf b">A</code>作为参数传递给函数<code class="du lc ld le lf b">B</code>并且函数<code class="du lc ld le lf b">B</code>使用函数<code class="du lc ld le lf b">A</code>给自己添加某种功能，那么函数<code class="du lc ld le lf b">A</code>被称为回调函数。</p><p id="4091" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这对TensorFlow意味着什么？在TensorFlow Keras <a class="ae it" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks" rel="noopener ugc nofollow" target="_blank">文档</a>页面中，回调函数被解释为:</p><blockquote class="kv kw kx"><p id="11d6" class="iu iv ky iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated">回调:在模型训练期间的某些点调用的实用程序。</p></blockquote><p id="7a15" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，它们是您可以添加到代码中的某些功能，将在模型训练期间的某些时候被调用。这意味着你可以以任何你想要的方式操纵模型训练，这打开了许多可能性。回调最常见的用例是调整模型的超参数，或者监控一些模型指标，并在训练进行时对它们进行操作。</p><h1 id="ff02" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">为什么需要回调函数？</h1><p id="2019" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">请考虑这种情况，因为您让您的模型训练了大量的历元，所以您的模型过度适应了训练数据。训练损失持续减少，但测试/验证却相反。解决这个问题的一个好策略是监控验证损失，如果验证损失不再减少，我们可以停止训练。这意味着必须在每个时期后监控验证损失值。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/1555acab247fc41777de93dad2221c59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w-b6je7UTTtYGp26lcTPfA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">培训和验证损失—过度拟合</figcaption></figure><p id="b919" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另一种非常常见的情况是，当你设置太大的学习率时，模型不收敛，损失振荡太多。为了解决这个问题，我们可以监控验证损失，如果它波动太大，我们可以降低学习率，以便采取更小的步骤。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ll"><img src="../Images/bfea478f9794b26bb624f5adadedb15d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fmPdzcbuhLgcUuZRjvPypg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">培训和验证损失——振荡损失</figcaption></figure><p id="5768" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这种情况下，如果你想在训练的时候进行操作，使用回调函数会有所帮助。</p><h2 id="fb49" class="lm jt hh bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">TensorFlow Keras回调</h2><p id="1c30" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">TensorFlow为我们提供了一些回调，其中一个著名的回调可能是<a class="ae it" href="http://tensorflow.org/api_docs/python/tf/keras/callbacks/EarlyStopping" rel="noopener ugc nofollow" target="_blank"> EarlyStopping </a>，这在许多TensorFlow官方教程和大多数教程视频中都有提及。EarlyStopping回调的功能是通过监控一个超参数(<code class="du lc ld le lf b">val_loss</code>是最常见的一个)来停止训练。当使用<code class="du lc ld le lf b">val_loss</code>作为超参数时，在每个时期之后，将检查<code class="du lc ld le lf b">val_loss</code>是否在减少，如果在一些时期之后，它没有显示减少的趋势，将停止模型训练。</p><p id="2af1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您可以在此查看TensorFlow文档<a class="ae it" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks" rel="noopener ugc nofollow" target="_blank">中的所有其他回调。找到这篇</a><a class="ae it" href="https://blog.paperspace.com/tensorflow-callbacks/" rel="noopener ugc nofollow" target="_blank">文章</a>，它令人惊讶地解释了TensorFlow提供的所有回调。</p><h1 id="971f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">自定义回调</h1><p id="5895" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">这里最明显的问题是，如果库已经提供了这样的通用函数，为什么还要编写自己的函数呢？的确，在大多数情况下，您只需要使用TensorFlow提供的回调。但是在极少数情况下，你需要写你自己的，有两种方法可以做到这一点，这个博客会解释这两种方法。</p><h2 id="bfd9" class="lm jt hh bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">了解回调事件</h2><p id="4f8e" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在我们深入讨论如何编写自定义回调之前，我们需要了解何时可以触发我们的函数。TensorFlow提供以下事件，在这些事件上可以触发回调函数:</p><ul class=""><li id="5d62" class="ma mb hh iw b ix iy jb jc jf mc jj md jn me jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_batch_begin</code>:在批处理开始时调用。有3种变化:<code class="du lc ld le lf b">on_(train/test/predict)_batch_begin</code>，分别在每批<code class="du lc ld le lf b">.fit</code>、<code class="du lc ld le lf b">.evaluate</code>、<code class="du lc ld le lf b">.predict</code>方法开始时调用。它将<code class="du lc ld le lf b">batch</code>和<code class="du lc ld le lf b">logs</code>作为输入。</li><li id="57e5" class="ma mb hh iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_batch_end</code>:在批处理结束时调用。有3种变化:<code class="du lc ld le lf b">on_(train/test/predict)_batch_end</code>，分别在每批<code class="du lc ld le lf b">.fit</code>、<code class="du lc ld le lf b">.evaluate</code>、<code class="du lc ld le lf b">.predict</code>方法结束时调用。它以<code class="du lc ld le lf b">batch</code>和<code class="du lc ld le lf b">logs</code>为输入。</li><li id="7d8e" class="ma mb hh iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_epoch_begin</code>:在一个时期开始时调用。它将<code class="du lc ld le lf b">epoch</code>和<code class="du lc ld le lf b">logs</code>作为输入。</li><li id="2781" class="ma mb hh iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_epoch_end</code>:在一个时期结束时调用。它以<code class="du lc ld le lf b">epoch</code>和<code class="du lc ld le lf b">logs</code>为输入。</li><li id="8429" class="ma mb hh iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_(train/test/predict)_begin</code>:分别在<code class="du lc ld le lf b">.fit</code>、<code class="du lc ld le lf b">.evaluate</code>、<code class="du lc ld le lf b">.predict</code>方法开始时调用。它将<code class="du lc ld le lf b">logs</code>作为输入。</li><li id="b187" class="ma mb hh iw b ix mj jb mk jf ml jj mm jn mn jr mf mg mh mi bi translated"><code class="du lc ld le lf b">on_(train/test/predict)_end</code>:分别在<code class="du lc ld le lf b">.fit</code>、<code class="du lc ld le lf b">.evaluate</code>、<code class="du lc ld le lf b">.predict</code>方法结束时调用。它将<code class="du lc ld le lf b">logs</code>作为输入。</li></ul><p id="f2df" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">调用训练/测试/预测方法时，TensorFlow在内部提供方法的所有输入。在<a class="ae it" href="https://www.tensorflow.org/api_docs/python/tf/keras/callbacks/Callback" rel="noopener ugc nofollow" target="_blank">文档</a>中可获得更多用于这些方法的细节和参数。</p><h1 id="67ea" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">创建自定义回调</h1><h2 id="f65d" class="lm jt hh bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">使用LambdaCallback</h2><p id="4ce4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">创建定制回调的一种方法是使用LambdaCallback。TensorFlow文档将LambdaCallback解释为:</p><blockquote class="kv kw kx"><p id="32b8" class="iu iv ky iw b ix iy iz ja jb jc jd je kz jg jh ji la jk jl jm lb jo jp jq jr ha bi translated">回调创建简单的，定制的动态回调。</p></blockquote><p id="647e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lc ld le lf b">tf.keras.callbacks.LambdaCallback</code>可以将任何普通的函数转换成回调函数，可以在上述事件中调用。</p><pre class="lh li lj lk fd mo lf mp mq aw mr bi"><span id="76f3" class="lm jt hh lf b fi ms mt l mu mv">tf.keras.callbacks.LambdaCallback(<br/>    on_epoch_begin=None, on_epoch_end=None,<br/>    on_batch_begin=None, on_batch_end=None,<br/>    on_train_begin=None, on_train_end=None, **kwargs<br/>)</span></pre><p id="5d3d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">自定义函数的定义中应该有与事件方法相同的参数。我用一个例子来阐述一下。如果要记录值<code class="du lc ld le lf b">loss</code>、<code class="du lc ld le lf b">accuracy</code>、<code class="du lc ld le lf b">val_loss</code>等。对于一些调试，可以通过下面的代码使用日志模块轻松完成。</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="aa01" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将把<code class="du lc ld le lf b">epoch</code>、<code class="du lc ld le lf b">loss</code>和<code class="du lc ld le lf b">accuracy</code>写入文件<code class="du lc ld le lf b">lambdacallback.log</code>，看起来像这样。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div class="er es my"><img src="../Images/4b775e5ead9fe4df4f17d8c3d7ae4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*Bd_gF7l3Fa3cryf8SGsUGQ.png"/></div></figure><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">训练时使用<code class="du lc ld le lf b">printlogcallback(LambdaCallback) instance </code>的参考代码</figcaption></figure><h2 id="ebb9" class="lm jt hh bd ju ln lo lp jy lq lr ls kc jf lt lu kg jj lv lw kk jn lx ly ko lz bi translated">继承回调类</h2><p id="8782" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">创建回调的第一种方法有一些限制，因此创建自定义回调的另一种方法是从回调基类继承并创建一个自定义回调类。如果您需要部署代码或者需要复杂的功能，这是我推荐的方法，因为类提供了很大的灵活性。</p><p id="9c12" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du lc ld le lf b">tf.keras.callbacks.Callback</code>是一个“用于构建新回调的抽象基类”。基类必须被继承，无论我们想要触发哪个事件，都必须被覆盖。同样的<code class="du lc ld le lf b">printlogcallback</code>可以像这样创建一个类实例:</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mw mx l"/></div></figure><p id="495d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将像以前一样把<code class="du lc ld le lf b">epoch</code>、<code class="du lc ld le lf b">loss</code>和<code class="du lc ld le lf b">accuracy</code>写入文件<code class="du lc ld le lf b">lambdacallback.log</code>。与第一种方法相比，这可能看起来有些费力，但是这种方法有很大的灵活性，因为它现在是一个类。当我们将复杂的功能集成到培训管道中时，这种方法将大有裨益。</p><figure class="lh li lj lk fd ii"><div class="bz dy l di"><div class="mw mx l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">训练时使用<code class="du lc ld le lf b">printlogcallback(Callback)</code>实例的参考代码</figcaption></figure><p id="760b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用这种方法的主要优点是模型本身的操作。因为它是从<code class="du lc ld le lf b">tf.keras.callbacks.Callback</code>继承的，所以它能够使用<code class="du lc ld le lf b">model</code>变量操作模型属性。例如，如果您想要停止训练，您可以在其中一个方法中使用<code class="du lc ld le lf b">self.model.stop_training = True</code>，训练将会停止。为了降低移动中的学习率，我们可以使用<code class="du lc ld le lf b">self.model.optimizer.lr = new_lr</code>。这给了我们很大的权力和灵活性。您也可以在一个类中使用上述所有事件来创建一个复杂的回调。我在这里没有提到所有的参数，但是你想要调整的任何超参数都可以这样做。我鼓励您查看文档以了解更多信息。</p><h1 id="f804" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">结论</h1><p id="a366" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在，您已经知道如何使用第一种方法编写简单的回调，或者使用第二种方法重载基本方法来创建复杂的回调，并将其用于您的模型训练。大多数时候TensorFlow提供的回调可能是足够的和必要的，比如使用<code class="du lc ld le lf b">EarlyStopping</code>进行过度拟合。有时为了在管道中增加额外的功能，我们需要编写自定义的回调函数，现在你知道怎么做了。:')</p><p id="fc2c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果您有任何疑问，请随时通过<a class="ae it" href="mailto:arjun.06muraleedharan@gmail.com" rel="noopener ugc nofollow" target="_blank">arjun.06muraleedharan@gmail.com</a>联系我</p></div></div>    
</body>
</html>