<html>
<head>
<title>The First Chapter of Data Analysis — Part I</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据分析第一章—第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-first-chapter-of-data-analysis-part-i-2aafe332cf6b?source=collection_archive---------13-----------------------#2021-04-30">https://medium.com/analytics-vidhya/the-first-chapter-of-data-analysis-part-i-2aafe332cf6b?source=collection_archive---------13-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="62b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">任何数据科学项目的第一步都是探索性数据分析(EDA)！</p><p id="0436" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大约60年前，美国杰出的统计学家约翰·w·塔基(John w . Tuckey)(1915–2000)发表了一篇名为“<strong class="ig hi">数据分析的未来</strong>”的革命性论文，提出了一种新的科学学科，称为数据分析。在经典统计学中，统计学家大多把他们的注意力限制在推断上，因为这是一个基于有限数量的样本得出总体结论的复杂过程。约翰·塔基在统计学和计算科学如计算机科学和工程学之间建立了联系。在这本现已成为经典的书中，<em class="jd">探索性数据分析，</em>他利用简单的图表和统计摘要，给出了所研究主题的全貌。</p><blockquote class="je jf jg"><p id="f182" class="ie if jd ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated"><em class="hh">在经典统计学中，他们设计实验，然后收集数据，而在数据科学中，他们使用已经收集的数据作为知识发现的基础！</em></p></blockquote><p id="fc5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在EDA的第一部分，我们将主要关注汇总统计数据、使用的指标以及如何用python语言实现它们。我们从数据结构和类型开始，这是任何数据驱动决策的基础。</p><h1 id="547e" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数据结构</h1><p id="1be7" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">数据来自不同的资源，如物联网设备产生大量待分析的数据。数据科学的首要也是最关键的目标是利用尽可能多的原始数据，并将其转化为可操作的知识。大多数时候，原始数据是以非结构化或半结构化数据的形式收集的。为了提取知识，需要将非结构化数据转换成结构化数据。结构化数据的典型形式是矩形数据(有时称为数据框)，它由许多行组成，称为<em class="jd">记录</em>，具有多个列，称为<em class="jd">特征</em>。<strong class="ig hi">在<em class="jd"> Python </em>中，使用Pandas库，基本的矩形数据结构是DataFrame对象。</strong></p><h1 id="599a" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">数据类型</h1><p id="c5d0" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">了解了数据的结构之后，您应该知道手边的数据类型。但是为什么知道数据类型如此重要呢？在数据科学和预测建模过程中，数据类型对于采用可视化显示、数据分析和统计模型的类型至关重要。它也决定了软件如何处理变量的计算方面。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kn"><img src="../Images/b2efe897833400a3375888e0db112c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QctcPZeHOfZWVSBDFvNomw.png"/></div></div><figcaption class="kz la et er es lb lc bd b be z dx translated">数据类型</figcaption></figure><p id="e147" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据类型分为数字和分类类型。数值数据类型是可以用数值范围表示的数据。它可以是连续的，取某个区间内的任何值，也可以是离散的，只取整数值。在分类数据类型中，数据只能接受一组表示特定类别的特定值。它可以是名义类型，由不同的名称组成，也可以是顺序类型，有明确的顺序，如低、中、高。</p><h1 id="1437" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">统计摘要</h1><h2 id="d69f" class="ld jl hh bd jm le lf lg jq lh li lj ju ip lk ll jy it lm ln kc ix lo lp kg lq bi translated"><strong class="ak">地点</strong></h2><p id="02ea" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">EAD的一个基本步骤是找出给定特性的典型值。它决定了给定特征的位置、中心倾向。下面给出了估计位置的不同方法。这部分主要受《数据科学家实用统计学<a class="ae jc" href="https://www.oreilly.com/library/view/practical-statistics-for/9781491952955/" rel="noopener ugc nofollow" target="_blank">一书的启发。</a></p><ul class=""><li id="93a1" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">表示</strong>:所有值的总和除以值的个数。</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es ma"><img src="../Images/96a9ad63352d80a4cf6b822ba3d10178.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/1*yIT5OStUtBjmn_tczC5qqw.png"/></div></figure><p id="a42a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python实现是:</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="24c1" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np</span><span id="3ba7" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>np.mean(x)</span></pre><ul class=""><li id="1f6e" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi"> Trimmed Mean </strong>:在每端去掉固定数量的排序值，然后取剩余值的平均值。它用于消除极值的影响。</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es ml"><img src="../Images/c5a629e5d1e6221b444fdc3827c3678e.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*ZlOaXoM8zuhgTqf6ZbU4Wg.png"/></div></figure><p id="fcd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">10%修整平均值的python实现如下</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="9e04" class="ld jl hh mc b fi mg mh l mi mj">from scipy.stats import trim_mean</span><span id="b675" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>trim_mean(x, 0.1)</span></pre><ul class=""><li id="7056" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">加权平均值:</strong>通过将每个数据值<em class="jd"> x_i </em>乘以用户指定的权重<em class="jd"> w_i </em>并将它们的总和除以权重的总和来计算。公式是:</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mm"><img src="../Images/626209081bdd03247cda2d294eb93d81.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*6etd63ou_Vkmj_HX60fFkw.png"/></div></figure><p id="e45f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们主要在两种情况下使用加权平均值:当一些值比其他值更易变(不太可靠)时。因此，值的变化越大，权重就越低。另一种情况是，每个样本来自不同规模的群体。python3的实现如下:</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="e9e0" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np</span><span id="08ca" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>w = [10, 12, 32, 34, 32, 45, 21, 56, 21, 100]<br/>weighted_mean = np.average(x, weights=w)</span></pre><ul class=""><li id="10ee" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">中位数</strong>:先将数值按升序排序，然后取一个数值，将样本分成相等的两组。如果值的数量是偶数，则是两个中间值的平均值。<strong class="ig hi"> <em class="jd">与依赖于所有值的平均值不同，中值仅依赖于中间值，这使其对异常值具有鲁棒性。</em> </strong>离群值是指与数据集中的其他值相距甚远的任何值。python实现是:</li></ul><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="763b" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np</span><span id="0083" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>median = np.median(x)</span></pre><h2 id="ef69" class="ld jl hh bd jm le lf lg jq lh li lj ju ip lk ll jy it lm ln kc ix lo lp kg lq bi translated">变化性</h2><p id="4339" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">另一个统计汇总指标称为可变性，衡量值是紧密聚集还是分散分布。可变性的另一个名称是离差。就像位置估计量一样，我们有不同的可变性估计量。</p><ul class=""><li id="86a6" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">平均绝对偏差:</strong>通过平均每个数值相对于平均值的绝对偏差来计算。公式是:</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mn"><img src="../Images/b00d1bd787646e1037e2dbf0e71b427e.png" data-original-src="https://miro.medium.com/v2/resize:fit:538/format:webp/1*KPrMN9qhSMsvYRUkPAnzFQ.png"/></div></figure><p id="89e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python实现是</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="68f7" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np<br/>from numpy import mean, absolute</span><span id="d7a6" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>mean_abs_dev = np.mean(np.absolute(x - np.mean(x)))</span></pre><ul class=""><li id="e318" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">方差:</strong>另一个众所周知的变异性估计量是方差及其平方根knwon作为<strong class="ig hi">标准差</strong>。公式是</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mo"><img src="../Images/1af0162ccef011d4b37b01f96da9e8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*VWCcoTNaLyAGDYYopolmDg.png"/></div></figure><p id="adc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python实现是:</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="8d79" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np</span><span id="852a" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]</span><span id="d320" class="ld jl hh mc b fi mk mh l mi mj">var = np.var(x, ddof=1)<br/>sd = np.std(x, ddof=1)</span></pre><p id="ec40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">标准差比方差更便于解释，因为它是在相同的数值范围内。</p><ul class=""><li id="76f1" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">中位数绝对偏差(MAD): </strong>与位置估计量类似，方差和标准差容易受到异常值的影响。MAD是另一种基于中位数的变异性估计量，对异常值更稳健。MAD的公式是:</li></ul><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mp"><img src="../Images/26255fd22e3694e68959bf3a4e338923.png" data-original-src="https://miro.medium.com/v2/resize:fit:858/format:webp/1*aIzxq8GFZZCpOPwRKgLT-w.png"/></div></figure><p id="8bbb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">python实现如下:</p><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="ff87" class="ld jl hh mc b fi mg mh l mi mj">from statsmodels import robust</span><span id="b498" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>mad = robust.scale.mad(x)</span></pre></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="76a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jd">标准差总是大于平均绝对偏差，而平均绝对偏差本身又大于中位数绝对偏差。</em>T9】</strong></p><ul class=""><li id="7ec7" class="lr ls hh ig b ih ii il im ip lt it lu ix lv jb lw lx ly lz bi translated"><strong class="ig hi">四分位距(IQR): </strong>可变性的另一个常用度量是四分位距或简称IQR。这就是75分和25分的区别。在数据集中，第<em class="jd"> P- </em>百分位数是一个值，使得至少有<em class="jd"> P </em>个百分比的值等于或小于该值，至少有(100 — <em class="jd"> P </em>)个百分比的值等于或大于该值。python实现是:</li></ul><pre class="ko kp kq kr fd mb mc md me aw mf bi"><span id="b65f" class="ld jl hh mc b fi mg mh l mi mj">import numpy as np</span><span id="cdfb" class="ld jl hh mc b fi mk mh l mi mj">x = [1, 2, 2, 1, 23, 4, 5, 6, 2, 3]<br/>IQR = np.quantile(x, 0.75) - np.quantile(x, 0.25)</span></pre><h1 id="6369" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">总结</h1><p id="03e9" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">本文为数据科学奠定了基础。在第一部分中，我们讨论了统计摘要，并介绍了许多位置和可变性度量，以及每个度量有用的情况。在下一部分，我们将讨论EDA中最有用的分布和可视化显示。敬请关注！</p></div></div>    
</body>
</html>