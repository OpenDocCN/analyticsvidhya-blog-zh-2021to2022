<html>
<head>
<title>Tensordot — Multidimensional Dot Product — Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensordot —多维点积—解释</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/tensordot-explained-6673cfa5697f?source=collection_archive---------0-----------------------#2021-10-15">https://medium.com/analytics-vidhya/tensordot-explained-6673cfa5697f?source=collection_archive---------0-----------------------#2021-10-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/0fc930d2fbdf98bd8ed814b4e4c4f92e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0EFIlN-duiIBj_co91VwiA.jpeg"/></div></div></figure><div class=""/><h1 id="fd0a" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">从标量到多维张量</h1><p id="8684" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">tensordot是多维运算符、轴线破坏者和维度转换器，它在超级有用的多维矩阵运算符竞技场中赢得了应有的地位。对于张量(多维矩阵)来说，Tensordot是一个强大的工具，但它也可能有点难以捉摸，似乎有点不可思议。为张量获得一个强有力的直觉是很困难的，这主要是因为如果你需要一个张量运算，你的大脑很可能已经对记录一个张量的所有维度感到迷惑了。为了完全掌握tensordots，从简单的矩阵开始，然后慢慢地建立一种直觉，一直到多维操作，这是有帮助的。</p><p id="cd9a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">以下是掌握tensordot的几个理由:</p><ol class=""><li id="b28c" class="kr ks ht jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">Tensordot是一个非常有用的张量运算工具，适用于优化、工程、机器学习…或者任何你需要执行多维运算的地方。</li><li id="ab02" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">对于多维点积，您可以使用tensordot而不是嵌套循环来加速代码。</li><li id="b18b" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">它将帮助你建立一个多维操作的直觉，并给你张量的经验。</li><li id="aea6" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">一旦你完全理解tensordot，它往往会坚持。如果你已经有了一些矩阵的经验，这个操作在理论上并不严格，它更多的是你已经知道的视觉/感知的扩展。</li><li id="e99f" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">我们将特别关注numpy tensor dot，然而直觉也适用于许多使用tensor的库(tensorflow，pytorch…)。</li></ol><p id="3ce3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在我们深入研究张量之前，让我们回顾一些基本知识，然后从那里开始更复杂的张量运算。虽然张量背后有一些数学理论，但对我们来说，张量只是二维以上的矩阵。事实上，我们把所有矩阵都称为张量，甚至2D矩阵也是如此。以下是我们将涉及内容的快速总结:</p><ol class=""><li id="03c1" class="kr ks ht jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated"><strong class="jq hu">轴和轴名称</strong></li><li id="d12d" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hu"> 2D点积</strong></li><li id="2657" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hu">带向量的Tensordot】</strong></li><li id="ae3c" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated"><strong class="jq hu">2D张量的张量点</strong></li></ol><p id="0dd8" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">(一)。参数轴= 0的Tensordot</p><p id="05e5" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">㈡。参数轴= 1的Tensordot</p><p id="cc3b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">㈢。参数轴=2的Tensordot</p><p id="6ea7" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu"> 5。多维十进制和元组表示法</strong></p><p id="03c0" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu"> 6。外卖</strong></p><p id="1864" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">7.<strong class="jq hu">参考文献</strong></p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="20ea" class="iq ir ht bd is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn bi translated"><strong class="ak">轴和轴名称</strong></h1><p id="dd07" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">2D矩阵有两个轴，惯例是先沿行再沿列给每个轴编号，如下所示。这可能会引起混淆，因为轴0的每个实例都是一列，而轴1的每个实例都是一行。我之所以使用“沿着”轴0或1这个词，是为了说明我们沿着特定的轴行进，以提取该轴的实例或记录。在元组形式中，我们可以说这个矩阵是(2，3)。元组中的第一个数字表示轴0的大小，第二个数字表示轴1的大小。换句话说，axis 0的单个实例是一行，在我们的矩阵中有两行。axis 1的单个实例是一列，在我们的矩阵中有三列。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es lr"><img src="../Images/bfbfbda3390655e5cf621f9880a415ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*r1x9jlHIqkXW7pzz0BPUyg.png"/></div></figure><p id="d4cc" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">同样的原理适用于2维以上，所以我们可以扩展我们的符号和可视化表示，如下所示。现在我们的矩阵是(2，3，深度，…N)。和以前一样，沿轴0的长度是2，沿轴1的长度是3，沿轴2的长度是深度…我停止指定实际长度，以将理解抽象到轴n的任何维度。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es lw"><img src="../Images/17230869ceab9d731790dd6a1f5806c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*T3Brxoh34F5L9fUxze0K5g.png"/></div></figure></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="38dc" class="iq ir ht bd is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn bi translated"><strong class="ak"> 2D点积</strong></h1><p id="4d9b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在让我们回顾一个简单的二维矩阵的点积。正如您在下面看到的，我们从X中取出每一行(沿轴1的每个实例)和从Y中取出每一列(沿轴0的每个实例)，将行和列元素相乘，然后将输出相加。输出矩阵中的每个元素都由来自X的行和来自y的列的所有可能组合组成。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es lx"><img src="../Images/ac7500299620171c67768d495bbe5850.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97ZPTZEDXlR0J9WdDpQgJw.png"/></div></div></figure><p id="b20b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是np.tensordot的一个秘密峰值。注意轴符号，这是理解多维tensordot操作的关键部分。axes参数中的第一个嵌套元组指的是x轴，而第二个嵌套元组指的是y轴。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="720e" class="md ir ht lz b fi me mf l mg mh">x<br/>array([[1, 2, 3],<br/>       [2, 3, 4]])<br/>y<br/>array([[4, 5],<br/>       [5, 6],<br/>       [6, 7]])</span><span id="b3ba" class="md ir ht lz b fi mi mf l mg mh">np.dot(x,y)</span><span id="25e8" class="md ir ht lz b fi mi mf l mg mh">same as</span><span id="3135" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((1),(0)))</span><span id="2e8b" class="md ir ht lz b fi mi mf l mg mh">Out:<br/>array([[32, 38],<br/>       [47, 56]])</span></pre><p id="1c58" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在2D，一个简单的np.dot(x，y)点积自动为我们指定了轴，对于多维运算，我们需要指定乘法/求和发生在哪个轴上。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="6d88" class="iq ir ht bd is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn bi translated"><strong class="ak">带向量的Tensordot】</strong></h1><p id="8f79" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">让我们从矩阵点积后退几步，从零开始，用向量来画tensordot。带向量的Tensordot有助于建立强大的直觉。它遵循与矩阵点积相同的模式，唯一的区别是我们将沿着我们指定的轴来看点积。</p><p id="113f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">首先，让我们创建两个向量。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="1b5b" class="md ir ht lz b fi me mf l mg mh">x = np.array([1,2,3])<br/>y = np.array([4,5,6])</span></pre><p id="7d55" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">根据numpy文档，轴参数接受以下输入:</p><p id="de6f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><a class="ae mj" href="https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jq hu"> np.tensordot(x，y，坐标轴)</strong> </a></p><p id="3af6" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu">坐标轴</strong> <em class="mk"> int或(2，)array_like </em></p><ul class=""><li id="e5bc" class="kr ks ht jq b jr km jv kn jz kt kd ku kh kv kl ml kx ky kz bi translated">integer_like如果一个int N，依次对<em class="mk"> a </em>的最后N个轴和<em class="mk"> b </em>的前N个轴求和。相应轴的大小必须匹配。当<em class="mk">轴</em>为integer_like时，求值顺序为:首先是<em class="mk"> a </em>中的第-n轴和<em class="mk"> b </em>中的第0轴，最后是<em class="mk"> a </em>中的第-1轴和<em class="mk"> b </em>中的第n轴</li><li id="f036" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl ml kx ky kz bi translated">(2)array _ like或要求和的轴列表，第一个序列应用于<em class="mk"> a </em>，第二个序列应用于<em class="mk"> b </em>。两个元素array_like的长度必须相同</li></ul><p id="8a2b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">就我个人而言，我并不觉得这个解释很有帮助，尽管它是一个很好的起点。为了充分研究axes参数的输入，我们将练习两种类型的输入:整数和嵌套元组。两者是相关的，整数输入是点积的更常见情况的简化，这也可以通过指定轴来执行，沿着该轴与嵌套元组相乘/求和。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es mm"><img src="../Images/17cf9db34d260a241f39c6a24a253b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*NVUQmpAsCOCju9XGKeFjcA.png"/></div></figure><p id="c18b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于axes = 0的tensordot，取x的最后一个零轴，x的每个实例，然后用y乘以/求和。这里的措辞看起来很笨拙，因为不清楚x的最后一个零轴是什么，但随着我们的深入，它会变得更加清楚。我试图使用与numpy文档相同的措辞来建立理解。x的最后一个零轴只是x的标量元素。</p><p id="caf3" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">维数变化如下(3)*(3) =&gt; 3x3因为x和y总共有9个唯一的组合，x的每个实例都是一个标量，我们最后只将x[i]乘以y。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="f75c" class="md ir ht lz b fi me mf l mg mh">np.tensordot(x,y, axes = 0)<br/>array([[ 4,  5,  6],<br/>       [ 8, 10, 12],<br/>       [12, 15, 18]])</span></pre><p id="7c6b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下图显示了两个长度为3的向量如何转换成一个3x3的矩阵。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mn"><img src="../Images/a6371f7f0b8ca615da1d2fb4114a5bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhZ875IGcU63GuHZZbzIWg.png"/></div></div></figure><p id="d456" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">当axes参数为1时，x轴的点积沿0轴的完整实例，y轴的点积为0，然后执行点积(乘加)。奇怪的措辞如下，取x的最后一个轴，用y的最后一个轴做点积。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="5ce8" class="md ir ht lz b fi me mf l mg mh">x = np.array([1,2,3])<br/>y = np.array([4,5,6])<br/></span><span id="403f" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 1)<br/>array(32)</span><span id="a489" class="md ir ht lz b fi mi mf l mg mh">we can also use the tuple notation </span><span id="1f33" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = (0,0))<br/>Out[77]: array(32)</span></pre><p id="bb8c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下图显示了两个向量之间简单的点-prod。这种符号在学校里很常见，因为你可以用权重和变量(x+2y+3z)来表示一个方程。该符号可以结合到2D和代表一个方程组。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mo"><img src="../Images/92f544c649c6b66067fa9c798496d556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pnsDcjapYVQWLJtWe_-Dhw.png"/></div></div></figure><p id="6893" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于向量，当axes参数= 2时，我们不能进一步探索np.tensordot(x，y，axes = 2)做什么，因为向量是一维的。如果我们试图将轴添加到轴的元组符号中，我们将得到IndexError或ValueError。现在让我们到二维张量，继续探索张量。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="5817" class="md ir ht lz b fi me mf l mg mh">np.tensordot(x,y)<br/>IndexError: tuple index out of range</span><span id="690a" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = (0,1))<br/>IndexError: tuple index out of range</span><span id="187b" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = (0,1))<br/>ValueError: shape-mismatch for sum  (in this case we are trying to dot prod (1,3)(1,3) and the size of inner values don't match. )</span></pre></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><h1 id="f3c4" class="iq ir ht bd is it lm iv iw ix ln iz ja jb lo jd je jf lp jh ji jj lq jl jm jn bi translated"><strong class="ak">2D张量的张量点</strong></h1><p id="bcf0" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">记住，就我们而言，张量只是一个二维以上的矩阵。我将继续把例子中的矩阵称为张量。</p><p id="3430" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">让我们修改numpy关于轴参数和输入类型INT (N)的文档。这就是奇怪的措辞的来源。</p><blockquote class="mp mq mr"><p id="36f0" class="jo jp mk jq b jr km jt ju jv kn jx jy ms ko kb kc mt kp kf kg mu kq kj kk kl hb bi translated">按顺序对a的最后N个轴和b的前N个轴求和。<br/>当<em class="ht">轴</em>为integer_like时，求值顺序为:首先是<em class="ht"> a </em>中的第-n轴和<em class="ht"> b </em>中的第0轴，最后是<em class="ht"> a </em>中的第-1轴和<em class="ht"> b </em>中的第n轴</p></blockquote><p id="0fd2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们用一个元组来表示张量的形状，下图解释了numpy的定义，并且可以扩展到N个轴。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mv"><img src="../Images/292cea5b2535912dc51914805350da8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEwTg55Gdn_omp3eSUALJw.png"/></div></div></figure><h2 id="943d" class="md ir ht bd is mw mx my iw mz na nb ja jz nc nd je kd ne nf ji kh ng nh jm ni bi translated">参数轴= 0的Tensordot</h2><p id="15f4" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当N = 0时，我们不在轴上操作，而是在x的每个标量值上操作。操作可以用以下方式表述:对x的每个实例和y的每个实例执行点积。</p><p id="0025" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是我解释axes = 0的numpy定义的方法。取x的最后一个0轴，如果x的最后一个轴是矢量，那么取最后一个0轴就是取比矢量更低/更简单的东西，是标量。y的第一个0轴，是越过一个矩阵向量。</p><p id="da16" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这种情况下x的单个实例是x的每个标量值，y的单个实例是整个y矩阵。为了解开“洋葱”,我们将在x上移动0轴，然后是1轴，或者一个嵌套循环，并将x(i，j)的每个实例乘以y，然后对结果求和。因为在我们的例子中x(i，j)是一个标量，所以不需要求和。对于轴=0，不进行轴缩减，但输出矩阵会发生变换。最终的形状是x轴和y轴的组合。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="539b" class="md ir ht lz b fi me mf l mg mh">(2,3) tensordot (2,3) =&gt; (2,3,2,3)</span><span id="1418" class="md ir ht lz b fi mi mf l mg mh">x<br/>array([[1, 2, 3],<br/>       [2, 3, 4]])<br/>y<br/>array([[4, 5, 6],<br/>       [5, 6, 7]])</span><span id="e9bf" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 0)<br/>Out: <br/>array([[[[ 4,  5,  6],<br/>         [ 5,  6,  7]],<br/>        [[ 8, 10, 12],<br/>         [10, 12, 14]],<br/>        [[12, 15, 18],<br/>         [15, 18, 21]]],<br/>       [[[ 8, 10, 12],<br/>         [10, 12, 14]],<br/>        [[12, 15, 18],<br/>         [15, 18, 21]],<br/>        [[16, 20, 24],<br/>         [20, 24, 28]]]])</span></pre><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es nj"><img src="../Images/4c6c79e568ee22488af0992759ad0f50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*aQMo5AKweWCPRY_Sh8-yjg.png"/></div></figure><h2 id="f61a" class="md ir ht bd is mw mx my iw mz na nb ja jz nc nd je kd ne nf ji kh ng nh jm ni bi translated">参数轴= 1的Tensordot</h2><p id="930b" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当N = 1时，我们将沿最后一个轴取x (2，3)的每个实例，这样将得到两个长度为3的向量，并沿第一个轴对y (2，3)的每个实例执行点积…</p><p id="03c4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">等等，这不行，因为对于x，我们有2个长度为3的向量，对于y，我们有3个长度为2的向量。如果我们在x和y上尝试dotproduct，我们将得到一个ValueError，如下面的代码所示。</p><p id="3124" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们可以转置y以获得(3，2)的形状，转置x以获得(3，2)的形状，或者使用tensordot元组表示法来指定哪个轴用于点积。这就是元组符号的强大之处，你可以简单地指定沿着哪个轴执行点积，而不是改变张量的形状。遵循下面的python代码，并尝试自己使用代码。让我们先看看x和y沿1的原始轴的tensordot，以得到2x2的最终张量形状。我说原始轴，因为我们需要转换y轴，这样y轴1就不同了。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="58f9" class="md ir ht lz b fi me mf l mg mh">(2,3) tensordot (3,2) =&gt; (2,2)</span><span id="e74a" class="md ir ht lz b fi mi mf l mg mh">x = np.array([[1, 2, 3],<br/>              [2, 3, 4]])</span><span id="24b8" class="md ir ht lz b fi mi mf l mg mh">y = np.array([[4, 5, 6],<br/>              [5, 6, 7]])</span><span id="c576" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 1) <br/>ValueError: shape-mismatch for sum</span><span id="a215" class="md ir ht lz b fi mi mf l mg mh">y.transpose()<br/>array([[4, 5],<br/>       [5, 6],<br/>       [6, 7]])</span><span id="92bc" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y.transpose(), axes = 1)</span><span id="7848" class="md ir ht lz b fi mi mf l mg mh">or simply use tuple notation without transpose </span><span id="d23d" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((1),(1)))</span><span id="c80f" class="md ir ht lz b fi mi mf l mg mh">which can also be used when y is transposed</span><span id="be94" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y.transpose(), axes = ((1),(0)))</span><span id="5fb3" class="md ir ht lz b fi mi mf l mg mh">Out: <br/>array([[32, 38],<br/>       [47, 56]])</span></pre><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nk"><img src="../Images/4e93894754bd709e43c46b6db0df53f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zdn0X1xyxWRB1sS1PB91Fg.png"/></div></div></figure><p id="3a0d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我们还可以对x和y执行沿原始轴0的tensordot，(轴参数仍然是1)，这将返回一个3x3张量。当我们转置x时，我们翻转轴的名称，所以轴0变成1，轴1变成0。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="cadb" class="md ir ht lz b fi me mf l mg mh">(3,2) tensordot (2,3) =&gt; (3,3)</span><span id="89c9" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x.transpose(),y, axes = 1)</span><span id="b2e5" class="md ir ht lz b fi mi mf l mg mh">or simply use the tuple notation to specify axes</span><span id="26df" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((0),(0)))</span><span id="5bf8" class="md ir ht lz b fi mi mf l mg mh">Out: <br/>array([[14, 17, 20],<br/>       [23, 28, 33],<br/>       [32, 39, 46]])</span></pre><h2 id="5ca6" class="md ir ht bd is mw mx my iw mz na nb ja jz nc nd je kd ne nf ji kh ng nh jm ni bi translated">参数轴= 2的Tensordot</h2><p id="6f9a" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">当轴参数为2时，我们采用x的最后两个轴，y的前两个轴。为了遵循之前使用的相同措辞，我们对x的每个实例和y的每个实例执行点积。对于2D张量，我们最终采用x的整个张量和y的整个张量，逐元素相乘，并将所有结果元素相加以返回标量。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="4a01" class="md ir ht lz b fi me mf l mg mh">(2,3) tensordot (2,3) =&gt; scalar</span><span id="bc4d" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 2)</span><span id="a596" class="md ir ht lz b fi mi mf l mg mh">same as</span><span id="f610" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((1,0),(1,0)))</span><span id="1fb9" class="md ir ht lz b fi mi mf l mg mh">same as</span><span id="7602" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y.transpose(), axes = ((1,0),(0,1)))</span><span id="bb10" class="md ir ht lz b fi mi mf l mg mh">same as</span><span id="eab5" class="md ir ht lz b fi mi mf l mg mh">np.dot(x.ravel(), y.ravel())</span><span id="51ab" class="md ir ht lz b fi mi mf l mg mh">Out: <br/>array(88)</span></pre><p id="7444" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">x的实例由axes参数指定。你可以把它理解为“x的每一个单位将与y的每一个单位一起分享点积”。对于上述所有示例，当axes =0时，每个实例都是一个标量。对于axes =1或((1)，(1))，每个实例都是一个向量。对于axes = 2或((1，0)，(1，0))，每个实例都是完整的2D特斯诺。不管每个实例的维数是多少，它都被简化为一个标量。因此，对轴指定的另一种理解是“沿着哪些轴执行归约(乘法/加法)”。对于axes = 2的情况，我们可以通过将张量展平为向量并执行点积来说明将两个矩阵简化为标量。</p><p id="205d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这就是我说的展平张量的意思。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="260a" class="md ir ht lz b fi me mf l mg mh">Tensor X<br/>X = np.array([[1, 2, 3],<br/>              [2, 3, 4]])</span><span id="5f3b" class="md ir ht lz b fi mi mf l mg mh">Vector (flatten) x</span><span id="577e" class="md ir ht lz b fi mi mf l mg mh">x = np.array([1, 2, 3, 2, 3, 4])</span><span id="330c" class="md ir ht lz b fi mi mf l mg mh">Matrix y </span><span id="c9a6" class="md ir ht lz b fi mi mf l mg mh">Y = np.array([[4, 5, 6],<br/>              [5, 6, 7]])</span><span id="521b" class="md ir ht lz b fi mi mf l mg mh">Vector (flatten) y</span><span id="a5e7" class="md ir ht lz b fi mi mf l mg mh">y = np.array([4, 5, 6, 5, 6, 7])<br/></span><span id="72b6" class="md ir ht lz b fi mi mf l mg mh">np.dot(x,y)</span><span id="24ba" class="md ir ht lz b fi mi mf l mg mh">or </span><span id="d940" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 1) <br/># axis = 1 since we flattened the 2D tensor to 1D</span><span id="e088" class="md ir ht lz b fi mi mf l mg mh">Out: <br/>array(88)</span></pre><p id="4fd0" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是2D张量的axes = 2的视觉效果。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es nl"><img src="../Images/b3b053f1a09e58b0c54f96a7edb4f6f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*IYSJK-3_Z1vYzYNzkDwjqg.png"/></div></figure></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="b8c5" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于一个3D张量，如果我们设置axes参数= 3，那么我们将遵循与上面类似的过程，将x和y元素相乘，然后将所有值相加，得到一个标量结果。当轴= N时，此模式适用于N维。</p><h1 id="7145" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated"><strong class="ak">多维十进制数和元组符号</strong></h1><p id="cf16" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">使用点积，您可以将一个实例中的所有维度展平(或分解)到一个向量中，并使用另一个向量执行点积。这是我自己的术语，仅用于说明目的。</p><p id="477e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">从某种意义上来说，每个实例都是经过整形张量的向量。例如，当x的形状为(2，4)，y的形状为(4，2)，并且axes = ((1)，(0))时，用x行(而不是列)填充向量a_i，用y列(而不是行)填充向量b_j。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="4a12" class="md ir ht lz b fi me mf l mg mh">a_0 = x[0,:] <br/>a_1 = x[1,:]</span><span id="eb94" class="md ir ht lz b fi mi mf l mg mh">b_0 = y[:,0]<br/>b_1 = y[:,1]<br/>  <br/>out_(0,0) = np.dot(a_0,b_0)<br/>out_(0,1) = np.dot(a_0,b_1)<br/>...<br/>out_(1,1) = np.dot(a_1,b_1)</span></pre><p id="b4d4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">另一个将张量分解成实例的例子，当x的形状为(2，4)，y的形状为(4，2)，轴= ((1，0)，(0，1))</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="bfd6" class="md ir ht lz b fi me mf l mg mh">a = x[:,1], x[:,0] = [x1, ...x8]<br/>b = y[1,:], y[0,:] = [y1, ...y8]</span><span id="98a1" class="md ir ht lz b fi mi mf l mg mh">out = np.dot(a,b)</span></pre><p id="fdec" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">到目前为止，我的希望是上面的例子已经建立了一些关于元组符号的直觉，以及每个轴指定如何形成结果张量。</p><p id="4e68" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">仔细看这个例子，试着理解它。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="d617" class="md ir ht lz b fi me mf l mg mh">x shape =&gt; (2,3,5)<br/>y shape =&gt; (2,3,5)</span><span id="715b" class="md ir ht lz b fi mi mf l mg mh">x = array([[[1, 2, 3, 4, 5],<br/>            [1, 2, 3, 4, 5],<br/>            [3, 4, 5, 6, 7]],<br/>            [[4, 5, 6, 7, 8],<br/>            [5, 6, 7, 8, 9],<br/>            [6, 7, 8, 9, 1]]])</span><span id="f70d" class="md ir ht lz b fi mi mf l mg mh">y = array([[[2, 3, 4, 5, 6],<br/>            [2, 3, 4, 5, 6],<br/>            [3, 4, 5, 6, 8]],<br/>           [[4, 5, 6, 7, 9],<br/>            [5, 6, 7, 8, 1],<br/>            [6, 7, 8, 9, 2]]])</span><span id="d023" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = 3)</span><span id="72a6" class="md ir ht lz b fi mi mf l mg mh">same as </span><span id="2b8c" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((2,1,0),(2,1,0)))</span><span id="1a6f" class="md ir ht lz b fi mi mf l mg mh">Out[49]: array(895)</span></pre><p id="0859" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">以下是其他几个例子。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="d88f" class="md ir ht lz b fi me mf l mg mh">np.tensordot(x,y, axes = ((0),(0))).shape<br/>Out[53]: (3, 5, 3, 5)</span><span id="a2be" class="md ir ht lz b fi mi mf l mg mh">x(2,3,5) y(2,3,5) =&gt;(3, 5, 3, 5)<br/>reduce on axis 0 for x, and axis 0 for y<br/><br/>np.tensordot(x,y, axes = ((1),(1))).shape<br/>Out[55]: (2, 5, 2, 5)</span><span id="d92f" class="md ir ht lz b fi mi mf l mg mh">x(2,3,5) y(2,3,5) =&gt;(2, 5, 2, 5)<br/>reduce on axis 1 for x, and axis 1 for y</span><span id="53a5" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((1,0),(1,0))).shape<br/>Out[56]: (5, 5)</span><span id="1c8f" class="md ir ht lz b fi mi mf l mg mh">x(2,3,5) y(2,3,5) =&gt;(5, 5)<br/>reduce on axis 1 and 0 for x, and axis 1 and 0 for y</span></pre><p id="af5d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">回顾下面的笔记(用我的鼠标:D书写的星形笔迹)来更好地观察在操作过程中张量轴是如何在输出张量中减少的。</p><figure class="ls lt lu lv fd hk er es paragraph-image"><div class="er es nm"><img src="../Images/ad693e46feee71eedaa91b9490470af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*xeJX43ooh0Geedz3D5CAsg.png"/></div></figure><p id="ffde" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">axes参数并不要求每个轴都是有序的，就像上面axes = ((2，1，0)，(2，1，0))的例子一样。给定一个形状的张量x(a，b，c)和形状的张量y(d，e，f)，只要轴长匹配，就可以按任意轴的顺序执行张量点，或者可以广播轴。例如，当我们执行轴= 0的点积时，标量值被传播到每个向量或张量。一个形状匹配的例子，如果我们要做一个长度为2的第一个向量的张量点，第二个向量也必须是长度为2的。这是它看起来的样子。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="db83" class="md ir ht lz b fi me mf l mg mh">x.shape = (a,c,b)</span><span id="1873" class="md ir ht lz b fi mi mf l mg mh">y.shape = (f,d,e)</span><span id="bc66" class="md ir ht lz b fi mi mf l mg mh">np.tensordot(x,y, axes = ((a,b,c)),(d,e,f)))</span><span id="5021" class="md ir ht lz b fi mi mf l mg mh">len(a) = len(d)<br/>len(b) = len(e)<br/>len(c) = len(f)</span></pre><p id="14ce" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我在下面附上了一些笔记和一些额外的例子。reduce阶段显示了两个张量/矩阵形状，这两个形状按元素相乘，然后求和以减少为单个标量。对于形状为(2，3，6)的x和形状为(2，6，3)的y，如果我们沿着轴((2，0)，(1，0))应用张量积，那么我们对形状为x(6，2)和y(6，2)的许多张量(准确地说是9个)执行点积。结果是我们有一个3×3张量，其中(I，j)上的每个值是x(i，6，2)和y(j，6，2)上的单个张量点。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="1988" class="md ir ht lz b fi me mf l mg mh">np.tensordot(np.random.rand(2,3,6),<br/>             np.random.rand(2,6,3), <br/>             axes = ((2,0),(1,0))).shape<br/>Out: (3, 3)</span></pre><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nn"><img src="../Images/82998127f9f66079e73d0d9768c2aae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OZ5UdFL4pHQqYUBZPIKntQ.png"/></div></div></figure><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="f79d" class="md ir ht lz b fi me mf l mg mh">np.tensordot(np.random.rand(2,3,6),<br/>             np.random.rand(2,6,3), <br/>             axes = ((1,0),(2,0))).shape<br/>Out: (6, 6)</span></pre><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es no"><img src="../Images/6a45238b5d0313d8c901aa09d16c948f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GP4EU8IrmGJ9RfghSaX0Uw.png"/></div></div></figure><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="083f" class="md ir ht lz b fi me mf l mg mh">np.tensordot(np.random.rand(2,4,4,2,3,4),<br/>             np.random.rand(3,2,4), <br/>             axes = ((4,3),(0,1))).shape<br/>Out: (2, 4, 4, 4, 4)</span></pre><figure class="ls lt lu lv fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es np"><img src="../Images/fda805535cecffb375d268724379e9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f817NfI6azdLqbESHV0dFg.png"/></div></div></figure><h1 id="b241" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">外卖食品</h1><p id="531d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Tensordot沿axes参数定义的轴执行点积(元素式乘法，然后是加法)。</p><p id="a58a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Axes参数可以接受整数输入来捕获一些更常见的tensordot情况，也可以接受元组输入来定义在哪个轴上执行点积:</p><p id="df31" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu">轴= 0 </strong>:</p><p id="2cfe" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">来自x的每个标量乘以满y张量。没有轴缩减，输出张量形状是x形状和y形状的组合。</p><p id="8aba" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu"> axes = 1 </strong>:</p><p id="b95a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这是一个常见的点积，经常在学校和早期矩阵代数中使用。通过矢量点积减少输出(“矢量减少”)。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="a1d0" class="md ir ht lz b fi me mf l mg mh">np.tensordot(x,y.transpose(), axes = 1)<br/>np.tensordot(x,y, axes = ((1),(1)))<br/>np.tensordot(x,y.transpose(), axes = ((1),(0)))</span></pre><p id="172a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu"> axes = 2 </strong>:</p><p id="2c6d" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">x轴的最后两个轴与y轴的前两个轴的逐元素乘法/完全加法。输出通过矩阵点积减少(“矩阵减少”)。</p><p id="d58b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">对于2D张量，输出将是一个标量。你可以扩展到N维，对于N维张量，如果axes =N，输出将是一个标量。</p><p id="9e3c" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">以下所有这些操作都是等效的。</p><pre class="ls lt lu lv fd ly lz ma mb aw mc bi"><span id="b3ef" class="md ir ht lz b fi me mf l mg mh">np.tensordot(x,y, axes = 2)<br/>np.tensordot(x,y, axes = ((1,0),(1,0)))<br/>np.tensordot(x,y.transpose(), axes = ((1,0),(0,1)))<br/>np.dot(x.ravel(), y.ravel())</span></pre><p id="cd7a" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated"><strong class="jq hu">坐标轴=元组</strong>:</p><p id="af57" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一种想象的方法是按照元组表示的轴顺序分解x和y，然后执行矢量点积。该操作通过元组中定义的轴来缩小输出形状，这些轴被缩小为标量值。</p></div><div class="ab cl lf lg gp lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="hb hc hd he hf"><p id="8e83" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">我希望你觉得这很有价值，请随时留下反馈并提出任何更新，因为我是根据自己的学习匆忙整理的。</p><h1 id="3a5f" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">参考</h1><div class="hh hi ez fb hj nq"><a href="https://numpy.org/doc/stable/reference/generated/numpy.tensordot.html" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hu fi z dy nv ea eb nw ed ef hs bi translated">NumPy . tensordot-NumPy 1.21版手册</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">计算沿指定轴的张量点积。给定两个张量a和b，以及一个类似array _的对象包含两个…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">numpy.org</p></div></div></div></a></div><div class="hh hi ez fb hj nq"><a href="https://pytorch.org/docs/stable/generated/torch.tensordot.html" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hu fi z dy nv ea eb nw ed ef hs bi translated">torch.tensordot - PyTorch 1.9.1文档</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">加入PyTorch开发人员社区，贡献、学习并获得您的问题的答案。</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">pytorch.org</p></div></div></div></a></div><div class="hh hi ez fb hj nq"><a href="https://mathsisfun.com/algebra/matrix-multiplying.html" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hu fi z dy nv ea eb nw ed ef hs bi translated">如何乘矩阵</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">一个矩阵是一个数字的数组:一个矩阵(这个有2行3列)乘以一个单一的数字…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">mathsisfun.com</p></div></div></div></a></div><div class="hh hi ez fb hj nq"><a href="https://stackoverflow.com/questions/44763910/multiply-2d-numpy-arrays-element-wise-and-sum" rel="noopener  ugc nofollow" target="_blank"><div class="nr ab dw"><div class="ns ab nt cl cj nu"><h2 class="bd hu fi z dy nv ea eb nw ed ef hs bi translated">将2D数个数组按元素相乘并求和</h2><div class="nx l"><h3 class="bd b fi z dy nv ea eb nw ed ef dx translated">我想知道是否有更快的方法/专用的NumPy函数来执行2D NumPy的元素级乘法…</h3></div><div class="ny l"><p class="bd b fp z dy nv ea eb nw ed ef dx translated">stackoverflow.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe hp nq"/></div></div></a></div></div></div>    
</body>
</html>