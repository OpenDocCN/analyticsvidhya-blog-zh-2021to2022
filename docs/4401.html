<html>
<head>
<title>Pretraining BERT from scratch on openwebtext data on a single GPU using Docker.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker在单个GPU上对openwebtext数据从头开始预训练BERT。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pretraining-bert-from-scratch-on-openwebtext-data-on-a-single-gpu-using-docker-8d8e2f05e8d6?source=collection_archive---------6-----------------------#2021-10-05">https://medium.com/analytics-vidhya/pretraining-bert-from-scratch-on-openwebtext-data-on-a-single-gpu-using-docker-8d8e2f05e8d6?source=collection_archive---------6-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ef61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">嘿大家好！欢迎来到我的博客。这篇博客详细介绍了如何构建docker镜像来训练ELECTRA。我可以听到你问我为什么需要建立一个码头工人的形象？好了，开始了。运行ELECTRA所需的版本是tensorflow 1.15.5(较旧版本),它需要CUDA版本10。如果您有不同版本的CUDA，如安装在您机器上的CUDA 11，并且您想从头开始预训练ELECTRA，dockerization是运行tensorflow 1.15.5旧版本的最佳方式。</p><p id="6a71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> Git克隆ELECTRA </strong></p><p id="834d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们首先使用命令<code class="du jd je jf jg b">git clone <a class="ae jh" href="https://github.com/google-research/electra.git" rel="noopener ugc nofollow" target="_blank">https://github.com/google-research/electra.git</a></code>将伊莱克特代码克隆到我们的本地机器上，然后使用命令<code class="du jd je jf jg b">cd electra</code>进入那个目录。为了从头开始预训练ELECTRA，我们将使用openwebtext语料库，如<a class="ae jh" href="https://github.com/google-research/electra#quickstart-pre-train-a-small-electra-model" rel="noopener ugc nofollow" target="_blank">快速入门:预训练小型ELECTRA </a>模型中所述。</p><p id="58c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建数据文件夹并下载vocab.txt </strong></p><p id="a142" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们在<code class="du jd je jf jg b">electra</code>文件夹中使用命令<code class="du jd je jf jg b">mkdir data</code>创建一个名为‘数据’的文件夹。使用<code class="du jd je jf jg b">wget https://storage.googleapis.com/electra-data/vocab.txt</code>命令从<a class="ae jh" href="https://storage.googleapis.com/electra-data/vocab.txt" rel="noopener ugc nofollow" target="_blank">https://storage.googleapis.com/electra-data/vocab.txt</a>下载vocab.txt。</p><p id="13a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用gdown下载数据集</strong></p><p id="803a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来让我们下载<a class="ae jh" href="https://drive.google.com/drive/folders/1IaD_SIIB-K3Sij_-JjWoPy_UrWqQRdjx?usp=sharing" rel="noopener ugc nofollow" target="_blank"> openwebtext </a>数据集。可以在docker容器中下载数据集，但是为了简单起见，让我们先将它下载到本地机器上。我们将使用命令<code class="du jd je jf jg b">pip install gdown</code>,</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="31e5" class="jq jr hi jg b fi js jt l ju jv">gdown <a class="ae jh" href="https://drive.google.com/uc?id=1EA5V0oetDCOke7afsktL_JDQ-ETtNOvx" rel="noopener ugc nofollow" target="_blank">https://drive.google.com/uc?id=1EA5V0oetDCOke7afsktL_JDQ-ETtNOvx</a></span></pre><p id="05c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这会将<code class="du jd je jf jg b">openwebtext.tar.xz</code>下载到<code class="du jd je jf jg b">data/</code>文件夹中。</p><p id="7b33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">使用Docker文件构建Docker映像</strong></p><p id="8310" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个博客不包括docker的安装。请参考这里的文档<a class="ae jh" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">在ubuntu中安装</a>。一旦docker安装到您的系统中，我们需要创建<code class="du jd je jf jg b">Dockerfile</code>。在electra文件夹中使用<code class="du jd je jf jg b">nano Dockerfile </code>创建一个文件。在<code class="du jd je jf jg b">Dockerfile</code>中键入以下命令并保存<code class="du jd je jf jg b">Dockerfile</code></p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="af31" class="jq jr hi jg b fi js jt l ju jv">FROM tensorflow/tensorflow:1.15.5-gpu-py3</span><span id="82c3" class="jq jr hi jg b fi jw jt l ju jv">RUN /usr/bin/python3 -m pip install -U pip</span><span id="1e8b" class="jq jr hi jg b fi jw jt l ju jv">ADD requirements.txt /tmp/</span><span id="e486" class="jq jr hi jg b fi jw jt l ju jv">RUN /usr/bin/python3 -m pip install -r /tmp/requirements.txt</span><span id="9252" class="jq jr hi jg b fi jw jt l ju jv">ADD . /app</span><span id="c47a" class="jq jr hi jg b fi jw jt l ju jv">WORKDIR /app</span><span id="a03d" class="jq jr hi jg b fi jw jt l ju jv"># bash</span><span id="dc68" class="jq jr hi jg b fi jw jt l ju jv">CMD ["/bin/bash"]</span></pre><p id="2c6a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要TensorFlow 1.15.0配GPU和Python3。命令<code class="du jd je jf jg b">FROM tensorflow/tensorflow:1.15.0-gpu-py3</code>用python3从基础映像TensorFlow 1.15.0映像创建docker映像。</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="6ef5" class="jq jr hi jg b fi js jt l ju jv">RUN /usr/bin/python3 -m pip install -U pip</span></pre><p id="8be3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的命令安装<code class="du jd je jf jg b">pip</code>。<code class="du jd je jf jg b">ADD requirements.txt /tmp/</code>将<code class="du jd je jf jg b">requirements.txt</code>文件添加到<code class="du jd je jf jg b">tmp</code>文件夹中。</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="a00e" class="jq jr hi jg b fi js jt l ju jv">RUN /usr/bin/python3 -m pip install -r /tmp/requirements.txt</span></pre><p id="f94d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的命令安装了<code class="du jd je jf jg b">requirements.txt.</code> <code class="du jd je jf jg b">ADD . /app</code>中提到的所有依赖项，将当前目录中的所有文件添加到docker映像中的<code class="du jd je jf jg b">app</code>文件夹，在我们的例子中是electra文件夹。<code class="du jd je jf jg b">WORKDIR /app</code>将<code class="du jd je jf jg b">app</code>目录设置为创建的docker镜像中的当前工作目录。</p><p id="50a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建<code class="du jd je jf jg b">.dockerignore</code>文件并添加<code class="du jd je jf jg b">data/openwebtext/*.xz . </code>这确保在构建docker时不会排除这些文件。</p><p id="8cbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">构建docker映像</strong></p><p id="7e14" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要创造体积</p><p id="c281" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要构建映像，请确保您位于docker文件所在的目录中。理想情况下，这个文件夹包含所有的数据和文件。在我们的例子中，它是electra文件夹。我们将使用<code class="du jd je jf jg b"><a class="ae jh" href="https://docs.docker.com/engine/reference/commandline/build/" rel="noopener ugc nofollow" target="_blank">docker build</a></code>命令，<code class="du jd je jf jg b">-t</code>标志用名称<code class="du jd je jf jg b">electra-image</code>标记新图像。<code class="du jd je jf jg b">.</code>表示当前目录，其中包含所有数据、文件和Dockerfile。</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="5286" class="jq jr hi jg b fi js jt l ju jv">docker build -t electra-image .</span></pre><p id="28a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">成功构建映像后，您可以选中运行docker映像以列出所有映像。你应该看到你的图片名为<code class="du jd je jf jg b">electra-image</code>。</p><p id="6538" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为我们需要从容器中获取模型，所以我们将把data文件夹作为一个卷挂载到electra文件夹中。(注意:请给出数据文件夹的绝对路径)。下面的命令为我们之前构建的<code class="du jd je jf jg b">electra-image</code>创建并启动容器。</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="5594" class="jq jr hi jg b fi js jt l ju jv">docker run --rm --gpus 0  -v /path/electra/data:/app/data -it electra-image</span></pre><p id="b5b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行此命令后，它会自动将您带到图像的终端，如下图所示。您可以看到,<code class="du jd je jf jg b">app/</code>文件夹包含了来自<code class="du jd je jf jg b">electra</code>文件夹的所有文件。</p><figure class="ji jj jk jl fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jx"><img src="../Images/2bbd2a19009f9d8dce298342ecd79025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT71DfpL0Iz3Ren8SlD20Q.png"/></div></div></figure><p id="7653" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了预处理electra的openwebtext数据集，转到<code class="du jd je jf jg b">app/</code>文件夹并运行命令<code class="du jd je jf jg b">python3 build_openwebtext_pretraining_dataset.py --data-dir data/ --num-processes 32.</code>，它预处理/标记数据并将示例输出为<code class="du jd je jf jg b">data/pretrain_tfrecords</code>下的<a class="ae jh" href="https://www.tensorflow.org/tutorials/load_data/tfrecord" rel="noopener ugc nofollow" target="_blank"> tfrecord </a>文件。tfrecords大约需要30G的磁盘空间。机器中有32个可用内核，因此使用32个num进程。请检查机器中可用的内核数量，并相应地选择数量。</p><p id="4431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">模型预处理</strong></p><p id="0af2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行<code class="du jd je jf jg b">python3 run_pretraining.py --data-dir data/ --model-name electra_small_owt</code>为了运行小型模型，除了<code class="du jd je jf jg b">electra_objective</code>之外，我们使用了<code class="du jd je jf jg b">configure_pretraining.py</code>中设置的超参数。由于我们正在训练一个BERT模型，我们将<code class="du jd je jf jg b">electra_objective</code>设置为<code class="du jd je jf jg b">false</code>。模型和我们的配置文件被写到<code class="du jd je jf jg b">data/models</code>目录中。</p><p id="bda1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">微调胶水数据上的伯特</strong></p><p id="55b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击从<a class="ae jh" href="https://github.com/nyu-mll/jiant-v1-legacy/blob/master/scripts/download_glue_data.py" rel="noopener ugc nofollow" target="_blank">下载胶水数据。遵循</a><a class="ae jh" href="https://github.com/google-research/electra#finetune-electra-on-a-glue--task" rel="noopener ugc nofollow" target="_blank">fine tune ELECTRA on a GLUE task</a>中给出的步骤。确保所有下载的胶水数据集都在<code class="du jd je jf jg b">/data/finetuning_data</code>下。您必须编辑<code class="du jd je jf jg b">.dockerignore</code>文件以排除模型和粘合数据集。参考<a class="ae jh" href="https://github.com/smallbenchnlp/BERT-small" rel="noopener ugc nofollow" target="_blank"> github </a> repo中的<code class="du jd je jf jg b">.dockerignore</code>文件。由于我们已经将<code class="du jd je jf jg b">data</code>文件夹挂载为卷，我们将能够访问docker容器中的模型和胶合数据集。构建docker映像并运行docker命令</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="75ee" class="jq jr hi jg b fi js jt l ju jv">docker build -t electra-image-finetune .<br/>docker run --rm --gpus 0  -v /path/electra/data:/app/data -it electra-image-finetune</span></pre><p id="bae6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要对Cola数据集进行微调，请运行下面给出的命令。</p><pre class="ji jj jk jl fd jm jg jn jo aw jp bi"><span id="dac6" class="jq jr hi jg b fi js jt l ju jv">python3 run_finetuning.py --data-dir $DATA_DIR --model-name electra_small_owt --hparams '{"model_size": "small", "task_names": ["cola"]}'</span></pre><p id="0e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您想试验不同的学习率，请将<code class="du jd je jf jg b">"learning_rate":3e-5</code>转到<code class="du jd je jf jg b">--hparams</code></p><p id="7e8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你想用<code class="du jd je jf jg b">Dockerfile</code>、<code class="du jd je jf jg b">.dockerignore</code>和<code class="du jd je jf jg b">requirements.txt</code>克隆回购协议，你可以在这里找到<a class="ae jh" href="https://github.com/smallbenchnlp/BERT-small" rel="noopener ugc nofollow" target="_blank">:</a></p><p id="903f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要删除您的图像，您可以运行命令<code class="du jd je jf jg b">docker image rm electra-image -f</code>。该命令强制删除<code class="du jd je jf jg b">electra-image</code>。删除不需要的图片以释放内存是一个很好的做法:)如果您有任何问题，请在github repo中留下评论或打开问题。</p></div></div>    
</body>
</html>