<html>
<head>
<title>Benchmarking Performances and Scaling of Time Series Forecast with Ray, Spark, Multiprocessing, and Concurrent futures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Ray、Spark、多处理和并发未来对时间序列预测的性能和规模进行基准测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/benchmarking-performances-and-scaling-of-time-series-forecast-with-multiprocessing-concurrent-68a8c552afd6?source=collection_archive---------8-----------------------#2021-03-03">https://medium.com/analytics-vidhya/benchmarking-performances-and-scaling-of-time-series-forecast-with-multiprocessing-concurrent-68a8c552afd6?source=collection_archive---------8-----------------------#2021-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="ae21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文介绍了不同的方法来衡量时间序列预测模型和基准他们的表现</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/817bd18d50b6495b16b7cf5429965ede.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*cRA5oFnEMQGALFa7vCORjA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:https://www.youtube.com/watch?v=fegS34ItKcI</figcaption></figure><p id="18b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">背景</strong></p><p id="7e53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我之前作为数据科学家的工作中，我的任务是构建一个时间序列预测模型来预测1000家商店的客流量。就像任何实验开始时一样，我采取了构建时间序列模型的天真方法:一个接一个地顺序循环，花了大约7个小时来训练和预测。这让我开始研究大规模预测这个话题。从我的研究中，我发现了多种方法来并行化训练和预测时间序列模型的任务，从使用具有多个核心的单个机器到使用多个机器。在试验了这些方法之后，我觉得有必要对它们进行基准测试，并找到最佳方法。对这些方法进行基准测试的灵感来自于马蒂亚斯·阿拉维娜·甘博亚撰写的媒体文章<a class="ae jo" rel="noopener" href="/spikelab/forecasting-multiples-time-series-using-prophet-in-parallel-2515abd1a245">使用并行预言家</a>预测多个时间序列。除了在上面的文章中提到的使用多重处理来扩展Prophet时间序列预测之外，我还介绍了使用并发期货的新方法，Spark和Ray，它们的性能明显优于多重处理。</p><p id="0904" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">不同的扩展方法</strong></p><p id="22e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于基准测试，我对不同的方法使用了相同的数据集、机器规格、预测程序和超参数。</p><p id="e16f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">数据集:</strong><a class="ae jo" href="https://www.kaggle.com/c/demand-forecasting-kernels-only/data" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/c/demand-forecasting-kernels-only/data</a></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/89efd5e83b589ab75f17c1261ce86c63.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*0xQP-IkgNbW582LfH2JHyg.png"/></div></div></figure><p id="9555" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该数据集包含10家商店的历史每日销售数据，每家商店包含2013年至2017年过去5年中的50件单品。任务是预测每个商店商品组合未来90天的销售额，这需要对500个不同的时间序列进行训练和预测。</p><p id="df4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">机器规格:</strong></p><p id="ed98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了对多处理、并发未来和Ray进行基准测试，我使用了我的个人机器<strong class="ig hi"> (MSI GL62MVR、I7、16GB RAM、8核设置)</strong></p><p id="c884" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了在Spark上进行分发，我提供了一个集群，其中有两个工作节点<strong class="ig hi"> (n1-standard-4 </strong> ) 4个内核，每个内核都使用<strong class="ig hi"> GCP Dataproc。</strong></p><p id="3e03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">预测程序:</strong> FBProphet</p><p id="21eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">FBProphet是一个预测时间序列的程序。这只是作为一个例子，但是该函数可以直接替换为任何预测模型并进行缩放。使用这个过程的原因之一是它使用stan的高效实现。在扩展这些过程时，确保它们是性能优化的非常重要。当使用云中的资源进行扩展时，这有助于降低每次预测的成本。</p><p id="6d84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将FBProphet分发到不同的内核，我创建了一个名为<strong class="ig hi"> run_prophet </strong>的函数。对于所有商店商品组合，函数中的参数是固定的，并且它返回带有预测的结果数据框架。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ju"><img src="../Images/13af4c5b27341a23ed00763853034491.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*tqqd1axriw0DHGuP5NbD_Q.png"/></div></figure><p id="4435" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法一:</strong> <strong class="ig hi">顺序式</strong></p><p id="7a68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为基线，prophet时间序列程序被依次训练和预测。整个过程花费了大约<strong class="ig hi"> 1小时20分钟</strong>来预测500种商店商品组合的销售。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jv"><img src="../Images/cfaecd74c16484c9df8b80b4adb86ff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rkM7_MpoQl7wyTE7eHo_Cw.png"/></div></div></figure><p id="4b0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法2: </strong> <strong class="ig hi">多重处理</strong></p><p id="0074" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">多重处理是一个支持多进程生成的包。代码中的<strong class="ig hi">池</strong>对象有助于并行执行<strong class="ig hi"> run_prophet </strong>函数。<strong class="ig hi"> imap() </strong>对可迭代<strong class="ig hi">系列</strong>中的每个数据帧异步运行<strong class="ig hi"> run_prophet </strong>函数，并阻塞直到结果准备好。<strong class="ig hi"> Join() </strong>方法等待工作进程退出。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jw"><img src="../Images/225c3b49b0518fbd77bf52e92e4097b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/format:webp/1*XC8E2zdaJNacsmJ8hN1jCQ.png"/></div></figure><p id="d248" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法三:同时期货</strong></p><p id="3fc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ProcessPoolExecutor 是运行多个进程的一种更简单有效的方式，它可以在<strong class="ig hi"> concurrent.futures </strong>模块中获得，最好与上下文管理器一起使用。<strong class="ig hi"> map() </strong>方法为可迭代<strong class="ig hi">系列中的每个数据帧异步运行<strong class="ig hi"> run_prophet </strong>函数。</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jv"><img src="../Images/bb964982c189c125cdf18c0f41f423df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keSH4qxZnlpb_zf6_uZbRw.png"/></div></div></figure><p id="ff1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法4:射线</strong></p><p id="2f45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Ray为构建分布式系统提供了一个简单通用的API。它支持并行处理单个机器代码，代码变化为零。从例子中可以看出，可以使用<strong class="ig hi"> ray.init() </strong>方法启动Ray。然后，Ray将使您能够利用机器上的所有内核。通过添加<strong class="ig hi"> @ray.remote </strong>装饰器，<strong class="ig hi"> run_prophet </strong>函数变成了一个远程函数，可以作为一个工作进程上的任务异步执行。函数的结果可以用<strong class="ig hi"> ray.get() </strong>方法检索。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jx"><img src="../Images/a5167523909627e190203e9819b54ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tPy5lt9Pgi_J0TDAgplUg.png"/></div></div></figure><p id="4912" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法5:火花</strong></p><p id="01e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Apache Spark </strong>是一个数据处理引擎，它也有助于分布大量模型的训练，它的处理数量只受可以提供的节点数量的限制。对于这个基准测试，我使用<strong class="ig hi"> GCP Dataproc </strong>和<strong class="ig hi"> 2个工作节点(每个4个内核)</strong>提供了一个托管spark集群。</p><p id="c1b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于Spark中的每个工人都需要有一个数据子集，在下面的代码片段中，我按照每个商店商品组合的销售数据进行分组。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jy"><img src="../Images/a213a18b4180d6ca6c03932c7c2a7e40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*FKdiEy7aR_1jiBLAp9Vd6g.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:<a class="ae jo" href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener ugc nofollow" target="_blank">https://databricks . com/blog/2020/01/27/time-series-forecasting-prophet-spark . html</a></figcaption></figure><p id="bc22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用装饰器<strong class="ig hi"> @pandas_udf </strong>声明的<strong class="ig hi"> pandas UDF </strong>的功能，可以为分组数据框中可用的每个数据子集训练模型。除此之外，UDF还将数据收集到单个结果数据帧中。这项工作持续了大约12分钟。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jz"><img src="../Images/bdd3c5881cebf71318bc32518a6ab467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*VdksrQ2W2xavrmEMTU61YQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:<strong class="bd ka"/><a class="ae jo" href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener ugc nofollow" target="_blank"><strong class="bd ka">https://databricks . com/blog/2020/01/27/time-series-forecasting-prophet-spark . html</strong></a></figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kb"><img src="../Images/23136c6b7926b6ad655826fbba406429.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*EVPmNBX06CE3BrooGaXdvA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:<a class="ae jo" href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener ugc nofollow" target="_blank">https://databricks . com/blog/2020/01/27/time-series-forecasting-prophet-spark . html</a></figcaption></figure><p id="42fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">运行基准测试</strong></p><p id="3c62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些基准测试的结果可以使用<a class="ae jo" href="https://github.com/amrishan/scaling-prophet-timeseries" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>重现。</p><p id="542a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在运行笔记本之前，激活conda环境。</p><p id="e357" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码在我的个人笔记本电脑上运行(<strong class="ig hi"> MSI GL62MVR，I7，16GB RAM，8核设置)。</strong></p><p id="eee7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于spark，使用GCPs free credits创建一个包含2个worker节点的DataProc集群。基准的spark代码可在处找到<a class="ae jo" href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1d3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="98b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从基准测试中，我们可以看到<strong class="ig hi"> Ray </strong>和<strong class="ig hi"> Spark </strong>框架花费的时间<strong class="ig hi">比模块<strong class="ig hi">多处理</strong>和<strong class="ig hi">并发期货</strong>花费的时间</strong>少一半。</p><p id="f417" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这主要是因为，Ray <strong class="ig hi">能够高效地处理数字数据</strong>而<strong class="ig hi">能够在任务</strong>之间共享变量。类似地，Spark凭借其分布式处理和可伸缩性做了同样令人印象深刻的工作。</p><p id="6808" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我个人喜欢Ray，因为它的<strong class="ig hi">几乎不需要修改代码</strong>就可以在一台机器上扩展时间序列预测模型。即使有大量模型需要训练，Ray也可以通过增加内核数量来配置更大的实例，从而毫不费力地进行扩展。除此之外，Ray工作负载可以<strong class="ig hi">自动从机器和进程故障中恢复。</strong></p><p id="04e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一些基准测试中</p><p id="4348" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">"<em class="kc"> Ray比串行Python快</em><strong class="ig hi"><em class="kc">10–30x</em></strong><em class="kc">，</em><strong class="ig hi"><em class="kc">5–25x</em></strong><em class="kc">比多处理快，</em><strong class="ig hi"><em class="kc">5–15x</em></strong><em class="kc">比大型机器上的这两个</em>快。"</p><p id="1ee4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于这个基准测试的更多信息可以在这里找到<a class="ae jo" href="https://towardsdatascience.com/10x-faster-parallel-python-without-python-multiprocessing-e5017c93cce1" rel="noopener" target="_blank">10倍更快的并行python无python多处理</a>作者<a class="ae jo" rel="noopener" href="/@robertnishihara?source=post_page-----e5017c93cce1--------------------------------"> Robert Nishihara </a></p><p id="d257" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Spark </strong>和<strong class="ig hi"> </strong>在训练和预测方面做得同样出色。使用Spark的主要优势是它能够从1000个模型扩展到数百万个模型，这仅受集群大小的限制。因此，根据不同的用例,<strong class="ig hi"> Spark </strong>或<strong class="ig hi"> Ray </strong>在扩展时间序列预测模型方面做得非常出色。</p><p id="e4c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">参考</strong></p><div class="kd ke ez fb kf kg"><a href="https://towardsdatascience.com/10x-faster-parallel-python-without-python-multiprocessing-e5017c93cce1" rel="noopener follow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hi fi z dy kl ea eb km ed ef hg bi translated">没有Python多重处理，并行Python速度快10倍</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">虽然Python的多重处理库已经被成功地用于广泛的应用中，但是在这篇博文中…</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">towardsdatascience.com</p></div></div><div class="kp l"><div class="kq l kr ks kt kp ku ji kg"/></div></div></a></div><div class="kd ke ez fb kf kg"><a href="https://databricks.com/blog/2020/01/27/time-series-forecasting-prophet-spark.html" rel="noopener  ugc nofollow" target="_blank"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hi fi z dy kl ea eb km ed ef hg bi translated">用Prophet &amp; Spark进行时间序列预测</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">试试Databricks中的时间序列预测笔记本时间序列预测的进步使零售商能够…</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">databricks.com</p></div></div><div class="kp l"><div class="kv l kr ks kt kp ku ji kg"/></div></div></a></div><div class="kd ke ez fb kf kg"><a rel="noopener follow" target="_blank" href="/spikelab/forecasting-multiples-time-series-using-prophet-in-parallel-2515abd1a245"><div class="kh ab dw"><div class="ki ab kj cl cj kk"><h2 class="bd hi fi z dy kl ea eb km ed ef hg bi translated">并行使用Prophet预测多重时间序列</h2><div class="kn l"><h3 class="bd b fi z dy kl ea eb km ed ef dx translated">一个关于多重处理的小故事</h3></div><div class="ko l"><p class="bd b fp z dy kl ea eb km ed ef dx translated">medium.com</p></div></div><div class="kp l"><div class="kw l kr ks kt kp ku ji kg"/></div></div></a></div><p id="b953" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">多处理和并发未来模块简介【https://www.youtube.com/results? T42】search _ query = corey+shafer+多重处理</p></div></div>    
</body>
</html>