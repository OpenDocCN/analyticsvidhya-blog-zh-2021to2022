<html>
<head>
<title>Contours and Convex Hull in OpenCV Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV Python中的轮廓和凸包</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/contours-and-convex-hull-in-opencv-python-d7503f6651bc?source=collection_archive---------0-----------------------#2021-04-19">https://medium.com/analytics-vidhya/contours-and-convex-hull-in-opencv-python-d7503f6651bc?source=collection_archive---------0-----------------------#2021-04-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9676" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数计算机视觉问题的答案在于找到并分析图像中存在的形状，而获取轮廓就是这样一种方法。对于初学者，我会把轮廓简单地解释为“<em class="jd">一条连接位于形状</em>边界上的所有点的曲线”。</p><p id="046a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设我有下面这张手的图像，手的轮廓是由绿线表示的曲线。红点显示的是我们通过连接组成轮廓曲线的点。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/764c58992fcb9ce9f27717d73494a69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*S6qd7TxmhYCyImzgmIof9A.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">轮廓点(红色)。连接轮廓点，我们创建轮廓曲线(绿色)</figcaption></figure><p id="d481" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是常见形状的轮廓:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es jq"><img src="../Images/8d19e2a8f9f9588d8eb3f35108b0a210.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*aq7hzQc3oard4WjlzxXkcw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">常见形状的轮廓(绿色)</figcaption></figure><p id="60d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我仍然记得我的高等数学课，他们教等高线。但这很难与这个主题的重要性联系起来，因为老师从未提到轮廓在现实世界中的任何应用。今天是我意识到它们在计算机视觉中有多重要的一天。</p></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><h1 id="c3c7" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">在OpenCV中查找轮廓</h1><blockquote class="kw kx ky"><p id="120a" class="if ig jd ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">在图像中寻找轮廓的唯一先决条件是图像应该是二值的。要详细了解二进制图像，请查看我的<a class="ae lc" href="https://dhruv-pandey93.medium.com/image-simplification-through-binarization-in-opencv-1292d91cae12" rel="noopener">文章</a>。</p></blockquote><p id="f269" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我使用前一篇文章中讨论的Canny边缘检测将我的图像转换为二进制图像:</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="a112" class="li jz hi le b fi lj lk l ll lm">binary_image = edgeDetection(image)<br/>contours, hierarchy = cv2.findContours(binary_image, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)</span></pre><p id="c038" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦你有了二值图像，你只需要把它传给<em class="jd"> findContours() </em>就可以了，轮廓已经准备好了。在我们继续之前，让我们讨论这个函数的其他参数。</p><p id="32b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">第二个参数(轮廓检索模式):</em> </strong> <br/>一个形状(或轮廓)可能存在于另一个形状(或轮廓)内部。所以我们可以称外部形状为父母，称内部形状为孩子。检索模式参数决定是否希望轮廓列表以分级(父-子)方式输出，或者我们只是希望它们作为一个列表(没有分级)。使用<em class="jd"> cv2。RETR _列表</em>用于无层次/普通列表。点击查看更多变体<a class="ae lc" href="https://docs.opencv.org/4.5.1/d9/d8b/tutorial_py_contours_hierarchy.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="e1c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:</em> <em class="jd">对轮廓检测没有影响。只是响应表示发生了变化。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ln"><img src="../Images/0698dc9a4ab4b8b642103c74becfd667.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*HzUjeHJoJ5wnD3s3btNJmA.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">轮廓层次结构</figcaption></figure><p id="de02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">第三个参数(轮廓近似):</em> </strong> <br/>轮廓只是一个由点的集合表示的形状(第一个图像中的红点)。因此，此参数指定应存储多少个点，以便保留轮廓形状并可以重新绘制。<em class="jd"> cv2。CHAIN _ approximate _ NONE</em>表示我们存储所有的点(无近似值)。这需要更多的存储空间，但是如果有一条之字形线，我们肯定需要存储所有的点来保持轮廓形状。但是在直线的情况下，2个点就足够了，因为中间的点可以根据直线的方程来近似，所以我们使用<em class="jd"> cv2。链_近似_简单。</em></p><p id="7652" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">输出<em class="jd">轮廓</em>是轮廓点的列表，每个轮廓点具有x和y坐标。</p></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><h1 id="3176" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">等高线上的操作</h1><ol class=""><li id="aea8" class="lo lp hi ih b ii lq im lr iq ls iu lt iy lu jc lv lw lx ly bi translated"><strong class="ih hj">轮廓面积:</strong>您可以根据轮廓面积对其进行排序。</li></ol><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="7e38" class="li jz hi le b fi lj lk l ll lm">contours = sorted(contours, key=lambda x: cv2.contourArea(x), reverse=True)</span></pre><p id="2eb9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">轮廓周长:</strong>你可以计算每个轮廓的周长。</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="fcae" class="li jz hi le b fi lj lk l ll lm">for contour in contours:<br/>    perimeter = cv2.arcLength(contour, True)</span></pre><p id="5324" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">轮廓的顶点:</strong>由于我们知道轮廓只是它的点的x和y坐标的表示。所以得到轮廓的长度，就给了我们轮廓的顶点。</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="54f8" class="li jz hi le b fi lj lk l ll lm">len(contour) == 4   #Rectangle</span></pre><p id="7deb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.<strong class="ih hj">轮廓近似:</strong>这有点棘手，所以需要更多的解释。这非常类似于我们上面讨论的第三个论点，只是它给了我们更多的手动控制。</p><p id="6b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设OpenCV检测到一个轮廓，如下图(1)所示。你认为能得到的最接近的规则形状会是什么，肯定是一条线(假设峰值对我们不重要)。此外，既然峰值对我们来说并不重要，为什么要浪费我们的存储空间来存储峰值的坐标。相反，如果我们能以某种方式将这个轮廓近似为一条线，我们只需要2个坐标来存储我们的轮廓。这就是cv2.approxPolyDP() 为我们做的事情。它试图将不规则轮廓近似为其他形状，以便简化轮廓。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/155752927bb589fcdedfce7aaa64cf95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkEkMkI7roXHWmS65EwbaQ.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">如何控制轮廓近似</figcaption></figure><p id="6489" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们如何控制这种近似？<em class="jd"> cv2.approxPolyDP() </em>接受一个<em class="jd"> epsilon </em>参数，该参数的值告诉OpenCV，为了得到简化的轮廓，我们可以允许与原始形状有多大的偏差。图像(3)显示了10%的ε，这意味着我们有点愿意得到简化的轮廓(如5中的直线)。图像(4)显示了20%的ε，这意味着我们更愿意得到简化的轮廓(如5中的直线)。随着ε值的增加，峰值向直线方向移动。<em class="jd">更多的ε意味着更愿意得到简化的轮廓。</em></p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="10ff" class="li jz hi le b fi lj lk l ll lm">for contour in contours:<br/>    perimeter = cv2.arcLength(contour, True)<br/>    approximatedShape = cv2.approxPolyDP(contour, 0.02 * perimeter, True)</span></pre><p id="81c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看看我们是如何传递第二个参数(ε)的。最后一个参数只是说如果想要一个封闭的轮廓。</p><p id="6dfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.<strong class="ih hj">最小封闭圆:</strong>使用minEnclosingCircle()可以找到一个以最小面积完全覆盖物体轮廓的圆。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es me"><img src="../Images/cdacec7c422b096b60c6e284a06ad698.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*Vbw3X6dekkNiZub2CD61Cg.png"/></div></figure><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="0786" class="li jz hi le b fi lj lk l ll lm">(centerXCoordinate, centerYCoordinate), radius = cv2.minEnclosingCircle(contour)</span></pre><p id="489a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.<strong class="ih hj">矩:</strong>矩可以让你提取重要轮廓的物理属性，比如物体的质心，物体的面积等。</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="db9a" class="li jz hi le b fi lj lk l ll lm">for contour in contours:<br/>    moment = cv2.moments(contour)</span></pre><p id="65e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以用矩来进一步计算轮廓的重要属性，如形心:</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="07ec" class="li jz hi le b fi lj lk l ll lm">centroidXCoordinate = int(moment['m10'] / moment['m00'])<br/>centroidYCoordinate = int(moment['m01'] / moment['m00'])</span></pre><p id="2ac3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以在此查看轮廓<a class="ae lc" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html" rel="noopener ugc nofollow" target="_blank">上允许的更多此类操作。</a></p></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><h1 id="c369" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">凸包</h1><p id="cbca" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq mf is it iu mg iw ix iy mh ja jb jc hb bi translated">如果用外行的话来解释，一个物体的凸包就是能够完全包围或者包裹该物体(或者该物体的轮廓)的<em class="jd">最小</em>边界。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mi"><img src="../Images/3c97d170ce0f48eecf3b7964d915391f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*yOK58dmzVVTgAGCmyJWs2Q.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">此处引用自<a class="ae lc" href="https://theailearner.com/2019/12/05/finding-convex-hull-opencv-python/" rel="noopener ugc nofollow" target="_blank">中的</a></figcaption></figure><p id="6e67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有许多算法可以用来寻找给定轮廓的凸包，但我不会在本文中详细讨论它们。一旦你找到了轮廓，找到凸包就相当简单了</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="ab43" class="li jz hi le b fi lj lk l ll lm">for contour in contours:<br/>    convexHull = cv2.convexHull(contour)<br/>    cv2.drawContours(image, [convexHull], -1, (255, 0, 0), 2)<br/><br/># Display the final convex hull image<br/>cv2.imshow('ConvexHull', image)<br/>cv2.waitKey(0)</span></pre></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><h1 id="27ec" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">凸面缺陷</h1><p id="4126" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq mf is it iu mg iw ix iy mh ja jb jc hb bi translated">轮廓与其凸包的任何偏差都称为凸性缺陷。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mj"><img src="../Images/711aa6d1087c2463f6b11a749d9325b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oQr4F4lYcMRO4l4oCgXjg.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">最后一张图中的垂直线就是我们所说的凸面缺陷</figcaption></figure><p id="eff3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意:可能有多个凸度缺陷点，其中外壳偏离轮廓，但在最后一幅图像中，我只显示了主要的凸度缺陷，以免混淆。</em></p><p id="8c6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">OpenCV提供了一种从轮廓和外壳中找到凸面缺陷的简单方法:</p><pre class="jf jg jh ji fd ld le lf lg aw lh bi"><span id="ad3c" class="li jz hi le b fi lj lk l ll lm">convexityDefects = cv2.convexityDefects(contour, convexhull)</span></pre><p id="9ad2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">凸面缺陷</em>包含所有发现的凸面缺陷列表。该列表中的每个元素都具有以下属性:</p><p id="1e7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">【起点、终点、最远点、到最远点的近似距离】</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mk"><img src="../Images/e126b45916bdd3d0d436be4f9d46986f.png" data-original-src="https://miro.medium.com/v2/resize:fit:740/format:webp/1*Q9UVsouEISLEdMlWAU7zGw.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">特定凸性缺陷的值(3，4)</figcaption></figure></div><div class="ab cl jr js gp jt" role="separator"><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw jx"/><span class="ju bw bk jv jw"/></div><div class="hb hc hd he hf"><h1 id="0daf" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">最后的话</h1><p id="12af" class="pw-post-body-paragraph if ig hi ih b ii lq ik il im lr io ip iq mf is it iu mg iw ix iy mh ja jb jc hb bi translated">大多数计算机视觉问题都有自己的解决方案</p><ol class=""><li id="0bdf" class="lo lp hi ih b ii ij im in iq ml iu mm iy mn jc lv lw lx ly bi translated">找到轮廓，然后</li><li id="7cb7" class="lo lp hi ih b ii mo im mp iq mq iu mr iy ms jc lv lw lx ly bi translated">应用轮廓操作以获得期望的结果。</li></ol><p id="2fa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从我的个人经验来看，我会说第一点并不难，但是第二点需要你付出大部分的努力，在进入下一步之前，在每一步结束时仔细检查和调试结果。</p><p id="301a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望他的文章能给你一个很好的轮廓入门。我会写更多关于我们实际应用轮廓的真实项目的文章。所以别忘了检查它们。</p></div></div>    
</body>
</html>