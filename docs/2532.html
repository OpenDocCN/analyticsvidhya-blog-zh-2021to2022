<html>
<head>
<title>A Simple Walkthrough With Sci-kit Learn’s Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sci-kit Learn管道的简单演练</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-simple-walkthrough-with-sci-kit-learns-pipeline-46cdf6e53354?source=collection_archive---------4-----------------------#2021-04-30">https://medium.com/analytics-vidhya/a-simple-walkthrough-with-sci-kit-learns-pipeline-46cdf6e53354?source=collection_archive---------4-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/efc59563ad9310f2ba9527b8018754fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LI1hS6e6PL6AVUTe7z47CQ.jpeg"/></div></div></figure><h1 id="8bd1" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">管道的基本概述</h1><p id="1a81" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">流水线在机器学习系统中很常见，有助于加速和简化一些预处理情况。它们用于将多个估计器链接成一个，从而自动化机器学习过程。这非常有用，因为在处理数据时通常有固定的步骤顺序。当涉及到分离基本模型并比较它们以查看哪一个可能为特定的一个或多个指标提供更好的结果时，它们也是有用的，但是访问管道的某些部分也可能是棘手的。一个模型的管道框架相当简单。</p><h1 id="fc42" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">我们的示例数据</h1><p id="c977" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">我们将在本演练中使用的数据将是葡萄酒质量数据集，我们可以从Sci-kit Learn的库中获得。如果你想继续，这里有这个博客的Jupyter笔记本的链接。让我们继续导入我们将使用的必要库:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="b759" class="kv iq hh kr b fi kw kx l ky kz"># importing libraries<br/>import pandas as pd<br/>import numpy as np<br/>from sklearn import datasets</span></pre><p id="6b4c" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">现在，让我们将数据加载到数据帧中，并将功能名称分配给正确的列:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="26b5" class="kv iq hh kr b fi kw kx l ky kz"># loading in the data<br/>wine = datasets.load_wine()</span><span id="a6cd" class="kv iq hh kr b fi lf kx l ky kz"># Creating a dataframe<br/>df = pd.DataFrame(wine['data'])</span><span id="9647" class="kv iq hh kr b fi lf kx l ky kz"># Assigning the correct feature names for each column in the df<br/>df.columns = wine['feature_names']</span><span id="be52" class="kv iq hh kr b fi lf kx l ky kz"># Adding the target to our dataframe<br/>df['target'] = wine['target']</span><span id="7713" class="kv iq hh kr b fi lf kx l ky kz">df.head()</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/813bfecc63cabb88725ab8791d6cf87c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFBCNqCKjoZj5h3aLJHm2w.jpeg"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">查看df的头部</figcaption></figure><h1 id="4a1d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">我们将使用的模型类型</h1><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="2326" class="kv iq hh kr b fi kw kx l ky kz">from sklearn.svm import SVC</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es ll"><img src="../Images/6264c1b740ac0ad9aa85b91fd012539b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*iUPqc_nTwe_O_GB4F6qGXw.png"/></div></figure><p id="a602" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">我们将使用Sci-kit Learn的支持向量机分类器模型。SVC的主要目标是以尽可能好的方式分离给定的数据集。这两个最近点之间的距离称为边距。目标是在给定的数据集中选择一个在支持向量之间具有最大可能间隔的超平面。它对自己训练出来的数据没有任何假设。它还要求对数值数据进行要素缩放，并且对数据集中的任何空值都很敏感。我们还应该注意到，它对异常值非常健壮。</p><p id="7ff9" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated"><strong class="jp hi">该型号的优点包括</strong>:</p><ul class=""><li id="d97a" class="lm ln hh jp b jq la ju lb jy lo kc lp kg lq kk lr ls lt lu bi translated">适用于变量多于观测值的数据集</li><li id="c2d9" class="lm ln hh jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">良好的性能</li><li id="698d" class="lm ln hh jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">几种情况下良好的现成模型</li><li id="e82d" class="lm ln hh jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">可以逼近复杂的非线性函数</li></ul><p id="74ab" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated"><strong class="jp hi">缺点包括</strong>:</p><ul class=""><li id="8267" class="lm ln hh jp b jq la ju lb jy lo kc lp kg lq kk lr ls lt lu bi translated">需要长时间的培训</li><li id="939c" class="lm ln hh jp b jq lv ju lw jy lx kc ly kg lz kk lr ls lt lu bi translated">需要调整来确定哪个核对于非线性支持向量机是最佳的</li></ul><p id="71f8" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">因为SVC模型对数据集中的空值很敏感，所以让我们确保没有空值。我们可以通过调用以下命令来查看数据集，以确保没有空值:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="26c6" class="kv iq hh kr b fi kw kx l ky kz"># Viewing the percentage of null values in each column<br/>df.isna().mean()</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es ma"><img src="../Images/67015bded1b79390dd7819e7c636689e.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*ZgitHoRd3l2nsM9n0mhooA.jpeg"/></div></figure><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="6dae" class="kv iq hh kr b fi kw kx l ky kz"># Viewing the values within each column<br/>df.describe()</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/a2ee8cee4026f23c97bf8d5c9ea370d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0F6FcsR4Ua1JDYBlu7Mvzg.jpeg"/></div></div><figcaption class="lh li et er es lj lk bd b be z dx translated">df.describe()结果在此图中被有意缩短</figcaption></figure><p id="8eac" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">请注意，每列中的数字数据有不同的范围。在拟合模型之前，我们需要对数据进行缩放。在我们开始使用Sci-kit Learn的管道对象之前，让我们先在不使用管道的情况下设置和训练一个SVC模型。</p><h1 id="38b0" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">基于缩放的训练和测试数据训练SVC</h1><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="255e" class="kv iq hh kr b fi kw kx l ky kz">from sklearn.preprocessing import StandardScaler<br/>from sklearn.model_selection import train_test_split</span></pre><p id="45dc" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">在扩展数据之前，我们必须首先将数据分成训练集和测试集。我们将导入更多的库，然后创建变量来保存特性和标签。</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="5235" class="kv iq hh kr b fi kw kx l ky kz"># Separating the features and target variable<br/>X = df.drop(columns='target')<br/>y = df['target']</span><span id="7e35" class="kv iq hh kr b fi lf kx l ky kz"># Creating train and test sets and setting seed<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)</span></pre><p id="8056" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">现在，我们可以使用StandardScaler对象来缩放训练和测试数据:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="00bd" class="kv iq hh kr b fi kw kx l ky kz"># fitting the scaler to the training features, and creating new variables to hold the scaled train and test features<br/>scaler = StandardScaler()<br/>X_train_scaled = scaler.fit_transform(X_train)<br/>X_test_scaled = scaler.transform(X_test)</span></pre><p id="fcea" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">实例化SVC模型:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="6bda" class="kv iq hh kr b fi kw kx l ky kz">svm = SVC()<br/>svm.fit(X_train_scaled, y_train)</span></pre><p id="a7fd" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">创建我们的预测以与测试集标签进行比较，并测量模型的准确性:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="2494" class="kv iq hh kr b fi kw kx l ky kz">y_pred = svm.predict(X_test_scaled)</span><span id="16bc" class="kv iq hh kr b fi lf kx l ky kz">print(metrics.classification_report(y_test, y_pred))</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/4480249c64814167ae4dbfcb00dca56a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*KPIz1x59U7RWxsgY53Y6RA.jpeg"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">我们的SVC模型的分类报告</figcaption></figure><p id="4124" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">似乎模型表现得极其出色，准确率在98%左右。让我们来看一个混淆矩阵:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="3342" class="kv iq hh kr b fi kw kx l ky kz">metrics.plot_confusion_matrix(svm,X_test_scaled,y_test,<br/>normalize=’true’,cmap=’Greens’);</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es md"><img src="../Images/967f580813acef58a760305da4e0dd42.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*MkwZyy_nKxr6UOmUGo-nmQ.jpeg"/></div><figcaption class="lh li et er es lj lk bd b be z dx translated">SVC模型的混淆矩阵</figcaption></figure><p id="3bbe" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">似乎这个模型在区分类1和类2时遇到了一点困难。我们可以对此进行更详细的阐述，并调整模型的参数，但是让我们实现Sci-kit Learn的管道对象！</p><h1 id="fe02" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">使用Sci-kit Learn的管道</h1><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="2e63" class="kv iq hh kr b fi kw kx l ky kz">from sklearn.pipeline import Pipeline</span></pre><p id="c1c6" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">为了实例化管道对象，我们可以说:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="dd41" class="kv iq hh kr b fi kw kx l ky kz">pipe = Pipeline()</span></pre><p id="5d00" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">在括号中，我们必须指定预处理步骤和模型，以便在管道中使用。为了得到比上述单元格更具体的信息，我们可以说:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="29cb" class="kv iq hh kr b fi kw kx l ky kz">pipe = Pipeline(steps=[(‘scaler’, StandardScaler()), ('svm', SVC()])</span></pre><p id="04b2" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">管道对象中的<strong class="jp hi">步骤</strong>参数接受一个元组列表。每个元组包含<em class="me">名称和一个转换器或模型的实例。</em>我们给每个变压器或型号起的名字可以是任何东西，它们只是为了清楚地识别变压器/型号。元组的顺序很重要——我们希望确保在将数据输入模型之前对其进行缩放。</p><p id="6755" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">现在，我们已经创建了管道并定义了步骤，我们可以使管道适合训练集，并使用测试集对其进行评估:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="c958" class="kv iq hh kr b fi kw kx l ky kz">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)</span><span id="fa58" class="kv iq hh kr b fi lf kx l ky kz">pipe.fit(X_train, y_train)</span></pre><p id="8551" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">创建我们的预测以与测试集标签进行比较，并测量流水线模型的准确性:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="3b09" class="kv iq hh kr b fi kw kx l ky kz"># Creating  <br/>y_pred_pipe = pipe.predict(X_test)</span><span id="b9ca" class="kv iq hh kr b fi lf kx l ky kz">print(metrics.classification_report(y_test, y_pred_pipe))</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/5e04f59ca0b8070c46186d82578576df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1054/format:webp/1*wWtA1CImMBC2tXhdl4eisg.jpeg"/></div></figure><p id="7ceb" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">现在让我们看看与我们的流水线模型相关的混淆矩阵:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="26bd" class="kv iq hh kr b fi kw kx l ky kz">metrics.plot_confusion_matrix(pipe, X_test, y_test, normalize=’true’, cmap=’Reds’);</span></pre><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/fb034f34a35cd1876aa76b26aa459fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*7U70W31qk8dwmi0nNHkt3A.jpeg"/></div></figure><p id="ba58" class="pw-post-body-paragraph jn jo hh jp b jq la js jt ju lb jw jx jy lc ka kb kc ld ke kf kg le ki kj kk ha bi translated">请注意，我们生成的两个混淆矩阵包含完全相同的结果——这是因为我们在创建训练集和测试集时定义了相同的随机状态。这很好，因为这告诉我们，我们用来训练和评估模型的两种方法给出了相同的结果。使用管道有助于执行所需的应用步骤顺序，创建方便的工作流程，确保工作的可重复性。如果您有任何问题，请随时联系我们。感谢阅读！</p></div></div>    
</body>
</html>