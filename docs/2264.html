<html>
<head>
<title>Building A Wedding Seating Plan Using Probabilistic Methods &amp; Simulated Annealing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用概率方法和模拟退火建立婚礼座位计划</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-wedding-seating-plan-using-probabilistic-methods-simulated-annealing-8f31d8987026?source=collection_archive---------1-----------------------#2021-04-15">https://medium.com/analytics-vidhya/building-a-wedding-seating-plan-using-probabilistic-methods-simulated-annealing-8f31d8987026?source=collection_archive---------1-----------------------#2021-04-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><blockquote class="if"><p id="0a9c" class="ig ih hi bd ii ij ik il im in io ip dx translated">这篇文章介绍了婚礼座位安排问题，这是一个组合难题，考虑到客人可能不想坐在餐桌上或不想和其他客人坐在一起，如何最好地给他们分配座位。</p><p id="c9f2" class="ig ih hi bd ii ij ir is it iu iv ip dx translated"><em class="iq">使用强力搜索和模拟退火以及其他典型优化方法(如遗传算法、MILP、WalkSAT等)的概述，对两种深入的示例方法进行了检验</em></p></blockquote><figure class="iw ix iy iz ja jb"><div class="bz dy l di"><div class="jc jd l"/></div></figure><p id="65a4" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">婚礼往往是有压力的事件，通常是因为需要在日期、地点、餐饮等方面做出许多决定，导致配偶之间需要大量的调整。</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kb"><img src="../Images/e7b350157f0a8c1b38958f03d85e00ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9R3jbtLfJjQrp9jqjc5XCw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:【Dreamstime.com】股票图片</figcaption></figure><p id="675f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">一个特别棘手的挑战是如何正确安排座位，因为经常会有一些客人需要坐在一起(例如，可能因为他们是直系或近亲家庭成员)，但也有一些客人可能需要分开(可能因为一些远房阿姨对另一个远房叔叔怀恨在心，因为他十年前在另一个堂兄弟的婚礼上对她的头发做了一些轻率的评论)</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es kr"><img src="../Images/63886f698b406c6d30dfde6f73d35799.png" data-original-src="https://miro.medium.com/v2/resize:fit:932/format:webp/1*QDQdDDN--nDicSDbXmGW7w.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">一个有用但不太数学化的指南(来源:<a class="ae kq" href="https://www.brides.com/story/wedding-reception-seating-chart-etiquette" rel="noopener ugc nofollow" target="_blank">Brides.com</a></figcaption></figure><p id="571d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">大多数时候，你可以通过反复试验来“手动”调整桌子座位，但是如果你有足够多的客人和/或桌子，那么考虑到你可以选择的可能配置的绝对数量，有效地这样做可能会变得相当复杂。</p><p id="086a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">令人欣慰的是，这种情况可以作为一个组合优化问题，并已研究了许多不同的方法来“解决”它。(我在‘解决’周围使用引号，因为从技术上讲，这个问题是NP难的<a class="ae kq" href="https://en.wikipedia.org/wiki/NP-hardness" rel="noopener ugc nofollow" target="_blank"/>,所以实际上它是关于找到‘足够好’的解决方案)</p><p id="a30b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">在本文中，我们将介绍两种不同的方法。第一种方法是使用电子表格工具的(天真的)暴力方法。尽管这仅适用于小规模的问题(也就是说，它的伸缩性很差)，但是为问题建立直觉是很有用的。第二种方法是通过一些Python代码，使用一种稍微复杂一点的技术，称为模拟退火。最后，如果您想进一步探索这个主题，我们将总结其他可能的解决方法。</p><p id="b97f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">完整代码(如Python Jupyter笔记本和XLSM文件等)可从Github链接获得:</p><div class="ks kt ez fb ku kv"><a href="https://github.com/ZhijingEu/Wedding-Seating-Problem-Simulated-Annealing" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">织金谷/婚礼座位问题模拟退火</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">婚礼座位问题是一个组合难题，经常出现在…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj kk kv"/></div></div></a></div><h1 id="fd1c" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">大纲:</h1><ul class=""><li id="d1b3" class="mi mj hi jg b jh mk jl ml jp mm jt mn jx mo ip mp mq mr ms bi translated"><a class="ae kq" href="#c20b" rel="noopener ugc nofollow"> <strong class="jg hj"> 1。将场景框架化为一个“可计算”的问题</strong> </a></li><li id="a45a" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated"><a class="ae kq" href="#8f48" rel="noopener ugc nofollow">2<strong class="jg hj">。方法1:用Excel进行朴素的蛮力搜索</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#5e49" rel="noopener ugc nofollow"><strong class="jg hj">2.1定义“代价”函数</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#2716" rel="noopener ugc nofollow"><strong class="jg hj">2.2开发一种搜索算法</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#9822" rel="noopener ugc nofollow"><strong class="jg hj">2.3缺点用蛮力方法</strong> </a></li><li id="a012" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated"><a class="ae kq" href="#c2f1" rel="noopener ugc nofollow"> <strong class="jg hj"> 3。方法二:用Python模拟退火</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#19a0" rel="noopener ugc nofollow"><strong class="jg hj">3.1定义“代价”函数</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#15a0" rel="noopener ugc nofollow"><strong class="jg hj">3.2开发一个(更好的)搜索算法:模拟退火</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#a336" rel="noopener ugc nofollow"><strong class="jg hj">3.3缺点用模拟退火方法</strong> </a></li><li id="1a8b" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated"><a class="ae kq" href="#8d05" rel="noopener ugc nofollow"> <strong class="jg hj"> 4。其他可能的解决方法</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#9a65" rel="noopener ugc nofollow"><strong class="jg hj">4.1 CNF+沃克萨特</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#1ef0" rel="noopener ugc nofollow"><strong class="jg hj">4.2禁忌搜索</strong></a><strong class="jg hj"><br/></strong><a class="ae kq" href="#8d82" rel="noopener ugc nofollow"><strong class="jg hj">4.3混合整数线性规划</strong> </a> <strong class="jg hj"> <br/> </strong> </li><li id="dbc5" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated"><a class="ae kq" href="#8049" rel="noopener ugc nofollow"> <strong class="jg hj"> 5。结论</strong> </a></li></ul><p id="c5ab" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">对于那些懒得通读下面全部细节的人来说，这篇文章也可以通过视频浏览:</p><figure class="kc kd ke kf fd jb"><div class="bz dy l di"><div class="jc jd l"/></div></figure><h1 id="c20b" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak"> 1。将该场景框定为一个“可计算”的问题</strong></h1><p id="984e" class="pw-post-body-paragraph je jf hi jg b jh mk jj jk jl ml jn jo jp my jr js jt mz jv jw jx na jz ka ip hb bi translated">在最高层次上，任何解决这个问题的方法都包括两个步骤</p><p id="9341" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">1.首先，需要定义什么标准使一种座位配置优于另一种。换句话说，它是关于开发一个评分方案或成本函数来评估任何给定的座位配置。</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es nb"><img src="../Images/86f5fca6cfe0c5ce89d4c2d3479ba475.png" data-original-src="https://miro.medium.com/v2/resize:fit:322/format:webp/1*zk6pwSyd3NtA2kKvs-Kt9Q.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源:<a class="ae kq" href="https://iconarchive.com/show/flatastic-7-icons-by-custom-icon-design/Test-paper-icon.html" rel="noopener ugc nofollow" target="_blank">图标存档股票图片</a></figcaption></figure><p id="f9ed" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">2.下一步是高效地<strong class="jg hj"><em class="nc"/></strong>搜索所有可能的配置，以找到产生最佳得分(即优化“成本函数”)的配置(可能有多个答案)</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es nd"><img src="../Images/e17dc9981abada1e964eb91e8e58f590.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*GlpOsdT7fHNgKLxFnuTEMQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源图片:改编自<a class="ae kq" href="https://www.dreamstime.com/photos-images/person-pile-papers.html" rel="noopener ugc nofollow" target="_blank">DreamsTime.com</a>股票图片</figcaption></figure><p id="cd22" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这种搜索方法的选择决定了运行该算法需要多长时间，例如，该算法是否会彻底检查所有可能的组合(提示——这通常不是一个好主意，因为它将不能很好地扩展，正如我们将在后面看到的…)或者它是否会使用一些其他类型的捷径(例如，启发式方法)来探索所有可能组合中的一部分，但仍然会提出一个足够好的解决方案(如果是这样， 假设可能有不止一个桌子座位安排满足约束条件，那么算法如何知道它找到的解决方案是否是最佳的呢？ )</p><p id="c1af" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">3.还有一个<em class="nc">隐含的第三步</em>，这是一个<strong class="jg hj"> <em class="nc">【开箱即用】</em> </strong>步骤，我们尝试<strong class="jg hj">通过只对问题的一个“子集”建模来降低计算复杂性。</strong></p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/f926432c81aaf4a98429d36c099b5c72.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*TbjT5BPX_hjn18MsS9XJlA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源图片:<a class="ae kq" href="https://www.istockphoto.com/photos/think-outside-the-box" rel="noopener ugc nofollow" target="_blank"> IStockPhoto </a></figcaption></figure><p id="5515" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">例如，如果你已经知道其中一个表格<strong class="jg hj">必须</strong>由新娘/新郎和他们的直系亲属填写——将他们从等式中移除有助于(稍微)缩减潜在的搜索空间和需要考虑的约束条件等。</p><p id="9c27" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">为了让你知道到底有多少，如果我们举一个例子，一个96人的宾客名单(<em class="nc">根据新加坡</em> <a class="ae kq" href="https://www.gov.sg/article/how-to-keep-safe-during-weddings-and-solemnisations" rel="noopener ugc nofollow" target="_blank"> <em class="nc">当前的COVID safe指南</em> </a> <em class="nc">对于婚礼派对</em>)保持在100人的上限内，12张桌子每张8人——这导致1.12146933999503206 e+86(！！！)不同的可能组合。(即使我们忽略个别客人的座位，也是如此)</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es nf"><img src="../Images/eb357088fd443ec632c75faf9cee5ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*8Lrkwrgk4zrtzGCCOm3rhQ.png"/></div></figure><p id="98e5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">仅删除8人组(即88人组和11张8人组的桌子)使其数字略小，为1.0148966011615896e+76(即比以前减少1e10倍)</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es ng"><img src="../Images/2ae4c9f8615096db67a96c3cfee9327e.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*lZlmlvcozEYebKfs1TUFzw.png"/></div></figure><p id="aad6" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">一个相关的想法是，在<strong class="jg hj"> <em class="nc">你如何“开始”搜索过程</em> </strong>要巧妙。以下所有技术都是从某个初始起始点开始执行搜索。通常，如果你不知道任何更好的，这将是一个完全随机的安排。然而，有时解决问题的一个简化版本(例如，可能在宽松的约束下运行问题，并看看它吐出什么)并以此为起点可能实际上使算法“更接近”真正的全局最优点。(<a class="ae kq" href="https://or.stackexchange.com/questions/1278/how-does-a-warm-start-work-in-lp-mip" rel="noopener ugc nofollow" target="_blank"> <strong class="jg hj">暖启动</strong> </a>)</p><h1 id="8f48" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">2.方法1:用Excel进行简单的强力搜索</h1><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es nd"><img src="../Images/4303413ed543df072a2fbbf2b853a5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*83EBhtXFWAdDzXJHST08XQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:<a class="ae kq" href="https://bruteforcestrength.com/tag/squat-training/" rel="noopener ugc nofollow" target="_blank">BruteForceStrength.com</a></figcaption></figure><p id="3490" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这个相对简单的(*) Excel电子表格允许用户输入客人名单、桌子大小和最多3对必须坐在一起或分开坐的人的名单。</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nh"><img src="../Images/42fe8a2f6e2931fca3a8317d74fe7765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMuuoc7lKp8UUsh20Vu4iA.png"/></div></div></figure><p id="b5af" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">(如果你想知道——客人的名字是使用<a class="ae kq" href="https://www.fakenamegenerator.com/" rel="noopener ugc nofollow" target="_blank">https://www.fakenamegenerator.com</a>生成的)</p><p id="d972" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><em class="nc"> (*)我说这很简单，但它涉及到一些Excel宏(不要评价我，VBA有时会使用它)来生成随机数和其他事情，如添加占位符座位，以确保所有的桌子都坐满了(即，一个92人的客人名单，选择的桌子大小为8人，将需要12张桌子，即，将有4个空座位)</em></p><p id="5e49" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 2.1定义“成本”功能</strong></p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ni"><img src="../Images/a7a0c25d79b846315dcb7fdd046e3ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gh5fd89ppbwrJyYq8NDujQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">电子表格工具识别出2个违规(参考黄色和蓝色表示应该在一起但没有在一起的人)</figcaption></figure><p id="223d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">通过数据透视表和查找公式的组合，电子表格通过将每张桌子上的每个客人与他们的其他共桌客人相对于所需的在一起/分开条件进行比较来评估任何给定的配置。然后，电子表格计算出“违规”的次数(例如，应该呆在一起的一对被分配到不同的桌子，或者相反，应该分开的人被分配到不同的桌子)。理想的目标是零违规。</p><p id="2716" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 2.2开发搜索算法</strong></p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nj"><img src="../Images/2199c50ae1b5a8330c65637ec185dd85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*aWw-yR0DQsKhbSceusU5dg.gif"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">电子表格工具在32人桌和8人桌的各种解决方案选项中循环，寻找解决方案</figcaption></figure><p id="f928" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">电子表格生成然后使用宏随机生成表分配，并通过多次迭代循环，直到它达到预定义的最大迭代次数，或者它偶然发现满足所有约束的座位安排。</p><p id="2712" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这本质上是一种蛮力方法，因为不涉及真正的技术，纯粹依赖于循环通过足够多的组合，并希望足够“幸运”找到一个赢家(可能不止一个！).如您所料，当条件数量增加时，这种方法的伸缩性很差。</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es nk"><img src="../Images/2aa7c380e8f86546ddb07a0b486fcb1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIIp5KZJ8rk_ztt_19jnGQ.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">啊哦。模拟结果为96人，每桌8人</figcaption></figure><p id="c196" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">然而，我们知道，当数量增加时，该工具可能无法找到解决方案，有一种手动调整模式，允许用户单步执行单个迭代，然后对座位分配进行更改。</p><p id="718b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">在Github链接中，我还包含了相同“逻辑”的Python笔记本实现，只是为了比较Excel和Python之间的计算速度差异。好消息是因为Python使用了大量的numpy计算——它比Excel VBA快了大约20倍。</p><p id="776c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这段代码也可以作为任何想将它应用到本文后面讨论的任何其他技术的人的起始代码；)</p><p id="9822" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 2.3强力方法的缺点</strong></p><ul class=""><li id="1aa9" class="mi mj hi jg b jh ji jl jm jp nl jt nm jx nn ip mp mq mr ms bi translated">当你扩大规模时，这种方法就失败了。如果你只有几对牌和足够多的牌桌，那么“分开”的条件很容易偶然满足，但是随着牌桌数量的增加,“在一起”就变得非常困难，因为我们真的是依靠偶然发现一个解决方案</li><li id="1863" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated">与强力方法关系不大，但问题的框架是约束公式使得难以识别不一致的约束，例如，当A &amp; B必须在一起时，B &amp; C必须分开，但A &amp; C必须仍然在一起(这是不可能的，因为如果A &amp; C坐在一起，那么B &amp; C最终也会坐在同一张桌子上)</li><li id="afea" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated">关于问题表述的同一点——在一起/分开的座位限制可能过于严格，因为它们只是“开/关”,无法处理我们可能不介意放松限制以找到“足够好”的解决方案的情况，例如，我们可能希望绝对让一些人在一起(例如配偶),但对其他人群不那么大惊小怪(例如，高中朋友应该坐在同一张桌子上，但如果做不到这一点——分开的桌子也可以)</li></ul><h1 id="c2f1" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">3.方法2:用Python模拟退火</h1><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es no"><img src="../Images/de786dc7f8a5352e1af479cc348d8847.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*5nfWFoGt94zjtx6i_sE4Tg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:【SciencePhoto.com T2】股票图片</figcaption></figure><p id="ff54" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">以下内容主要基于邱临安的这篇文章。我添加了一些我自己的代码</p><p id="fdfd" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">1.提供生成“虚拟”测试数据的选项，或者允许用户从早期的Excel工具中导入客人列表/条件</p><p id="fc26" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">2.检查座位约束的逻辑一致性</p><p id="3aed" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">3.以更加用户友好的方式查看结果。</p><div class="ks kt ez fb ku kv"><a href="http://linanqiu.github.io/2018/03/05/Wedding-Seat-Optimization/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">婚礼座位优化</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">或者我回新加坡参加一个朋友的婚礼时会做什么(祝贺Crystalbel和Kenneth！)并找到…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">linanqiu.github.io</p></div></div></div></a></div><p id="a26b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">如果你真的对它的工作原理感兴趣，请阅读上面的整篇文章，因为我不会在这里重复所有的细节。</p><p id="19a0" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 3.1定义“成本”功能</strong></p><p id="1a20" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这种改进的公式化问题的方法的关键区别在于，现在可以更好地细化“约束的强度”。不是只列出需要聚在一起(负数)或分开(正数)的游客对，而是给每个约束分配数值，其中-ve表示聚在一起，+ve表示分开，分数越大，影响越大。</p><p id="c59e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">使用与前面相同的92人桌、每桌8人桌场景的示例，将数据导入Jupyter笔记本。</p><pre class="kc kd ke kf fd np nq nr ns aw nt bi"><span id="aaf9" class="nu ll hi nq b fi nv nw l nx ny">import pandas as pd<br/>import numpy as np</span><span id="186e" class="nu ll hi nq b fi nz nw l nx ny">InputFileName="Example_Guests96pax_TableSize8pax.xls"</span><span id="7255" class="nu ll hi nq b fi nz nw l nx ny">table_size = pd.read_excel(InputFileName, 'TableSize').columns[1]</span><span id="84c8" class="nu ll hi nq b fi nz nw l nx ny">GuestListRaw = pd.read_excel(InputFileName, 'GuestList')</span><span id="f758" class="nu ll hi nq b fi nz nw l nx ny">guest_list=GuestListRaw["Guest"].values.tolist()</span><span id="aafe" class="nu ll hi nq b fi nz nw l nx ny">RelMatrixRaw=GuestListRaw.dropna(thresh=2)</span><span id="e240" class="nu ll hi nq b fi nz nw l nx ny">RelMatrixRaw<br/>relationships_edges={}<br/>Together1=RelMatrixRaw[["Guest","Together1"]].dropna(thresh=2)<br/>Together2=RelMatrixRaw[["Guest","Together2"]].dropna(thresh=2)<br/>Together3=RelMatrixRaw[["Guest","Together3"]].dropna(thresh=2)<br/>Together1.columns=["Guest","Together"]<br/>Together2.columns=["Guest","Together"]<br/>Together3.columns=["Guest","Together"]<br/>Together=pd.concat([Together1,Together2,Together3])<br/>Apart1=RelMatrixRaw[["Guest","Apart1"]].dropna(thresh=2)<br/>Apart2=RelMatrixRaw[["Guest","Apart2"]].dropna(thresh=2)<br/>Apart3=RelMatrixRaw[["Guest","Apart3"]].dropna(thresh=2)<br/>Apart1.columns=["Guest","Apart"]<br/>Apart2.columns=["Guest","Apart"]<br/>Apart3.columns=["Guest","Apart"]<br/>Apart=pd.concat([Apart1,Apart2,Apart3])<br/>for element in list(zip(Together["Guest"], Together["Together"])):<br/>        relationships_edges.update({element:-50})<br/>for element in list(zip(Apart["Guest"], Apart["Apart"])):<br/>        relationships_edges.update({element:50})</span></pre><p id="1cbd" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">接下来，关系(这是一个包含元组对的字典)被一个叫做Networkx的漂亮的库转换，然后总结成一个矩阵，如下所示:</p><pre class="kc kd ke kf fd np nq nr ns aw nt bi"><span id="92f9" class="nu ll hi nq b fi nv nw l nx ny">import networkx as nx</span><span id="1a72" class="nu ll hi nq b fi nz nw l nx ny">#Generate Relationship Matrix</span><span id="b940" class="nu ll hi nq b fi nz nw l nx ny">temp_graph = nx.Graph()<br/>for k, v in relationships_edges.items():<br/>    temp_graph.add_edge(k[0], k[1], weight=v)<br/>relationships_mat_unnormed = nx.to_numpy_matrix(temp_graph.to_undirected(), nodelist=guest_list)<br/>relationships_mat = relationships_mat_unnormed / 100</span><span id="f784" class="nu ll hi nq b fi nz nw l nx ny"># View Relationship Matrix<br/>RelationshipMatrix=pd.DataFrame(relationships_mat)<br/>RelationshipMatrix.index=guest_list<br/>RelationshipMatrix.columns=guest_list<br/>RelationshipMatrix = RelationshipMatrix[(RelationshipMatrix.T != 0).any()]<br/>RelationshipMatrix = RelationshipMatrix.loc[:, (RelationshipMatrix != 0).any(axis=0)]<br/>RelationshipMatrix</span></pre><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es oa"><img src="../Images/8e8f2c3b3cf8d56da9ee23feda79cfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xpi1f5E__gMiyi_YbqDN-Q.png"/></div></div></figure><p id="cf64" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">由于矩阵是对称的，这使得一下子看到所有的关系更加容易。</p><p id="0064" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这种重新表述的真正好处是，给定一些有用的矩阵属性，而不仅仅是违反次数的X的分数——可以获取所产生的座位安排矩阵*关系矩阵的<a class="ae kq" href="https://en.wikipedia.org/wiki/Trace_(linear_algebra)" rel="noopener ugc nofollow" target="_blank">轨迹</a>(有点——阅读Linan Qiu 的<a class="ae kq" href="http://linanqiu.github.io/2018/03/05/Wedding-Seat-Optimization" rel="noopener ugc nofollow" target="_blank">完整文章进行数学计算)并返回反映座位安排有多“好”的<strong class="jg hj">单值</strong>(数字越低越好)</a></p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ob"><img src="../Images/3d45e8d6f40e581bf8e95ecc37983c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUsedQhS6VT42WX3L9H4ug.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">座位安排的“成本函数”评估，算法将使用该评估来判断“良好度”并将其最小化(越低=越好)</figcaption></figure><p id="5f73" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">此外，矩阵视图中的关系允许用户更好地识别不一致</p><p id="cebc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">用一些“非法”值修改早期导入的输入，其中(A，B)加在一起是-50，但(B，A)加在一起是-75(如鲍进先生和夫人的情况),以及不可能的循环逻辑，其中(A，B)加在一起是-50，加在一起(B，C)是-50，但分开(B，C)是+50(如Morrison先生、Yasser先生和Olsen夫人的情况),使用代码如下…</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es oc"><img src="../Images/e8a1f1ece1353a30f24f45353e352598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ye5A1GaFYChiokgCEzqp8Q.png"/></div></div></figure><pre class="kc kd ke kf fd np nq nr ns aw nt bi"><span id="2b4c" class="nu ll hi nq b fi nv nw l nx ny">#CHECKS FOR INCONSISTENCIES BETWEEN RELATIONSHIPS</span><span id="1968" class="nu ll hi nq b fi nz nw l nx ny">pairs=[]<br/>rel_values=[]<br/>for pair, rel_value in relationships_edges.items():<br/>    pairs.append(pair)<br/>    rel_values.append(rel_value)</span><span id="0246" class="nu ll hi nq b fi nz nw l nx ny">pairs</span><span id="0508" class="nu ll hi nq b fi nz nw l nx ny">print("Checking For Pair Inconsistencies")<br/>print(" ")</span><span id="fd63" class="nu ll hi nq b fi nz nw l nx ny">sorted(pairs[0])==sorted(pairs[0])<br/>rel_values[0]!=rel_values[0]</span><span id="9254" class="nu ll hi nq b fi nz nw l nx ny">indicesWithIssues=[]</span><span id="e56b" class="nu ll hi nq b fi nz nw l nx ny">for i in range(0,len(pairs)):<br/>    for j in range(0,len(pairs)):<br/>        if sorted(pairs[i])==sorted(pairs[j]) and rel_values[i]!=rel_values[j]:<br/>            if i not in indicesWithIssues and j not in indicesWithIssues:<br/>                print("Inconsistency Detected Between:")<br/>                print(pairs[i],":",rel_values[i])<br/>                print(pairs[j],":",rel_values[j])<br/>                print(" ")<br/>                indicesWithIssues.append(i)<br/>                indicesWithIssues.append(j)            <br/>        else:<br/>            pass</span><span id="c687" class="nu ll hi nq b fi nz nw l nx ny">print(" ")<br/>print("Checking For Triad Inconsistencies")<br/>print(" ")</span><span id="0583" class="nu ll hi nq b fi nz nw l nx ny">all_cliques= nx.enumerate_all_cliques(temp_graph)<br/>triad_cliques=[x for x in all_cliques if len(x)==3 ]<br/>checkSignForTriad=[]<br/>for triad in triad_cliques:<br/>    print("Identified A Triad Consisting Of :",triad)<br/>    for i in range(0,len(pairs)):<br/>        if sorted(triad[1:])==sorted(pairs[i]) or sorted(triad[:2])==sorted(pairs[i]) or sorted([triad[0],triad[2]])==sorted(pairs[i]):<br/>            print(pairs[i],":",rel_values[i])<br/>            checkSignForTriad.append(rel_values[i])<br/>    if (checkSignForTriad[0]&lt;0 and checkSignForTriad[1]&lt;0 and checkSignForTriad[2]&lt;0) or (checkSignForTriad[0]&gt;=0 and checkSignForTriad[1]&gt;=0 and checkSignForTriad[2]&gt;=0):<br/>        print("Triad OK!")<br/>    else:<br/>        print("Triad Inconsistent ! Please Re-Check As All Triangles Should Be ALL Together or ALL Apart")<br/>        indicesWithIssues.append(i)<br/>    checkSignForTriad=[]<br/>    print(" ")</span><span id="5f6e" class="nu ll hi nq b fi nz nw l nx ny">if indicesWithIssues!=[]:<br/>    print("Warning ! If Not Corrected, Errors May Arise")<br/>else:<br/>    print("OK! No Inconsistencies Found")</span></pre><p id="dd4c" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">运行上述“一致性检查”脚本会产生以下结果:</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es od"><img src="../Images/ebb6fbfa10ebab39bb8d43a7e8a6b8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nl86lF2KJPghnR-m9xxUtg.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">代码自动检测不一致</figcaption></figure><p id="9abe" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">现在我们已经“修复”了非法/不一致的约束，我们准备好解决问题了。</p><p id="15a0" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 3.2开发(更好的)搜索算法:模拟退火</strong></p><p id="66dc" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">模拟退火是一种“<em class="nc">概率元启发式技术，用于在大搜索空间中逼近给定函数的全局最优值</em></p><div class="ks kt ez fb ku kv"><a href="https://machinelearningmastery.com/simulated-annealing-from-scratch-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">Python中从头开始的模拟退火-机器学习掌握</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">模拟退火是一种随机全局搜索优化算法。这意味着它利用随机性作为…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">machinelearningmastery.com</p></div></div><div class="le l"><div class="oe l lg lh li le lj kk kv"/></div></div></a></div><p id="203b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">在冶金学中，退火是将金属加热到高温，然后慢慢冷却的过程。这种缓慢的逐渐冷却过程是至关重要的，因为如果冷却太快，当金属变热时，原子会突然停止在它们所在的位置，导致随机排列和低质量的结果。逐渐冷却的过程使原子排列成“最佳”方向，使金属更具延展性和强度。</p><p id="1521" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">模拟退火并不是在所有可能的组合中随机地寻找出路，而是使用了一种更细致的方法，如下所示(大量摘自邱林安的文章):-</p><ol class=""><li id="6a4d" class="mi mj hi jg b jh ji jl jm jp nl jt nm jx nn ip of mq mr ms bi translated"><em class="nc">首先，生成一个随机解</em></li><li id="3dce" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"><em class="nc">使用你定义的成本函数计算它的成本</em></li><li id="cffa" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"><em class="nc">生成随机邻近解</em></li><li id="0949" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"><em class="nc">计算新解决方案的成本</em></li><li id="41d9" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"><em class="nc">对比一下:</em></li></ol><ul class=""><li id="20f2" class="mi mj hi jg b jh ji jl jm jp nl jt nm jx nn ip mp mq mr ms bi translated"><em class="nc">如果</em><code class="du og oh oi nq b"><em class="nc">c_new</em></code><em class="nc">&lt;</em><code class="du og oh oi nq b"><em class="nc">c_old</em></code><em class="nc">:移动到新的解决方案</em></li><li id="0fb4" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated"><em class="nc">如果</em><code class="du og oh oi nq b"><em class="nc">c_new</em></code><em class="nc">&gt;</em><code class="du og oh oi nq b"><em class="nc">c_old</em></code><em class="nc">:也许会挪到新的方案</em></li></ul><p id="8448" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">重复上面的步骤3-5，直到找到一个可接受的解决方案或者达到最大迭代次数。</p><p id="de30" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">核心思想是当前迭代的温度——基于预定的温度降低尺度(例如，简单的线性降低或更复杂的几何降低)和当前温度——算法倾向于在早期迭代中更“宽容”坏解(即，允许它“跳出”局部最小陷阱并到达“真正的”全局最优)</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es oj"><img src="../Images/903bdeffea89c74340dadbfc682cfaa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zpaGNuhCTRUz8So4.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源:<a class="ae kq" href="https://www.researchgate.net/figure/Simulated-Annealing-optimization-of-a-one-dimensional-objective-function_fig1_308786233" rel="noopener ugc nofollow" target="_blank">人工网络中的优化技术综述(Ghasemalizadeh等人)，2016 </a></figcaption></figure><p id="2766" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">就性能而言，当我们使用Excel电子表格工具(甚至是Python对Excel电子表格工具的“模仿”,迭代次数更高，达到10，000次)运行时，它所能达到的最好成绩是4次违规(目标为0)</p><p id="cb71" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">基于模拟退火法，处理时间为1分钟以上</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ok"><img src="../Images/3bab32113ea83bce90279f00556ca20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IVl_Gn7-XLjvepPBo7DQw.png"/></div></div></figure><p id="135f" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">将结果导出回电子表格工具并交叉检查，仍有1个条件 未满足<strong class="jg hj"> <em class="nc">。</em></strong></p><p id="2f36" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">然而，通过“放松”对精确解决方案的要求，我们已经设法达成了一个解决方案，它仍然比随机尝试不同桌子排列的强力方法好得多…</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es ol"><img src="../Images/5a3da664560a67ae0a8d6cb764878d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MRvLZFuvrlVIZlU_iavxfw.png"/></div></div></figure><p id="a336" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><strong class="jg hj"> 3.3模拟退火方法的缺点</strong></p><ul class=""><li id="7755" class="mi mj hi jg b jh ji jl jm jp nl jt nm jx nn ip mp mq mr ms bi translated">虽然它比随机搜索快得多，但当客人/条件的数量增加时，它仍然需要时间运行。</li><li id="e343" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated">生成的解决方案可能无法保证完全满足所有座位约束(假设它们仍然是“非此即彼”而不仅仅是偏好)</li><li id="a3c4" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated">模拟退火更复杂，需要更好地理解算法的实际机制，以<strong class="jg hj">调整设置</strong>，例如，初始温度设置什么，温度冷却时间表使用什么。</li><li id="41e0" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip mp mq mr ms bi translated">虽然它有更好的机会找到“真正的”全局最优解，但算法<strong class="jg hj">不能确定它找到的解是真正的最优解还是仅仅是局部最优解… </strong></li></ul><h1 id="8d05" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated"><strong class="ak"> 4。其他可能的解决方法</strong></h1><p id="1f87" class="pw-post-body-paragraph je jf hi jg b jh mk jj jk jl ml jn jo jp my jr js jt mz jv jw jx na jz ka ip hb bi translated">我们只讨论了上面的两种方法，但是还有许多其他的方法来构建问题(根据成本函数)和不同的解决方案搜索过程。下面是一些例子，其中前两个是强力随机行走和模拟退火方法的近亲，还有一些更远的亲戚。</p><h2 id="9a65" class="nu ll hi bd lm om on oo lq op oq or lu jp os ot ly jt ou ov mc jx ow ox mg oy bi translated">4.1 CNF +步行卫星</h2><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es oz"><img src="../Images/6f34aebbc66b4ed423306936a23efbd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*u8kjpZvdI1usaFwJ.gif"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:<a class="ae kq" href="https://www.cs.rochester.edu/u/kautz/walksat/" rel="noopener ugc nofollow" target="_blank"> WalkSAT主页</a></figcaption></figure><p id="397a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">在下面的例子中，作者用Python代码将所有约束翻译成CNF的合取范式，这是和或与或的乘积。</p><div class="ks kt ez fb ku kv"><a href="https://github.com/RishabhTyagiHub/Constraint-Satisfaction-Problem---Wedding-Seating-Arrangement" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">RishabhTyagiHub/约束-满意-问题—-婚礼-座位-安排</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">你需要为n位客人设计一个婚礼座位安排。两对客人中有些是朋友，有些是…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div></div></a></div><p id="a9d8" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">如果这听起来令人困惑——不要担心，因为如果你遵循上面的Excel示例，你可能已经有了它的要点——基本上它是关于检查客人X是否满足与谁坐在一起/分开的所有标准。这通常会为每张桌子上检查的每对客人生成许多真/假，但CNF  中的<strong class="jg hj"> <em class="nc">关键思想是<strong class="jg hj"> <em class="nc">将前面所有检查的最终结果简化为一个真/假语句</em> </strong></em></strong></p><div class="ks kt ez fb ku kv"><a href="https://en.wikipedia.org/wiki/WalkSAT" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">WalkSAT —维基百科</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">在计算机科学中，GSAT和WalkSAT是解决布尔可满足性问题的局部搜索算法。两者都…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">en.wikipedia.org</p></div></div></div></a></div><p id="b46a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">然而，由于数学公式更加形式化，因此可以使用称为walks at(SAT =可满足性)的局部搜索算法来求解。</p><p id="290e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">WalkSAT有点像随机漫步，但是在每一步的第一阶段，被当前赋值违反的约束将被随机选择</p><p id="8415" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">然后，该算法随机尝试“翻转”出现在先前选择的约束<strong class="jg hj">中的一个变量，该约束导致最少的先前满足的子句变得不满足，随机选择一个变量</strong></p><p id="84b4" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">如果长时间无法找到解决方案(即探索解决方案空间的死胡同部分)，该算法将重新开始新的随机分配。</p><p id="15cb" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">因此，作为一个粗略的类比，这有点像一个醉汉的散步，只是他有一只导盲犬，当他偏离轨道时，它知道回家的路，并以正确的方式“纠正”他。</p><h1 id="1ef0" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">4.2禁忌搜索</h1><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es pa"><img src="../Images/937f6bcfc8130ba8073608b34eae253d.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*veo7vjBByh0rpQISuaYiAw.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源图片:【BoardgameGeek.com T2】</figcaption></figure><p id="9ba5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">下面的文章是这个网站使用的方法的详细记录【WeddingSeatPlanner.com T4】</p><div class="ks kt ez fb ku kv"><a href="http://weddingseatplanner.com/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">婚礼座位策划</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">请注意，婚礼座位计划工具需要Adobe Flash player才能运行。如果您在以下情况下看不到该工具…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">weddingseatplanner.com</p></div></div><div class="le l"><div class="pb l lg lh li le lj kk kv"/></div></div></a></div><figure class="kc kd ke kf fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es pc"><img src="../Images/a4566e535a8e9285600f07341016258b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dY8XT45JbpWCz3cBfmEm6Q.png"/></div></div><figcaption class="km kn et er es ko kp bd b be z dx translated">来源:<a class="ae kq" href="https://pure.southwales.ac.uk/files/274133/RLewis.pdf" rel="noopener ugc nofollow" target="_blank">创建座位计划:实际应用R.Lewis &amp; F.Caroll 2016 </a></figcaption></figure><p id="0a59" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">禁忌搜索与模拟退火非常相似，但它加入了一种“记忆”功能，可以避免再次遇到不好的解决方案。</p><p id="fb41" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">从<a class="ae kq" href="https://en.wikipedia.org/wiki/Tabu_search" rel="noopener ugc nofollow" target="_blank">维基百科页面</a> : <em class="nc">本地(邻居)搜索获取问题的潜在解决方案，并检查其直接邻居(即，除了非常少的小细节之外相似的解决方案)，希望找到改进的解决方案。局部搜索方法有陷入次优区域或停滞不前的趋势，在那里许多解决方案同样适用。</em></p><p id="ba90" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><em class="nc">禁忌搜索通过放宽基本规则来提高局部搜索的性能。首先，在每一步，如果没有改进的走法可用，则可以接受恶化的走法(例如当搜索停留在严格的</em> <a class="ae kq" href="https://en.wikipedia.org/wiki/Local_minimum" rel="noopener ugc nofollow" target="_blank"> <em class="nc">局部最小值</em> </a> <em class="nc">)。此外，引入“禁忌”是为了阻止搜索返回到以前访问过的解决方案。</em></p><p id="1de1" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">非常可悲的是，尽管该网站提供免费服务，但界面仅通过Flash代码，自2020年12月以来，任何主要浏览器都不再支持Flash代码。</p><h2 id="8d82" class="nu ll hi bd lm om on oo lq op oq or lu jp os ot ly jt ou ov mc jx ow ox mg oy bi translated"><strong class="ak"> 4.3混合整数线性规划</strong></h2><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es pd"><img src="../Images/3ac7750fced436c9433b702fb5a6c0b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*0gy8gt3Su5r8ko9RMT09vw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:<a class="ae kq" href="https://www.vectorstock.com/royalty-free-vectors/salad-cartoon-vectors" rel="noopener ugc nofollow" target="_blank">VectorStock.com</a>股票图片</figcaption></figure><p id="6623" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">该问题的另一种表述是作为一个多重整数线性规划。关键是<em class="nc">使用一个</em> <strong class="jg hj"> <em class="nc">二进制决策变量</em> </strong> <em class="nc">来表示一个客人是否被分配到某一桌</em>，<strong class="jg hj">c<em class="nc">onstrain</em></strong><em class="nc">它使得每个客人都被</em> <strong class="jg hj"> <em class="nc">只分配到一个单桌</em> </strong>和一个最大桌位</p><p id="e337" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">一个简单的案例实现可以在<a class="ae kq" href="https://pypi.org/project/PuLP/" rel="noopener ugc nofollow" target="_blank"> PuLP </a>的帮助文档中找到(这是一个Python的线性编程库，实际上我在以前的一篇文章中提到过)</p><div class="ks kt ez fb ku kv"><a href="https://coin-or.github.io/pulp/CaseStudies/a_set_partitioning_problem.html" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">集合划分问题—纸浆2.4文档</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">集合划分问题决定了如何将一个集合中的项目划分成更小的子集。所有项目…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">coin-or.github.io</p></div></div></div></a></div><p id="a027" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这里还有上面的<a class="ae kq" href="https://cupdf.com/document/operations-research-and-optimization-in-python-using-pulp.html" rel="noopener ugc nofollow" target="_blank">演示版</a>。不过，公平的警告是，这只是一个<strong class="jg hj"> <em class="nc">玩具示例</em> </strong>，是<strong class="jg hj"> <em class="nc">而不是</em> </strong>针对它如何搜索最佳配置的过程进行了优化，并且只使用默认的<a class="ae kq" href="https://github.com/coin-or/Cbc" rel="noopener ugc nofollow" target="_blank"> CBC解算器</a>。如果您查看代码，这一行是使它组合失败的一行:</p><pre class="kc kd ke kf fd np nq nr ns aw nt bi"><span id="c095" class="nu ll hi nq b fi nv nw l nx ny"><em class="nc">#create list of all possible tables</em><br/>possible_tables = [tuple(c) <strong class="nq hj">for</strong> c <strong class="nq hj">in</strong> pulp.allcombinations(guests, <br/>                                        max_table_size)]</span></pre><p id="c935" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">当我在96人、8人/桌的场景下运行这个程序时——不出所料(考虑到它可能试图生成一万亿个组合并将其存储在内存中)——它挂起了我的笔记本电脑:/</p><p id="4899" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">在下面这篇SAS文章中可以找到使用相同的一般方法的更复杂的方法。</p><div class="ks kt ez fb ku kv"><a href="https://blogs.sas.com/content/operations/2014/11/10/do-you-have-an-uncle-louie-optimal-wedding-seat-assignments/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">你有路易叔叔吗？最佳婚礼座位分配</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">你有路易叔叔吗？是的——我们都是！你知道我的意思——这个人:当我和我妻子打算…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">blogs.sas.com</p></div></div><div class="le l"><div class="pe l lg lh li le lj kk kv"/></div></div></a></div><p id="97d9" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">这个例子以类似的方式“计算”了不愉快水平，但是使用了SAS的专有解算器之一，称为<a class="ae kq" href="http://support.sas.com/documentation/cdl/en/ormpug/67517/HTML/default/viewer.htm#ormpug_decomp_details06.htm" rel="noopener ugc nofollow" target="_blank"> DECOMP(它是定制设计的，用于处理在某些约束条件下将集合划分为更小的子集的情况</a>，以更好地搜索解决方案空间，找到<strong class="jg hj">最佳</strong>解决方案。</p><p id="f5cf" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">最后一个例子是下一篇论文，作者是普林斯顿的一对夫妻，他们实际上在自己的婚礼上使用了它(我认为它超级怪异，但令人难以置信的甜蜜)</p><div class="ks kt ez fb ku kv"><a href="https://www.improbable.com/2012/02/12/finding-an-optimal-seating-chart-for-a-wedding/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">为婚礼寻找最佳座位表</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">编者按:作者在婚礼前很久就提交了这篇文章。不知何故，我们设法没有看到它，直到…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">www.improbable.com</p></div></div><div class="le l"><div class="pf l lg lh li le lj kk kv"/></div></div></a></div><p id="d791" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">与SAS/OR版本形成对比——该解决方案通过<a class="ae kq" href="https://www.gams.com/34/docs/S_CPLEX.html" rel="noopener ugc nofollow" target="_blank"> GAMS/CPLEX </a>(另一个优化求解程序)实施，其公式略有不同，试图最大限度地增加每位客人在餐桌上认识的人数，即这次没有“讨厌/保持分开”的座位限制；)</p><p id="2790" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">不考虑具体的实现细节，MILP方法家族的好处在于，由于求解方法通常使用“回溯搜索”策略(例如，<a class="ae kq" href="https://en.wikipedia.org/wiki/Branch_and_bound" rel="noopener ugc nofollow" target="_blank">分支&amp;界限方法</a>)，假设你不着急*，这种方法最终保证找到的<a class="ae kq" href="https://math.stackexchange.com/questions/2915145/does-branch-and-bound-always-achieve-a-globally-optimal-solution" rel="noopener ugc nofollow" target="_blank">解将是全局最优解</a>，或者将证明没有解。</p><p id="d351" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">* <em class="nc">如果你读了普林斯顿夫妇的文章，他们的婚宴有107人，10张桌子，花了36个小时来梳理2.69e+111个可能的组合——然而这篇文章是在2012年写的，所以今天的硬件改进可能会有更好的性能</em></p><h2 id="462f" class="nu ll hi bd lm om on oo lq op oq or lu jp os ot ly jt ou ov mc jx ow ox mg oy bi translated"><strong class="ak"> 4.4遗传算法</strong></h2><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es no"><img src="../Images/9c12ebc2e31c40caabcb75d05caa1498.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*Cn5--MukV9E935U7iTC8tQ.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:<a class="ae kq" href="https://www.vectorstock.com/royalty-free-vector/genetics-concept-cartoon-icon-vector-7197466" rel="noopener ugc nofollow" target="_blank">VectorStock.com</a>股票图片</figcaption></figure><p id="4e01" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">与模拟退火不同，模拟退火只“跟踪”单个状态，并在每次迭代中决定是否“移动”到邻近的解决方案，<a class="ae kq" href="https://towardsdatascience.com/introduction-to-genetic-algorithms-including-example-code-e396e98d8bf3" rel="noopener" target="_blank">遗传算法</a>生成一群可能的解决方案，挑选最佳方案(基于成本分数)进行组合(交叉)，并应用一些随机变化(突变)</p><p id="117b" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">下面这个Github链接是一个用R写的解决婚礼座位问题的遗传算法方法的例子，用作者自己的话说:<em class="nc">它使用一个二进制染色体(每个客人要么是为给定的桌子选择的，要么不是)，一次选择一张桌子，从矩阵中删除这些客人，减少染色体的大小，然后选择下一张桌子。</em></p><div class="ks kt ez fb ku kv"><a href="https://github.com/meganstiles/Seating_Chart" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">Megan stiles/Seating _图表</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">这个代码使用遗传算法来优化婚宴座位表的基础上密切相关的…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div><div class="le l"><div class="pg l lg lh li le lj kk kv"/></div></div></a></div><p id="1583" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">如果你不介意支付一点，这另一家公司的餐桌计划提供了一个软件服务，生成座位安排解决方案，也使用遗传算法。</p><div class="ks kt ez fb ku kv"><a href="https://www.perfecttableplan.com/" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">餐桌计划软件-婚礼和活动的完美餐桌座位</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">完美的桌面计划-桌面计划软件。在您的…上为您的婚礼或活动设计并打印餐桌座位计划</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">www.perfecttableplan.com</p></div></div><div class="le l"><div class="ph l lg lh li le lj kk kv"/></div></div></a></div><p id="588a" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">基于一些在线搜索(<a class="ae kq" href="https://www.researchgate.net/post/Simulated_Annealing_vs_genetic_algorithm" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae kq" href="https://arxiv.org/pdf/1001.3920.pdf" rel="noopener ugc nofollow" target="_blank">这里</a>)看起来这是相当领域特定的，但是一般来说，如果问题有一个以上的最优解(这是经常发生的情况)，那么遗传算法会比模拟退火算法更快地找到更好的解。</p><h2 id="93cf" class="nu ll hi bd lm om on oo lq op oq or lu jp os ot ly jt ou ov mc jx ow ox mg oy bi translated">4.5 K均值聚类</h2><p id="1643" class="pw-post-body-paragraph je jf hi jg b jh mk jj jk jl ml jn jo jp my jr js jt mz jv jw jx na jz ka ip hb bi translated">(<em class="nc">编辑——在我已经发表了这篇文章的第一稿之后，我偶然发现了这一点，但还是决定把它包括进来，因为它对有趣的问题有一个完全不同的框架</em><strong class="jg hj"><em class="nc"/></strong><em class="nc"/></p><div class="ks kt ez fb ku kv"><a rel="noopener follow" target="_blank" href="/@brandonsegal/data-science-for-wedding-planning-d1e8e23c43fe"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">婚礼策划的数据科学</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">我如何使用KMeans和排名来帮助找出我的婚礼的一部分</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">medium.com</p></div></div><div class="le l"><div class="pi l lg lh li le lj kk kv"/></div></div></a></div><p id="47ba" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">与所有其他方法不同，本文作者并没有将这一问题描述为优化/集合划分类型的问题，而是采用了一种新颖的方法，他使用了<a class="ae kq" href="https://towardsdatascience.com/k-means-clustering-from-a-to-z-f6242a314e9a" rel="noopener" target="_blank"> K-Means算法</a>来识别应该坐在一起的客人集群。</p><p id="926e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">基本的想法是根据一些二元特征来描述每个客人(例如，作者使用了类似于“同一所学校y/n？家庭y/n？同样的俱乐部？等等)，然后<strong class="jg hj"> <em class="nc">使用K-Means算法，基于他们想要为</em> </strong>计划的桌数，将最相似的人聚类在一起。</p><h2 id="a633" class="nu ll hi bd lm om on oo lq op oq or lu jp os ot ly jt ou ov mc jx ow ox mg oy bi translated">4.6其他更复杂的公式——如果座位顺序很重要呢？！</h2><p id="138e" class="pw-post-body-paragraph je jf hi jg b jh mk jj jk jl ml jn jo jp my jr js jt mz jv jw jx na jz ka ip hb bi translated">最后一个例子……上面所有的解决方案都假设桌子内座位的“排序”是不相关的。一张A，B，C，D，E的桌子和A，C，B，E，D是一样的(如果你能想象他们坐成一圈的话)</p><p id="f728" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">我还没有找到一个例子，但我认为实际上有可能将问题重新表述为不仅要看哪些客人必须分开/坐在一起，还要结合一组“第二级”约束，即他们是否需要并排坐着。</p><p id="ab6d" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">数学可能需要利用第一类斯特灵数，这是我在研究这篇文章时偶然发现的一个有趣的概念。它基本上是一种计算围绕一个有序“圆”排列多个元素的方法，如下所示。</p><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es pj"><img src="../Images/e2b583b79060ce79e8ef148bae32935a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*_U--SKYo7pWYOXuL6NCSVw.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated"><a class="ae kq" href="https://mathworld.wolfram.com/StirlingNumberoftheFirstKind.html" rel="noopener ugc nofollow" target="_blank">资料来源:Wolfram Alpha </a></figcaption></figure><h1 id="8049" class="lk ll hi bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">5.结论</h1><figure class="kc kd ke kf fd jb er es paragraph-image"><div class="er es pk"><img src="../Images/7757431fc10d26067efbf640e8eca65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*CfCXFpeKm0YAH4_IOKopKA.png"/></div><figcaption class="km kn et er es ko kp bd b be z dx translated">图片来源:【KnowYourMeme.com】数学/糊涂女士Meme</figcaption></figure><p id="e048" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">总之——希望通过浏览所有这些不同的方法，我已经成功地证明了有许多不同的方法可以将问题“翻译”成算法优化方案**这取决于我们试图解决的问题。</p><p id="464e" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">我还希望我已经为您提供了一些工作代码(和一个供非编码人员使用的Excel方法)，您可以亲自使用它们来解决座位安排问题，如果您想更深入地研究这个主题并构建自己的定制解决方案，我还提供了一些入门资源。</p><p id="6db2" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">最后，我给你一个“跳出框框”的视角...我给一个朋友看了这篇文章的草稿，她的反应是— <em class="nc"> omg这太复杂了！把它设置成自助餐，让人们随意坐，这不是更简单的方法吗？不要低估了大多数人倾向于很好地避开他们不想和他们在一起的人，坚持和他们想亲近的人在一起… </em></p><p id="1209" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated">下次见！</p><p id="60d5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="4d44" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="2d50" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="f5bf" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="a1b5" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="f185" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi">.</p><p id="f6a0" class="pw-post-body-paragraph je jf hi jg b jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ip hb bi translated"><em class="nc"> **如果你喜欢这篇文章，你可以做一些额外的事情来获得额外的学分*wink*wink* : </em></p><ol class=""><li id="1d9b" class="mi mj hi jg b jh ji jl jm jp nl jt nm jx nn ip of mq mr ms bi translated"><em class="nc">上面的例子大多都是通过定义某种“快乐”分数，然后尝试优化所有表格的“总体”快乐。</em>因此，作为一项挑战，您可以尝试修改现有的 <a class="ae kq" href="#c2f1" rel="noopener ugc nofollow"> <strong class="jg hj"> <em class="nc">模拟退火示例</em> </strong> </a> <em class="nc">的代码，以使用替代优化目标来确保“幸福”在所有表格中更公平的分布(例如，可能通过基尼系数分数来估计？)</em></li><li id="16fe" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"> <a class="ae kq" href="#a633" rel="noopener ugc nofollow"> <strong class="jg hj"> <em class="nc">如果桌子周围的座位顺序也很重要呢？</em> </strong> </a> <em class="nc">场景:我在网上找不到任何东西，但如果你知道一个很好的例子，概述了概念方法或实现它的实际工作代码，请在评论中留下链接……</em></li><li id="67b0" class="mi mj hi jg b jh mt jl mu jp mv jt mw jx mx ip of mq mr ms bi translated"><em class="nc">对于那些走在事物前沿的硬核极客来说——你可以探索</em> <strong class="jg hj"> <em class="nc">量子解算器</em></strong><em class="nc">——我推荐尝试一下</em><a class="ae kq" href="https://qiskit.org/" rel="noopener ugc nofollow" target="_blank"><em class="nc">Qiskit</em></a><em class="nc">，IBM的SDK允许用户创建自己的量子算法，并在IBM的量子体验上的量子模拟器或原型量子设备上运行。Qiskit相对容易掌握，因为它运行在Python上。我在网上快速搜索了一下，找到了两个例子，一个是</em><a class="ae kq" href="https://qiskit.org/textbook/ch-applications/satisfiability-grover.html" rel="noopener ugc nofollow" target="_blank"><em class="nc">3 sat CNF</em></a><em class="nc">和</em> <a class="ae kq" href="https://qiskit.org/documentation/tutorials/optimization/7_examples_vehicle_routing.html" rel="noopener ugc nofollow" target="_blank"> <em class="nc"> MILP车辆路径问题</em> </a> <em class="nc">但是看起来</em> <strong class="jg hj"> <em class="nc">没有人专门为婚礼座位问题制定解决方案</em> </strong></li></ol><div class="ks kt ez fb ku kv"><a rel="noopener follow" target="_blank" href="/qiskit/towards-quantum-advantage-for-optimization-with-qiskit-9a564339ef26"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hj fi z dy la ea eb lb ed ef hh bi translated">Qiskit新优化模块的演练</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">一个新的Qiskit模块，以促进量子优化算法的研究，开发和基准测试的近期…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">medium.com</p></div></div><div class="le l"><div class="pl l lg lh li le lj kk kv"/></div></div></a></div></div></div>    
</body>
</html>