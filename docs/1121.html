<html>
<head>
<title>‘A Basket of Sorting Algorithms’ Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的一篮子排序算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-basket-of-sorting-algorithms-using-python-84a6c43f6aba?source=collection_archive---------12-----------------------#2021-02-15">https://medium.com/analytics-vidhya/a-basket-of-sorting-algorithms-using-python-84a6c43f6aba?source=collection_archive---------12-----------------------#2021-02-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/396ccaf18b1d8578bdaee96e829f9296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FxMUk7VY7kHQateI"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">由<a class="ae it" href="https://unsplash.com/@traxing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">苏拉娅·欧文</a>在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2424" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“排序”本质上是指“按升序排序”，除非另有说明。</p><blockquote class="js jt ju"><p id="1c9a" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">排序算法能够做多种不同寻常的事情，想象一下，一个人需要花多少时间来排序成千上万个名字的列表以制作电话簿，或者成千上万个食谱、档案、动物等的列表。</p></blockquote><p id="8fd8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们创建一个要排序的数字列表作为示例！</p><p id="5eab" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du jz ka kb kc b">nums</code>:数字列表，如<code class="du jz ka kb kc b">[4, 2, 6, 3, 4, 6, 2, 1]</code></p><h2 id="80e0" class="kd ke hh bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated"><strong class="ak"> 1。冒泡排序</strong></h2><p id="1175" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">之所以叫这个名字，是因为这里较小的元素<em class="jv">泡</em>到顶部，较大的元素<em class="jv">沉</em>到底部。</p><p id="cac8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">冒泡排序的核心操作是“比较”和“交换”。</p><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="3a76" class="kd ke hh kc b fi ll lm l ln lo">def bubble_sort(nums):<br/>    # Create a copy of the list, to avoid changing it<br/>    nums = list(nums)<br/>    <br/>    # 4. Repeat the process n-1 times<br/>    for _ in range(len(nums) - 1):<br/>        <br/>        # 1. Iterate over the array (except last element)<br/>        for i in range(len(nums) - 1):<br/>            <br/>            # 2. Compare the number with  <br/>            if nums[i] &gt; nums[i+1]:<br/>                <br/>                # 3. Swap the two elements<br/>                nums[i], nums[i+1] = nums[i+1], nums[i]<br/>    <br/>    # Return the sorted list<br/>    return nums</span></pre><h2 id="4fc8" class="kd ke hh bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">2.插入排序</h2><p id="8b20" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">这里我们保持数组的初始部分排序，并在正确的位置一个接一个地插入剩余的元素。</p><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="d66c" class="kd ke hh kc b fi ll lm l ln lo">def insertion_sort(nums):<br/>    nums = list(nums)<br/>    for i in range(len(nums)):<br/>        cur = nums.pop(i)<br/>        j = i-1<br/>        while j &gt;=0 and nums[j] &gt; cur:<br/>            j -= 1<br/>        nums.insert(j+1, cur)<br/>    return nums</span></pre><p id="57c6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了更有效地执行排序，应用了一种称为<strong class="iw hi">分而治之</strong>的策略，其一般步骤如下:</p><ol class=""><li id="a0a2" class="lp lq hh iw b ix iy jb jc jf lr jj ls jn lt jr lu lv lw lx bi translated">将输入分成大致相等的两部分。</li><li id="e0e2" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">分别递归求解这两个部分的问题。</li><li id="fd02" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">合并结果以解决原始输入的问题。</li><li id="a5df" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">包括小的或不可分割的输入的终止条件。</li></ol><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es md"><img src="../Images/6cd018903c37d6f585cbb0218a2cd1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*hqWFfXgDyVcUjgoOf4wx2Q.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">上述策略的可视化表示</figcaption></figure><h2 id="5657" class="kd ke hh bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">3.合并排序</h2><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="8f4f" class="kd ke hh kc b fi ll lm l ln lo">def <strong class="kc hi">merge_sort</strong>(nums):<br/>    <em class="jv"># Terminating condition (list of 0 or 1 elements)</em><br/>    if len(nums) &lt;= 1:<br/>        return nums<br/>    <br/>    <em class="jv"># Get the midpoint</em><br/>    mid = len(nums) // 2<br/>    <br/>    <em class="jv"># Split the list into two halves</em><br/>    left = nums[:mid]<br/>    right = nums[mid:]<br/>    <br/>    <em class="jv"># Solve the problem for each half recursively</em><br/>    left_sorted, right_sorted = merge_sort(left), merge_sort(right)<br/>    <br/>    <em class="jv"># Combine the results of the two halves</em><br/>    sorted_nums =  merge(left_sorted, right_sorted)<br/>    <br/>    return sorted_nums</span></pre><p id="0e66" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，如何合并两个排序后的数组呢？</p><p id="36bf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，我们可以重复比较每个数组中最少的两个元素，并将较小的元素复制到一个新的数组中。</p><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="ac7e" class="kd ke hh kc b fi ll lm l ln lo">def <strong class="kc hi">merge</strong>(nums1, nums2):    <br/>    <em class="jv"># List to store the results </em><br/>    merged = []<br/>    <br/>    <em class="jv"># Indices for iteration</em><br/>    i, j = 0, 0<br/>    <br/>    <em class="jv"># Loop over the two lists</em><br/>    while i &lt; len(nums1) and j &lt; len(nums2):        <br/>        <br/>        <em class="jv"># Include the smaller element in the result and move to next element</em><br/>        if nums1[i] &lt;= nums2[j]:<br/>            merged.append(nums1[i])<br/>            i += 1 <br/>        else:<br/>            merged.append(nums2[j])<br/>            j += 1<br/>    <br/>    <em class="jv"># Get the remaining parts</em><br/>    nums1_tail = nums1[i:]<br/>    nums2_tail = nums2[j:]<br/>    <br/>    <em class="jv"># Return the final merged array</em><br/>    return merged + nums1_tail + nums2_tail</span></pre><h2 id="d189" class="kd ke hh bd kf kg kh ki kj kk kl km kn jf ko kp kq jj kr ks kt jn ku kv kw kx bi translated">4.快速排序</h2><p id="7597" class="pw-post-body-paragraph iu iv hh iw b ix ky iz ja jb kz jd je jf la jh ji jj lb jl jm jn lc jp jq jr ha bi translated">这是另一种基于<strong class="iw hi">分治</strong>的排序算法，其工作原理如下:</p><ol class=""><li id="ca98" class="lp lq hh iw b ix iy jb jc jf lr jj ls jn lt jr lu lv lw lx bi translated">如果列表为空或者只有一个元素，则返回它。已经整理好了。</li><li id="89d2" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">从列表中选择一个随机元素。这个元件被称为<em class="jv">枢轴</em>。</li><li id="8710" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">对列表重新排序，使值小于或等于透视值的所有元素位于透视值之前，而值大于透视值的所有元素位于透视值之后。这个操作被称为<em class="jv">分区</em>。</li><li id="0ce7" class="lp lq hh iw b ix ly jb lz jf ma jj mb jn mc jr lu lv lw lx bi translated">pivot元素将数组分为两个部分，通过递归调用quicksort可以对这两个部分进行独立排序。</li></ol><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="962c" class="kd ke hh kc b fi ll lm l ln lo">def <strong class="kc hi">quicksort</strong>(nums, start=0, end=None):<br/>    <em class="jv"># print('quicksort', nums, start, end)</em><br/>    if end is None:<br/>        nums = list(nums)<br/>        end = len(nums) - 1<br/>    <br/>    if start &lt; end:<br/>        pivot = partition(nums, start, end)<br/>        quicksort(nums, start, pivot-1)<br/>        quicksort(nums, pivot+1, end)<br/><br/>    return nums</span></pre><p id="9048" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是partition的一个实现，它使用列表的最后一个元素作为支点:</p><pre class="ld le lf lg fd lh kc li lj aw lk bi"><span id="2a43" class="kd ke hh kc b fi ll lm l ln lo">def <strong class="kc hi">partition</strong>(nums, start=0, end=None):<br/>    <em class="jv"># print('partition', nums, start, end)</em><br/>    if end is None:<br/>        end = len(nums) - 1<br/>    <br/>    <em class="jv"># Initialize right and left pointers</em><br/>    l, r = start, end-1<br/>    <br/>    <em class="jv"># Iterate while they're apart</em><br/>    while r &gt; l:<br/>        <em class="jv"># print('  ', nums, l, r)</em><br/>        <em class="jv"># Increment left pointer if number is less or equal to pivot</em><br/>        if nums[l] &lt;= nums[end]:<br/>            l += 1<br/>        <br/>        <em class="jv"># Decrement right pointer if number is greater than pivot</em><br/>        elif nums[r] &gt; nums[end]:<br/>            r -= 1<br/>        <br/>        <em class="jv"># Two out-of-place elements found, swap them</em><br/>        else:<br/>            nums[l], nums[r] = nums[r], nums[l]<br/>    <em class="jv"># print('  ', nums, l, r)</em><br/>    <em class="jv"># Place the pivot between the two parts</em><br/>    if nums[l] &gt; nums[end]:<br/>        nums[l], nums[end] = nums[end], nums[l]<br/>        return l<br/>    else:<br/>        return end</span></pre><p id="9536" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里的关键观察是，在划分之后，pivot元素在排序后的数组中处于正确的位置，并且数组的两个部分可以就地独立排序。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="08a1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以上算法的效率总结→</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/192d479fc9144939a4e1177edb4f0812.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*qU4efRepTtf8nJiKiYtdjA.png"/></div></figure><p id="a40f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，排序算法是基于应用和该应用所需的效率来选择的。</p></div></div>    
</body>
</html>