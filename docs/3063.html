<html>
<head>
<title>Understand The DBSCAN Clustering Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解DBSCAN聚类算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understand-the-dbscan-clustering-algorithm-b064025a6b5?source=collection_archive---------4-----------------------#2021-06-01">https://medium.com/analytics-vidhya/understand-the-dbscan-clustering-algorithm-b064025a6b5?source=collection_archive---------4-----------------------#2021-06-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/8e086ec38327e2fbf07d90091bebb513.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/0*7JCHZmU1ABaE8w9Y.PNG"/></div></figure><p id="1aa5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我将解释DBSCAN算法。这是一种用于聚类的无监督学习算法。首先，我将解释该算法的每个概念细节，然后我将向您展示如何使用Sci-kit Learn编写DBSCAN算法。</p><p id="29ef" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">DBSCAN算法的全称是带噪声的应用程序的基于密度的空间聚类。嗯，从名字中我们需要特别注意三个词。它们是密度、聚类和噪声。从名字上看，很明显该算法使用密度来对数据点进行聚类，并且它与噪声有关。也许它能很好地识别噪音。我们过会儿会看见它。</p><h1 id="ff3f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">目录</h1><ol class=""><li id="dd81" class="kh ki hh in b io kj is kk iw kl ja km je kn ji ko kp kq kr bi translated">什么是密度？</li><li id="67b5" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">DBSCAN算法的重要参数</li><li id="50ed" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">数据点的分类</li><li id="2856" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">密度边和密度连接点</li><li id="16e7" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">DBSCAN算法中的步骤</li><li id="714e" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">如何确定ε和z？</li><li id="e707" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">噪声消除</li><li id="79ac" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji ko kp kq kr bi translated">Python的实际实现</li></ol><h1 id="5180" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">1.什么是密度？</h1><p id="1337" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">首先，我们来了解一下什么是密度。</p><p id="bc0d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">从物理学中我们知道，密度就是单位体积中的物质数量。我们可以很容易地将体积的概念扩展到更高的维度，甚至更低的维度。</p><p id="d5f3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，我们有这个区域。</p><p id="effc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们在这个区域有一些数据点。我们在同一区域的另一个区域有这么多数据点。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/1f658cd6804c3e5460e99f6877f9ab9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:530/format:webp/0*CprTB412fzQnBcVy.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated"><a class="ae lj" href="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.researchgate.net%2Fprofile%2FQing_Yu51%2Fpublication%2F343345471%2Ffigure%2Fdownload%2Ffig4%2FAS%3A919536819781634%401596246070710%2FSpatial-cluster-identified-by-Density-Based-Spatial-Clustering-of-Applications-with-Noise.jpg&amp;f=1&amp;nofb=1" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="f481" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以，从密度的概念来看，第一个区域的密度大于第二个区域。因为，第一个区域有更多的数据点，更多的物质。DBSCAN使用这种密度概念对数据集进行聚类。现在为了清楚地理解DBSCAN算法，我们需要知道一些重要的参数。</p><h1 id="f369" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">2.DBSCAN算法的重要参数</h1><p id="28ac" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">第一个是epsilon。</p><h1 id="af11" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">2.1ε</h1><p id="9c8f" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">这是对邻居的一种度量。</p><p id="25be" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">什么是邻居？</p><h1 id="269c" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">2.2邻里关系</h1><p id="bb47" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">假设，这是我们现在考虑的点，让我以这点为中心画一个圆，加上距离ε。</p><p id="27a4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">所以，我们说这个圆是这个点的邻域。所以，ε只是一个数字，它代表了围绕一个特定点的圆的半径，我们要考虑这个点的邻域。</p><p id="cf70" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下一个参数是min_sample。</p><h1 id="675f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">2.3分钟_样本</h1><p id="516d" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">在本文中，我将min_samples表示为z。如果你要从其他来源研究这个DBSCAN，那么你可能会遇到这个术语min_samples或minPts等等。这是我们希望在点的邻域中看到的最少点数的阈值。假设我们<br/>取z = 3。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lk"><img src="../Images/2a0632c04dcf0ca37025e8a0ac275afb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*AXpXkiKdKCr4OGPi.jpg"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated"><a class="ae lj" href="https://lh3.googleusercontent.com/proxy/LSWS-2LZgLQb91X15murhE7VcbnheZ-69c1y_qnvJE2m81UOs3dNDOjrOxIRtLzR4dFmpv9gzMXxdKYeh4lXMUIA13VEOwl9XVdRdcVm_r7AkBbxSK1d" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="8ee7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我们的邻域中有4个点，这也将满足我们的阈值z = 3。因为该阈值表示邻域中样本的最小数量。</p><h1 id="bae6" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">3.数据点的分类</h1><p id="bf04" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">现在，基于这两个参数，即ε和min_samples，我们首先将数据集中的每个点分为三类。他们是</p><ul class=""><li id="f83b" class="kh ki hh in b io ip is it iw ll ja lm je ln ji lo kp kq kr bi translated">核心要点</li><li id="dd97" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji lo kp kq kr bi translated">边界点或边界点</li><li id="f7df" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji lo kp kq kr bi translated">噪音点</li></ul><p id="aa4f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">先看核心点。</p><h1 id="7947" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">3.1核心要点</h1><p id="e38a" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">现在见上图。我代表了一个核心观点a。</p><p id="a60e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果我说一个点是核心点，那么它必须满足一个条件。条件是相邻点的数量必须大于或等于我们的阈值min_samples或z。如果我设置z = 3，则该点满足此条件。因此，我们说这是核心点。</p><p id="d2df" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们来看第二类点。</p><h1 id="6c1e" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">3.2边界点</h1><p id="67ab" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">如果我说一个点作为边界点，那么它必须满足以下两个条件。</p><ul class=""><li id="abfc" class="kh ki hh in b io ip is it iw ll ja lm je ln ji lo kp kq kr bi translated">邻居的数量必须小于z。</li><li id="b58b" class="kh ki hh in b io ks is kt iw ku ja kv je kw ji lo kp kq kr bi translated">该点应该在核心点的邻域内。</li></ul><p id="961d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">考虑上面提到的同一个数字。我表示一个边界点b。该点的邻居数量少于其邻域内的邻居数量，并且它位于另一个核心点的邻域内。所以，这个点B是一个边界点或边界点。</p><p id="67d5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们看看最后一种观点。</p><h1 id="4950" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">3.3噪音点</h1><p id="7ba1" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">噪声点的定义很简单。如果一个点既不是核心点也不是边界点，那么这个点叫做噪声点。在上图中，C点既不是核心点，也不是边界点。因此，我们可以说这是一个噪声点。</p><p id="793e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，我们已经将每一个数据点分为三类。这是DBSCAN算法的第一步。</p><p id="d905" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在你需要理解另一个概念。</p><h1 id="72c5" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">4.密度边和密度连接点</h1><h1 id="42b8" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">4.1密度边缘</h1><p id="2073" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">假设我们得到了<br/>两个核心点。如果两个点是邻居，那么我们用一条叫做<br/>的边将它们连接起来，我们称之为密度边。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/5ea656398877070c9c7f0190b96e1e60.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/0*_zuxDgvqHaFy-uWZ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated"><a class="ae lj" href="https://shritam.medium.com/how-dbscan-algorithm-works-2b5bef80fb3" rel="noopener">信号源</a></figcaption></figure><h1 id="ae9f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">4.2密度连接点</h1><p id="9e54" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">我们来考虑6点。我假设每个点都是一个核心点。假设它们通过密度边连接<br/>。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/25abb44c43cd5919046357cdba50802e.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/0*PGHp05t1IX5DIiNG.JPG"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated"><a class="ae lj" href="https://shritam.medium.com/how-dbscan-algorithm-works-2b5bef80fb3" rel="noopener">来源</a></figcaption></figure><p id="881f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可以看到p '在p "的邻域内，其他点也是如此。但是p和q不是邻居。如果出现这种情况，当两个核心点通过密度边相连时，那么我们说p和q是密度连结点。</p><p id="38d4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们来看看这个算法的步骤。</p><h1 id="6f55" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">5.DBSCAN算法中的步骤</h1><p id="2836" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">1.分门别类。</p><p id="f494" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">2.丢弃噪音。</p><p id="0ec5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">3.将集群分配给核心点。</p><p id="7d92" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">4.给一个核心点的所有密度连接点着色。</p><p id="e841" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">5.根据最近的核心点对边界点进行着色。</p><p id="22fd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">上面已经解释了第一步。</p><p id="07a3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第二是消除噪声点。</p><p id="302c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们来看看第三步。例如，我取一个核心点，并将其指定为聚类红色。第四步，我们要给第三步中选中的核心点的所有密度连接的点上色，颜色为红色。记住这里，我们不应该给边界点上色。</p><p id="6f9f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们必须对每个未着色的核心点重复第三和第四步。</p><p id="220f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">DBSCAN算法完成了！</p><p id="9d88" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我解释一下这个算法的几个非常重要的问题。</p><h1 id="be9a" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">6.如何确定ε和z？</h1><p id="9506" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">老实说，这是一个困难的问题，因为DBSCAN算法对其初始参数非常敏感。所以，如果你稍微改变ε和z的值，那么你的算法会产生非常不同的结果。这是这个算法的一个缺点。但是，如果您有适当的领域知识，您可以明智地选择这些值。根据经验，如果你有大量的例子，那么你可以按照维度的顺序选择z。如果你有10个维度，那么最好选择一个接近10的z值，比如12或15。</p><p id="0e69" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要知道ε的值，你可以试试。假设你选择了z = 5。那么，之后你会做什么？你会发现第五个邻居与每个数据点的距离。</p><p id="4e82" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，你将有一个距离数组，数组中的第I个元素将代表第I个数据点的第5个邻居的距离。然后你要对这个距离数组进行排序，然后像这样画出来。y轴上是距离，x轴上是指数(I)。</p><p id="bd07" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">理想情况下，你应该得到这样的图。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/e31ac031cdc69688ae6096a8af3b4b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/0*h2xCRKurjkQJjpqh.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated"><a class="ae lj" href="https://external-content.duckduckgo.com/iu/?u=https%3A%2F%2Fwww.datanovia.com%2Fen%2Fwp-content%2Fuploads%2Fdn-tutorials%2F005-advanced-clustering%2Ffigures%2F023-dbscan-density-based-clustering-k-nearest-neighbor-distance-1.png&amp;f=1&amp;nofb=1" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="0934" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">由于我们已经对其进行了排序，随着索引的增加，第5个数据点与该点的距离也将增加。如果你运气好，你可以找到这种肘型的东西。你可以用一条水平线来切割它，水平线会在某个点切割y轴，你可以把这个值作为ε。但在现实世界中，你可能得不到这种光滑的肘部。但这是在某些情况下可以应用的技巧。</p><p id="d636" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我来谈谈第二个要点。</p><h1 id="1f5f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">7.噪声消除</h1><p id="928c" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">DBSCAN在消除噪声方面非常有效。</p><p id="05c2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">正如您在我之前的示例中看到的，我们将这些点分为三类，其中有一类是噪声点。因此，该算法可以很好地应用于噪声数据集。最后一点是DBSCAN不能很好地处理高维数据。这是许多聚类算法的一个缺点。随着维度的增加，我们必须在更大的体积中寻找相同数量的邻居。所以，点与点之间的相似性降低了。这将导致聚类错误。</p><p id="eef1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们跳到代码部分。</p><h1 id="a209" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">8.Python的实际实现</h1><p id="b79c" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">首先，我要做一个假数据集。为了制作一个假数据集，我们使用了我们最喜欢的图书馆Sci-kit Learn。我们需要从sklearn.datasets导入名为make_blobs的函数。</p><p id="9c78" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">该函数采用n_samples，这表示我们需要产生多少数据点。</p><p id="0afd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第二个论点集中在。这告诉我们将会有多少个星团。</p><p id="5b27" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第三个参数n_features就是我们数据集的维度。</p><p id="e5fa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">random_state用于产生相同的结果。这个函数将返回两件事。</p><p id="f0cc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第一个是我赋给变量X的数据点，第二个是它将返回一个标签数组。</p><p id="a7dd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，记住DBSCAN是无监督学习。因此，我们一开始就不提供标签，即事实真相。我们让我们的算法自己找到这些标签。我们需要一些其他的库，比如pandas、matplotlib和NumPy。</p><pre class="lb lc ld le fd ls lt lu lv aw lw bi"><span id="a65f" class="lx jk hh lt b fi ly lz l ma mb">import numpy as np from sklearn.datasets import make_blobs from matplotlib import pyplot as plt from pandas import DataFrame X, _ = make_blobs(n_samples = 500, centers = 3, n_features = 2, random_state = 20)</span></pre><p id="821e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">继续进行可视化，您可以看到这里有三个集群。现在，我们的DBSCAN算法将尝试自己找到标签。</p><pre class="lb lc ld le fd ls lt lu lv aw lw bi"><span id="4229" class="lx jk hh lt b fi ly lz l ma mb">df = DataFrame(dict(x=X[:,0], y=X[:,1])) fig, ax = plt.subplots(figsize=(8,8)) df.plot(ax=ax, kind='scatter', x='x', y='y') plt.xlabel('x_1') plt.ylabel('x_2') plt.show()</span></pre><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/40b9fbd95a34ed5a8e7dfaf5822fa6be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*z8DX6R2jXqMjgD4F.png"/></div></figure><p id="0d34" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">使用scikit-learn在python中实现DBSCAN算法非常简单。类名为DBSCAN。我们需要用它创造一个物体。我在这里创建的对象是集群。我们需要输入我在概念部分讨论过的两个最重要的参数。第一个是eps，第二个是z或min_samples。现在我已经给了ε为1，min_samples为5。在下一步中，我们只是获取集群的标签。</p><pre class="lb lc ld le fd ls lt lu lv aw lw bi"><span id="411b" class="lx jk hh lt b fi ly lz l ma mb">from sklearn.cluster import DBSCAN clustering = DBSCAN(eps = 1, min_samples = 5).fit(X) cluster = clustering.labels_</span></pre><p id="c27e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要查看它在数据集上找到了多少个聚类，我们可以将这个数组转换成一个集合，然后打印出这个集合的长度。现在你可以看到它是4。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es md"><img src="../Images/380b22040ff22ca0da7df1beaafe6ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/0*lOyVF7s9NVJTsSRd.png"/></div></figure><p id="c404" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">但是发生了什么？</p><p id="52f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们看到我们的数据集包含三个集群。</p><p id="258a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">第一个为-1级的簇表示该DBSCAN中的噪声。你可以看到，我们只是通过这段简单的代码来可视化我们的集群，然后我们会发现类似这样的东西。</p><pre class="lb lc ld le fd ls lt lu lv aw lw bi"><span id="a302" class="lx jk hh lt b fi ly lz l ma mb">def show_clusters(X, cluster): df = DataFrame(dict(x=X[:,0], y=X[:,1], label=cluster)) colors = {-1: 'red', 0: 'blue', 1:'orange', 2:'green', 3:'yellow'} fig, ax = plt.subplots(figsize=(8,8)) grouped = df.groupby('label') for key, group in grouped: group.plot(ax=ax, kind='scatter', x='x', y='y', label=key, color=colors[key]) plt.xlabel('x_1') plt.ylabel('x_2') plt.show()</span><span id="2fee" class="lx jk hh lt b fi me lz l ma mb">show_clusters(X, cluster)</span></pre><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/9b4a441c67fdcadd7d86f30b48e58d29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/0*nUTakFPmxWa9v3ZV.png"/></div></figure><p id="8561" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这就是使用sci-kit learn实现DBSCAN有多简单。</p><h1 id="ac38" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">尾注</h1><p id="f209" class="pw-post-body-paragraph il im hh in b io kj iq ir is kk iu iv iw kx iy iz ja ky jc jd je kz jg jh ji ha bi translated">我希望你现在确信可以在一些数据集上应用DBSCAN。是时候把它弄到手了！</p><p id="d309" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> <em class="mg">本文中显示的媒体不归Analytics Vidhya所有，由作者自行决定使用。</em> </strong></p></div><div class="ab cl mh mi go mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ha hb hc hd he"><p id="539c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="mg">原载于2021年6月1日</em><a class="ae lj" href="https://www.analyticsvidhya.com/blog/2021/06/understand-the-dbscan-clustering-algorithm/" rel="noopener ugc nofollow" target="_blank"><em class="mg">https://www.analyticsvidhya.com</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>