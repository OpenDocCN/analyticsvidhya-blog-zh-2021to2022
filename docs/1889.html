<html>
<head>
<title>Building an API with Dlib + Python + Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dlib + Python + Heroku构建API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-an-api-with-dlib-python-heroku-2d25687e66f0?source=collection_archive---------3-----------------------#2021-03-24">https://medium.com/analytics-vidhya/building-an-api-with-dlib-python-heroku-2d25687e66f0?source=collection_archive---------3-----------------------#2021-03-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="1ff2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本文旨在使用Python的Dlib库构建一个用于人脸识别的API。为了创建API，我们将使用Python 3的Flask框架。为了简单起见，我们将把这个API部署到Heroku环境中，它提供了简单的步骤，即使我们不是这个领域的专家，也可以很容易地遵循。Docker将帮助我们解决最大的依赖性。我们可以开始了吗？</p><h1 id="6d5f" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">Dlib</h1><p id="5620" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">Dlib是一个用C++构建的库，它提供了多种机器学习算法，其中一些算法与图像处理相关。该库为python提供了一个API。在本文中，我们将使用Dlib来识别人脸内部的点。我们还将使用OpenCV，这是另一个用于人脸识别的库，Dlib将帮助收集检测到的人脸中的点。</p><h1 id="4146" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">瓶</h1><p id="078f" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">Flask是用Python构建web应用程序的微框架。它非常容易安装和使用，不需要像我们在更完整的框架中那样进行大量的配置。</p><p id="4526" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于人脸检测，我们需要一个<em class="km">face _ recognition _ service . py</em>文件。我们可以使用类似这样的结构:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="533f" class="kw jk hh ks b fi kx ky l kz la"><em class="km">import </em>cv2<br/><em class="km">import </em>dlib<br/><em class="km">import </em>base64<br/><em class="km">from </em>imutils <em class="km">import </em>resize, face_utils<br/><em class="km">from </em>urllib.parse <em class="km">import </em>quote</span><span id="c3d4" class="kw jk hh ks b fi lb ky l kz la">detector = dlib.get_frontal_face_detector()<br/>predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")</span><span id="ef3c" class="kw jk hh ks b fi lb ky l kz la"><em class="km">def </em>get_image_with_landmarks(file_path: str):<br/>    rects = <em class="km">None<br/>    </em>gray = <em class="km">None<br/>    </em>clone = <em class="km">None<br/><br/>    try</em>:<br/>        image = cv2.imread(file_path, 1)<br/>        image = resize(image, height=240)<br/>        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br/>        clone = image.copy()<br/>        rects = detector(gray, 1)<br/><br/>    <em class="km">except </em>Exception:<br/>        <em class="km">return </em>{'error': 'Error while reading the image'}<br/><br/>    any_face_was_found = len(rects) &gt; 0<br/>    <em class="km">if </em>any_face_was_found:<br/>        <em class="km">for </em>(i, rect) <em class="km">in </em>enumerate(rects):<br/>            shape = predictor(gray, rect)<br/>            shape = face_utils.shape_to_np(shape)<br/><br/>            <em class="km">for </em>point <em class="km">in </em>range(1, 68):<br/>                coords = shape.tolist()[point]<br/>                cv2.circle(clone, (coords[0], coords[1]), 1, (0, 0, 255), thickness=2)<br/>    <em class="km">else</em>:<br/>        <em class="km">return </em>{'error': 'No face was detected in the image provided'}<br/><br/>    retval, buffer = cv2.imencode('.jpg', clone)<br/>    image_as_text = base64.b64encode(buffer)<br/><br/>    <em class="km">return </em>{'image_with_landmarks': 'data:image/png;base64,{}'.format(quote(image_as_text))}</span></pre><p id="b653" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了使用Dlib进行人脸地标识别，我们需要提供一个名为<strong class="in hi"><em class="km">shape _ predictor _ 68 _ face _ landmarks . dat</em></strong>的训练模型。我们可以从<a class="ae lc" href="http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2" rel="noopener ugc nofollow" target="_blank">网站</a>或者存储库中获得这个文件。</p><p id="8d9a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于Flask框架，我们需要定义一个控制器<em class="km"> app.py </em>文件，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="698c" class="kw jk hh ks b fi kx ky l kz la"><em class="km">import </em>os<br/><em class="km">from </em>flask <em class="km">import </em>Flask, render_template, request<br/><em class="km">from </em>face_recognition_service <em class="km">import </em>get_image_with_landmarks<br/><br/>app = Flask(__name__)<br/>app.config['UPLOAD_FOLDER'] = './'<br/><br/><br/>@app.route('/', methods=["GET", "POST"])<br/><em class="km">def </em>index():<br/>    <em class="km">if </em>request.method == "GET":<br/>        <em class="km">return </em>render_template("index.html", result={})<br/>    <em class="km">else</em>:<br/>        image = request.files["image"]<br/>        path = os.path.join(app.config['UPLOAD_FOLDER'], image.filename)<br/>        image.save(path)<br/>        result_from_landmarks = get_image_with_landmarks(path)<em class="km"><br/>        </em>os.remove(path)<br/><br/>        <em class="km">return </em>render_template("index.html", result=result_from_landmarks)<br/><br/><br/><em class="km">if </em>__name__ == '__main__':<br/>    port = int(os.environ.get("PORT", 5000))<br/>    app.run(host='0.0.0.0', port=port)</span></pre><p id="e4ea" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于UI，我们可以提供一个简单的HTML。这个文件应该在一个<em class="km">模板</em>文件夹中，我们使用<em class="km">index.html</em>作为文件名。对于我们在HTML中使用的注释，我们可以寻找<a class="ae lc" href="https://jinja.palletsprojects.com/en/2.11.x/" rel="noopener ugc nofollow" target="_blank"> Jinja </a>文档。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="062d" class="kw jk hh ks b fi kx ky l kz la">&lt;!DOCTYPE <em class="km">html</em>&gt;<br/>&lt;html <em class="km">lang</em>="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta <em class="km">charset</em>="UTF-8"&gt;<br/>    &lt;meta <em class="km">name</em>="viewport" <em class="km">content</em>="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;title&gt;Testing API with Dlib&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;h2&gt;Face recognition with Dlib&lt;/h2&gt;<br/>    &lt;form <em class="km">method</em>="post" <em class="km">enctype</em>="multipart/form-data"&gt;<br/>        &lt;input <em class="km">type</em>="file" <em class="km">name</em>="image" <em class="km">placeholder</em>="Upload an image"&gt;<br/>        &lt;button&gt;Send&lt;/button&gt;<br/>    &lt;/form&gt;<br/>    &lt;div <em class="km">style</em>="background: #f6f6f6; padding: 20px; margin-top: 20px;"&gt;<br/>        &lt;strong&gt;Result with landmarks&lt;/strong&gt;<br/>        {% <em class="km">if </em>result <em class="km">and </em>result.error %}<br/>            &lt;p&gt;{{ result.error }}&lt;/p&gt;<br/>        {% <em class="km">elif </em>result <em class="km">and </em>result.image_with_landmarks %}<br/>            &lt;p&gt;&lt;img <em class="km">src</em>="{{ result.image_with_landmarks }}" <em class="km">alt</em>="face with landmarks"/&gt;&lt;/p&gt;<br/>        {% <em class="km">else  </em>%}<br/>            &lt;p&gt;The results will be placed here&lt;/p&gt;<br/>        {% <em class="km">endif </em>%}<br/>    &lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h1 id="11ff" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated"><strong class="ak"> Heroku </strong></h1><p id="4c07" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">Heroku是一个云平台，它帮助我们部署、为不同的环境创建管道、监控我们的应用程序以及其他许多事情。它易于使用和配置。</p><p id="6672" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于这个配置，我们需要提供一个<em class="km"> requirements.txt </em>文件。在这个文件中，我们可以添加项目中的任何依赖项。我们可以看到Flask是我们案例中的主要依赖项。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="16cf" class="kw jk hh ks b fi kx ky l kz la">click==6.7<br/>Flask==1.1.2<br/>numpy==1.20.1<br/>Dlib==19.21.1<br/>opencv-python==4.5.1.48<br/>itsdangerous==0.24<br/>Jinja2&gt;=2.10.1<br/>MarkupSafe==1.0<br/>Werkzeug&gt;=0.15<br/>imutils==0.5.3</span></pre><p id="4fe9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于Heroku，我们通常提供一个<a class="ae lc" href="https://devcenter.heroku.com/articles/procfile" rel="noopener ugc nofollow" target="_blank"> Procfile </a>来定义启动应用程序的例程。在我们的例子中，不需要Procfile，因为我们将使用另一个配置文件来构建Docker。</p><p id="0379" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们不只是简单地将它作为一个普通的git仓库部署在Heroku上的原因是，由于大量的子依赖项，Dlib需要相当长的时间才能安装在云环境中。Dlib使用c++依赖项，如Cmake、Boost和XQuartz。事实上，当Heroku试图使用Procfile安装Dlib时，它会花费大量时间来尝试安装，并且根本不会完成。这是一个机器学习库，所以可以期待这一点。</p><h1 id="e256" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">码头工人</h1><p id="6859" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">我们使用<a class="ae lc" href="https://www.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker </a>构建独立的容器，其中包含操作系统和应用程序中需要的软件。这些组件是独立的、强大的、轻量级的，我们可以受益于不需要手动在云中设置虚拟机，就像我们以前做的那样。</p><p id="803e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为此，我们需要在项目中设置一个Dockerfile，如下所示:</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="72d1" class="kw jk hh ks b fi kx ky l kz la">FROM jhonatans01/python-dlib-opencv<br/>COPY . /app<br/>WORKDIR /app<br/>RUN pip3 install -r requirements.txt<br/>CMD ["python3", "app.py"]</span></pre><p id="cdc7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这个文件中，我们从DockerHub中提取一个名为<a class="ae lc" href="https://hub.docker.com/r/jhonatans01/python-dlib-opencv" rel="noopener ugc nofollow" target="_blank">jhonatans 01/python-DLI b-opencv</a>的图像。此图包含使用Python 3.6的Dlib + OpenCV依赖项。基本上，在这5行代码中，我们:</p><ol class=""><li id="96d9" class="ld le hh in b io ip is it iw lf ja lg je lh ji li lj lk ll bi translated">提取这个图像</li><li id="0a2d" class="ld le hh in b io lm is ln iw lo ja lp je lq ji li lj lk ll bi translated">将项目中的所有内容复制到<em class="km"> app </em>文件夹中</li><li id="1717" class="ld le hh in b io lm is ln iw lo ja lp je lq ji li lj lk ll bi translated">将这个<em class="km"> app </em>文件夹设置为我们的工作空间</li><li id="67a3" class="ld le hh in b io lm is ln iw lo ja lp je lq ji li lj lk ll bi translated">用pip安装我们的依赖项(除了Dlib或OpenCV)</li><li id="9902" class="ld le hh in b io lm is ln iw lo ja lp je lq ji li lj lk ll bi translated">为Flask运行我们的python主文件，它是<em class="km"> app.py </em>。</li></ol><p id="cb89" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于Heroku配置，我们仍然需要一个<em class="km"> heroku.yml </em>文件，以便定义这是一个在您每次提交和推送您的更改到git存储库时要用Docker部署的应用程序。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="21eb" class="kw jk hh ks b fi kx ky l kz la">build:<br/>  docker:<br/>    web: Dockerfile</span></pre><p id="9eaa" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这非常简单，对于这个项目，我们只需要设置docker文件的路径。</p><h1 id="e86c" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">部署API</h1><p id="cf2c" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">到目前为止，我们假设您已经有了一个Heroku帐户。如果您还没有，请继续注册。此外，您需要安装<a class="ae lc" href="https://devcenter.heroku.com/articles/heroku-cli" rel="noopener ugc nofollow" target="_blank"> Heroku CLI </a>来运行以下命令。</p><p id="83c2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">要构建将要部署的映像，您需要在本地机器上安装Docker。</p><p id="97de" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">安装好所有东西后，您需要创建一个项目。Heroku UI平台可以帮助你做到这一点。让我们在终端登录heroku，构建并推送docker容器。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="4c16" class="kw jk hh ks b fi kx ky l kz la">$ heroku login<br/>$ heroku container:login<br/>$ heroku container:push web -a name_of_your_app<br/>$ heroku container:release web -a name_of_your_app</span></pre><p id="0c4b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">完成这些步骤后，您应该能够在线打开应用程序并看到类似于以下内容的内容:</p><figure class="kn ko kp kq fd ls er es paragraph-image"><div class="er es lr"><img src="../Images/1377e6583a9858546b4fd6ed9a2e2f9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*tNRIvuC2AT8M7YC3aWNonw.gif"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">Heroku环境中运行的应用程序</figcaption></figure><p id="67ee" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您使用的是链接到Heroku应用程序的git存储库，那么您提交的任何新更改都将自动触发Docker构建，并在以后进行部署。你只需要在第一次需要部署这个应用的时候担心上面提到的<em class="km"> heroku container </em>命令。</p><p id="1e0c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个代码存在于我的<a class="ae lc" href="https://github.com/jhonatans01/face_recognition_api_heroku_example" rel="noopener ugc nofollow" target="_blank"> github </a>中。在资源库中有一个<em class="km"> docker-compose.yml </em>文件，允许你用一个命令在本地运行这个应用程序。</p><pre class="kn ko kp kq fd kr ks kt ku aw kv bi"><span id="3814" class="kw jk hh ks b fi kx ky l kz la">docker-compose up --build</span></pre><p id="d2b0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">希望这对你有所帮助:)</p></div></div>    
</body>
</html>