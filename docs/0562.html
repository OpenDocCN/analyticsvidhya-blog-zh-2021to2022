<html>
<head>
<title>Regularization and Cross-Validation — How to choose the penalty value (lambda)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">正则化和交叉验证—如何选择罚值(λ)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/regularization-and-cross-validation-how-to-choose-the-penalty-value-lambda-1217fa4351e5?source=collection_archive---------1-----------------------#2021-01-22">https://medium.com/analytics-vidhya/regularization-and-cross-validation-how-to-choose-the-penalty-value-lambda-1217fa4351e5?source=collection_archive---------1-----------------------#2021-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="217a" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">超参数调整| L1 VS L2正则化|监督学习</h2><div class=""/><div class=""><h2 id="9ad4" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">使用交叉验证选择正确的超参数值</h2></div><p id="35bf" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">简单线性回归有两个主要缺陷:</p><ol class=""><li id="7f64" class="kc kd hi ji b jj jk jm jn jp ke jt kf jx kg kb kh ki kj kk bi translated">它容易与许多输入特征过度匹配，</li><li id="567a" class="kc kd hi ji b jj kl jm km jp kn jt ko jx kp kb kh ki kj kk bi translated">它不容易表达非线性/曲线关系。</li></ol><p id="1263" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">解决这些问题的一种方法是增加模型的复杂性。通过使用决策树和多项式回归来表示非线性关系，可以增加模型的复杂性。</p><p id="6726" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">由于复杂性增加，这些算法也容易过度拟合。因此，为了在不过度拟合的情况下表示非线性函数，我们利用了正则化技术。</p><p id="ec09" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">正则化技术用于校准线性/非线性回归模型，以便最小化调整后的损失函数并防止过拟合。</p><p id="cc93" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">两种常见的正则化方法是:</p><ol class=""><li id="4d2d" class="kc kd hi ji b jj jk jm jn jp ke jt kf jx kg kb kh ki kj kk bi translated">LASSO(最小绝对收缩和选择算子)回归或<strong class="ji hs"> L1惩罚</strong></li></ol><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es kq"><img src="../Images/d00ea264965ca9229759b4151ab9be79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*GWtu8jMiAwPYm7VyggC7XQ.jpeg"/></div></figure><p id="5972" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">2.岭回归还是<strong class="ji hs"> L2被罚</strong></p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es ky"><img src="../Images/62730e12dfc47251eeaf61c8f3d2884f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1372/format:webp/1*dLi2HseAMWTU4MUyn8bNag.jpeg"/></div></figure><p id="c34f" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">降低<strong class="ji hs">λ</strong>的值会使模型复杂，反之亦然。我们应该找到完美的平衡来防止过度拟合。<strong class="ji hs">λ</strong>为正值，范围从0到正无穷大。但是通常选择在0到10之间。</p><p id="da90" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">那么，我们如何选择惩罚值<strong class="ji hs">λ呢？</strong>答案是交叉验证。</p><p id="a085" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">交叉验证是一种仅使用训练数据来调整超参数的方法。交叉验证有不同的变体，但最常见的是10重交叉验证。</p><p id="c2ba" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">请记住，数据是有限的资源，我们必须明智地使用它。这里要记住的主要事情是，我们必须让测试数据远离算法，并且只对训练数据进行所有的验证。</p><p id="52e3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">步骤1:首先将整个数据集分成训练集和测试集。(70%-30%或者80%-20%)。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/70b773cbbdc431cd1c6cd9c8982852e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7vpn0wUbki22FX7EeWNtVQ.png"/></div></div></figure><p id="65c0" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">步骤2:现在把测试集放在一边，把训练数据分成10等份。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es le"><img src="../Images/879ae378e156750e26efd59c5c3503be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kK2KBiKf9U_44dNJdubCOw.png"/></div></div></figure><p id="40ad" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第三步:现在说我们选择λ= 0.2。在9个折叠上训练模型，并在维持折叠(现在作为训练数据中的测试数据)上评估模型，并获得维持分数，这是该模型的性能分数。假设我们得到0.52</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lf"><img src="../Images/4ff2fde213e29de65be671b5cb53e411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mM5GTFVc18cF2dASKU8aaw.png"/></div></div></figure><p id="2b1d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">第4步:重复第3步9次，每次在不同的维持折叠，并记录他们的维持分数。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lg"><img src="../Images/ab35767e66881eb5334d9e8b8dc93f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqVo1EWX-crwgqGiv-yXjA.png"/></div></div></figure><p id="ebca" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">步骤5:在所有的迭代完成之后，模型将每次使用10个不同的保持折叠上的不同折叠进行训练，给出10个不同的保持分数。要获得最终的交叉验证分数，请取所有单个拒绝分数的平均值。</p><figure class="kr ks kt ku fd kv er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es lh"><img src="../Images/9ccc9375407a0b2ee5eccea8ab4e7a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDkc_1ESr5v10n322OLSLA.png"/></div></div></figure><p id="23ab" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">交叉验证分数是对数据集使用一组特定的超参数值(在本例中为λ= 0.2)的模型的性能。</p><p id="a1a9" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在，对您想要尝试的其他lambda集执行从1到5的<strong class="ji hs">步骤。最后，你会得到这样的东西，</strong></p><figure class="kr ks kt ku fd kv er es paragraph-image"><div class="er es li"><img src="../Images/6e37307c85afca3cb9db8bbdd66dad88.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*Sk77GgbG4qZl4khGPi7Xtw.jpeg"/></div></figure><p id="f978" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">λ值为0.4时获得最佳交叉验证分数。这是你的最佳λ值。</p><p id="c1c3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">现在用λ= 0.4的超参数值在整个初始训练数据集上训练模型</p><p id="9a37" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">这就是我们如何选择具有最佳超参数值的估计最佳模型。对不同类型的算法使用相同的过程，如山脊、套索、弹性网、随机森林和增强树。在这样做的时候，我们需要为不同的算法设置不同的超参数。例如，随机森林不具有alpha超参数，它具有最大叶子样本大小。</p></div><div class="ab cl lj lk gp ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="hb hc hd he hf"><p id="c307" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">感谢您的阅读。如果您有任何问题，请通过LinkedIn联系。</p><div class="lq lr ez fb ls lt"><a href="https://swapnilin.github.io/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab dw"><div class="lv ab lw cl cj lx"><h2 class="bd hs fi z dy ly ea eb lz ed ef hr bi translated">Swapnil Kangralkar</h2><div class="ma l"><h3 class="bd b fi z dy ly ea eb lz ed ef dx translated">Swapnil Kangralkar。我是一名驻加拿大渥太华的中级数据科学家。</h3></div><div class="mb l"><p class="bd b fp z dy ly ea eb lz ed ef dx translated">swapnilin.github.io</p></div></div><div class="mc l"><div class="md l me mf mg mc mh kw lt"/></div></div></a></div></div></div>    
</body>
</html>