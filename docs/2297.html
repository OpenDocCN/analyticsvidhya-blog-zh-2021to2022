<html>
<head>
<title>Scene-15 Image classification problem with Transfer Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于迁移学习的场景15图像分类问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scene-15-image-classification-problem-with-transfer-learning-231962b85c6e?source=collection_archive---------6-----------------------#2021-04-17">https://medium.com/analytics-vidhya/scene-15-image-classification-problem-with-transfer-learning-231962b85c6e?source=collection_archive---------6-----------------------#2021-04-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fdf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图像分类是将图像分类到不同类别的过程。图像分类是深度学习最重要的应用之一。迁移学习是解决图像分类问题的一种高效技术。基本上，在迁移学习中，我们必须使用“ImageNet”数据集权重来提高预测精度。为了证明我的观点，我使用了scene-15数据集。你可以在这里找到这个数据集。</p><h1 id="a43e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">场景15</h1><figure class="kc kd ke kf fd kg er es paragraph-image"><div class="er es kb"><img src="../Images/d9b230fe8240a28d645b2d4bcfe242d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*vI0ZNMB3ov-mCq_oSOeRdg.jpeg"/></div><figcaption class="kj kk et er es kl km bd b be z dx translated">来自scene-15数据集的一些图片</figcaption></figure><p id="15d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所示，Scene-15数据集包含15个不同类别的不同图片。在15个不同的类中总共有4485个图像可用，其中我们将使用100个图像进行训练，其余的用于测试。我们有1500张图片用于训练，2985张图片用于测试。</p><p id="97f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们首先导入库。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="b477" class="ks je hh ko b fi kt ku l kv kw"># importing libraries</span><span id="5567" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">import pandas as pd<br/>import numpy as np<br/>import os<br/>import cv2<br/>import random<br/>import keras<br/>import matplotlib.pyplot as plt</em></strong></span><span id="c7c9" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">from scipy import misc<br/>from plot_keras_history import plot_history<br/>from keras import Model<br/>from keras.applications.resnet50 import preprocess_input<br/>from keras.applications import ResNet152V2<br/>from keras.preprocessing.image import img_to_array, load_img<br/>from keras.layers import ZeroPadding2D<br/>from keras.models import Sequential<br/>from keras.layers import Dense, Conv2D, MaxPooling2D,Dropout, Flatten, BatchNormalization, Concatenate, AveragePooling2D<br/>from keras.callbacks import EarlyStopping, LearningRateScheduler</em></strong></span></pre><h1 id="1fd6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">拆分数据</h1><p id="f84d" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">在训练和测试中分割数据是很重要的。但是这里我们有15个不同的文件夹可用，所以首先尝试将数据拆分到train/test文件夹中。以下代码将有助于将函数拆分到指定位置的Train和Test文件夹中。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="0269" class="ks je hh ko b fi kt ku l kv kw"># function to split images into train&amp;test</span><span id="1a29" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">def create_train_test(data_dir, class_folder):<br/>    directory = data_dir + "/" + class_folder + "/"<br/>    data = os.listdir(directory)<br/>    random.shuffle(data)<br/>    train = data[:100]  # random 100 images (random.shuffle) for train<br/>    test = data[100:]  # rest for test</em></strong></span><span id="b2fb" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">return train, test</em></strong></span><span id="35b5" class="ks je hh ko b fi kx ku l kv kw"># Getting available features</span><span id="0761" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">class_folder = []<br/>path = "C:/Users/Cobra/Python Learning/Lakehead Assignments/Assignent_2_(part-1)/15-Scene/"</em></strong></span><span id="f4d6" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi"><em class="ky">for category in sorted(os.listdir(path)):<br/>    class_folder.append(category)</em></strong></span><span id="8feb" class="ks je hh ko b fi kx ku l kv kw"># splitting images into train &amp; test<br/># Remember we just split the image into train &amp; test (without preprocessing)</span><span id="a90f" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">train_set = []<br/>test_set = []</strong></span><span id="2c0d" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">data_dir = 'give data dir path'</strong></span><span id="f86a" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">for class_name in class_folder:<br/> train, test = create_train_test(data_dir, class_name)<br/> train_data = [class_name, train]<br/> test_data = [class_name, test]<br/> train_set.append(train_data)<br/> test_set.append(test_data)<br/>train_set = np.array(train_set)<br/>test_set = np.array(test_set)</strong></span></pre><p id="67c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建训练和测试图像数据后，我们必须将它们存储在不同的地方以备将来使用。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="b340" class="ks je hh ko b fi kt ku l kv kw"># Create directory to store train and test folder</span><span id="7b5f" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">dir_create = “give dir path”<br/>output_directory = os.mkdir(os.path.join(dir_create, ‘15-Scene_output’))</strong></span></pre><p id="2d19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们创建一个函数，将图像写入到上面创建的文件夹中。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="03e5" class="ks je hh ko b fi kt ku l kv kw"># Function to create train and test folder in given directory<br/># data_dir = Original dataset path<br/># output_path = Path where we want to create folder<br/># output_directory = output directory name<br/># folder_name = folder name like. Train/Test<br/># dataset = train_set/test_set</span><span id="df33" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">def write_img_to_folder(data_dir, output_path, output_directory, folder_name,<br/> dataset):</strong></span><span id="3013" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">new_folder_path = os.path.join(output_directory, folder_name)<br/> make_directory = os.mkdir(new_folder_path)</strong></span><span id="c41a" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">for data in dataset:<br/> class_name = data[0]<br/> data_files = data[1]<br/> data_path = os.path.join(<br/> output_path + ‘/’ + str(output_directory) + ‘/’ + str(folder_name),<br/> class_name)<br/> category_dire = os.mkdir(data_path)<br/> for filename in data_files:<br/> img = cv2.imread(data_dir + ‘/’ + class_name + ‘/’ + filename, 0)<br/> cv2.imwrite(os.path.join(data_path, filename), img)</strong></span><span id="929a" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">output_path = os.getcwd()</strong></span><span id="3402" class="ks je hh ko b fi kx ku l kv kw"># Train/Test folder using write_img_to_folder function</span><span id="58ec" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">train_folder = write_img_to_folder(data_dir, output_path,'Train', train_set)<br/>test_folder = write_img_to_folder(data_dir, output_path,'Test', test_set)</strong></span></pre><h1 id="9f30" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">加载数据</h1><p id="fa99" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">现在，我们的数据集可以使用了。我们需要从存储的路径中加载图像，并将它们转换成一个数组来执行图像分类。所以，让我们从将图像转换成数组开始。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="8ce8" class="ks je hh ko b fi kt ku l kv kw"># Function to load image and convert into array</span><span id="12e7" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">def convert_img_to_array(dir_path):<br/>    X = []<br/>    y = []<br/>    one_hot_lookups = np.eye(15)<br/>    for category in sorted(os.listdir(dir_path)):<br/>        for file in os.listdir(dir_path + category):</strong></span><span id="6da7" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">            img = load_img(dir_path + category + '/' + file,<br/>                       target_size=(224, 224))</strong>  # Load image<br/>            <strong class="ko hi">img = img_to_array(img)  </strong># Convert image to array<br/>            <strong class="ko hi">img = preprocess_input(img)</strong>  # Preprocessing on the image<br/>            <strong class="ko hi">X.append(img)</strong>  # Append image to X_train<br/>            <strong class="ko hi">y.append(np.reshape(one_hot_lookups[int(category)],<br/>                                  [15]))</strong>  # Append category to y_train<br/>    <strong class="ko hi">return X,y</strong></span></pre><p id="55bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在创建了从给定路径加载图像并将其转换为数组的函数之后，我们需要生成x_train，y_train和x_test，y_test数据。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="cf13" class="ks je hh ko b fi kt ku l kv kw"><strong class="ko hi">def load_data():<br/>    train_dir_path = "Give train dir path"<br/>    X_train,y_train = convert_img_to_array(train_dir_path)<br/>    <br/>    test_dir_path = "Give test dir path"<br/>    X_test, y_test = convert_img_to_array(test_dir_path)<br/>    <br/>    X_train = np.asarray(X_train)<br/>    X_test = np.asarray(X_test)<br/>    y_train = np.asarray(y_train)<br/>    y_test = np.asarray(y_test)<br/>    <br/>    X_train /= np.std(X_train, axis = 0)<br/>    X_test /= np.std(X_test, axis = 0)<br/>    <br/>    return ((X_train, y_train), (X_test, y_test))</strong></span><span id="b5da" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">(x_train, y_train), (x_test, y_test) = load_data()</strong></span></pre><h1 id="efd7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">创建迁移学习模型</h1><p id="b628" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">在生成模型之前，有一些事情需要明确。第一个是什么是迁移学习，简而言之，迁移学习是一种使用其他预训练模型的权重以获得更高准确性的技术。这里，我们使用“ImageNet”预训练权重，该数据集有1000个类。第二件事是，我们需要添加一些额外的层，以获得所需的输出。我们只有15个类，因此，为了解决最终节点，我们在模型中添加了一些额外的层。这里，我们使用ResNet152V2预训练模型进行迁移学习。让我们开始程序。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="4f0b" class="ks je hh ko b fi kt ku l kv kw"><strong class="ko hi">def transfer_model(weights, input_shape, num_output):</strong><br/>    <strong class="ko hi">transfer_model = ResNet152V2(weights=weights, include_top=False,                              input_shape=input_shape,pooling='max',classifier_activation='softmax')</strong><br/>    <strong class="ko hi">inp = transfer_model.input</strong></span><span id="3d2a" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">new_classification_layer = Dense(num_output, activation='softmax') </strong># make a new softmax layer with 257 neurons</span><span id="e28b" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">out = new_classification_layer(transfer_model.layers[-1].output)</strong> # connect our new layer to the second to last layer in ResNet152V2, and make a reference to it</span><span id="40e3" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">final_model = keras.Model(inp, out)</strong> # create a new network between inp and out<br/>    <br/> <strong class="ko hi">   return final_model</strong></span><span id="948b" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">transfer_model = transfer_model(weights='imagenet',input_shape=(224,224,3), num_output=15)</strong></span><span id="dfd1" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">transfer_model.summary()</strong></span></pre><p id="5751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的代码中，我们将得到下面的输出。</p><figure class="kc kd ke kf fd kg er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/19ef4d179cf3c96dd0bb90b2328535a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3rwVp14BGg8B9mXGBX8R9A.png"/></div></div><figcaption class="kj kk et er es kl km bd b be z dx translated">注意:这只是具有15个输出节点的模型的结尾。</figcaption></figure><h1 id="ccf3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">模型的编制</h1><p id="16de" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">创建模型后，需要在拟合数据集之前进行编译。所以，我们先来编译一下模型。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="83a5" class="ks je hh ko b fi kt ku l kv kw"><strong class="ko hi">def compile_model(model):<br/>    lr_schedule = keras.optimizers.schedules.ExponentialDecay(<br/>    initial_learning_rate=0.01, decay_steps=1000, decay_rate=0.9)</strong></span><span id="31d6" class="ks je hh ko b fi kx ku l kv kw"># Optimizer for the model<br/><strong class="ko hi">    optimizer = keras.optimizers.SGD(learning_rate=lr_schedule)</strong></span><span id="2946" class="ks je hh ko b fi kx ku l kv kw"># Creating the log file<br/>    <strong class="ko hi">model.compile(loss='categorical_crossentropy',<br/>              optimizer=optimizer,<br/>              metrics=['accuracy'])<br/>    return model</strong></span><span id="b476" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">final_model = compile_model(final_model)</strong></span></pre><h1 id="6852" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">拟合数据</h1><p id="a816" class="pw-post-body-paragraph ie if hh ig b ih kz ij ik il la in io ip lb ir is it lc iv iw ix ld iz ja jb ha bi translated">编译模型后，我们需要用训练和测试数据来拟合模型。</p><pre class="kc kd ke kf fd kn ko kp kq aw kr bi"><span id="1d83" class="ks je hh ko b fi kt ku l kv kw"><strong class="ko hi">accuracy = []<br/>losses = []</strong></span><span id="47ad" class="ks je hh ko b fi kx ku l kv kw"><strong class="ko hi">for i in range(3):<br/>    keras.backend.clear_session()<br/>    <br/>    model = transfer_model<br/>    <br/>    model = compile_model(model)<br/>    model_history = train_model(model, x_train, y_train, x_test, y_test)<br/>    loss, acc = model.evaluate(x_test, y_test, verbose=1)<br/>    <br/>    plot_history(model_history.history)<br/>    plt.show()<br/>    <br/>    print(f"\n")<br/>    print(f"------------------------------------------------------")<br/>    print(f"\n")<br/>    accuracy.append(acc)<br/>    losses.append(loss)</strong></span></pre><p id="cb0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我已经运行了整个模型3次，以达到最佳的平均精度。通过实现这段代码，我能够达到89.53%的准确率。</p><p id="64c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">谢谢你。</p></div><div class="ab cl lj lk go ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ha hb hc hd he"><p id="8ab8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请随时到jivaniutsav007@gmail.com找我。</p></div></div>    
</body>
</html>