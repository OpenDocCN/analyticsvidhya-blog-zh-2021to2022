<html>
<head>
<title>Three pillars of a “good” software product</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“好”软件产品的三大支柱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/three-pillars-of-a-good-software-product-fc839393274c?source=collection_archive---------2-----------------------#2022-01-21">https://medium.com/analytics-vidhya/three-pillars-of-a-good-software-product-fc839393274c?source=collection_archive---------2-----------------------#2022-01-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b01d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有多少次你的经理提到SLA或SLO这样的术语，而你却不知道？</p><p id="b237" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我最近开始读这本很棒的书Martin Kleppman的《设计数据密集型应用程序》,我想我应该分享一下我所学到的东西。我个人认为，如果你从事任何技术产品方面的工作，这篇博客文章将会帮助你。在这篇博客中，我将回顾可靠性、可伸缩性和可维护性的定义；为什么它们很重要，以及我们如何确保在产品中正确使用它们。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/e9dba72a60e43ffee9320cec0285c20a.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/format:webp/1*jvztvb22FKw8dGq4WCIp2g.png"/></div></figure><h1 id="353c" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">可靠性</h1><p id="d63a" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">一个系统需要保持正常工作，即使面对意想不到的情况，如硬件/软件故障或人为错误。预测这些故障并尝试设计一个具有容错/弹性的系统是很重要的。克莱普曼确实提到没有容错系统-</p><blockquote class="kn ko kp"><p id="0813" class="ie if kq ig b ih ii ij ik il im in io kr iq ir is ks iu iv iw kt iy iz ja jb ha bi translated">如果整个地球(以及地球上的所有服务器)被一个黑洞吞噬，容忍这个错误将需要在太空中进行网络托管</p></blockquote><p id="a975" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，我们最感兴趣的是触发错误并确保错误处理或bug得到处理。网飞的库<a class="ae ku" href="https://github.com/Netflix/chaosmonkey" rel="noopener ugc nofollow" target="_blank">混沌猴子</a>允许你随机终止进程来发现错误，以帮助建立更有弹性的系统。</p><p id="39ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">硬件错误:目前，很多公司依赖云平台来满足他们的基础设施需求。存在通过平台提供的虚拟机随机离线的情况。一个可以在停机时间工作并可以一次一个节点上线的系统是一种使其对硬件故障具有弹性的方法。冗余也很重要，在多台机器上部署一个服务，所以如果其中一台出现问题，服务不会完全离线。例如，在多台机器上部署接收披萨订单的聊天机器人。</p><p id="5b83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">软件错误:这些更难预测，并且可能与导致多个故障的其他节点相关。接收比萨饼订单的聊天机器人有一个软件错误，导致故障。我们希望确保比萨饼请求被保存在某个地方，以便当系统恢复在线时可以处理它，并且客户不必花费整个晚上来诅咒您的平台。解决方案:使用消息队列(还要确保传入消息的数量等于传出消息的数量)。</p><p id="62cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">人为错误:众所周知，人类是不可靠的，不幸的是，从设计到运营，我们都是每个系统的一部分。我们能做些什么来使系统从人为错误中恢复过来？</p><ul class=""><li id="8049" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb la lb lc ld bi translated">设计系统，尽量减少出错的机会。例如，运营团队使用代码(基础设施即代码)更新基础设施，而不是手动更新。然而，如果界面限制性太强，人们往往会绕开它。如果某个运营团队成员手动更改了基础架构，那么代码就会失去同步，这将导致更多的错误。</li><li id="60e4" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">提供沙盒环境进行探索和实验。</li><li id="3f42" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb la lb lc ld bi translated">出现错误时快速回滚，出现问题时逐步部署以赢得时间。</li></ul><h1 id="a345" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">可量测性</h1><p id="42f0" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">可伸缩性是描述系统是否能够处理负载增加的术语。在任何解决方案投入生产之前，技术团队经常使用的一个词是“性能测试”/“负载测试”。一般来说，有一些数字，如每秒请求数、数据库中读写的比率等，团队正在试图围绕这些数字进行优化。</p><ol class=""><li id="443b" class="kv kw hh ig b ih ii il im ip kx it ky ix kz jb lj lb lc ld bi translated">批处理:在这些系统中，我们关心吞吐量，即每秒处理的记录数量。例如，通宵运行的cron作业，我们关心处理一定数量的记录所花费的时间。</li><li id="08ab" class="kv kw hh ig b ih le il lf ip lg it lh ix li jb lj lb lc ld bi translated">在线系统:在这些系统中，我们关心处理需要多长时间。如果我们在网上购物，我们希望我们的推荐在几秒钟内出现，而不是等待。响应时间:-从客户端发送请求到返回结果所需的时间。一般来说，响应时间不是系统的一个具体数字，而是一个值的分布。</li></ol><blockquote class="kn ko kp"><p id="7ab2" class="ie if kq ig b ih ii ij ik il im in io kr iq ir is ks iu iv iw kt iy iz ja jb ha bi translated">延迟与响应时间:响应时间是客户端看到的，它还包括网络延迟、排队延迟，而延迟只是请求等待处理的持续时间。因此，响应时间是客户体验的更好反映。</p></blockquote><p id="7334" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Locust是一个开源工具，可以让您在API端点上执行性能测试，下面是一个端点响应时间统计数据的截图。需要我们注意的一件事是，结果是以百分位数汇总的。为什么这很重要？为什么不取个平均值呢？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lk"><img src="../Images/e51ba1445b4cec3c4315bce2864fe2c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NHF96sUA6CjwDbIRKpD95A.png"/></div></div></figure><p id="fc93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">50%文件= 250毫秒—这意味着50%的请求耗时不到250毫秒，其余50%的请求耗时超过250毫秒</p><p id="ebed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样的，</p><p id="b723" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">99%ile = 670毫秒—这意味着，在100个请求中，99个不到670毫秒，1个超过670毫秒</p><p id="e0ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">百分位数帮助我们量化用户体验，高百分位数的响应时间例如99.9百分位数的响应时间表明1000个请求中有1个请求超过了某个时间阈值。这是公司需要询问他们是否可以接受1000个请求中有一个响应较慢的地方。百分比通常用于服务水平目标(SLO)和服务水平协议(SLA ),它们定义了服务的预期性能和可用性。</p><h1 id="6e3f" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">可维护性</h1><p id="0e8c" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">有多少次你被要求在一个复杂的、有预设假设的遗留系统上工作，而且，曾经工作过的任何人都已经离开了公司。</p><p id="aa82" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可维护性是关于遵循最佳实践来增强简单性和可发展性(未来的变更)。例如，确保使用正确的抽象来简化系统，并且代码是模块化的，使用<a class="ae ku" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> DRY </a>。</p><p id="ba45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可维护性还包括一个方面——可操作性。使运营团队更容易保持系统运行。例如，监视系统的健康状况、追踪问题的根源、了解系统中的相互依赖性、用安全补丁更新系统(还记得最近的log4j安全漏洞吗？)等等。</p><p id="8a75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">简单并不总是意味着我们减少系统的功能。这只是意味着对于一个具有一定复杂性的问题，我们不会实现一个更复杂的解决方案。这尤其与数据科学领域相关，当模型无法处理所有的边缘情况时，就会投入大量代码来填补假设的空白。这种情况导致了一团乱麻，下一个员工必须解开，然后他/她决定是时候从头开始写了。</p></div><div class="ab cl lp lq go lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ha hb hc hd he"><p id="04ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总而言之，作为一名软件工程师，对你的系统进行压力测试，找出需要处理的错误，进行负载测试，确保你的客户不会被晾在一边，做一个更伟大的人，写出你的下一任愿意与之共事的代码，这是很重要的。</p><p id="74f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">继续测试&amp;继续编码！</p><p id="b8e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你想和我联系，你可以通过<a class="ae ku" href="https://www.linkedin.com/in/apurva-misra/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我</p></div></div>    
</body>
</html>