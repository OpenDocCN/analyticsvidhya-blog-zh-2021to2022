<html>
<head>
<title>Building Earthquake Prediction Model with PySpark and Bokeh</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用PySpark和Bokeh建立地震预测模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-earthquake-prediction-model-with-pyspark-and-bokeh-3b4577dc5a26?source=collection_archive---------0-----------------------#2021-09-11">https://medium.com/analytics-vidhya/building-earthquake-prediction-model-with-pyspark-and-bokeh-3b4577dc5a26?source=collection_archive---------0-----------------------#2021-09-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6210" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">概述</strong></p><p id="f0a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我将使用PySpark库、用于存储数据库的MongoDB和用于数据可视化的Bokeh构建一个预测地震的模型。该数据集包含数以千计的地震，按照时间、日期、纬度、经度、深度、震级等进行分类。数据集可以在这里<a class="ae jc" href="https://github.com/EBISYS/WaterWatch/blob/master/database.csv" rel="noopener ugc nofollow" target="_blank">下载。在这个项目中，我用的是Jupyter笔记本。</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/47853dade18f8faa7a443584777a40d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Rae7N_pAakAzDC4GitXLw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图1地震预测图</figcaption></figure><p id="1801" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">目的</strong></p><p id="a570" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该项目旨在帮助地球科学家根据1965年至2016年的历史数据预测即将发生的地震。我们用来创建模型的算法是RandomForestRegressor。为了测试模型的准确性，我使用1965年至2016年的数据集作为训练数据，使用2017年的数据集作为测试数据，然后用RMSE进行测量。如果RMSE是&lt;0.5 the model can be categorized as a good fit and reliable for predicting earthquakes.</p><p id="0489" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">设置和安装</strong></p><ol class=""><li id="0b71" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">首先，我们需要使用PySpark和MongoDB建立一个数据管道架构，你可以在<a class="ae jc" rel="noopener" href="/@vandanylubis/how-to-setup-pyspark-and-mongodb-for-building-data-pipeline-b528f56b30aa">我之前的文章</a>中找到完整的教程。</li><li id="f0d7" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">安装第三方库，如FindSpark、PySpark、pandas、NumPy、Bokeh、PyMongo和math。您可以使用命令pip install library-name或conda install library-name(如果您使用的是Anaconda提示符)来安装库。</li></ol><p id="e3de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">会议1:将PYSPARK与JUPYTER笔记本集成</strong></p><p id="975d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们完成所有的设置和安装之后，现在我们需要将PySpark与Jupyter笔记本集成，在这一步中我们需要findspark库。要做到这一点，我们可以简单地这样做:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kh"><img src="../Images/2b747a6acf1040e82ec7c4567db60718.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmSbkFiYoGefh_Zmri9vkA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图2集成PySpark和Jupyter笔记本</figcaption></figure><p id="4bc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有错误消息，我们可以转到ETL会话。</p><p id="1db3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">会议2:提取、转换、加载(ETL) </strong></p><p id="7e11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们在Jupyter Notebook中成功运行PySpark，现在我们就可以从本地目录加载数据集了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ki"><img src="../Images/45b904f8e83103f07638e2bc65f40a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bOvCYRNJsOjkskXQlJG1zQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图3加载数据集</figcaption></figure><p id="64dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">加载数据集后，我们可以使用df.take()预览列，这个函数有助于显示特定的行。在输出中，我们可以看到数据集包含许多列，因此我们不需要使用所有的列。所以我们使用df.drop()删除不需要的列</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kj"><img src="../Images/4ccd54df165db8fa85d3bc5ce17a7f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIGVQ8xpcx3pu1tr8iA0WQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图4下降柱</figcaption></figure><p id="75bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们只能看到我们需要操作的列，数据集现在更清晰了。在我们对列进行排序之后，现在我们需要做的事情是将“Year”列追加到数据帧中。在我们将它添加到dataframe之前，我们需要将“日期”列的类型转换为“时间戳”,因为“日期”的原始类型是“对象”,而“对象”类型是无法提取的。所以我们可以简单地这样做:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kk"><img src="../Images/8aa7614e9ee097dd348b81d6ddc97998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zOeATly5wHTme57rfkJjfw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图5添加年份字段</figcaption></figure><p id="bb7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们将“年”列加入数据框后，现在我们可以计算每年发生多少次地震。我们可以使用groupBy()和count():</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kl"><img src="../Images/bb99a1fcd4737148e9d860f2df7fc0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A8_KIer6Ao03EB_Mv6JWDA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图6统计每年发生的地震</figcaption></figure><p id="e6b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据数据框架，我们可以看到year列没有按顺序排序，稍后我们可以处理这个问题。</p><p id="30e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们统计了一年的地震后，现在我们可以检查列中每个数据的类型，如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es km"><img src="../Images/388985ceafe08623f14c8476e57e7f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gDbQx6B0wbAho9qlGIP2bQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图7检查数据列类型</figcaption></figure><p id="6f24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们从输出中看到的，列的大部分类型是一个不能连接的字符串。为此，我们需要使用cast()将一些列从字符串转换成数字类型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kn"><img src="../Images/1046896434dcae38f9d6a7f4dbe50a07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gt2UGEWUdJhBSayH0HniJQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图8将字符串列转换为数字列</figcaption></figure><p id="0c0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们将字符串列转换为数字之后，现在我们可以将df_max和df_avg连接到一个名为df_quake_freq的新变量中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ko"><img src="../Images/b7b80ac5ebd04c6c968190cb6831c8ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhkxUddz5curxb3XE9jeiQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图9将df_max和df_avg加入df_quake_freq</figcaption></figure><p id="dd32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果这些列已经成功连接，接下来我们可以做的就是从数据帧中删除所有缺失的值。我们可以使用dropna()。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/105af632ae042a6fb66f25ae0a8c4538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FjoOGetC2YQjfWcsxq6g5Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图10移除空值</figcaption></figure><p id="2eb1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们移除了空值之后，现在数据已经可以使用了，接下来我们需要做的是将数据保存到MongoDB中。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kq"><img src="../Images/6245d064be7d8639f70b775eca2e1ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*joaqCt-3q5kzmyK0eRmObA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图11将清理后的数据保存到MongoDB中</figcaption></figure><p id="dec4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了确保数据帧被正确地保存到MongoDB中，我们可以打开NoSQLBooster并扩展Quake数据库，如果您看到这一点，这意味着数据已经被成功存储，在这一步中忽略pred_results。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kr"><img src="../Images/c78d0b8a67985cf7bc4008dc433da9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*eAXC6ATmAjYCjco5SImjUQ.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图12 quake.freq和quakes保存成功</figcaption></figure><p id="3248" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在训练数据已经保存之后，我们可以做的下一件事是加载测试数据。你可以从<a class="ae jc" href="https://github.com/EBISYS/WaterWatch/blob/master/query.csv" rel="noopener ugc nofollow" target="_blank">这里</a>下载测试数据。文件名为query.csv，其内容与训练数据相同，但不同之处在于其范围仅为2017年。</p><p id="2f83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，一旦你下载了文件，你现在可以用Jupyter笔记本加载测试和训练数据了。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ks"><img src="../Images/900f9ebcd059729542d55de88864e6e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hMwAwjNsDnLS_cHKz7NDHA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图13加载测试和训练数据</figcaption></figure><p id="2f35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在加载了测试和训练数据之后，接下来我们可以做的事情是选择我们想要的列并重命名它们。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/06e7424ce846da54d34b5cf9bd678e76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ej1r9FftWKJV_jVz4ZezoA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图14从测试数据中选择并重命名我们需要的字段</figcaption></figure><p id="93d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，我们正在执行与之前对训练数据所做的相同的一组过程，因此现在我们检查测试数据中的字段类型，并将其从字符串转换为数字。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ku"><img src="../Images/a3e661239add0029f388ef422425f650.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coOBNJKs6NNsB9JpboW_Mw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图15将字符串数据转换成数字</figcaption></figure><p id="563b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们需要的所有列都转换成数字之后，现在我们可以创建一个训练和测试数据帧，并使用dropna()删除其中所有缺失的值。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kv"><img src="../Images/74816f171607016842702e61bf972b9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5qXdwjxWY-8mcslqV50cHg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图16移除空值</figcaption></figure><p id="ccd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们移除了所有的空值，数据帧变得整洁，我们就可以进入机器学习阶段了。</p><p id="8655" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第三场:机器学习</strong></p><p id="4ee4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们转移到机器学习会话，在这个过程中，我们将导入一些必要的库来创建模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/8e3a32342599dee00a7ea4b78593af63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l7XJvdmcmiD-CPk7oWbtQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图17导入ML库</figcaption></figure><p id="012f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">导入我们需要的库后，我们可以创建模型。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kx"><img src="../Images/41b743f6e47c1945e7781ef026e4be05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXrbpPjTgVEN9F_i5PRc3w.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图18预测模型</figcaption></figure><p id="fe7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的语法中我们可以看出，为了进行预测，我们需要将纬度、经度和深度数据聚集到一个向量中，并将其存储到一个名为features的新列中。之后，预测的结果会自动存储在预测列中。我们可以将预测值与测试数据中的值进行比较，两者之间的差异是可以接受的。为了验证该模型的可靠性，我们需要使用RMSE来测试其准确性。如果RMSE低于0.5，这意味着模型是一个很好的拟合，我们可以用它来预测。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ky"><img src="../Images/ddb24424fa6bf6d6f41b5606df459cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xr2FHOs9r-AxZN6dHH10Qg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图19 RMSE</figcaption></figure><p id="d457" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们计算RMSE之后，结果是0.402274，这意味着该模型是很好的拟合和可靠的。</p><p id="7b3d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以做的下一件事是创建一个预测数据集，删除我们不需要的列，并重命名一些列。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kz"><img src="../Images/b01699441e720fcb30b0b545153668a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KJlBFC0GdZcVwBksC1zkrg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图20预测数据集</figcaption></figure><p id="d828" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">会议4:数据可视化</strong></p><p id="686d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在是有趣的部分，因为我们可以通过图看到我们的模型。在我们开始创建图之前，我们需要导入一些库。其中一个库是散景，它是可视化模型的重要部分。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es la"><img src="../Images/e317eb6d20c3f7ab28bc6fbefbe02561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhee3-losifPf9iuKs77kg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图21导入库以可视化数据</figcaption></figure><p id="6499" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在库被导入后，我们可以做的下一件事是创建一个定制的read函数。这部分对于从MongoDB读取数据很重要。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lb"><img src="../Images/24137e6847e56f1b5037b1251edacd5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qadPz7jre8qfrkwzGnJkog.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图22从MongoDB读取数据的自定义读取函数</figcaption></figure><p id="76f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们提取2016年的数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lc"><img src="../Images/0904fb93c79bf9caf514213e7abac6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vLC2l020EyDea7Y-5iPFDw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图23 2016年的数据</figcaption></figure><p id="39ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后输入output_notebook来验证BokehJS是否加载到Jupyter Notebook中。</p><p id="79f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，在我们创建了2016年的数据集之后，我们现在可以做的下一件事是创建一个函数来设计我们的绘图。要设置绘图样式，只需执行以下操作:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ld"><img src="../Images/4cbc33f28185d838d945b1e07bd12737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hCtbS377MGSRVIGtvQ8W0Q.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图24造型图</figcaption></figure><p id="60fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们创建了一个自定义样式函数之后，现在我们可以创建Geo Map plot。使用Geo Map，我们可以看到我们的模型应用在地球地图上。语法很长，所以我引用下面的代码:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="616e" class="lj lk hh lf b fi ll lm l ln lo"># Create the Geo Map plot<br/>def plotMap():<br/> lat = df_quakes_2016[‘Latitude’].values.tolist()<br/> lon = df_quakes_2016[‘Longitude’].values.tolist()<br/> <br/> pred_lat = df_quake_pred[‘Latitude’].values.tolist()<br/> pred_lon = df_quake_pred[‘Longitude’].values.tolist()<br/> <br/> lst_lat = []<br/> lst_lon = []<br/> lst_pred_lat = []<br/> lst_pred_lon = []<br/> <br/> i=0<br/> j=0<br/> <br/> # Convert lat and lon values into merc_projection format<br/> for i in range (len(lon)):<br/> r_major = 6378137.000<br/> x = r_major * math.radians(lon[i])<br/> scale = x/lon[i]<br/> y = 180.0/math.pi * math.log(math.tan(math.pi/4.0 +<br/> lat[i] * (math.pi/180.0)/2.0)) * scale<br/> <br/> lst_lon.append(x)<br/> lst_lat.append(y)<br/> i += 1<br/> <br/> # Convert predicted lat and long values into merc_projection format<br/> for j in range (len(pred_lon)):<br/> r_major = 6378137.000<br/> x = r_major * math.radians(pred_lon[j])<br/> scale = x/pred_lon[j]<br/> y = 180.0/math.pi * math.log(math.tan(math.pi/4.0 +<br/> pred_lat[j] * (math.pi/180.0)/2.0)) * scale<br/> <br/> lst_pred_lon.append(x)<br/> lst_pred_lat.append(y)<br/> j += 1<br/> <br/> df_quakes_2016[‘coords_x’] = lst_lat<br/> df_quakes_2016[‘coords_y’] = lst_lon<br/> df_quake_pred[‘coords_x’] = lst_pred_lat<br/> df_quake_pred[‘coords_y’] = lst_pred_lon<br/> <br/> # Scale the circles<br/> df_quakes_2016[‘Mag_Size’] = df_quakes_2016[‘Magnitude’] * 4<br/> df_quake_pred[‘Mag_Size’] = df_quake_pred[‘Pred_Magnitude’] * 4<br/> <br/> # Create datasources for our ColumnDataSource object<br/> lats = df_quakes_2016[‘coords_x’].tolist()<br/> longs = df_quakes_2016[‘coords_y’].tolist()<br/> mags = df_quakes_2016[‘Magnitude’].tolist()<br/> years = df_quakes_2016[‘Year’].tolist()<br/> mag_size = df_quakes_2016[‘Mag_Size’].tolist()<br/> <br/> pred_lats = df_quake_pred[‘coords_x’].tolist()<br/> pred_longs = df_quake_pred[‘coords_y’].tolist()<br/> pred_mags = df_quake_pred[‘Pred_Magnitude’].tolist()<br/> pred_year = df_quake_pred[‘Year’].tolist()<br/> pred_mag_size = df_quake_pred[‘Mag_Size’].tolist()<br/> <br/> # Create column datasource<br/> cds = ColumnDataSource(<br/> data=dict(<br/> lat=lats,<br/> lon=longs,<br/> mag=mags,<br/> year=years,<br/> mag_s=mag_size<br/> )<br/> )<br/> <br/> pred_cds = ColumnDataSource(<br/> data=dict(<br/> pred_lat=pred_lats,<br/> pred_long=pred_longs,<br/> pred_mag=pred_mags,<br/> year=pred_year,<br/> pred_mag_s=pred_mag_size<br/> )<br/> )<br/> <br/> # Tooltips<br/> TOOLTIPS = [<br/> (“Year”, “ <a class="ae jc" href="http://twitter.com/year" rel="noopener ugc nofollow" target="_blank">@year</a>”),<br/> (“Magnitude”, “ <a class="ae jc" href="http://twitter.com/mag" rel="noopener ugc nofollow" target="_blank">@mag</a>”),<br/> (“Predicted Magnitude”, “ <a class="ae jc" href="http://twitter.com/pred_mag" rel="noopener ugc nofollow" target="_blank">@pred_mag</a>”)<br/> ]<br/> <br/> # Create figure<br/> p = figure(title = ‘Earthquake Map’,<br/> plot_width=2300, plot_height=450,<br/> x_range=(-2000000, 6000000),<br/> y_range=(-1000000, 7000000),<br/> tooltips=TOOLTIPS)<br/> <br/> p.circle(x=’lon’, y=’lat’, size=’mag_s’, fill_color=’#cc0000', fill_alpha=0.7,<br/> source=cds, legend=’Quakes 2016')<br/> <br/> # Add circles for our predicted earthquakes<br/> p.circle(x=’pred_long’, y=’pred_lat’, size=’pred_mag_s’, fill_color=’#ccff33', fill_alpha=7.0,<br/> source=pred_cds, legend=’Predicted Quakes 2017')<br/> <br/> tile_provider = get_provider(Vendors.CARTODBPOSITRON)<br/> p.add_tile(tile_provider)<br/> <br/> # Style the map plot<br/> # Title<br/> p.title.align=’center’<br/> p.title.text_font_size=’20pt’<br/> p.title.text_font=’serif’<br/> <br/> # Legend<br/> p.legend.location=’bottom_right’<br/> p.legend.background_fill_color=’black’<br/> p.legend.background_fill_alpha=0.8<br/> p.legend.click_policy=’hide’<br/> p.legend.label_text_color=’white’<br/> p.xaxis.visible=False<br/> p.yaxis.visible=False<br/> p.axis.axis_label=None<br/> p.axis.visible=False<br/> p.grid.grid_line_color=None<br/> <br/> <br/> show(p)<br/> <br/>plotMap()</span></pre><p id="88ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行语法后，现在您会看到带有圆点的地图输出。绿点代表2017年预测的地震，红点代表2016年的地震。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lp"><img src="../Images/59bff5cecb9e01e1e53932f685b1fb76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bjR-MDHUFSQiUH3mWw187w.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图25地震地图</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/cfaac41bd02016c4ffb78d27dd518c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kXu0fw9SaTu_Ad0WOuNEhQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图26 2017年印度洋预测震级预览</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/5a6815ffcc20221e8b6b5b3c61ab5ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*blNFKXcNrCJZrbT0QgTMGg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图27 2016年日本地震前瞻</figcaption></figure><p id="30c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，在我们创建了地理图之后，接下来我们可以做的是创建一个条形图。在这个柱状图中，我们可以看到每年地震的频率。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lr"><img src="../Images/7411015435edb9978950e0045582bd62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EFYc1P_E3S3ADOrfO8qofA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图28创建条形图</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/09509d5e15333c79431c3430e9d891b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uiDGqDAWQCF33vJvi-qkJw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图29按年份划分的地震频率</figcaption></figure><p id="f1cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">柱状图告诉我们每年地震的趋势，根据图表我们可以看到2010年是地震发生次数最多的一年。</p><p id="4496" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们创建了地震频率的条形图之后，现在我们将创建一个折线图来了解每年的震级趋势。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lt"><img src="../Images/c88386518d29437d7deb078f70a2e2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*afLIM4JYu7nRDP6TUEDOWw.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图30创建幅度图</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/a73f57853b938be4f0c8da048e22e65b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nA5RzI-q7a5DRZSGH0FqAA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图31各年最大和平均震级趋势</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/824bb1d24d5b62ab4f09050e503b9d84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XUl7ITZbYjrkXAExkiDQVg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">图32按年份划分的最高震级</figcaption></figure><p id="eaf5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从线图中我们可以看出，如果我们调查2011年发生的里氏9.1级地震与1965年至2016年间最高震级的<a class="ae jc" href="https://en.wikipedia.org/wiki/2011_T%C5%8Dhoku_earthquake_and_tsunami" rel="noopener ugc nofollow" target="_blank"> 2011年北府地震和海啸</a>有关，我们就可以知道。</p><p id="6987" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，这就是我们如何预测地震和了解每年地震趋势的教程。</p><p id="276b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇文章有助于增加我们的知识，特别是在使用数据预测和查看趋势方面。</p><p id="f8e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢您的阅读！</p><p id="0f31" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编制人:Vandany Lubis</p><p id="11e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">指导:<a class="ae jc" href="https://github.com/EBISYS" rel="noopener ugc nofollow" target="_blank"> EBISYS </a></p></div></div>    
</body>
</html>