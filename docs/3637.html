<html>
<head>
<title>Spotify Music Data Analysis: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Spotify音乐数据分析:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spotify-music-data-analysis-part-2-3a69ae0f7f01?source=collection_archive---------4-----------------------#2021-07-15">https://medium.com/analytics-vidhya/spotify-music-data-analysis-part-2-3a69ae0f7f01?source=collection_archive---------4-----------------------#2021-07-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><h2 id="e7ff" class="hf hg hh bd b fp hi hj hk hl hm hn dx ho translated" aria-label="kicker paragraph">了解你自己系列—</h2><div class=""/><div class=""><h2 id="6b1c" class="pw-subtitle-paragraph in hq hh bd b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je dx translated">数据清理和预处理</h2></div><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jf"><img src="../Images/ef7097e88460bae358ddaf4794bfed8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bgJ-iGh7VmV1Lw24"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated"><a class="ae jv" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">摄粘土堤</a>上<a class="ae jv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">的Unsplash </a></figcaption></figure><p id="6a00" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在开始数据分析之前，有必要检查数据并解决其中存在的任何混乱，以获得准确的结果。</p><p id="a33d" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在第一部分中，数据集是使用Spotify API收集的。这些数据是我从开始在Spotify上听音乐以来近两年的数据。</p><p id="d17a" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在这个系列的这一部分，我将寻找数据中出现的任何偏差，这些偏差可能会扭曲我们的结果。接下来是数据预处理，以便根据需要转换数据。</p><p id="104f" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">本文使用的代码来自我的<a class="ae jv" href="https://github.com/pragyy/my-music-analysis" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中的笔记本<strong class="jy hr"><em class="ks">data _ cleaning . ipynb</em></strong>。看看吧！</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="aa9d" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">目录</h1><ol class=""><li id="a11a" class="ls lt hh jy b jz lu kc lv kf lw kj lx kn ly kr lz ma mb mc bi translated">导入数据</li><li id="828a" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">删除重复的列</li><li id="afe6" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">删除重复的行</li><li id="3dbc" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">零检查</li><li id="7553" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">数据格式检查</li><li id="7e85" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">价值检查</li><li id="ebeb" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">导出数据</li><li id="7752" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">结论</li><li id="bdcd" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr lz ma mb mc bi translated">链接到本系列的其他部分</li></ol></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="9991" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">导入数据</h1><p id="5071" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">首先，让我们导入数据。所以，我有两个数据集——歌曲和播放列表。名为<strong class="jy hr"> <em class="ks"> final </em> </strong>的CSV文件存储所有先前播放的歌曲的历史和特征信息。播放列表数据存储在名为<strong class="jy hr"> <em class="ks">播放列表</em> </strong>的CSV文件中，该文件给出了播放列表信息以及每个播放列表中所有歌曲的详细信息。</p><p id="0367" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">可以使用<code class="du ml mm mn mo b">read_csv()</code>加载数据。在<code class="du ml mm mn mo b">read_csv</code>中传递的参数是数据文件路径。此外，可以使用<code class="du ml mm mn mo b">head()</code>功能查看数据的前几行。</p><p id="505b" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">因此将歌曲和播放列表数据集分别加载到两个不同的数据帧<strong class="jy hr"> <em class="ks"> df1 </em> </strong>和<strong class="jy hr"> <em class="ks"> df2 </em> </strong>中。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="73f0" class="mt lb hh mo b fi mu mv l mw mx"><em class="ks"># loading the song file</em><br/>df1 = pd.read_csv('spotify data scraping\output<strong class="mo hr">\\</strong>final.csv')<br/>df1.head()</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es my"><img src="../Images/1582f21681b6743766b27714df276218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wtJ2haz0kzJgaV9wlkZsSg.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df1.head()的结果</figcaption></figure><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="6d93" class="mt lb hh mo b fi mu mv l mw mx"><em class="ks"># loading the playlist data file</em><br/>df2 = pd.read_csv('spotify data scraping\playlist.csv')<br/>df2.head()</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es mz"><img src="../Images/a0e8a0ef736eef64e71fc6fe9b257f14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FVY0nSVG3KDvTOJr-oyHAw.png"/></div></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df2.head()的结果</figcaption></figure></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="b846" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">删除重复的列</h1><p id="2250" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">现在，为了按列来整理数据，让我们快速浏览一下上面的数据快照，我们可以看到有一些不需要的列，如<strong class="jy hr"> <em class="ks">未命名:0。</em> </strong></p><p id="a8b4" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">可以使用以下代码请求数据列的完整列表:</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="6666" class="mt lb hh mo b fi mu mv l mw mx">df1.columns</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es na"><img src="../Images/f0320b23000c6eff6ef45fe9032f9aba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*VThnOc5XmkP6jUrMkjIiUQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df1中的列</figcaption></figure><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="c09c" class="mt lb hh mo b fi mu mv l mw mx">df2.columns</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nb"><img src="../Images/bb541a8d4987b312ffb3e512919935e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*aBuG92edLbKR-spGx9JJ5g.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df2中的列</figcaption></figure><p id="ffda" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">粗略地看一下，可以确认这些属性中的许多在分析中是不需要的。因此，删除这些不必要的列以释放空间并减少处理时间是非常重要的。</p><p id="03c2" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">可以使用<code class="du ml mm mn mo b">drop()</code>函数删除数据列，并提供列名列表作为参数。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="baaf" class="mt lb hh mo b fi mu mv l mw mx">df1 = df1.drop(columns=['Unnamed: 0', 'name', 'endTime', 'type', 'uri', 'track_href', 'analysis_url', 'duration_ms' ])<br/>df2 = df2.drop(columns=['Unnamed: 0', 'id', 'spotify_id', 'list_id' ])</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="004a" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">删除重复的行</h1><p id="5f5f" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">像任何人一样，我听过一首歌很多次。因此，数据集中有同一首歌曲的多个条目。我需要的信息包括总播放时间、一首音乐的播放次数以及更多类似的数据，所以我不会删除重复的内容，否则我会丢失这些信息，数据搜索也不会产生正确的结果。</p><p id="600b" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">另一方面，不需要复制来检查所有曲调的特性。因此，为了处理这个问题，我将创建一个新的数据帧，通过删除重复的行来存储唯一的歌曲及其属性。</p><p id="489f" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">首先，在删除重复项之前，让我们看看行数。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="b243" class="mt lb hh mo b fi mu mv l mw mx"><em class="ks"># shape before dropping duplicate rows</em><br/>df1.shape<br/>df2.shape</span></pre><p id="a44e" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">上述代码的输出分别是(8413，17)和(342，18)。因此歌曲数据中有8413行，播放列表数据中有342行。</p><p id="f971" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">为了删除重复的行，我将使用<code class="du ml mm mn mo b">drop_duplicates()</code>函数。对于函数参数，提到<code class="du ml mm mn mo b">keep = "Last"</code>，因为需要这些行的最新实例。此外，为了定义查找重复项的规则，在名为<code class="du ml mm mn mo b">subset</code>的函数中传递了一个参数。它以列的名称为基础，重复项将被识别和删除，如果没有提到，那么该函数将从数据中删除完全相同的重复项。因此，对于歌曲数据，可以基于轨道名称移除重复项，此外，对于播放列表数据集，可以消除属于同一播放列表的歌曲的多个条目。换句话说，基于<em class="ks">列表名称</em>(播放列表名称)和<em class="ks">歌曲名称</em>。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="4246" class="mt lb hh mo b fi mu mv l mw mx"># we are keeping the last instance instead of the first as we need the latest entry of the song</span><span id="339f" class="mt lb hh mo b fi nc mv l mw mx">df1_new = df1.drop_duplicates( subset = 'trackName', keep = 'last')<br/>df2_new = df2.drop_duplicates( subset = ['list_name', 'song_name'], keep = 'last')</span></pre><p id="b7c3" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在删除不需要的行之后，我将它们存储在不同的数据帧中，以便随后可以将它们导出到一个新的CSV文件中。</p><p id="9cb4" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">并且得到的数据集的形状分别是(2135，17)和(242，18)。</p><p id="092d" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">最后，我有4个数据帧<strong class="jy hr"> <em class="ks"> df1、df2 </em> </strong>用于存储原始歌曲和播放列表数据，还有<strong class="jy hr"> <em class="ks"> df1_new、df2_new </em> </strong>用于存储经过重复数据删除的歌曲和播放列表数据。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="416e" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">零检查</h1><p id="38b4" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">空单元格是最常见和预期的数据清理问题。因此，在消除重复行之后，检查任何丢失的数据点是最重要的步骤。</p><p id="8fe6" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">在python dataframe中，可以使用<code class="du ml mm mn mo b">isnull()</code>检查空单元格，进一步使用<code class="du ml mm mn mo b">sum()</code>函数获得空值的总和。我这样做是因为<code class="du ml mm mn mo b">isnull()</code>为每个单元格返回真或假的布尔结果，并且滚动每一行寻找空白单元格是一项相当乏味的任务。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nd"><img src="../Images/ce441bbeeaec80d005e02dd6104b6d9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*dnKy-5d8LpZugLTPnwZDEA.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df1的空值检查输出</figcaption></figure><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="55e9" class="mt lb hh mo b fi mu mv l mw mx">df1.isnull().sum()</span></pre><p id="ff48" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">上面代码行的输出显示空单元格的总和为零。因此，在歌曲的数据集中没有空值需要处理。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ne"><img src="../Images/1b72785f7b08db1a9f4a056764f7b7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*6-1d8lDjB3AsWcPJo1BK8A.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df2的零校验输出</figcaption></figure><p id="d5bb" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">类似地，我将对播放列表数据执行null检查。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="be7f" class="mt lb hh mo b fi mu mv l mw mx">df2.isnull().sum()</span></pre><p id="f8f7" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">输出表明有一个空值。</p><p id="d40a" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">因此，我仔细阅读了数据集，发现我在Spotify中创建了一个没有任何歌曲的播放列表。因此，在输出中，没有空的<strong class="jy hr"> <em class="ks"> list_name </em> </strong>值，但是，它的其余值为空，因为其中没有歌曲。因此，为了处理这个问题，最简单的解决方案是删除该播放列表条目，因为它不包含任何有用的信息。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="ce50" class="mt lb hh mo b fi mu mv l mw mx"># playlist data<br/>df2.dropna(subset=['song_id', 'song_name', 'artist', 'popularity', 'release_date', 'energy', 'liveness', 'tempo', 'speechiness', 'acousticness', 'instrumentalness', 'danceability', 'duration_ms', 'loudness', 'valence', 'mode', 'key'] , inplace = <strong class="mo hr">True</strong>)</span><span id="a949" class="mt lb hh mo b fi nc mv l mw mx"># deduplicated playlist data<br/>df2_new.dropna(subset=['song_id', 'song_name', 'artist', 'popularity', 'release_date', 'energy', 'liveness', 'tempo', 'speechiness', 'acousticness', 'instrumentalness', 'danceability', 'duration_ms', 'loudness', 'valence', 'mode', 'key'] , inplace = <strong class="mo hr">True</strong>)</span></pre><p id="998d" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">删除空行后，再次执行空检查以进行验证。</p><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nf"><img src="../Images/967e5b04c7dbb52e40ae073c865849fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*POvbIL0_xMH4Ea_LtL0uWQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">播放列表数据的空检查</figcaption></figure><p id="4b8b" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">从输出可以得出结论，现在没有空行了。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="ac57" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">数据格式检查</h1><p id="94dc" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">我现在将检查属性是否有数据类型不匹配，因为有时浮点值被读取为字符串，字符串值被读取为数字格式，还有许多这样的数据不匹配。</p><p id="1e0d" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">对于这个测试，只需使用<code class="du ml mm mn mo b">dtypes</code>请求所有列的数据类型，并验证所有数据类型是否都正确。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="8761" class="mt lb hh mo b fi mu mv l mw mx">df1.dtypes</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ng"><img src="../Images/afb85a44a9349d93ae807f35db510121.png" data-original-src="https://miro.medium.com/v2/resize:fit:418/format:webp/1*4GyNpTX5gPIM-y7uR5ycNQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df1.dtypes的输出</figcaption></figure><p id="f54b" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">从上面的输出可以推断，没有数据不匹配，所有数据都以各自的数据类型格式存储。</p><p id="78db" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">类似地，我检查了播放列表数据集的数据类型。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="46f5" class="mt lb hh mo b fi mu mv l mw mx">df2.dtypes</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nh"><img src="../Images/18da0e16462e324f2e93fc74eb39e3f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:434/format:webp/1*7dy0sNCXIY65uviXRmqC9Q.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df2.types的输出</figcaption></figure><p id="5013" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">这里也可以验证没有数据不匹配。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="dee6" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">价值检查</h1><p id="9a0d" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">在这一步中，我将检查单元格内的内容是否正确。因此，通过找到数值的最大值和最小值，我们可以确定这些值是否在可接受的范围内。</p><p id="73fa" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">所以我将分别使用<code class="du ml mm mn mo b">.max()</code>和<code class="du ml mm mn mo b">.min()</code>请求列的最大值和最小值。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="ff31" class="mt lb hh mo b fi mu mv l mw mx">df1.max(axis=0)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es ni"><img src="../Images/6f53059e20b84094261c4f7caddd2520.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/1*k3GzBVMpvjSlSDQpZ7BPtQ.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">d1.max()的输出</figcaption></figure><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="0085" class="mt lb hh mo b fi mu mv l mw mx">df1.min(axis=0)</span></pre><figure class="jg jh ji jj fd jk er es paragraph-image"><div class="er es nj"><img src="../Images/0f6791dc62fc7964b68900bd68fbe2a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*P925hbK4rtxOgaBZuGoaBg.png"/></div><figcaption class="jr js et er es jt ju bd b be z dx translated">df1.min的输出()</figcaption></figure><p id="8553" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">上面的代码表明歌曲数据集中没有数据值问题。所有数值都在可接受的范围内。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="eaef" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">导出数据</h1><p id="66b2" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">我已经识别并纠正了所有不一致的数据。现在所有的数据都被清理和处理，因此可以使用<code class="du ml mm mn mo b">to_csv()</code>将其导出为新的CSV文件。</p><pre class="jg jh ji jj fd mp mo mq mr aw ms bi"><span id="9493" class="mt lb hh mo b fi mu mv l mw mx">df1.to_csv('data\song_data.csv') df1_new.to_csv('data\distinct_song.csv') df2.to_csv('data\playlist_data.csv') df2_new.to_csv('data\distinct_playlist.csv')</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="2755" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">结论</h1><p id="dfa8" class="pw-post-body-paragraph jw jx hh jy b jz lu ir kb kc lv iu ke kf mi kh ki kj mj kl km kn mk kp kq kr ha bi translated">所有的数据异常和困惑被处理。</p><p id="314b" class="pw-post-body-paragraph jw jx hh jy b jz ka ir kb kc kd iu ke kf kg kh ki kj kk kl km kn ko kp kq kr ha bi translated">现在，在下一部分中，我将执行数据探索和分析。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="44fd" class="la lb hh bd lc ld le lf lg lh li lj lk iw ll ix lm iz ln ja lo jc lp jd lq lr bi translated">链接到本系列的其他部分</h1><ul class=""><li id="77ef" class="ls lt hh jy b jz lu kc lv kf lw kj lx kn ly kr nk ma mb mc bi translated"><a class="ae jv" rel="noopener" href="/@vermapragya/spotify-music-data-analysis-part-1-c8457bfc53a"> Spotify音乐数据分析第1部分:数据收集</a></li><li id="8e0d" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr nk ma mb mc bi translated">Spotify音乐数据分析第2部分:数据清理和预处理</li><li id="02aa" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr nk ma mb mc bi translated"><a class="ae jv" rel="noopener" href="/@vermapragya/spotify-music-data-analysis-part-3-9097829df16e"> Spotify音乐数据分析第3部分:数据可视化</a></li><li id="cdfd" class="ls lt hh jy b jz md kc me kf mf kj mg kn mh kr nk ma mb mc bi translated"><a class="ae jv" rel="noopener" href="/@vermapragya/spotify-music-data-analysis-part-4-4016e2954795"> Spotify音乐数据分析第4部分:聚类分析</a></li></ul></div></div>    
</body>
</html>