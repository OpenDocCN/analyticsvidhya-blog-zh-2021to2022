<html>
<head>
<title>Building A Monte Carlo Method Stock Price Simulator With Geometric Brownian Motion And Bootstrap Sampling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用几何布朗运动和Bootstrap抽样建立蒙特卡罗方法股票价格模拟器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-monte-carlo-method-stock-price-simulator-with-geometric-brownian-motion-and-bootstrap-e346ff464894?source=collection_archive---------1-----------------------#2021-01-14">https://medium.com/analytics-vidhya/building-a-monte-carlo-method-stock-price-simulator-with-geometric-brownian-motion-and-bootstrap-e346ff464894?source=collection_archive---------1-----------------------#2021-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3a0b9eedd77eab1acf9ac12f4804e631.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*m_JHmCdCgSshTb8M.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://knowyourmeme.com/memes/stonks" rel="noopener ugc nofollow" target="_blank">https://knowyourmeme.com/memes/stonks</a></figcaption></figure><h1 id="4e41" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">摘要</h1><p id="4c55" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated"><em class="kr">我用Python Flask开发了一个web应用程序，允许你使用一种叫做蒙特卡罗模拟的方法来模拟未来的股票价格走势，有两种“口味”可供选择:几何布朗运动(GBM)和Bootstrapped Sampling。</em></p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="kw kx l"/></div></figure><div class="ky kz ez fb la lb"><a href="https://www.stonksforecast.online/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">z的股票模拟器</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">图片来源:KnowYourMeme.com嗨！我是Z，这是一个简单的股票价格预测网络应用程序，我是为了好玩而开发的…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">www.stonksforecast.online</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp io lb"/></div></div></a></div><p id="0fa5" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><em class="kr">虽然我可能会在下面包含一些编程代码，但这篇文章不会是一篇“代码教程”,而是更侧重于GBM和Bootstrap抽样背后的基本理论。</em></p><p id="c8d1" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><em class="kr">然原生*。*py和一个Jupyter笔记本版本的相同代码可以在下面的GitHub链接上找到，如果你想深入了解的话。</em></p><div class="ky kz ez fb la lb"><a href="https://github.com/ZhijingEu/StockSimulatorFlaskApp" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">ZhijingEu/StockSimulatorFlaskApp</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">这是一个股票分析Python Flask web应用程序，它允许你使用…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">github.com</p></div></div><div class="lk l"><div class="lv l lm ln lo lk lp io lb"/></div></div></a></div><p id="34a9" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><strong class="jv hj">警告！我不是任何类型的投资大师，所以我强烈建议你不要把这篇文章作为你投资决策的(唯一)依据。</strong></p><h1 id="97af" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">概述</h1><ul class=""><li id="9691" class="lw lx hi jv b jw jx ka kb ke ly ki lz km ma kq mb mc md me bi translated"><a class="ae iu" href="#376a" rel="noopener ugc nofollow"> <strong class="jv hj">几何布朗运动</strong></a><strong class="jv hj">【GBM】</strong></li><li id="559d" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#e429" rel="noopener ugc nofollow"> <strong class="jv hj">蒙特卡洛模拟</strong> </a></li><li id="1fb2" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#0450" rel="noopener ugc nofollow"> <strong class="jv hj">利用GBM </strong> </a>模拟单只股票</li><li id="93a9" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#b49a" rel="noopener ugc nofollow"> <strong class="jv hj">利用GBM </strong> </a>模拟投资组合中的多只股票</li><li id="a03a" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#f6d0" rel="noopener ugc nofollow"> <strong class="jv hj">另一种使用自举抽样的方法</strong> </a></li><li id="2d8e" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#7d0e" rel="noopener ugc nofollow"> <strong class="jv hj"> Bootstrap vs GBM:哪个效果更好？</strong> </a></li><li id="07aa" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><a class="ae iu" href="#05ad" rel="noopener ugc nofollow"> <strong class="jv hj">结论</strong> </a></li></ul><h1 id="1058" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">几何布朗运动</h1><p id="2a67" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">你可能对高中物理中的布朗运动很熟悉。这是空气粒子相互碰撞时看似随机的运动。虽然我们可能无法描述单个粒子的行为，但物理学和统计学让我们有能力描述整个系统结束的可能性。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/38c338bdb55518a58f12efe5c5c366a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/0*rp20rUJF2maeFl_l.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://en.wikipedia.org/wiki/Brownian_motion" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="64ab" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">同样，几何布朗运动是一个资产回报模型，其中资产/股票/投资的价格(或回报)可以建模为随机游走(即一个<em class="kr">过程，其中股票价格的变化具有相同的分布并且相互独立。因此，它假定股票价格或市场的过去运动或</em> <a class="ae iu" href="https://www.investopedia.com/terms/t/trend.asp" rel="noopener ugc nofollow" target="_blank"> <em class="kr">趋势</em> </a> <em class="kr">不能用于预测其未来运动(来源:Investopedia) </em></p><p id="6d4e" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">与其一头扎进一些相当复杂的随机微分方程，不如直观地了解它是如何工作的</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/188a7fe5b957a9e4e33bcb3e3350e968.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*j3bYh_aQSZ-TtnQFpa52fA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:改编自<a class="ae iu" href="https://www.investopedia.com/articles/07/montecarlo.asp" rel="noopener ugc nofollow" target="_blank">https://www.investopedia.com/articles/07/montecarlo.asp</a></figcaption></figure><p id="7eff" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><strong class="jv hj"> <em class="kr">其中:</em> </strong></p><ul class=""><li id="5e21" class="lw lx hi jv b jw lq ka lr ke mm ki mn km mo kq mb mc md me bi translated"><em class="kr">s</em>ₜ<em class="kr">=股价</em></li><li id="579e" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="kr">ds</em>ₜ<em class="kr">=股票价格的变化</em></li><li id="096e" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="kr">μ=预期收益</em></li><li id="002a" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="kr">σ=收益的标准差</em></li><li id="6973" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="kr">w</em>ₜ=<em class="kr"/><a class="ae iu" href="https://en.wikipedia.org/wiki/Wiener_process" rel="noopener ugc nofollow" target="_blank"><em class="kr">维纳过程</em> </a> <em class="kr">随机变量其中t时间内的增量具有以零为中心的正态分布n(即W </em> ₜ - <em class="kr"> W </em> ₀~ N(0，t))</li><li id="fd7d" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><em class="kr">d</em>ₜ<em class="kr">=经过的时间段</em></li></ul><p id="2de3" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">本质上，GBM模型允许我们基于由平均值(即对数收益的平均值)驱动的“漂移”和随机但仍可以由波动性(即对数收益的标准差)表征的“冲击”的组合来对未来价格建模。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mp kx l"/></div></figure><p id="9405" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">但是，应该注意的是，该模型做出了几个关键假设:</p><ul class=""><li id="515a" class="lw lx hi jv b jw lq ka lr ke mm ki mn km mo kq mb mc md me bi translated"><strong class="jv hj">股价的对数变化呈正态分布* </strong></li><li id="4941" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><strong class="jv hj">波动率(即对数收益的标准差)是常数</strong></li><li id="38b5" class="lw lx hi jv b jw mf ka mg ke mh ki mi km mj kq mb mc md me bi translated"><strong class="jv hj">预期收益(即对数收益的均值)</strong>与股票表现无关</li></ul><p id="6d6e" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><em class="kr">(*你可能想知道为什么我们使用回报而不是价格——这是因为回报是无标度的(以百分比而不是绝对值表示),并且通常具有更“稳定”的统计特性(例如恒定均值&amp;方差)。此外，对数回归比简单回归有优势，因为对数正态分布随机变量的</em> <strong class="jv hj">对数将是正态分布的。来自statsexchange的这三篇文章<a class="ae iu" href="https://quant.stackexchange.com/questions/17287/why-is-rate-of-return-on-the-stock-normally-distributed-under-gbm" rel="noopener ugc nofollow" target="_blank"> (1) </a>、<a class="ae iu" href="https://quant.stackexchange.com/questions/32244/geometric-brownian-motion-percentage-returns-vs-log-returns" rel="noopener ugc nofollow" target="_blank"> (2) </a>和<a class="ae iu" href="https://stats.stackexchange.com/questions/230955/forecasting-with-arima-and-garch-does-my-plan-look-alright" rel="noopener ugc nofollow" target="_blank"> (3) </a>更详细。<em class="kr"> ) </em></strong></p><p id="d685" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而，正如我们将在后面看到的，这些条件并不总是成立的，所以任何预测的有效性都需要非常仔细地评估。</p><h1 id="e429" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">蒙特卡洛模拟</h1><p id="7f8d" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">如前所述，我已经有一篇关于这个主题的<a class="ae iu" rel="noopener" href="/analytics-vidhya/building-a-probabilistic-risk-estimate-using-monte-carlo-simulations-cf904b1ab503">独立文章</a>但简单来说:蒙特卡罗模拟是一种通过重复运行具有随机变量的模型并汇总所有结果来了解结果范围的预测方法。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mq kx l"/></div></figure><p id="8b26" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">因此，尽管GBM预测的每次迭代都会略有不同，但我们可以进行多次预测，并汇总所有结果，以查看预期时间框架内潜在价格变化的总体范围。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="mr kx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">基于1年的历史数据，对大约3周的NFLX股票价格进行10次不同的迭代预测。(注意:我使用了7天的回溯测试期，因此实际价格与预测价格之间存在重叠)</figcaption></figure><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="ms kx l"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">同样10次迭代的第10、90百分位和NFLX预测价格中位数</figcaption></figure><p id="7960" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">正如所料，越往后，可能的价格范围(即P10到P90)越宽。(根据经验，有一篇学术论文称，当限于<a class="ae iu" href="https://www.researchgate.net/publication/325987061_Forecasting_Share_Prices_of_Small_Size_Companies_in_Bursa_Malaysia_Using_Geometric_Brownian_Motion" rel="noopener ugc nofollow" target="_blank">最长2周</a>前瞻时，GBM最适合预测)</p><h1 id="0450" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">用GBM模拟一只股票</h1><p id="302b" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">该web应用程序是通过扩展另一位作者根据下面的文章构建的一些代码构建的，在这篇文章中，我将它与Python Flask相结合，以允许用户通过网站选择股票计数器以及所需的历史数据范围和预测持续时间。</p><div class="ky kz ez fb la lb"><a href="https://towardsdatascience.com/how-to-simulate-financial-portfolios-with-python-d0dc4b52a278" rel="noopener follow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">如何用Python模拟金融投资组合</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">多维几何布朗运动的一个应用</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">towardsdatascience.com</p></div></div><div class="lk l"><div class="mt l lm ln lo lk lp io lb"/></div></div></a></div><p id="3c5b" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">代码看起来有点像下面，其中有一个使用pandasDataReader从Yahoo Finance中提取股票价格的函数</p><pre class="ks kt ku kv fd mu mv mw mx aw my bi"><span id="8eb0" class="mz iw hi mv b fi na nb l nc nd">import pandas as pd<br/>from pandas_datareader import data</span><span id="0c9c" class="mz iw hi mv b fi ne nb l nc nd">import numpy as np, numpy.random<br/>from numpy import mean</span><span id="014e" class="mz iw hi mv b fi ne nb l nc nd">import random<br/>import matplotlib.pyplot as plt</span><span id="5e78" class="mz iw hi mv b fi ne nb l nc nd">from datetime import datetime</span><span id="3bc8" class="mz iw hi mv b fi ne nb l nc nd">from scipy.stats import norm <br/>from scipy.stats import kstest<br/>from scipy.stats import skew<br/>from scipy.stats import kurtosis<br/>from scipy import stats</span><span id="d726" class="mz iw hi mv b fi ne nb l nc nd">def extract_prices(start_date,end_date,symbols,backtestduration=0):<br/>    dim=len(symbols)<br/>    for symbol in symbols:<br/>        dfprices = data.DataReader(symbols, start=start_date, end=end_date, data_source='yahoo')<br/>        dfprices = dfprices[['Adj Close']]<br/>    dfprices.columns=[' '.join(col).strip() for col in dfprices.columns.values]</span><span id="7042" class="mz iw hi mv b fi ne nb l nc nd">    for i in range(0,len(symbols)):<br/>        noOfShares.append(portfolioValPerSymbol[i]/priceAtEndDate[i])<br/>    noOfShares=[round(element, 5) for element in noOfShares]<br/>    listOfColumns=dfprices.columns.tolist()   <br/>    dfprices["Adj Close Portfolio"]=dfprices[listOfColumns].mul(noOfShares).sum(1)<br/>    <br/>    print(f"Extracted {len(dfprices)} days worth of data for {len(symbols)} counters with {dfprices.isnull().sum().sum()} missing data")<br/>    <br/>    return dfprices</span></pre><p id="e67e" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">之后，另一个函数将价格转换成对数回报</p><pre class="ks kt ku kv fd mu mv mw mx aw my bi"><span id="e43c" class="mz iw hi mv b fi na nb l nc nd">def calc_returns(dfprices,symbols):<br/>    dfreturns=pd.DataFrame()<br/>    columns = list(dfprices) <br/>    mean=[]<br/>    stdev=[]<br/>    for column in columns:<br/>        dfreturns[f'Log Daily Returns {column}']=np.log(dfprices[column]).diff()<br/>        mean.append(dfreturns[f'Log Daily Returns {column}'][1:].mean())<br/>        stdev.append(dfreturns[f'Log Daily Returns {column}'][1:].std())<br/>    dfreturns=dfreturns.dropna()<br/>    <br/>    if len(dfreturns.columns)==1:<br/>        df_mean_stdev=pd.DataFrame(list(zip(symbols,mean,stdev)),columns =['Stock', 'Mean Log Daily Return','StdDev Log Daily Return']) <br/>    else:<br/>        df_mean_stdev=pd.DataFrame(list(zip(symbols+["Portfolio"],mean,stdev)),columns =['Stock', 'Mean Log Daily Return','StdDev Log Daily Return'])<br/>    <br/>    return dfreturns ,df_mean_stdev</span></pre><p id="9e1d" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">这些对数回报作为输入输入到另一个函数中，该函数估计平均值、标准偏差，然后与初始价格一起推送到一个函数中，该函数将输入拟合到上一节讨论的方程中</p><pre class="ks kt ku kv fd mu mv mw mx aw my bi"><span id="cf35" class="mz iw hi mv b fi na nb l nc nd">def GBMsimulatorUniVar(So, mu, sigma, T, N):<br/>    """<br/>    Parameters<br/>    So:     initial stocks' price<br/>    mu:     expected return<br/>    sigma:  volatility<br/>    Cov:    covariance matrix<br/>    T:      time period<br/>    N:      number of increments<br/>    """</span><span id="9bff" class="mz iw hi mv b fi ne nb l nc nd">    dim = np.size(So)<br/>    t = np.linspace(0., T, int(N))<br/>    S = np.zeros([dim, int(N)])<br/>    S[:, 0] = So<br/>    for i in range(1, int(N)):    <br/>        drift = (mu - 0.5 * sigma**2) * (t[i] - t[i-1])<br/>        Z = np.random.normal(0., 1., dim)<br/>        diffusion = sigma* Z * (np.sqrt(t[i] - t[i-1]))<br/>        S[:, i] = S[:, i-1]*np.exp(drift + diffusion)<br/>    return S, t</span></pre><p id="33bd" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">尽管对结果的有效性有一个重要的警告。在代码中，最佳拟合正态分布是根据历史数据估计的，但更相关的是回报的“正态”程度。</p><p id="2a83" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">因此，我增加了一组关于正态性的统计测试,我不会在本文中详述。可以说，这些测试生成了一个统计值和一个p值，可以根据选定的显著性水平进行测试，以检查历史回报数据的“正态性”(*)。具体来说，我实现了两个测试，一个是Kolmogorov Smirnov测试，一个是Shapiro维尔克测试，显著性水平为5%。(为什么是5%？这里<a class="ae iu" href="https://stats.stackexchange.com/questions/55691/regarding-p-values-why-1-and-5-why-not-6-or-10" rel="noopener ugc nofollow" target="_blank">看这个</a></p><p id="bdcf" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><em class="kr"> (*严格来说，这不是真正的‘检查’本身，但我宁愿不去探究</em> <a class="ae iu" href="https://machinelearningmastery.com/statistical-hypothesis-tests" rel="noopener ugc nofollow" target="_blank"> <em class="kr">假设检验是如何工作的</em></a><em class="kr">)</em></p><p id="97ee" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">不幸的是，运行一些不同股票的数字(使用大约从6个月到一年的历史数据)显示，根据以下任意示例，CRM (Salesforce)和NFLX(网飞)的股票在2019年1月至2020年7月期间的回报并不总是“正常的”。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nf"><img src="../Images/90cea0889711ff80c1e8941eba513fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ggsRhrmQjIe4Epucy7kZ7g.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">CRM日志返回不正常(P值0.0048 &lt; alpha of 0.05) but NFLX log returns are normal (P Value 0.068 &gt; 0.05)</figcaption></figure><p id="495d" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而现在，让我们假设我们将使用这种方法的股票会表现得很好。</p><h1 id="b49a" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">使用GBM模拟投资组合中的多只股票</h1><p id="687c" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">一个更现实的问题是建立一个由多个柜台组成的股票投资组合模型。</p><p id="34d3" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">不幸的是，你不能只对两只不同的股票分别进行GBM模拟，然后再将它们结合起来，因为尽管每只股票的回报率变动是随机的，但股票之间的<strong class="jv hj">回报率(*)是相关的</strong>。</p><p id="29c3" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">(<strong class="jv hj"> * </strong>如前一节所述，估算的是回报的相关性，而不是价格。这篇<a class="ae iu" href="https://quantdare.com/correlation-prices-returns/" rel="noopener ugc nofollow" target="_blank">文章</a>解释了原因)</p><p id="8310" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><strong class="jv hj"> <em class="kr"> &lt;警告:有数学来袭！&gt; </em> </strong></p><p id="9767" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><a class="ae iu" href="#39b3" rel="noopener ugc nofollow"> &lt;如果你想跳过理论&gt; </a>点击这里</p><p id="8c2a" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">因此，为了将这种相关效应重新整合到GBM模型中，我们使用了早期方程的修改形式，现在包括了一个新项，<em class="kr"> Aij，</em>股票收益之间协方差矩阵的<em class="kr"> Cholesky因子</em></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ng"><img src="../Images/99115806a45f7b4a2d4ef6425eed09d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/0*9P_V8Bl2s2MIKXvM"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:P. Glasserman，<em class="nh">金融工程中的蒙特卡罗方法</em>。第53卷(2013年)</figcaption></figure><p id="e3e0" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">这个<em class="kr">乔莱斯基分解项</em>用于收益协方差矩阵，并乘以不相关随机变量矩阵，以“诱导”它们之间的相关性。</p><div class="ky kz ez fb la lb"><a href="https://towardsdatascience.com/behind-the-models-cholesky-decomposition-b61ef17a65fb" rel="noopener follow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">模型背后:乔莱斯基分解</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">运行今天的线性模型和蒙特卡洛模拟的19世纪地图制作者的诡计</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">towardsdatascience.com</p></div></div><div class="lk l"><div class="ni l lm ln lo lk lp io lb"/></div></div></a></div><p id="e4cf" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">例如，下面是由3个元素组成的相同示例的协方差矩阵，即同一时期的股票计数器CRM和NFLX。通常，协方差矩阵更难解释，因为它们反映了“绝对”联合可变性，因此另一种可视化变量之间关系的方法是使用<a class="ae iu" href="https://en.wikipedia.org/wiki/Covariance_and_correlation" rel="noopener ugc nofollow" target="_blank">相关矩阵，它是协方差矩阵</a>的“标准化”版本，其中每个值介于-1(完全负相关)到0(无相关)到+1(完全正相关)之间</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nj"><img src="../Images/ff36d5b81e11c9be9037499da3dcc1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEbI9HOpLIQow0WnZY1jYw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">协方差矩阵；协方差矩阵的Cholesky分解；以及2019年1月至2020年7月期间股票CRM和NFLX的相关矩阵</figcaption></figure><p id="78e1" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">不幸的是，对于等式中的这个新项，除了回报是否是“正态分布”之外，还需要检查协方差矩阵是否是对称正定的。</p><p id="e245" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">特别是对于有几十只不同股票的较大投资组合，这变得更加复杂，因为我们不仅要担心两只不同股票之间的相关性，还要担心多只股票之间的所有相关性，以便关系保持“一致”</p><p id="9ea6" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">因此，该算法偶尔会发出一条错误消息<em class="kr"> LinAlgError:矩阵不是正定的——无法计算乔莱斯基分解。(</em>这种正定性是矩阵的一个特性，它允许矩阵在不改变向量符号的情况下<strong class="jv hj">相乘多次)</strong></p><div class="ky kz ez fb la lb"><a href="https://towardsdatascience.com/what-is-a-positive-definite-matrix-181e24085abd" rel="noopener follow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">什么是正定矩阵？</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">为什么这很重要？</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">towardsdatascience.com</p></div></div><div class="lk l"><div class="nk l lm ln lo lk lp io lb"/></div></div></a></div><p id="72d1" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">这是因为在实践中，股票回报数据可能有噪声，或者特别是对于有许多股票的大型投资组合(即高维数)，一些股票可能是多共线的(其中股票回报之间可能存在相互依赖性)。</p><div class="ky kz ez fb la lb"><a href="https://blog.clairvoyantsoft.com/correlation-and-collinearity-how-they-can-make-or-break-a-model-9135fbe6936a" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">相关性和共线性-它们如何建立或破坏模型</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">相关性和共线性</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">blog.clairvoyantsoft.com</p></div></div><div class="lk l"><div class="nl l lm ln lo lk lp io lb"/></div></div></a></div><p id="5e8c" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">注意，GBM的多元形式假设<strong class="jv hj">协方差也是随时间恒定的</strong>(注意:不幸的是，在实践中，就像均值和方差一样，相关性也会随时间变化)</p><p id="39b3" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated"><strong class="jv hj"> <em class="kr"> &lt;数学预警结束&gt; </em> </strong></p><p id="f8a6" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">因此，以代码形式将所有这些放在一起看起来有点像下面的，其中有另一个新函数来计算不同股票之间的对数回报的协方差，GBM函数有一个额外的协方差项作为输入。</p><pre class="ks kt ku kv fd mu mv mw mx aw my bi"><span id="6aac" class="mz iw hi mv b fi na nb l nc nd">def create_covar(dfreturns):  <br/>    try:<br/>        returns=[]<br/>        arrOfReturns=[]<br/>        columns = list(dfreturns)<br/>        for column in columns:<br/>            returns=dfreturns[column].values.tolist()<br/>            arrOfReturns.append(returns)<br/>        Cov = np.cov(np.array(arrOfReturns))    <br/>        return Cov<br/>    except LinAlgError :<br/>        Cov = nearPD(np.array(arrOfReturns), nit=10)<br/>        print("WARNING -Original Covariance Matrix is NOT Positive Semi Definite And Has Been Adjusted To Allow For Cholesky Decomposition ")<br/>        return Cov</span><span id="b230" class="mz iw hi mv b fi ne nb l nc nd">def GBMsimulatorMultiVar(So, mu, sigma, Cov, T, N):<br/>    """<br/>    Parameters<br/>    So:     initial stocks' price<br/>    mu:     expected return<br/>    sigma:  volatility<br/>    Cov:    covariance matrix<br/>    T:      time period<br/>    N:      number of increments<br/>    """</span><span id="5a15" class="mz iw hi mv b fi ne nb l nc nd">    dim = np.size(So)<br/>    t = np.linspace(0., T, int(N))<br/>    A = np.linalg.cholesky(Cov)<br/>    S = np.zeros([dim, int(N)])<br/>    S[:, 0] = So<br/>    for i in range(1, int(N)):    <br/>        drift = (mu - 0.5 * sigma**2) * (t[i] - t[i-1])<br/>        Z = np.random.normal(0., 1., dim)<br/>        diffusion = np.matmul(A, Z) * (np.sqrt(t[i] - t[i-1]))<br/>        S[:, i] = S[:, i-1]*np.exp(drift + diffusion)<br/>    return S, t</span></pre><h1 id="f6d0" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">GBM的替代方案——自举抽样</h1><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nm"><img src="../Images/01c3cf761b1715af2106f1ac69c844f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s9sNw2FnEtLX5lPP"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">来源:<a class="ae iu" href="https://www.huffpost.com/entry/pull-yourself-up-by-your-bootstraps-nonsense_n_5b1ed024e4b0bbb7a0e037d4" rel="noopener ugc nofollow" target="_blank">https://www . huffpost . com/entry/pull-your-up-by-your-bootstraps-废话_n_5b1ed024e4b0bbb7a0e037d4 </a></figcaption></figure><p id="0868" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">不幸的是，GBM方法需要对基础分布的形状做很多假设才能工作。因此，我想分享一种替代方法，叫做替换引导抽样</p><div class="ky kz ez fb la lb"><a href="https://towardsdatascience.com/an-introduction-to-the-bootstrap-method-58bcb51b4d60" rel="noopener follow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">自助法简介</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">关于bootstrap方法、动机及其工作原理的探讨</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">towardsdatascience.com</p></div></div><div class="lk l"><div class="nn l lm ln lo lk lp io lb"/></div></div></a></div><p id="c25b" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">这种方法从历史数据中随机抽取样本，生成新的“合成”数据集来预测未来价格。这样，Bootstrapping <strong class="jv hj"> <em class="kr">就不需要显式的理论模型</em> </strong>来生成预测(因此，在短语“<em class="kr">通过自己的引导来提升自己</em>”之后，它被称为Bootstrapping，意思是在没有外部帮助的情况下改善自己的状况)。</p><p id="1a5e" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">在代码中，我使用numpy的random.randint“选择”一个随机时间戳来提取历史日志返回，模拟了这种带有替换行为的采样。然后重复这一过程，以创建一系列随机日志回报来建立预测。</p><pre class="ks kt ku kv fd mu mv mw mx aw my bi"><span id="5885" class="mz iw hi mv b fi na nb l nc nd">def bootstrap_w_replc_singleval(dfreturns):<br/>    columns=dfreturns.columns        ____singlesample=pd.DataFrame(dfreturns.values[np.random.randint(len(dfreturns), size=1)], columns=columns)<br/>    return singlesample</span><span id="54fa" class="mz iw hi mv b fi ne nb l nc nd">def bootstrapforecast(dfreturns,T):<br/>    columnlist=dfreturns.columns<br/>    X=[]<br/>    for i in range(0,T):<br/>        ____X.append(bootstrap_w_replc_singleval(dfreturns).values.tolist()[0])<br/>    Y=pd.DataFrame(X)<br/>    Y.columns=columnlist<br/>    Y.loc[-1] = [0]*len(columnlist)  # adding a row<br/>    Y.index = Y.index + 1  # shifting index<br/>    Y = Y.sort_index()  # sorting by index<br/>    <br/>    return Y</span></pre><p id="d2d0" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而，这种方法仍然依赖于提取的历史回报数据，这些数据是股票回报的潜在行为的无偏表示。</p><p id="1f85" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">此外，即使数据不再需要正态分布，Bootstrapping也假设均值和方差是同方差的(即不随时间变化)。换句话说，我们假设任何观察值(来自历史回报数据集)都同样有可能被选择，并且它的选择是独立的。</p><p id="423d" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">这种方法也适用于多只股票的投资组合，但与GBM的另一种方法不同，Bootstrap采样不需要估计协方差，因为我们将从历史数据中对“一整行”回报进行采样，从而隐含地捕捉它们之间的任何相关性。</p><h1 id="7d0e" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">Bootstrap vs GBM:哪个效果更好？</h1><p id="3e4e" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">那么这两种方法中，哪一种效果更好呢？嗯，这要看情况。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/dad93de1d264279b32248d75ca1f7b24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wFORrIa21Jl8j31arkqGXw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">比较GBM与Bootstrap方法在100次迭代中的聚合结果</figcaption></figure><p id="9744" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">基本的第一步检查应该是测试收益分布的正态性和偏斜度(因为GBM需要这个假设来保证结果的有效性)</p><p id="e561" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而，在上面的例子中，对数收益分布的形状似乎表明股票收益符合正态假设，并且具有相当均匀的对称形状(这意味着GBM应该是一种有效的方法)</p><p id="184f" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而，与30天回测期的Bootstrap抽样相比，GBM方法给出了更大的均方根误差。因此，我的建议是在不同的回溯测试持续时间内对两者进行测试，并比较RMSE-s(或者，如果您直接使用该文件的Jupyter笔记本版本，我猜您也可以编写自己的脚本来测试MAE、MAPE或任何您喜欢的预测准确性指标)</p><h1 id="05ad" class="iv iw hi bd ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js bi translated">结论</h1><p id="2dc7" class="pw-post-body-paragraph jt ju hi jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq hb bi translated">所以在这一切之后，最大的问题是… <strong class="jv hj">这些方法能用来预测未来的股票价格并获利吗？</strong></p><p id="15fb" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">简答:…。不尽然(可悲)。大多数现实生活中的股票回报具有厚尾分布，并表现出波动聚集行为(即标准偏差和方差不会随着时间的推移而保持良好和固定)，这打破了我们之前所做的假设。</p><p id="88e0" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">然而，对于特定时间范围内的某些股票，假设可能仍然成立(或接近有效)，这种方法确实提供了一种结构化的方法来估计短期(约1-2周)回报的相对最坏-最好情况范围。</p><p id="9577" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">如果你访问过该网站，你可能会注意到，除了GBM和Bootstrap抽样，该网站应用程序还允许使用其他“传统”统计时间序列预测方法进行预测，如ARIMA，霍尔特温特斯和向量自动回归。如果你想让我介绍其他方法，请在下面的评论中告诉我。</p><p id="d7dd" class="pw-post-body-paragraph jt ju hi jv b jw lq jy jz ka lr kc kd ke ls kg kh ki lt kk kl km lu ko kp kq hb bi translated">同时，如果你喜欢这篇文章——看看我下面的其他文章:</p><div class="ky kz ez fb la lb"><a href="https://zhijingeu.medium.com/how-to-estimate-optimal-stock-portfolio-weights-using-monte-carlo-simulations-modern-portfolio-d27d534e8a1a" rel="noopener follow" target="_blank"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">如何使用蒙特卡罗模拟和现代投资组合来估计最优股票投资组合权重</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">在本文中，我将介绍如何使用现代投资组合理论&amp;蒙特卡洛模拟法来估计一个最优的风险回报…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">zhijingeu.medium.com</p></div></div><div class="lk l"><div class="np l lm ln lo lk lp io lb"/></div></div></a></div><div class="ky kz ez fb la lb"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/building-a-simple-stock-ranking-screening-tool-7bc10049e85"><div class="lc ab dw"><div class="ld ab le cl cj lf"><h2 class="bd hj fi z dy lg ea eb lh ed ef hh bi translated">建立一个简单的股票排名和筛选工具</h2><div class="li l"><h3 class="bd b fi z dy lg ea eb lh ed ef dx translated">配料:一杯要素投资原则；从雅虎网上新收集的一些股票指数…</h3></div><div class="lj l"><p class="bd b fp z dy lg ea eb lh ed ef dx translated">medium.com</p></div></div><div class="lk l"><div class="nq l lm ln lo lk lp io lb"/></div></div></a></div></div></div>    
</body>
</html>