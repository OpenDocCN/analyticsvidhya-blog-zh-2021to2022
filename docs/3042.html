<html>
<head>
<title>How to Use Materialized View in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Django中使用物化视图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-use-materialized-view-in-django-3b91f71f718a?source=collection_archive---------0-----------------------#2021-05-31">https://medium.com/analytics-vidhya/how-to-use-materialized-view-in-django-3b91f71f718a?source=collection_archive---------0-----------------------#2021-05-31</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d0bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Django是最流行的Python Web框架之一。它是基于“模型-模板-视图”模式设计的。在Django中，模型充当数据(数据库)的接口。由于每个模型都与数据库中的每个物理表相关联，我开始考虑是否有可能让ORM处理更高级的数据库特性，即视图和物化视图。结果不仅仅是伟大！</p><p id="a130" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">视图和物化视图是查找SQL查询的结果。它们之间的主要区别是物化视图将结果存储为一个实际的表，而视图不是。从技术角度来说，视图和物化视图有利于重复查询。它们提高了查询速度。从业务的角度来看，它们可以用于声明不同团队/部门使用的数据范围。问题是我们如何在Django中利用这个特性？</p><p id="796d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是我的研究结论——ORM可以很好地处理物化视图而不是视图。很有道理，不是吗？因为物化视图是一个物理表。ORM应该能联想到。关于视图，ORM有一个类似的称为“管理器”的机制，我将在以后写另一篇文章向您介绍。让我们继续我们的物化视图教程。</p><p id="b950" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">属国</p><ol class=""><li id="95b3" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Python 3.7</li><li id="a181" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">Django 2.2.x</li><li id="ae99" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">psyco pg 2-二进制2.8.6</li></ol><p id="5e1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本教程中，我将使用PostgreSQL数据库。一定要选择您想使用的任何关系数据库。为了让Python与PostgreSQL数据库“对话”，我们需要pip安装<strong class="ih hj"> psycopg2-binary </strong>。此外，您可能需要在自己的机器上设置一个本地PostgreSQL数据库，以便Django项目中的模型可以连接。</p><h1 id="8ec5" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">步骤0。创建本地数据库</h1><p id="69b3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如下下载并安装PostgreSQL引擎。按照步骤操作。您应该能够创建一个本地数据库。</p><p id="36b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">https://www.postgresql.org/download/<a class="ae ku" href="https://www.postgresql.org/download/" rel="noopener ugc nofollow" target="_blank"/></p><p id="c92e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关于数据库客户端，我想用DBeaver社区版。有很多选择。这取决于你。</p><div class="kv kw ez fb kx ky"><a href="https://dbeaver.io/" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">DBeaver</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">免费的多平台数据库工具，适用于开发人员、数据库管理员、分析师和所有需要工作的人…</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">dbeaver.io</p></div></div><div class="lh l"><div class="li l lj lk ll lh lm ln ky"/></div></div></a></div><h1 id="f380" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">第一步。构建模型以创建源表</h1><p id="d7a3" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在<strong class="ih hj">民调</strong> app中的models.py，声明一个<strong class="ih hj">问题</strong>模型如下。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="d0d3" class="lx js hi lt b fi ly lz l ma mb">from django.db import models<br/> <br/> <br/>class Question(models.Model):<br/>    question_text = models.CharField(max_length=200)<br/>    pub_date = models.DateField(null=True, default=None)</span></pre><p id="ba71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如下运行迁移命令。等待第一个命令产生影响，然后再运行第二个命令。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="2547" class="lx js hi lt b fi ly lz l ma mb">python manage.py makemigration polls<br/>python manage.py migrate polls</span></pre><p id="97a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这应该会在数据库中创建一个<strong class="ih hj"> polls_question </strong>表。在我的例子中，我的本地数据库名是<strong class="ih hj"> postgres </strong>。该表位于<strong class="ih hj">公共</strong>模式下。各列如下所示。</p><figure class="lo lp lq lr fd md er es paragraph-image"><div class="er es mc"><img src="../Images/9aafcd89633498023cd913afb0e9aded.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*olFlPBtdLT4hy532exW8aQ.png"/></div></figure><p id="e54d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们将一些数据填充到表格中。</p><p id="b379" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行下面的命令，应该会把我们带到Django控制台。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="0c49" class="lx js hi lt b fi ly lz l ma mb">python manage.py shell</span></pre><p id="2418" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在控制台中复制并粘贴以下代码。点击<strong class="ih hj">进入</strong>。它应该插入1000行。现在我们有足够的数据来测试！</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="7c33" class="lx js hi lt b fi ly lz l ma mb">from polls.models import Question<br/>import string<br/>import random<br/>import datetime</span><span id="a491" class="lx js hi lt b fi mf lz l ma mb">N = 10<br/>questions = []<br/>for each in range(1000):<br/>    res = ''.join(random.choices(string.ascii_uppercase + string.digits, k=N))<br/>    syear = random.randint(2018, 2021)<br/>    smonth = random.randint(1, 12)<br/>    sdate = random.randint(1, 20)<br/>    pub_date = datetime.date(year=syear, month=smonth, day=sdate)<br/>    questions.append(Question(question_text=res, pub_date=pub_date))</span><span id="7c53" class="lx js hi lt b fi mf lz l ma mb">Question.objects.bulk_create(questions)</span></pre><h1 id="ab50" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">第二步。在源表上创建查找查询</h1><p id="78f1" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在<strong class="ih hj"> polls </strong> app的<strong class="ih hj"> views.py </strong>中，选择<strong class="ih hj"> polls_question </strong>表中的所有数据，添加查找查询。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="f51b" class="lx js hi lt b fi ly lz l ma mb">from django.shortcuts import render<br/>from polls.models import Question<br/>import datetime</span><span id="ce83" class="lx js hi lt b fi mf lz l ma mb">def index(request):<br/>    questions = Question.objects.all()<br/>    print('Origin table returns {} questions'.format(questions.count()))</span><span id="e3f1" class="lx js hi lt b fi mf lz l ma mb">return render(request, 'polls/index.html')</span></pre><p id="4c7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动项目。在浏览器中打开<a class="ae ku" href="http://127.0.0.1:8000/polls/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/polls/</a>。我们应该在控制台中看到如下的打印结果。它返回1000行。这是我们所期待的。</p><figure class="lo lp lq lr fd md er es paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="er es mg"><img src="../Images/d0f0f991c6add292e65881252500a5c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EpBvtHYMyGxmHovzTlQjpw.png"/></div></div></figure><h1 id="b5f4" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">第三步。在数据库中创建实体化视图</h1><p id="319c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在PostgreSQL控制台中，运行以下SQL命令生成一个物化视图，该视图仅包含发布日期在2021年或之后的数据。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="4210" class="lx js hi lt b fi ly lz l ma mb">create materialized view polls_question_materialized_view_2021 as<br/>select * from polls_question<br/>where pub_date&gt;='2021-01-01'</span></pre><p id="d355" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们应该在如下的物化视图类别下看到它。</p><figure class="lo lp lq lr fd md er es paragraph-image"><div class="er es ml"><img src="../Images/021979c19190c9248b2ef55ea56fea1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*2lr5G8B9SM5gagCL5LNhhw.png"/></div></figure><h1 id="b20f" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">第四步。构建模型并将其与物化视图相关联</h1><p id="4160" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在<strong class="ih hj">polls</strong>app的【models.py 中，创建一个模型<strong class="ih hj"> Question2021 </strong>如下图。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="5e3e" class="lx js hi lt b fi ly lz l ma mb">class Question2021(models.Model):<br/>    question_text = models.CharField(max_length=200)<br/>    pub_date = models.DateField(null=True, default=None)</span><span id="b180" class="lx js hi lt b fi mf lz l ma mb">    class Meta:<br/>        managed = False<br/>        db_table = 'polls_question_materialized_view_2021'</span></pre><p id="8736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显式声明db_table很重要，这样Django就可以在模型和物化视图之间建立连接。请不要运行迁移。因为物化视图已经通过SQL命令手动创建。另外，我们需要确保<strong class="ih hj">管理的</strong>属性为假。这确保了Django不会在我们将来在<strong class="ih hj"> polls </strong>应用上运行迁移时错误地创建表。</p><h1 id="e953" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">第五步。在物化模型上创建查找查询</h1><p id="a2d9" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">通过选择<strong class="ih hj">问题2021 </strong>模型上的所有数据添加查找查询，并在控制台中打印退货数量。代码应该如下所示。</p><pre class="lo lp lq lr fd ls lt lu lv aw lw bi"><span id="c34d" class="lx js hi lt b fi ly lz l ma mb">from django.shortcuts import render<br/>from polls.models import Question, Question2021</span><span id="5829" class="lx js hi lt b fi mf lz l ma mb">def index(request):<br/>    questions = Question.objects.all()<br/>    print('Origin table returns {} questions'.format(questions.count()))</span><span id="580d" class="lx js hi lt b fi mf lz l ma mb">questions_2021 = Question2021.objects.all()<br/>    print('Materialized view returns {} questions.'.format(questions_2021.count()))</span><span id="370e" class="lx js hi lt b fi mf lz l ma mb">return render(request, 'polls/index.html')</span></pre><p id="2aab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启动项目。在浏览器中打开<a class="ae ku" href="http://127.0.0.1:8000/polls/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/polls/</a>。我们应该在控制台中看到如下两个打印结果。实体化视图返回的行数少于源表返回的行数。果然有效！</p><figure class="lo lp lq lr fd md er es paragraph-image"><div class="er es mm"><img src="../Images/65cb43c077cc0f0a865ec793c292ee49.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*Cq1zKcIhg7TU8g7pHrFm8w.png"/></div></figure><h1 id="7877" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">结论</h1><p id="e443" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">在本文中，我们在数据库中创建了物化视图，并将其与ORM模型相关联。很简单，是吗？从架构的角度来看，希望它能让您更好地了解如何管理您的数据查询引擎。感谢阅读。敬请关注。</p><p id="d67c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你感兴趣的话，我已经把这个项目上传到这里了。</p><div class="kv kw ez fb kx ky"><a href="https://github.com/slow999/DjangoAndMaterializedView" rel="noopener  ugc nofollow" target="_blank"><div class="kz ab dw"><div class="la ab lb cl cj lc"><h2 class="bd hj fi z dy ld ea eb le ed ef hh bi translated">slow 999/djangoandmaterialized view</h2><div class="lf l"><h3 class="bd b fi z dy ld ea eb le ed ef dx translated">通过在GitHub上创建一个帐户，为slow 999/DjangoAndMaterializedView开发做出贡献。</h3></div><div class="lg l"><p class="bd b fp z dy ld ea eb le ed ef dx translated">github.com</p></div></div><div class="lh l"><div class="mn l lj lk ll lh lm ln ky"/></div></div></a></div><p id="bb15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在上面拍了视频。请看下面。谢了。</p><figure class="lo lp lq lr fd md"><div class="bz dy l di"><div class="mo mp l"/></div></figure></div></div>    
</body>
</html>