<html>
<head>
<title>Multithreading and Multiprocessing in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多线程和多重处理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multithreading-and-multiprocessing-in-python-1f773d1d160d?source=collection_archive---------5-----------------------#2021-05-30">https://medium.com/analytics-vidhya/multithreading-and-multiprocessing-in-python-1f773d1d160d?source=collection_archive---------5-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/1acad9e6edf3143f5b2f34c2ad16103e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uoTRaUmxj8oYUaJGrhjWbA.png"/></div></div></figure><h1 id="6b37" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">进程与线程</h1><p id="d8ae" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">进程</strong>是计算机程序(例如Python脚本)的执行环境。多个进程可以运行同一个程序，但是它们可以使用不同的数据和计算资源。</p><p id="8a5e" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">一个<strong class="jq hj">线程</strong>是进程中的一个执行单元。线程只能串行执行指令，但是一个进程可以有多个线程同时运行，承担任务的不同部分。</p><h1 id="21f0" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">全局解释器锁(GIL)</h1><p id="d09a" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">全局解释器锁(GIL) </strong>的概念对于理解Python中的多线程和多重处理至关重要。GIL是一个进程锁，可以防止多个线程在一个Python进程中同时执行。尽管在一个进程中可以同时运行多个线程，但是在任何给定的时间，只有一个线程可以执行代码，其余的线程必须等待。</p><h1 id="ba16" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">多线程操作</h1><p id="fb03" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">多线程</strong>意味着让同一个进程同时运行多个线程，共享同一个CPU和内存。然而，由于Python中的GIL，并不是所有的任务都可以通过使用多线程来更快地执行。多个线程不能同时执行代码，但是当一个线程空闲等待时，另一个线程可以开始执行代码。</p><p id="9e32" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">这就是为什么Python中的多线程非常适合受I/O限制的任务，这些任务的执行时间主要受等待输入和输出的时间限制。使用多线程可以大大提高速度的任务示例包括从互联网下载数据和将数据写入文件。</p><p id="43e5" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在下面的Python代码示例中，两个线程都执行I/O绑定任务，休眠1秒钟。通过使用多线程，第二个任务将开始而不等待第一个任务完成，因此整个过程只需要1秒多一点就可以执行，而不是2秒。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="54f5" class="la ir hi kw b fi lb lc l ld le">import time<br/>import threading</span><span id="b636" class="la ir hi kw b fi lf lc l ld le">def some_task():<br/>    time.sleep(1)<br/>    print("Finished task")</span><span id="0e29" class="la ir hi kw b fi lf lc l ld le">if __name__ == "__main__":<br/>    start = time.time()</span><span id="5063" class="la ir hi kw b fi lf lc l ld le">    # Create two threads<br/>    t1 = threading.Thread(target=some_task)<br/>    t2 = threading.Thread(target=some_task)</span><span id="b110" class="la ir hi kw b fi lf lc l ld le">    # Start running both threads<br/>    t1.start()<br/>    t2.start()</span><span id="af50" class="la ir hi kw b fi lf lc l ld le">    # Wait until both threads are complete, and join the process into a single thread<br/>    t1.join()<br/>    t2.join()</span><span id="97cf" class="la ir hi kw b fi lf lc l ld le">    end = time.time()</span><span id="50ae" class="la ir hi kw b fi lf lc l ld le">    print(f"Finished process in {end - start} seconds")</span></pre><h1 id="ee8e" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">多重处理</h1><p id="946f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated"><strong class="jq hj">多重处理</strong>是指从主进程派生出多个进程，每个进程都有自己的CPU和内存。每个进程也有自己的GIL，这意味着并发进程可以同时执行代码。</p><p id="1383" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Python中的多处理非常适合受CPU限制的任务，这些任务的执行时间主要受CPU速度的限制。CPU利用率高的任务可以通过使用多处理来加速，因为工作负载分散在多个CPU上。</p><p id="562b" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在下面的Python代码示例中，两个进程都在执行计算1+1一亿次的CPU任务。通过使用多重处理，它们将同时执行，并且只需要大约一半的时间就能完成。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e1c7" class="la ir hi kw b fi lb lc l ld le">import time<br/>import multiprocessing</span><span id="c534" class="la ir hi kw b fi lf lc l ld le">def some_task():<br/>    for _ in range(100_000_000):<br/>        x = 1 + 1<br/>    print("Finished task")</span><span id="a6a6" class="la ir hi kw b fi lf lc l ld le">if __name__ == "__main__":<br/>    start = time.time()</span><span id="47a2" class="la ir hi kw b fi lf lc l ld le">    # Create two threads<br/>    p1 = multiprocessing.Process(target=some_task)<br/>    p2 = multiprocessing.Process(target=some_task)</span><span id="b1f3" class="la ir hi kw b fi lf lc l ld le">    # Start running both threads<br/>    p1.start()<br/>    p2.start()</span><span id="1a12" class="la ir hi kw b fi lf lc l ld le">    # Wait until both threads are complete, and join the process into a single thread<br/>    p1.join()<br/>    p2.join()</span><span id="3833" class="la ir hi kw b fi lf lc l ld le">    end = time.time()</span><span id="5728" class="la ir hi kw b fi lf lc l ld le">    print(f"Finished process in {end - start} seconds")</span></pre><h1 id="5cce" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">并行未来</h1><p id="a83f" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Python 3.2引入了<em class="lg"> concurrent.futures </em>模块，该模块提供了一个更简单的接口来将<em class="lg">线程</em>和<em class="lg">多处理</em>模块结合在一起。它利用<em class="lg"> ThreadPoolExecutor </em>和<em class="lg"> ProcessPoolExecutor </em>类来管理线程和进程池，这些线程和进程池共享大部分相同的接口，使多线程和多处理之间的切换更加容易。撇开接口不谈，<em class="lg"> concurrent.futures </em>模块在概念上与<em class="lg">线程</em>和<em class="lg">多处理</em>模块相同。</p><h1 id="7f0c" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">共享内存和竞争条件</h1><p id="8ee4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">进程有一些全局状态，可以在所有线程之间共享，每个线程也可以有自己的本地状态。</p><p id="de2c" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">由于线程可以共享相同的全局变量，如果多个线程同时访问全局变量，那么使用<strong class="jq hj">锁</strong>(也称为<strong class="jq hj">互斥</strong>)来防止竞争情况是很重要的。<em class="lg">穿线类。锁</em>是实现锁的一种方式，其中全局变量可以被不同的线程获取和释放。当一个线程获得一个全局变量时，它被锁定，并且不能被另一个线程访问，直到那个线程释放它。</p><p id="7ab4" class="pw-post-body-paragraph jo jp hi jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">不同的进程不能共享相同的全局变量(如果每个进程试图访问一个全局变量，它实际上会复制一个全局变量)，但是如果进程需要彼此共享数据，它们可以使用<strong class="jq hj">共享内存队列</strong>。<em class="lg">多重处理</em>模块提供了一个<em class="lg">队列</em>类，非常类似于Python的<em class="lg">队列。Queue </em>类，这是一个FIFO数据结构。不同的进程可以使用<em class="lg">多重处理来存放和获取数据。使用与单个进程使用<em class="lg">队列放入和获取数据相同的方式对</em>进行排队。队列</em>和<em class="lg">多重处理。队列</em>在共享内存内部使用锁，因此用户在使用<em class="lg">多处理时不必担心竞争情况。队列</em>。</p></div></div>    
</body>
</html>