# 没有行话:Python 的幕后

> 原文：<https://medium.com/analytics-vidhya/no-jargon-behind-the-scenes-of-python-852eb6949b90?source=collection_archive---------4----------------------->

![](img/8fa4a6a60783476ff974a174fa25ec2b.png)

众所周知，Python 易于编写，但是如果没有上下文，很难知道后台发生了什么。Python 是众多以面向对象编程 [(OOP)](https://en.wikipedia.org/wiki/Object-oriented_programming) 为特色的语言之一，这意味着数据和函数可以被分组到称为**对象**的有用类别中但是令人惊讶的是，尤其是对初学者来说，Python 中的一切都已经是一个对象了，**不仅仅是程序员创建的****[**实例**](https://www.tutorialspoint.com/python/python_classes_objects.htm)[](https://www.tutorialspoint.com/python/python_classes_objects.htm)**类。****

****Python 不能让你编写特别接近金属的代码，因为它被解释成 C 语言，然后被编译。Python 的创造者吉多·范·罗苏姆说过:****

> ****Python 的所有对象都基于通用的 C 数据结构，这种结构在解释器中随处可见。变量、列表、函数和其他所有东西都使用了这种数据结构的变体——不管这种结构是表示一个简单的对象，比如一个整数，还是表示一个更复杂的对象，比如一个类。****

****这使得 Python 在相对较短的程序中有了很大的提升力(尤其是与 C 相比)，但这也意味着在幕后有一些神奇的事情发生。让我们在窗帘后面偷看一下。****

# ****id，类型，isinstance****

****[id](https://docs.python.org/3.3/library/functions.html?highlight=id%20function#id) 是 Python 中的一个函数，允许你返回一个对象的“身份”，其写法是这样的:id(object)。id 将为它传递的任何内容返回一个唯一的整数。它的输出看起来会像这样(为了清楚起见进行了编辑，不是真正的代码):****

```
**id(6) = 10914528
id(x) = 10914496
id(y) = 10914496**
```

****其中输出中的数字根据您的系统而变化。如果你用许多不同的数据类型测试 id，你会发现一些令人惊讶的事情。例如，具有不同名称的空元组将返回相同的输出，因为它们被 Python“拘留”或**预先分配**以方便使用。小整数也是预先分配的，20 个字符以下的字符串也是如此。这有助于 Python 运行得更快一些。做一些调查，看看是否有其他类型的数据会发生这种情况。****

****要做到这一点，您可能需要了解一些关于[](https://www.geeksforgeeks.org/python-type-function/)**类型的函数。Type 将返回对象的类型。比如你写 a = 100，运行 type(a)，type 会返回 **< class 'int' >** ，因为 100 是一个整数。******

****类型不会给你更多的信息。还有另一个有用的函数叫做[**is instance**](https://www.guru99.com/type-isinstance-python.html#3)**，它也会告诉你一个对象是否是用户定义的类的成员。例如，以下代码将产生“**真**”输出:******

```
**class MyClass:
    _message = "Hello World"

_class = MyClass()

print("_class is a instance of MyClass() : ", isinstance(_class,MyClass))**
```

******isinstance** 也可以处理不属于某个类的数据，因为它有更广泛的可能性，所以经常被用来代替 type。使用上面的例子，isinstance(_message，str)也会有一个 **True** 输出。****

****在使用这些函数时，您会发现一些在屏幕上看起来相同的数据会产生不同的 id，并且一些输出会令人惊讶。这是为什么呢？它归结为可变和不可变数据(以及我们已经讨论过的预分配)。****

# ****可变和不可变数据****

****下面是 Python 中不可变和可变数据类型的表格:****

****![](img/758ee4a959d0b969559e7c6e25cb2bd5.png)****

****使用 id，我们可以对这个概念做一个简单的说明:****

> ****a = 4
> b = 4
> id(a)# 10105184
> id(b)# 10105184
> a = 5
> id(a)# 43777957****

****整数是“不可变的”,这意味着它们不能被改变。因此，虽然变量名的值都是 4，4 是一个整数(如上所述，它是预先分配的)，但无论使用什么名称来引用它，都有一个静态 id。如果你熟悉 C 编程，把变量名想象成 C 中的指针会很有用，因为它们引用内存中的某个位置。然而，在 Python 中，我们理解 a 和 b 指向同一个**对象** *，*即 *int(4)* 。Python 中的一切都是对象。****

****当给定一个**可变对象**时，即使有相同的值，Python 也会吐出类似这样的东西，一个使用列表的例子:****

> ****a = [1，2，3]
> b = [1，2，3]
> id(a)= 4380236680
> id(b)= 4380237448****

****因为**列表**是可变的，它们不能引用内存中的同一个位置而不引起一些严重的混乱。因此，您将会看到，尽管列表具有相同的值，但它们的 id 是不同的。这意味着，如果你操作 a，或者 b，甚至两者都操作，Python 永远不会丢失哪个是哪个的线索。这对于其他可变的数据类型特别有用，比如**字典**，其中可能有多个非常相似的条目用于非常不同的数据类型。例如，如果你有一个学生字典，有多个 17 岁的丽贝卡，但其中只有一个注册了戏剧。在这种情况下，使用不同的标识符非常有用。否则，每个丽贝卡都会把他们的分数弄混！呀！****

# ****好吧，为什么这很重要？****

****就计算能力而言，传递对同一对象的引用(如 int(4))成本更低，这对于 Python 这样的解释型语言非常有用，因为在 Python 中，数据只是占用更多的空间。作为参考，在 C 语言中，一个整数占用 4 个字节的内存，与 Python 的 28 个字节形成鲜明对比。这意味着 Python 通过使用这些对对象的引用，运行速度比其他方式要快。****

****它还暗示了数据如何通过函数传递。使用可变类型的数据意味着，即使在程序运行过程中对数据进行了操作，您也总能找出哪个列表被操作了，即使是在大量相似的列表中。这对于故障排除来说意义重大，也意味着大量数据可以在一个程序中处理而不会丢失。****

****类似地，如果我们在函数中使用不可变的数据类型作为参数，我们可以放心，没有什么会被扭曲。熟悉 C 的程序员会记得有一次他们在一个程序中两次使用 **i** 作为变量，得到了一些非常*非常*意想不到的结果。在 Python 中，如果你两次使用一个变量名，但是它引用了同一个数字，比如说零，你的程序仍然可以工作。****

****这确实意味着你可以写一些计算机能理解的非常潦草的代码，但是人类不能。这是 Python 的学习曲线之一——一定要写出可读的代码，尤其是在幕后发生如此多事情的语言中。这就是为什么，像一个负责任的程序员，你应该(而且是！在这篇文章中已经讲到了这一点)，花点时间了解一下拥有一个面向对象的程序意味着什么，以及 Python 是如何用这么少的几行代码完成所有这些繁重的工作的。****

****要了解 Python 的更多功能，请花时间浏览一下它的[文档](https://docs.python.org/3/)。记住，再多的阅读(即使很少或没有行话)也不能代替自己做一些优秀的老式编程。****