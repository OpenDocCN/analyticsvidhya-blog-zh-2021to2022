<html>
<head>
<title>Difference between deepcopy and shallow copy in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中深层拷贝和浅层拷贝的区别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/difference-between-deepcopy-and-shallow-copy-in-python-c0ecea1e0d7b?source=collection_archive---------4-----------------------#2021-04-04">https://medium.com/analytics-vidhya/difference-between-deepcopy-and-shallow-copy-in-python-c0ecea1e0d7b?source=collection_archive---------4-----------------------#2021-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4ae3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在python中，赋值操作符不复制对象，而是复制对象的引用并存储在新变量中，因此一个变量中的任何变化都会反映在另一个变量中。</p><p id="3824" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">举例:</strong></p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="3651" class="jl jm hh jh b fi jn jo l jp jq">a = [1,2,3,4]<br/>b = a<br/>print('---before change---')<br/>print('a:',a,'b:', b)<br/>a.append(5)<br/>print('---after change---')<br/>print('a:',a,'b:', b)</span></pre><p id="6c52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出:</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="314b" class="jl jm hh jh b fi jn jo l jp jq">---before change--- <br/>a: [1, 2, 3, 4] b: [1, 2, 3, 4]<br/> ---after change--- <br/>a: [1, 2, 3, 4, 5] b: [1, 2, 3, 4, 5]</span></pre><p id="1915" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们借助下图更好地理解它:</p><figure class="jc jd je jf fd js er es paragraph-image"><div class="er es jr"><img src="../Images/759f6062eeda46f1d694cd48f88a8c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*3sxcLYBrkIbW3aAvSUbycQ.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">b = a(列出指向同一对象的a和b)</figcaption></figure><p id="1d52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当a.append(5)被执行时，值5将被追加到列表a和b所指向的同一个对象上，因此a和b的值总是相同的。</p><figure class="jc jd je jf fd js er es paragraph-image"><div class="er es jz"><img src="../Images/4a48d4213a930facb2c03f95a24a4582.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*FtMwViww4VkoG9xoFxOhzQ.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">ia.append(5)</figcaption></figure><p id="d3b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在python中，为了复制对象，我们有一个单独的模块叫做“复制”。该模块提供了两个复制对象的功能，如下所示:</p><ol class=""><li id="6022" class="ka kb hh ig b ih ii il im ip kc it kd ix ke jb kf kg kh ki bi translated">copy.copy(x):执行浅层复制</li><li id="2aa3" class="ka kb hh ig b ih kj il kk ip kl it km ix kn jb kf kg kh ki bi translated">copy.deepcopy(x):执行深度复制</li></ol><p id="03ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这两个函数都将创建一个新对象并复制元素。浅复制和深复制的区别只与复合对象有关。复合对象只不过是包含另一个对象的对象。</p><p id="cf9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们借助下面的例子来理解它，</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="1b86" class="jl jm hh jh b fi jn jo l jp jq">import copy<br/>a = [1,2,3,4,5,[1,2,3,4,5,6,7]]<br/>deep = copy.deepcopy(a)<br/>shallow = copy.copy(a)<br/></span></pre><p id="88a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“a”是一个复合对象，因为它是一个包含另一个列表的列表，当我们调用deepcopy函数时，它会创建“a”的新对象和嵌套列表的新对象，因此所有内容都被复制到全新的内存位置。</p><figure class="jc jd je jf fd js er es paragraph-image"><div class="er es ko"><img src="../Images/76fc53260000d1ebdf7f46fe095529bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1230/format:webp/1*jBNC3E--o6Va-vEZJM8BNg.png"/></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">深层拷贝</figcaption></figure><p id="ce15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们调用copy()时，它创建对象的浅层副本，这意味着将创建新对象，但不会为嵌套对象创建新对象，它将指向原始对象的相同嵌套对象。如下图所示,“a”和“shallow”的第五个元素指向同一个列表对象。</p><figure class="jc jd je jf fd js er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kp"><img src="../Images/53ab6f084fc2b8e7fccb733361776dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sOI1ZoqCdT625DkVn7txBw.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">浅拷贝</figcaption></figure><p id="bcda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们修改原始对象' a '，它不会在浅和深对象中得到反映，</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="339c" class="jl jm hh jh b fi jn jo l jp jq">a = [1,2,3,4,5,[1,2,3,4,5,6,7]]<br/>b = a<br/>shallow = copy.copy(a)<br/>deep = copy.deepcopy(a)<br/>a.append(10)<br/>print('a:',a, end = '\n')<br/>print('shallow: ',shallow,  end = '\n')<br/>print('deep: ', deep)</span></pre><p id="b0c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">输出:</strong></p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="6760" class="jl jm hh jh b fi jn jo l jp jq">a: [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7], 10] <br/>shallow:  [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7]] <br/>deep:  [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7]]</span></pre><p id="4e1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，当我们修改嵌套对象时，变化将反映在浅层拷贝中，而不是深层拷贝中。</p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="4d63" class="jl jm hh jh b fi jn jo l jp jq">a = [1,2,3,4,5,[1,2,3,4,5,6,7]]<br/>b = a<br/>shallow = copy.copy(a)<br/>deep = copy.deepcopy(a)<br/>a[5].append(23)<br/>print('a:',a, end = '\n')<br/>print('shallow: ',shallow,  end = '\n')<br/>print('deep: ', deep)</span></pre><p id="9ca1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">输出:</strong></p><pre class="jc jd je jf fd jg jh ji jj aw jk bi"><span id="5b69" class="jl jm hh jh b fi jn jo l jp jq">a: [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7, 23]] <br/>shallow:  [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7, 23]] <br/>deep:  [1, 2, 3, 4, 5, [1, 2, 3, 4, 5, 6, 7]]</span></pre><p id="9658" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论:</strong></p><ol class=""><li id="6dc2" class="ka kb hh ig b ih ii il im ip kc it kd ix ke jb kf kg kh ki bi translated">浅层拷贝构建一个新的复合对象，然后(尽可能地)将原始对象包含的相同对象插入其中。</li><li id="2a51" class="ka kb hh ig b ih kj il kk ip kl it km ix kn jb kf kg kh ki bi translated">深度复制构造一个新的复合对象，然后递归地将原始对象中的对象的副本插入其中。</li></ol></div></div>    
</body>
</html>