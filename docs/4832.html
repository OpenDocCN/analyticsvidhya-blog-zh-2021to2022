<html>
<head>
<title>Why and How do we split the Dataset?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们为什么以及如何分割数据集？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/why-and-how-do-we-split-the-dataset-fcbcb86c7dce?source=collection_archive---------0-----------------------#2022-02-28">https://medium.com/analytics-vidhya/why-and-how-do-we-split-the-dataset-fcbcb86c7dce?source=collection_archive---------0-----------------------#2022-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/fe17d5e4a0b8c98b7637dea7cd1242e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*0KydCIc02KaFf3LN.jpg"/></div></div></figure><p id="b66a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据集是机器学习项目的重要组成部分。没有数据，机器学习就只是机器，学习是从题目中剥离出来的。这是机器和深度学习的人无法忍受的，他们会抗议这些数据😅。</p><h1 id="c68e" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">介绍</h1><p id="efc0" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">由于数据如此重要，当我们的数据集包含几百或更少的数据行时，我们必须保留一些数据用于测试目的。一旦软件准备好了，我们必须在把它投入市场之前对它进行测试，在市场上它将做出决定并影响人们的生活。因此，该模型预计不会出错，或者至少不会出错。</p><p id="9ce9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，测试成为开发和机器学习中的一个重要部分，因为我们正在处理数据，所以我们也必须有一些用于测试的数据。</p><p id="4b6b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">测试数据的目的是这样的，一旦被放在一边，在训练完成之前，该数据永远不应该对机器学习模型可用，然后并且只有在那时，我们才应该将测试数据引入到机器学习模型，该机器学习模型是在一些数据上训练的，该测试数据是这些数据的一部分。</p><p id="074b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们已经了解了<code class="du kr ks kt ku b">why</code>测试数据，那么让我们看看<code class="du kr ks kt ku b">How</code>我们是否将这些数据放在一边用于测试？</p><p id="7db8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们将使用来自<a class="ae kv" href="https://kaggle.com" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>的<code class="du kr ks kt ku b">california dataset</code>，我们将使用<code class="du kr ks kt ku b">pandas</code>加载数据集，然后制作<code class="du kr ks kt ku b">spliting</code>。我们可以通过两种方式进行拆分:</p><ol class=""><li id="1ea5" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">通过选择索引范围进行手动操作</li><li id="9e9f" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">使用<code class="du kr ks kt ku b">Sklearn</code>中的功能。</li></ol><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="b559" class="ls jp hi ku b fi lt lu l lv lw">import pandas as pd dataset = pd.read_csv(housing.csv) dataset.head()</span></pre><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/43fc60087865f24e6c15840820abf842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG_pal8D1-TUikEeoOR9jw.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">加州数据集</figcaption></figure><p id="17de" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据加载后，我们可以看到使用<code class="du kr ks kt ku b">head()</code>，数据集的前5行，以获得数据集的一瞥。<br/>现在，我们在数据集变量中有了完整的数据集，我们准备好进行分割了。但是首先，让我们看看数据集的长度，这样我们可以在执行<code class="du kr ks kt ku b">split</code>后再次看到这个长度，并验证分割是否成功。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="8dd5" class="ls jp hi ku b fi lt lu l lv lw">len(dataset)</span></pre><p id="b7e8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi">20640</p><p id="876a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个简单的函数<code class="du kr ks kt ku b">len()</code>给出了数据集<code class="du kr ks kt ku b">20640</code>中的行数</p><p id="076c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们将看到如何使分裂<code class="du kr ks kt ku b">manually using the indexing</code>。</p><h1 id="ab2d" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用手动索引</h1><p id="7dc7" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在这个方法中，我们想要指定我们想要哪个索引的<code class="du kr ks kt ku b">training</code>以及我们想要哪个索引的<code class="du kr ks kt ku b">testing set</code>，反之亦然。</p><p id="d1cc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">语法简单明了:<code class="du kr ks kt ku b">dataset_variable[strat:end]</code></p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="b5e8" class="ls jp hi ku b fi lt lu l lv lw">train = dataset[:16000] test = dataset[16000:]</span></pre><p id="a4fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我们简单地说了以下内容:</p><ol class=""><li id="2cc5" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">从开始，即0索引到16000索引，获取数据行并将其放入训练变量中，即我们正在制作包含前16000行的训练集</li><li id="bb0f" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">从16000到结尾，将行放入测试集中。</li></ol><p id="284d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行这行代码后，如果我们现在看到<code class="du kr ks kt ku b">train</code>和<code class="du kr ks kt ku b">test</code>的长度，我们将得到<code class="du kr ks kt ku b">16000</code>和<code class="du kr ks kt ku b">4640</code>。</p><p id="0506" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的问题是，我们必须知道我们希望拆分到哪个索引，或者从哪个索引开始拆分，还有一个缺点是，我们不能在这里打乱数据行。如果我们必须洗牌，我们必须在流程中增加另一个步骤。<br/>也就是说，在进行拆分之前，我们必须手动混洗数据集，然后进行基于索引的拆分。</p><p id="b931" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，当我们使用sklearn时，这些步骤只需要一个参数，我们不需要担心索引和其他东西。</p><p id="eca5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何使用Sklarn的<code class="du kr ks kt ku b">train_test_split</code>函数执行同样的操作。</p><h1 id="c607" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">来自Sklearn的train_test_split</h1><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="6cb7" class="ls jp hi ku b fi lt lu l lv lw">from sklearn.model_selection import train_test_split</span></pre><p id="e04c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，这个牛逼又上天的函数是从sklearn的<code class="du kr ks kt ku b">model_selection</code>模块导入的，简单如蛋糕。<br/>导入后，我们需要做的就是传递数据集和我们想要的<code class="du kr ks kt ku b">test set</code>大小，这样就完成了。</p><p id="82ab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">需要记住的是，如果我们以<code class="du kr ks kt ku b">DataFrame</code>的形式给出数据集，我们会得到两个<code class="du kr ks kt ku b">dataframes</code>，一个用于<code class="du kr ks kt ku b">training</code>，一个用于<code class="du kr ks kt ku b">testing</code>。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="9460" class="ls jp hi ku b fi lt lu l lv lw">training, testing = train_test_split(dataset, test_size=0.3, shuffle=True, random_state=32)</span></pre><p id="0139" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们为此函数提供了以下参数:</p><ol class=""><li id="e0c4" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated"><code class="du kr ks kt ku b">Dataset</code> -我们拥有的整个数据集。</li><li id="3f4a" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><code class="du kr ks kt ku b">test_size</code> -我们想要测试集的数据百分比</li><li id="18db" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><code class="du kr ks kt ku b">shuffle=True</code>，我们是否希望我们的数据集在分割前被打乱。如果<code class="du kr ks kt ku b">True</code>，索引将被打乱，然后进行拆分。</li><li id="4562" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated"><code class="du kr ks kt ku b">random_state=any_number</code> -如果设置，那么无论我们进行多少次拆分，每次都会得到相同的拆分。</li></ol><p id="1e63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">通过使用这一点，我们确保了测试集总是安全的，不受模型的影响。</p><p id="418b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这个函数返回的训练和测试变量是什么。training包含数据集的一部分，有14448行，索引也是混洗的。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="2ece" class="ls jp hi ku b fi lt lu l lv lw">training</span></pre><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/603f8081fbe47ee39b944eac1c690f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dxR6Rj693LDprfHd9I8EmA.png"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">训练集</figcaption></figure><p id="37e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">14448行× 10列</p><p id="e722" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以类似的方式，testing包含6192行和混排索引。如果我们计算这个数据集的<code class="du kr ks kt ku b">30%</code>，就会得到6192。因此，我们的数据的<code class="du kr ks kt ku b">30%</code>在测试集中。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="c0eb" class="ls jp hi ku b fi lt lu l lv lw">testing</span></pre><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/776223a90f05c5e3275990108cf1acf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCsLMRVTECZ4j_rA_TR6YQ.png"/></div></div></figure><p id="d64a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">6192行× 10列</p><h1 id="f020" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">当我们分离输入和输出变量时</h1><p id="e87b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">现在如果我们把输入和输出变量分成x作为输入，y作为输出。<br/>然后在这个数据集中，我们将在y中有median_house_value，因为它是输出变量，其余的列将在<code class="du kr ks kt ku b">x</code>中作为模型的输入。</p><p id="b868" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个<code class="du kr ks kt ku b">x</code>将作为模型的输入，在此基础上模型将与<code class="du kr ks kt ku b">y</code>一起被训练。但是在将来，当这个模型进行预测时，它会根据<code class="du kr ks kt ku b">x</code>来预测<code class="du kr ks kt ku b">y</code>。让我们将数据集分成<code class="du kr ks kt ku b">x</code>和<code class="du kr ks kt ku b">y</code>。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="4e49" class="ls jp hi ku b fi lt lu l lv lw">x = dataset.drop(median_house_value, axis=1)</span></pre><p id="3b57" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里我们说的是，沿着<code class="du kr ks kt ku b">axis=1</code>放下<code class="du kr ks kt ku b">median_house_value</code>，即整个列或列的方向。</p><p id="4be8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注:<code class="du kr ks kt ku b">axis=0</code>表示行，<code class="du kr ks kt ku b">axis=1</code>表示列。</p><p id="17d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，我们将有<code class="du kr ks kt ku b">x</code>，其中没有<code class="du kr ks kt ku b">median_house_value</code>，所有其他列都将存在。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="8d0c" class="ls jp hi ku b fi lt lu l lv lw">x</span></pre><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/b3d78f44829ccd1c9370a1ce06e04e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUARteZI43SQJfR3Q7DrnA.png"/></div></div></figure><p id="846a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">20640行× 9列</p><p id="a604" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">事实的确如此。</p><p id="75ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们通过编写下面的代码来创建我们的<code class="du kr ks kt ku b">y</code>。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="6875" class="ls jp hi ku b fi lt lu l lv lw">y = dataset[median_house_value]</span></pre><p id="bbda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们在这里说，获取名为<code class="du kr ks kt ku b">median_house_value</code>的列，并将其放入<code class="du kr ks kt ku b">y</code>中。听起来很简单。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="a761" class="ls jp hi ku b fi lt lu l lv lw">y</span></pre><p id="6dfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">0 452600.0 1 358500.0 2 352100.0 3 341300.0 4 342200.0<code class="du kr ks kt ku b"> Name: median_house_value, Length: 20640, dtype: float64</code></p><p id="70fa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，如果我们传递<code class="du kr ks kt ku b">train_test_split</code>中的<code class="du kr ks kt ku b">x</code>和<code class="du kr ks kt ku b">y</code>而不是整个数据集，我们将获得4个变量作为回报。训练集的两个变量是训练的输入和训练的输出，同样，测试集的两个变量是测试的输入和测试的输出。</p><p id="9e70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的代码显示了函数x和y的输出</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="8904" class="ls jp hi ku b fi lt lu l lv lw">train_x, test_x, train_y, test_y = train_test_split(x, y, test_size=0.3, shuffle=True, random_state=32)</span></pre><p id="fb01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看<code class="du kr ks kt ku b">train_x</code>的<code class="du kr ks kt ku b">len</code>和<code class="du kr ks kt ku b">train_y</code>以及<code class="du kr ks kt ku b">test_x</code>和<code class="du kr ks kt ku b">test_y</code>。</p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="cf1b" class="ls jp hi ku b fi lt lu l lv lw">print(fThe length of Train_x: {len(train_x)} and length of train_y: {len(train_y)})</span></pre><p id="0845" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">The length of Train_x: 14448 and length of train_y: 14448</code></p><pre class="lk ll lm ln fd lo ku lp lq aw lr bi"><span id="4c83" class="ls jp hi ku b fi lt lu l lv lw">print(fThe length of Test_x: {len(test_x)} and length of test_y: {len(test_y)})</span></pre><p id="f237" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du kr ks kt ku b">The length of Test_x: 6192 and length of test_y: 6192</code></p><p id="0100" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实际上和上面的一样，当我们给出整个数据集时。</p><h1 id="da39" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="cb9c" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在这篇文章中，我们试图理解拆分数据的必要性，以及我们如何以一种有效的方式执行这种拆分。</p><p id="58d3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们学习手册以及现代的sklearn的方法，大多数机器学习从业者都这样做。我希望你理解了这个过程，现在也能理解这个过程的原因和方式。</p><p id="3114" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就这些了，谢谢。<br/>请留下评论，也分享一下。</p></div><div class="ab cl mf mg gp mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="hb hc hd he hf"><p id="2d5a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="mm">原载于2022年2月28日</em><a class="ae kv" href="https://mlforlazy.in/why-and-how-do-we-split-the-dataset/" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://mlforlazy . in</em></a><em class="mm">。</em></p></div></div>    
</body>
</html>