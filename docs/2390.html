<html>
<head>
<title>How to Use pytest-mock to Simulate Responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用pytest-mock模拟响应</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-use-pytest-mock-to-simulate-responses-1ea41e964161?source=collection_archive---------2-----------------------#2021-04-21">https://medium.com/analytics-vidhya/how-to-use-pytest-mock-to-simulate-responses-1ea41e964161?source=collection_archive---------2-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c15cb5c25165b972d3b7922345582e62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*h-kZPeaUaDIkWO7e.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Alexandre Debiève 在<a class="ae iu" href="https://unsplash.com/photos/FO7JIlwjOtU?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=view-photo-on-unsplash&amp;utm_campaign=unsplash-ios" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="9a00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">电气、计算机或设计工程师面临的最大挑战之一是弥合硬件和软件之间的差距。编写软件来运行硬件的任务一直被证明是一项具有挑战性的任务。这主要是因为专注于学习语言语法，而没有足够的时间花在学习调试和软件测试上。当被要求证明软件在运行硬件时没有带来问题时，差距进一步扩大。这通常会导致数小时的长时间全系统测试，以确保可重复性，当涉及硬件时，由于响应缓慢，这不是一个可扩展的解决方案。对于Python开发者来说，解决方案是使用<a class="ae iu" href="https://pypi.org/project/pytest/" rel="noopener ugc nofollow" target="_blank"> pytest </a>和<a class="ae iu" href="https://pypi.org/project/pytest-mock/" rel="noopener ugc nofollow" target="_blank"> pytest-mock </a>插件来编写测试代码的单元测试，以模拟硬件响应。</p><p id="334a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意:虽然这篇文章是为硬件工程师写的，但是这个概念也可以扩展到任何外部进程或系统，比如数据库。</p><h1 id="357b" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">驱动程序代码</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0cb8" class="la ju hi kw b fi lb lc l ld le">from time<br/>import sleep<br/>from fabric import Connection</span><span id="5b03" class="la ju hi kw b fi lf lc l ld le">class Driver:<br/>    def __init__(self, hostname):<br/>        self.connection = Connection(hostname)</span><span id="7aab" class="la ju hi kw b fi lf lc l ld le">def run(self, command):<br/>        sleep(5)<br/>        return self.connection.run(command, hide=True).stdout.strip()</span><span id="0c79" class="la ju hi kw b fi lf lc l ld le">def disk_free(self):<br/>        return self.run("df -h")</span><span id="5eb0" class="la ju hi kw b fi lf lc l ld le">@staticmethod<br/>    def extract_percent(output):<br/>        free_line = output.split("\n")[1]<br/>        percent = free_line.split()[4] return percent</span></pre><p id="a8c8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的驱动程序是一个简单的例子。它使用一个名为<a class="ae iu" href="https://pypi.org/project/fabric/" rel="noopener ugc nofollow" target="_blank"> Fabric </a>的库来建立SSH连接。有两种方法:</p><ol class=""><li id="cf05" class="lg lh hi ix b iy iz jc jd jg li jk lj jo lk js ll lm ln lo bi translated"><strong class="ix hj"> run() </strong> —允许在目标上发出任何通用命令，并返回原始输出。在输出返回之前，会插入一个5秒的延迟来模拟缓慢的响应。</li><li id="abea" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js ll lm ln lo bi translated"><strong class="ix hj"> disk_free() </strong> —生成命令“df -h”，然后使用生成的命令调用<strong class="ix hj"> run() </strong>方法</li><li id="64d5" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js ll lm ln lo bi translated"><strong class="ix hj"> extract_percent() </strong> —解析原始输出并返回磁盘可用百分比</li></ol><h1 id="4997" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">以集成方式测试代码</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="870e" class="la ju hi kw b fi lb lc l ld le">import socket<br/>from mock_tutorial.driver import Driver</span><span id="e49c" class="la ju hi kw b fi lf lc l ld le">def test_driver_integrated():<br/>    d = Driver(socket.gethostname())<br/>    result = d.disk_free()<br/>    percent = d.extract_percent(result)<br/>    assert percent == "75%"</span></pre><p id="d79b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述测试代码通常以黑盒测试方式编写，用于测试该驱动程序。首先实例化驱动对象，调用<strong class="ix hj"> disk_free() </strong>函数，解析输出，最后与预期结果进行比较。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="7c79" class="la ju hi kw b fi lb lc l ld le">$ pytest -s<br/>======================== test session starts =======================<br/>platform linux -- Python 3.9.4, pytest-6.2.3, py-1.10.0, pluggy-0.13.1 rootdir: /home/chinghwa/projects/mock_tutorial<br/>plugins: mock-3.5.1<br/>collected 1 item<br/>tests/test_driver.py .                                        [100%]<br/>========================= 1 passed in 5.51s ========================</span></pre><p id="6aec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">除了执行慢了5.51秒，还有一个问题。“df -h”的输出很可能会随着时间而变化，不会停留在75%。虽然这个例子是虚构的，但它说明了以另一种方式检查输出的必要性。</p><h1 id="dcf7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">用pytest-mock测试代码以模拟响应</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f418" class="la ju hi kw b fi lb lc l ld le">import socket<br/>import pytest<br/>from mock_tutorial.driver import Driver</span><span id="d569" class="la ju hi kw b fi lf lc l ld le">def test_driver_unit(mocker):<br/>    output_list = [<br/>        "Filesystem Size Used Avail Use% Mounted on",<br/>        "rootfs 472G 128G 344G 28% /",<br/>        "none 472G 128G 344G 28% /dev", ]<br/>    output = "\n".join(output_list)<br/>    mock_run = mocker.patch( "mock_tutorial.driver.Driver.run", return_value=output )<br/>    d = Driver(socket.gethostname())<br/>    result = d.disk_free()<br/>    percent = d.extract_percent(result)<br/>    mock_run.assert_called_with("df -h") assert percent == "28%"</span></pre><p id="00aa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上面的代码被重写为使用一个模拟对象来修补(替换)run() 方法。首先，我们需要导入pytest(第2行)并从pytest-mock(第5行)调用mocker fixture。</p><p id="dc1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第12–14行，<strong class="ix hj">驱动程序</strong>的<strong class="ix hj"> run() </strong>方法被打了补丁，用预编程的响应来模拟实际的响应。这意味着任何对<strong class="ix hj"> run() </strong>的调用都将返回<strong class="ix hj">输出</strong>的字符串值。</p><p id="c0c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第18行将检查发送给<strong class="ix hj"> run() </strong>方法的命令。当调用<strong class="ix hj"> disk_free() </strong>方法时，这将生成一个“df -h”命令，并用这个命令调用<strong class="ix hj"> run() </strong>。</p><p id="155f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第19行将检查从<strong class="ix hj">输出</strong>中提取百分比的解析函数。如果第8行中的Use%被更改，这将失败，因为这是正在提取的值。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1a8f" class="la ju hi kw b fi lb lc l ld le">$ pytest -s<br/>======================== test session starts =======================<br/>platform linux -- Python 3.9.4, pytest-6.2.3, py-1.10.0, pluggy-0.13.1<br/>rootdir: /home/chinghwa/projects/mock_tutorial<br/>plugins: mock-3.5.1<br/>collected 1 item<br/>tests/test_driver.py .                                        [100%]<br/>========================= 1 passed in 0.36s ========================</span></pre><p id="7d14" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">添加模拟对象后，测试时间减少到0.36秒。缓慢的<strong class="ix hj"> run() </strong>方法被修补以更快地执行，并且还检查了解析模拟输出的代码。</p><h1 id="d767" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">摘要</h1><p id="1d45" class="pw-post-body-paragraph iv iw hi ix b iy lu ja jb jc lv je jf jg lw ji jj jk lx jm jn jo ly jq jr js hb bi translated">通过用模拟对象修补缓慢的响应，这应该为用Python开发快速执行的单元测试提供了一个良好的起点。除了单元测试之外，还应该编写集成测试，尽管它们可以不那么频繁地执行。</p><p id="4ca6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这篇文章是我用Python写的第一篇关于这个主题的文章，我希望将来能深入研究其他pytest-mock方法。</p><h1 id="ace4" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">资源</h1><ul class=""><li id="34f5" class="lg lh hi ix b iy lu jc lv jg lz jk ma jo mb js mc lm ln lo bi translated">本文代码—<a class="ae iu" href="https://github.com/chinghwayu/mock_tutorial" rel="noopener ugc nofollow" target="_blank">https://github.com/chinghwayu/mock_tutorial</a></li><li id="1f59" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js mc lm ln lo bi translated">pytest夹具—<a class="ae iu" href="https://docs.pytest.org/en/stable/fixture.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/stable/fixture.html</a></li><li id="2064" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js mc lm ln lo bi translated">pytest-mock方法—<a class="ae iu" href="https://github.com/pytest-dev/pytest-mock/" rel="noopener ugc nofollow" target="_blank">https://github.com/pytest-dev/pytest-mock/</a></li><li id="c383" class="lg lh hi ix b iy lp jc lq jg lr jk ls jo lt js mc lm ln lo bi translated">pytest标记和标记测试为慢—<a class="ae iu" href="https://docs.pytest.org/en/stable/example/markers.html" rel="noopener ugc nofollow" target="_blank">https://docs.pytest.org/en/stable/example/markers.html</a></li></ul></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="7a8d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mk">原载于2021年4月21日https://chinghwayu.com</em><em class="mk"/><a class="ae iu" href="https://chinghwayu.com/2021/04/how-to-use-pytest-mock-to-simulate-responses/" rel="noopener ugc nofollow" target="_blank"><em class="mk">。</em></a></p></div></div>    
</body>
</html>