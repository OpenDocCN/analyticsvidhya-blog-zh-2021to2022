<html>
<head>
<title>Understanding GANs — Deriving the Adversarial loss from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解GANs——从零开始推导对抗性损失</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-gans-deriving-the-adversarial-loss-from-scratch-ccd8b683d7e2?source=collection_archive---------1-----------------------#2021-03-03">https://medium.com/analytics-vidhya/understanding-gans-deriving-the-adversarial-loss-from-scratch-ccd8b683d7e2?source=collection_archive---------1-----------------------#2021-03-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a81b21bed0595e4e40eaae33068b2d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cs048_fLVYbN1XpZZtV8zQ.jpeg"/></div></div></figure><p id="a9ec" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated"><span class="l jp jq jr bm js jt ju jv jw di">G</span>generate adversarial networks(简称GANs)是一项无监督的学习任务，其中生成器模型学习发现输入数据中的模式，以便该模型可以用于生成训练数据的新样本。</p><p id="6973" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">GAN的主要思想是<strong class="is hj">对抗训练</strong>，两个神经网络互相对抗，并提高自己以更好地战斗。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jx"><img src="../Images/f5fca9af60a5e47cf28c280f5c233534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krq4xN2EAfaJLCIwm7uVcQ.png"/></div></div></figure><p id="3153" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器将噪声向量作为输入，然后将噪声向量转换为假训练样本，然后通过鉴别器。鉴别器获取真实样本(来自训练数据)和虚假样本(由生成器生成)，然后尝试区分虚假样本和真实样本。换句话说，<strong class="is hj">生成器试图通过向鉴别器显示虚假的训练数据样本</strong>来欺骗鉴别器，而鉴别器试图尽可能地聪明。</p><p id="0583" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">主要思想是，如果生成器欺骗了鉴别器，那么这意味着鉴别器应该改进自己。另一方面，如果鉴别器完美地分类了假样本和真样本，那么这意味着发生器应该自我改进，以便能够欺骗鉴别器！</p><p id="a1b1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">可能的原因是，</p><ol class=""><li id="dc6d" class="kd ke hi is b it iu ix iy jb kf jf kg jj kh jn ki kj kk kl bi translated"><strong class="is hj">生成器欺骗鉴别器</strong>表示鉴别器未能对假图像样本进行分类。在这种情况下，<strong class="is hj"> </strong>鉴别能力应该会提高，因此损耗将仅通过鉴别器反向传播！</li><li id="0637" class="kd ke hi is b it km ix kn jb ko jf kp jj kq jn ki kj kk kl bi translated"><strong class="is hj">鉴别器在鉴别真假图像</strong>方面做得很好，这意味着假图像还不足以迷惑鉴别器<strong class="is hj">。</strong>这意味着发电机应该自我改进，因此损耗将仅通过发电机网络反向传播！</li></ol><h1 id="44f5" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">但是，问题是生成器如何能骗过鉴别器呢？</h1><p id="39a7" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">直观地，生成器学习我们的训练数据的概率分布。下图直观地描述了这个想法。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lu"><img src="../Images/7158df11bd9a7dcb97d369f1ff292572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8svmmHGrNY6lzY5fSgdI4Q.png"/></div></div></figure><p id="1d4b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">一句话，生成器学习近似实际训练数据的分布，然后从学习的分布中采样。训练时，发生器和鉴别器会有一场战斗，两者交替训练，同时保持另一个固定！</p><h1 id="259a" class="kr ks hi bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">导出对抗性损失:</h1><p id="e2c9" class="pw-post-body-paragraph iq ir hi is b it lp iv iw ix lq iz ja jb lr jd je jf ls jh ji jj lt jl jm jn hb bi translated">鉴别器只不过是一个执行二元分类(真的或假的)的分类器。那么，我们用什么损失函数进行二分类呢？不就是<strong class="is hj">二进制交叉熵</strong>吗？</p><p id="34aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">二元交叉熵损失函数的方程如下所示。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lv"><img src="../Images/e7fc05b278c97041c6756810e4bec07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MuelMXmEUsFmhW3jQqNGaQ.png"/></div></div></figure><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/0a6a589a004ae172f3c3a468d03e89c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQEEl8dvDSnNHWRgy3M5Nw.png"/></div></div></figure><p id="6a6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Z </strong>:噪声向量(噪声向量的维数为超参数)。</p><p id="9021" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> G(Z) </strong>:给定噪声矢量Z时发电机的输出。</p><p id="4da7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> X: </strong>真实的训练数据。</p><p id="45f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> D(G(Z)) </strong>:给定假生成数据或G(Z)时鉴频器的输出。</p><p id="dd9a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> D(X) </strong>:给定来自X的真实训练数据时鉴别器的输出。</p><p id="7068" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴别器采用X或G(Z)。请注意，鉴别器只不过是一个二元分类器，因此，<strong class="is hj">我们将D(X)标记为1，D(G(Z))标记为0 </strong>。</p><p id="678c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们希望我们的鉴别器将所有D(X)标记为1，将所有D(G(Z))标记为0。对吗？</p><p id="62f5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/9873167a49d9cbcf56bfd79730b681a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dAUmoeZhF9RCpm7u7UJBqA.png"/></div></div></figure><p id="3993" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴别器应该使Log(D(X))最大化，并且因为Log是单调函数，所以如果<strong class="is hj">鉴别器使D(X) </strong>最大化，Log(D(X))将自动最大化。</p><p id="e407" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/55effab241435af885187c96ea9c03dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tCtFx7JfPCnntf1m-nfPg.png"/></div></div></figure><p id="08d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">鉴别器需要最大化log(1 — D(G(Z)))，这意味着它必须<strong class="is hj">最小化D(G(Z)) </strong>。</p><p id="ee66" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，鉴别器的损失函数(对于单个样本)变成，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lz"><img src="../Images/8563dc453ef6aab208bfa3f3755dbda1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K6bZ2OO2nTelT38A5c-zmA.png"/></div></div></figure><blockquote class="ma mb mc"><p id="1ea9" class="iq ir kc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated">鉴别器将<strong class="is hj">最大化D(X) </strong>并且<strong class="is hj">最小化D(G(Z)) </strong>以整体最大化上述损失函数。</p></blockquote><p id="e5af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，D(X)和D(G(Z))都是概率值，并且<strong class="is hj">都位于0和1之间</strong>。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/cb88d79a1d8eb2e23f15a5c6c6d9ad72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*14VTh_3J2Qo57tZ4QSa0qg.png"/></div></div></figure><p id="7fbe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，鉴别器在一批中的损失函数是，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/5d8d5d416479198210ffe59b55815d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TP6XHQU9JLUs8Bc-812w2g.png"/></div></div></figure><blockquote class="ma mb mc"><p id="bbd6" class="iq ir kc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated">其中，P(X)是真实训练数据的概率分布，P(Z)是噪声向量Z的概率分布。通常，P(Z)是高斯或均匀的。</p></blockquote><p id="1206" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">生成器需要通过生成尽可能真实的图像来欺骗鉴别器。这意味着<strong class="is hj">生成器应该生成这样的G(Z ),如果我们通过鉴别器，它将被标记为1。</strong></p><blockquote class="ma mb mc"><p id="7b3c" class="iq ir kc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated">因此，鉴别器希望D(G(Z))等于1，生成器希望D(G(Z))等于0。</p></blockquote><p id="9a85" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，从二元交叉熵来看，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/19838b4434b2a64342ea4680b1603855.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*yAfwic0weJd2ETvACp49hQ.png"/></div></figure><p id="93da" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的只是一个样本。一批下来，会是，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/40e0d56baea0176c00d42023ac990069.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUVLNkbLv2B68nE294G2JA.png"/></div></div></figure><p id="6230" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">发电机将最小化上述损失函数，并且为了最小化上述损失函数，发电机必须最大化D(G(Z))。现在很清楚了<strong class="is hj">鉴别器想最小化D(G(Z))，生成器想最大化D(G(Z))。</strong></p><p id="4a3b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要知道，发电机永远不会看到任何真实数据，但为了完整起见，发电机损耗函数可以写成如下形式！</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/8353648a347bec3332d52e72b8cd49ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xDQynsEBfqK9Lfkpfaw3xQ.png"/></div></div></figure><p id="ad9d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意，发生器无法控制第一项，因此<strong class="is hj">发生器只会最小化第二项</strong>。</p><p id="9b5f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设，<strong class="is hj"> D </strong>是鉴频器的参数，<strong class="is hj"> G </strong>是发生器的参数。所以，我们可以把损失函数写成，</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/3fd4a04fa96d10cec11829a928e7cb1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ZoaIG2lLxp2MXt0ZFTKwQ.png"/></div></div></figure><h2 id="2236" class="mm ks hi bd kt mn mo mp kx mq mr ms lb jb mt mu lf jf mv mw lj jj mx my ln mz bi translated"><strong class="ak">这意味着鉴别器参数(由D定义)将最大化损失函数，而发生器参数(由G定义)将最小化损失函数。</strong></h2><blockquote class="ma mb mc"><p id="8085" class="iq ir kc is b it iu iv iw ix iy iz ja md jc jd je me jg jh ji mf jk jl jm jn hb bi translated">对抗损失可以通过梯度下降来优化。但是当训练一个GAN <strong class="is hj">时，我们不会同时训练发生器和鉴别器</strong>，当训练发生器时，我们冻结鉴别器，反之亦然！</p></blockquote><p id="e020" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最初的GAN论文提供了一个伪代码，显示了GAN是如何被训练的。</p><figure class="jy jz ka kb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es na"><img src="../Images/39c5bcc55003d39b8d409ae68939e5b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBaGh1E4wu1LTJiwLy-n3Q.png"/></div></div></figure><p id="994a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我认为这并不难理解！:)</p><p id="5626" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">参考文献:</strong></p><div class="nb nc ez fb nd ne"><a href="https://en.wikipedia.org/wiki/Generative_adversarial_network" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">生成对抗网络</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">生成对抗网络(GAN)是由Ian Goodfellow和他的团队设计的一类机器学习框架</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">en.wikipedia.org</p></div></div><div class="nn l"><div class="no l np nq nr nn ns io ne"/></div></div></a></div><div class="nb nc ez fb nd ne"><a href="https://arxiv.org/abs/1406.2661" rel="noopener  ugc nofollow" target="_blank"><div class="nf ab dw"><div class="ng ab nh cl cj ni"><h2 class="bd hj fi z dy nj ea eb nk ed ef hh bi translated">生成对抗网络</h2><div class="nl l"><h3 class="bd b fi z dy nj ea eb nk ed ef dx translated">我们提出了一个新的框架，通过一个对抗的过程来估计生成模型，在这个过程中，我们同时…</h3></div><div class="nm l"><p class="bd b fp z dy nj ea eb nk ed ef dx translated">arxiv.org</p></div></div></div></a></div></div></div>    
</body>
</html>