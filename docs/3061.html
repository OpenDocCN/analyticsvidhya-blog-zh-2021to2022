<html>
<head>
<title>Sparkify: Predicting the user churn using Apache Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Sparkify:使用Apache Spark预测用户流失</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sparkify-predicting-the-user-churn-using-apache-spark-ee4178f859c8?source=collection_archive---------2-----------------------#2021-06-01">https://medium.com/analytics-vidhya/sparkify-predicting-the-user-churn-using-apache-spark-ee4178f859c8?source=collection_archive---------2-----------------------#2021-06-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d4b09fff88dd1adcbaf6ecf9790b0fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vyXO4v0OQsmcctUcx6jL3w.png"/></div></div></figure><p id="8d59" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个项目旨在预测一个名为<strong class="ir hi"> Sparkify </strong>的虚拟数字音乐流媒体服务的用户流失</p><p id="3330" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">客户流失预测是业内最受欢迎的大数据用例之一，如果预测客户在不久的将来会流失，它可以帮助企业主动做出如何留住客户的决策，方法是针对客户开展促销活动，并给他们留下继续经营的理由。</p><p id="ce88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用<strong class="ir hi"> CRISP-DM </strong>(数据挖掘的跨行业流程)的行业实践来分析、探索和建模我们的解决方案，我们将在以下部分解释该解决方案:</p><ol class=""><li id="ea8a" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">商业理解</strong></li><li id="9698" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">数据理解</strong></li><li id="e6f3" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">准备数据</strong></li><li id="f91c" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">数据建模</strong></li><li id="8980" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">评估结果</strong></li><li id="6ca7" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated"><strong class="ir hi">展开</strong></li></ol><h1 id="5ada" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">商业理解</h1><p id="4452" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">Sparkify是一项数字音乐流媒体服务，用户可以通过收听歌曲之间的广告或支付月订阅费来获得无广告体验。只要用户愿意，他们也可以决定从高级降级到免费，从免费升级到高级，甚至取消服务。</p><p id="2857" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当用户从服务中取消时，就是我们表示用户已经改变的时候。</p><h1 id="4097" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">数据理解&amp;数据准备</strong></h1><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/14bb5dbb2a0556cf7afee82176109a2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5zXdhGlCy1jWlIthp-KGjw.png"/></div></div></figure><p id="90e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所提供的数据集基本上由平台上的每个用户操作的日志组成。每一个动作都标有一个特定的时间戳，即该动作发生的时间</p><p id="5942" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在数据集中，我们有691个用户，有543705个事件</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lj"><img src="../Images/281938da2b6bf3878ba91c4bb56794bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*V1UvXyLvlYWaU2kayVPqyQ.png"/></div></figure><p id="294e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些用户执行不同的操作，点击不同的页面，正如你在分布图中看到的，用户执行的大部分操作是点击下一首歌曲</p><p id="cd57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也有用户升级/降级了他们的服务，然后也有99个用户取消了他们的服务，这99个用户将被标记为被搅动。</p><p id="8065" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在来看一下有过搅动的用户的一些方面，以及他们与没有搅动的用户的比较</p><p id="3728" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将首先看一下与被搅动的用户相比，性别是如何分布的</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/56f05ec26ee649bd4f19fe3371718b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RkLHrziEoS6rbbUoONvBsQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated"><em class="lp">男性顾客比女性顾客更容易流失</em></figcaption></figure><p id="c9bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在来看一些指标，以及它们如何在活跃用户和不活跃用户之间进行比较</p><div class="lf lg lh li fd ab cb"><figure class="lq ii lr ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/259888357d4843b2a6cdf79e803ff835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*sM5ZQrXQ9LsFE0Z5uj3iPw.png"/></div></figure><figure class="lq ii lw ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/f38edee10e4b47f202e385069ae941a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*PKMtd18-3E9y3nix1fONWA.png"/></div></figure></div><div class="ab cb"><figure class="lq ii lx ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/f9eeb724ee0b9abd355702645431ec8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*Y9kR9bYQaEGpoDF400MAtw.png"/></div></figure><figure class="lq ii ly ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/609525404701d383637c9e61d33da3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*H-MkJn68WMsIzd15q241LA.png"/></div></figure></div><div class="ab cb"><figure class="lq ii lz ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/7c02e1d7b0975f0a71a0c4e6e76d36f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*w1BGN_NwR__fHskTq3lY_w.png"/></div></figure><figure class="lq ii ma ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><img src="../Images/ca29ecc38e0b470714d93e1718c5312a.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*ADoYbC7nk3SXFT5NIgPSng.png"/></div></figure></div><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/84e53c5efb04584da6736d3fb8cad002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LhRE9S4IXCv9zOTW0fWOtQ.png"/></div></div></figure><h1 id="6474" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">数据建模</strong></h1><p id="2001" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">作为数据建模的一部分，在用户流失预测中识别并使用了11个特征，这些特征是:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/a33abdefc05d31dd4fd83d5696845e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h8hVCKpBGFEJ5EsXteiLNA.png"/></div></div></figure><p id="0751" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上面的字段列表中，<strong class="ir hi"> userId </strong>被省略，性别和级别等分类变量被一键编码，因为它们都只有两个不同的值，所以它们被转换为二进制列。</p><p id="bca8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">诸如<strong class="ir hi"> total_lifetime </strong>(自注册以来的时间)、<strong class="ir hi"> average_songs_played </strong>(每次会话播放的平均歌曲数)等功能必须经过设计</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="33e8" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># Total time since registration</em><br/>total_lifetime = user_log_valid.select('userId', 'registration', 'ts').withColumn('total_lifetime', (user_log_valid.ts - user_log_valid.registration))\<br/>    .groupBy('userId').agg({'total_lifetime' : 'max'})\<br/>    .withColumnRenamed('max(total_lifetime)', 'total_lifetime')\<br/>    .select('userId', (col('total_lifetime')/1000/3600/24).alias('total_lifetime'))<br/>total_lifetime.show(5)</span><span id="597a" class="mi kc hh me b fi mo mk l ml mm"><em class="mn"># Average songs played per session</em><br/>avg_song_played = user_log_valid.where('page == "NextSong"').groupby(['userId', 'sessionId']).count().groupby(['userId']).agg({'count':'avg'}).withColumnRenamed('avg(count)', 'avg_songs_played')<br/>avg_song_played.show(5)</span></pre><p id="f50c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大多数其他功能都是按<strong class="ir hi">用户id</strong>分组时的总和</p><p id="192b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">标签(用户流失)</strong>和<strong class="ir hi">降级</strong>也是使用窗口函数计算的</p><p id="277c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在省略了<strong class="ir hi"> userId </strong>和<strong class="ir hi"> label </strong>变量后，使用<strong class="ir hi"> VectorAssembler </strong>和<strong class="ir hi"> StandardScaler </strong>对这些特征进行矢量化和缩放</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="aaa0" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># Three ML algorithms will be used to build model and f1 score will be used to optimize.  These are</em><br/><em class="mn"># 1. Logistic Regression, 2. Random Forest Classifier and 3. Gradient Boosting Trees</em><br/><em class="mn"># First of vectorize numerical variables in model data, transform them for feature pipeline.</em><br/>columns = []   <br/><strong class="me hi">for</strong> field <strong class="me hi">in</strong> model_data.schema.fields :<br/>            columns.append(field.name)<br/><br/>columns.remove('label')<br/>columns.remove('userId')<br/>assembler = VectorAssembler(inputCols=columns, outputCol="num_features")<br/>model_data = assembler.transform(model_data)<br/><br/><em class="mn"># using standard scaler</em><br/>scaler = StandardScaler(inputCol="num_features", outputCol="features", withStd=<strong class="me hi">True</strong>)<br/>scalerModel = scaler.fit(model_data)<br/>model_data = scalerModel.transform(model_data)</span></pre><p id="1326" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，最终矢量化、缩放的特征数据集被分成训练集、测试集和验证集，以执行模型的训练和评估。</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="f308" class="mi kc hh me b fi mj mk l ml mm"><em class="mn">#Split the full dataset into train, test, and validation sets.</em> train, rest = model_data.randomSplit([0.6, 0.4], seed=42) validation, test = rest.randomSplit([0.5, 0.5], seed=42)</span></pre><h1 id="381b" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">评估结果</strong></h1><p id="bf69" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated"><strong class="ir hi">混淆矩阵</strong>是一个表格，通常用于描述一个分类模型对一组真实值已知的测试数据的性能。</p><p id="48d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">准确性</strong>衡量分类器做出正确预测的频率。它是正确预测数与总预测数的比率:</p><p id="2c7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mp mq mr me b">Accuracy = (True Positives + True Negative) / (True Positives + False Positives + True Negatives + False Negatives)</code></p><p id="8aa8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">精度告诉我们正确预测的比例实际上是正确的。它是真阳性与所有阳性的比率:</p><p id="02c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mp mq mr me b">Precision = True Positives / (True Positives + False Positives)</code></p><p id="7c6c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">回忆(敏感度)</strong>告诉我们实际上正确的预测中有多少被我们归类为正确的。它是真阳性与所有实际阳性预测的比率:</p><p id="2045" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du mp mq mr me b">Recall = True Positives / (True Positives + False Negative)</code></p><p id="851c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> F-beta评分</strong>是一个同时考虑精确度和召回率的指标:</p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/7fe29e6dcb1d5207ef45c6d1d108e5ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:522/format:webp/0*0qiiuTJ0XUHgFanO.png"/></div></figure><p id="ddaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据集不平衡的事实也意味着<strong class="ir hi">精确度</strong>没有太大帮助，因为即使我们获得高精确度，实际预测也不一定那么好。在这些情况下，通常建议使用<strong class="ir hi">精确</strong>和<strong class="ir hi">召回</strong></p><p id="6a8b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们比较3个模型的结果:</p><ul class=""><li id="7f70" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm mt jt ju jv bi translated"><strong class="ir hi">逻辑回归</strong></li><li id="861d" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mt jt ju jv bi translated"><strong class="ir hi">随机福里斯特</strong></li><li id="a17f" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm mt jt ju jv bi translated"><strong class="ir hi">梯度提升树</strong></li></ul><ol class=""><li id="a1b0" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated"><strong class="ir hi">逻辑回归</strong></li></ol><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="2e26" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># 1. Logistic Regression </em><br/><br/><em class="mn"># initialize classifier, set evaluater and build paramGrid</em><br/>lr = LogisticRegression(maxIter=10)<br/>f1_evaluator = MulticlassClassificationEvaluator(metricName='f1')<br/>paramGrid = ParamGridBuilder().build()<br/>crossval_lr = CrossValidator(estimator=lr, evaluator=f1_evaluator, estimatorParamMaps=paramGrid,numFolds=3)<br/><br/><em class="mn"># Calculate time metric of model. </em><br/>start_time = time()<br/>cvModel_lr = crossval_lr.fit(train)<br/>end_time = time()<br/>cvModel_lr.avgMetrics<br/>seconds = end_time- start_time<br/><br/>results_lr = cvModel_lr.transform(validation)<br/><br/>evaluator = MulticlassClassificationEvaluator(predictionCol="prediction")</span><span id="8acd" class="mi kc hh me b fi mo mk l ml mm"><strong class="me hi">Logistic Regression Metrics:<br/>Accuracy of model is : 0.7443609022556391<br/>F1 score of model is :0.6724855617304131<br/>The training process of model took 13.907336235046387 seconds</strong></span></pre><p id="c5b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2。随机森林</strong></p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="cdcf" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># 2. Random Forest Classifier </em><br/><br/><em class="mn"># initialize classifier, set evaluater and build paramGrid</em><br/>rf = RandomForestClassifier()<br/>f1_evaluator = MulticlassClassificationEvaluator(metricName='f1')<br/>paramGrid = ParamGridBuilder().build()<br/>crossval_rf = CrossValidator(estimator=rf,estimatorParamMaps=paramGrid,evaluator=f1_evaluator,numFolds=3)<br/><br/><em class="mn"># Calculate time metric of model. </em><br/>start_time = time()<br/>cvModel_rf = crossval_rf.fit(train)<br/>end_time = time()<br/>cvModel_rf.avgMetrics<br/>seconds = end_time- start_time<br/><br/>results_rf = cvModel_rf.transform(validation)<br/><br/>evaluator = MulticlassClassificationEvaluator(predictionCol="prediction")</span><span id="0712" class="mi kc hh me b fi mo mk l ml mm"><strong class="me hi">Random Forest Metrics:<br/>Accuracy of model is : 0.7969924812030075<br/>F1 score of model is :0.7585255822483037<br/>The training process of model took 12.764495134353638 seconds</strong></span></pre><p id="9ee0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3。梯度增强树</strong></p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="b67f" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># 3. Gradient Boosting Trees</em><br/><br/><em class="mn"># initialize classifier, set evaluater and build paramGrid</em><br/>gbt = GBTClassifier(maxIter=10,seed=42)<br/>f1_evaluator = MulticlassClassificationEvaluator(metricName='f1')<br/>paramGrid = ParamGridBuilder().build()<br/>crossval_gbt = CrossValidator(estimator=gbt,estimatorParamMaps=paramGrid,evaluator=f1_evaluator,numFolds=3)<br/><br/><em class="mn"># Calculate time metric of model. </em><br/>start_time = time()<br/>cvModel_gbt = crossval_gbt.fit(train)<br/>end_time = time()<br/>cvModel_gbt.avgMetrics<br/>seconds = end_time- start_time<br/><br/>results_gbt = cvModel_gbt.transform(validation)<br/><br/>evaluator = MulticlassClassificationEvaluator(predictionCol="prediction")</span><span id="ceb9" class="mi kc hh me b fi mo mk l ml mm"><strong class="me hi">Gradient Boosted Trees Metrics: <br/>Accuracy of model is : 0.8270676691729323 <br/>F1 score of model is :0.799474962304081 <br/>The training process of model took 31.332529306411743 seconds</strong></span></pre><p id="0840" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">细化</strong></p><p id="7db3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，梯度增强树具有最好的f1值，这就是为什么我选择它用于下一步，通过让<code class="du mp mq mr me b">ParamGridBuilder()</code>和<code class="du mp mq mr me b">CrossValidator()</code>搜索所有参数，我将找到最好的超参数</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="1dab" class="mi kc hh me b fi mj mk l ml mm"><em class="mn"># Optimizing Hyperparameters in Random Forest Classification</em><br/>clf = GBTClassifier()<br/>maxIter=[5,10,20]<br/>maxDepth=[10,20]    <br/>paramGrid = ParamGridBuilder().addGrid(clf.maxIter, maxIter).addGrid(clf.maxDepth, maxDepth).build()       <br/>crossval = CrossValidator(estimator = Pipeline(stages=[clf]),<br/>                         estimatorParamMaps = paramGrid,<br/>                         evaluator = MulticlassClassificationEvaluator(metricName='f1'),<br/>                         numFolds = 3)<br/><br/>cvModel_gbt = crossval.fit(train)<br/>predictions = cvModel_gbt.transform(test)<br/><br/>evaluator = MulticlassClassificationEvaluator(metricName='f1')<br/>f1_score = evaluator.evaluate(predictions.select(col('label'), col('prediction')))<br/>print('The F1 score is <strong class="me hi">{:.2%}</strong>'.format(f1_score)) <br/>   <br/>bestPipeline = cvModel_gbt.bestModel</span><span id="c030" class="mi kc hh me b fi mo mk l ml mm"><strong class="me hi">The F1 score is 0.818<br/>Best parameters : max depth:10, max Iter:5</strong></span></pre><p id="0d8d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">特征重要性</strong></p><p id="5ad8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们在最终调整和优化的模型中发现特性的重要性</p><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="34bd" class="mi kc hh me b fi mj mk l ml mm">Feature_Importance_Scores = gbt_best_model.featureImportances.values.tolist()<br/>Feature_Importance_df = pd.DataFrame({'Feature_Importance_Scores': Feature_Importance_Scores, 'Features': columns})<br/>plt.title('Features Importance Scores of Gradient Boosted Trees Model')<br/>sns.barplot(x='Feature_Importance_Scores', y='Features', data=Feature_Importance_df, color="blue")</span></pre><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/6269f12eb8ed19610fa2c3ce21f134dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZePyqnkTHuh-y7Z95x9yDg.png"/></div></div></figure><pre class="lf lg lh li fd md me mf mg aw mh bi"><span id="1477" class="mi kc hh me b fi mj mk l ml mm"><em class="mn">We observe that register_duration (days) and average listened songs per session are top 2 most important features while predicting churn.</em></span></pre><h1 id="155b" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">部署</h1><p id="86d4" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">为了训练和部署模型，我们使用了IBM Watson Studio，它让您可以在自由层中用有限的资源创建一个Spark环境，我利用它来探索、训练和评估我的模型。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/2bd322c43445de9f4d4bacf317cdd7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNfQ_z-tcj_DJ9vHvC313A.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">使用Spark 2.4和Python 3.7环境创建一个项目</figcaption></figure><p id="e160" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该环境由一个Apache Spark集群组成，该集群由1个驱动程序节点(1个vCPU和4GB RAM)和2个执行器节点(1个vCPU和4GB RAM)组成</p><p id="22ad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些节点运行Apache Spark v2.4和Python 3.7，并附带一个笔记本，用于探索、训练和评估模型。</p><figure class="lf lg lh li fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/c57bdc902a04e758e54d852604bf30ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XfRjWRyp2Sn0VrPbeiNAgA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">带有笔记本和Apache Spark环境的IBM Watson项目</figcaption></figure><h1 id="0fa1" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">结论</strong></h1><p id="8dd8" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">我们的目标是预测用户是否会取消服务，以使公司能够为他提供优惠或折扣，从而留住这些用户。在清理数据并将它们建模为准备用于ML训练的数据集之后，我们测试了三个不同模型的性能。考虑到<strong class="ir hi"> F-1分数</strong>最佳模型是<strong class="ir hi">梯度提升树。</strong>尽管结果很好，但该模型可以通过设计更多的工程特性来捕捉一些与用户对服务的满意度相关的行为模式，从而得到改进:推荐引擎好吗？意思是推荐给用户的歌真的符合他们的口味。从<strong class="ir hi"> GBT </strong>的特性重要性来看，原始特性<em class="mn"> register_duration </em>和<em class="mn">平均每期收听歌曲数</em>相当重要</p><p id="2362" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:</strong>代码可以在这个G <a class="ae mx" href="https://github.com/abhinavrohatgi30/sparkify-user-churn" rel="noopener ugc nofollow" target="_blank"> ithub库</a>中找到</p></div></div>    
</body>
</html>