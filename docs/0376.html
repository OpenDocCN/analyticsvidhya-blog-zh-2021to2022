<html>
<head>
<title>How to automate Whatsapp (or any website) with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Python自动化Whatsapp(或任何网站)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-automate-whatsapp-or-any-website-with-python-71d10dad7b68?source=collection_archive---------6-----------------------#2021-01-14">https://medium.com/analytics-vidhya/how-to-automate-whatsapp-or-any-website-with-python-71d10dad7b68?source=collection_archive---------6-----------------------#2021-01-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ee5d60b0919d7dd1d231ceb76b1bd448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rmkcy5kKlGzW44d0.jpg"/></div></div></figure><p id="5f33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本文将介绍如何使用名为selenium的Python模块以编程方式自动化WhatsApp Web或任何其他网页。这可能会受到一些页面的限制，这些页面专门使用验证码来防止使用机器人，但是selenium对于实验来说非常好。</p><p id="60f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这篇文章在很大程度上受到了我最近完成的一个项目的启发:<a class="ae jo" href="https://zee.gl/OiKGKfX" rel="noopener ugc nofollow" target="_blank"> WhatsappPlusPlus </a>，在这个项目中，我自动化了WhatsApp Web，创建了一个浮动窗口来给我的朋友发短信，很像脸书的聊天工具，但要原始得多。该项目在GUI和其他功能的其他模块中使用Tkinter，但是今天我们不会讨论它，所以如果您感兴趣，请查看代码。</p><p id="7eee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">使用本文末尾的代码查看示例项目。</strong></p><h1 id="50c0" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">硒是什么？</h1><p id="5196" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">Selenium是web自动化的python模块。这与网络抓取有很大不同，后者主要是在静态网站上完成的，HTML通常是在静态网站上下载和解析的。相反，Web自动化是用代码与网页上的元素进行交互的行为。Selenium是一个一体化的包，允许我们解析动态页面中的html，并与元素进行交互。理论上，selenium可以用于web抓取，但是我不推荐它。</p><h1 id="b4a5" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">安装</h1><p id="e142" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">我们需要做的第一件事是安装硒。</strong>这很容易做到，使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="06c8" class="lb jq hi kx b fi lc ld l le lf">pip install selenium</span></pre><p id="c907" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果这不起作用，请查看我在<a class="ae jo" href="https://kgdavidson.co.uk/python-bare-minima--how-to-install-modules-with-pip-and-fix-it-when-it-fails/" rel="noopener ugc nofollow" target="_blank">如何用PIP安装模块(并在它失败时修复它)</a>中的故障排除提示来安装selenium。</p><p id="3233" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第二件事是让webdriver与selenium一起使用。webdriver是浏览器的精简版本，专门用于自动化。大多数现代浏览器都有可供下载的网络驱动程序。然而，在本教程中，我们将使用Chrome webdriver。下载可以在<a class="ae jo" href="https://zee.gl/1kR8EgB" rel="noopener ugc nofollow" target="_blank">这里</a>找到。你必须确保驱动程序版本与你安装的Chrome版本相匹配，并且你已经解压了存档文件。</strong></p><h1 id="008c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">入门指南</h1><p id="5fd1" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">既然我们已经有了所有需要的东西，我们可以开始写代码了。我建议创建一个新文件夹来包含所有内容。<strong class="is hj">我已经将下载的chromedriver放在了一个空python项目(main.py)旁边的文件夹中，我们的代码将放在那里。</strong></p><h2 id="3226" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">设置驱动程序</h2><p id="a1e2" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先，我们将导入以下内容:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e7a2" class="lb jq hi kx b fi lc ld l le lf">from selenium import webdriver import time</span></pre><p id="b56c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们导入<em class="lt">时间</em>纯粹是为了延迟后面的事情，防止事情跑得太快。</p><p id="1202" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们将使用以下代码来设置selenium以使用我们的驱动程序:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="fdcb" class="lb jq hi kx b fi lc ld l le lf">currentPath = __file__.split("main.py")[0] <br/>driverPath = currentPath + r"chromedriver.exe" <br/>driver = webdriver.Chrome(driverPath)</span></pre><p id="9cb8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lt">current path</em>变量简单地获取包含我们的python文件</strong>的文件夹的路径，并且通过扩展，获取包含我们的chromedriver的文件夹的路径。</p><p id="eee1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lt">driver path</em>变量使用<em class="lt"> currentPath </em>创建chromedriver的完整路径。</strong>这样做是为了防止从不同的地方运行python文件所导致的错误。这两行确保python代码找到chromedriver，只要它在同一个文件夹中。</p><p id="56a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"><em class="lt">驱动</em>变量将作为我们对浏览器窗口的直接访问，并将用于所有未来的交互。</strong>我们使用从selenium导入的webdriver组件指定webdriver用于Chrome。我们将驱动程序的路径作为参数传入。如果可靠性不成问题，你可以用chromedriver的完整路径替换<em class="lt"> driverPath </em>。</p><h2 id="832a" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">安全关闭浏览器</h2><p id="abb9" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">单独运行这段代码将会显示一个chrome窗口，通知说:“Chrome正由自动化测试软件控制。”在python终端中还有一条消息:“DevTools监听ws://…..”。</p><p id="c473" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你会看到python代码会继续运行，直到你关闭chrome窗口。但是，我们希望在结束程序时正确关闭chrome窗口。这很容易做到，使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e074" class="lb jq hi kx b fi lc ld l le lf">driver.close()</span></pre><p id="9814" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将它添加到代码中会使浏览器窗口在突然关闭之前打开一会儿。我们想做的是在关闭浏览器窗口之前运行一些代码。<strong class="is hj">因此，我们将在开发过程中对该行进行注释。</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ef24" class="lb jq hi kx b fi lc ld l le lf">#driver.close()</span></pre><h2 id="6f8b" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">加载网站</h2><p id="0de3" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们需要selenium的下一个基本功能是加载一个特定的网站。这也很简单，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="eeb0" class="lb jq hi kx b fi lc ld l le lf">driver.get("http://web.whatsapp.com")</span></pre><p id="bdeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你可以把任何网站放在报价里面，它就会被加载。</p><h1 id="2a89" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">设置ChromeDriver选项</h1><p id="965c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">ChromeDriver选项只是您在代码中指定的使用驱动程序的首选项。有两个你应该知道的ChromeDriver选项。我们将只使用其中的一个来自动化Whatsapp，但是另一个是值得了解的。</p><h2 id="0ab3" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">设置选项</h2><p id="6f3d" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先，我们需要导入以下内容:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="4321" class="lb jq hi kx b fi lc ld l le lf">from selenium.webdriver.chrome.options import Options</span></pre><p id="7ca8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这让我们创建一个<em class="lt"> chromeOptions </em>变量:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="7de8" class="lb jq hi kx b fi lc ld l le lf">chromeOptions = Options()</span></pre><p id="9fa8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我们必须在驱动变量创建之前创建此变量</strong>，因为我们将调整驱动变量创建，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="809d" class="lb jq hi kx b fi lc ld l le lf">driver = webdriver.Chrome(driverPath, options=chromeOptions)</span></pre><p id="cf1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">既然我们的驱动程序变量已经被更改为使用我们的选项，我们需要通过<em class="lt"> chromeOptions </em>变量指定您想要使用的选项。<strong class="is hj">我们添加的所有选项都需要在初始化<em class="lt"> chromeOptions </em>变量之后、驱动程序创建之前直接出现。</strong></p><h2 id="eeca" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">在会话之间保存cookies</h2><p id="1332" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">我们将利用的第一个选项是在脚本运行之间保存cookies的能力。在我们的情况下，这是必要的，以防止用户在跑步时扫描新的二维码。可以这样做:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ed36" class="lb jq hi kx b fi lc ld l le lf">chromeOptions.add_argument("user-data-dir=" + currentPath + "cookies")</span></pre><p id="7c05" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这行代码的作用是指定cookie将保存在一个名为<em class="lt">cookie</em>的文件夹中，这个文件夹与我们的脚本在同一个文件夹中。这通过使用我们的<em class="lt"> currentPath </em>变量来表示。文件夹路径可以是任何东西，这正是我所选择的。</p><h2 id="f4a8" class="lb jq hi bd jr lg lh li jv lj lk ll jz jb lm ln kd jf lo lp kh jj lq lr kl ls bi translated">隐藏浏览器窗口</h2><p id="0d36" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在一些selenium项目中，您可能会发现需要隐藏浏览器窗口并向用户显示自定义GUI。您可以使用以下方式在selenium中隐藏浏览器窗口:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="198a" class="lb jq hi kx b fi lc ld l le lf">chromeOptions.add_argument('headless') </span><span id="7a55" class="lb jq hi kx b fi lu ld l le lf">chromeOptions.add_argument( "user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3312.0 Safari/537.36")<br/>chromeOptions.add_argument("remote-debugging-port=3333")</span></pre><p id="81c9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一行是隐藏窗口的那一行。另外两个只是我的推荐，不完全需要。</p><p id="12b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">包含第二行是因为一些无头模式的网站会出现错误。例如，WhatsApp Web将浏览器注册为过时。<strong class="is hj">第二行绕过了这一点，让网站认为浏览器是更新版本。</strong></p><p id="fd21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第三行指定了无头模式的远程调试端口。<strong class="is hj">这意味着如果你想在开发无头模式时看到你的浏览器窗口，你可以转到:</strong></p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="1055" class="lb jq hi kx b fi lc ld l le lf">localhost:3333</span></pre><p id="1beb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在您的普通浏览器中，显示隐藏浏览器窗口的实时视图。</strong>如果需要，端口号当然可以在代码中更改。</p><p id="1ba3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在本例中，我们将使用cookie持久性，而不是headless模式。</strong></p><h1 id="73a4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">识别网站元素</h1><p id="6940" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">自动化WhatsApp的下一步是识别网站的各个部分。然后可以点击这些部分或对其进行文本解析。selenium中有一些内置的方法可以帮助实现这一点。</p><p id="6608" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">列出的函数分为返回单个元素的函数和返回元素列表的函数。</strong>每种类型在各自的情况下都很有用。除了这些功能，还有一些其他的功能可以在这里找到<a class="ae jo" href="https://selenium-python.readthedocs.io/locating-elements.html" rel="noopener ugc nofollow" target="_blank"/>，然而我认为这些是最有用的。下面列出的所有函数只是接受一个对应于属性值的字符串。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="b4c3" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_id() <br/>driver.find_element_by_tag_name() driver.find_element_by_class_name() </span><span id="afd2" class="lb jq hi kx b fi lu ld l le lf">driver.find_elements_by_tag_name() driver.find_elements_by_class_name()</span></pre><p id="50ff" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面是WhatsApp Web指定的一个例子。在加载WhatsApp Web并扫描二维码后，加载的页面会在左上角显示您的个人资料图片。使用Inspect Element (Ctrl + Shift + C)来选择profile图片元素会显示一个HTML元素，如下所示:</p><p id="cb51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这意味着div有一个“_3LtPa”类，因此我们应该使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="67ee" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_class_name("_3LtPa")</span></pre><p id="70e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">它获取具有给定类名的第一个元素。要获得该类的所有元素，我们可以使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a15c" class="lb jq hi kx b fi lc ld l le lf">driver.find_elements_by_class_name("_3LtPa")</span></pre><p id="f50f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，我们可以使用:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="2ee5" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_id("_3LtPa")</span></pre><p id="8320" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果HTML元素碰巧显示为:</p><p id="9985" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后两个功能:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="6ca9" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_tag_name("div") driver.find_elements_by_tag_name("div")</span></pre><p id="2429" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">将分别返回屏幕上div标记的第一个实例或所有实例。这个函数可以找到HTML中存在的任何标签。</p><p id="599b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些函数都可以相互链接，以获取其他元素中的元素。例如:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="e8a6" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_tag_name("div")[0].find_elements_by_class_name("_3LtPa")</span></pre><p id="1709" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这将查找页面上的第一个div标记，然后查找该div标记中类名为“_3LtPa”的所有元素。</p><h1 id="50b2" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">等待页面加载</h1><p id="7e84" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们知道了如何识别页面上的元素，我们需要在开始自动化WhatsApp之前搞清楚最后一步。这是为了确定页面何时完成加载。遗憾的是，selenium没有任何内置的功能来做到这一点。幸运的是，检查页面是否已经加载并不太困难。</p><p id="f5c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这个方法，简单来说，就是我们暂停执行，直到找到一个只存在于最终加载的页面中的元素。</strong>在代码中，这是通过while循环和元素标识完成的，如下所示:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c6ee" class="lb jq hi kx b fi lc ld l le lf">while not driver.find_elements_by_class_name("_3LtPa"):     <!-- -->⠀⠀⠀⠀<!-- -->time.sleep(1)</span></pre><p id="be3e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">这段代码一直等到找到类名为“_3LtPa”的元素。</strong>我们正在重用“_3LtPa”类名，据我所知，只有当用户扫描了二维码并加载时，才会加载该类名。您可以选择符合您标准的任何其他元素。<strong class="is hj"><em class="lt">time . sleep</em>每次找不到元素时，代码执行延迟一秒钟。</strong>在这个用例中，响应时间不是很重要，因此我们可以承受页面加载的延迟。您可以根据需要增加或减少延迟时间。</p><h1 id="0015" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">自动化所有的事情</h1><p id="0528" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">现在我们已经完全准备好自动化WhatsApp Web。在这里，我将讨论自动化时你可能需要的三个主要功能。<strong class="is hj">这将是从一个元素中获取文本，输入文本</strong> <strong class="is hj">并单击。</strong></p><h1 id="2a17" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">获取文本</h1><p id="1120" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">在selenium中获取文本是通过访问任何selenium元素的文本变量来完成的:</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="cd33" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_class_name("_1MZWu").text</span></pre><p id="b687" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">记住<em class="lt">文本</em>不是一个函数。</strong></p><h1 id="4bb7" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">键入文本</h1><p id="29c1" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">首先在文本框中键入文本需要您已经获得了文本框的元素。从那里你可以<em class="lt">发送_keys() </em>到元素。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="ad75" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_class_name("_1awRl").send_keys("Hello World!") driver.find_element_by_class_name("_1awRl").send_keys('\ue007')</span></pre><p id="ad88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第二行是selenium允许您发送的特殊字符(Enter/Return)的示例。这里是所有可用键的列表。</p><h1 id="e55b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">微小静电干扰声</h1><p id="6b3c" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">点击进入selenium就像跑步一样简单。在识别的元素上单击()。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="43c3" class="lb jq hi kx b fi lc ld l le lf">driver.find_element_by_class_name("_3Tw1q").click()</span></pre><p id="7bd2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">点击一个元素后，你可以检查一个新的元素出现，或者简单地设置一个持续的延迟。需要有某种延迟，以允许页面在点击后加载。</p><h1 id="d132" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最终代码</h1><p id="d88a" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">这里显示的最后一段代码自动加载WhatsApp，等待用户登录，然后选择第一个联系人并发送一条消息“Hello World！”。然后，程序等待几秒钟，并关闭浏览器窗口。</p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lv lw l"/></div></figure><p id="8b01" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="lt">原载于2021年1月14日</em><a class="ae jo" href="https://kgdavidson.co.uk/miscellaneous--how-to-automate-whatsapp-or-any-website-with-python/" rel="noopener ugc nofollow" target="_blank"><em class="lt">【https://kgdavidson.co.uk】</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>