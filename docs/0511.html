<html>
<head>
<title>Divide and Conquer — Concept, Code, and Practice Problems</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分而治之—概念、代码和实践问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/divide-and-conquer-concept-code-and-practice-problems-86531dd441e?source=collection_archive---------6-----------------------#2021-01-19">https://medium.com/analytics-vidhya/divide-and-conquer-concept-code-and-practice-problems-86531dd441e?source=collection_archive---------6-----------------------#2021-01-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cecd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客向读者介绍了<strong class="ig hi">分而治之策略</strong>，并讨论了一个通用的3步法，它可以适用于解决几乎所有属于<strong class="ig hi">分而治之范畴的问题。</strong>为了详细解释这个概念，博客将使用——合并排序——一种每个计算机科学学生都应该很好理解的算法。博客还解释了<strong class="ig hi">如何编写</strong>合并排序，并通过向读者提供一个<strong class="ig hi">评论良好的Python代码</strong>涵盖了实际方面。最后，它还提供了一些带有答案链接的练习题。</p><p id="96ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这个博客证明是有帮助的。</p><p id="f712" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不再拖延，让我们开始吧！！😃</p><h2 id="bddd" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">为什么叫“分而治之”？</h2><p id="d960" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">我们将通过一个假设的例子来理解这一点。</p><p id="ea89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们有一副牌(总共52张)，我们想把所有的黑桃从剩下的牌中分离出来。我们可以通过许多方式实现这一点；然而，我们超级聪明😎 😆，我们都知道。我们把这副牌分成两半，每一半有26张牌，并向我们的两个好朋友寻求帮助。我们把一半给第一个朋友，另一半给第二个朋友，让他们把所有的黑桃都交给我们。换句话说，我们要求他们通过收集委派给他们的一半中的所有黑桃来征服每一半。</p><p id="9b25" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重申一下，我们<strong class="ig hi">将</strong>牌组分成两半，并让朋友们<strong class="ig hi">为我们征服</strong>每一半。嗯，这可能已经是相关的，这种方法被称为分而治之的方法。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es kc"><img src="../Images/75629a287d84914e937db94ef86fea02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*wa5Q4dIiHQs7bByDgFI5GQ.png"/></div></figure><p id="9308" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更正式地说，在分而治之的方法中，我们<strong class="ig hi">将给定的问题</strong>分成子问题，并试图<strong class="ig hi">解决/征服</strong>子问题。一旦子问题被攻克，我们试图<strong class="ig hi">结合</strong>已解决的子问题来导出原始问题的解决方案。</p><p id="4d90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们以合并排序为例，看看它是如何工作的。</p><h2 id="55cf" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">合并排序—图解说明</h2><p id="bd6f" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">让我们假设已经给了我们一个列表——[3，1，4，2]——我们应该使用分而治之的策略对它进行升序排序。为此，我们将使用合并排序。然而，让我们假设不存在合并排序这种东西。我们将如何做到这一点？🤔</p><p id="f127" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好吧，让我们用“卡片例子”作为参考。当我们拿到52张牌，并被要求把所有的黑桃分开时，我们做了什么？</p><ul class=""><li id="6f48" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">首先，我们把牌分成两半。</li><li id="6335" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">然后，我们把每一半委托给我们的一个朋友。</li><li id="1fb8" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">最后，我们收集了每个朋友归还的黑桃。</li></ul><p id="976e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，我们处理给我们的列表:</p><ul class=""><li id="736b" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">首先，我们将列表分成两半。</li><li id="4e01" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">然后，我们将把每个列表委托给我们的一个朋友。</li><li id="d670" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">朋友们将返回一个排序列表，我们将组合该列表以形成一个排序列表。</li></ul><p id="225a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，有些事情我们可能没有意识到。我们的朋友也很聪明，和我们一样遵循分而治之的策略。当朋友们收到26张牌时，他们把它们分成两半(每一半13张牌)，并叫他们的另外2个朋友找出所有的黑桃。这个分成两半并分配任务的过程一直持续到没有找到所有的黑桃。</p><p id="d665" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个新的场景中，我们的朋友也很聪明，我们意识到我们的职责和我们的朋友是一样的——我们都倾向于在给我们的卡片上使用分而治之的方法。</p><p id="473c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于任务/职责相同，我们意识到没有必要一次又一次地给新朋友打电话。换句话说，我可以说没有必要一次又一次地定义新的函数。相反，我们可以定义一个依赖于<strong class="ig hi">递归</strong>的<strong class="ig hi">核心函数</strong>。核心职能应该:</p><ol class=""><li id="4f28" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb ky kq kr ks bi translated">接受输入</li><li id="bcdc" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated">把它分成两半——左半部分和右半部分。</li><li id="cce6" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated"><strong class="ig hi">递归调用自己</strong>两次——一次在左边，一次在右半部分。</li><li id="a73f" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated">适当地<strong class="ig hi">将两部分</strong>结合在一起并返回结果。</li></ol><p id="f296" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，可能有一些事情还不太清楚。然而，让我们通过合并排序的例子，并试图建立一个更好的理解。</p><p id="b936" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">概括地说，我们有一个列表— [3，1，4，2]，我们想使用Merge Sort对它进行升序排序。</p><blockquote class="kz la lb"><p id="deac" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">注意:从现在开始，我可能会互换使用术语列表和数组。数组和列表是不同的。但是，这种随便用一个换另一个的方式，并不妨碍我们理解分而治之的逻辑。</p></blockquote><p id="915d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们制作一个核心函数，并将其命名为:<strong class="ig hi"> sort (list)，or sort(arr)，or sort(arr)</strong><br/><strong class="ig hi">sort()</strong>函数将一个<strong class="ig hi">列表作为参数，然后采用分治法</strong>。</p><p id="8a5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是一组解释合并排序如何工作的图片。</p><p id="2cf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们将排序函数称为:sort([3，1，4，2])。此时的状态如下图所示:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/b15078b273ecda7f879659a2d95fb500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZERPaLCflEdzmRH84IvwQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态1</figcaption></figure><p id="f679" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，sort([3，1，4，2])将数组分成两半，并在左半部分递归调用自身，即[3，1]。发出调用后，它等待递归结束。该状态如下图所示的'<em class="lc">状态2' </em>:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/fdd9d7d220604e47ef495cba190de17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hy6TJZ2IE3EKLNI1bJTxkw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态2</figcaption></figure><p id="579e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，sort([3，1])将数组分成两半，并在左半部分递归调用自身，即[3]。发出调用后，它等待递归结束。状态如下图状态3所示:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/2516a9e18b54c6e7a76ebb03e6b7f1e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7TPvBMytsIMxYy231x4vAA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态3</figcaption></figure><p id="0ada" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，sort([3])意识到它的输入中只有一个元素。由于只有一个元素，它不能被分割，因此按原样返回。换句话说，sort([3])不进行任何递归调用。这种极限情况被称为基础情况更正式地说，基础用例充当递归树的叶子。</p><p id="6530" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在基本情况即sort([3])完成其执行并返回值之后，暂停的父实例即sort([3，1])重新开始其执行。这已在下面的状态4图中显示:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lq"><img src="../Images/58886c816a5042a8d20d26d325a482f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e16-tC6mY8iqxUl6pkdi8Q.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态4</figcaption></figure><p id="4ec7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重新开始执行后，sort([3，1])对右半部分进行递归调用，即sort([1])。这显示在下面的状态5图中:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lr"><img src="../Images/579c1ef6aedcecd01556e7e91d840904.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMHAIgRNtoGSpxdziN325Q.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态5</figcaption></figure><p id="3bf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为sort([1])是一种基本情况，所以它按原样返回值。这个值被返回给名为right_sorted的变量。这显示在下面的状态6图中:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lp"><img src="../Images/e1af1688fc4a48d6193bbeb78595e1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Std_C6kXzeNLo4v9WtIKQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态6</figcaption></figure><p id="e765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦sort([3，1])收到了<strong class="ig hi"> right_sorted </strong>中的值，它就完成了所有的递归调用。目前，<strong class="ig hi"> left_sorted </strong>按排序顺序存储左半部分，<strong class="ig hi"> right_sorted </strong>按排序顺序存储右半部分。现在，我们必须将左半部分和右半部分排序，然后<strong class="ig hi">将它们组合/合并</strong>到一个排序数组中。</p><blockquote class="kz la lb"><p id="7de9" class="ie if lc ig b ih ii ij ik il im in io ld iq ir is le iu iv iw lf iy iz ja jb ha bi translated">将两个数组或列表合并成一个是一个众所周知的问题，我希望读者了解这种技术。</p></blockquote><p id="4924" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，sort([3，1])调用Merge函数将left_sorted和right_sorted列表/数组合并为一个。一旦合并完成，合并后的列表将返回到外部排序调用，即sort([3，1，4，2])。<br/> sort([3，1，4，2])接收其left_sorted变量中的值，并重新开始执行。这显示在下面的状态7图中:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lg"><img src="../Images/1b52c7264f096d620ce330e623f879d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iOVpQBBlOZKMxWtQhDMyWw.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态7</figcaption></figure><p id="df62" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重新开始执行后，sort([3，1，4，2])对右半部分进行递归调用，即sort([4，2])。这显示在下面的状态8图中:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ls"><img src="../Images/7c3d4fbb9ba8160e8a35a497099f099a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4aXK270RFVF7Roa_PdTEUQ.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">状态8</figcaption></figure><p id="a1e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，同样的步骤——除法、递归调用、基本情况、合并等等。—使用sort([3，1])发生的将使用sort([4，2])发生。最终，sort([3，1，4，2])的left_sorted和right_sorted变量将合并产生最终结果，即[1，2，3，4]。这已在下面的最终状态图中显示出来:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lt"><img src="../Images/404e5ab43c155a33ac18a69f295bc98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsGzZDwBtpqcmuTcVHNdGg.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">末态</figcaption></figure><p id="639b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所看到的，一旦到达最终状态，我们将得到排序后的数组。</p><p id="9d1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理解了这个例子，我们可以向三步法迈进一步。这三个步骤是什么？</p><h1 id="8837" class="lu jd hh bd je lv lw lx ji ly lz ma jm mb mc md jp me mf mg js mh mi mj jv mk bi translated">三步法</h1><p id="ea6e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在仔细分析了合并排序的工作原理后，我们发现在处理分治时，我们需要考虑并实现以下三件事:</p><ol class=""><li id="0799" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb ky kq kr ks bi translated">处理<strong class="ig hi">基本情况</strong>。</li><li id="c0ae" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated">对两半部分进行递归调用。</li><li id="b41d" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated"><strong class="ig hi">结合</strong>递归调用得到的结果。</li></ol><p id="5d38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们尝试使用3步法进行合并排序，我们应该按照以下方式思考:</p><ol class=""><li id="934c" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb ky kq kr ks bi translated"><strong class="ig hi">基础案例是什么？</strong> <br/>当列表/数组的长度为1时，我们命中基例。</li><li id="10ce" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated"><strong class="ig hi">如何进行递归调用？</strong> <br/>将数组/列表一分为二，在两者上调用sort()函数。将输出存储在left_sorted和right_sorted变量中。</li><li id="ce54" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated"><strong class="ig hi">如何组合结果？</strong> <br/>制作一个合并函数，帮助我们将两个排序列表/数组合并成一个排序列表/数组。</li></ol><p id="7c6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们搞清楚了这一点，我们就可以设计我们的核心函数了——叫做<strong class="ig hi"> sort(list)。</strong>sort函数将以与上述相同的顺序实现这3个步骤，分而治之的整个逻辑将成功运行。</p><p id="5bf6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图说明了三步法如何帮助我们编写合并排序算法:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ml"><img src="../Images/da85f472a86e2a9812191872495debd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*swP8f16ByFO0kRMb_oWruA.png"/></div></div><figcaption class="ll lm et er es ln lo bd b be z dx translated">归并排序的图形表示与代码之间的并行绘制</figcaption></figure><p id="c9ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，既然我们已经熟悉了如何设计核心函数，即<strong class="ig hi"> sort()，</strong>，让我们跳到编码部分。</p><h2 id="4adf" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">Python中的合并排序代码</h2><p id="b59c" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">这是LeetCode问题的链接。在你阅读解决方案之前一定要试一试。</p><div class="mm mn ez fb mo mp"><a href="https://leetcode.com/problems/sort-an-array/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">对数组排序- LeetCode</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">leetcode.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd ki mp"/></div></div></a></div><p id="0f7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">LeetCode提供了一些如下所示的初始代码:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es ne"><img src="../Images/afa3f6e0981c50aa06e400a114f92a15.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*2NvOy2KGkLqMTrl0TmVkTQ.png"/></div></figure><p id="a0d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将遵循我们的<strong class="ig hi"> 3步</strong>方法，从编写核心函数开始，称为<strong class="ig hi">排序</strong>。下图显示了<strong class="ig hi">排序</strong>功能的代码:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nf"><img src="../Images/d609cb362da6feb10dc65515a555e190.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qxryoB0dznHDafdyo7gtJA.png"/></div></div></figure><p id="b286" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦核心函数形成，我们只需要编写<strong class="ig hi">合并</strong>函数。合并函数的代码如下所示:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es ng"><img src="../Images/2051e044ac2bb29e02f4dc59d1226011.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ScavC4yVoAgeWq-VJ2O5ow.png"/></div></div></figure><p id="8d8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">合并函数一旦编码完成，我们只需要从LeetCode提供的函数中调用排序函数，即sortArray函数。它看起来像这样:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es nh"><img src="../Images/66afc28bd488dea3cfcfb846c2e82b6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*kuw8dfUbkKNnTrTZYc4M5w.png"/></div></figure><p id="e526" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是代码的GitHub链接:</p><div class="mm mn ez fb mo mp"><a href="https://github.com/shantanutrip/Blog_Codes/blob/main/Divide_and_Conquer/sort-an-array.py" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">shantanutrip/Blog_Codes</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">在GitHub上创建一个帐户，为shantanutrip/Blog_Codes的开发做出贡献。</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="ni l na nb nc my nd ki mp"/></div></div></a></div><h2 id="2179" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">复杂性分析—类型1</h2><p id="6377" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">为了分析复杂性，让我们看看上面的<strong class="ig hi"> self.sort() </strong>函数。如果我们认为:</p><ul class=""><li id="a080" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated"><em class="lc"> self.sort(list) </em>函数对长度为“<em class="lc"> n </em>的列表进行排序所用的时间为<em class="lc"> T(n) </em>，</li><li id="a5b0" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">那么self.sort(left_half)所用的时间将是T(n/2)</li><li id="3c71" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb kp kq kr ks bi translated">而self.sort(right_half)所用的时间也将是T(n/2)。</li></ul><p id="0609" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们知道:</p><ul class=""><li id="666a" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb kp kq kr ks bi translated">self.merge()函数的总时间复杂度为O(n)</li></ul><p id="3d83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用这些信息，我们可以推导出self.sort(list)所用时间的公式。为了更好地理解，让我们看看下图:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nj"><img src="../Images/6d1ad017ae54f56fbca06a2d4dbba428.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zSHcMtduOc2RtZQB4btRqg.png"/></div></div></figure><p id="618d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们将master-method应用于上图中得到的最终方程，我们会发现时间复杂度为<strong class="ig hi"> O(n log n) </strong>。</p><h2 id="49f3" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">复杂性分析—类型2</h2><p id="de20" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">还有另一种分析复杂性的方法。然而，与类型1相比，这需要更多的可视化。在这种方法中，</p><ol class=""><li id="7e3c" class="kk kl hh ig b ih ii il im ip km it kn ix ko jb ky kq kr ks bi translated">我们想象递归树的样子。</li><li id="e617" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated">然后，在递归树的每一层，我们添加由组合/合并调用完成的所有工作。</li><li id="e2f7" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated">然后，我们将递归树的每一层所做的工作相加。</li></ol><p id="7cf5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了更好地理解，请看下图:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es nk"><img src="../Images/235fae5af282171c2f13a938a004f5db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nnREOgaEW3jaN8Swjt80aw.png"/></div></div></figure><p id="f871" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，在每一级，总功加起来是n。因此，总功是:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es nl"><img src="../Images/6d491d62e9f301cebb1db4f2e4b0db75.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*agvGUpfsmfInfkA6aIBdnw.png"/></div></figure><p id="832e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">h的值是多少？？</strong></p><p id="9b12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们观察上面显示的递归树，我们看到在每一层，我们将输入除以2，直到到达叶节点，在那里输入变成1。换句话说，当我们到达叶节点时，我们已经将N除以2‘h’次，因此将输入大小减少到1。</p><p id="7c17" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用数学的方法来说，</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es nm"><img src="../Images/7b36fadb5a06b663b40a07d870db70df.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/1*qqlFRGH40I6EC0ZqEhoPBQ.png"/></div></figure><p id="00d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，合并排序的总时间复杂度为:</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div class="er es nn"><img src="../Images/c22dfeb2341c3ef2f1e03d4222f21b59.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/1*ROUhLL9zszwYtNdX43iwAg.png"/></div></figure><h1 id="7f43" class="lu jd hh bd je lv lw lx ji ly lz ma jm mb mc md jp me mf mg js mh mi mj jv mk bi translated">练习题:</h1><p id="25d0" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated"><em class="lc">我要感谢我的朋友Deepankar帮我选择练习题。</em></p><p id="3997" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我刚刚用合并排序来解释这个概念，但我希望读者现在能够使用<strong class="ig hi"> 3步法</strong>来解决他们遇到的任何问题。为了更好地练习，我提供了一些问题的LeetCode链接，这些问题可以通过分而治之来解决。可能有其他方法来解决这些问题；然而，我建议读者应该坚持分而治之，以建立对主题的坚定理解。</p><p id="18c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我还提供了问题的代码。代码注释应该有助于理解如何针对各种问题实现和编码分而治之。</p><p id="7914" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">问题链接:</p><div class="mm mn ez fb mo mp"><a href="https://leetcode.com/problems/maximum-subarray/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">最大子阵列- LeetCode</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">给定一个整数数组nums，找出具有最大和的连续子数组(至少包含一个数)</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">leetcode.com</p></div></div><div class="my l"><div class="no l na nb nc my nd ki mp"/></div></div></a></div><div class="mm mn ez fb mo mp"><a href="https://leetcode.com/problems/merge-k-sorted-lists/solution/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">合并k个排序列表- LeetCode</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">提高你的编码技能，迅速找到工作。这是扩展你的知识和做好准备的最好地方…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">leetcode.com</p></div></div><div class="my l"><div class="np l na nb nc my nd ki mp"/></div></div></a></div><p id="3721" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lc">最大子阵列代码:</em> </strong></p><div class="mm mn ez fb mo mp"><a href="https://github.com/shantanutrip/Blog_Codes/blob/main/Divide_and_Conquer/maximum_subarray.cpp" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">shantanutrip/Blog_Codes</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">在GitHub上创建一个帐户，为shantanutrip/Blog_Codes的开发做出贡献。</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="nq l na nb nc my nd ki mp"/></div></div></a></div><p id="0df7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面提到的最大子阵是<strong class="ig hi"> O(n log n) </strong>。</p><p id="f32e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您想使用<strong class="ig hi">分治法</strong>解决<strong class="ig hi"> O(n) </strong>中的最大子数组吗？请参考以下链接:</p><div class="mm mn ez fb mo mp"><a href="https://www.geeksforgeeks.org/maximum-sum-subarray-using-divide-and-conquer-set-2/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">使用分治法的最大和子数组|集合2 - GeeksforGeeks</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">最大和子数组使用分治| Set 2给定一个整数数组arr[]，任务是找到最大…</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="my l"><div class="nr l na nb nc my nd ki mp"/></div></div></a></div><p id="9c0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lc">合并K排序列表代码:</em> </strong></p><div class="mm mn ez fb mo mp"><a href="https://github.com/shantanutrip/Blog_Codes/blob/main/Divide_and_Conquer/merge-k-sorted-lists.cpp" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab dw"><div class="mr ab ms cl cj mt"><h2 class="bd hi fi z dy mu ea eb mv ed ef hg bi translated">shantanutrip/Blog_Codes</h2><div class="mw l"><h3 class="bd b fi z dy mu ea eb mv ed ef dx translated">在GitHub上创建一个帐户，为shantanutrip/Blog_Codes的开发做出贡献。</h3></div><div class="mx l"><p class="bd b fp z dy mu ea eb mv ed ef dx translated">github.com</p></div></div><div class="my l"><div class="ns l na nb nc my nd ki mp"/></div></div></a></div><h2 id="15a1" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">结论</h2><p id="1d72" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在这篇博客中，我们讨论了<em class="lc">分而治之</em>的主题，也学习了通用的三步法来解决这个主题领域中的问题。为了更好地理解这些概念，我们详细研究了合并排序算法，并探索了整个递归树。通过学习如何编写合并排序算法，我们还获得了实际的理解。我们更进一步，理解了使用分而治之策略的解决方案的复杂性分析过程。最后，为了帮助读者提高他们的实现技能，我们提供了2个LeetCode问题和到它们的解决方案的链接。</p><p id="25f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望读者发现这个博客是有帮助的。谢谢你的时间。😃</p><h2 id="5b78" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">参考资料:</h2><ol class=""><li id="76a1" class="kk kl hh ig b ih jx il jy ip nt it nu ix nv jb ky kq kr ks bi translated"><a class="ae nw" href="https://leetcode.com/problemset/all/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a> —问题</li><li id="6b53" class="kk kl hh ig b ih kt il ku ip kv it kw ix kx jb ky kq kr ks bi translated"><a class="ae nw" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank">极客为极客</a> —增强型解决方案</li></ol></div></div>    
</body>
</html>