<html>
<head>
<title>Dispatching asynchronous Side Effects inside synchronous Redux actions without using any middleware — React.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在不使用任何中间件的情况下，在同步Redux动作中分派异步副作用——React。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dispatching-asynchronous-side-effects-inside-synchronous-redux-actions-without-using-any-cd06e0d4152c?source=collection_archive---------4-----------------------#2021-04-11">https://medium.com/analytics-vidhya/dispatching-asynchronous-side-effects-inside-synchronous-redux-actions-without-using-any-cd06e0d4152c?source=collection_archive---------4-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/ff696110cae8f2c0ed7abc4a07418123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GO5XXRB5X4CUX04gutlTkA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/s/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的<a class="ae iu" href="https://unsplash.com/@neonbrand?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> NeONBRAND </a>拍摄</figcaption></figure><p id="241e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">异步的东西总是令程序员头疼。<code class="du jt ju jv jw b">setTimeout(), callbacks, promises, aync await, </code>等。—我们有如此多的工具，但有时我们仍会迷失在编程的同步范例中。在过去的一年里，我一直在大规模使用<strong class="ix hj"> React </strong>。开发高功能仪表板、UI优化、控制数据流以及处理大量API集成是我日常工作的一部分。<em class="jx">最近我遇到了一个情况，当用户重置过滤器时，应用程序应该从前端进行两次API调用，其中一个queryparams来自于从另一个获取的数据。</em>在这篇博客中，我将解释我是如何通过使同步<strong class="ix hj"> Redux </strong>动作异步来实现这一点的。所以让我们开始吧。</p><p id="95d1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我在这里假设您对React和Redux的工作原理有一个基本的了解。根据Redux docs —</p><blockquote class="jy jz ka"><p id="796c" class="iv iw jx ix b iy iz ja jb jc jd je jf kb jh ji jj kc jl jm jn kd jp jq jr js hb bi translated">Redux存储本身对异步逻辑一无所知。它只知道如何同步调度动作，通过调用根reducer函数来更新状态，并通知UI发生了变化。任何异步都必须发生在商店之外。</p></blockquote><p id="3e9f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我用JavaScript工具武装自己，只做了一个简单的小把戏，就非常容易地绕过了上面的协议，达到了我的目的。</p><pre class="ke kf kg kh fd ki jw kj kk aw kl bi"><span id="c80b" class="km kn hi jw b fi ko kp l kq kr">export const resetFilter = () =&gt; async (dispatch, getState) =&gt; {   <br/>    dispatch({ type: RESET_FILTER });</span><span id="f035" class="km kn hi jw b fi ks kp l kq kr">    await dispatch(callAPI_1());<br/>    const {<br/>        mainComponent: { api1_data },<br/>    } = getState();</span><span id="586d" class="km kn hi jw b fi ks kp l kq kr">    await dispatch(<br/>        callAPI_2(api1_data.param1, api1_data.param2)<br/>    );<br/>};</span></pre><p id="4f6d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这几乎是我所做的一切。<code class="du jt ju jv jw b">callAPI_1</code>和<code class="du jt ju jv jw b">callAPI_2</code>是已经定义的redux动作，我在这里调用每个API。当用户重置过滤器时，resetFilter操作被触发，应用程序需要用新的参数调用API。这里的技巧部分是<code class="du jt ju jv jw b">callAPI_2 </code>的<strong class="ix hj"> queryparams </strong>来自<code class="du jt ju jv jw b">callAPI_1</code>的<strong class="ix hj">新状态</strong>，由于Redux动作是同步的，整个系统在没有<strong class="ix hj"> async-await </strong>的情况下失败。通过使用async-await，我们等待第一个API调用完成，在触发它之前获取它的数据并将其传递给第二个API调用的queryparams。像这样再次aync-await拯救世界！</p><p id="87a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于复杂的情况，您可能需要使用一些Redux中间件，如<a class="ae iu" href="https://github.com/reduxjs/redux-thunk#redux-thunk" rel="noopener ugc nofollow" target="_blank"> redux-thunk </a>来使动作异步。但是对于像这样的小用例，我的方法就足够了。这也可以使用setTimeout()、回调或承诺来完成，但我更喜欢async-await ( <em class="jx"> es6 yaay！！</em>)。</p><p id="539c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可能有这样一个用例，你正在进行相同类型的API调用，但是你是作为一个副作用<a class="ae iu" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">而不是动作来做的。逻辑是相同的，但是我们需要像这样从一个useEffect钩子中调用<code class="du jt ju jv jw b">callAPI_1</code>和<code class="du jt ju jv jw b">callAPI_2</code>动作:</a></p><pre class="ke kf kg kh fd ki jw kj kk aw kl bi"><span id="a216" class="km kn hi jw b fi ko kp l kq kr">useEffect(() =&gt; {<br/>    async function getData() {<br/>        await callAPI_1();<br/>        await callAPI_2(api1_data.param1, api1_data.param2);<br/>    }<br/>    getData();<br/>}, [callAPI_1]);</span></pre><p id="c80d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，<code class="du jt ju jv jw b">promises</code>和<code class="du jt ju jv jw b">useEffect( async() =&gt; …</code>在React中不被支持，但是你可以在一个效果中调用异步函数。还有一个你应该永远记住的React hooks <a class="ae iu" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则</a>:</p><blockquote class="jy jz ka"><p id="98f3" class="iv iw jx ix b iy iz ja jb jc jd je jf kb jh ji jj kc jl jm jn kd jp jq jr js hb bi translated"><strong class="ix hj">不要在循环、条件或嵌套函数中调用钩子。相反，在任何早期返回之前，总是在React函数的顶层使用钩子。通过遵循这条规则，您可以确保每次组件呈现时都以相同的顺序调用钩子。这使得React能够正确地保存多个<code class="du jt ju jv jw b">useState</code>和<code class="du jt ju jv jw b">useEffect</code>调用之间的钩子状态。</strong></p></blockquote><p id="19e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="jx">附加提示</em> </strong> <em class="jx">:总会有边界但是作为程序员的你总是可以使用已经可用的工具来创造魔法。</em></p></div><div class="ab cl kt ku gp kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="hb hc hd he hf"><p id="5430" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您通读。我将非常感谢您的评论和建议。如果你有其他的优化技术，请在评论中告诉我。</p><p id="885e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你觉得它有用，请给我一个掌声，并与你的开发伙伴分享。<strong class="ix hj"> <em class="jx">不要硬编码，硬编码！</em>T25】</strong></p><h1 id="d5e2" class="la kn hi bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">苏巴扬·戈什</h1><p id="a67d" class="pw-post-body-paragraph iv iw hi ix b iy lx ja jb jc ly je jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated"><a class="ae iu" href="https://www.linkedin.com/in/realsubhayan/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae iu" href="https://twitter.com/realsubhayan" rel="noopener ugc nofollow" target="_blank">Twitter</a>|<a class="ae iu" href="https://www.instagram.com/realsubhayan/" rel="noopener ugc nofollow" target="_blank">insta gram</a></p></div></div>    
</body>
</html>