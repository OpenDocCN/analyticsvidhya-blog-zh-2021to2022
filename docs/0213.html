<html>
<head>
<title>Programming in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Julia中编程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-blocks-of-julia-9eabbb2cffb2?source=collection_archive---------18-----------------------#2021-01-08">https://medium.com/analytics-vidhya/building-blocks-of-julia-9eabbb2cffb2?source=collection_archive---------18-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="37a1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">像Python一样的能力，像C一样的速度</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/723618e5ef6b1544e50d3c318d2c75f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OxjeIv706eI98InB"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae jm" href="https://unsplash.com/@laurentmedia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">给</a>拍照</figcaption></figure><p id="197b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia是一种高级、高性能的编程语言，由Jeff Bezanson、Stefan Karpinski和Viral Shah领导的计算机科学家团队在2012年创建。Julia旨在解决传统科学计算语言(如MATLAB、Python和R)的局限性，同时仍然保留它们的易用性和灵活性。</p><p id="9146" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">朱莉娅的一个主要特点是它的性能。Julia被设计得很快，执行速度堪比C和Fortran等编译语言。这是通过结合使用实时(JIT)编译和类型推断来实现的，前者在代码执行时动态编译代码，后者允许Julia在运行时确定变量的数据类型。</p><p id="f023" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia的另一个重要特性是支持多种调度。多重分派允许Julia根据传递给函数的参数类型选择合适的方法。这使得Julia成为一种灵活且富于表现力的语言，可以很容易地扩展和定制，以适应广泛的编程任务。</p><p id="e908" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia还包括许多内置的数据结构和库，使得使用数组、矩阵和其他科学计算工具变得容易。这些工具包括线性代数、统计、优化和机器学习工具，以及对分布式计算和并行性的支持。</p><p id="7abb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">除了其科学计算功能，Julia还包括对通用编程任务的支持，如web开发、数据库访问和文件I/o。Julia不断增长的包生态系统为这些任务提供了广泛的库和工具，使其成为可用于各种编程任务的通用语言。</p><p id="c5c8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">朱莉娅的主要优势之一是它的社区。Julia拥有一个快速增长的开发者和用户社区，他们积极地为该语言及其生态系统做出贡献。这个社区已经创建了大量高质量的软件包，以及许多学习和讨论该语言的在线资源和论坛。</p><p id="4c08" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">大多数现代编程语言都有一套类似的构建模块，例如</p><ol class=""><li id="d5f8" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">接收来自用户的输入并向用户显示输出</li><li id="1193" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">在变量中存储值的能力(通常是不同种类的，如整数、浮点或字符)</li><li id="2642" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">可以存储姓名、地址或任何其他类型文本的字符串</li><li id="26d2" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">一些高级数据类型，比如可以存储一系列常规变量(比如一系列整数)的数组</li><li id="b8c9" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">循环代码的能力从某种意义上说，你想从一个用户那里接收10个名字，你将为此写10次代码，但只写一次，并告诉计算机循环10次</li><li id="d4f7" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">有条件地执行代码语句的能力，例如，如果分数超过40，则学生通过，否则失败</li><li id="869c" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">将您的代码放在函数中</li><li id="b48a" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">通过一种或多种基本数据类型(如结构或类)的组合形成的高级数据类型</li><li id="8021" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">从磁盘读取文件并将文件保存到磁盘</li><li id="6b48" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">能够对你的代码进行注释，这样当你过一段时间再次访问它的时候就能理解它</li></ol><p id="7b2f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们开始吧，看看我们如何在Julia中做这些事情。</p><p id="be60" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">0。如何在你的桌面上安装Julia？</p><p id="a151" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们开始用Julia写程序之前，我们需要安装<a class="ae jm" href="https://julialang.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Julia </a>。接下来你可以安装<a class="ae jm" href="https://code.visualstudio.com/Download" rel="noopener ugc nofollow" target="_blank"> VSCode </a>。现在启动VSCode并安装Julia(Julia lang)扩展。现在，您可以创建一个新的test.jl文件，并添加以下代码，看看是否运行。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="aaa3" class="lc ld hh ky b fi le lf l lg lh">4+2; # If you don't want to see the result of the expression printed, use a semicolon at the end of the expression</span><span id="0844" class="lc ld hh ky b fi li lf l lg lh">ans; # the value of the last expression you typed on the REPL, it's stored within the variable ans</span></pre><p id="329a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们开始之前，链接函数在Julia中是可能的，就像这样:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="9d45" class="lc ld hh ky b fi le lf l lg lh">1:10 |&gt; collect</span></pre><h2 id="231c" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">1.接收来自用户的输入并向用户显示输出</h2><p id="6e14" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">有几种方法可以向用户显示输出。让我们看看显示输出的一些方法:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="aa5e" class="lc ld hh ky b fi le lf l lg lh"># receiving input from user<br/>name = readline(stdin) </span><span id="adfc" class="lc ld hh ky b fi li lf l lg lh"># showing output to user<br/>println("you name is ", name)</span></pre><h2 id="4055" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">2.在变量中存储值的能力(通常是不同种类的，如整数、浮点或字符)</h2><p id="36a5" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">变量的名字是小写的。单词分隔可以用下划线来表示。朱莉娅有几种类型的变量，大致分为具体和抽象类型。可以有子类型的类型(例如Any、Number)称为抽象类型。可以有实例的类型称为具体类型。这些类型不能有任何子类型。</p><p id="a33e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">具体类型可以进一步分为基本类型和复合类型。让我们深入了解一下:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="4cd2" class="lc ld hh ky b fi le lf l lg lh"># Primitive types<br/>## the basic integer and float types (signed and unsigned): Int8, UInt8, Int16, UInt16, Int32, UInt32, Int64, UInt64, Int128, UInt128, Float16, Float32, and Float64<br/>a = 10 </span><span id="16c4" class="lc ld hh ky b fi li lf l lg lh">## more advanced numeric types: BigFloat, BigInt<br/>a = BigInt(2)^200 </span><span id="c23a" class="lc ld hh ky b fi li lf l lg lh">## Boolean and character types: Bool and Char<br/>selected = true</span><span id="1545" class="lc ld hh ky b fi li lf l lg lh">## Text string types: String<br/>name = "vivek"</span><span id="fbd4" class="lc ld hh ky b fi li lf l lg lh"># Composite type<br/>## Rational, used to represent fractions. It is composed of two pieces, a numerator and a denominator, both integers (of type Int)<br/>666//444 # To make rational numbers, use two slashes (//)</span></pre><p id="ee85" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">一些高级数据类型包括字典和集合。集合类似于数组，不同之处在于它们不允许元素重复。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="0b3a" class="lc ld hh ky b fi le lf l lg lh">dict = Dict("a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 3)<br/>dict = Dict{String,Integer}("a"=&gt;1, "b" =&gt; 2) # If you know the types of the keys and values in advance, you can specify them after the Dict keyword, in curly braces</span><span id="9edb" class="lc ld hh ky b fi li lf l lg lh"># looking things up<br/>dict["a"]<br/>values(dict) # to retrieve all values<br/>keys(dict) # to retrieve all keys</span><span id="77b3" class="lc ld hh ky b fi li lf l lg lh"># these can be useful for iterating<br/>for k in keys(dict)<br/>for (key, value) in dict</span><span id="1948" class="lc ld hh ky b fi li lf l lg lh">merge(d1, d2) # merge() function which can merge two dictionaries<br/>findmin(d1) # find the minimum value in a dictionary, and return the value, and its key<br/>filter((k, v) -&gt; k == 1, d1)</span><span id="6b40" class="lc ld hh ky b fi li lf l lg lh"># sort dict - you can use the SortedDict data type from the DataStructures.jl package<br/>Pkg.add("DataStructures")<br/>import DataStructures<br/>dict = DataStructures.SortedDict("b" =&gt; 2, "c" =&gt; 3, "d" =&gt; 4, "e" =&gt; 5, "f" =&gt; 6)</span><span id="8038" class="lc ld hh ky b fi li lf l lg lh"># Sets - A set is a collection of elements, just like an array or dictionary, with no duplicated elements. <br/>colors = Set{String}(["red","green","blue","yellow"])<br/>push!(colors, "black")  # You can use push!() to add elements to a set</span><span id="cf79" class="lc ld hh ky b fi li lf l lg lh">union(colors, rainbow) # The union of two sets is the set of everything that is in one or the other sets<br/>intersect(colors, rainbow) # The intersection of two sets is the set that contains every element that belongs to both sets<br/>setdiff(colors, rainbow) # The difference between two sets is the set of elements that are in the first set, but not in the second</span></pre><p id="daac" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将在下面的第8节讨论抽象数据类型。</p><h2 id="3dfb" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">3.可以存储姓名、地址或任何其他类型文本的字符串</h2><p id="29b1" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">在Julia中，写在一对双引号内的任何值都被视为一个字符串。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="c5e3" class="lc ld hh ky b fi le lf l lg lh">"this is a string"</span><span id="9081" class="lc ld hh ky b fi li lf l lg lh"># double quotes and dollar signs need to be preceded (escaped) with a backslash<br/>"""this is "a" string with double quotes""" # triple double quotes can be used to store strings with double quotes in them</span></pre><p id="b429" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia还允许用户指定特殊字符串。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="f219" class="lc ld hh ky b fi le lf l lg lh"># special strings<br/>r" " indicates a regular expression<br/>v" " indicates a version string<br/>b" " indicates a byte literal<br/>raw" " indicates a raw string that doesn't do interpolation</span></pre><p id="3d54" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里的关键思想是学习如何操作字符串变量</p><p id="2244" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将关注一些常见的操作:a .连接字符串</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="9221" class="lc ld hh ky b fi le lf l lg lh"># Concatenate strings<br/>join(split(s, r"a|e|i|o|u", false), "aiou") # You can join the elements of a split string in array form using join()</span></pre><p id="c0c4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">b.计算字符串中的字符数</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="9d8b" class="lc ld hh ky b fi le lf l lg lh"># Counting number of characters in a string<br/>length(str) # to find the length of a string<br/>lastindex(str) # to find index of last char of string</span></pre><p id="68a8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">c.更改大小写— toupper() &amp; tolower()函数</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="e8cb" class="lc ld hh ky b fi le lf l lg lh">uppercase(s)</span></pre><p id="7d7d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">d.拆分字符串</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="d36e" class="lc ld hh ky b fi le lf l lg lh">split("You know my methods, Watson.") # by default splits on space<br/>split("You know my methods, Watson.", 'W') # splits on the char W<br/># If you want to split a string into separate single-character strings, use the empty string ("") </span><span id="9082" class="lc ld hh ky b fi li lf l lg lh">split("You know my methods, Watson.", r"a|e|i|o|u", false) # splits string on the char that matches any of the vowels<br/># false makes sure that empty strings are not returned</span></pre><p id="4418" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">e.字符串插值</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="600a" class="lc ld hh ky b fi le lf l lg lh"># string interpolation - use the results of Julia expressions inside strings.<br/>x = 42<br/>"The value of x is $(x)." # "The value of x is 42."</span></pre><p id="b2e9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">f.迭代一个字符串</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="49f8" class="lc ld hh ky b fi le lf l lg lh">for char in s  # iterate through a string<br/>    print(char, "_")<br/>end</span></pre><p id="6ee6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">g.获取字符串中所有字符的索引</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="87a7" class="lc ld hh ky b fi le lf l lg lh">for i in eachindex(str)<br/>    @show su[i]<br/>end</span></pre><p id="4e7e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">h.数字和字符串之间的转换</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="90c3" class="lc ld hh ky b fi le lf l lg lh">a = BigInt(2)^200 <br/>a=string(a) # convert number to string<br/>parse(BigInt, a) # convert strings to numbers</span></pre><p id="1143" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">I .查找和替换字符串中的内容</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="d0f0" class="lc ld hh ky b fi le lf l lg lh">s = "My dear Frodo";<br/>in('M', s) # true<br/>occursin("Fro", s) # true<br/>findfirst("My", s) # 1:2<br/>replace(s, "Frodo" =&gt; "Frodo Baggins")</span></pre><p id="72ae" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">还有许多其他功能:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="6dea" class="lc ld hh ky b fi le lf l lg lh">length(str) - - length of string<br/>sizeof(str) - length/size<br/>startswith(strA, strB) - does strA start with strB?<br/>endswith(strA, strB) - does strA end with strB?<br/>occursin(strA, strB) - does strA occur in strB?<br/>all(isletter, str) - is str entirely letters?<br/>all(isnumeric, str) - is str entirely number characters?<br/>isascii(str) - is str ASCII?<br/>all(iscntrl, str) - is str entirely control characters?<br/>all(isdigit, str) - is str 0-9?<br/>all(ispunct, str) - does str consist of punctuation?<br/>all(isspace, str) - is str whitespace characters?<br/>all(isuppercase, str) - is str uppercase?<br/>all(islowercase, str) - is str entirely lowercase?<br/>all(isxdigit, str) - is str entirely hexadecimal digits?<br/>uppercase(str) - return a copy of str converted to uppercase<br/>lowercase(str) - return a copy of str converted to lowercase<br/>titlecase(str) - return copy of str with the first character of each word converted to uppercase<br/>uppercasefirst(str) - return copy of str with first character converted to uppercase<br/>lowercasefirst(str) - return copy of str with first character converted to lowercase<br/>chop(str) - return a copy with the last character removed<br/>chomp(str) - return a copy with the last character removed only if it's a newline</span></pre><h2 id="4ccf" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">4.一些高级数据类型，比如可以存储一系列常规变量(比如一系列整数)的数组</h2><p id="4bd1" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">数组可以是一维的，也可以是多维的。使用方括号、数组构造函数或其他几种方法创建数组。数组支持Julia中的许多功能，所以我在这篇特定于数组的文章中有更详细的介绍。现在让我们来看看关键的功能。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="aa7e" class="lc ld hh ky b fi le lf l lg lh"># Defining<br/># Creating arrays by initializing<br/>arr_Int64 = [1, 2, 3, 4, 5]</span><span id="c71f" class="lc ld hh ky b fi li lf l lg lh"># Creating empty arrays<br/>b = Int64[]</span><span id="4a90" class="lc ld hh ky b fi li lf l lg lh"># Creating 2-d arrays<br/>arr_2d = [1 2 3 4] # If you leave out the commas when defining an array, you can create 2D arrays quickly. Here's a single row, multi-column array: <br/>arr_2d = [1 2 3 4 ; 5 6 7 8] # you can add another row using ;</span><span id="9cf1" class="lc ld hh ky b fi li lf l lg lh"># Creating arrays using range objects<br/>a = 1:10 # creates a range variable with 10 elements from 1 to 10<br/>collect(a) # collect displays a range variable <br/>[a...] # instead of collect, you could use the ellipsis (...) operator (three periods) after the last element<br/>range(1, length=12, stop=100) # Julia calculates the missing pieces for you by combining the values for the keywords step(), length(), and stop()</span><span id="5694" class="lc ld hh ky b fi li lf l lg lh"># Using comprehensions and generators to create arrays<br/>[n^2 for n in 1:5] # a 1-d array<br/>[r * c for r in 1:5, c in 1:5] # a 2-d array</span><span id="cfd4" class="lc ld hh ky b fi li lf l lg lh"># Reshape an array to create a multi-dimentional array<br/>reshape([1, 2, 3, 4, 5, 6, 7, 8], 2, 4) # create a simple array and then change its shape</span><span id="f2ef" class="lc ld hh ky b fi li lf l lg lh"># Supports indexing and slicing<br/># 1-d<br/>a[5] # 5th element<br/>a[end] # last element<br/>a[end-1] # second last element<br/># 2-d<br/>a = [[1, 2] [3,4]]<br/>a[2,2] # element at row-2 x col-2<br/>a[:,2] # all elements of col-2<br/>getindex(a, 2,2) # same as a[2,2]</span><span id="8b39" class="lc ld hh ky b fi li lf l lg lh"># Elements can be added<br/>a = Array[[1, 2], [3,4]]<br/>push!(a, [5,6]) # The push!() function pushes another item onto the back of an array<br/>pushfirst!(a, 0) # To add an item at the front<br/>splice() # To insert an element into an array at a given index<br/>splice!(a, 4:5, 4:6) # insert, at position 4:5, the range of numbers 4:6<br/>L = ['a','b','f']; splice!(L, 3:2, ['c','d','e']) # insert c, d, e between b and f</span><span id="2ac3" class="lc ld hh ky b fi li lf l lg lh"># Elements can be removed<br/>splice!(a,5); # If you don't supply a replacement, you can also use splice!() can remove elements and move the rest of them along<br/>pop!(a) # To remove the last item<br/>popfirst!(a)</span><span id="d4cd" class="lc ld hh ky b fi li lf l lg lh"># Elementwise and vectorized operations<br/>a / 100 # every element of the new array is the original divided by 100. These operations operate elementwise</span><span id="434f" class="lc ld hh ky b fi li lf l lg lh">n1 = 1:6;<br/>n2 = 2:7;<br/>n1 .* n2; # if two arrays are to be multiplied then we just add a . before the mathematical operator to signify elementwise<br/># the first element of the result is what you get by multiplying the first elements of the two arrays, and so on</span><span id="bde7" class="lc ld hh ky b fi li lf l lg lh"># How function works on individual variables<br/>f(a, b) = a * b<br/>a=10;b=20;print(f(a,b))</span><span id="74d0" class="lc ld hh ky b fi li lf l lg lh"># How function can be applied elementwise to arrays<br/>n1 = 1:6;<br/>n2 = 2:7;<br/>print(f.(n1, n2))</span></pre><h2 id="8234" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">5.循环代码的能力从某种意义上说，你想从一个用户那里接收10个名字，你将为此写10次代码，但只写一次，并告诉计算机循环10次</h2><p id="dcb3" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">Julia有几个循环选项，如“for”和“while”。还有嵌套选项(单个、两个、三个，..)循环。a . While循环反复执行相同的代码，直到满足停止条件:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="e02c" class="lc ld hh ky b fi le lf l lg lh"># while end - iterative conditional evaluation<br/>x=0<br/>while x &lt; 4<br/>    println(x)<br/>    global x += 1<br/>end</span></pre><p id="6a98" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">b.for循环:在Julia中充当迭代器；它遍历序列中的项或任何其他可迭代的项。我们已经知道可以迭代的对象包括字符串、列表、元组，甚至字典的内置可迭代对象，比如键或值。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="9fde" class="lc ld hh ky b fi le lf l lg lh"># for end - iterative evaluation<br/># use the global keyword to define a variable that outlasts the loop<br/>for i in 1:10<br/>    z = i<br/>    println("z is $z")<br/>end</span><span id="d385" class="lc ld hh ky b fi li lf l lg lh"># Some sample for loop statements for different data types<br/>for color in ["red", "green", "blue"] # an array<br/>for letter in "julia" # a string<br/>for element in (1, 2, 4, 8, 16, 32) # a tuple<br/>for i in Dict("A"=&gt;1, "B"=&gt;2) # a dictionary<br/>for i in Set(["a", "e", "a", "e", "i", "o", "i", "o", "u"])</span></pre><p id="2eb1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia还提供了break和continue语句，允许我们进一步改变循环。以下是它们的用法:break:脱离当前最近的封闭循环。继续:转到最近的封闭循环的顶部。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="a16d" class="lc ld hh ky b fi le lf l lg lh"># Example with break statement<br/>x=0<br/>while true<br/>    println(x)<br/>    x += 1<br/>    x &gt;= 4 &amp;&amp; break # breaks out of the loop<br/>end</span></pre><p id="87dc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">break和continue语句可以出现在循环体中的任何地方，但是我们通常会将它们与if语句进一步嵌套，以便根据某种条件执行某个操作。</p><p id="eb56" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">以下是循环选项的一些其他选项:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="3413" class="lc ld hh ky b fi le lf l lg lh"># list comprehensions<br/>[i^2 for i in 1:10]<br/>[(r,c) for r in 1:5, c in 1:2] # two iterators in a comprehension</span><span id="f7a0" class="lc ld hh ky b fi li lf l lg lh"># Generator expressions - generator expressions can be used to produce values from iterating a variable<br/>sum(x^2 for x in 1:10)</span><span id="7405" class="lc ld hh ky b fi li lf l lg lh"># Enumerating arrays<br/>m = rand(0:9, 3, 3)<br/>[i for i in enumerate(m)]</span><span id="4721" class="lc ld hh ky b fi li lf l lg lh"># Zipping arrays<br/>for i in zip(0:10, 100:110, 200:210)<br/>    println(i)<br/>end</span><span id="1090" class="lc ld hh ky b fi li lf l lg lh"># Iterable objects<br/>ro = 0:2:100<br/>[i for i in ro]<!-- --> </span></pre><h2 id="8693" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">6.有条件地执行代码语句的能力，例如，如果分数超过40，则学生通过，否则失败</h2><p id="bf6e" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">Julia提供了几个应用条件逻辑的选项。让我们来看看它们:a .三元和复合表达式:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="0fa0" class="lc ld hh ky b fi le lf l lg lh">x = 1<br/>x &gt; 3 ? "yes" : "no"</span></pre><p id="4935" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">b.布尔开关表达式:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="dc8e" class="lc ld hh ky b fi le lf l lg lh">isodd(1000003) &amp;&amp; @warn("That's odd!")<br/>isodd(1000004) || @warn("That's odd!")</span></pre><p id="f674" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">c.if elseif else end —条件求值:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="710d" class="lc ld hh ky b fi le lf l lg lh">name = "Julia"<br/>if name == "Julia"<br/>   println("I like Julia")<br/>elseif name == "Python"<br/>   println("I like Python.")<br/>   println("But I prefer Julia.")<br/>else<br/>   println("I don't know what I like")<br/>end</span></pre><p id="3f95" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">c.使用try处理错误..接住。这使得代码即使在错误发生时仍能继续执行，而错误通常会导致程序暂停。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="a713" class="lc ld hh ky b fi le lf l lg lh"># try catch error throw exception handling<br/>try<br/>    &lt;statement-that-might-cause-an-error&gt;;<br/>catch e # error gets caught if it happens<br/>    println("caught an error: $e") # show the error if you want to<br/>end<br/>println("but we can continue with execution...")</span><span id="0227" class="lc ld hh ky b fi li lf l lg lh"># Example 1 - error doesnt occur<br/>try<br/>    a=10 # no error <br/>catch e<br/>    print(e)<br/>end</span><span id="215e" class="lc ld hh ky b fi li lf l lg lh"># Example 2 - error occurs<br/>try<br/>    la-la-la # undefined variable error<br/>catch e<br/>    print(e)<br/>end</span></pre><h2 id="c4df" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">7.将您的代码放在函数中</h2><p id="afa9" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">函数允许我们创建一个可以多次执行的代码块，而不需要重新编写。朱莉娅有一个叫做单一表达式函数的东西。这些通常在一行中定义，如下所示:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="1cc2" class="lc ld hh ky b fi le lf l lg lh"># Single expression functions<br/>f(x) = x * x<br/>g(x, y) = sqrt(x^2 + y^2)</span></pre><p id="be06" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">也支持具有多个表达式的函数，并且可以使用function关键字进行定义:</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="50f3" class="lc ld hh ky b fi le lf l lg lh"># Syntax<br/># Functions with multiple expressions<br/>function say_hello(name) <br/>    println("hello ", name)<br/>end<br/>say_hello("vivek")</span></pre><p id="f0e0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，可以对函数进行编程，使用return关键字返回单个或多个值。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="74e9" class="lc ld hh ky b fi le lf l lg lh"># define function which returns a value<br/>function add_numbers(a,b)<br/>    return a+b<br/>end<br/># call the function<br/>add_numbers(2,3)</span><span id="864e" class="lc ld hh ky b fi li lf l lg lh"># define function which returns multiple values<br/>function add_multiply_numbers(a, b=10) # we can supply default values as well<br/>    return(a+b, a*b)<br/>end<br/># call the function<br/>add_multiply_numbers(2,3)<br/>add_multiply_numbers(2)</span></pre><p id="0b10" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">args…让函数接受任意数量的参数。可以使用for循环来迭代这些参数。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="d34a" class="lc ld hh ky b fi le lf l lg lh">function show_args(args...)<br/>    for arg in args<br/>        println(arg," ")<br/>    end<br/>end<br/>show_args(10,20,25,35,50)</span></pre><p id="e2c6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Julia也支持匿名函数，没有名字。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="041c" class="lc ld hh ky b fi le lf l lg lh">map((x,y,z) -&gt; x + y + z, [1,2,3], [4, 5, 6], [7, 8, 9])</span></pre><p id="478d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Map和reduce也可用于将函数应用于数组。Map —如果已经有了一个函数和一个数组，可以使用Map()为数组的每个元素调用函数</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="9af7" class="lc ld hh ky b fi le lf l lg lh">a=1:10;<br/>map(sin, a) # map() returns a new array but if you call map!() , you modify the contents of the original array</span></pre><p id="159a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">map()函数收集某个函数处理iterable对象的每个元素的结果，比如一个数字数组。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="5e20" class="lc ld hh ky b fi le lf l lg lh">map(+, 1:10)</span></pre><p id="ca30" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">reduce()函数做类似的工作，但是在函数看到并处理了每个元素之后，只剩下一个元素。该函数应该接受两个参数并返回一个。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="cce1" class="lc ld hh ky b fi le lf l lg lh">reduce(+, 1:10)</span></pre><h2 id="b1d5" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">8.通过一种或多种基本数据类型(如结构或类)的组合形成的高级数据类型</h2><p id="d26f" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">Julia允许用户使用抽象类型(抽象的)或可变结构(具体的)创建用户定义的变量。让我们一起来看看。抽象类型</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="228a" class="lc ld hh ky b fi le lf l lg lh">abstract type MyAbstractType end # By default, the type you create is a direct subtype of Any<br/>abstract type MyAbstractType2 &lt;: Number end # the new abstract type is a subtype of Number</span></pre><p id="470f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用可变结构的具体类型</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="cb8f" class="lc ld hh ky b fi le lf l lg lh"># define the data type<br/>mutable struct student &lt;: Any<br/>   name<br/>   age::Int<br/>end</span><span id="f3b7" class="lc ld hh ky b fi li lf l lg lh"># initialize a variable of that data type<br/>x=student("vivek", 30)</span><span id="8b41" class="lc ld hh ky b fi li lf l lg lh"># use the variable<br/>x.name<br/>x.age</span></pre><h2 id="e619" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">9.从磁盘读取文件并将文件保存到磁盘</h2><p id="3153" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">让我们看看如何有条理地阅读。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="5c37" class="lc ld hh ky b fi le lf l lg lh">f = open("dirk-gently.txt") # To read text from a file, first obtain a file handle: <br/>close(f) # When you've finished with the file, you should close the connection</span></pre><p id="2739" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果你使用下面的技巧，那么你就不需要关闭。当这个程序块完成时，打开的文件会自动关闭。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="3856" class="lc ld hh ky b fi le lf l lg lh">open("dirk-gently.txt") do file<br/>    # do stuff with the open file<br/>end</span></pre><h2 id="4944" class="lc ld hh bd lj lk ll lm ln lo lp lq lr jw ls lt lu ka lv lw lx ke ly lz ma mb bi translated">10.能够对你的代码进行注释，这样当你过一段时间再次访问它的时候就能理解它</h2><p id="b519" class="pw-post-body-paragraph jn jo hh jp b jq mc ii js jt md il jv jw me jy jz ka mf kc kd ke mg kg kh ki ha bi translated">我们可以告诉Julia，以#开头的一行代码是一个注释。</p><pre class="ix iy iz ja fd kx ky kz la aw lb bi"><span id="5471" class="lc ld hh ky b fi le lf l lg lh"># this is a comment</span></pre><p id="00d6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">总的来说，Julia是一种强大而灵活的编程语言，非常适合科学计算和其他高性能任务。Julia强调性能、多种调度以及不断增长的软件包和工具生态系统，对于研究人员、数据科学家和其他需要快速、灵活和富于表现力的语言来开展工作的专业人员来说，它是一个有价值的工具。</p><p id="1eda" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后，我将强调在学习任何新东西时练习的重要性。坚持不懈，尝试这些积木的不同组合，先解决简单的问题，再解决复杂的问题，是变得流利的唯一途径。</p><p id="8b98" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">欢迎评论！</p></div></div>    
</body>
</html>