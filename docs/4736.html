<html>
<head>
<title>Comparison — RandomForest with Oversampling vs Augmented Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对比—过采样随机森林与增强数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/comparison-randomforest-with-oversampling-vs-augmented-data-bd7fcb96ef0f?source=collection_archive---------0-----------------------#2022-01-26">https://medium.com/analytics-vidhya/comparison-randomforest-with-oversampling-vs-augmented-data-bd7fcb96ef0f?source=collection_archive---------0-----------------------#2022-01-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/efdc9275bfd6e3b153eb68e821786f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PPaDJSZHcNkKMFmZ"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">卢卡·布拉沃在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7ddd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这篇博客中，我想展示当在一个高度偏向的数据库上训练一个随机森林时，深度表格扩充可以带来的不同。在这种情况下，我们来看看信用卡欺诈，欺诈本身比非欺诈少得多。数据集可在<a class="ae it" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p><p id="4cef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看非frauf案例比欺诈案例多多少:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="56b9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总的来说，我们有284.807行，其中有283.823个非欺诈案例。为了利用深度表格扩充，我们需要缩放数据，然后只使用那些我们感兴趣的类，在这种情况下“类”等于1。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="9560" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了让我们的模型工作，我们需要将我们的数据放入DataLoader(这里我使用来自deep data augmentation的DataBunch类)。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="7897" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经准备好了。我们可以定义我们的可变编码器架构(这里:50–12–12–5–12–12–50 ),然后使用学习率查找器告诉我们最佳学习率:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es jy"><img src="../Images/57088ab8cc5f5755c2876c31979b49f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/1*fz0UJ5-LUwuQsSw5gi7T8Q.png"/></div></figure><p id="98c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们为我们的学习率设置了一个理想的学习率和时间表:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="d8d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们训练模型:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="a43d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看创建的数据是什么样子的:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jz"><img src="../Images/535d26489f2e19ea6924907c8c7f9059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JiN2zg6vxElT3elYWncA9g.png"/></div></div></figure><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ka"><img src="../Images/393df083dede23649d3186a1d35e2d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NBEgWcJCvo5byFGYpFnqPg.png"/></div></div></figure><h1 id="a800" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">训练随机森林</h1><p id="dba3" class="pw-post-body-paragraph iu iv hh iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">我们想要比较内置的class_weight功能与新方法的性能(剧透:如果你不使用任何权重，RandomForest将总是预测0)。因此，我们创建了三个数据帧:原始帧、附加了fake_data的原始帧、附加了带有噪声的伪数据的原始帧。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="b89f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使事情更容易理解，让我们定义训练和评估结果的数据集:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><p id="8d5d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，让我们在原始数据上训练模型，同时使用类出现的差异作为权重。</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es le"><img src="../Images/63d134c86bb616cf8e8554082d79a093.png" data-original-src="https://miro.medium.com/v2/resize:fit:344/format:webp/1*mC5c8C63Sw07jVzpviIakg.png"/></div></figure><p id="2f18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们使用扩充的数据帧:</p><figure class="js jt ju jv fd ii"><div class="bz dy l di"><div class="jw jx l"/></div></figure><figure class="js jt ju jv fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/b3c32f2002865d36bbb949b9504157be.png" data-original-src="https://miro.medium.com/v2/resize:fit:326/format:webp/1*jP9JNSEQ4WOO3Fpx91tX7Q.png"/></div></figure><p id="710b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">哇，我认为这是相当惊人的。我们设法大大增加了我们能够发现的欺诈案件的数量。此外，我们没有对模型架构进行任何微调，只是简单地使用了VAE的默认结构，就取得了这些结果。</p><p id="53e9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我希望这篇博客能给我们一些启示，为什么在高度有偏差的数据上使用这种方法值得一试。</p><p id="40ce" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">另外，如果你想自己试试，我做了一个包，你可以安装并使用。这里是<a class="ae it" href="https://github.com/lschmiddey/deep_tabular_augmentation" rel="noopener ugc nofollow" target="_blank">回购</a>。</p><p id="ccb4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">拉塞</p><p id="d835" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lg">原载于2021年1月24日</em><a class="ae it" href="https://lschmiddey.github.io/fastpages_/2021/04/10/DeepLearning_TabularDataAugmentation.html" rel="noopener ugc nofollow" target="_blank"><em class="lg">https://lschmiddey . github . io</em></a><em class="lg">。</em></p></div></div>    
</body>
</html>