<html>
<head>
<title>Single Linked Lists and Double Linked Lists Overview and Its Implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单链表和双链表概述及其在Python中的实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/single-linked-lists-and-double-linked-lists-overview-and-its-implementation-in-python-ffc41ffa7cfe?source=collection_archive---------20-----------------------#2021-01-12">https://medium.com/analytics-vidhya/single-linked-lists-and-double-linked-lists-overview-and-its-implementation-in-python-ffc41ffa7cfe?source=collection_archive---------20-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="5524" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">单一链接列表概述:</h1><p id="23ec" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">单个链表，最简单的形式，是节点的集合，共同形成一个线性序列。每个节点存储一个对作为序列元素的对象的引用，以及对列表中下一个节点的引用。</p><p id="a56a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在单链表中，每个节点都有两部分数据和下一个节点的地址，如下图所示。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/6419c94a8d424d84e743a6f63d9c5a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*4ia5X80xuEmCCi0jRl7hEw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated"><a class="ae kr" href="https://dev.to/ivywalobwa/singly-linked-list-f2m" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="1bcd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">单链表包含一个头指针，它包含第一个节点(头节点)的地址。向前连续移动。<br/>注意，最后一个节点的链接部分设置为空</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/ac8f781ca913cabefb271bd4c7609820.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/0*wYO41nlcj9HUKy5R.gif"/></div></div></figure><p id="2bce" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">链表的第一个和最后一个节点被称为链表的<strong class="je hi">头</strong>和<strong class="je hi">尾</strong>。我们可以将尾部标识为没有作为其下一个引用的节点。遍历节点并通过遍历节点来检查链表的过程通常被称为<strong class="je hi">遍历</strong>链表，遍历链表的过程有时也被称为<strong class="je hi">链接跳转</strong>或<strong class="je hi">指针跳转。</strong></p><p id="5879" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">每个节点都表示为一个唯一的对象，该实例存储对其元素的引用和对下一个节点的引用(或者不存储)</p><p id="1ad7" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">注意:</strong>链表的一个重要属性是它没有预先确定的固定大小。它使用的空间与其当前的元素数量成比例。</p><p id="555b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> </strong>我们创建一个新节点</p><p id="c64e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> </strong>将其元素设置为新元素</p><p id="d63e" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> </strong>设置其下一个链接到新元素</p><p id="4ff1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> </strong>设置其下一个链接指向当前头</p><p id="5dba" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi"> </strong>然后设置列表头指向新节点。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es kx"><img src="../Images/163f5a9f23b62d0fde76bc9260584836.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgiOO6HvOrzFho0RUO1_5A.png"/></div></div></figure><p id="c16d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">类似地，我们也可以很容易地在列表的尾部插入一个元素，只要我们保留一个对尾部节点的引用。</p><ol class=""><li id="e32d" class="ky kz hh je b jf ka jj kb jn la jr lb jv lc jz ld le lf lg bi translated">创建一个新节点。</li><li id="5291" class="ky kz hh je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg bi translated">将其下一个引用赋值为none。</li><li id="606a" class="ky kz hh je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg bi translated">将尾部的下一个引用设置为指向这个新节点。</li><li id="776c" class="ky kz hh je b jf lh jj li jn lj jr lk jv ll jz ld le lf lg bi translated">然后将尾部引用更新到我们已经创建的新尾部节点。</li></ol><p id="01c1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">从单链表的头部删除一个元素实质上是在头部插入一个新元素的反向操作。</p><p id="562c" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们不能轻易地删除单链表的最后一个节点。即使我们维护一个直接指向列表最后一个节点的尾引用，我们也必须能够访问最后一个节点之前的节点，以便移除最后一个节点。但是我们不能通过跟随尾部的下一个链接到达尾部之前的节点。</p><p id="dc90" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果我们想要有效地支持这样的操作，我们将需要把我们的列表做成双向链表。</p><h1 id="d0b6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">单链表实现</h1><p id="7260" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将实现一个基本的单链表。</p><p id="cf22" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">记住，在一个单链表中，我们有一个有序的条目列表，作为指向其他节点的单独节点。</p><pre class="kg kh ki kj fd lm ln lo lp aw lq bi"><span id="9aff" class="lr if hh ln b fi ls lt l lu lv">class Node(object):<br/>    <br/>    def __init__(self,value):<br/>        <br/>        self.value = value<br/>        self.nextnode = None</span></pre><p id="5c67" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在我们可以用节点集合构建链表:</p><pre class="kg kh ki kj fd lm ln lo lp aw lq bi"><span id="d91c" class="lr if hh ln b fi ls lt l lu lv">a = Node(1)<br/>b = Node(2)<br/>c = Node(3)</span><span id="4f56" class="lr if hh ln b fi lw lt l lu lv">a.nextnode = b</span><span id="e5f1" class="lr if hh ln b fi lw lt l lu lv">b.nextnode = c</span></pre><p id="da83" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在一个链表中，第一个节点被称为<strong class="je hi">头</strong>，最后一个节点被称为<strong class="je hi">尾</strong>。让我们讨论一下链表的优缺点:</p><h1 id="28df" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">赞成的意见</h1><ul class=""><li id="84f8" class="ky kz hh je b jf jg jj jk jn lx jr ly jv lz jz ma le lf lg bi translated">链表在任何位置都有固定时间的插入和删除，相比之下，数组做同样的事情需要O(n)时间。</li><li id="5850" class="ky kz hh je b jf lh jj li jn lj jr lk jv ll jz ma le lf lg bi translated">链表可以继续扩展，而不必事先指定它们的大小。</li></ul><h1 id="7e27" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">骗局</h1><ul class=""><li id="62c9" class="ky kz hh je b jf jg jj jk jn lx jr ly jv lz jz ma le lf lg bi translated">要访问链表中的一个元素，从链表头到第k个元素需要O(k)时间。相比之下，数组有常量时间操作来访问数组中的元素。</li></ul><h1 id="bfa6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">双向链表概述:</h1><p id="17f1" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在一个双向链表中，我们定义了一个链表，其中每个节点都保持一个对它之前的节点的显式引用和对它之后的节点的引用。</p><p id="47c0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">这些列表允许更多种O(1)时间的更新操作，包括插入和删除。</p><p id="acc2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们继续使用术语<strong class="je hi">“下一个”</strong>来指代跟随另一个节点的节点，并且使用术语<strong class="je hi">“上一个”</strong>来指代在它之前的节点。</p><p id="536d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在双向链表中，我们在链表的两端添加特殊的节点。</p><p id="53c2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">列表开头的<strong class="je hi">头</strong>节点和列表结尾的<strong class="je hi">尾</strong>。这些“虚拟”节点被称为<strong class="je hi">哨兵或守卫</strong>节点。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mb"><img src="../Images/0f69ed4dd40cf546db8cb2e4c550088d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KAvz7HI8L2WzIQ8r0mwvAQ.png"/></div></div></figure><p id="1e2f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">对双向链表表示的每次插入都将发生在一对现有节点之间。当一个新元素被插入到序列的前面时，我们将简单地在头部和头部后面的节点之间添加新的节点。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mc"><img src="../Images/9d3df827cb0cba98e4ee4c2454374c84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WJGOel5Vn55dk6jJ3nnoiw.png"/></div></div></figure><p id="1ffe" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">向双向链表中插入新元素与从双向链表中移除元素是一样的。</p><h1 id="3606" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">双向链表实现</h1><p id="e8e2" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">现在我们将实现一个双向链表</p><pre class="kg kh ki kj fd lm ln lo lp aw lq bi"><span id="0026" class="lr if hh ln b fi ls lt l lu lv">class DoublyLinkedListNode(object):<br/>    <br/>    def __init__(self,value):<br/>        <br/>        self.value = value<br/>        self.next_node = None<br/>        self.prev_node = None</span></pre><p id="6907" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在我们有了可以引用下一个<em class="md">和前一个</em>值的节点，让我们开始构建我们的链表吧！</p><pre class="kg kh ki kj fd lm ln lo lp aw lq bi"><span id="9810" class="lr if hh ln b fi ls lt l lu lv">a = DoublyLinkedListNode(1)<br/>b = DoublyLinkedListNode(2)<br/>c = DoublyLinkedListNode(3)</span><span id="34d2" class="lr if hh ln b fi lw lt l lu lv"># Setting b after a<br/>b.prev_node = a<br/>a.next_node = b</span><span id="fd75" class="lr if hh ln b fi lw lt l lu lv"># Setting c after a<br/>b.next_node = c<br/>c.prev_node = b</span></pre><p id="520f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">拥有一个双向链表允许我们向前<strong class="je hi">和向后</strong>遍历链表。</p><p id="d287" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在下一篇博客中，我们将看到递归及其在python中的实现。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="7607" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>