<html>
<head>
<title>Incremental and Reinforced learning for Image classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用于图像分类的增量和强化学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/incremental-and-reinforced-learning-for-image-classification-d02b7a6b7d07?source=collection_archive---------10-----------------------#2021-02-27">https://medium.com/analytics-vidhya/incremental-and-reinforced-learning-for-image-classification-d02b7a6b7d07?source=collection_archive---------10-----------------------#2021-02-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a838e5e44d63def6384ade0a0703889e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rdYTnHIljy7oBJeewD2pOQ.jpeg"/></div></div></figure><h1 id="6053" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="d200" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">深度学习今天面临的最大挑战之一是在不改变架构或存储先前数据集的情况下，向神经模型添加新标签。这些问题通常围绕这样一个事实:随着时间的推移存储数据会导致系统内存膨胀，并且还会显著增加训练时间。至于神经架构，它几乎是在训练的第一阶段定义的，或者我们可以称之为零模型，在添加新标签的同时使用以前的学习实际上是不可能的。</p><p id="ca9b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我们通常采用的解决方案是迁移学习，这有助于我们使用已训练模型的权重和偏差，并使用它来训练定制模型，这里的问题是，以前的标签不会结转。因此，要么我们需要系统被训练过的所有数据，要么我们需要现成的东西。</p><p id="1601" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这就是在具有混合神经架构的修改系统中的增量学习可以帮助我们获得期望结果的地方，而不损害准确性，或者不需要大量数据。</p><blockquote class="kq kr ks"><p id="f73c" class="jn jo kt jp b jq kl js jt ju km jw jx ku kn ka kb kv ko ke kf kw kp ki kj kk ha bi translated">如果我告诉你，我们打算从这篇文章中学习的不仅仅是增量学习，而是动态地将新数据和标签强化到系统中。T3】</p><p id="51d0" class="jn jo kt jp b jq kl js jt ju km jw jx ku kn ka kb kv ko ke kf kw kp ki kj kk ha bi translated"><strong class="jp hi"> <em class="hh">如果不需要海量数据来训练一个模型呢？梦想成真？</em> </strong></p></blockquote><p id="4409" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">不要浪费太多时间，让我们开始吧。<strong class="jp hi">你可以在这里</strong>  <strong class="jp hi">找到右</strong> <a class="ae kx" href="https://github.com/vaibhavsatpathy/incremental-reinforcement-learning" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi">下面的代码。</strong></a></p><p id="a79e" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">下面的步骤提到了必要的代码片段和对各个功能需求的解释。</p><h2 id="1de5" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">1.导入所有必需的库</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="02df" class="ky iq hh lr b fi lv lw l lx ly">import tensorflow as tf<br/>from tensorflow.keras.layers import Input, Conv2D, Dense, MaxPooling2D, Flatten, BatchNormalization, Reshape, LeakyReLU, multiply, Embedding, UpSampling2D, Dropout<br/>from tensorflow.keras.models import Model, load_model, Sequential<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.preprocessing.sequence import pad_sequences</span><span id="d7a8" class="ky iq hh lr b fi lz lw l lx ly">import os<br/>import numpy as np<br/>import json<br/>import cv2<br/>import matplotlib.pyplot as plt<br/>import random<br/>from tqdm import tqdm</span></pre><h2 id="86c1" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">2.我们为测试目的定义了一个非常简单的架构。您可以构建自己的定制架构来满足您的需求。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="ac2b" class="ky iq hh lr b fi lv lw l lx ly">def req_model(no_of_labels):<br/>    input_layer = Input(shape=image_inp_shape_conv)<br/>    conv_1 = Conv2D(filters=64, kernel_size=(2,2),activation='relu', padding='same')(input_layer)<br/>    flatten_1 = Flatten()(conv_1)<br/>    out_layer = Dense(no_of_labels, activation="softmax")(flatten_1)<br/>    <br/>    model = Model(input_layer, out_layer)<br/>    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])<br/>    return model</span></pre><h2 id="0d17" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">3.创建一个基本的函数来跟踪你的标签，并根据需要对文件进行必要的更新。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="0534" class="ky iq hh lr b fi lv lw l lx ly">def labels():<br/>    if os.path.isfile(labels_file_path):<br/>        labels_file = open(labels_file_path, "r")<br/>        labels = json.load(labels_file)<br/>    else:<br/>        labels_dict = {0:"noise"}<br/>        with open(labels_file_path, "w") as f:<br/>            json.dump(labels_dict, f)<br/>        labels = labels_dict<br/>    return labels</span></pre><h2 id="8a40" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">4.对于一个简单的图像分类类型问题，我们不要创建任何花哨的预处理。如果需要，您可以创建自己的定制预处理管道并替换现有管道。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="3aca" class="ky iq hh lr b fi lv lw l lx ly">def preprocess(image):<br/>    image_arr = cv2.imdecode(np.frombuffer(image, np.uint8), -1)<br/>    image_processed = cv2.resize(image_arr, image_inp_shape)<br/>    image_processed = cv2.cvtColor(image_processed, cv2.COLOR_BGR2GRAY)<br/>    image_processed = (image_processed) / 255.0<br/>    return image_processed</span><span id="1e00" class="ky iq hh lr b fi lz lw l lx ly">def preprocess_gan(image):<br/>    image_arr = cv2.imdecode(np.frombuffer(image, np.uint8), -1)<br/>    image_processed = cv2.resize(image_arr, image_inp_shape)<br/>    image_processed = cv2.cvtColor(image_processed, cv2.COLOR_BGR2GRAY).reshape((dense_output,))<br/>    image_processed = (image_processed) / 255.0<br/>    return image_processed</span></pre><h2 id="2690" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">5.为您的用户创建一个能够利用该模型的预测函数。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="9924" class="ky iq hh lr b fi lv lw l lx ly">def predict(image):<br/>    labels_read = labels()<br/>    if os.path.isfile(model_file):<br/>        model = load_model(model_file)<br/>    else:<br/>        model = req_model(no_of_labels=len(labels_read))<br/>    test_image = np.expand_dims(image, axis=0)<br/>    results = model.predict(test_image)<br/>    predicted_label = labels_read.get(str(np.argmax(results[0])))<br/>    return predicted_label</span></pre><h2 id="a198" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">6.现在是具有挑战性的部分。本质上，我们需要在下一个函数中写的是能够改变神经架构的权重和偏差的NumPy数组。</h2><p id="fedb" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">对于要添加到系统中的新标签，神经模型的最后一层需要具有额外的元素来适应改变。与此同时，模型先前的权重需要带入网络的更新形状中。</p><p id="70c3" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">如您所见，GAN模型也有一个更新的脚本。不要担心，我们将在后面的步骤中谈到这一点。</p><h2 id="0c3b" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">7.为模型创建一个训练脚本。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="ecda" class="ky iq hh lr b fi lv lw l lx ly">def train(image, ground_truth, add_label:bool):<br/>    labels_read = labels()<br/>    if os.path.isfile(model_file):<br/>        if add_label:<br/>            model_old = load_model(model_file)<br/>            model_new = req_model(no_of_labels=len(labels_read))<br/>            model = update_model_arc(model_v1=model_new, model=model_old)<br/>        else:<br/>            model = load_model(model_file)<br/>    else:<br/>        model = req_model(no_of_labels=len(labels_read))<br/>    test_image = np.expand_dims(image, axis=0)<br/>    ground_truth_arr = np.asarray([float(ground_truth)])<br/>    for i in tqdm(range(0,max_iter), desc="training req model..."):<br/>        history = model.train_on_batch(test_image,ground_truth_arr)<br/>    model.save("model.h5")</span></pre><h2 id="abdf" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">8.创建GAN模型架构。</h2><p id="e84c" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在我们进一步处理之前，让我们讨论同样的需要。为了训练和验证的目的，可以通过输入用户在测试系统时上传的样本来增强系统。问题是，当向系统显示太多新标签样本用于训练时，会发生什么。</p><p id="b54b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在一条直线上——这会在系统中产生偏差。为了避免这种情况，我们可以使用有条件的GAN，它本质上为所有已经在系统中训练过的标签创建虚拟数据，并将最新的用户数据与其一起传递。</p><p id="9684" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">从而在系统被训练的样本或种类的数量上建立平衡。</p><h2 id="265c" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">9.现在让我们创建训练和更新模型所需的包装函数。</h2><blockquote class="kq kr ks"><p id="5a8f" class="jn jo kt jp b jq kl js jt ju km jw jx ku kn ka kb kv ko ke kf kw kp ki kj kk ha bi translated"><strong class="jp hi"><em class="hh">CGAN的训练和使用是可选的。为了获得立竿见影的效果，避免使用CGAN进行培训，并注释掉相同的培训管道。</em>T3】</strong></p></blockquote><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="ab fe cl ma"><img src="../Images/2d67d5f75c30283ca4a6600139a8cccc.png" data-original-src="https://miro.medium.com/v2/format:webp/1*Pseb6oLc72__AzZbTvC4Bw.png"/></div></figure><h2 id="32ea" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">10.保存标签，以便它们可以重新用于预测和强化。</h2><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="c3a5" class="ky iq hh lr b fi lv lw l lx ly">def rev_labels(labels_dict):<br/>    rev_labels_read = {}<br/>    for key,val in labels_dict.items():<br/>        rev_labels_read[val] = key<br/>    return rev_labels_read</span></pre><h2 id="e64e" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">11.现在我们需要做的就是编译所有的东西并创建可能的场景。</h2><p id="1c61" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">场景1-您的模型第一次接受训练。<br/>场景2 —您的模型已经过训练，但由于预测错误而需要更新<br/>场景3 —您的模型已经在某些标签上进行了训练，现在需要添加一个新标签。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="ab fe cl ma"><img src="../Images/155c2c504c86cd78fdc6416c7f261a26.png" data-original-src="https://miro.medium.com/v2/format:webp/1*XrzbU8jco34utF_SexO3Jw.png"/></div></figure><h2 id="1f10" class="ky iq hh bd ir kz la lb iv lc ld le iz jy lf lg jd kc lh li jh kg lj lk jl ll bi translated">12.最后，让我们看看大量编码的结果。</h2><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="ab fe cl ma"><img src="../Images/7f74c93132b03489621f7868100a51d5.png" data-original-src="https://miro.medium.com/v2/format:webp/1*lcKXUZTDtSPro32QtAhM4w.png"/></div></figure><p id="8a88" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">有了这个，你将能够在不需要存储大量数据的情况下训练图像分类模型。当有大量用户使用这种系统并希望随着时间的推移获得更高的准确性时，这种系统可以证明是非常高效的。</p><p id="c62d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">相同的架构可以调整并用于各种用例，如情感分析、文档分类、声音分析等。</p><p id="4e89" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我希望本教程能帮助你开发突破性的技术。</p><p id="00e0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">谢谢你…</p><h1 id="ffb1" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">作者</h1><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/59063ff10aa359fadb05adf68c26d291.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZqnWSAk0LCaQ2zSA.jpg"/></div></div></figure><p id="15f5" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">最简单的描述我的方式是技术爱好者。我有一颗非常好奇的心，善于修补趋势技术，并通过尝试从不同的角度可视化问题来解决现实世界的问题。最后但同样重要的是，在一天结束的时候，我真的希望我的工作能对社会的进步产生建设性的影响。</p><p id="960d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">您也可以在我们的移动应用程序上阅读这篇文章。</p><p id="f7f9" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated"><em class="kt">原载于2021年2月27日https://www.analyticsvidhya.com</em><em class="kt"/><a class="ae kx" href="https://www.analyticsvidhya.com/blog/2021/02/incremental-and-reinforced-learning-for-image-classification/" rel="noopener ugc nofollow" target="_blank"><em class="kt">。</em></a></p></div></div>    
</body>
</html>