# SQL 软件最合适的替代品是什么？

> 原文：<https://medium.com/analytics-vidhya/what-are-the-most-appropriate-alternatives-to-sql-software-eb42af2ba016?source=collection_archive---------0----------------------->

![](img/0ad1c90da63c3a512fb5f4cfa7a0b676.png)

作为一种编程语言，对于数据库计算，开源的 SPL 是 SQL 的更好替代。

**数据库语言的目标**

为了阐明这个目标，我们需要首先理解数据库是做什么的。

说到数据库，人们总是认为它主要是用来存储的，因为它的名字中有一个“base”部分。但实际上并非如此，数据库可以实现两个重要的功能:**计算和事务**，也就是我们常说的**OLAP 和 OLTP。数据库的存储就是为了这两个功能，仅仅充当存储角色并不是数据库的目标。**

**我们知道，SQL 是目前主流的数据库语言。那么，用 SQL 做这样两件事方便吗？**

**事务函数主要是解决读写过程中数据的一致性问题。虽然很难实现，但它的接口对于应用程序来说非常简单，操纵数据库读写的代码也非常简单。如果假设关系数据库的当前逻辑存储方案是合理的(即，使用数据表和记录来存储数据。是否合理是另一个复杂的问题，这里就不详细讨论了)，那么用 SQL 来描述事务函数就不是什么大问题了，因为不需要描述复杂的动作，复杂性已经在数据库里解决了。**

**至于计算功能，不过，情况会有所不同。**

**我们这里说的计算是一个更宽泛的概念。它不仅仅是简单的加法和减法，搜索和联想都可以看作是一些计算。**

**那么问题来了，什么样的计算系统好？**

**需要两个特征:**易写，运行快。****

**易写容易理解，就是让程序员快速写代码，这样单位时间可以做更多的工作；而对于 fast in running，更容易理解，因为我们肯定希望在更短的时间内得到计算结果。**

**实际上，SQL 中的 Q 代表查询。发明 SQL 的最初目的是查询(即计算)，这是 SQL 的主要目标。但是，在描述计算任务时，很难说 SQL 非常胜任。**

****SQL 为什么不行****

**让我们从简单的写作开始。**

**用 SQL 写的代码很像英文，有些查询可以用英文读写(网上例子太多了，这里就不举例了)。这应该算是满足了易写的要求。**

**等一下！我们在课本上看到的用 SQL 写的代码往往只有两三行，确实简单，但是如果我们试图解决一些稍微复杂一点的问题呢？**

**下面举一个实际上并不是很复杂的例子:计算一只股票保持上涨的最大连续天数。用 SQL 把它写成这样:**

```
select max (consecutive_day) 
from (select count(*) (consecutive_day 
      from (select sum(rise_mark) over(order by trade_date) days_no_gain 
            from (select trade_date, 
                         case when closing_price>lag(closing_price) over(order by trade_date) 
                              then 0 else 1 END rise_mark 
                  from stock_price ) ) 
      group by days_no_gain)
```

**这个说法的工作原理这里就不解释了，反正有点混乱。你可以自己试试。**

**这是 Raqsoft 公司的一次招聘考试，通过率不到 20%；因为太难，后来改成了另一种测试方式:请考生解释一下写的 SQL 语句是什么，可惜通过率还是不高。**

**它揭示了什么？它揭示了情况稍微复杂，SQL 变得既难理解又难写！**

**我们来看一下跑步中的快这个问题，以经常使用的简单任务为例:从一亿条数据中取前 10 名。用 SQL 编写这个任务并不复杂:**

```
SELECT TOP 10 x FROM T ORDER BY x DESC
```

**但是这个语句对应的执行逻辑是先对所有数据进行大排序，然后取前 10 个，剩下的数据丢弃。众所周知，排序是一个非常慢的操作，并且会多次遍历数据。如果数据量太大而无法加载到内存中，它还需要在外部存储中缓冲数据，从而导致性能进一步急剧下降。如果严格遵循这个语句所体现的逻辑，操作无论如何都不会运行得很快。幸运的是，许多程序员知道这种操作不需要大的排序，也不需要外部存储来缓冲，因为它只需遍历一次，只占用很少的内存空间，这意味着存在更高性能的算法。遗憾的是，这样的算法无法用 SQL 实现。我们只能希望数据库优化器足够聪明，能够将这个 SQL 语句转换成高性能算法来执行，但是当情况复杂时，数据库优化器可能不可靠。**

**看来 SQL 在这两方面都做得不好。虽然这两个例子都不是很复杂，但是 SQL 在这两个例子中的表现都不好。实际上，难以编写和运行缓慢的情况在有数千行的 SQL 代码中比比皆是。**

**那么，为什么这两个方面在 SQL 中不能很好的实现呢？**

**要回答这个问题，我们需要分析用程序代码实现计算到底是做什么的。**

**本质上，编程的过程就是**将解决问题的想法翻译成计算机可执行的精确形式语言的过程**。举个例子，就像小学生解一道应用题一样，学生在分析问题并想出解决方法后，也需要列出一个与四种基本算术运算相关的表达式。同样，对于用程序进行的计算，不仅需要想出解决方案，还需要将解决方案转化为计算机可以理解和执行的动作。**

**对于用来描述计算方法的形式语言来说，其核心在于所采用的代数系统。简单来说，所谓的代数系统包括两个关键要素:数据类型和相应的运算规则。例如，我们在小学学习的算术的关键要素是整数和包括加、减、乘、除在内的运算。一旦我们得到了这两个关键元素，我们就可以用代数系统中规定的符号把我们想要的运算写成某个东西，也就是代码，然后计算机就可以执行了。**

**如果一个代数系统设计得不好，导致提供的数据类型和运算不方便，那么描述算法就会非常困难。在这种情况下，会出现一个奇怪的现象:**将解决方案翻译成代码的难度远远大于解决问题本身**。**

**例如，我们在童年时学会了使用阿拉伯数字进行日常计算，使用这样的数字进行加减乘除非常方便，因此每个人都自然地认为数字运算应该是这样的。所有的数值运算都这么方便吗？不一定！估计很多人都知道还有一个数字叫罗马数字。你知道罗马数字的加减乘除吗？还有古罗马人是怎么上街购物的？**

****编码之所以难，很大程度上是因为代数。****

**我们来看看跑不快的原因。**

**软件不能改变硬件的性能；CPU 和硬盘的速度取决于各自的配置。但是我们可以设计一个低复杂度的算法，也就是计算量更小的算法，让计算机执行更少的动作，这样运行速度自然会更快。然而，仅仅算出算法是不够的，我们还需要用某种形式语言对算法进行编程，否则，计算机将无法执行。此外，它需要相对简单的编码。如果某一种形式语言的代码很长，会很麻烦，没有人会用这样的形式语言。所以对于程序来说，**易写和快运行**其实是同一个问题，背后是形式语言采用的代数。如果代数不好，高性能算法就很难甚至不可能实现，结果就是没办法跑快。如上所述，我们所期望的占用一点内存空间并且只遍历一次的算法在 SQL 中是无法实现的。因此，如果您希望它运行得更快，您只能寄希望于优化器。**

**我们再打个比方:**

**上过小学的同学大概都知道高斯算 1+2+3+…+100 的故事。普通学生采用的是最原始的方法，就是一步一步地加 100 倍，而小高斯非常聪明，他发现 1+100=101，2+99=101，…，50+51=101，由此他将 50 乘以 101，因此很快算出结果，然后回家吃午饭。**

**听完这个故事，我们都觉得高斯太聪明了，竟然想到了这么巧妙的解决办法，简单又快捷。对，没错，但是很容易忽略一点:在高斯的时代，**乘法**早已存在于人类的算术体系中(也是一种代数)！如前所述，由于我们在童年时学习了四则算术运算，因此我们理所当然地认为应该使用乘法。但实际上不是！乘法是加法之后发明的。如果高斯时代还没有发明乘法，无论高斯有多聪明，他也不会找到快速解决这个问题的方法。**

**目前主流的数据库是关系数据库，之所以这么叫，是因为它的数学基础叫做**关系代数**。SQL 正是从关系代数理论发展而来的一种形式语言。**

**现在可以回答为什么 SQL 在我们预期的两个方面都不能胜任了。**问题出在关系代数**，关系代数就像一个只有加法没有乘法的算术系统。所以很多事情做不好是必然的。**

**关系代数已经发明了五十年。五十年前和今天的应用程序要求和硬件环境之间的差异非常巨大。继续套用五十年前的理论来解决今天的问题，是不是听起来太过时了？然而，这就是现实。由于大量的现有用户和缺乏成熟的新技术，基于关系代数的 SQL 仍然是当今最重要的数据库语言。虽然近几十年来做了一些改进，但基础并没有改变。面对当代复杂的需求和硬件环境，SQL 力不从心也在情理之中。**

**而且很遗憾，这个问题是理论层面的，在实践中再怎么优化也无济于事，只能有限的改善，而不能根除。遗憾的是，大多数数据库开发者并没有想到这个层面，或者说，为了照顾现有用户的兼容性，他们并不打算考虑这个层面。于是，主流数据库行业一直在这个有限的空间里兜圈子。**

****为什么 SPL 有能力****

**那么，如何使计算更容易写，运行更快呢？**

****发明新的代数！**一个带“乘法”的代数，然后基于新的代数设计新的语言。**

**这就是 SPL 的由来。它的理论基础不再是关系代数，而是一种叫做**离散数据集**的东西。基于这种新代数设计的形式语言被命名为 **SPL** (结构化过程语言)。**

**针对 SQL 的缺点对 SPL 进行了创新(更准确地说，针对关系代数的各种不足对离散数据集进行了创新)。SPL 重新定义和扩展了结构化数据的许多操作，具体来说，它增加了离散性，增强了有序计算，实现了彻底的集合定向，支持对象引用，并提倡分步操作。**

**限于篇幅，这里不全面介绍 SPL(离散数据集)，而列举 SPL(离散数据集)对 SQL(关系代数)的一些差分改进:**

****离散记录****

**离散数据集中的记录是一种基本数据类型，可以独立于数据表而存在。数据表是由记录构成的集合，组成某个数据表的记录也可以用来组成其他数据表。例如，过滤操作是使用原始数据表中符合条件的记录组成一个新的数据表，这样，无论是在空间占用还是操作性能上都更有优势。**

**关系代数没有可计算的数据类型来表示记录。单个记录实际上是只有一行的数据表，不同数据表中的记录一定不能相同。例如，在过滤操作中，新的记录将被复制以形成新的数据表，这将导致空间和时间成本的增加。**

**特别是，由于存在离散记录，离散数据集允许记录的字段值是某个记录，这样更容易实现外键连接。**

****订购特性****

**关系代数是基于无序集合设计的，集合成员没有序号的概念。而且，它不提供定位计算和相邻参考的机制。在实践中，SQL 做了一些局部改进，允许现代 SQL 轻松地进行一些有序操作。**

**相反，离散数据集中的集合是有序的，所有集合成员都有序号的概念，可以用序号访问。此外，离散数据集定义定位操作，以便返回集合中成员的序列号。另外，离散数据集提供了在集合运算中实现相邻引用的符号，并支持根据集合中某个序号的位置进行计算。**

**有序操作很常见，但对于 SQL 来说一直很难。即使有窗口函数可用，SQL 中有序操作的实现仍然非常麻烦。SPL 已经大大改善了这种情况，这可以从前面股票上涨的例子中得到说明。**

****离散性和设定方位****

**关系代数定义了丰富的集合运算，即可以把集合作为一个整体来参与聚合、分组等运算。这就是 SQL 比 Java 之类的高级编程语言更方便的地方。**

**而关系代数离散性很差，没有离散记录，而 Java 等高级编程语言在这方面没有问题。**

**至于离散数据集，相当于把离散性和集合定向结合起来，也就是说它不仅有集合数据类型和相关操作，还有从集合中分离出来做独立操作或形成其他集合的集合成员。因此，可以说 SPL 集成了 SQL 和 Java 的优点。**

**有序操作是一种典型的将离散性与设定方向相结合的情况。序的概念只对集合有意义，对单个成员无意义，体现了集合取向；有序运算需要计算某个成员及其相邻成员，需要离散性。**

**只有在离散性的支持下，才能获得更彻底的集合定向，才能解决有序运算之类的问题。**

**简而言之，离散数据集是一个同时具有离散性和集向性的代数系统，而关系代数只有集向性。**

****对分组的理解****

**分组操作的初衷是将一个大的集合按照一定的规则拆分成几个子集。在关系代数中，由于没有可以表示集合的集合的数据类型，所以它必须在分组后进行聚合操作。**

**反之，离散数据集允许集合的集合，它能代表合理的分组运算结果。分组操作和分组后的聚合操作被分成两步独立的操作。这样，可以对分组的子集执行更复杂的操作。**

**在关系代数中，只有一种等价分组，即根据分组键值对集合进行划分。等价分组是一个完整的划分。**

**然而，对于离散数据集，它认为任何分裂大集合的方法都是分组操作。除了常规的等价分组，它还提供了结合排序特征的有序分组，以及可能得到不完全除法结果的对齐分组。**

****对聚合的理解****

**关系代数中没有显式的集合数据类型。聚合计算的结果都是单值，分组后的聚合运算也是单值，只包括 SUM、COUNT、MAX、MIN 等。特别地，关系代数不能把 TOPN 运算看作一个集合。输出结果集时，对整个集合执行的 TOPN 运算只能取排序后的前 N 项。然而，对于分组的子集，很难实现 TOPN，在这种情况下，需要改变思路，并制定出序号来实现。**

**离散数据集主张泛集，聚合运算结果不一定是单个值，也可能仍然是一个集合。在离散数据集中，TOPN 运算与求和、计数等具有相同的地位。也就是说，它可以在整个集合或分组的子集上执行。**

**SPL 将 TOPN 作为聚合操作后，也可以避免实际中所有数据的排序，从而获得高性能。然而，SQL 中的 TOPN 总是伴随着按操作排序。理论上只能靠大排序来实现，这种情况下，你需要寄希望于实践中的数据库优化。**

****订购特性支持高性能****

**离散数据集特别强调有序集，可以使用有序特征实现许多高性能算法。这是基于无序集的关系代数无法实现的，只能寄希望于实践中的优化。**

**以下是一些可以使用排序特征实现的低复杂度操作:**

**1)数据表按主键排序，相当于自然有了索引。通常可以快速定位关键字段的过滤，以减少外部存储器中的遍历量。按键值随机取数据时，二分搜索法也可以用来定位；在通过多个键值同时提取数据的情况下，可以重用索引信息。**

**2)通常，分组操作是用哈希算法实现的。如果我们确定数据是按分组键值排序的，我们只需要做相邻比较，从而避免了哈希值的计算，这样就不会有哈希冲突问题，非常容易进行并行计算。**

**3)数据表按键排序，两个大表之间的对齐连接可以使用性能更高的合并算法。这样，我们只需要遍历数据一次，而不需要缓冲数据，从而使内存占用更少。然而，传统的散列值划分方法不仅相对复杂，需要更多的存储器和外部存储中的数据缓冲，而且还可能由于不适当的散列函数而导致二次散列和重新缓冲。**

**4)大型表作为外键表的连接。当事实表比较小时，可以使用外键表进行排序，从中快速取出关联键值对应的数据实现连接，不需要做哈希分区。当事实表也很大时，我们可以用分位数将外键表划分成多个逻辑段，然后再用逻辑段对事实表进行分区。这样只需要对一个表进行分区，在分区的过程中不会出现哈希分区时可能出现的二次分区，从而计算复杂度大大降低。**

**上面的第 3)项和第 4)项利用了离散数据集中连接操作的修改。如果继续使用关系代数中的定义(可能会产生多对多)，很难实现这样的低复杂度算法。**

**除了理论上的差异，SPL 还有很多工程级的优势，比如:更容易编写并行计算代码，大内存预关联提高外键连接性能，独特的列存储机制支持任意分段和并行计算等。**

**重新记录之前在 SPL 的问题会给你一个直接的感受。**

**计算股票持续上涨的最大连续天数:**

```
stock_price.sort(trade_date).group@i(closing_price<closing_price[-1]).max(~.len())
```

**虽然计算思路和之前的 SQL 一样，但是因为引入了排序特性，所以表达起来简单多了，不再混乱。**

**从 1 亿条数据中选出前 10 条:**

```
T.groups(;top(-10,x))
```

**SPL 有更丰富的集合数据类型，很容易描述在单次遍历上实现简单聚集的高效算法，而不涉及大的排序动作。**

**这里有更多的代码和大数据算法反映了 SPL 的想法:**

**[性能优化技巧:使用多用途遍历加速多个分组](http://c.raqsoft.com/article/1571218947381)**

**[性能优化技能:TopN](http://c.raqsoft.com/article/1571217482491)**

**[性能优化技能:预加入](http://c.raqsoft.com/article/1578990230409)**

**[性能优化技能:部分预关联](http://c.raqsoft.com/article/1577757794142)**

**[性能优化技巧:对外键进行编号](http://c.raqsoft.com/article/1577758685313)**

**[性能优化技能:维度表过滤关联&计算](http://c.raqsoft.com/article/1577759666735)**

**[性能优化技能:有序合并](http://c.raqsoft.com/article/1578990862712)**

**[性能优化技巧:有序定位关联，加速连接的子母表上的过滤](http://c.raqsoft.com/article/1583486613507)**

**[性能优化技巧:附表](http://c.raqsoft.com/article/1584935117965)**

**[性能优化技巧:关联小事实表和大维度表](http://c.raqsoft.com/article/1585880740537)**

**[性能优化技巧:关联大事实表和大维度表](http://c.raqsoft.com/article/1585881236616)**

**[性能优化技能:有序分组](http://c.raqsoft.com/article/1586241773057)**

**[性能优化技能:后半段有序分组](http://c.raqsoft.com/article/1589945316467)**

**[性能优化技能:前半有序排序](http://c.raqsoft.com/article/1589944685796)**