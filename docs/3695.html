<html>
<head>
<title>Complete guide to Pandas library (Python Code) — Part 2/ 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫图书馆完整指南(Python代码)——第2/ 4部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/complete-guide-to-pandas-library-python-code-part-2-4-4c0d9d9bd511?source=collection_archive---------11-----------------------#2021-07-18">https://medium.com/analytics-vidhya/complete-guide-to-pandas-library-python-code-part-2-4-4c0d9d9bd511?source=collection_archive---------11-----------------------#2021-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="35a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在第一部分学到了很多基础知识。现在，您知道了如何使用多种条件、过滤器和选择来创建数据框的子集。我们还讲述了如何处理缺失值，找出缺失值背后的原因，并使用多熊猫函数总结数据集。</p><p id="6c75" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这部分将重点介绍<a class="ae jc" href="https://pandas.pydata.org/pandas-docs/stable/index.html" rel="noopener ugc nofollow" target="_blank">熊猫</a>库的<strong class="ig hi">数据角力能力</strong>。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/1b58927a233afdee339fa48d46ede97c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*84TDQCD1j0AGVdlH"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jc" href="https://unsplash.com/@firmbee?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Firmbee.com</a>在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><h2 id="bcba" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">索引</h2><ul class=""><li id="9f45" class="ko kp hh ig b ih kq il kr ip ks it kt ix ku jb kv kw kx ky bi translated">使用不同的数据类型。</li><li id="5957" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">重塑数据帧对象</li><li id="349b" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">绕轴旋转</li><li id="bdd6" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">数据聚合和分组操作</li></ul><p id="0a4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在接下来的两篇文章中，我们将对2020年数据集使用<strong class="ig hi">堆栈溢出调查。</strong>该数据集拥有来自180多个国家的近65，000份回复。调查的目的是涵盖开发者体验的所有方面，从职业满意度和求职到教育和对开源软件的看法。</p><p id="2941" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据集:<a class="ae jc" href="https://insights.stackoverflow.com/survey" rel="noopener ugc nofollow" target="_blank">https://insights.stackoverflow.com/survey</a></p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="3aa0" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">加载数据集和基本的数据理解。</h2><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="e6cd" class="jt ju hh lm b fi lq lr l ls lt">data = pd.read_csv("survey_results_public.csv")<br/>data.head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/33c3c6467d2511c795fdfb0da59ad7b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GWM4ZXXMrE-8LHDjINqYKQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><em class="lv">数据集第一眼</em></figcaption></figure><p id="c3cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">始终将理解和验证数据集中所有属性的真实性作为EDA过程的首要目标。<br/>在开始任何事情之前，检查以下提到的一些基本事项:</p><blockquote class="lw lx ly"><p id="6425" class="ie if lz ig b ih ii ij ik il im in io ma iq ir is mb iu iv iw mc iy iz ja jb ha bi translated"><strong class="ig hi">考虑数据集= df </strong></p></blockquote><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="fccb" class="jt ju hh lm b fi lq lr l ls lt"><strong class="lm hi">df.shape</strong>  #Shape of the whole dataset</span><span id="1912" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi">df.dtypes</strong>  #Data type of every attribute</span><span id="72cd" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi">df.describe</strong>  #Overview of all statistical detail of Numerical col.</span><span id="86fd" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi">df.describe(include = 'object')</strong>  #For Object Columns.</span><span id="6f6e" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi">df.isnull().sum()  </strong>#Total number of null values in Dataset.</span><span id="9e35" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi">df['column name'].unique()</strong>  #Total number of unique cat. values</span></pre><h2 id="91bb" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated"><em class="lv">使用不同的数据类型</em></h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es me"><img src="../Images/c7f7f7f8fe9644cc555c734626f64c97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gjAyhxZIPiPIE3NS"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jc" href="https://unsplash.com/@deonblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">迪昂布莱克</a>在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2d2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过执行上述步骤，您将对数据集有一个很好的了解，假设您发现各种应该是对象或分类格式的属性都是整数格式，反之亦然，如果一个应该是日期格式的列是对象格式又会怎样。我们需要在继续分析之前解决这个问题，因为这是确保我们的数据集讲述正确故事的一个非常重要的步骤。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="3ae9" class="jt ju hh lm b fi lq lr l ls lt"><strong class="lm hi"># Converting numeric datatype to Object</strong></span><span id="be30" class="jt ju hh lm b fi md lr l ls lt">data['Respondent'] = data['Respondent'].astype('object')</span><span id="d7a0" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi"># Converting object datatype to Numeric</strong></span><span id="daf4" class="jt ju hh lm b fi md lr l ls lt">data['Age'] = pd.to_numeric(data.Age)</span><span id="250f" class="jt ju hh lm b fi md lr l ls lt"><strong class="lm hi"># Converting object datatype to Date format</strong></span><span id="f13a" class="jt ju hh lm b fi md lr l ls lt">new_data['date']  = pd.to_datetime(new_data['date'])</span></pre><h2 id="d5ae" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">重塑表格和数据透视表</h2><p id="18d4" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip mf ir is it mg iv iw ix mh iz ja jb ha bi translated">现在，重塑数据集仅仅意味着以最适合您需求的格式制作和拆分数据集。例如，如果您想要创建时间序列图，您需要一个<strong class="ig hi">日期</strong>列作为您的索引，并且需要绘制的值必须在每个日期的列中。</p><p id="274c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这样的需求，您甚至不需要处理数据集中的其余列，因此您可以删除它们，或者简单地创建一个包含所需特定列的单独的数据集。</p><p id="6cbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，为了重塑数据集，您可以根据您想要执行的操作，使用pandas中的多个函数，即<strong class="ig hi"> <em class="lz">、pivot()、pivot_table()、melt()、stack() </em> </strong> <em class="lz"> </em>。</p><p id="5da4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来看看实际情况，为此我们将使用一个单独的<a class="ae jc" href="https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>。只是为了更方便。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mi"><img src="../Images/e67ff8baf38a2679032812e957c36707.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mbX8YaHBkIriIvI3TDxT-A.png"/></div></div></figure><p id="7cf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，正如您所看到的，这个数据集有更多的数字列，但没有日期属性。因此，我们可以创建一个只是为了演示的目的</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="471a" class="jt ju hh lm b fi lq lr l ls lt">new_data['date'] = pd.date_range(start='2020/01/01'  , end='2020/10/29', freq='D')</span><span id="ba1b" class="jt ju hh lm b fi md lr l ls lt"><br/># pd.daterange() -- This function creates a date range.</span><span id="678e" class="jt ju hh lm b fi md lr l ls lt"># start -- This specifies the start of the date range</span><span id="450d" class="jt ju hh lm b fi md lr l ls lt"># end  -- This specifies the end of the date range.</span><span id="0a5a" class="jt ju hh lm b fi md lr l ls lt"># freq -- Creates dates based on days. Other options are W, M, Y.</span><span id="4a0b" class="jt ju hh lm b fi md lr l ls lt"># period -- Specifies how many interval between dates(12 for a Year)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mj"><img src="../Images/95910d687c3f7536d550291d026d44ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8ZoOMPwaoVSnoll8yzht6w.png"/></div></div></figure><h2 id="47ab" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">创建枢纽</h2><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="6e6c" class="jt ju hh lm b fi lq lr l ls lt">new_data.pivot(index='date' , columns='cp' ,values = 'age' ).head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mk"><img src="../Images/858c57f7b8d2c6ab87f1002498dc0bec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0q8CeZcB7T8asK9tIKv-wg.png"/></div></div></figure><p id="cdf3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您创建pivot <strong class="ig hi"> index </strong>、<strong class="ig hi"> column </strong>和<strong class="ig hi"> values </strong>是三个需要指定的重要参数，数据将相应地被重新整形。请注意，values参数是将根据这些行索引和列索引绘制的参数。</p><p id="a30a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">重要提示:</strong>请记住，如果省略了values参数，并且数据集中有多个列，则生成的透视数据框架将采用所有这些列，并创建一个分层索引。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ml"><img src="../Images/a02f7eb92c0ec18df2eb3ca9a7d7efff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l7dgo1ao6HJh48XH_UYxfw.png"/></div></div></figure><p id="f2f5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您看到，在这个例子中，我没有提供values参数，因此pivot创建了一个包含数据集中所有其他列的多索引数据框架。</p><p id="1aea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的数据集中有如此多的NaN值，我们可以使用fillna()参数用任何值填充它们。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="45fa" class="jt ju hh lm b fi lq lr l ls lt">new_data.pivot(index='date' , columns='cp' ,values = ['age','sex' ,'chol']).fillna(0).head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mm"><img src="../Images/8d1c040cbdb849829c1202e4b716606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tVLw8pMXpvx9uLTn0pCRDA.png"/></div></div></figure><blockquote class="lw lx ly"><p id="9862" class="ie if lz ig b ih ii ij ik il im in io ma iq ir is mb iu iv iw mc iy iz ja jb ha bi translated">如果索引/列对不是唯一的，<code class="du mn mo mp lm b"><a class="ae jc" href="https://pandas.pydata.org/docs/reference/api/pandas.pivot.html#pandas.pivot" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">pivot()</strong></a></code>将抛出错误<code class="du mn mo mp lm b">ValueError: Index contains duplicate entries, cannot reshape</code>。在这种情况下，可以考虑使用<code class="du mn mo mp lm b"><a class="ae jc" href="https://pandas.pydata.org/docs/reference/api/pandas.pivot_table.html#pandas.pivot_table" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">pivot_table()</strong></a></code>，它是pivot的一种推广，可以处理一个索引/列对的重复值。</p></blockquote><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="83c5" class="jt ju hh lm b fi lq lr l ls lt">new_data.pivot_table(index = 'age' , columns= 'sex' , values = ['chol' , 'thall','oldpeak'] ).head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mq"><img src="../Images/bf9f15a140644a2e3da92aa544e56d5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_O499XEVPssaf8DEWRhKHg.png"/></div></div></figure><h2 id="a2e9" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">融化( )</h2><p id="7d0c" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip mf ir is it mg iv iw ix mh iz ja jb ha bi translated">melt()是另一个可用于以类似方式重塑数据集的函数，它采用以下参数。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="b9e4" class="jt ju hh lm b fi lq lr l ls lt">new_data[['age' , 'sex' , 'cp']].melt(id_vars= ['age' , 'sex'] , var_name='Rest of the column').head()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mr"><img src="../Images/fa9781f3da0d59240b0d916abcc6fdb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6KzBduCUzQjgzTbFfGYYgw.png"/></div></div></figure><p id="0109" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">重要:</strong>在melt()中，id_vars是将被视为用于整形的索引值的参数，与pivot()中的索引和列相同，value_vars与value参数相同。</p><p id="0ea2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，在melt中，如果不提供value_vars参数，它将使用数据集中的每一列垂直创建堆栈。<em class="lz">(尝试剧情一次)</em></p><h2 id="b77e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">数据聚合和分组操作</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ms"><img src="../Images/f56e23416923b3e45620156c86370230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*farc_0AAKXisgFTy"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jc" href="https://unsplash.com/@iamchang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">张阳</a>在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="cbea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文的这一部分是最有趣的部分，使用groupby()和agg()函数可以完成的事情绝对没有限制，特别是通过将它们组合在一起。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="6ed8" class="jt ju hh lm b fi lq lr l ls lt">new_data.groupby(["sex" , "cp"]).count()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mi"><img src="../Images/d283402f41641336fabdb0c9791fbe1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7hYy-M4BP51VAxgyFwu5bA.png"/></div></div></figure><p id="2a3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们使用groupby()函数对大量数据进行分组，现在我们可以对整组数据应用各种函数。<br/> groupby()操作包括拆分对象、应用函数和组合结果的一些组合。输出是一个groupby对象，其中包含有关组的信息。</p><p id="e022" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">像max()、min()、mean()、first()、last()这样的函数可以快速应用于GroupBy对象</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="0408" class="jt ju hh lm b fi lq lr l ls lt">new_data.groupby(["sex" , "cp"]).max()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mt"><img src="../Images/a6b2501e330e780f563bf1960217c62f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pcBYPwW4mqI257zslO3reA.png"/></div></div></figure><p id="c772" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您在这里看到的输出基本上是按性别和年龄列分组时每个属性的最大值，这可以解释为</p><ul class=""><li id="6a21" class="ko kp hh ig b ih ii il im ip mu it mv ix mw jb kv kw kx ky bi translated">"<em class="lz">女性(性别= 0)出现下胸痛(cp = 0)的最大年龄是71岁</em>"</li><li id="6aee" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">患有高度胸痛(cp = 3)的女性(性别= 0)的最大年龄是69岁</li></ul><p id="b9f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，您可以使用其余的功能，并很快获得这些有意义的见解。</p><p id="e80c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以通过使用groupby子句后的过滤器来选择想要在输出中显示多少列，让我们只选择<em class="lz"> age </em>和<em class="lz"> chol </em>列来显示它们的最大值。<br/>这很有用，如果您想查看最大值，但只查看特定列而不是所有列的最大值。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="331c" class="jt ju hh lm b fi lq lr l ls lt"> new_data.groupby(["sex" , "cp"])[['age' , 'chol']].mean()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mx"><img src="../Images/430766d1d547b69fdd8373035c3a253c.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*eW41Mor4IxYsPOTRF1S13w.png"/></div></figure><p id="022d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您希望仅查找女性患者的所有这些值，或者仅查找胸痛值为3的患者的所有这些值，以便对他们的药物治疗进行优先级排序，您可以通过筛选一个列来实现这一点，以便仅对特殊组而不是整个数据集应用groupby函数</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="0b85" class="jt ju hh lm b fi lq lr l ls lt">new_data[new_data['cp'] == 3].groupby(['sex' , 'thall']).max()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es my"><img src="../Images/8f78035a1e6810d65362e83d3f6589e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YKE4UGUlAs_jsmOg4C4zpg.png"/></div></div></figure><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="117f" class="jt ju hh lm b fi lq lr l ls lt">new_data[new_data['sex'] == 0].groupby(['sex' , 'thall']).max()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es my"><img src="../Images/c5f541fba41fd2ccafa6eb9be39a4632.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rjgDXB6OBy4H6qoiaCi8oQ.png"/></div></div></figure><p id="82e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，如果您不想将这些用于groupby的列作为索引，并希望将它们视为dataframe中的一列，或者假设您已经完成了使用groupby函数对数据集的操作，现在您希望将它们作为最终数据集导出，您可以通过传递一个附加参数as_index = False来实现这一点，它们将不再是索引值，而是dataframe中的一列。非常酷…不是吗？</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="f49d" class="jt ju hh lm b fi lq lr l ls lt">new_data[new_data['cp'] == 3].groupby(['sex' , 'thall'] , as_index = False).max()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mz"><img src="../Images/7ed9796ee2fc88f1ca794d2907877fce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lCfkbmO1xQpl_JBih5aw5w.png"/></div></div></figure><p id="252c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这只是使用groupby的几种方式，对于所有用途的分析，这个函数是多么强大，我怎么强调都不为过。</p><p id="cbe1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们来谈谈聚合函数，它和groupby一样神奇，如果我们将它们结合起来，它会更加强大。<br/>聚合函数，agg()用于一次聚合多个计算任务的函数。您还可以传递要应用于特定列的函数列表，它可以计算所有相应的值，返回一个多级索引数据帧。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="868a" class="jt ju hh lm b fi lq lr l ls lt">new_data.groupby(['sex' , 'cp']).agg(max)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es na"><img src="../Images/fde63b9446e5833a262875a3939bfb4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fBo6nFQgDOYgmZ08eJG79Q.png"/></div></div></figure><p id="c4f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是使用agg()并传递一个函数来执行一些操作的最简单的方法，它将通过每一列传递该函数，并在dataframe中输出计算的值。但是等等，不也是像上个例子一样直接指定max()函数就行了吗，那我们为什么还需要agg()函数。</p><p id="8418" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就是agg()函数真正出彩的地方，它向我们展示了它的真正威力，在这里，您可以使用(key : value)对一次在整个数据集中执行不同的操作。在这个功能键中:value实际上是指(column : Function)相应地，</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="d38c" class="jt ju hh lm b fi lq lr l ls lt">new_data.groupby(['sex', 'cp']).agg({'age': max , 'trtbps' : np.mean})</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nb"><img src="../Images/5c3f9675af1df1fb5f6b6acad1454282.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*RJ1lZsqGYT8w9pj_aaRhsQ.png"/></div></div></figure><p id="9bc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，你可以看到我们能够同时为两个不同的列计算两个不同的值，你可以想象这在产生洞察力方面是多么强大。agg()函数接受一个字典或键值对列表来操作分组值。</p><p id="7892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以创建自己的dict或list，将不同的函数映射到不同的列，并简单地将它们传递给agg()函数，它将返回包含所有计算值的dataframe。</p><pre class="je jf jg jh fd ll lm ln lo aw lp bi"><span id="de0d" class="jt ju hh lm b fi lq lr l ls lt">agg_fucntion = {'age': [max , min , sum] , 'trtbps' : min}</span><span id="2a4c" class="jt ju hh lm b fi md lr l ls lt">new_data.groupby(['sex', 'cp']).agg(agg_fucntion)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es nc"><img src="../Images/8923a7092c2ffb9fdd86ef76b6527f84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*7MsNItkiGnwDrXpMlcbX0g.png"/></div></figure><p id="1435" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，我传递了一个要应用于列<em class="lz"> age </em>的函数列表，以及一个要应用于<em class="lz"> trtbps </em>的函数。产生的数据帧输出了预期的值，这一事实令人兴奋，它可以用于如此多的分析情况，并可以如此轻松地执行复杂的逻辑。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><h2 id="16a3" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">结论。</h2><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es nd"><img src="../Images/54a9e49bd2b74d191c82bdca0020e6d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JqUehXPRIL-uDGpP"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jc" href="https://unsplash.com/@alschim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Alexander Schimmeck </a>在<a class="ae jc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="402f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，是的，在Python中使用Pandas，你可以了解到所有最常用的特性和函数，这些特性和函数在你的EDA过程中肯定会用到。</p><ul class=""><li id="bbad" class="ko kp hh ig b ih ii il im ip mu it mv ix mw jb kv kw kx ky bi translated">我们讨论了如何使用不同的数据类型，以及如何根据需要处理它们或改变它们的数据类型。</li><li id="2365" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">使用melt()和pivot()函数重塑数据集。理解pivot和pivot_table在不同情况下的用法。</li><li id="b6ed" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">我们研究了如何以最佳方式使用groupby()和agg()函数，以及如何使这些函数中的大部分可供我们使用。</li><li id="b6c9" class="ko kp hh ig b ih kz il la ip lb it lc ix ld jb kv kw kx ky bi translated">当然还有很多事情要做，但是如果你有了如何使用它的概念和想法，以及这个函数最初是如何工作的，那么你就可以以多种方式使用它。</li></ul></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><p id="acd0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本系列的下一篇文章是使用Pandas的<strong class="ig hi"> <em class="lz">绘图和可视化</em> </strong>。</p><h2 id="3c7f" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">其他文章。</h2><ul class=""><li id="e29d" class="ko kp hh ig b ih kq il kr ip ks it kt ix ku jb kv kw kx ky bi translated"><a class="ae jc" href="https://datasciencestuff.medium.com/complete-guide-to-pandas-library-python-code-part-1-4-420cd5bd8249" rel="noopener">第1部分</a>和<a class="ae jc" href="https://datasciencestuff.medium.com/complete-guide-to-pandas-library-python-code-part-3-4-6bc11f9465d0" rel="noopener">第3部分</a>在此链接，如果您还没有查看，请务必查看。</li></ul></div></div>    
</body>
</html>