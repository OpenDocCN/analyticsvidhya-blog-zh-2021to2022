<html>
<head>
<title>Time Series Prediction (feat. Introduction of Julia)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">时间序列预测(专长。朱莉娅的介绍)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-prediction-feat-introduction-of-julia-78ed6897910c?source=collection_archive---------4-----------------------#2021-01-17">https://medium.com/analytics-vidhya/time-series-prediction-feat-introduction-of-julia-78ed6897910c?source=collection_archive---------4-----------------------#2021-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="826d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续我的<a class="ae jd" rel="noopener" href="/analytics-vidhya/use-correlation-to-predict-market-index-dc16136bd28c">上一篇文章</a>的工作，我将类似的ML模型应用于比特币ETF的预测。这一次，我将使用Julia而不是Python来编写模型代码。</p><h1 id="2a74" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">朱莉娅简介</h1><p id="f40b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated"><a class="ae jd" href="https://julialang.org" rel="noopener ugc nofollow" target="_blank"> Julia </a>是科学计算的另一种流行语言。与Python的动态类型相反，它是一种严格类型化的函数语言。虽然严格的类型化给编码带来了一些不便，但它带来了更快的计算速度。你可以通过执行从其<a class="ae jd" href="https://julialang.org/learning/getting-started/" rel="noopener ugc nofollow" target="_blank">页面</a>下载的安装程序来尝试安装Julia。</p><h1 id="a3e1" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">模型假设</h1><p id="ab03" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">假设比特币信托(<a class="ae jd" href="https://finance.yahoo.com/quote/GBTC/" rel="noopener ugc nofollow" target="_blank"> GBTC </a>)与比特币价格(BTC)和外汇汇率(FX)相关，我们可以用BTC的历史收益率和FX汇率来预测第二天GBTC的未来收益率。</p><h1 id="8f88" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据收集</h1><ol class=""><li id="47d1" class="kh ki hi ih b ii kc im kd iq kj iu kk iy kl jc km kn ko kp bi translated">BTC的历史数据可以通过API (bitdataset.com)进行检索。</li></ol><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="eb74" class="kz jf hi kv b fi la lb l lc ld"><a class="ae jd" href="http://api.bitdataset.com/v1/ohlcv/history/BITFINEX:BTCUSD?period=D1" rel="noopener ugc nofollow" target="_blank">http://api.bitdataset.com/v1/ohlcv/history/BITFINEX:BTCUSD</a></span></pre><p id="9986" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Julia提供了HTTP包来调用HTTP端点(API端点)。要使用这个包，只需要下面几行代码来获得json响应。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="a920" class="kz jf hi kv b fi la lb l lc ld">using HTTP<br/>using JSON</span><span id="ec6d" class="kz jf hi kv b fi le lb l lc ld">raw_response = HTTP.request("GET", url_query, headers)<br/>rsp = JSON.parse(String(raw_response.body))</span></pre><p id="7e38" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Julia还提供了数据结构——类似于Python熊猫家族的数据框架。从上面的json响应中检索到的每一行都可以插入到DataFrame中。“！”函数push意味着函数将更新变量df。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="04c2" class="kz jf hi kv b fi la lb l lc ld">using DataFrames</span><span id="42e8" class="kz jf hi kv b fi le lb l lc ld">df = DataFrame(high = Float32[],low = Float32[],open = Float32[],close = Float32[],volume = Float32[], time = String[])<br/>    <br/>for d in rsp<br/>    push!(df,d)<br/>end</span></pre><p id="7bff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.外汇的历史汇率可以通过API (exchangeratesapi.io)以类似的方式检索。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="11a8" class="kz jf hi kv b fi la lb l lc ld"><a class="ae jd" href="https://api.exchangeratesapi.io/history?start_at=" rel="noopener ugc nofollow" target="_blank">https://api.exchangeratesapi.io/history</a></span></pre><p id="3962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.GBTC的历史股票报价可以通过雅虎下载！Finanace API ( <a class="ae jd" href="https://pypi.org/project/yfinance/" rel="noopener ugc nofollow" target="_blank"> yfinance </a>)。既然是python包，我们就用Julia里的PyCall来调用python包。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="ca65" class="kz jf hi kv b fi la lb l lc ld">using PyCall<br/>yf = pyimport("yfinance")<br/>ticker = yf.Ticker("gbtc")<br/>etf = ticker.history(period="3y")</span></pre><p id="2b56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pycall方法(ticker.history)返回的对象“etf”是原始Python包中的DataFrame。Python数据帧可以转换成Julia数据帧。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="5f6f" class="kz jf hi kv b fi la lb l lc ld">function pd_to_df(df_pd)<br/>    df= DataFrame()<br/>    for col in df_pd.columns<br/>        df[!, col] = getproperty(df_pd, col).values<br/>    end<br/>    df[!,:Date] = collect(df_pd[:index])<br/>    return df<br/>end<br/>etf = pd_to_df(etf)</span></pre><h1 id="b1ef" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据帧</h1><p id="de21" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在Julia中，DataFrame的操作方式与Python类似。</p><ul class=""><li id="262e" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">在列上应用转换，这类似于Pandas DataFrame方法:Apply。下面是列“datestr”到日期对象的转换。的“.”函数后的“日期”意味着该函数应用于数组x的每个元素</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="3c22" class="kz jf hi kv b fi la lb l lc ld">transform!(df, :datestr =&gt; ( x -&gt; Date.(x, Dates.DateFormat("yyyy-mm-dd")) ) =&gt; :date)</span></pre><ul class=""><li id="a317" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">数据帧的读/写CSV文件很简单</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="e2c0" class="kz jf hi kv b fi la lb l lc ld">using CSV<br/>    <br/>rawdata = CSV.File(infile)<br/>rawdata = DataFrame(rawdata)<br/>CSV.write(infile, rawdata)</span></pre><ul class=""><li id="0251" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">通过innerjoin可以很容易地执行表连接，然后按列“日期”排序。结果被就地更新为“df”，如“！”所示排序后。</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="32de" class="kz jf hi kv b fi la lb l lc ld">df = innerjoin(df, etf, on = :date)<br/>sort!(df, [:date])</span></pre><ul class=""><li id="555b" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">数据透视表可以通过表连接构造，如下所示。这里我们需要将所有33个国家的外汇表(“日期”、“货币”、“汇率”)转换为数据透视表，每个国家的货币作为单独的列。</li></ul><ol class=""><li id="d7ff" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc km kn ko kp bi translated">使用包“DataFramesMeta”和“@linq”选择每种货币(“c”)的数据</li></ol><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="495b" class="kz jf hi kv b fi la lb l lc ld">using DataFramesMeta<br/>df1 = <a class="ae jd" href="http://twitter.com/linq" rel="noopener ugc nofollow" target="_blank">@linq</a> rawdata |&gt; where(:CUR .== c) |&gt; select(:ondate,:rate_mean)</span></pre><p id="879c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.将上面的输出与“on-date”列连接起来。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="978e" class="kz jf hi kv b fi la lb l lc ld">coldata = leftjoin(datecol,df1,on=:ondate)</span></pre><p id="21c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.将结果指定为货币“c”的列数据。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="125e" class="kz jf hi kv b fi la lb l lc ld">df[:,c] = coldata[:,:rate_mean]</span></pre><figure class="kq kr ks kt fd lk er es paragraph-image"><div class="er es lj"><img src="../Images/d6bb6ef9f794d19acd4acf56d0b08e12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*3hSG2xmUHJrKQ47cUyP_1Q.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">数据帧:“原始数据”</figcaption></figure><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="fe90" class="kz jf hi kv b fi la lb l lc ld">df = DataFrame()<br/>df.ondate = unique(rawdata.ondate)<br/>datecol = df<br/>for c in unique(rawdata.CUR)<br/>    df1=<a class="ae jd" href="http://twitter.com/linq" rel="noopener ugc nofollow" target="_blank">@linq</a> rawdata|&gt;where(:CUR .== c)|&gt;select(:ondate,:rate_mean)<br/>    coldata = leftjoin(datecol,df1,on=:ondate)<br/>    df[:,c] = coldata[:,:rate_mean]<br/>end</span></pre><p id="16e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以上是要转换为以下数据透视表的完整for循环。</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/4cbee99f7384e6a2829318e38b4cc590.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-pmNFVg0KzejpFDjKoy0g.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">旋转数据帧:“df”</figcaption></figure><ul class=""><li id="d8d8" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">最后，通过删除丢失数据的行来清理数据。</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="642c" class="kz jf hi kv b fi la lb l lc ld">dropmissing!(df)</span></pre><h1 id="0f21" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">特征工程</h1><ul class=""><li id="fae6" class="kh ki hi ih b ii kc im kd iq kj iu kk iy kl jc li kn ko kp bi translated">我使用Julia包时间序列从BTC和GBTC的外汇汇率和报价计算回报率。函数“percentchange”可以很容易地计算出当前值相对于滞后值的变化。</li><li id="3e7f" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">然后，对所有输入列应用PCA(33个国家的外汇汇率，以及BTC开盘价、收盘价、最高价、最低价及其每日交易量)。计算前3个PCA分量作为最终输入变量。</li><li id="e920" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">连接从时间<em class="mb"> i </em>到<em class="mb"> i+seqlen-1 </em> (pcax[:，i:i+seqlen-1])的3个PCA输出的当前和先前值</li><li id="0d69" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">预测目标是第二天的GBTC收盘价收益= <em class="mb"> i+seqlen </em> (df[i+seqlen，target])</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="7a06" class="kz jf hi kv b fi la lb l lc ld">ts = TimeArray(df,timestamp=:date)<br/>pct = percentchange(ts)<br/>df = DataFrame(pct)<br/>mx = transpose(convert(Matrix,df[:,features]))<br/>M = MultivariateStats.fit(PCA, mx; maxoutdim=3)<br/>pcax = MultivariateStats.transform(M, mx)<br/>for i in 1:len-seqlen-1<br/>        x = pcax[:,i:i+seqlen-1]<br/>        xtrain = vcat(xtrain,[x])<br/>        y = df[i+seqlen,target]<br/>        ytrain = vcat(ytrain,[y])<br/>end</span></pre><h1 id="5bdc" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">神经网络模型</h1><p id="d670" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们在递归层GRU上叠加卷积层。</p><p id="cb64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="http://julia flux example" rel="noopener ugc nofollow" target="_blank"> Flux </a>是茱莉亚给神经网络编码的ML包。</p><ul class=""><li id="b2fe" class="kh ki hi ih b ii ij im in iq lf iu lg iy lh jc li kn ko kp bi translated">由于卷积层的输入形状是4-D，我们需要使用unsqueeze添加2个维度。</li><li id="d419" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">经过2层conv/最大池，我们平坦的所有通道输出。</li><li id="ac69" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">然后，转置它，以便与GRU输入层匹配。</li><li id="6359" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">由于我只关心最后一个时间步的预测，我们将层(x -&gt; x[:end])添加到GRU层的输出中。</li><li id="fcb9" class="kh ki hi ih b ii lw im lx iq ly iu lz iy ma jc li kn ko kp bi translated">最后，我们添加密集层以获得最终预测。</li></ul><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="cd18" class="kz jf hi kv b fi la lb l lc ld">using Flux</span><span id="15c6" class="kz jf hi kv b fi le lb l lc ld">function build_model(Nh)<br/>    a = floor(Int8,Nh)<br/>    return Chain(<br/>    x -&gt; Flux.unsqueeze(Flux.unsqueeze(x,3),4),<br/>    <br/>    # First convolution<br/>    Conv((2, 2), 1=&gt;a, pad=(1,1), relu),<br/>    MaxPool((2,2)),</span><span id="01b4" class="kz jf hi kv b fi le lb l lc ld">    # Second convolution<br/>    Conv((2, 2), a=&gt;Nh, pad=(1,1), relu),<br/>    MaxPool((2,2)),</span><span id="6968" class="kz jf hi kv b fi le lb l lc ld">    Flux.flatten,<br/>    Dropout(0.1),<br/>    (x-&gt;transpose(x)),</span><span id="af58" class="kz jf hi kv b fi le lb l lc ld">    GRU(1,Nh),<br/>    GRU(Nh,Nh),</span><span id="ceda" class="kz jf hi kv b fi le lb l lc ld">    (x -&gt; x[:,end]),<br/>    Dense(Nh, 1),<br/>    (x -&gt; x[1]))<br/>end</span></pre><h1 id="e18e" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">培训结果</h1><p id="8619" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">按照以下方式训练模型“m ”:</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="afed" class="kz jf hi kv b fi la lb l lc ld">train_loader = Flux.Data.DataLoader(xtrain,ytrain, batchsize=batchsize,shuffle=false)</span><span id="3232" class="kz jf hi kv b fi le lb l lc ld">m = build_model(Nh)<br/>    <br/>function mae_loss(x,y)<br/>     yh = m.(x)<br/>     e = Flux.mae(yh,y)<br/>     return e<br/>end</span><span id="7ecd" class="kz jf hi kv b fi le lb l lc ld"><a class="ae jd" href="http://twitter.com/epochs" rel="noopener ugc nofollow" target="_blank">@epochs</a> num_epoch Flux.train!(mae_loss,Flux.params(m),train_loader,RMSProp(lr))</span></pre><p id="2806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">培训效果不好。这是预测值y1(红色)和训练数据y2(蓝色)的曲线图。预测值与实际值不符。</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/03da6bc8673c73d80ef97d374fe089a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9TednGFo_Zj1V1GK337Pg.png"/></div></div></figure><p id="1fc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以观察到实际值波动很大，这可能会导致梯度下降无法收敛。因此，我尝试使用移动平均来平滑数据。我计算了PCA降维前的10天移动平均线。我对输入变量和目标变量都应用了10天移动平均线。</p><pre class="kq kr ks kt fd ku kv kw kx aw ky bi"><span id="429b" class="kz jf hi kv b fi la lb l lc ld">pct = percentchange(ts)<br/>ma = moving(mean, pct, 10)</span></pre><p id="2e13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是使用移动平均后预测y1(红色)和训练数据y2(蓝色)的曲线图。预测可以很好地拟合实际线。答对了。</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/9b055fd99f0391512d42e92350088a65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EcV2EL-1GMjruU-aeFbemw.png"/></div></div></figure><h1 id="ff4a" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">用看不见的数据测试</h1><p id="a799" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我通过拿出最近250天的数据进行验证和测试来重新运行培训。结果还是不错的。</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mc"><img src="../Images/c6815ad95a0f1fff637a4be8f8ae1b78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgP5nupJIFDaYwRf9YpP3g.png"/></div></div></figure><h1 id="fe6b" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据泄露？</h1><p id="4106" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于担心移动平均计算中的数据泄漏导致结果的改善，我重新详细讨论了该计算。</p><p id="c28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，输入变量是从时间<em class="mb"> i </em>到<em class="mb"> i+seqlen-1 </em>的值。移动平均线取该值与前9天值的平均值。因此，它在时间<em class="mb"> i+seqlen </em>不会有未来值。虽然我也对目标变量进行移动平均，但是输入仍然不包含时间<em class="mb"> i+seqlen </em>的未来值。</p><p id="323c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了安全起见，我尝试在其他目标数据上运行相同的模型。如果好的结果是由数据泄漏而不是数据相关性引起的，那么我会对其他目标数据得到类似的结果。我尝试了股票:新加坡、2840.HK和GLD。SQ是与比特币相关的NASAQ股票。GLD和2840是美国市场和香港市场的黄金ETF。下面是训练数据的拟合。结果表明，即使使用移动平均法，相关性较小的目标数据也不能很好地拟合模型。</p><figure class="kq kr ks kt fd lk er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es md"><img src="../Images/0ea7ac3c3b69a7fb52ddb046520ad040.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4gRIRV1wO2_ddT_NzEJlRw.png"/></div></div></figure><h1 id="9933" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">评论朱莉娅</h1><p id="4dc8" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">虽然据称Julia在计算上非常快，但编译开销会使代码在第一次运行时变慢。当您使用“using <pkg>”命令导入包时，预编译需要一些时间。</pkg></p><p id="302c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">而且打字比较严格，不好用。尤其是DataFrame没有Python熊猫DataFrame好用。</p><p id="c3ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以在我的<a class="ae jd" href="https://github.com/iwasnothing/JuliaConvGRU" rel="noopener ugc nofollow" target="_blank"> git repo </a> ( <a class="ae jd" href="https://github.com/iwasnothing/JuliaConvGRU/blob/main/ConvGRU/src/ConvGRU.jl" rel="noopener ugc nofollow" target="_blank">模块文件</a> / <a class="ae jd" href="https://github.com/iwasnothing/JuliaConvGRU/blob/main/loading.ipynb" rel="noopener ugc nofollow" target="_blank">笔记本</a>)里查看完整的Julia代码。</p></div></div>    
</body>
</html>