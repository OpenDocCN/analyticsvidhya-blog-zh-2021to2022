<html>
<head>
<title>A brief overview of Stack in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中堆栈的简要概述</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-brief-overview-of-stack-in-python-41287f18ce20?source=collection_archive---------14-----------------------#2021-07-20">https://medium.com/analytics-vidhya/a-brief-overview-of-stack-in-python-41287f18ce20?source=collection_archive---------14-----------------------#2021-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dab9e60b5bd4974066c6d047fbeedcab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yRTMyhYCS4YOMstiWEqgJw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">贝基尔·登梅兹在<a class="ae it" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="49f0" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">堆</h1><p id="9b35" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">堆栈是根据后进先出(LIFO)原则插入和移除的对象的集合。</p><p id="9344" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">参考上面的图片和移除物体的确切原理。我们从顶部移除并在顶部插入，因此，后进先出。</p><p id="665b" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">栈上的主要操作</strong></p><ul class=""><li id="d8c7" class="kv kw hh ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">推送:将元素添加到堆栈中。</li><li id="5a71" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">从堆栈中删除最近添加的条目。</li><li id="d561" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">Peek:在不修改堆栈的情况下访问顶层元素。</li></ul><h1 id="2025" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用带有包装类的列表进行堆栈</h1><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3aa7" class="ls iv hh lo b fi lt lu l lv lw">class Stack():<br/>    <br/>    def __init__(self):<br/>        self.stack = list()<br/>        <br/>    def push(self, item):<br/>        self.stack.append(item)<br/>        <br/>    def pop(self):<br/>        if len(self.stack) &gt; 0:<br/>            return self.stack.pop()<br/>        else:<br/>            return None<br/>        <br/>    def peek(self):<br/>        if len(self.stack) &gt; 0:<br/>            return self.stack[len(self.stack)-1]<br/>        else:<br/>            return None<br/>        <br/>    def __str__(self):<br/>        return str(self.stack)</span></pre><h1 id="58b9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">运行代码:</h1><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3bec" class="ls iv hh lo b fi lt lu l lv lw"># creating stack object<br/>my_stack = Stack()<br/><br/><br/>my_stack.push(1)<br/>my_stack.push(2)<br/>my_stack.push(3)<br/>print('Complete stack as of now')<br/>print(my_stack)<br/><br/>print('\nStack after applying peek')<br/>print(my_stack.peek())<br/>print(my_stack)<br/><br/>print('\nStack after applying pop once')<br/>print(my_stack.pop())<br/>print(my_stack)<br/><br/><br/>print('\nStack after applying peek')<br/>print(my_stack.peek())<br/>print(my_stack)</span><span id="e81e" class="ls iv hh lo b fi lx lu l lv lw"># Results: *******************************************************</span><span id="c10b" class="ls iv hh lo b fi lx lu l lv lw">Complete stack as of now<br/>[1, 2, 3]<br/><br/>Stack after applying peek<br/>3<br/>[1, 2, 3]<br/><br/>Stack after applying pop once<br/>3<br/>[1, 2]<br/><br/>Stack after applying peek<br/>2<br/>[1, 2]</span></pre><h1 id="47a5" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">有趣的细节</h1><ul class=""><li id="d3ea" class="kv kw hh ju b jv jw jz ka kd ly kh lz kl ma kp la lb lc ld bi translated">推入和弹出操作只发生在结构的一端，称为堆栈的顶部。</li><li id="6961" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">这种数据结构使得将堆栈实现为一个<strong class="ju hi">单链表和一个指向顶层元素</strong>的指针成为可能。</li><li id="d54a" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">堆栈可以被实现为具有有限的容量。</li><li id="fe9b" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">如果堆栈已满，没有足够的空间来接受要推送的实体，则认为堆栈处于溢出状态。</li></ul><h2 id="f68b" class="ls iv hh bd iw mb mc md ja me mf mg je kd mh mi ji kh mj mk jm kl ml mm jq mn bi translated">为您做的事情:</h2><p id="9d02" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated"><strong class="ju hi">添加实现来检查堆栈是否为空，并返回其大小。</strong></p><h1 id="7a76" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">用例</h1><ul class=""><li id="d1f3" class="kv kw hh ju b jv jw jz ka kd ly kh lz kl ma kp la lb lc ld bi translated">堆栈用于实现深度优先搜索(回溯*)。</li><li id="3015" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">表达式可以用前缀、后缀或中缀来表示，从一种形式到另一种形式的转换可以使用堆栈来完成。</li><li id="e817" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">许多编译器使用堆栈来解析表达式、程序块等的语法。在翻译成低级代码之前。</li><li id="c028" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">最近邻链算法是一种基于维护簇堆栈的凝聚层次聚类方法，每个簇都是堆栈上其前一个簇的最近邻。</li></ul><p id="e6a4" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">既然您已经熟悉了堆栈的概念，那么请访问<a class="ae it" href="https://leetcode.com/tag/stack/" rel="noopener ugc nofollow" target="_blank"> Leet code </a>来练习一些现实生活中的问题，并使用本概述中总结的思想来解决它们。万事如意！</p><p id="6ef7" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">特别感谢Wikipedia*和python文档*提供了宝贵的信息，我在本文中使用了这些信息来概括这个至关重要的概念。</p><h2 id="a640" class="ls iv hh bd iw mb mc md ja me mf mg je kd mh mi ji kh mj mk jm kl ml mm jq mn bi translated">谢谢你看我的帖子。我希望你学到了一些有用的东西*🙌 🎉</h2></div></div>    
</body>
</html>