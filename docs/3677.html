<html>
<head>
<title>Window Functions Deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">窗口功能深度潜水</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/window-functions-deep-dive-4aeffebf81e1?source=collection_archive---------6-----------------------#2021-07-17">https://medium.com/analytics-vidhya/window-functions-deep-dive-4aeffebf81e1?source=collection_archive---------6-----------------------#2021-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9bfe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我在《火花深潜》中的一个故事</p><h1 id="de8f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><a class="ae ka" rel="noopener" href="/@somanathsankaran">https://medium.com/@somanathsankaran</a></h1><p id="5fb6" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在这篇博客中，我们将看到窗口函数如何拯救各种分析用例。</p><p id="0106" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我仍然记得当我启动窗口函数的时候，我只记得它被用于行号排序。</p><p id="2ece" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博客中，我将尝试提供一些我们可以利用窗口功能的用例</p><ol class=""><li id="1110" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated">删除重复项</li><li id="972a" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">基于优先级的拣选</li><li id="6135" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">部分选择</li><li id="adfe" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated">Excel拖动相似功能</li></ol><p id="48c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:这不是对窗口函数的介绍，有很多相关的资料。</p><h2 id="3d43" class="ku jd hh bd je kv kw kx ji ky kz la jm ip lb lc jq it ld le ju ix lf lg jy lh bi translated">窗口功能关键组件</h2><p id="00b3" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在编写任何窗口函数之前，我们需要记住下面的逻辑</p><blockquote class="li lj lk"><p id="79d2" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi">函数over (partition by group子句order by子句)</strong></p></blockquote><p id="ba8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数→最小值、最大行数等函数</p><p id="5825" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分区依据→数据分组所依据的字段</p><p id="c114" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">order by →选择组中的最新值</p><h2 id="e975" class="ku jd hh bd je kv kw kx ji ky kz la jm ip lb lc jq it ld le ju ix lf lg jy lh bi translated">删除重复项</h2><p id="6927" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">让我们考虑下面的数据。</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div class="er es lp"><img src="../Images/b00f735ff67db79fc4f5902444ae86e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:490/format:webp/1*E2brpM3ulTASRYMtveznuA.png"/></div></figure><p id="6845" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">获取id的最新记录是最常见的用例。</p><p id="0495" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有几个选项可用，如<a class="ae ka" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.functions.rank.html#pyspark-sql-functions-rank" rel="noopener ugc nofollow" target="_blank">等级</a>、<a class="ae ka" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.functions.rank.html#pyspark-sql-functions-rank" rel="noopener ugc nofollow" target="_blank">密集_等级</a>、<a class="ae ka" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.sql.functions.rank.html#pyspark-sql-functions-rank" rel="noopener ugc nofollow" target="_blank">行_编号</a></p><blockquote class="li lj lk"><p id="7ae2" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi">但是最适合的是行号，因为在其他函数的情况下，如果我们在order by子句中获得相同的值，则两者都将被赋予相同的值</strong></p></blockquote><p id="a867" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参照我们的上述标准</p><p id="a436" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数→行数</p><p id="62ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">partition by →id(因为我们需要为每个id选取1行)</p><p id="6d60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">订购依据→(自_年_月_日起，desc，因为我们需要获取最新数据)</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lx"><img src="../Images/2f8dbce195e01969b02816999b80b781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fHGElvdOAuucZP8ncpuKgw.png"/></div></div><figcaption class="mc md et er es me mf bd b be z dx translated">我们看到两个行的rank和dense rank都返回1，因为按年份排序是相同的(2021年)。大多数情况下，人们错误地认为第二条记录会发生跳跃(即2020年分配3，dense rank分配2)</figcaption></figure><p id="5f84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终查询:</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mg"><img src="../Images/4e41120b0b06a4fe6ccc29e4f293a90a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkmYSvEnx3L1z_Hr8NFyug.png"/></div></div></figure><h2 id="6bbb" class="ku jd hh bd je kv kw kx ji ky kz la jm ip lb lc jq it ld le ju ix lf lg jy lh bi translated">基于优先级的拣选</h2><p id="b07c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">下一个挑战是当我们拾取相同的数据而不是最新的数据时，我们可能需要优先考虑某个字段。例如，对于这个数据，我们假设如果钦奈可用，我们必须接钦奈，即使它不是最新的。如果我们在同一个城市中有多行，那么“截止年份”应该是最小的一行，因为我们需要知道此人居住在钦奈的时间</p><p id="c3cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参照我们的上述标准</p><p id="ab2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数→行数</p><p id="7e50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">partition by →id(因为我们需要为每个id选取1行)</p><p id="84b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">order by→我们使用case语句在order by子句中指定优先级，也按年份排序，因为我们需要知道一个人从什么时候开始生活</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div class="er es mh"><img src="../Images/3c7551f9af73493f99601327d19a8e68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Pycai4H4eCQsYC3LO3jSQg.png"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">我们使用case语句按优先级排序，如上所示</figcaption></figure><p id="6f33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终查询:</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div class="er es mi"><img src="../Images/3ffbb486be8e8d7ec8155a876a9f0fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*iUFTP6Ul4c0j9AQhVXLjdg.png"/></div></figure><p id="a785" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.部分选择</p><p id="8591" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑下面的场景</p><p id="3f66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们假设我们需要得到城市生活(即我们需要创建列2021 _城市生活，2020 _城市生活的每个id)</p><p id="bcf6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参照我们的上述标准</p><p id="7482" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">function →concat_ws("，"，collect_Set(city)因为我们需要得到2020年、2021年居住的所有城市</p><p id="c844" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">partition by →id(因为我们需要为每个id选取1行)</p><p id="d1d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">order by→不需要</p><p id="6f1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们只需要考虑2020年为020个城市居住的年份</p><blockquote class="li lj lk"><p id="3496" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi">我们将通过使用case </strong>将其他行转换为null来创造奇迹</p></blockquote><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mj"><img src="../Images/2b678d5846b22b50bb06ea898019183f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YEXOLLT5qVqu2ai1l-UN0A.png"/></div></div></figure><blockquote class="li lj lk"><p id="b9dc" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">df.selectExpr("* "，" concat_ws('，')，collect_set( <strong class="ig hi"> case当as _ of _ yr = 2020 then city else null end)over(partition by id)</strong>)as 2020 _ cities _ lived "<br/>，" concat_ws('，'，collect_set(case当as _ of _ yr = 2021 then city else null end))over(partition by id)as 2021 _ cities _ lived "，<br/>)。显示()</p><p id="4975" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi">这里的关键是带有null的case语句，它会将不需要的行with转换为null。例如，当我们需要2020年的列表时，id 1在2021年居住的德里被跳过</strong></p></blockquote><h2 id="0025" class="ku jd hh bd je kv kw kx ji ky kz la jm ip lb lc jq it ld le ju ix lf lg jy lh bi translated"><strong class="ak"> Excel拖动类似功能</strong></h2><blockquote class="li lj lk"><p id="9c7e" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">最后一个用例是当我们可能需要用以前的可用数据填充空白数据时，类似于excel拖动加号图标。</p></blockquote><p id="c07e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们考虑下面的数据</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div class="er es mk"><img src="../Images/eae72475a2608cf7a397aa99c6387e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*vvV2NMM9itlzhsfb_tS0Sg.png"/></div></figure><p id="de4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，由于我们不知道2020年的id居住地，我们可以使用2019年的数据进行ffill或使用2021年的数据进行回填。</p><p id="103d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参照我们的上述标准</p><p id="667f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">partition by →id(因为我们需要为每个id选取1行)</p><p id="cf7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">order by →asc因为我们要回填2019年的数据</p><p id="64d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">函数→最后一个值，将选取组中最后一个有效值(2019年到2021年的数据)</p><p id="474d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">步骤2:因为我们需要填充NA行的最后一个值。</p><p id="28dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要将Na行转换为null(这样做的原因将在后面讨论)</p><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es ml"><img src="../Images/f819358820beb33fa538470de92e0e25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtBt0IiAo0gy61JRQmK8XA.png"/></div></div></figure><blockquote class="li lj lk"><p id="bd5c" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">第三步:我们将把partition by与未绑定的前一行和当前行之间的行结合起来，这将限制我们选择的行</p><p id="c27e" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">前无界后无界—填写所有行</em> </strong></p><p id="5b43" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">未绑定的前一行和当前行—从组</em> </strong>中的所有前一行到当前行进行检查</p><p id="7284" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">当前行和无界后续——从当前行检查到组</em> </strong>下面的所有行</p></blockquote><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mm"><img src="../Images/b77fa24b09c11ebcefe1274719db4657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mvx8cHMB8F4DbuaFFPGXuw.png"/></div></div></figure><p id="a60c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们只使用最后一个值和当前行之前的所有行，我们知道最后一个值是行的相应值。这里的技巧是让ignore null变为true</p><p id="1fd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将获得最后一个非空值并解决我们的问题</p><blockquote class="li lj lk"><p id="6357" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated"><strong class="ig hi">这就是我们将NA或垃圾值改为null的原因</strong></p></blockquote><figure class="lq lr ls lt fd lu er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mn"><img src="../Images/367d9cbd1758af4134e31dac1a6ec080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jneqVdm4y_jB-p_GLOZgg.png"/></div></div></figure><p id="21b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天就到这里吧！！快乐阅读</p><p id="2d2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">学习并让别人学习干杯！！</p><p id="fc72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="ll">请把我在spark中必须涉及的话题发给我，并给我提供改进写作的建议:)</em> </strong></p></div></div>    
</body>
</html>