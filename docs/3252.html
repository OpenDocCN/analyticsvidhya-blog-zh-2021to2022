<html>
<head>
<title>NLP — Getting started with Sentiment Analysis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NLP —情感分析入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/nlp-getting-started-with-sentiment-analysis-126fcd61cc4a?source=collection_archive---------1-----------------------#2021-06-21">https://medium.com/analytics-vidhya/nlp-getting-started-with-sentiment-analysis-126fcd61cc4a?source=collection_archive---------1-----------------------#2021-06-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/d17ad66bc7599c6569a3ff865295ca1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N0tViJGkxRYkyQlq3PV4mw.jpeg"/></div></div></figure><h2 id="0c1b" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">情感分析</h2><p id="f429" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">顾名思义，它的意思是识别一种情况背后的观点或情绪。它的基本意思是分析和发现一篇文章或一段讲话或任何交流方式背后的情感或意图。</p><p id="0585" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">在本文中，我们将重点研究文本数据的情感分析。</p><p id="8992" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们人类用各种各样的语言相互交流，任何语言都只是我们试图表达自己的一种媒介或方式。无论我们说什么或写什么，都有与之相关的情感。它可能是积极的或消极的，也可能是中性的。</p><h2 id="b0f6" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们举个例子——</h2><p id="2317" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">假设有一家快餐连锁公司，他们出售各种不同的食品，如汉堡、比萨饼、三明治、奶昔等。他们创建了一个网站来销售他们的食品，现在顾客可以从他们的网站上订购任何食品。网站上有一个选项，让顾客提供反馈或评论，比如他们是否喜欢这些食物。</p><p id="f20a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">用户评论1:我喜欢这个奶酪三明治，太好吃了。<br/>网友评论2:这个鸡肉汉堡味道非常不好。<br/>用户评论3:我今天点了这个披萨。</p><p id="186a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因此，正如我们看到的，在以上三篇评论中，</p><ol class=""><li id="4bf2" class="kp kq hi jq b jr kj jv kk jb kr jf ks jj kt ki ku kv kw kx bi translated">第一次评价肯定是积极的，这表明顾客对三明治非常满意。</li><li id="d7d0" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated">第二次审查是否定的，因此公司需要调查他们的汉堡部门。</li><li id="68f3" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated">第三个问题并不意味着客户是否满意，因此我们可以将此视为中性陈述。</li></ol><p id="512c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">通过查看上面的评论，该公司现在可以得出结论，如果他们想增加整体销售额，他们需要更多地关注三明治的生产和推广，并提高汉堡的质量。</p><p id="76d0" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">但是，现在出现了一个问题，他们的产品会有成千上万的用户评论，一段时间后，几乎不可能浏览每一个用户评论并得出结论。</p><p id="0d52" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">他们也不能仅凭100条左右的评论就得出结论，因为也许前100-200名顾客有相似的口味，因此他们喜欢三明治。</p><p id="b765" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">但随着时间的推移，当评论数量增加时，可能会出现正面评论被更多负面评论所取代的情况。</p><p id="5fee" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">所以这就是情感分析和机器学习发挥作用的地方，让整个过程无缝衔接。用于情感分析的ML模型接受具有用户评论的大量数据，然后找到一种模式，并基于真实证据而不是基于小样本数据的假设得出结论。</p><p id="42ec" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们知道我们有三种主要的情绪与每个句子相关。但是，我们甚至可以将这些主要情绪(积极的、消极的和中性的)分解成更小的次级情绪，比如“快乐”、“爱”、“惊喜”、“悲伤”、“恐惧”、“愤怒”等等。根据需要或业务要求。</p><h2 id="935f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">让我们举一个真实的例子——</h2><ol class=""><li id="2866" class="kp kq hi jq b jr js jv jw jb ld jf le jj lf ki ku kv kw kx bi translated">曾经有一段时间，像脸书这样的社交媒体服务对每个帖子只有两种情绪，也就是说，你可以喜欢一个帖子，或者你可以毫无反应地离开帖子，这意味着你不喜欢它。</li><li id="ded1" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated">但是，随着时间的推移，这些对帖子的反应已经发生了变化，并成长为我们现在看到的更具体的情感，如“喜欢”、“爱”、“悲伤”、“愤怒”等。</li></ol><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lg"><img src="../Images/a7fb23bcf034c2e2696c4aa724bd9b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-H4_5S69Ei-98QMjwWLM_Q.png"/></div></div></figure><p id="d744" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">由于这一升级，当任何公司在脸书上推广其产品时，他们都会收到更具体的评论，这反过来有助于他们改善客户体验。</p><p id="32bf" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">正因为如此，他们现在对如何对待他们的消费者有了更细致的控制，即他们可以以不同于“愤怒”的客户的方式瞄准“悲伤”的客户，并相应地提出商业计划，因为现在，仅仅做最少的<strong class="jq hj">是不够的</strong>。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ll"><img src="../Images/7a044c852dd670bb8e51ac0003e21a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*33laj-fm5LMT_2vBaW8Tug.jpeg"/></div></div></figure><p id="d23e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将创建一个情感分析模型，但是说起来容易做起来难。</p><p id="eef1" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因为我们人类用自然语言相互交流，这对于我们来说很容易理解，但如果我们真的去研究它，它会变得更加复杂和混乱。</p><p id="f55a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因为有几十亿人，他们有自己的交流方式，也就是说，语言中加入了许多微小的变化，并附加了许多情感，这对我们来说很容易理解，但对机器来说却是一个挑战。例如，我们大多数人在句子中使用讽刺，这只是说了与事实相反的话。</p><p id="dfee" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因此，机器学习模型很难理解这种情绪。</p><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lm"><img src="../Images/438605f6c203fc2ef20f708b6e42cd7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uB9byyqtYQEzTB2flT_9Cg.jpeg"/></div></div></figure><p id="2ebe" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">这就是为什么我们需要一个过程，让计算机像我们人类一样理解自然语言，这就是我们所说的自然语言处理(NLP)。</p><p id="9986" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">情感分析是NLP的一个子领域，在机器学习技术的帮助下，它试图从数据中识别和提取洞察力。</p><p id="f322" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，让我们通过实现情感分析来尝试一下，它将预测给定语句的情感。</p><h2 id="d5ed" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">首先，让我们导入我们将在整个程序中使用的所有python库。</h2><h2 id="e2a5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">基本Python库</h2><ol class=""><li id="9420" class="kp kq hi jq b jr js jv jw jb ld jf le jj lf ki ku kv kw kx bi translated"><strong class="jq hj">熊猫</strong>——用于数据分析和数据处理。</li><li id="52f4" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> Matplotlib </strong> —用于数据可视化。</li><li id="78d3" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> Seaborn </strong> —它基于matplotlib，为数据可视化提供了一个高级接口。</li><li id="a927" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> WordCloud </strong> —用于以云的形式可视化文本数据。</li><li id="a93c" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> re </strong> —提供根据给定的正则表达式预处理字符串的函数。</li></ol><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="80b4" class="iq ir hi lo b fi ls lt l lu lv">import pandas as pd<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from wordcloud import WordCloud<br/>import re</span></pre><h2 id="5f62" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">自然语言处理</h2><ol class=""><li id="8d3c" class="kp kq hi jq b jr js jv jw jb ld jf le jj lf ki ku kv kw kx bi translated"><strong class="jq hj"> nltk </strong> —自然语言工具包是一个用于自然语言处理的库集合。</li><li id="de84" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">停用词</strong> —对句子没有任何意义的单词集合。</li><li id="10fd" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> WordNetLemmatizer </strong> —它用于将不同形式的单词转换成一个条目，但仍然保持上下文完整。</li></ol><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="309f" class="iq ir hi lo b fi ls lt l lu lv">import nltk<br/>from nltk.corpus import stopwords<br/>from nltk.stem import WordNetLemmatizer</span></pre><h2 id="1361" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">sci kit-Learn(Python的机器学习库)</h2><ol class=""><li id="f667" class="kp kq hi jq b jr js jv jw jb ld jf le jj lf ki ku kv kw kx bi translated"><strong class="jq hj">计数矢量器</strong> —用于将文本转换成矢量。</li><li id="81cf" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> GridSearchCV </strong> —用于ML模型的超参数调整。</li><li id="0a3f" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">RandomForestClassifier</strong>—用于分类的机器学习算法。</li></ol><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="2fbe" class="iq ir hi lo b fi ls lt l lu lv">from sklearn.feature_extraction.text import CountVectorizer<br/>from sklearn.model_selection import GridSearchCV<br/>from sklearn.ensemble import RandomForestClassifier</span></pre><h2 id="51b7" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">评估指标</h2><ol class=""><li id="fa85" class="kp kq hi jq b jr js jv jw jb ld jf le jj lf ki ku kv kw kx bi translated"><strong class="jq hj">准确度分数</strong> —正确分类的实例数/实例总数。</li><li id="46ef" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">精度分数</strong>—它是正确预测的实例与总阳性实例的比率。</li><li id="0ee5" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">召回分数</strong> —它是正确预测的实例与该类中所有实例的比率。</li><li id="cffc" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> Roc曲线</strong>——真阳性率对假阳性率的曲线图。</li><li id="b4ca" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">分类报告</strong> —准确率、召回率和f1评分报告。</li><li id="bfd5" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">混淆矩阵</strong> —用于描述分类模型的表格。</li></ol><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="14ae" class="iq ir hi lo b fi ls lt l lu lv">from sklearn.metrics import accuracy_score,precision_score,recall_score,confusion_matrix,roc_curve,classification_report<br/>from scikitplot.metrics import plot_confusion_matrix</span></pre><p id="8e27" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们将使用<a class="ae lw" href="https://www.kaggle.com/praveengovi/emotions-dataset-for-nlp" rel="noopener ugc nofollow" target="_blank">这个</a>数据集，可以在Kaggle上获得，用于情感分析，它由句子及其各自的情感组成，作为目标变量。该数据集包含3个单独的文件，分别名为train.txt、test.txt和val.txt。</p><p id="3a01" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将读取训练数据和验证数据。由于数据是文本格式，用分号分隔，没有列名，我们将创建数据帧，用read_csv()和参数分别作为“分隔符”和“名称”。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="b763" class="iq ir hi lo b fi ls lt l lu lv">df_train = pd.read_csv("train.txt", delimiter=';',names=['text','label'])<br/>df_val = pd.read_csv("val.txt", delimiter=';',names=['text','label'])</span></pre><p id="d044" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因为我们将使用交叉验证，并且我们也有单独的测试数据集，所以我们不需要单独的验证数据集。因此，我们将连接这两个数据帧，然后我们将重置索引以避免重复索引。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="8642" class="iq ir hi lo b fi ls lt l lu lv">df = pd.concat([df_train,df_val])<br/>df.reset_index(inplace=True, drop=True)</span></pre><p id="d9ab" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们可以使用pandas的“sample”方法查看数据集内容的样本，并使用“shape”方法检查维度。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="5b93" class="iq ir hi lo b fi ls lt l lu lv">print("Shape of the DataFrame:", df.shape)<br/>df.sample(5)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lx"><img src="../Images/a205a7973f1dae850e32482cfb316a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jXoeBz4ZD1IdOKtz3Ry7og.png"/></div></div></figure><p id="5d7a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将使用seaborn检查数据集中的各种目标标签。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="2c9e" class="iq ir hi lo b fi ls lt l lu lv">sns.countplot(df.label)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ly"><img src="../Images/923ae157c13914135ecd08dd5b4a1de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f1nmfla3teHxKSzQNBpuIA.png"/></div></div></figure><p id="b356" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">正如我们可以看到的，我们在数据集中有6个标签或目标。我们可以做一个多类分类器用于情感分析。但是，为了简单起见，我们将把这些标签合并成两类，即积极情绪和消极情绪。</p><ol class=""><li id="630e" class="kp kq hi jq b jr kj jv kk jb kr jf ks jj kt ki ku kv kw kx bi translated"><em class="ko">积极情绪——“喜悦”、“爱”、“惊喜”</em></li><li id="dd53" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><em class="ko">消极情绪——“愤怒”、“悲伤”、“恐惧”</em></li></ol><p id="4026" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将创建一个自定义编码器，将分类目标标签转换为数字形式，即(0和1)。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="c143" class="iq ir hi lo b fi ls lt l lu lv">def custom_encoder(df):<br/>    df.replace(to_replace ="surprise", value =1, inplace=True)<br/>    df.replace(to_replace ="love", value =1, inplace=True)<br/>    df.replace(to_replace ="joy", value =1, inplace=True)<br/>    df.replace(to_replace ="fear", value =0, inplace=True)<br/>    df.replace(to_replace ="anger", value =0, inplace=True)<br/>    df.replace(to_replace ="sadness", value =0, inplace=True)</span><span id="1616" class="iq ir hi lo b fi lz lt l lu lv">custom_encoder(df['label'])</span><span id="2871" class="iq ir hi lo b fi lz lt l lu lv">sns.countplot(df.label)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ma"><img src="../Images/7295fbeb916fc6060ef1593583facaf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*srFF2rhQB8FVDy-Dcpux1A.png"/></div></div></figure><p id="a2ad" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们可以看到我们的目标变成了0和1，即0表示负，1表示正，数据或多或少处于平衡状态。</p><h2 id="1dd5" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">数据预处理</h2><p id="accb" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在，我们将对数据进行一些预处理，然后将其转换为向量，并传递给机器学习模型。</p><p id="11f3" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们将创建一个数据预处理功能。</p><ol class=""><li id="c23c" class="kp kq hi jq b jr kj jv kk jb kr jf ks jj kt ki ku kv kw kx bi translated">首先，我们将遍历每条记录，通过使用<strong class="jq hj">正则表达式</strong>，我们将去掉除字母之外的任何字符。</li><li id="66c4" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated">然后，我们将把字符串转换成小写的<strong class="jq hj"/>，因为单词<strong class="jq hj">【好】</strong>不同于单词<strong class="jq hj">【好】</strong>。</li></ol><p id="6729" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><em class="ko">注意——因为，如果我们不将字符串转换成小写，当我们创建这些单词的向量时，会导致一个问题，因为将为同一个单词创建两个不同的向量，这是我们不想要的。</em></p><p id="5739" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">3.然后，我们将检查数据中的停用词并删除它们。</p><p id="b73c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">术语预警</strong> — <strong class="jq hj"> <em class="ko">停用词</em> </strong> <em class="ko">是句子中的常用词，如“the”、“an”、“to”等。这并没有增加多少价值。</em></p><p id="7eee" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">4.然后，我们将对每个单词执行<strong class="jq hj">词条化</strong>，即将一个单词的不同形式转换为一个词条，称为词条。</p><p id="7312" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">术语提醒</strong> — <em class="ko">一个</em> <strong class="jq hj"> <em class="ko">词条</em> </strong> <em class="ko">是一个词的基本形式。例如，“跑”、“奔跑”和“奔跑”都是同一个词位的形式，其中“奔跑”是引理。因此，我们把所有出现的同一个词位转换成它们各自的引理。</em></p><p id="b0de" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">5.然后，我们将返回一个经过处理的数据语料库。</p><p id="845e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因此，首先，我们将创建一个WordNetLemmatizer对象，然后我们将执行转换。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="412c" class="iq ir hi lo b fi ls lt l lu lv">#object of WordNetLemmatizer<br/>lm = WordNetLemmatizer()</span><span id="fd06" class="iq ir hi lo b fi lz lt l lu lv">def text_transformation(df_col):<br/>    corpus = []<br/>    for item in df_col:<br/>        new_item = re.sub('[^a-zA-Z]',' ',str(item))<br/>        new_item = new_item.lower()<br/>        new_item = new_item.split()<br/>        new_item = [lm.lemmatize(word) for word in new_item if word not in set(stopwords.words('english'))]<br/>        corpus.append(' '.join(str(x) for x in new_item))<br/>    return corpus</span><span id="1c31" class="iq ir hi lo b fi lz lt l lu lv">corpus = text_transformation(df['text'])</span></pre><p id="8c85" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将创建一个<strong class="jq hj">字云</strong>。</p><p id="f3bb" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">术语提醒</strong>—<strong class="jq hj"><em class="ko">word cloud</em></strong><em class="ko">是一种数据可视化技术，用于以这样一种方式描述文本，即与不太频繁的单词相比，更频繁的单词看起来更大。这让我们对数据经过所有步骤处理后的样子有了一点了解。</em></p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="7de7" class="iq ir hi lo b fi ls lt l lu lv">rcParams['figure.figsize'] = 20,8<br/>word_cloud = ""<br/>for row in corpus:<br/>    for word in row:<br/>        word_cloud+=" ".join(word)<br/>wordcloud = WordCloud(width = 1000, height = 500,background_color ='white',min_font_size = 10).generate(word_cloud)<br/>plt.imshow(wordcloud)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/924d067f440dec282c103d285828f289.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qoJeiINZsv9NEJpo97KtKg.png"/></div></div></figure><h2 id="5126" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">一袋单词</h2><p id="a34d" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在，我们将使用单词袋模型(BOW)，它用于以单词袋的形式表示文本，即语法和句子中单词的顺序不被赋予任何重要性，相反，多重性，即(单词在文档中出现的次数)是主要关注点。</p><p id="ab80" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">基本上，它描述了单词在文档中的总出现次数。</p><p id="e648" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj"> Scikit-Learn </strong>提供了一种使用<strong class="jq hj">计数矢量器</strong>执行单词包技术的简洁方法。</p><p id="883d" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">因此，我们将通过拟合和转换我们创建的语料库，将文本数据转换为向量。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="752a" class="iq ir hi lo b fi ls lt l lu lv">cv = CountVectorizer(ngram_range=(1,2))<br/>traindata = cv.fit_transform(corpus)<br/>X = traindata<br/>y = df.label</span></pre><p id="91a5" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们将<strong class="jq hj"> ngram_range </strong>作为(1，2 ),表示二元模型。</p><p id="a368" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj">术语提醒— <em class="ko"> Ngram </em> </strong> <em class="ko">是一行或一个句子中“n”个单词的序列。“ngram_range”是一个参数，我们使用它来赋予单词组合以重要性。</em></p><p id="f8f8" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><em class="ko">例如，单词“</em> <strong class="jq hj"> <em class="ko">【社交媒体】</em> </strong> <em class="ko">”放在一起与单词“</em> <strong class="jq hj"> <em class="ko">【社交</em> </strong> <em class="ko">”和“</em> <strong class="jq hj"> <em class="ko">媒体</em> </strong> <em class="ko">”分开具有不同的含义。</em></p><p id="629c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们可以试验<strong class="jq hj"> ngram_range </strong>参数的值，并选择给出更好结果的选项。</p><h2 id="ac28" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">模型创建</h2><p id="c94c" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在是机器学习模型创建部分，在这个项目中，我将使用<strong class="jq hj">随机森林分类器</strong>，我们将使用GridSearchCV调整超参数。</p><p id="0f81" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated"><strong class="jq hj"> GridSearchCV </strong>()用于根据预定义超参数的所有可能组合来拟合我们对训练数据的估计，我们将向其提供信息并为我们提供最佳模型。</p><p id="067f" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们将向GridSearchCV提供以下参数，</p><ol class=""><li id="aad6" class="kp kq hi jq b jr kj jv kk jb kr jf ks jj kt ki ku kv kw kx bi translated"><strong class="jq hj">估计器或模型</strong> —在我们的例子中是RandomForestClassifier。</li><li id="1108" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj">参数</strong> —超参数名称及其值的字典。</li><li id="0d27" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> cv </strong> —表示交叉验证折叠。</li><li id="e95e" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> return_train_score </strong> —返回各种模型的训练分数。</li><li id="a612" class="kp kq hi jq b jr ky jv kz jb la jf lb jj lc ki ku kv kw kx bi translated"><strong class="jq hj"> n_jobs </strong> —表示并行运行的作业数量(“-1”表示将使用所有CPU内核，这大大减少了训练时间)</li></ol><p id="f076" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">首先，我们将创建一个字典“parameters”，它将包含不同超参数的值。</p><p id="c79e" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">我们将把它作为一个参数传递给GridSearchCV，使用这些参数的所有可能组合来训练我们的随机森林分类器模型，以找到最佳模型。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="aefe" class="iq ir hi lo b fi ls lt l lu lv">parameters = {'max_features': ('auto','sqrt'),<br/>             'n_estimators': [500, 1000, 1500],<br/>             'max_depth': [5, 10, None],<br/>             'min_samples_split': [5, 10, 15],<br/>             'min_samples_leaf': [1, 2, 5, 10],<br/>             'bootstrap': [True, False]}</span></pre><p id="bff4" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将数据放入网格搜索中，并使用GridSearchCV的“<strong class="jq hj"> best_params_ </strong>”属性查看最佳参数。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="078d" class="iq ir hi lo b fi ls lt l lu lv">grid_search = GridSearchCV(RandomForestClassifier(),parameters,cv=5,return_train_score=True,n_jobs=-1)<br/>grid_search.fit(X,y)<br/>grid_search.best_params_</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/dfd6be09a6aa63737aee64bc8eee894d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85LPTpXBdPtcF9RCtulHaA.png"/></div></div></figure><p id="bce2" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">然后，我们可以查看所有模型及其各自的参数，平均测试分数和等级，因为GridSearchCV将所有中间结果存储在<strong class="jq hj"> cv_results_ </strong>属性中。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="19e5" class="iq ir hi lo b fi ls lt l lu lv">for i in range(432):<br/>    print('Parameters: ',grid_search.cv_results_['params'][i])<br/>    print('Mean Test Score: ',grid_search.cv_results_['mean_test_score'][i])<br/>    print('Rank: ',grid_search.cv_results_['rank_test_score'][i])</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/dddd4f1267b0cbc0025089fae35dfb35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3_LbUOTe_S4iNWt7iXvkJQ.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">输出的样本</figcaption></figure><p id="7e37" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们将选择从GridSearchCV获得的最佳参数，并创建最终的随机森林分类器模型，然后训练我们的新模型。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="0daf" class="iq ir hi lo b fi ls lt l lu lv">rfc = RandomForestClassifier(max_features=grid_search.best_params_['max_features'],<br/>                                      max_depth=grid_search.best_params_['max_depth'],<br/>                                      n_estimators=grid_search.best_params_['n_estimators'],<br/>                                      min_samples_split=grid_search.best_params_['min_samples_split'],<br/>                                      min_samples_leaf=grid_search.best_params_['min_samples_leaf'],<br/>                                      bootstrap=grid_search.best_params_['bootstrap'])<br/>rfc.fit(X,y)</span></pre><h2 id="4962" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">测试数据转换</h2><p id="7af4" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">现在，我们将读取测试数据，并执行与训练数据相同的转换，最后根据预测评估模型。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="ec6e" class="iq ir hi lo b fi ls lt l lu lv">test_df = pd.read_csv('test.txt',delimiter=';',names=['text','label'])</span><span id="b4e6" class="iq ir hi lo b fi lz lt l lu lv">X_test,y_test = test_df.text,test_df.label<br/>#encode the labels into two classes , 0 and 1<br/>test_df = custom_encoder(y_test)<br/>#pre-processing of text<br/>test_corpus = text_transformation(X_test)<br/>#convert text data into vectors<br/>testdata = cv.transform(test_corpus)<br/>#predict the target<br/>predictions = rfc.predict(testdata)</span></pre><h2 id="0354" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">模型评估</h2><p id="ba88" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">我们将使用各种指标来评估我们的模型，如准确度分数、精确度分数、召回分数、混淆矩阵，并创建roc曲线来可视化我们的模型的表现。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="3d4f" class="iq ir hi lo b fi ls lt l lu lv">rcParams['figure.figsize'] = 10,5<br/>plot_confusion_matrix(y_test,predictions)<br/>acc_score = accuracy_score(y_test,predictions)<br/>pre_score = precision_score(y_test,predictions)<br/>rec_score = recall_score(y_test,predictions)<br/>print('Accuracy_score: ',acc_score)<br/>print('Precision_score: ',pre_score)<br/>print('Recall_score: ',rec_score)<br/>print("-"*50)<br/>cr = classification_report(y_test,predictions)<br/>print(cr)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/2b8e1527c2edbed0ec0551bea556149a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F_STkSv2xQ2z87IfHrMKCw.png"/></div></div></figure><h2 id="0d4f" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">混淆矩阵:</h2><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/82c5631574ddc97ffbcd55bde17cfdbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*nGpFy-vWNFf6PkdPcHI2eA.png"/></div></figure><h2 id="0dee" class="iq ir hi bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">Roc曲线:</h2><p id="6539" class="pw-post-body-paragraph jo jp hi jq b jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki hb bi translated">我们将使用随机森林分类器的predict_proba()方法找到类的概率，然后绘制roc曲线。</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="4279" class="iq ir hi lo b fi ls lt l lu lv">predictions_probability = rfc.predict_proba(testdata)<br/>fpr,tpr,thresholds = roc_curve(y_test,predictions_probability[:,1])<br/>plt.plot(fpr,tpr)<br/>plt.plot([0,1])<br/>plt.title('ROC Curve')<br/>plt.xlabel('False Positive Rate')<br/>plt.ylabel('True Positive Rate')<br/>plt.show()</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/273440ba5815dde19a8e51215ecb2ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ycqjZQDVoHDAyl4AdP15Xg.png"/></div></div></figure><p id="df85" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">正如我们可以看到的，我们的模型在情感分类方面表现得非常好，准确率、精确度和召回率大约为。<strong class="jq hj"> 96% </strong>。roc曲线和混淆矩阵也很好，这意味着我们的模型可以准确地对标签进行分类，出错的机会更少。</p><p id="2afb" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">现在，我们也将检查自定义输入，并让我们的模型识别输入语句的情感。</p><p id="62c9" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">预测自定义输入:</p><pre class="lh li lj lk fd ln lo lp lq aw lr bi"><span id="c0d8" class="iq ir hi lo b fi ls lt l lu lv">def expression_check(prediction_input):<br/>    if prediction_input == 0:<br/>        print("Input statement has Negative Sentiment.")<br/>    elif prediction_input == 1:<br/>        print("Input statement has Positive Sentiment.")<br/>    else:<br/>        print("Invalid Statement.")</span><span id="52fa" class="iq ir hi lo b fi lz lt l lu lv"># function to take the input statement and perform the same transformations<br/>def sentiment_predictor(input):<br/>    input = text_transformation(input)<br/>    transformed_input = cv.transform(input)<br/>    prediction = rfc.predict(transformed_input)<br/>    expression_check(prediction)<br/></span><span id="2bff" class="iq ir hi lo b fi lz lt l lu lv">input1 = ["Sometimes I just want to punch someone in the face."]<br/>input2 = ["I bought a new phone and it's so good."]</span><span id="8548" class="iq ir hi lo b fi lz lt l lu lv">sentiment_predictor(input1)<br/>sentiment_predictor(input2)</span></pre><figure class="lh li lj lk fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/b9892e53893e94821e6a6bd26303ec83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*fqJjkX_1Y1qyWkModuHMDg.png"/></div></figure><p id="628c" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">万岁，我们可以看到，我们的模型准确地分类了两个句子的情绪。</p></div><div class="ab cl mm mn gp mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hb hc hd he hf"><p id="ba62" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">如果你喜欢这篇文章，那么请在<a class="ae lw" href="https://www.linkedin.com/in/nkr4nikhilraj" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p><p id="f246" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">并且，你可以从<a class="ae lw" href="https://github.com/redocer/NLP_Sentiment_Analysis" rel="noopener ugc nofollow" target="_blank">这里</a>得到完整的代码。</p><p id="507a" class="pw-post-body-paragraph jo jp hi jq b jr kj jt ju jv kk jx jy jb kl ka kb jf km kd ke jj kn kg kh ki hb bi translated">结局？</p></div></div>    
</body>
</html>