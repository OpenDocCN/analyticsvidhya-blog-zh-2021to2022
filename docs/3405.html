<html>
<head>
<title>Getting Started With Tensorflow Input Pipeline</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Tensorflow输入管道入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-tensorflow-input-pipeline-aa0f31eea74a?source=collection_archive---------4-----------------------#2021-06-29">https://medium.com/analytics-vidhya/getting-started-with-tensorflow-input-pipeline-aa0f31eea74a?source=collection_archive---------4-----------------------#2021-06-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cfaf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">TensorFlow输入管道入门指南(tf.data.dataset)</p><h1 id="f865" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">介绍</h1><p id="9d37" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">嘿大家好，</p><p id="79da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一篇关于如何使用<strong class="ig hi"> Tensorflow的输入管道的相对快速简单的文章。对于许多人来说，它仍然是一个黑匣子，因为它的文档不太友好，类和不同API的复杂性但是我觉得它相对容易。在这里，我们不打算探究本质和细节，相反，我们将看看如何使用它，并且我们还将编写一些代码来获得实践经验<strong class="ig hi">。</strong>此外，如果您有任何疑问，请在下面的评论区提问，我会尽快回复。</strong></p><h1 id="fd3e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">议程</h1><p id="653b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">文章分为两部分:</p><p id="fe39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">- <strong class="ig hi"> <em class="kf">理论部分</em> </strong>:快速直观地涵盖所有要点，让您快速入门</p><p id="f043" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">- <strong class="ig hi"> <em class="kf">编码部分</em> </strong>:用于一些动手练习。我们将在基础上工作，并将它们应用到图像数据集(猫和狗)。</p><p id="09cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我会敦促你按照你的编码部分，建立概念。</strong></p><h1 id="5af0" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">第1部分-理论</h1><h1 id="dae0" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是张量流输入管道</h1><p id="717d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">输入管道是<code class="du kg kh ki kj b">tf.data</code> <em class="kf"> api </em>中提供的一个快速简单的工具，可以用简单的可重用代码和几行代码创建复杂的输入管道。它还允许处理大量数据，从而使低端机器在计算数据方面具有优势。</p><p id="fa81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它通过将数据包装到<code class="du kg kh ki kj b"> tf.data.dataset</code>类中并对其执行一系列操作来实现，这些操作称为ETL - <strong class="ig hi">提取、转换、加载。</strong></p><h1 id="2cf7" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">有什么好处</h1><p id="b0b9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">使用它的好处如下:</p><p id="7fd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.<strong class="ig hi">加载数据:</strong>数据以<code class="du kg kh ki kj b">tf.data.dataset </code>结构或批处理的方式分块加载，允许在保留内存空间的同时管理和加载大量数据。此外，它允许支持不同的数据格式和类型，包括云存储(S3)。</p><p id="6328" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.<strong class="ig hi">数据处理/扩充:- </strong>一般来说，这是通过<code class="du kg kh ki kj b">Pandas, Numpy -</code>文本/表格/数字数据，或<code class="du kg kh ki kj b">Keras ImageDataGenerator / OpenCV-</code>图像数据来完成的。<strong class="ig hi">但是在这里，它可以在输入管道本身中执行，从而在编码的同时允许更快和快速的原型制作</strong>。<em class="kf">过滤、贴图、调整大小、裁剪</em>等等。</p><p id="1ae5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.<strong class="ig hi">最后一行:</strong>所有这些都可以在一行代码中完成，从而节省内存空间。下面是它的一个简短片段和解释:</p><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es kk"><img src="../Images/1c696074466a884f957e24b6111a8728.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ER2y0LWkIGL0e1RLLhIKFw.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">通用输入管道</figcaption></figure><p id="f554" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.它支持企业的分布式和并行计算，这对于云计算和大数据至关重要。</p><p id="3f41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意:- Tensors是<code class="du kg kh ki kj b">tf.data.dataset</code>背后的底层数据结构，所以它不同于<strong class="ig hi"> NumPy数组或Pandas dataframe。不要弄错了😉。</strong></p><h1 id="ae8d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">第2部分-编码</h1><h1 id="3770" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">1.基础</h1><p id="2d5e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">现在，让我们来看一些我们需要开始的基本材料。所以“首先”加载我们的数据。</p><h1 id="185a" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">加载数据</h1><p id="af6c" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们可以使用的最基本的东西是使用<code class="du kg kh ki kj b">tf.data.dataset.from_tensor_slices(list) </code>从python列表中加载数据，如下所示:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="d34f" class="le jd hh kj b fi lf lg l lh li"># importing library<br/><strong class="kj hi">import</strong> tensorflow <strong class="kj hi">as</strong> tf  </span><span id="4950" class="le jd hh kj b fi lj lg l lh li"># creating a list object- monthly expenses in dollars <br/>dataset = [12,15,67,-56,78,90,25,-890,-45,67,90,45,34,-100,300]<br/>  <br/># creating tf.data.dataset object  <br/>tf_dataset = tf.data.Dataset.from_tensor_slices(dataset) tf_dataset</span></pre><h1 id="e137" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">查看内容</h1><p id="1e4e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">由于<code class="du kg kh ki kj b">tf_dataset</code>是一个张量数据类型，我们可以遍历它来查看它的所有内容:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="2152" class="le jd hh kj b fi lf lg l lh li"># view the content by iterating<br/>for i in tf_dataset:<br/>    print(i)</span><span id="9767" class="le jd hh kj b fi lj lg l lh li"># retunrs</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lk"><img src="../Images/252a5a29a6e5c060101c7337c75c9641.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*K8EAUC8tag1utwMQazFm9A.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">上述代码的结果</figcaption></figure><p id="4211" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很明显，这个内容视图并不是很有用，因为它包含了许多其他对用户不友好的元素。所以我们可以做的一件简单的事情就是调用<code class="du kg kh ki kj b">no.numpy()</code>或<code class="du kg kh ki kj b">tf_dataset.as_numpy_iterator()</code>将数据转换成一个<strong class="ig hi"> NumPy </strong>数组并只打印元素。它可以实现为:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="c135" class="le jd hh kj b fi lf lg l lh li"># Converting the tensor to numpy object using ```numpy()```<br/>for i in tf_dataset:<br/>    print(i.numpy())</span><span id="c92a" class="le jd hh kj b fi lj lg l lh li">or </span><span id="4b59" class="le jd hh kj b fi lj lg l lh li"># Or use tf_dataset.as_numpy_iterator  <br/>for i in tf_dataset.as_numpy_iterator():     <br/>    print(i)</span><span id="7b73" class="le jd hh kj b fi lj lg l lh li"># Returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es ll"><img src="../Images/4ef62a2e8dc6b7f8e51f4d13017c1968.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*SuJlKiS_yPz_gtOWNdULkA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">仅以Numpy数组的形式返回值</figcaption></figure><p id="e7e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，以这种格式查看数据要方便得多。<strong class="ig hi">注意这只对数字数据类型有效，对字符串无效！</strong></p><p id="5dfd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们也可以使用<code class="du kg kh ki kj b">take(no)</code>方法只查看指定数量的数据点<strong class="ig hi">()。T </strong> <em class="kf">他的代码位看起来是这样的:</em></p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="c461" class="le jd hh kj b fi lf lg l lh li"># Converting the tensor to numpy object using ```numpy()```<br/>for i in tf_dataset.as_numpy_iterator():     <br/>    print(i)</span><span id="80ad" class="le jd hh kj b fi lj lg l lh li"># Returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lm"><img src="../Images/559432b3323a7ffba69ec356494edc96.png" data-original-src="https://miro.medium.com/v2/resize:fit:156/format:webp/1*AD3LpRdnBhpa7Mlmi-koQg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">仅返回3个元素</figcaption></figure><h1 id="4c81" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">过滤数据</h1><p id="9637" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们在数据集中有许多<strong class="ig hi">负值(-ve) <em class="kf"> </em> </strong>值，所以一个显而易见的事情是只过滤<strong class="ig hi"> <em class="kf">正值(+ve) </em> </strong>的数据。使用i <em class="kf"> nput管道api </em>，可以使用<code class="du kg kh ki kj b">tf_dataset.filter(custom_fn)</code>来完成:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="20aa" class="le jd hh kj b fi lf lg l lh li"># lambda x : x&gt;0 - fn to return the positive</span><span id="6893" class="le jd hh kj b fi lj lg l lh li">tf_dataset = tf_dataset.filter(lambda x : x&gt;0)</span><span id="7404" class="le jd hh kj b fi lj lg l lh li">for i in tf_dataset.as_numpy_iterator():<br/>    print('$ '+str(i))</span><span id="3e26" class="le jd hh kj b fi lj lg l lh li">#returns </span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es ln"><img src="../Images/383df7e87410cd2c229cb0729cbe3fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:234/format:webp/1*lfG3alRUc3PHEsd1AGkDAQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">返回大于0的值</figcaption></figure><p id="5aea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看出，只有正值被返回，所以我们的过滤器工作得很好，是一种快速过滤数据集的便捷方式。</p><h1 id="a586" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">映射数据</h1><p id="046a" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">通常我们需要<strong class="ig hi">在整个数据集</strong>上处理某个过程，一个接一个地做有点乏味。想想用户的tensorflow提供了一个<code class="du kg kh ki kj b">map()</code>方法，可以在数据集上调用它，并在一行代码中完成我们的工作。<strong class="ig hi">自定义函数被提供给</strong>，它将该过程应用于整个数据集。我们可以这样做:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="c623" class="le jd hh kj b fi lf lg l lh li"># using map fn <br/># lambda x : x*72 - multiplies the value by 72</span><span id="0e62" class="le jd hh kj b fi lj lg l lh li">for i in tf_dataset.map(lambda x : x*72):<br/>    print('Rs '+str(i.numpy()))</span><span id="8805" class="le jd hh kj b fi lj lg l lh li"># returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lo"><img src="../Images/566f125716770a90e72f2a2f3a3a21bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/format:webp/1*xqHaG-l33bENnloKc0XSCw.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">返回值为Rs</figcaption></figure><p id="6744" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们使用等式<strong class="ig hi"> ₹ = $*72 </strong>将数据从美元转换为₹，在<code class="du kg kh ki kj b">map</code>的帮助下，我们<strong class="ig hi"> <em class="kf">将每个元素乘以72 </em> </strong>来进行转换。</p><h1 id="860e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">洗牌数据</h1><p id="6d81" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在进行图像分析甚至数据准备时，我们经常需要打乱数据集。这可以通过<code class="du kg kh ki kj b">tf_dataset.shuffle()</code> a方法来实现，该方法将<strong class="ig hi">缓冲区</strong>作为参数，并根据<em class="kf">缓冲区获得的</em>个元素(窗口)来随机洗牌。</p><p id="6ecb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用它来洗牌，非常方便:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="9c11" class="le jd hh kj b fi lf lg l lh li">for i in tf_dataset.shuffle(3):<br/>    print(i.numpy())</span><span id="297c" class="le jd hh kj b fi lj lg l lh li"># returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lp"><img src="../Images/954a913748c3594cb624048c532d0ba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:128/format:webp/1*ZMQZo9jv476Ckw6jyqcsIw.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">返回混洗的值</figcaption></figure><p id="b0c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看出，<strong class="ig hi">一些值已经被打乱，从而使我们的数据集具有随机性，没有训练集所需的固定顺序</strong>。</p><h1 id="ce2e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">批处理数据</h1><p id="261b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在进行图像分析甚至数据准备时，我们经常需要打乱数据集。这可以通过<code class="du kg kh ki kj b">tf_dataset.shuffle()</code>来实现，该方法以<strong class="ig hi">缓冲区</strong>为参数，并根据<em class="kf">缓冲区获取的【窗口】元素数量</em>随机洗牌数据集。</p><p id="7972" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用它来洗牌，非常方便:</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="1220" class="le jd hh kj b fi lf lg l lh li">for i in tf_dataset.batch(3):<br/>    print(i.numpy())</span><span id="8275" class="le jd hh kj b fi lj lg l lh li"># returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="er es lq"><img src="../Images/2aced7696d4284d099160bcd6b703702.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/1*ixe-oaN_tokdp8qu7DkRxQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">数据分成大小为2的批，每批3个元素</figcaption></figure><p id="9bd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">如图所示，数据集被分成大小为2的批次，每个批次包含3个元素</strong>。<em class="kf">这允许高效地处理大型数据集，并在没有很多资源的机器上工作</em> —考虑一个8Gb的ram，包含100万个数据样本🤓。</p><h1 id="4549" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">链接呼叫</h1><p id="578f" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">关于<code class="du kg kh ki kj b"> tf.data</code> api的一个好处是，它允许<strong class="ig hi">链接</strong>所有的方法，并在一行代码中完成所有上述步骤(<em class="kf">加载、过滤、映射、混排、批处理</em>，等等)。我们这样做的方法是使用一个<code class="du kg kh ki kj b">'.'</code>操作符</p><pre class="kl km kn ko fd la kj lb lc aw ld bi"><span id="a0d8" class="le jd hh kj b fi lf lg l lh li"># one liner using '.<br/># reading + filtering + mapping + shuffling + batching in one  line<br/>tf_dataset_new = tf.data.Dataset.from_tensor_slices(dataset).filter(lambda x: x&gt;0).map(lambda a: a*72).shuffle(2).batch(2)</span><span id="e14c" class="le jd hh kj b fi lj lg l lh li">for i in tf_dataset_new.as_numpy_iterator():<br/>    print(i)</span><span id="7ec2" class="le jd hh kj b fi lj lg l lh li">#returns</span></pre><figure class="kl km kn ko fd kp er es paragraph-image"><div class="er es lr"><img src="../Images/fea7f56598d736089214f1a042f74496.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/format:webp/1*QU4AGJ9vZN7e-ZJCqLUIDQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">返回已处理的数据集</figcaption></figure><p id="d109" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kf">由于批处理时最后一个数据点是奇数，没有配对，对于2的混洗，对于</em> <strong class="ig hi"> <em class="kf">每个窗口，即</em> </strong> <em class="kf">，除了最后一个以外，返回值为2。更多信息请点击</em> 查看 <a class="ae ls" href="https://stackoverflow.com/questions/53514495/what-does-batch-repeat-and-shuffle-do-with-tensorflow-dataset" rel="noopener ugc nofollow" target="_blank"> <em class="kf"/></a></p><p id="2a00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，这些是一些快速代码，您可以尝试，并启动和运行大多数输入管道任务。</p><p id="6323" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来:通过为<strong class="ig hi">猫&amp;狗图像数据集</strong>制作输入管道来应用我们的学习。</p><h1 id="6f53" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><p id="1700" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">对于那些想了解更多内容的人，这里有一些很好的参考资料:</p><p id="6086" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">*有关输入管道的更多信息，请访问<a class="ae ls" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/api_docs/python/tf/data/Dataset</a></p><ul class=""><li id="57df" class="lt lu hh ig b ih ii il im ip lv it lw ix lx jb ly lz ma mb bi translated">代码笔记本:<a class="ae ls" href="https://colab.research.google.com/drive/11dlXiEWDGw-YEsiKo8-JUE4BehRwy-RA?usp=sharing" rel="noopener ugc nofollow" target="_blank">基础知识</a></li><li id="2a0a" class="lt lu hh ig b ih mc il md ip me it mf ix mg jb ly lz ma mb bi translated">教程视频+通用输入管道图片致谢:<a class="ae ls" href="https://youtu.be/VFEOskzhhbc" rel="noopener ugc nofollow" target="_blank"> CodeBasics </a></li></ul><p id="88aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">谢谢😄</p></div></div>    
</body>
</html>