<html>
<head>
<title>Manage instance attributes and its access to code more defensively in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中更具防御性地管理实例属性及其对代码的访问</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ways-to-manage-instance-attributes-and-access-in-python-to-code-more-defensively-a95384298c33?source=collection_archive---------25-----------------------#2021-04-03">https://medium.com/analytics-vidhya/ways-to-manage-instance-attributes-and-access-in-python-to-code-more-defensively-a95384298c33?source=collection_archive---------25-----------------------#2021-04-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e75e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有人需要介绍Python是一种优雅的语言，很多人都喜欢，它有一个伟大的开发社区作为后盾，它被广泛用于不同的应用程序，如数据、web、桌面GUI、商业应用程序等。</p><p id="e354" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是有一些警告，理解python的内部机制如何工作将帮助我们更好地编码，更重要的是编写易于维护的通用库。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/6c70cecd09d564d167184d8c41777001.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*2jpkNxCva654rHModZDmeA.jpeg"/></div></figure><p id="dbaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章的灵感来自于阅读David Beazley的一本关于python的书，我们使用他的方法在Apache Spark上编写了一个框架，用于创建可维护的应用程序。(使用spark的ETL作业更容易编写，但是很难维护)</p><h1 id="e637" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">理解类、实例及其属性</strong></h1><p id="5805" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们将从理解类、实例和属性等基本概念开始。</p><p id="a929" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我们的用例涉及到很多依赖关系，我举一个简单的例子，这个例子对每个人来说都很容易理解，并试图解释事情。假设我们正在用python创建一个简单的类和该类的一个实例。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="715c" class="ks jl hh ko b fi kt ku l kv kw">class Person(object):<br/>    def __init__(self, name, age, address, salary):<br/>        self.name = name<br/>        self.age = age<br/>        self.address = address<br/>        self.salary = salary</span><span id="0634" class="ks jl hh ko b fi kx ku l kv kw">person1 = Person("Erling", 22, 'US', 1000)</span></pre><p id="31a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">似乎我们有一个与创建的实例相关联的特殊属性，称为“__dict__”，它描述了对象，这意味着它包含了对象的所有属性。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="9e63" class="ks jl hh ko b fi kt ku l kv kw">person1.__dict__<br/>{‘name’: ‘Erling’, ‘age’: 22, ‘address’: ‘US’, ‘salary’: 1000}</span></pre><p id="d6a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们也可以使用属性名作为dict属性的键来访问属性。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="e805" class="ks jl hh ko b fi kt ku l kv kw">person1.__class__<br/>&lt;class '__main__.Person'&gt;</span><span id="8a6a" class="ks jl hh ko b fi kx ku l kv kw">person1.__class__.__dict__['name']<br/>'Erling'</span></pre><p id="b4cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是意料之中的。但是我敢肯定，作为一名python程序员，您可能至少曾经面临过这个问题。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="408d" class="ks jl hh ko b fi kt ku l kv kw">person1.salary = '2000' # wrong type<br/>person1.adres = 'Norway' # wrong attribute name</span><span id="f1c2" class="ks jl hh ko b fi kx ku l kv kw">person1.__dict__<br/>{'name': 'Erling', 'age': 27, 'address': 'US', 'salary': '2000', 'adres': 'Norway'}</span></pre><p id="36f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们的一个属性是错误的类型，由于一个打字错误，我们意外地创建了一个新的属性，python没有抱怨，根据您的实现的复杂性，您的程序可能会变得疯狂，并且难以排除故障。这是众所周知的，因为python是解释性的。</p><p id="db3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一些方法可以解决这个问题，下面是其中之一。</p><h1 id="bbf3" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">getter和setter</strong></h1><p id="93dd" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">与其他面向对象语言(例如Java)相比，python中Getters和setters的工作方式几乎没有什么不同。在python中使用它的主要目的可能是隐藏对类属性的直接访问，并可能在我们访问/修改实例的属性时添加一些自定义验证或其他逻辑。</p><p id="92c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">回到我们的例子，我们希望避免为属性设置错误的类型，我们可以编写如下代码。(在python中，我们使用@property decorator，setter来实现这一点)。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="f15e" class="ks jl hh ko b fi kt ku l kv kw">class Person(object):<br/>    def __init__(self, name, age, address, salary):<br/>        self.name = name<br/>        self.age = age<br/>        self.address = address<br/>        self._salary = salary</span><span id="b875" class="ks jl hh ko b fi kx ku l kv kw"><a class="ae ky" href="http://twitter.com/property" rel="noopener ugc nofollow" target="_blank">@property</a><br/>    def salary(self):<br/>        return self._salary</span><span id="a0c1" class="ks jl hh ko b fi kx ku l kv kw"><a class="ae ky" href="http://twitter.com/salary" rel="noopener ugc nofollow" target="_blank">@salary</a>.setter<br/>    def salary(self, newsalary):<br/>    if not isinstance(newsalary, int):<br/>        raise TypeError('Salary expected an Int value')<br/>    self._salary = newsalary</span><span id="4ec2" class="ks jl hh ko b fi kx ku l kv kw"><a class="ae ky" href="http://twitter.com/property" rel="noopener ugc nofollow" target="_blank">@property</a><br/>    def age(self):<br/>        return self._age</span><span id="2760" class="ks jl hh ko b fi kx ku l kv kw"><a class="ae ky" href="http://twitter.com/age" rel="noopener ugc nofollow" target="_blank">@age</a>.setter<br/>    def age(self, newage):<br/>    if not isinstance(newage, int):<br/>        raise TypeError('Age expected an Int value')<br/>    if newage &lt; 0:<br/>        raise ValueError('Age should be more than zero')<br/>    self._age = newage</span><span id="7464" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1 = Person('Erling', 21, 'Norway', 1000)</span><span id="0498" class="ks jl hh ko b fi kx ku l kv kw">person1.__dict__</span><span id="53bc" class="ks jl hh ko b fi kx ku l kv kw">{'name': 'Erling', '_age': 21, 'address': 'Norway', '_salary': 1000}</span></pre><p id="680e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">程序员暗示以' _ '开头的实例变量是内部实现，不应该使用实例直接访问。(python约定)</p><p id="a186" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以将年龄和薪水作为常规属性来访问，这有我们的验证逻辑。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="b478" class="ks jl hh ko b fi kt ku l kv kw">&gt;&gt;&gt; person1.age = 25</span><span id="b37f" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.salary = 2000</span><span id="8e2a" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.__dict__</span><span id="3271" class="ks jl hh ko b fi kx ku l kv kw">{‘name’: ‘Erling’, ‘_age’: 25, ‘address’: ‘Norway’, ‘_salary’: 2000}</span><span id="f2c0" class="ks jl hh ko b fi kx ku l kv kw">person2 = Person(‘Haaland’, ‘20’, ‘Norway’, 3000)</span><span id="1c13" class="ks jl hh ko b fi kx ku l kv kw">Traceback (most recent call last):</span><span id="51f1" class="ks jl hh ko b fi kx ku l kv kw">File “&lt;stdin&gt;”, line 1, in &lt;module&gt;</span><span id="9d12" class="ks jl hh ko b fi kx ku l kv kw">File “&lt;stdin&gt;”, line 4, in __init__</span><span id="253a" class="ks jl hh ko b fi kx ku l kv kw">File “&lt;stdin&gt;”, line 21, in age</span><span id="da5a" class="ks jl hh ko b fi kx ku l kv kw">TypeError: Age expected an Int value</span></pre><ol class=""><li id="d51c" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">但是这产生了另一个问题，有太多的锅炉板代码，很快就会变得令人讨厌。(考虑一下为每个创建的类编写这样的代码)</li><li id="5a62" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">我们还没有处理在实例中添加新属性的问题。</li></ol><h1 id="a348" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">通过理解“.”来管理属性</h1><p id="80c0" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们知道可以使用“.”来获取实例的属性但是这是如何工作的呢？</p><p id="7ce3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们做到了</p><p id="1134" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">人员1 .薪金= 2000</p><p id="d635" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">似乎Python会得到实例的类，检查它的__dict__属性中的关键字“salary”，这将返回一个属性，然后检查该属性是否有“__set__”方法，如果有，则调用set方法。一个消除困惑的例子。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="eb8c" class="ks jl hh ko b fi kt ku l kv kw">person1.__class__<br/>&lt;class '__main__.Person'&gt;<br/>person1.__class__.__dict__['salary']<br/>&lt;property object at 0x10349af90&gt;<br/>person1.__class__.__dict__['salary']<br/>&lt;property object at 0x10349af90&gt;<br/>property = person1.__class__.__dict__['salary']<br/>&gt;&gt;&gt; hasattr(property, '__set__')<br/>True<br/>property.__set__(person1, 1000)</span></pre><p id="dbc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样的过程也适用于从实例中获取属性。</p><p id="14e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们能利用这一点来减少我们需要使用property和setter为我们创建的类编写的代码行吗？似乎我们可以。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="3afe" class="ks jl hh ko b fi kt ku l kv kw">class Integer(object):<br/>    def __init__(self, name):<br/>        self.name = name<br/>    def __get__(self, instance, cls):<br/>        return instance.__dict__[self.name]<br/>    def __set__(self, instance, value):<br/>        if not isinstance(value, int):<br/>            raise TypeError('Expected an int value')<br/>        instance.__dict__[self.name] = value<br/><br/>class String(object):<br/>    def __init__(self, name):<br/>        self.name = name<br/>    def __get__(self, instance, cls):<br/>        return instance.__dict__[self.name]<br/>    def __set__(self, instance, value):<br/>        if not isinstance(value, str):<br/>            raise TypeError('Expected a string value')<br/>        instance.__dict__[self.name] = value</span></pre><p id="ec7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，我创建了一个整数和字符串类，它使用内部机制(使用set和get方法)来截取“.”当我们访问一个实例的属性时。</p><p id="6fae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的代码看起来像这样，</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="6f49" class="ks jl hh ko b fi kt ku l kv kw">class Person(object):<br/><br/>    age = Integer('age')<br/>    salary = Integer('salary')<br/>    name = String('name')<br/>    def __init__(self, name, age, address, salary):<br/>        self.name = name<br/>        self.age = age<br/>        self.address = address<br/>        self.salary = salary</span><span id="3fc5" class="ks jl hh ko b fi kx ku l kv kw">person1 = Person("Erling", '27', 'US', 1000)</span><span id="4714" class="ks jl hh ko b fi kx ku l kv kw">Traceback (most recent call last):</span><span id="9871" class="ks jl hh ko b fi kx ku l kv kw">File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><span id="a077" class="ks jl hh ko b fi kx ku l kv kw">File "&lt;stdin&gt;", line 7, in __init__</span><span id="c43c" class="ks jl hh ko b fi kx ku l kv kw">File "&lt;stdin&gt;", line 8, in __set__</span><span id="0837" class="ks jl hh ko b fi kx ku l kv kw">TypeError: Expected an int value</span></pre><p id="196d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用getter和setter实现相同的功能，我们编写的代码量大大减少了。为了进一步改进这段代码，我们将使用继承来创建一个通用类型类，以重用get和set方法。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="d031" class="ks jl hh ko b fi kt ku l kv kw">class Type(object):<br/>    expected_type = object<br/><br/>    def __init__(self, name):<br/>        self.name = name<br/><br/>    def __get__(self, instance, cls):<br/>        return instance.__dict__[self.name]<br/><br/>    def __set__(self, instance, value):<br/>        if not isinstance(value, int):<br/>            raise TypeError('Expected{}'.format(self.expected_type))<br/>        instance.__dict__[self.name] = value<br/><br/>class Integer(object):<br/>    expected_type = int<br/><br/>class String(object):<br/>    expected_type = str<br/><br/>class Float(object):<br/>    expected_type = float</span><span id="9bc8" class="ks jl hh ko b fi kx ku l kv kw">class Person(object):<br/><br/>    age = Integer()<br/>    salary = Integer()<br/>    name = String()<br/>    def __init__(self, name, age, address, salary):<br/>        self.name = name<br/>        self.age = age<br/>        self.address = address<br/>        self.salary = salary</span></pre><p id="9818" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们创建我们的框架时，这确实帮助了我们，我们可以扩展这个功能来拥有像expected_type这样的自定义对象，如果你愿意，就像一个小的类型系统。</p><p id="78d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在到了问题的最后一部分，我们需要限制实例来创建新的属性。</p><p id="a47b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">似乎有一种更通用的方法来获取和设置属性，使用神奇的方法__getattr__和__setattr__。当我们通过实例调用属性时，它被__getattr__截获，当我们设置属性时__setattr__方法被调用。我们可以覆盖__setattr__方法并在那里添加我们的检查。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="71c6" class="ks jl hh ko b fi kt ku l kv kw">person1 = Person('Rick', 65, 'US', 10)</span><span id="6d67" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.age</span><span id="4cdf" class="ks jl hh ko b fi kx ku l kv kw">65</span><span id="f684" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.name</span><span id="4498" class="ks jl hh ko b fi kx ku l kv kw">‘Rick’</span><span id="9387" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.__setattr__(‘age’, 66)</span><span id="694a" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt;</span><span id="330c" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.__dict__<br/>{‘name’: ‘Rick’, ‘age’: 66, ‘address’: ‘US’, ‘salary’: 10}</span></pre><p id="6c27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以现在我们的Person类是这样的。</p><pre class="jd je jf jg fd kn ko kp kq aw kr bi"><span id="514b" class="ks jl hh ko b fi kt ku l kv kw">class Person(object):<br/>    age = Integer()<br/>    salary = Integer()<br/>    name = String()<br/>    def __init__(self, name, age, address, salary):<br/>        self.name = name<br/>        self.age = age<br/>        self.address = address<br/>        self.salary = salary<br/>    def __setattr__(self, key, value):<br/>        if key not in {'name', 'age', 'address', 'salary'}:<br/>            raise AttributeError("No attribute {}".format(key))</span><span id="236f" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1 = Person("Erling", 27, 'US', 1000)</span><span id="b971" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.age = 21</span><span id="189c" class="ks jl hh ko b fi kx ku l kv kw">&gt;&gt;&gt; person1.money = 1000</span><span id="4510" class="ks jl hh ko b fi kx ku l kv kw">Traceback (most recent call last):</span><span id="cacc" class="ks jl hh ko b fi kx ku l kv kw">File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span><span id="0758" class="ks jl hh ko b fi kx ku l kv kw">File "&lt;stdin&gt;", line 12, in __setattr__</span><span id="2636" class="ks jl hh ko b fi kx ku l kv kw">AttributeError: No attribute money</span></pre><p id="15ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我们现在可以限制实例来添加更多的属性。希望这些想法能在某种程度上帮助你用python创建库/框架，使代码更易维护。</p></div><div class="ab cl ln lo go lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ha hb hc hd he"><p id="473b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[1]: Python食谱:掌握Python的食谱3第3版</p><p id="baf0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae ky" href="https://www.amazon.in/Python-Cookbook-Recipes-Mastering-ebook/dp/B00DQV4GGY" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . in/Python-Cookbook-Recipes-Mastering-ebook/DP/b 00 dq v4 ggy</a></p></div></div>    
</body>
</html>