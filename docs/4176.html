<html>
<head>
<title>End-to-End Maching Learning Project: Predicting House Prices in California</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">端到端机器学习项目:预测加州房价</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/end-to-end-maching-learning-project-predicting-house-prices-in-california-2e95171d49cc?source=collection_archive---------0-----------------------#2021-09-06">https://medium.com/analytics-vidhya/end-to-end-maching-learning-project-predicting-house-prices-in-california-2e95171d49cc?source=collection_archive---------0-----------------------#2021-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b3b636f7a9e807912d8dccc5bd3b957f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ly9qv9SsZ4jfTP7X"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">马丁·范·登·霍维尔在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="1103" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">欢迎来到加州房价分析！在这个项目中，我们将使用1990年加州人口普查数据集来研究并试图理解不同的属性如何使房价变高或变低。位置如何影响？房子的大小怎么样？年龄？</p><p id="0ff0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个数据集有很多信息可以帮助我们。主要目标是在python中建立一个机器学习模型，该模型可以从这些数据中学习，并在给定数据集中提供的所有其他指标的情况下，预测任何地区的房屋价格。</p><p id="b08b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该项目将分为两个主要部分:首先，我们将深入研究数据，清理数据，并制作一个大型EDA来收集见解并创建可能对模型有帮助的假设。</p><p id="7c11" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在此之后，我们将通过重重困难来创建一个能够对房价做出最佳预测的ML模型:我们将测试不同的模型，检查所阐述的假设，尝试创建新的特征，优化超参数等等。</p><p id="c41c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">数据集、文档和jupyter笔记本可以在我的<a class="ae it" href="https://github.com/DanielEliezer/california_housing" rel="noopener ugc nofollow" target="_blank"> github页面</a>找到</p><p id="7e11" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们走吧！</p><h1 id="db5c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">先看数据</strong></h1><p id="dbc6" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我们来看看从1990年加利福尼亚人口普查中收集的原始数据集。它包含20640行，每行存储一个特定块的信息。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/23f48d573466ccd2d8cee809b549ab25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VXC57woLoknuwS_h0noT-g.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">数据集的前几行</figcaption></figure><p id="ec14" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有以下变量，下面的描述收集在kaggle的dataset <a class="ae it" href="https://www.kaggle.com/camnugent/california-housing-prices" rel="noopener ugc nofollow" target="_blank"> page </a>中。</p><ul class=""><li id="5275" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated">经度:衡量一所房子向西多远的尺度；更高的值在更西边<br/><strong class="iw hi">纬度:</strong>一个测量房子有多北的尺度；更高的值是更北<br/><strong class="iw hi">住房_中位数_年龄:</strong>一个街区内房屋的中位数年龄；较低的数字是较新的建筑<br/><strong class="iw hi">总房间数:</strong>一个街区内的总房间数<br/><strong class="iw hi">总卧室数:</strong>一个街区内的总卧室数<br/><strong class="iw hi">人口数:</strong>居住在一个街区内的总人数<br/><strong class="iw hi">户数:</strong>总户数，居住在一个家庭单元内的一组人， 对于一个街区<br/><strong class="iw hi">中值_收入:</strong>一个街区内家庭的中值收入(以万美元计)<br/><strong class="iw hi">海洋_邻近度:</strong>房子的位置w.r.t海洋/海洋<br/><strong class="iw hi">中值_房子_价值:</strong>一个街区内家庭的中值房子价值(以美元计)</li></ul><p id="11c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好的，现在我们有一个小障碍。我们的目标变量是“中值房屋价值”，即给定街区中一栋房屋<strong class="iw hi">的中值。但是，一些指标与整个街区相关(房间总数、卧室总数和人口)。<strong class="iw hi">我们可能需要创建一些新的特性来保证它们在同一个“单元”中。</strong></strong></p><h1 id="5fca" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">清理数据</h1><p id="6494" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在进行上述更改之前，让我们先检查一下空值</p><p id="475d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">空值处理</strong></p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="f2a8" class="lo jt hh lk b fi lp lq l lr ls"># df.isnull().sum()</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/a5ce10fb20d24eabda7bec831314cbda.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*H9LsRWaKNvYguXmgyXalig.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">具有空值的变量</figcaption></figure><p id="90a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有207个“总卧室”缺失值的记录。这个数字非常小，丢失的值不会危及模型:几乎每个“经典”的解决方案，如删除行，用均值/中值填充等。将在最终模型中给出类似的结果。</p><p id="9169" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是出于教学的目的，让我们做一个更好的解决方案:</p><p id="eb6f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">想法是在将空值分组为更小的子集后，用中值填充空值。这个解决方案很有趣，因为对整个数据集只使用一个值可能会有问题，因为这些数字离中值越来越远。以更小的间隔对数据集进行分组保证了我们输入的是更接近极值的中值。</p><p id="5570" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">解决方案:首先，检查相关矩阵，与“卧室总数”最相似的度量是“住户”。因此，我们可以在用中位数填充之前，用它们<strong class="iw hi">对记录进行分组。这种分组将以20个单元为一组(例如，1~19户的➡组1，20 ~ 39户的➡组2，等等)</strong></p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="b311" class="lo jt hh lk b fi lp lq l lr ls">## Grouping the data in blocks of 20 values<br/>df["households_gp"] = df["households"]//20</span><span id="9875" class="lo jt hh lk b fi lu lq l lr ls">## Filling the null values with the median<br/>df["total_bedrooms"] = df["total_bedrooms"].fillna(df.groupby("households_gp")["total_bedrooms"].transform('median'))</span></pre><p id="15aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很好，我们没有空值了。</p><p id="b44b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">改变变量“单位”</strong></p><p id="90e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们进行前面提到的更改:我们需要创建新的变量，以确保关于房间、卧室和人口的信息与我们的目标在同一个“单元”中。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="ed2e" class="lo jt hh lk b fi lp lq l lr ls">## Creating useful features</span><span id="9f31" class="lo jt hh lk b fi lu lq l lr ls">df["rooms_per_household"] = df["total_rooms"]/df["households"]<br/>df["bedrooms_per_household"] = df["total_bedrooms"]/df["households"]<br/>df["population_per_household"] = df["population"]/df["households"]</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lv"><img src="../Images/ac8475581a4a60661b47062bb0417533.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*5V5YPx5-Tzarr3DS7uIXdQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">新创建变量的统计数据</figcaption></figure><p id="b0b9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看新变量的描述性统计数据，我们可能会发现另一个问题:“每户人口”和“每户房间”的最大值远远高于预期。再深入一点，我们确定了一些具有这些极值的行，<strong class="iw hi">，并将在下一步中删除它们</strong>。</p><p id="7d81" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我们将非常保守:许多记录看起来有很高的价值，但是我们仍然假定它们是无辜的，并把它们保存在我们的数据中。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="0d9e" class="lo jt hh lk b fi lp lq l lr ls"># Dropping outliers<br/>df_cleaned = df.drop([1914,1979,3364,16669,19006]).reset_index(drop = True)</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/225a8bdec5172720d51f825466f85114.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*I0Wi9eakUrKJBIKV3XqwMw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">更改后的最大值</figcaption></figure><p id="3633" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好吧，即使新的最大值仍然很高，他们似乎更合理。我们继续吧。</p><p id="1476" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">探索变量之间的关系</strong></p><p id="6aef" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们试着理解变量之间的关系。为此，<strong class="iw hi">我们将使用AutoViz库</strong>，它自动为我们绘制所有关系，类似于Sweetviz、pandas profiling等</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="6f07" class="lo jt hh lk b fi lp lq l lr ls"># Checking the distributions of our main variables <br/>AV = AutoViz_Class()<br/>dft = AV.AutoViz(“”, dfte=df, depVar = ‘median_house_value’)</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/3655e53bfa4427a7f9c47230f8cb3e3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xmyuQWUx1e1sTfoERg9vDQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">AutoViz报告的一小部分</figcaption></figure><p id="75e4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看一下Autoviz的报告，一些事情引起了我们的注意:让我们更仔细地看看收入中位数和房屋价值中位数之间的关系。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/54fcf000c33cdc2097b67a3df788f56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RSiG-I7OSBHmvG5dldXWVA.png"/></div></div></figure><p id="58fa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们似乎对房屋价值中值有一些问题:首先，最高房屋价值明确设定为500.000美元，所有比这更贵的房屋都“收到”这一金额。<strong class="iw hi">这些记录应该被删除，因为它们的目标值不正确，可能会扰乱模型。</strong></p><p id="e99c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第二个问题是我们可以在一些具体的点上看到一些水平线，比如450.000，350.000，350.000，275.000$。这看起来很不自然，这些值可能放错了地方。这里有两个选择:我们可以简单地删除所有具有这些值的记录，或者我们可以尝试为这些怪癖中的每一个确定一个阈值，在该点之后，数据似乎是不正确的。</p><p id="9e5a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于数据集足够大，这些值只代表数据的一小部分(大约1%)。我们就放弃吧。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/4724dedbf9b9b52560fec983d75f895a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgMglYMzJFx8Q9vo2BUTjA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">变化后的相同关系</figcaption></figure><p id="0b95" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这看起来更自然！</p><p id="143d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是目前所有的清洁工作，让我们在我们的EDA中挖一个小挖掘机。</p><h1 id="414f" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">探索性数据分析</h1><h2 id="389e" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">地理空间数据</h2><p id="e620" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">首先，让我们看看我们的目标在地图中的行为。地段对决定房子价值中位数有多重要？</p><p id="0c49" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将使用plotly和<a class="ae it" href="https://www.mapbox.com/" rel="noopener ugc nofollow" target="_blank"> mapbox API </a>。你需要创建一个mapbox帐户来免费获取访问令牌。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="6ca6" class="lo jt hh lk b fi lp lq l lr ls">## Plotting the map, using the mapbox api<br/>mapbox_access_token = &lt;YOUR_TOKEN&gt;<br/>px.set_mapbox_access_token(mapbox_access_token)<br/>fig = px.scatter_mapbox(small_df, lat=”latitude”, lon=”longitude”, zoom=4, color=”median_house_value”,<br/> color_continuous_scale=px.colors.diverging.RdBu_r, opacity = 0.2)<br/>fig.show()</span></pre><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="mn mo l"/></div></figure><p id="d16d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从地图上，我们可以看到一些有趣的事情:</p><p id="f249" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">几乎所有的红点(标记更昂贵的房子)都相对靠近海洋，这在我们的分析中突出了海洋邻近性的重要性。 <br/>洛杉矶，海湾附近的城市(尤其是西区)，圣巴巴拉，圣地亚哥有很多街区都有昂贵的房子。<br/>尽管该州的首府是萨克拉门托，但该市的大部分街区都有廉价房。<br/>随着我们从海洋走向内陆，房价大幅下跌。中西部有许多山区的事实可能会导致这种行为。这个州的北部几乎没有红斑，即使是在靠近海洋的地方。</p><h2 id="9a7c" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">分类值:海洋邻近度</h2><p id="4a5a" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">我们能够在地图上非常清楚地看到地理位置在确定房子价值中的重要性。在我们的模型中，分类值“海洋接近度”也很有帮助，因为一些模型很难从纬度/经度中学习。让我们看看房屋的价格与这几类有关:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mp"><img src="../Images/d6d6be32d51d0414def70cfb6aa44fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mW4c5xxC2CxX1QCNwRS2MA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">每类住房价值</figcaption></figure><p id="c879" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">总的来说，我们可以看到“靠近海湾”、“靠近海洋”和“靠近海洋”的房子比内陆的房子更贵。此外，这些类别的价格范围更广。</p><p id="0d25" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是我们能做得更好吗？</p><p id="175b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们在地图上注意到，我们在整个海岸都有红色斑点…除了该州的北部，那里甚至在海岸上也有更便宜的房子。</p><p id="a12e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">让我们创建新的类别来将北海岸与其他地区分开:</strong>在纬度38.20以上，我们将为“near_ocean”和“less_1h_to_ocean”创建新的类别。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/d13bb0d9097176d183d48ba1cd52b815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zo979WEmm9p8aSW-XD2fAw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">变动后每一类别的住房价值</figcaption></figure><p id="b735" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那很好。对于这两个新类别，我们可以看到北方数据和南方数据之间的巨大差异。</p><p id="9f3b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将把这些变化保存在一个单独的数据集中，看看它是否能帮助机器学习模型。</p><h2 id="2581" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">数据</h2><p id="1fbe" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我们画出相关矩阵，看看数值变量是如何相互关联的</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="2295" class="lo jt hh lk b fi lp lq l lr ls">## Checking the correlation matrix</span><span id="902b" class="lo jt hh lk b fi lu lq l lr ls">corr_mat = df_cleaned.corr().round(2)<br/>f, ax = plt.subplots(figsize=(7,7))<br/>mask = np.zeros_like(corr_mat,dtype=np.bool)<br/>mask[np.triu_indices_from(mask)] = True<br/>sns.heatmap(corr_mat,mask=mask,vmin=-1,vmax=1,center=0, <br/> cmap='RdYlBu',square=False,lw=2,annot=True,cbar=False);<br/>plt.title("Correlation Matrix", fontsize = 18, fontweight = 'bold')<br/>plt.show()</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/766a61d11ca57b269b21d8a7ee784e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*KTLVccmrXOrRjPigI7QZnw.png"/></div></figure><p id="74b3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看看我们的相关矩阵，没有太多大的发现。所有的强关系都是显而易见的，我们可以预见它的到来:一个街区住的人越多，房间就越多。一个街区的住户越多，卧室就越多，等等。我们能提取的最有用(但也有点明显)的信息是:<strong class="iw hi">家庭收入中值越高，房子就越贵。</strong></p><h2 id="8850" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">快速括号</h2><p id="963b" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我在这里插一句:一个有趣的事情是，房子年龄中位数和房子价值中位数的系数略为正:房子越老，越贵。当然，知道了上下文，我们可能会怀疑这实际上没有意义。如果有人买了一栋全新的房子，我们应该预料到如果房子是旧的，而不是全新的，她的价值会更高？大概不会。</p><p id="3c3d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">再深入一点，我们可以看到为什么会发生这种情况:</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/8ff77e71573e142d1aab87ffd4ffb69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6fuCxeIBBkp_t6gwTxI88g.png"/></div></div></figure><p id="b429" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">房子越新，它位于“内陆”的可能性就越大，我们已经注意到，内陆的房子不如靠近海洋或海湾的房子昂贵。这就是为什么我们会有越老的房子越贵的想法。考虑到同一街区的房屋，这种相关性不太可能成立。</p><p id="e813" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这凸显了这种探索性数据分析的难度。有时很难在我们的数据中找到隐藏的模式，了解业务是收集见解的一个非常好的方法。</p><h2 id="ffee" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">继续我们的EDA</h2><p id="5a57" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我们再来看看收入中值和房价中值之间的关系，因为它们有很强的关系。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/4724dedbf9b9b52560fec983d75f895a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HgMglYMzJFx8Q9vo2BUTjA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">变化后的相同关系</figcaption></figure><p id="e00b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以发现一个对线性模型不太好的“锥形”形式。这种效应也出现在其他关系中。在这些情况下，<strong class="iw hi">使用特征的对数可以帮助模型做出更好的预测</strong>。让我们创建一个单独的数据框架，以检查这些新的日志转换功能是否有所帮助。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="1a82" class="lo jt hh lk b fi lp lq l lr ls"># Creating a log dataframe <br/>list_log = [‘housing_median_age’, ‘median_income’,<br/> ‘median_house_value’,’rooms_per_household’,’population_per_household’,’bedrooms_per_household’]</span><span id="91cd" class="lo jt hh lk b fi lu lq l lr ls">df_with_log = df_cleaned.copy()<br/>for col in list_log:<br/> name_log = 'log_' + str(col)<br/> df_with_log[name_log] = np.log(df_with_log[col] + 1)</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/a2dc51a39f6c3a7755b081a484d0c890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gZ41Myu5ReRPyoAtT2FAwg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">对数变换后的新关系</figcaption></figure><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="9636" class="lo jt hh lk b fi lp lq l lr ls">## Comparing the pearson correlation coefficient with and without the log<br/>df_with_log.corr().loc[[‘median_house_value’,’log_median_house_value'], [‘median_income’,’log_median_income’]]</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es mu"><img src="../Images/cfd5f2f198f9f3b0186ab7ee24d56756.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*FUGOOY05M0Xp75HEsH5A_A.png"/></div></figure><p id="3f56" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于对数特征，皮尔逊系数略好。我们将在接下来的步骤中检查使用这些方法是否会对我们的模型产生积极影响。</p><h1 id="f790" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">构建我们的第一个机器学习模型</h1><p id="f3f5" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">在本节课中，我们将尝试给出一些答案:</p><p id="c161" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的问题的最佳模型是什么(线性、基于树、SVR、基于邻居)？<br/>在我们的数字数据中应用日志增强了模型？如果变量被缩放会怎样？</p><p id="3486" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">现在，我们将选择每种类型的一个模型(在线性、基于树的、邻居和SVR之间),看看哪种模型的性能更好，以及性能如何随着一些变换(对数变换和变量标准化)而变化。</strong></p><p id="fa9f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了监控这些步骤的结果，我们将主要使用R平方度量(R ),因为这个度量是自解释的，并且是回归中最常见的度量。有时，我们还会使用RMSE(均方根误差)来更好地了解我们的误差(单位为美元)。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="f923" class="lo jt hh lk b fi lp lq l lr ls">dict_modelos ={<br/> ‘LinearRegression’:LinearRegression, # linear model<br/> ‘KNeighbors’: KNeighborsRegressor, # neighbors<br/> ‘RandomForest’: RandomForestRegressor, # tree-based<br/> ‘SVR’:svm.SVR # SVR<br/> }<br/># creating dict to store the results from each model, with the transformations<br/>result_models = {}<br/>result_models_std = {}<br/>result_models_log = {}<br/>result_models_std_log = {}</span><span id="bb74" class="lo jt hh lk b fi lu lq l lr ls"># no log and no std_scaler<br/>for key, value in dict_modelos.items():<br/> r2, mse = run_and_evaluate_model(df_cleaned, value, std_scaler = False)<br/> result_models[key] = r2</span><span id="8868" class="lo jt hh lk b fi lu lq l lr ls"># no log and with std_scaler<br/>for key, value in dict_modelos.items():<br/> r2, mse = run_and_evaluate_model(df_cleaned, value, std_scaler = True)<br/> result_models_std[key] = r2</span><span id="5661" class="lo jt hh lk b fi lu lq l lr ls"># with log and no std_scaler<br/>for key, value in dict_modelos.items():<br/> r2, mse = run_and_evaluate_model(df_with_log, value, std_scaler = False, log = True)<br/> result_models_log[key] = r2</span><span id="9157" class="lo jt hh lk b fi lu lq l lr ls"># with log and with std_scaler<br/>for key, value in dict_modelos.items():<br/> r2, mse = run_and_evaluate_model(df_with_log, value, std_scaler = True, log = True)<br/> result_models_std_log[key] = r2</span><span id="e849" class="lo jt hh lk b fi lu lq l lr ls"># joining the results in a single df<br/>df_results = pd.DataFrame([result_models, result_models_std, result_models_log, result_models_std_log])<br/>df_results.index = [‘no_std_no_log’, ‘with_std_no_log’, ‘no_std_with_log’, ‘with_std_with_log’]<br/>df_results</span></pre><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es mv"><img src="../Images/518778cf94bb9731e9197f8013907f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*-9ByNA11imi6qyEi3IH5OQ.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">结果表</figcaption></figure><p id="302a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看结果，我们可以看到线性模型不是很好。我们尝试在数值变量中使用对数确实改进了模型，但是R值远远落后于其他选项。</p><p id="1355" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用标准缩放对于某些类型的模型非常重要，如SVR和KNeighbors。在线性和基于树的情况下，这似乎没有太大的区别。</p><p id="8822" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">性能最好的模型是基于树的模型</strong>。我们能提高到什么程度？</p><h1 id="97ea" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">优化机器学习模型</h1><p id="3bc4" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在，我们的目标是提高基于树的模型的性能，而不管它看起来如何。</p><p id="b91a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将尝试获得更好的结果:删除变量，创建新的变量，并执行超参数优化。最后，我们将检查是否有其他基于树的模型可以胜过随机森林。</p><p id="2e54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mw">注意:现在我们将使用交叉验证来评估模型，因为我们寻求更多的可靠性，即我们的改变有助于模型，这不是由于随机性。因此，我们必须重新评估模型，以获得交叉验证的新基线。</em></p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="d7cb" class="lo jt hh lk b fi lp lq l lr ls"># New baseline<br/>&gt;&gt; The R² of the model is: 0.8<br/>&gt;&gt; The RMSE is $43047</span></pre><h2 id="9343" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated"><strong class="ak">移除特征</strong></h2><p id="b54b" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">首先，让我们检查哪些特征对随机森林模型更重要，以评估结果。我们可以试着去掉最不重要的，看看是否能改进模型。</p><figure class="kw kx ky kz fd ii er es paragraph-image"><div class="er es mx"><img src="../Images/f886c713518e4aa8e74addabfd484161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*T1nP8YrXGZp3WdtLs-IRbg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">特征对随机森林模型的重要性</figcaption></figure><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="c251" class="lo jt hh lk b fi lp lq l lr ls"># Removing least important features<br/>run_and_evaluate_model_cv(df_cleaned.drop(['ocean_proximity_near_bay','ocean_proximity_less_1hour_to_ocean','ocean_proximity_near_ocean'], axis = 1), RandomForestRegressor(random_state = seed))</span><span id="891f" class="lo jt hh lk b fi lu lq l lr ls">&gt;&gt; The R² of the model is: 0.799</span></pre><p id="0a0d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有时，删除最不重要的特征会给模型带来更好的结果。这里的情况并非如此:在移除一些特性组合(移除最差的、移除第二差的、移除两者等等)之后评估模型之后，<strong class="iw hi">我们无法获得比基线更好的结果。</strong>我们将继续使用所有的原始功能。</p><h2 id="3b1b" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">创建新功能</h2><p id="b478" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在，让我们看看随机森林模型在“df_cleaned_ocean_loc”数据集中的表现，我们为海洋邻近度数据创建了附加类别，将其他州的北部分开，如前所述。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="9b8a" class="lo jt hh lk b fi lp lq l lr ls">df_cleaned_ocean_loc = pd.get_dummies(df_cleaned_ocean_loc, columns=['ocean_proximity_new']).drop('ocean_proximity_new_island', axis = 1)<br/>run_and_evaluate_model_cv(df_cleaned_ocean_loc, RandomForestRegressor(random_state = seed))</span></pre><p id="9cff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.8</p><p id="9ee7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这不是我们所期待的。<strong class="iw hi">这些变化似乎并没有改善基于树的模型</strong>(尽管它改善了线性模型)</p><p id="b55f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">也许我们可以做得更好:<strong class="iw hi">让我们尝试使用K-Means对数据进行聚类，并用这些结果创建一个新的‘cluster’变量来改进模型。</strong></p><h2 id="2a29" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">创建地理聚类要素</h2><p id="aa81" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">因为这里的主要目标是用地理空间数据帮助模型，所以我们将只使用纬度和经度值来拟合算法。这样，不同的聚类就不会在地图上重叠。</p><p id="d6d7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这一点上，我们将面临一些技术挑战:我们需要建立一个管道，以防止数据泄漏(当训练集以外的信息用于创建模型时)。不仅如此，<strong class="iw hi">拥有一个管道将使优化超参数</strong>变得更加容易，因为我们将尝试从KMeans模型和回归模型本身获得参数之间的最佳组合。</p><p id="962d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使用来自sklearn的管道，我们需要创建一个使用KMeans作为转换步骤的类，该转换步骤将创建一个传递给主模型的新特性。我们要超有创意，叫它KMeansTransformer。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="be4c" class="lo jt hh lk b fi lp lq l lr ls">class KMeansTransformer(BaseEstimator, TransformerMixin):<br/> <br/> def __init__(self, n_clusters=25, max_iter = 200, random_state = seed):<br/> self.n_clusters = n_clusters<br/> self.max_iter = max_iter<br/> self.random_state = seed<br/> self.model = KMeans(n_clusters, random_state = seed, max_iter = max_iter)</span><span id="4b31" class="lo jt hh lk b fi lu lq l lr ls">def fit(self,X,y=None):<br/> self.model.fit(X[[‘latitude’,’longitude’]])<br/> <br/> <br/> def transform(self,X,y=None):<br/> X[‘cluster’]= self.model.predict(X[[‘latitude’,’longitude’]]).reshape(-1,1)<br/> return X<br/> <br/> def fit_transform(self, X, y=None):<br/> self.fit(X[[‘latitude’,’longitude’]])<br/> return self.transform(X)</span></pre><p id="77ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，评估模型:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="5761" class="lo jt hh lk b fi lp lq l lr ls">pipe = Pipeline([(“clusterization”, KMeansTransformer(random_state = seed)),<br/> (“regressor”, RandomForestRegressor(random_state = seed))])<br/>run_and_evaluate_model_cv(df_cleaned, pipe)</span></pre><p id="fb82" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.804</p><p id="c0d5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是个好消息！使用KMeans创建一个“集群”列似乎有助于模型！出于好奇，让我们看看这些星团在地图上是什么样子。我们建立了25个簇的初始数目，在优化过程中，该数目可能会改变。</p><figure class="kw kx ky kz fd ii"><div class="bz dy l di"><div class="mn mo l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">地图上的集群</figcaption></figure><h2 id="6288" class="lo jt hh bd ju ma mb mc jy md me mf kc jf mg mh kg jj mi mj kk jn mk ml ko mm bi translated">超参数优化</h2><p id="7255" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">现在让我们试着用贝叶斯优化来优化它。在这种方法中，我们将为模型提供一系列我们想要调整的超参数值，它将随机搜索给出最佳结果的值的组合。在一些随机迭代之后，我们将找到最佳组合，算法将使用高斯过程继续搜索该点附近的值。</p><p id="6056" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们将尝试调整随机森林模型的超参数。这个过程需要几个小时。完成后，我们将得到一个优化的超参数列表，然后可以传递给我们的管道。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="02d6" class="lo jt hh lk b fi lp lq l lr ls">def train_model(params):<br/> n_clusters = params[0]<br/> n_estimators = params[1]<br/> min_samples_leaf = params[2]<br/> max_depth = params[3]<br/> max_features = params[4]<br/> <br/> print(params, ‘\n’)</span><span id="20df" class="lo jt hh lk b fi lu lq l lr ls"> mdl = Pipeline([(“clusterization”, KMeansTransformer(n_clusters = n_clusters)),<br/> (“regressor”, RandomForestRegressor(n_estimators = n_estimators,<br/> min_samples_leaf = min_samples_leaf,<br/> max_depth = max_depth,<br/> max_features = max_features))])<br/> mdl.fit(X, y)<br/> folds = KFold(n_splits = 4, shuffle = True, random_state = seed)<br/> scores = cross_val_score(mdl, X, y, cv=folds)<br/> return -round(np.mean(scores),3)</span><span id="c337" class="lo jt hh lk b fi lu lq l lr ls">space = [[10,15,20,25,30,35, 40], # n_cluster<br/> [100,200,400,800,1200,1600,2000,2400, 2700], # n_estimators<br/> [1,2,3,4,5,10,15,22,30], # min sample leaf<br/> [None], # max_depth<br/> [‘auto’,’sqrt’,’log2']] # max_features</span><span id="2d61" class="lo jt hh lk b fi lu lq l lr ls"> resultados_gp = gp_minimize(train_model, space, random_state=seed, verbose=1, n_calls=37, n_random_starts=25)</span><span id="57b1" class="lo jt hh lk b fi lu lq l lr ls"> resultados_gp.x</span></pre><p id="31de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基于上面的过程，我们得到了下面的管道:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="4d92" class="lo jt hh lk b fi lp lq l lr ls">pipe_rf = Pipeline([(“clusterization”, KMeansTransformer(random_state = seed, n_clusters = 25)),<br/> (“regressor”, RandomForestRegressor(random_state = seed, <br/> n_estimators = 800,<br/> min_samples_leaf = 1,<br/> max_depth = None,<br/> max_features = ‘log2’))])</span><span id="08d5" class="lo jt hh lk b fi lu lq l lr ls">run_and_evaluate_model_cv(df_cleaned, pipe_rf)</span></pre><p id="ec7f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.825</p><p id="31ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个非常有意义的进步:我们的R从0.804降到了0.825！</p><h1 id="a9e0" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">尝试另一种模式</h1><p id="37b1" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">让我们看看使用XGBoost是否能返回更好的结果。同样，我们将使用贝叶斯优化。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="7fbe" class="lo jt hh lk b fi lp lq l lr ls">def train_model_xgb(params):<br/>    n_clusters = params[0]<br/>    n_estimators = params[1]<br/>    learning_rate = params[2]<br/>    max_depth = params[3]<br/>    min_child_weight = params[4]<br/>    subsample = params[5]<br/>    num_parallel_tree = params[6]<br/>    <br/>    print(params, '\n')</span><span id="0c40" class="lo jt hh lk b fi lu lq l lr ls">    mdl = Pipeline<br/>([("clusterization", KMeansTransformer(n_clusters = n_clusters)),<br/>("regressor", XGBRegressor(<br/>n_estimators = n_estimators,<br/>learning_rate = learning_rate,                                           max_depth = max_depth,                                           min_child_weight = min_child_weight,                                           subsample = subsample,                                           num_parallel_tree = num_parallel_tree))])</span><span id="ed92" class="lo jt hh lk b fi lu lq l lr ls">mdl.fit(X, y)<br/>    folds = KFold(n_splits = 4, shuffle = True, random_state = seed)<br/>    scores = cross_val_score(mdl, X, y, cv=folds)<br/>    return -round(np.mean(scores),3)</span><span id="43f0" class="lo jt hh lk b fi lu lq l lr ls"> space_xgb = [list(range(15, 40)), # n_cluster <br/>          list(range(100, 2400)), # n_estimators<br/>          loguniform.rvs(1e-3, 1, size=1000, random_state=seed), # learning_rate<br/>          list(range(2, 7)), # max_depth<br/>          list(range(2, 30)), # min_child_weight<br/>          np.linspace(0.05, 1).tolist(), # subsample<br/>          list(range(2, 5))] # num_parallel_tree</span><span id="fbdc" class="lo jt hh lk b fi lu lq l lr ls">resultados_gp = gp_minimize(train_model_xgb, space_xgb, random_state=seed, verbose=1, n_calls=60, n_random_starts=40)<br/>resultados_gp.x</span></pre><p id="2ee0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，使用优化的参数运行新管道:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="03b0" class="lo jt hh lk b fi lp lq l lr ls">pipe_xgb_tuned = Pipeline([(“clusterization”, KMeansTransformer(n_clusters = 32)),<br/> (“regressor”, XGBRegressor(<br/> random_state = seed,<br/> n_estimators = 1085,<br/> learning_rate = 0.10595107822603367,<br/> max_depth = 5,<br/> min_child_weight = 15,<br/> subsample = 0.786734693877551,<br/> num_parallel_tree = 3))])</span><span id="ea20" class="lo jt hh lk b fi lu lq l lr ls">run_and_evaluate_model_cv(df_cleaned, pipe_xgb_tuned)</span></pre><p id="1ffe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.844</p><p id="80cd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">我们有了最终的模型！XGBoost比随机森林有更好的性能。</strong></p><p id="9e91" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所有的变化之后，RMSE从43047美元涨到了38059美元。这是一个很大的进步！</p><h1 id="cfd5" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">哪种功能更有帮助？</h1><p id="9c88" class="pw-post-body-paragraph iu iv hh iw b ix kq iz ja jb kr jd je jf ks jh ji jj kt jl jm jn ku jp jq jr ha bi translated">最后，我们有了最终的模型。出于好奇，让我们看看什么样的特征对做出预测更重要:关于地理位置的特征？关于房子和居民人数？家庭的收入？</p><p id="e4da" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将在这三个场景中运行模型，在每个场景中，我们将删除相关的功能。</p><ol class=""><li id="f61d" class="la lb hh iw b ix iy jb jc jf lc jj ld jn le jr my lg lh li bi translated"><strong class="iw hi">没有房子的信息</strong></li></ol><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="59ae" class="lo jt hh lk b fi lp lq l lr ls">## no info about the house</span><span id="ab69" class="lo jt hh lk b fi lu lq l lr ls">df_without_house_info = df_cleaned.drop(["housing_median_age",<br/> "rooms_per_household", "bedrooms_per_household",<br/> "population_per_household"], axis = 1)</span></pre><p id="eef2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.823</p><p id="6029" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。没有家庭收入的信息</strong></p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="de83" class="lo jt hh lk b fi lp lq l lr ls">## no info about the income</span><span id="6381" class="lo jt hh lk b fi lu lq l lr ls">df_without_income_info = df_cleaned.drop(['median_income'], axis = 1)</span></pre><p id="bdf3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.832</p><p id="ddcf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。没有关于房子位置的信息</strong></p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="a0a8" class="lo jt hh lk b fi lp lq l lr ls">## no info about the location</span><span id="030d" class="lo jt hh lk b fi lu lq l lr ls">df_without_location = df_cleaned.drop(['latitude','longitude','ocean_proximity_inland',<br/> 'ocean_proximity_less_1hour_to_ocean', 'ocean_proximity_near_bay',<br/> 'ocean_proximity_near_ocean'], axis = 1)</span></pre><p id="16cb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">&gt;&gt;模型的R为:0.621</p><p id="ce44" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就好奇了！这些实验表明，房子的位置是解释其价格的最重要的因素。尽管家庭收入和房价之间的相关性非常高，但最终这个属性并不那么重要。</p><p id="7804" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢阅读！</p></div></div>    
</body>
</html>