<html>
<head>
<title>Eye Aspect Ratio(EAR) and Drowsiness detector using dlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用dlib的眼睛纵横比(耳朵)和睡意检测器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/eye-aspect-ratio-ear-and-drowsiness-detector-using-dlib-a0b2c292d706?source=collection_archive---------1-----------------------#2021-04-21">https://medium.com/analytics-vidhya/eye-aspect-ratio-ear-and-drowsiness-detector-using-dlib-a0b2c292d706?source=collection_archive---------1-----------------------#2021-04-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8b80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将向您展示如何使用<em class="jd"> dlib </em>库来确定面部标志，如何计算EAR(眼睛纵横比)，以及使用EAR的概念来检测睡意。</p><blockquote class="je jf jg"><p id="168b" class="if ig jd ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">在开始本文的代码部分之前，您必须用python安装dlib库。安装dlib库有一些先决条件，我建议你查看<a class="ae jk" rel="noopener" href="/analytics-vidhya/how-to-install-dlib-library-for-python-in-windows-10-57348ba1117f">这篇文章</a>。</p></blockquote></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="76bc" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">dlib检测的面部标志是什么</h1><p id="e8f1" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated"><em class="jd"> dlib </em>库可以用来检测图像中的人脸，然后在检测到的人脸上找到68个面部标志。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/393ad541f77578bd615661047e56e07f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*WPh1v9qIrn5D7RU-fWqS5A.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">dlib在一张脸上发现的68个面部标志</figcaption></figure><p id="4d98" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不会详细介绍它如何检测人脸和定位面部标志。无论图像尺寸或面部大小如何，检测到的面部标志的顺序总是相同的，这意味着1-17将总是代表面部的轮廓。43–48代表左眼。如何做到这一点的确切代码将在本文后面给出。</p></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="6a8b" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">如何找到眼睛长宽比(耳朵)</h1><p id="a640" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">如果你注意到，每只眼睛用6个标志点表示。</p><p id="fa78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单眼的耳朵使用以下公式计算:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lh"><img src="../Images/d315edd28e0f8ff008a8708b9a71d7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*b42_JrQKCi0sTh9dV1s0Og.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">||p2-p6||表示点p2和p6之间的距离</figcaption></figure><blockquote class="je jf jg"><p id="b8c2" class="if ig jd ih b ii ij ik il im in io ip jh ir is it ji iv iw ix jj iz ja jb jc hb bi translated">耳朵越长，眼睛睁得越大。我们将决定一个最小耳值，并使用它来决定眼睛是否闭合。</p></blockquote><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es li"><img src="../Images/329559222ee1377b6a3da9bb713add4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*8bQB2IjpraO9gegFGkZmiw.png"/></div></figure><p id="014d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个效用函数，它将返回单眼的耳朵</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="f0dc" class="lo jt hi lk b fi lp lq l lr ls">def eye_aspect_ratio(eye):<br/>    p2_minus_p6 = dist.euclidean(eye[1], eye[5])<br/>    p3_minus_p5 = dist.euclidean(eye[2], eye[4])<br/>    p1_minus_p4 = dist.euclidean(eye[0], eye[3])<br/>    ear = (p2_minus_p6 + p3_minus_p5) / (2.0 * p1_minus_p4)<br/>    return ear</span></pre></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="c621" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">主要代码(睡意检测器)</h1><ol class=""><li id="579b" class="lt lu hi ih b ii kq im kr iq lv iu lw iy lx jc ly lz ma mb bi translated">我们将从导入必要的python库开始</li></ol><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="33b5" class="lo jt hi lk b fi lp lq l lr ls">import cv2<br/>import dlib<br/>import imutils<br/>from imutils import face_utils<br/>from scipy.spatial import distance as dist</span></pre><p id="1e46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.然后，我们声明一些全局配置变量，这些变量将用于我们代码的其余部分:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="8b9e" class="lo jt hi lk b fi lp lq l lr ls">FACIAL_LANDMARK_PREDICTOR = "shape_predictor_68_face_landmarks.dat"  <br/>MINIMUM_EAR = 0.2<br/>MAXIMUM_FRAME_COUNT = 10</span></pre><p id="fb2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">face _ LANDMARK _ PREDICTOR:</em>dlib预训练面部地标预测器的路径。你可以从<a class="ae jk" href="https://github.com/davisking/dlib-models/blob/master/shape_predictor_68_face_landmarks.dat.bz2" rel="noopener ugc nofollow" target="_blank">这里</a>下载这个文件。</p><p id="412e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> MINIMUM_EAR: </em>最小耳朵值，超过该值眼睛将被标记为睁开，否则为闭上。您可能希望根据自己的需求来调整这个参数。试着在不同的场景下找到EAR，然后确定值。此外，请注意，这个耳朵不是单眼的，而是双眼的累积耳朵。</p><p id="50c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd"> MAXIMUM_FRAME_COUNT: </em>耳朵的数值变化非常快。即使你眨眼，耳朵也会迅速下垂。但是眨眼不代表困倦。困倦将是一个人已经闭上眼睛(他的耳朵很小)例如连续10个视频帧的情况。所以这个变量告诉耳朵可以保持小于<em class="jd"> MINIMUM_EAR </em>的最大连续帧数，否则提醒困倦。</p><p id="3a63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.然后我们实例化dlib的<em class="jd"> faceDetector </em>(它将检测图像中的人脸)和<em class="jd"> landmarkFinder </em>(它将在检测到的人脸中找到68个地标)</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="6d02" class="lo jt hi lk b fi lp lq l lr ls">faceDetector = dlib.get_frontal_face_detector(<br/>landmarkFinder = dlib.shape_predictor(FACIAL_LANDMARK_PREDICTOR)<br/>webcamFeed = cv2.VideoCapture(0)</span></pre><p id="2555" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.然后，我们找到两只眼睛的界标id的开始和结束值。你也可以手动完成(右眼37–42，左眼43–48)，但是使用<em class="jd"> face_utils </em>你可以通过传递眼睛名称来获得这些值。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mc"><img src="../Images/937dd7554385aeed5931a237f355a07c.png" data-original-src="https://miro.medium.com/v2/resize:fit:644/format:webp/1*9o6QqU6964HqfNjKuOQCJQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">dlib面部标志</figcaption></figure><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="6c61" class="lo jt hi lk b fi lp lq l lr ls">(leftEyeStart, leftEyeEnd) = face_utils.FACIAL_LANDMARKS_IDXS["left_eye"]<br/>(rightEyeStart, rightEyeEnd) = face_utils.FACIAL_LANDMARKS_IDXS["right_eye"]</span></pre><p id="d558" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.最后一部分是真正的事情发生的地方</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="86c1" class="lo jt hi lk b fi lp lq l lr ls">EYE_CLOSED_COUNTER = 0<br/>try:<br/>    while True:<br/>        (status, image) = webcamFeed.read()<br/>        image = imutils.resize(image, width=800)<br/>        grayImage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)<br/><br/>        faces = faceDetector(grayImage, 0)<br/><br/>        for face in faces:<br/>            faceLandmarks = landmarkFinder(grayImage, face)<br/>            faceLandmarks = face_utils.shape_to_np(faceLandmarks)<br/><br/>            leftEye = faceLandmarks[leftEyeStart:leftEyeEnd]<br/>            rightEye = faceLandmarks[rightEyeStart:rightEyeEnd]<br/><br/>            leftEAR = eye_aspect_ratio(leftEye)<br/>            rightEAR = eye_aspect_ratio(rightEye)<br/><br/>            ear = (leftEAR + rightEAR) / 2.0<br/><br/>            leftEyeHull = cv2.convexHull(leftEye)<br/>            rightEyeHull = cv2.convexHull(rightEye)<br/><br/>            cv2.drawContours(image, [leftEyeHull], -1, (255, 0, 0), 2)<br/>            cv2.drawContours(image, [rightEyeHull], -1, (255, 0, 0), 2)<br/><br/>            if ear &lt; MINIMUM_EAR:<br/>                EYE_CLOSED_COUNTER += 1<br/>            else:<br/>                EYE_CLOSED_COUNTER = 0<br/><br/>            cv2.putText(image, "EAR: {}".format(round(ear, 1)), (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)<br/><br/>            if EYE_CLOSED_COUNTER &gt;= MAXIMUM_FRAME_COUNT:<br/>                cv2.putText(image, "Drowsiness", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)<br/><br/>        cv2.imshow("Frame", image)<br/>        cv2.waitKey(1)<br/>except:<br/>    pass</span></pre><p id="d28e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们声明一个变量<em class="jd"> EYE_CLOSED_COUNTER </em>，它记录耳朵小于<em class="jd"> MINIMUM_EAR的连续帧的计数。</em></p><p id="c8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们对图像进行了一些尺寸调整，并将其转换为灰度。</p><p id="538b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用dlib的<em class="jd">人脸检测器</em>检测图像中的所有人脸:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="c587" class="lo jt hi lk b fi lp lq l lr ls">faces = faceDetector(grayImage, 0)</span></pre><p id="c205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在每个面上循环，使用dlib的<em class="jd">地标探测器</em>找到68个地标:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="6823" class="lo jt hi lk b fi lp lq l lr ls">faceLandmarks = landmarkFinder(grayImage, face)</span></pre><p id="9838" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取左眼和右眼的界标，然后将其发送到<em class="jd"> eye_aspect_ratio() </em>以获取左眼和右眼的耳值:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="aa84" class="lo jt hi lk b fi lp lq l lr ls">leftEye = faceLandmarks[leftEyeStart:leftEyeEnd]<br/>rightEye = faceLandmarks[rightEyeStart:rightEyeEnd]<br/><br/>leftEAR = eye_aspect_ratio(leftEye)<br/>rightEAR = eye_aspect_ratio(rightEye)</span></pre><p id="9270" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">找出两只眼睛的累积耳朵:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="884b" class="lo jt hi lk b fi lp lq l lr ls">ear = (leftEAR + rightEAR) / 2.0</span></pre><p id="adad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用眼睛标志在图像上显示眼睛:</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="c0a8" class="lo jt hi lk b fi lp lq l lr ls">cv2.drawContours(image, [leftEyeHull], -1, (255, 0, 0), 2)<br/>cv2.drawContours(image, [rightEyeHull], -1, (255, 0, 0), 2)</span></pre><p id="078c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果对于当前帧，累积EAR小于MINIMUM_EAR，则增加计数器，否则重置计数器，因为我们只对连续帧感兴趣。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="3f66" class="lo jt hi lk b fi lp lq l lr ls">if ear &lt; MINIMUM_EAR:<br/>     EYE_CLOSED_COUNTER += 1<br/>else:<br/>     EYE_CLOSED_COUNTER = 0</span></pre><p id="aeb3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果耳朵小于指定数量的连续帧的MINIMUM_EAR，这意味着困倦。</p><pre class="kw kx ky kz fd lj lk ll lm aw ln bi"><span id="885e" class="lo jt hi lk b fi lp lq l lr ls">if EYE_CLOSED_COUNTER &gt;= MAXIMUM_FRAME_COUNT:<br/>                cv2.putText(image, "Drowsiness", (10, 50), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)</span></pre><p id="d664" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦一切就绪，您运行代码，它将生成如下所示的输出:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="me mf di mg bf mh"><div class="er es md"><img src="../Images/7417c3d05e6d25794160fa0d385ead2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3tugfKaP5fOKE5f0Q7PFvQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">EAR(未四舍五入到小数点后1位)小于minmin ium _ EAR(0.2)，报告困倦</figcaption></figure></div><div class="ab cl jl jm gp jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="hb hc hd he hf"><h1 id="fb69" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">最后的话</h1><p id="4317" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">在本文中，我们使用dlib库来确定面部标志。dlib库使用起来非常简单，即使没有GPU也能流畅运行。但是市场上也可能有其他免费使用的库。Mediapipe就是这样一个例子。如果你不知道这个库，你可以查看我以前的文章。在撰写本文时，Mediapipe库的Face模块还不能用于Python。在以后的某个时间，如果面部模块变得可用，它肯定值得一试，因为Mediapipe的面部标志检测肯定会比dlib更好。你可以在Github <a class="ae jk" href="https://github.com/pdhruv93/computer-vision/tree/main/drowsiness-detector" rel="noopener ugc nofollow" target="_blank">这里</a>找到这篇文章的源代码。</p></div></div>    
</body>
</html>