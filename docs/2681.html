<html>
<head>
<title>A (brief) crash course in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python的(简短)速成课程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-brief-crash-course-in-python-b172ed041d74?source=collection_archive---------15-----------------------#2021-05-12">https://medium.com/analytics-vidhya/a-brief-crash-course-in-python-b172ed041d74?source=collection_archive---------15-----------------------#2021-05-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3dd9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们遇到了检查包文件的需要，以查看是否所有标签都被正确地添加到了所有相关文件中。由于这个脚本(或我们使用的任何东西)将从我们的Jenkins管道中使用，我的第一反应是bash，但是，为什么我们不使它有趣些，用python来做呢？我没有这方面的经验，所以让我们直接开始吧。</p><p id="5552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们从<a class="ae jc" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> Python </a>本身开始，然后安装<a class="ae jc" href="https://www.jetbrains.com/pycharm/download/" rel="noopener ugc nofollow" target="_blank"> PyCharm社区</a>，因为它是免费的，看起来很有前途。它和Intellij IDEA有着相同的界面，所以这并不是一个太不和谐的变化。</p><p id="cc01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们打开PyCharm并选择新项目，用下面的配置创建一个。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/83c50f2df213bd0e4b39defad4bfae53.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*gjxK3hsF2Ks-1oHUtAFWug.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">创建一个main.py来看看主类的结构</figcaption></figure><p id="3b13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以现在，我们应该有下面的位，没有别的。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jp"><img src="../Images/7e9f1b11253476e32757154330481ff0.png" data-original-src="https://miro.medium.com/v2/resize:fit:374/format:webp/1*J2YZryES8JkP_fqYyt2y3w.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">主类</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jq"><img src="../Images/b0386c61aa56e4b052559d605cf977de.png" data-original-src="https://miro.medium.com/v2/resize:fit:306/format:webp/1*zYRjMlSHs2qgQrjgnW-Clw.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">要运行/调试的配置</figcaption></figure><p id="e3da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您通过上面绿色的run按钮运行它时，您应该看到以下内容</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jr"><img src="../Images/bbc0edb2f096de6236e157cd77e831d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:498/format:webp/1*v6deSzgX_B3hsETkVzU1GA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">耶，我们现在可以把python添加到我们的简历中了</figcaption></figure><p id="ed6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的任务是检查一个目录中的一些文件，但是这个目录会随着每次构建而改变，因此我们需要通过一个参数来获取这个目录。因此，让我们编辑我们的配置</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es js"><img src="../Images/8cb28b10382c72f9595dbdc9a19bb44f.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*1Dz4QjmGUY84GdM_Z2WXPw.png"/></div></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jt"><img src="../Images/f17fcf57f81239eedf9b1acba93e35c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*eMwv4FLPcB2WC28cZ083sg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">添加您想要检查包的任何目录</figcaption></figure><p id="c491" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，代码。让我们谈一谈。打开main.py并粘贴下面的代码。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e54a" class="jz ka hh jv b fi kb kc l kd ke">import sys<br/><br/><br/>def print_hi(name):<br/>    print(f'Hi, {name}')<br/><br/><br/>if __name__ == '__main__':<br/>    print_hi('PyCharm')<br/>    try:<br/>        directory_name = sys.argv[1]<br/>        print(directory_name)<br/>    except:<br/>        print('Please pass directory_name')</span></pre><p id="93e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在这里，我们导入sys模块，它执行以下操作(您可以在导入语句中通过ctrl+左键单击sys来查看详细信息)。简而言之，它允许访问cli参数。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="3737" class="jz ka hh jv b fi kb kc l kd ke"><em class="kf">"""<br/>This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter.<br/>Dynamic objects:<br/><br/>argv -- command line arguments; argv[0] is the script pathname if known<br/>...</em></span></pre><p id="33f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kf"> </em> <strong class="ig hi"> <em class="kf"> if </em> </strong>位是主类的开始。显然，所有代码都必须以空行结束。带有<strong class="ig hi"><em class="kf">print_hi(' py charm ')</em></strong>的下一部分在它上面一点的位置调用print _ hi方法，并打印传递的参数。还要注意导入、方法定义和主类之间的两行空格。Pyhton关心这些事情:d .缩进也很重要，因为没有像其他高级语言那样定义开始和结束的{}。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="9cf2" class="jz ka hh jv b fi kb kc l kd ke">def print_hi(name):<br/>    print(f'Hi, {name}')<br/></span><span id="ecdb" class="jz ka hh jv b fi kg kc l kd ke">if __name__ == '__main__':<br/>    print_hi('PyCharm')</span></pre><p id="bd1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另外，注意这一点。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f640" class="jz ka hh jv b fi kb kc l kd ke">    try:<br/>        directory_name = sys.argv[1]<br/>        print(directory_name)<br/>    except:<br/>        print('Please pass directory_name')</span></pre><p id="6fd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当您运行main.py时，您应该会得到；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kh"><img src="../Images/acf280162c38b0ec6aa34e5374a696a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*VOBgJgT0B8VGWMGE6tJDHg.png"/></div></figure><p id="10a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从main中删除def print_hi方法及其用法，然后继续在子目录中创建新文件，这样我们就不会像野蛮人一样将代码写入main.py。我假设这个逻辑在python中也成立。</p><p id="180f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我创造了一个这样的LoopHelper。注意__init__。py文件，它显然允许我们从main导入新文件(如果需要，也可以从其他文件导入)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ki"><img src="../Images/b58533fd2fa9e1af6de4b10e20454230.png" data-original-src="https://miro.medium.com/v2/resize:fit:356/format:webp/1*cjRl-GnRsSu2X1duWlJLig.png"/></div></div></figure><p id="ef58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">LoopHelper.py内容是这样的；</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="a255" class="jz ka hh jv b fi kb kc l kd ke">import os<br/><br/><br/>def loop_through(dir_name):<br/>    directory = os.fsencode(dir_name)<br/>    for file in os.listdir(directory):<br/>        filename = os.fsdecode(file)<br/>        if filename.endswith(".properties"):<br/>            print(os.path.join(directory, filename))<br/>            continue<br/>        else:<br/>            continue<br/></span></pre><p id="1662" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以基本上，我们已经创建了一个带有参数<strong class="ig hi">目录名</strong>的方法<strong class="ig hi"> loop_through </strong>。我们使用fsencode方法对<strong class="ig hi">目录名</strong>进行适当编码。然后我们列出并遍历文件，解码文件以获得路径，然后什么也不做。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="890e" class="jz ka hh jv b fi kb kc l kd ke"><strong class="jv hi"><em class="kf">os.fsencode()</em></strong> method in Python is used to encode the specified filename to the filesystem encoding with ‘<em class="kf">surrogateescape</em>‘ error handler, or ‘<em class="kf">strict</em>‘ on Windows;</span></pre><p id="a5a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们使用main中的新类，将它添加到最上面。基本上是文件夹结构，然后是类名。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="0493" class="jz ka hh jv b fi kb kc l kd ke">from classes.helpers import LoopHelper</span><span id="3eda" class="jz ka hh jv b fi kg kc l kd ke">...<br/>""" <br/>usage is like;<br/>FileName.ClassName.whateverMethod</span><span id="7652" class="jz ka hh jv b fi kg kc l kd ke">"""</span><span id="f2dd" class="jz ka hh jv b fi kg kc l kd ke">LoopHelper.LoopHelper().loop_through(sys.argv[1])</span></pre><p id="4730" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，有了这些信息，让我们修改我们的main.py如下，而我们在这里，让我们改变它的名字也像bundle_check.py</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="e933" class="jz ka hh jv b fi kb kc l kd ke">from classes.helpers import LoopHelper<br/>import sys<br/>import argparse<br/><br/>if __name__ == '__main__':<br/>    parser = argparse.ArgumentParser(<br/>        description='''Usage python PATHTO/bundle_check.py ROOTDIR ''')<br/>    parser.add_argument('path', nargs='*', default=[1], help='root dir to check for bundles')<br/>    args = parser.parse_args()<br/><br/>    print("Bundle check in dir: " + sys.argv[1])<br/>    LoopHelper.LoopHelper().loop_through(sys.argv[1])</span></pre><p id="6d7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一些额外的东西。最后两行是我们知道的，它表示我以dir的形式获得了这个参数，并将arg传递给loop_through方法。</p><p id="e289" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果有人使用我们的脚本，比如弹出的<strong class="ig hi"> python bundle_check.py -h </strong>，上面的几行是为了提供帮助；</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es kn"><img src="../Images/8c2ce1637b5789d8e5ff52ed8e870730.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*K8KSzdhDpVD0u3lMhRzi3Q.png"/></div></figure><p id="1ee0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在主要的工作是LoopHelper类。我把它分成了几个部分，</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="435e" class="jz ka hh jv b fi kb kc l kd ke">import os<br/>import mmap<br/>import sys</span><span id="4277" class="jz ka hh jv b fi kg kc l kd ke"><br/>class LoopHelper:<br/>    <em class="kf">"""<br/>    Main Helper class containing the logic for bundle checking.<br/><br/>    Depending on the failed value;<br/>    return sys.exit 1 if failed is true,<br/>    return sys.exit 0 if failed is false<br/>    """<br/><br/>    </em>TR_POSTFIX = '_tr.'<br/>    EN_POSTFIX = '_en.'<br/>    BUNDLE_EXT = 'properties'<br/>    TR_BUNDLE_EXT = TR_POSTFIX + BUNDLE_EXT<br/>    EN_BUNDLE_EXT = EN_POSTFIX + BUNDLE_EXT<br/>    failed = 0<br/>...</span></pre><p id="f972" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">LoopHelper类有几个常量，我们将使用它们来检查文件匹配操作。失败是我们将要玩的一个职业领域。如果我们得到一个包不匹配，这将被设置，所以应用程序将退出代码1，否则应用程序将退出代码0。</p><p id="564e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们看看方法；</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="fdea" class="jz ka hh jv b fi kb kc l kd ke">def analyse_files(self, root_dir):<br/>def nitpick(self, source_file, target_file, target_postfix):</span></pre></div><div class="ab cl ko kp go kq" role="separator"><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt ku"/><span class="kr bw bk ks kt"/></div><div class="ha hb hc hd he"><p id="8d56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">analyse_files使用目录来工作，并使用os.walk递归遍历文件的所有目录。对于目录中的每个文件，它将目录名与文件名合并以获得完整的路径。</p><p id="635a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，它检查文件名是否与_tr.properties的包扩展名匹配，并生成预期的_en等价物。这两个文件路径都被发送到pick方法进行检查。这同样适用于相反的情况。</p><p id="db3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果出现问题，它会设置失败标志并列出有问题的文件。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="cbeb" class="jz ka hh jv b fi kb kc l kd ke">def analyse_files(self, root_dir):<br/>    <em class="kf">"""<br/>    Prepares for analyses of files in work dir<br/>    Checks for existence of TR_BUNDLE_EXT file, tries to find related EN_BUNDLE_EXT file and sends<br/>    it to nitpick method and vice versa.<br/><br/>    Sets failed to 1 if any label or file is missing.<br/><br/>    </em><strong class="jv hi"><em class="kf">:param</em></strong><em class="kf"> root_dir: the root dir to check for bundles<br/>    """<br/>    </em>for dir_path, dir_name, files in os.walk(root_dir):<br/>        for file in files:<br/>            complete_path = os.path.join(dir_path, file)<br/>            try:<br/>                if file.endswith(self.TR_BUNDLE_EXT):<br/>                    tr_file_path = ""<br/>                    en_file_path = complete_path.replace(self.TR_POSTFIX, self.EN_POSTFIX)<br/>                    self.nitpick(complete_path, en_file_path, self.EN_POSTFIX)  # check for missing tr items in en<br/><br/>                if file.endswith(self.EN_BUNDLE_EXT):<br/>                    en_file_path = ""<br/>                    tr_file_path = complete_path.replace(self.EN_POSTFIX, self.TR_POSTFIX)<br/>                    self.nitpick(complete_path, tr_file_path, self.TR_POSTFIX)  # check for missing en items in tr<br/>            except Exception as generic:<br/>                self.failed = 1<br/>                print(generic)<br/>                print('Related files:\n' + (en_file_path or complete_path)<br/>                      + '\n' + (tr_file_path or complete_path) + '\n')</span></pre><p id="deae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在吹毛求疵的方法完全是另外一回事。它接受一个带有目标后缀的源文件和目标文件(因为我不想再费事去找它了)，并打开source进行循环，目标作为只读内存映射来查找所述标签。如果它不能在目标中找到标签，它设置失败，但继续前进。这是为了向开发人员展示所有缺失的包，并减轻我们不断构建的负担。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="16a8" class="jz ka hh jv b fi kb kc l kd ke">def nitpick(self, source_file, target_file, target_postfix):<br/>    <em class="kf">"""<br/>    Tries to find labels in source file in target file<br/>    </em><strong class="jv hi"><em class="kf">:param</em></strong><em class="kf"> source_file:<br/>    </em><strong class="jv hi"><em class="kf">:param</em></strong><em class="kf"> target_file:<br/>    </em><strong class="jv hi"><em class="kf">:param</em></strong><em class="kf"> target_postfix: The target postfix to easily find missing label harboring files<br/>    """<br/>    </em>with open(source_file) as file, open(target_file) as file_en:<br/>        mmap_en_file = mmap.mmap(file_en.fileno(), 0, access=mmap.ACCESS_READ)  # get mmap for en file<br/>        for bundle_line in file:  # bundle lines in source file<br/>            if bundle_line.find('=') &gt;= 0:<br/>                bundle_key = bundle_line[0:bundle_line.find('=')].strip()  # get bundle key<br/><br/>                if mmap_en_file.find(bundle_key.encode()) == -1:<br/>                    # if not able to find line in target file, set as failed<br/>                    print('Key-val pair -&gt; ' + os.path.basename(<br/>                        source_file) + ' : ' + bundle_key + ' not found in ' + target_postfix)<br/>                    self.failed = 1</span></pre><p id="dbe3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实际上差不多就是这样。此脚本使用以下命令运行；</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="f655" class="jz ka hh jv b fi kb kc l kd ke">python bundle_check.py DIR_TO_CHECK</span></pre><p id="916c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以集成到管道中，如下所示，因为它返回失败代码1。</p><pre class="je jf jg jh fd ju jv jw jx aw jy bi"><span id="1c49" class="jz ka hh jv b fi kb kc l kd ke">python bundle_check.py DIR_TO_CHECK <!-- -->&amp;&amp; echo 'OK' || echo 'Not OK'</span></pre><p id="f5aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有些地方可以改进，我们很乐意听听您的想法。感谢阅读。</p></div></div>    
</body>
</html>