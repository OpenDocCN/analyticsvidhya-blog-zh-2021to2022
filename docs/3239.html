<html>
<head>
<title>Memory Management in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的内存管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/memory-management-in-python-4332fbf95cd0?source=collection_archive---------12-----------------------#2021-06-20">https://medium.com/analytics-vidhya/memory-management-in-python-4332fbf95cd0?source=collection_archive---------12-----------------------#2021-06-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/13f1113f202e2ec57761680868f4a03f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*M58Q64vCpkLOcwya9eMcsw.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx translated"><a class="ae ip" href="https://unsplash.com/@huchenme?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">陈虎</a>在<a class="ae ip" href="https://unsplash.com/s/photos/elephant?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="67e4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">记忆对我来说一直是一个难以捉摸的话题，除了我知道在我的<code class="du jo jp jq jr b">C++</code>类中有一些术语，比如‘按值传递’，‘按引用传递’，‘析构函数’，‘seg fault’，我很明显地失败了。一年后重考这门课时，这次用Java语言授课，成绩很好，GPA飙升。“内存泄漏”又是我在后来的课上听到的一个听起来不祥的术语。在此之前，我遇到过“煤气泄漏”、“水泄漏”；这种“内存泄漏”会有多严重？</p><p id="6b98" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里我们将学习Python中的<strong class="is hi">变量</strong>、<strong class="is hi">内存地址</strong>、<strong class="is hi">引用计数</strong>、<strong class="is hi">内存泄漏</strong>和<strong class="is hi">垃圾收集</strong>。<code class="du jo jp jq jr b">tracemalloc</code>用于到达文章末尾。</p><p id="7d36" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Python中的变量是一个<strong class="is hi">引用</strong>到<strong class="is hi">的内存地址</strong>。那么什么是内存地址呢？嗯，内存地址是一个像<strong class="is hi">一样唯一保存对象的位置</strong>。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es js"><img src="../Images/d757ad5385dd331e2497fd254fdffdb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/format:webp/1*--CagwTwVd2C0cDynItnpw.png"/></div><figcaption class="il im et er es in io bd b be z dx translated">带有标记内存地址的堆中对象的示意图</figcaption></figure><p id="27ad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们检查这个变量赋值:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="35a1" class="kb kc hh jr b fi kd ke l kf kg">our_var = 12</span></pre><p id="c143" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里的变量<code class="du jo jp jq jr b">our_var</code>实际上是<strong class="is hi">引用</strong>到<strong class="is hi">保存对象的堆中的内存地址</strong>。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kh"><img src="../Images/e62c878571601ba7798251237d6305c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*oVy1BRYj8F68eNbZMHluQg.png"/></div><figcaption class="il im et er es in io bd b be z dx translated">显示引用存储器地址的变量的示意图</figcaption></figure><p id="18fd" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">我们可以使用<code class="du jo jp jq jr b">id()</code>方法，该方法采用变量名来获取以10为基数的内存地址，通过引用传递。要获得十六进制的内存地址，使用<code class="du jo jp jq jr b">hex()</code>方法，该方法将来自<code class="du jo jp jq jr b">id()</code>的值作为参数，按值传递。</p><p id="0932" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在Python中，我们不能直接访问内存。然而，我们有<code class="du jo jp jq jr b">ctypes</code>模块从内存地址获取值。</p><p id="52de" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里有一个例子:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="f1e1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">运行该文件时，我们会得到以下结果:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="42b7" class="kb kc hh jr b fi kd ke l kf kg">id = 140684875197072<br/>hex id: = 0x7ff3c002ea90<br/>Value from address 140684875197072 is 12</span></pre><p id="e0c1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><em class="kk">注意</em>:确保使用<code class="du jo jp jq jr b">ctypes.cast</code>时，您给出的地址是以10为基数的。尝试给出十六进制值，你会得到<code class="du jo jp jq jr b">bus error</code>。</p><p id="9361" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为了跟踪对一个对象的引用，我们有一个叫做<strong class="is hi">引用计数</strong>的机制。它记录了<strong class="is hi">有多少个变量</strong>引用了一个<strong class="is hi">相同的内存地址</strong>。</p><p id="8996" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在Python中，我们可以通过使用两个模块<code class="du jo jp jq jr b">sys</code>和<code class="du jo jp jq jr b">ctype</code>来获得引用计数。<code class="du jo jp jq jr b">ctype</code>比<code class="du jo jp jq jr b">sys</code>少1个值，因为<code class="du jo jp jq jr b">sys</code>将变量名作为输入，增加1个值，而<code class="du jo jp jq jr b">ctype</code>直接取内存地址。</p><p id="001a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">你能看出哪个是按引用传递的，哪个是按值传递的吗？</p><p id="c916" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们看一个例子:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="2a10" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">运行该文件时，我们得到:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="89f0" class="kb kc hh jr b fi kd ke l kf kg">our_var object reference count using sys module: 4<br/>our_var object reference count using ctypes module:3</span><span id="4848" class="kb kc hh jr b fi kl ke l kf kg">🌼 Adding variable `my_var` reference to `our_var` object 🌼</span><span id="5ff7" class="kb kc hh jr b fi kl ke l kf kg">our_var object reference count using sys module: 5<br/>our_var object reference count using ctypes module: 4</span><span id="93ef" class="kb kc hh jr b fi kl ke l kf kg">🌺 Deleting variable `my_var` reference to `our_var` object 🌺</span><span id="f35f" class="kb kc hh jr b fi kl ke l kf kg">our_var object reference count using sys module: 4<br/>our_var object reference count using ctypes module: 3</span></pre><p id="2154" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">你可以看到，使用<code class="du jo jp jq jr b">sys</code>和<code class="du jo jp jq jr b">ctypes</code>模块时，<code class="du jo jp jq jr b">our_var</code>对象的初始引用计数分别是4和3。在添加引用相同内存地址<code class="du jo jp jq jr b">our_var</code>的<code class="du jo jp jq jr b">my_var</code>对象时，我们将引用计数增加1。删除<code class="du jo jp jq jr b">my_var</code>对象后，我们返回到原始引用计数。</p><p id="9515" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为什么使用<code class="du jo jp jq jr b">sys</code>模块的原始引用计数给出的是4而不是2？<em class="kk">这两个引用的含义一个是被变量</em> <code class="du jo jp jq jr b"><em class="kk">our_var</em></code> <em class="kk">引用，另一个是通过</em> <code class="du jo jp jq jr b"><em class="kk">our_var</em></code> <em class="kk">打印</em>时引用。好问题！这是因为Python的编译器可能会有一些其他变量引用同一个字符串对象。</p><p id="5e1d" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在我们来看一下<strong class="is hi">垃圾收集</strong>。</p><p id="9ce8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">垃圾收集的工作是在<strong class="is hi">引用计数</strong>达到<strong class="is hi"> 0 </strong>后<strong class="is hi">回收</strong>内存地址。</p><p id="6111" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">Python有一个名为<code class="du jo jp jq jr b">gc</code>的模块，让我们可以检查或配置它。让我们使用<code class="du jo jp jq jr b">get_objects()</code>方法来获得它所列出的对象的长度。</p><p id="97d4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">让我们看一个例子:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="b674" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">示意性地看一下这个类:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es km"><img src="../Images/59ca9beaceb99b6571cc30e076b1b5bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*MWooxLg3ackFpVptc6_-mQ.png"/></div><figcaption class="il im et er es in io bd b be z dx translated">类Serval和Cat的实例</figcaption></figure><p id="d0c3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">运行该文件时，我们得到:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="16b6" class="kb kc hh jr b fi kd ke l kf kg">BEFORE: 5199</span><span id="2bab" class="kb kc hh jr b fi kl ke l kf kg">REFERENCE COUNT<br/>servy's reference count: 1<br/>whiky's reference count: 1</span><span id="a133" class="kb kc hh jr b fi kl ke l kf kg">AFTER CREATION: 5218</span><span id="4273" class="kb kc hh jr b fi kl ke l kf kg">AFTER DELETION: 5219</span></pre><p id="2a07" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">删除两个对象<code class="du jo jp jq jr b">servy</code>和<code class="du jo jp jq jr b">whiky</code>后，垃圾收集器列表中的对象只增加了1个(5219–5218 ),这让我有点惊讶。我的假设是，由于垃圾收集器是一个守护线程，它会以一种<em class="kk">自由放任</em>的方式找到另一个线程。也可能是编译器做了一些优化。如果你愿意，可以尝试一下。在这种情况下，<code class="du jo jp jq jr b">servy</code>和<code class="du jo jp jq jr b">whiky</code>的引用计数在删除时达到0，因为它们的初始引用计数是1。</p><p id="9bdd" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">然而，事实并非总是如此。我们有时会有循环引用。</p><p id="30d4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以此为例:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="a8da" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">示意性地看一下这些类:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kn"><img src="../Images/d4f953c3d7ce015d1b156683e98b0df9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*iyTqAMCvwc2dIc9r1BSf1g.png"/></div><figcaption class="il im et er es in io bd b be z dx translated">两个类Serval和Cat之间的循环引用</figcaption></figure><p id="a361" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在运行该文件时，我们得到</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="9b70" class="kb kc hh jr b fi kd ke l kf kg">servy's refcount: 2<br/>whiky's refcount: 2<br/>AFTER DELETION OF servy<br/>whiky's refcount: 2</span></pre><p id="4c9a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">你发现什么不对劲了吗？删除<code class="du jo jp jq jr b">whiky</code>所指向的<code class="du jo jp jq jr b">servy</code>实例后，<code class="du jo jp jq jr b">whiky</code>的引用计数仍然是2。这叫做循环引用，导致<strong class="is hi">内存泄漏</strong>！</p><p id="5baf" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因为我们特意编写了这段代码来演示它，所以我们可以通过将<code class="du jo jp jq jr b">whiky</code>的表亲分配给<code class="du jo jp jq jr b">None</code>来摆脱这种情况。</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="ae7f" class="kb kc hh jr b fi kd ke l kf kg">whiky.cousin = None</span></pre><p id="88da" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这使得<code class="du jo jp jq jr b">whiky</code>的引用计数为1，之后我们可以通过删除<code class="du jo jp jq jr b">whiky</code>实例将其引用为0。</p><p id="2ead" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在大型代码库中，找出哪里发生了内存泄漏可能是一项单调乏味的任务。幸运的是，我们有一个内存泄漏调试工具叫做<a class="ae ip" href="https://docs.python.org/3/library/tracemalloc.html" rel="noopener ugc nofollow" target="_blank"> <strong class="is hi"> tracemalloc </strong> </a>。</p><p id="c43b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">您可以询问我们希望保存多少堆栈帧，获取感兴趣的代码区域的快照，并进行比较。我们甚至有一个属性<code class="du jo jp jq jr b">lineno</code>，它会告诉我们代码库中的哪一行占用了大量资源。因此，帮助我们缩小搜索空间，并最终达到我们的目标。</p><p id="26d1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">对于python 3.4以上的版本，垃圾收集器能够清理导致内存泄漏的对象。</p><p id="8a6b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果你想看我瞎折腾，这里有一个带有<code class="du jo jp jq jr b">tracemalloc</code>模块的代码库:</p><figure class="jt ju jv jw fd ii"><div class="bz dy l di"><div class="ki kj l"/></div></figure><p id="8718" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">输出如下所示:</p><pre class="jt ju jv jw fd jx jr jy jz aw ka bi"><span id="567c" class="kb kc hh jr b fi kd ke l kf kg">servy's refcount: 2<br/>whiky's refcount: 3<br/>whiky's refcount after deleting grace: 2<br/>whiky's refcount after deleting circular reference: 1<br/>servy's refcount after deleting circular reference: 1<br/>.../medium/memory_management/circular_reference_2.py:19: size=424 B (+424 B), count=1 (+1), average=424 B<br/>.../medium/memory_management/circular_reference_2.py:18: size=424 B (+424 B), count=1 (+1), average=424 B<br/>/Library/Frameworks/Python.framework/Versions/3.9/lib/python3.9/tracemalloc.py:423: size=88 B (+88 B), count=2 (+2), average=44 B</span></pre><p id="63f0" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">希望这是一篇有帮助的文章，并准备好深入更深层次的高级代码转换！</p><p id="87a6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">恭喜你，感谢你的阅读！我很快会发表下一篇文章。🐛</p><p id="d6b3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">参考:</p><ul class=""><li id="a0e5" class="ko kp hh is b it iu ix iy jb kq jf kr jj ks jn kt ku kv kw bi translated"><a class="ae ip" href="https://www.udemy.com/course/python-3-deep-dive-part-1/" rel="noopener ugc nofollow" target="_blank"> Python 3:深潜</a></li></ul></div></div>    
</body>
</html>