<html>
<head>
<title>Machine Learning - Analysis of Weather in Szeged 2006–2016 To Predict the Apparent Temperature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习-分析Szeged 2006-2016年的天气以预测表观温度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-analysis-of-weather-in-szeged-2006-2016-to-predict-the-apparent-temperature-76f195c2ec60?source=collection_archive---------6-----------------------#2021-06-26">https://medium.com/analytics-vidhya/machine-learning-analysis-of-weather-in-szeged-2006-2016-to-predict-the-apparent-temperature-76f195c2ec60?source=collection_archive---------6-----------------------#2021-06-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="0f80" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">通过线性回归</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es jg"><img src="../Images/216fe9eeefa0d19589bc4680d30ad26c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H1gyY1CnJVirr5AYq34Jcw.jpeg"/></div></div></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="14fe" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">用例:湿度和温度有关系吗？湿度和表观温度之间呢？给定湿度，你能预测表观温度吗？</p><p id="b6b7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">数据集:<a class="ae kc" href="https://www.kaggle.com/budincsevity/szegedweather?select=weatherHistory.csv" rel="noopener ugc nofollow" target="_blank">查看数据集</a></p><p id="1eda" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">要做练习，你可以从上面的链接下载数据集。</p><p id="d720" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">首先我们必须导入一些库。因为大多数python库都有一组有用的函数，可以简单地消除从头编写代码的需要。所以我导入了下面的库。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="636f" class="ki kj hh ke b fi kk kl l km kn">import numpy as np<br/>import pandas as pd<br/>import scipy.stats as stats <br/>from matplotlib import pyplot as plt</span><span id="4c6b" class="ki kj hh ke b fi ko kl l km kn">%matplotlib inline<br/>                   <br/>from sklearn.preprocessing import StandardScaler</span></pre><p id="1090" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">Pandas主要用于逗号分隔值、JSON、SQL、Microsoft Excel等各种文件格式的数据分析。此外，它可以做一些数据操作，如合并，整形，选择，清理等。更多的库我会在需要的地方解释。</p><p id="576a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我已经添加了以下代码，用于将google drive帐户安装到google colaboratory，以访问drive上可用的文件。当我们执行下面的代码时，我们必须转到生成的URL，并获得授权代码才能进入这里。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="4c99" class="ki kj hh ke b fi kk kl l km kn">from google.colab import drive<br/>drive.mount("/content/gdrive")</span></pre><p id="936c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输入授权码后。您将收到一条消息，显示“安装在<a class="ae kc" href="https://colab.research.google.com/drive/1XcLXQSvTYMfUL0ic6IUTLLitWWYs3p7j?authuser=1#" rel="noopener ugc nofollow" target="_blank">/内容/驱动器</a>”。此后，通过下面的代码，您可以访问您连接的google drive上的文件。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="c9fa" class="ki kj hh ke b fi kk kl l km kn">data = pd.read_csv('/content/gdrive/My Drive/Colab Notebooks/data/weatherHistory.csv')</span></pre><p id="e0ca" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">现在，您已经成功地将数据加载到名为“data”的变量中。出于修改的目的，我将数据复制到另一个名为“X”的变量中</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="531f" class="ki kj hh ke b fi kk kl l km kn">X = data.copy() #dataset has been copied to  X</span></pre><p id="9adc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，您可以看到该变量中存储的前10个数据行。Pandas库提供了一个名为head()的方法，广泛用于返回一个数据帧或系列的前n行。默认情况下，该方法返回存储数据集的前5行。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="449f" class="ki kj hh ke b fi kk kl l km kn">X.head(10)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es kp"><img src="../Images/29941611241780f34c7f613e0b2c178f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*boKyVJRyQtvfxu5E"/></div></div></figure><h1 id="2da3" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01数据预处理</h1><p id="4511" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">数据预处理是机器学习中的一个主要步骤，因为从数据集中获得的有用信息直接影响模型的质量，所以在将数据输入模型之前，对数据进行必要的预处理是非常重要的。</p><h1 id="ad70" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01 A -&gt;数据清理-识别和处理缺失值、重复记录</h1><p id="f9f7" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">按照下面的代码，我们可以确定每列数据中缺少的值</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="e437" class="ki kj hh ke b fi kk kl l km kn">X.isnull().any()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ls"><img src="../Images/1c898ec304bfa698676a247fd3aaf820.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/0*nmUdAxSc_K9Vpy1o"/></div></figure><p id="c43f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">在上面的输出中，我们可以看到Precip类型为True。平衡是虚假的。因此，我们可以得出结论，Precip类型有一些缺失值，而balance特征没有缺失值。所以我们必须处理那些丢失的值。为此，我们必须检查给定值中缺失值的百分比。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="88c1" class="ki kj hh ke b fi kk kl l km kn">X['Precip Type'].value_counts() # To get the count of each available types</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lt"><img src="../Images/c7772aa93c062d646937342912ca8b36.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/0*uU-LJaBtIdJIx6ma"/></div></figure><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="5efd" class="ki kj hh ke b fi kk kl l km kn">(X['Precip Type'].isnull().sum()/len(X.index) )*100 # To check the null values percentage in available data set</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lu"><img src="../Images/20bfbb707e0cbca1974a1ed48a2c797d.png" data-original-src="https://miro.medium.com/v2/resize:fit:438/0*x3qeu2v5i6xx-do3"/></div></figure><p id="7a01" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的输出百分比值中，我们可以说空值占可用数据的百分比非常小。因此，我们可以删除那些空值行，并为进一步的预处理活动获取余额数据。通过下面的代码，我们可以删除空值</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b290" class="ki kj hh ke b fi kk kl l km kn">X = X.dropna() #drop all nan values in given data set<br/>X.isnull().sum() # For the verification.</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lv"><img src="../Images/aa175f5e4c2039e02f7a42290a3d610c.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/0*uMy8KZs39tkLmlTJ"/></div></figure><p id="d91b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">在上面的输出中，所有的值都是零，所以现在我们可以得出结论，在数据集中没有任何nan值。</p><p id="d195" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以检查数据集中的重复行。在下面的输出中，您可以看到24个值为True，95912个值为False。所以我们可以得出这个数据集有24个重复值的结论。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="38f4" class="ki kj hh ke b fi kk kl l km kn">print(X.duplicated().value_counts()) # To check duplicated values</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lw"><img src="../Images/7124d3c21f547f28623dea6213a83cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/0*w2lSsXwjyhwZR9XG"/></div></figure><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="cc6b" class="ki kj hh ke b fi kk kl l km kn">print(X[X.duplicated()]) # To check view the duplicated values</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lx"><img src="../Images/12cc2d4d43bdf9820b83ef4c17a3f485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*P59VuNx9yUD0xJ9h"/></div></div></figure><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="6c48" class="ki kj hh ke b fi kk kl l km kn">X=X.drop_duplicates() # To drop the duplicate values<br/>print(X.duplicated().value_counts()) # To check duplicated values</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ly"><img src="../Images/a97cd9b7d0fa006da2f7266321c3c0be.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/0*4ZiSodS3Wx3-5y8m"/></div></figure><p id="bba3" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的输出我们可以得出结论，数据集中没有重复的行</p><h1 id="51db" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01 B -&gt;数据清理——识别和处理异常值</h1><p id="f391" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">离群值被称为明显偏离其他对象的对象。它可能是由不同类型的错误引起的。因此，我们必须对给定的数据集进行离群点分析，以获得高质量的模型。</p><p id="e5b5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以得到连续的列名，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="8dab" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>X._get_numeric_data().columns.tolist()</span></pre><p id="8f4a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">上述代码的输出是['温度'，'表观温度'，'湿度'，'风速(km/h)'，'风向(度)'，'能见度(km)'，'大声覆盖'，'压力(毫巴)']，因此我们可以对这些列进行分析。</p><p id="2aca" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">温度柱的箱线图和Q-Q图</p><p id="20c5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="11e5" class="ki kj hh ke b fi kk kl l km kn">temp_df = pd.DataFrame(X, columns=['Temperature (C)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es lz"><img src="../Images/1eae11754f7649284046761c9f12b144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JTpKgrHZbx2QMlD8"/></div></div></figure><p id="3463" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2eea" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X["Temperature (C)"], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ma"><img src="../Images/19bb6185656196138d8ba54f0203fab6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/0*W7l9Nv6iEKBkt6tz"/></div></figure><p id="be03" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">表观温度柱的箱线图和Q-Q图</p><p id="2279" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="64c7" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Apparent Temperature (C)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mb"><img src="../Images/f1aac9dd52b4b68e8aca16b48963df22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NBCBnsXswTxXHon_"/></div></div></figure><p id="1bcd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="db49" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Apparent Temperature (C)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ma"><img src="../Images/92776fdd48b3daf461b81fef082dfb6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/0*p_cQicNfV8baB9MO"/></div></figure><p id="e2ae" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">风速(km/h)柱的箱线图和Q-Q图</p><p id="ca53" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b288" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Wind Speed (km/h)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mc"><img src="../Images/37fc221fbd7a216aef4631fb26a69dda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QU8xOPu2yfPOjS-j"/></div></div></figure><p id="2a7b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="95af" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Wind Speed (km/h)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ma"><img src="../Images/f89a981c6a4e2bd50c543f425d54fecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/0*h-SfdYPAN61QcsJH"/></div></figure><p id="61db" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">风向(度)柱的箱线图和Q-Q图</p><p id="2d9f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="6368" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Wind Bearing (degrees)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es md"><img src="../Images/1b36a7392feb5280db934edec1849f30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*omvcnRfwf9kN9Zgx"/></div></div></figure><p id="c7de" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="c8e9" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Wind Bearing (degrees)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es me"><img src="../Images/14de397aa825a0a6d432c8b1b5d8e17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/0*w7lBsQDBcXqZSOZv"/></div></figure><p id="88f9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">能见度(公里)柱的箱线图和Q-Q图</p><p id="369b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0745" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Visibility (km)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mf"><img src="../Images/6548903a303aa64a0fbd3bf43ee6a965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NizEATPPxTGhfNm4"/></div></div></figure><p id="9c70" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="56b3" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Visibility (km)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mg"><img src="../Images/b11dd3f2fe555c8cf29d4eedd2a133a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/0*W-H8lzPxyE8zJZeg"/></div></figure><p id="b2fa" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">大声盖柱的箱线图和Q-Q图</p><p id="0839" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="8903" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Loud Cover'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mh"><img src="../Images/8272643a1778815bda38f89d7ef1fd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9uM-lRXiwKjvVHzE"/></div></div></figure><p id="1e17" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="d4b3" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Loud Cover'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mi"><img src="../Images/973fc58a4b66fe9e58fb1384090fad33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/0*mfVkjDZ8kSO0v46Q"/></div></figure><p id="5ae8" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以通过下面的注释来查看“大声盖”的值计数，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0d27" class="ki kj hh ke b fi kk kl l km kn">X['Loud Cover'].value_counts()</span></pre><p id="9e80" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是0.0 95912</p><p id="b79d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的值和“大声掩盖”的箱线图，我们可以得出结论，没有使用保留该列。因为所有的值都是零。所以我们可以按照下面代码从数据集中删除该列，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="5950" class="ki kj hh ke b fi kk kl l km kn">X = X.drop('Loud Cover', axis = 1)</span></pre><p id="59bd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">压力(毫巴)柱的箱线图和Q-Q图</p><p id="b073" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="14b1" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Pressure (millibars)'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mj"><img src="../Images/68aee9013e1efaaa4a3b0a43740d9823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nuHV9ixfOkFJxdtZ"/></div></div></figure><p id="53f7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="ce66" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Pressure (millibars)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mk"><img src="../Images/ca87f769e4ce47834d0e9f7f1860d182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*4N0JQlR9empPYdKH"/></div></div></figure><p id="bd33" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的箱线图和下面的计数中，我们可以看到一些异常情况。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="94c6" class="ki kj hh ke b fi kk kl l km kn">X['Pressure (millibars)'].value_counts()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ml"><img src="../Images/85b6fc5f06c27c50e96d24a2e2d11435.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/0*wzu9WusXAO6_mlZ4"/></div></figure><p id="87be" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以得到给定列的描述，如平均值，计数，标准差，最小值等。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="ebbd" class="ki kj hh ke b fi kk kl l km kn">X['Pressure (millibars)'].describe()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mm"><img src="../Images/bc5f90dcfff3d2024809257f9d235027.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/0*eqboo4RqMb53Ac0p"/></div></figure><p id="288b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制图表上的点来检查值变化的模式，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="fefc" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (500, 8)<br/>plt.plot(X['Pressure (millibars)'].tolist(), label="Pressure")<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mn"><img src="../Images/34435625d43cf6a9a19d660ce558a976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PPnvP4J5BL_oLyBO"/></div></div></figure><p id="cab1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">在上图中，我们可以看到相当多的压降等于零。这可能是由于测量机器的误差造成的。被广泛接受的空间开始的边界，也是假设气压为零的点，被称为卡门线，位于100公里(62英里)以上。因此，该列中不可能有零值或小于零值的值。</p><p id="e36e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以计算给定列中零值或小于零值的百分比。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="d36a" class="ki kj hh ke b fi kk kl l km kn">len(X[(X['Pressure (millibars)']&lt;=0.0) ])* 100/len(X)</span></pre><p id="34dc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi">1.342897656184836</p><p id="8cfc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过遵循下面的代码，我们可以重置数据帧的索引，以避免在未来的步骤中出现问题。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2c22" class="ki kj hh ke b fi kk kl l km kn">X=X.reset_index(drop=True)</span></pre><p id="05dc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过以下代码，我们可以将np.nan指定为压力列中零值，以指定合适值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="ecf2" class="ki kj hh ke b fi kk kl l km kn">X.loc[X.index[X['Pressure (millibars)']&lt;=0.0].tolist(), ['Pressure (millibars)']] =np.nan</span></pre><p id="29a1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以通过下面的代码来检查我们是否已经正确地赋值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7103" class="ki kj hh ke b fi kk kl l km kn">X['Pressure (millibars)'].isnull().sum() # Verification</span></pre><p id="14f2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是1288。</p><p id="cfe5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过以下代码，我们可以为压力列中np.nan值分配合适值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="1e19" class="ki kj hh ke b fi kk kl l km kn">from sklearn.impute import SimpleImputer<br/>imputer = SimpleImputer()<br/>imputer.fit(X[['Pressure (millibars)']])<br/>X['Pressure (millibars)']=imputer.fit_transform(X[['Pressure (millibars)']])</span></pre><p id="3f69" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以通过下面的代码来检查我们是否已经通过SimpleImputer正确地赋值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7889" class="ki kj hh ke b fi kk kl l km kn">X['Pressure (millibars)'].isnull().sum() # Verificaion</span></pre><p id="e40b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi">0</p><p id="db7b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">使用简单的估算器后，在图形上可视化，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="5212" class="ki kj hh ke b fi kk kl l km kn">plt.plot(X['Pressure (millibars)'].tolist(), label="Pressure")<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mo"><img src="../Images/7ff1c0b0bcbb62b979b4082bdcb96d4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6qE8ffEW71wM3ocz"/></div></div></figure><p id="ece4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">使用简单估算器后的概率图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="9704" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Pressure (millibars)'], dist="norm", plot=plt)<br/>plt.show()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mk"><img src="../Images/81b85a7e9f8b53495e4cca772bdb1851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/0*CQhvYifRc-pdMqpT"/></div></div></figure><p id="e62a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">湿度柱的箱线图和Q-Q图</p><p id="2c3a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的箱线图来检查异常值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7c2e" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (22, 3)<br/>temp_df = pd.DataFrame(X, columns=['Humidity'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mp"><img src="../Images/382be9e2324952147d4d2b9b433560a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*riMXMxKSVqgZC1lg"/></div></div></figure><p id="b56f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制给定列的概率图，以检查分布模式，取值范围等。,</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="a1f7" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (10, 6)<br/>stats.probplot(X['Humidity'], dist="norm", plot=plt)<br/>plt.show()</span></pre><p id="61c7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">a</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mq"><img src="../Images/d0370561574c09963f5f057f5e49e4d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/0*9G00FLScMNtKvuqx"/></div></figure><p id="812c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的图中我们可以看到一些值为0。但是实际上不可能具有零值或小于正常环境下值。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2432" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (500, 8)<br/>plt.plot(X['Humidity'].tolist(), label="Humidity")<br/>plt.show()</span></pre><p id="945b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过使用上面的代码，我们可以绘制图表来查看值的变化模式。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mr"><img src="../Images/453d1158bc03b9cda838b1cef17bd067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LJsb1wtdHU34LSA-"/></div></div></figure><p id="4a08" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以使用下面的代码来检查数据集上零值的百分比。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="41c5" class="ki kj hh ke b fi kk kl l km kn">len(X[(X['Humidity']&lt;=0.0) ])* 100/len(X)</span></pre><p id="85dc" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi">0.022937692885144717</p><p id="0b90" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以得到给定列的描述，如平均值，计数，标准差，最小值等。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="682d" class="ki kj hh ke b fi kk kl l km kn">X['Humidity'].describe()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ms"><img src="../Images/0630214d545930e5daf103fe6da39456.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/0*F6IIIJpLrV4MA-qt"/></div></div></figure><p id="3d15" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">根据以上证据，我们可以说湿度的异常值很少。因此，通过下面的代码，我们可以删除数据集中的那些值行。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b44b" class="ki kj hh ke b fi kk kl l km kn">X.drop(X[X['Humidity'] == 0].index, inplace = True)</span></pre><p id="b9e1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">如果我们通过下面的代码在每次删除行值后都重置了索引，我们可以避免将来在连接列或拆分数据集时出现一些错误。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="5475" class="ki kj hh ke b fi kk kl l km kn">X=X.reset_index(drop=True)</span></pre><h1 id="af6c" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01 C -&gt;数据编码</h1><p id="07ba" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">ML模型要求所有输入和输出值都应该是数字。因此，如果数据集包含分类数据，您必须在拟合和评估模型之前将其编码为数字。有几种方法可以完成这项任务，如一键编码、整数(标签)编码。这里我使用了整数(标签)编码，因为一次性编码不能自动处理测试集中的新类别。</p><p id="8d83" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过使用以下代码，我们可以对“Precip类型”、“Summary”进行分类。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="5d86" class="ki kj hh ke b fi kk kl l km kn">from sklearn.preprocessing import LabelEncoder<br/>labelencoder =LabelEncoder()<br/></span><span id="9ec1" class="ki kj hh ke b fi ko kl l km kn">X['Precip_Types_cat']=labelencoder.fit_transform(X['Precip Type']) <br/>X = X.drop('Precip Type', axis = 1) </span><span id="d8e9" class="ki kj hh ke b fi ko kl l km kn">X['Summary_cat']=labelencoder.fit_transform(X['Summary'])<br/>X = X.drop('Summary', axis = 1)</span></pre><p id="23be" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">在数据编码之后，我删除了原来的列。上面的代码片段也提供了这些代码。</p><h1 id="1cab" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01 C -&gt;特征离散化</h1><p id="69c4" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">特征离散化是指将特征或变量的连续值划分或转换为离散化的或标称的特征或区间的过程。这里我使用了sklearn.preprocessing中的KBinsDiscretizer来完成相关的任务。</p><p id="57df" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">您可以按照以下代码对“风向(度)”进行特征离散化，因为“风向(度)”的值在0到359度之间。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mt"><img src="../Images/b2cfa46421b6de07956173b061829463.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wubl6W1EoMS6PXvU"/></div></div></figure><p id="ad94" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通常风向是根据上图的风向来考虑的。所以我选择n_bins = 16来做进一步的工作</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="418c" class="ki kj hh ke b fi kk kl l km kn">from sklearn.preprocessing import KBinsDiscretizer<br/>discretizer = KBinsDiscretizer(n_bins=16, encode='ordinal', strategy='uniform') <br/>discretizer.fit(X[['Wind Bearing (degrees)']])<br/>X['Wind Bearing (degrees)'] = discretizer.transform(X[['Wind Bearing (degrees)']])</span></pre><p id="4b64" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">这里我为箱子做了一个特征编码，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0fe6" class="ki kj hh ke b fi kk kl l km kn">X['Wind_Bearing_cat']=labelencoder.fit_transform(X['Wind Bearing (degrees)'])<br/>X = X.drop('Wind Bearing (degrees)', axis = 1)<br/>X.head() # For the verification</span></pre><p id="8b3d" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">你可以在下图的最后一栏看到特征离散化的效果。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mu"><img src="../Images/bfa0e4b9a443c2ed883eeadc0b1040a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EAhNyBiUAD4Ddbda"/></div></div></figure><p id="85e2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，您可以检查空值以继续工作。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7e30" class="ki kj hh ke b fi kk kl l km kn">X.isnull().any()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mv"><img src="../Images/8bedbf7a3024523705c200b458aff5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/0*k6BkiNoBwAh82Y77"/></div></figure><h1 id="b171" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤01 D -&gt;数据泄漏处理</h1><p id="557b" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">为了处理数据泄漏，我们可以在进行转换之前分离训练集数据和测试集数据。我们只需计算归一化的均值和方差，或者只与训练数据上的统计数据相关的一些其他变换，然后使用这些值来变换训练数据本身，然后使用相同的值来变换测试数据。在转换计算中包含测试数据集将允许信息从测试数据流向训练数据，并因此流向从中学习的模型，从而允许模型作弊(引入偏差)。</p><p id="daf2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">按照上面的代码，我们可以将数据集分成两部分。test_size=0.2，因此我们可以获得20 %的数据行用于测试目的，80 %的数据行用于训练目的，random_state=42。Random_state可以是0或1或任何其他整数。但是，如果您必须一次又一次地多次执行代码来验证您的代码或文件，那么它必须是相同的值。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7962" class="ki kj hh ke b fi kk kl l km kn">from sklearn.model_selection import train_test_split</span><span id="5c7e" class="ki kj hh ke b fi ko kl l km kn">train_X, test_X = train_test_split(X, test_size=0.2,random_state=42)</span></pre><p id="9155" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">如果我们通过下面的代码在每次删除行值后都重置了索引，我们可以避免将来在连接列或拆分数据集时出现一些错误。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="acc4" class="ki kj hh ke b fi kk kl l km kn">train_X=train_X.reset_index(drop=True) # Reset the dataframe Index<br/>len(train_X) # look the length for verification</span></pre><p id="444e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">76712，这是X列车的长度</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="9df9" class="ki kj hh ke b fi kk kl l km kn">test_X.head() # look  for verification</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mw"><img src="../Images/278f4ad5ee908b92a1607fac870653ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kvbxNK0loMFX1Tx5"/></div></div></figure><h1 id="46b2" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤02数据转换</h1><p id="ac97" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">大多数情况下，我们更喜欢数据来自正态分布来训练模型。因为实际数据集中的要素通常会遵循更偏态的分布。通过根据这些变量的偏斜度应用不同类型的变换，我们可以将偏斜分布映射成正态分布。</p><p id="a274" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以为数据集中的连续值列生成一个直方图。从直方图中，我们可以看到数据在特征中分布。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="51ed" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (24, 12)</span><span id="4966" class="ki kj hh ke b fi ko kl l km kn">train_X[['Temperature (C)','Apparent Temperature (C)','Humidity','Wind Speed (km/h)','Visibility (km)','Pressure (millibars)']].hist()</span></pre><p id="7624" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">您可以在下图中看到上述代码的输出，</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mx"><img src="../Images/9edffb8f603ad93c67c5374f0c235076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aNj-wpU8R1dpOa8g"/></div></div></figure><p id="3b5b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">湿度的数据转换</p><p id="4fe4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以为给定的数据列创建一个直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="cffe" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (24, 6)</span><span id="6941" class="ki kj hh ke b fi ko kl l km kn">train_X['Humidity'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/2a71b5d527e10e82276ef568997c4fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HOW_H2TN3SjG3wQZ"/></div></div></figure><p id="5771" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的湿度直方图中，我们可以看到左偏的分布。因此，我们可以使用指数或幂变换来减少左偏分布</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="4a04" class="ki kj hh ke b fi kk kl l km kn">from sklearn.preprocessing import FunctionTransformer</span><span id="3309" class="ki kj hh ke b fi ko kl l km kn">exponential_transformer = FunctionTransformer(np.exp, validate=True)<br/>exponential_transformer.fit(train_X[['Humidity']])</span><span id="bd0d" class="ki kj hh ke b fi ko kl l km kn">train_X['Humidity'] = exponential_transformer.transform(train_X[['Humidity']]) <br/>test_X['Humidity'] = exponential_transformer.transform(test_X[['Humidity']])</span></pre><p id="7e87" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的转换代码中，我们只需调整train_X[['湿度']]，以避免数据泄漏。</p><p id="914f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以看到指数变换后的直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="502c" class="ki kj hh ke b fi kk kl l km kn">train_X['Humidity'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/45c000656964942a8df93b082a3f70cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*civ3MyfFaE7erNNv"/></div></div></figure><p id="8b61" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">风速(千米/小时)的数据转换</p><p id="4386" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以为给定的数据列创建一个直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="8970" class="ki kj hh ke b fi kk kl l km kn">train_X['Wind Speed (km/h)'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/f3a609ee3049b8b2fed38eeebf364e13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hqwuuQf_uHjtxIFt"/></div></div></figure><p id="ae92" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的风速(千米/小时)直方图中，我们可以看到右偏分布。所以我们可以用平方根变换来减少右偏分布</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="08db" class="ki kj hh ke b fi kk kl l km kn">Square_root_transformer = FunctionTransformer(np.sqrt,validate=True)<br/>Square_root_transformer.fit(train_X[['Wind Speed (km/h)']])</span><span id="4b72" class="ki kj hh ke b fi ko kl l km kn">train_X['Wind Speed (km/h)'] = Square_root_transformer.transform(train_X[['Wind Speed (km/h)']]) <br/>test_X['Wind Speed (km/h)'] = Square_root_transformer.transform(test_X[['Wind Speed (km/h)']])</span></pre><p id="05b6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的转换代码中，我们必须只拟合train_X[['风速(km/h)']]，以避免数据泄漏。</p><p id="7ff0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以看到平方根变换后的直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="79d0" class="ki kj hh ke b fi kk kl l km kn">train_X['Wind Speed (km/h)'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/1352db953a9a693b5d97a47c1e3a8e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*whfd9oxuCl9I5ARb"/></div></div></figure><p id="963e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">能见度的数据转换</p><p id="f8d9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以为给定的数据列创建一个直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="c19e" class="ki kj hh ke b fi kk kl l km kn">train_X['Visibility (km)'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/f8a1bcc4c63589d2be956dc4a2c42015.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vu8reRwOKxa9hLte"/></div></div></figure><p id="eccf" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的能见度直方图中，我们可以看到左偏分布。因此，我们可以使用指数或幂变换来减少左偏分布</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7e97" class="ki kj hh ke b fi kk kl l km kn">exponential_transformer = FunctionTransformer(np.exp,validate=True)<br/>exponential_transformer.fit(train_X[['Visibility (km)']])</span><span id="cbfc" class="ki kj hh ke b fi ko kl l km kn">train_X['Visibility (km)'] = exponential_transformer.transform(train_X[['Visibility (km)']]) <br/>test_X['Visibility (km)'] = exponential_transformer.transform(test_X[['Visibility (km)']])</span></pre><p id="427c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的转换代码中，我们必须只拟合train_X[['Visibility (km)']]，以避免数据泄漏。</p><p id="f754" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以看到指数变换后的直方图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2eaa" class="ki kj hh ke b fi kk kl l km kn">train_X['Visibility (km)'].hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es mz"><img src="../Images/e7a8d2ab4877e5161fdbd8198f432e8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3LhiGRusHmzQAp9m"/></div></div></figure><p id="e345" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过遵循代码，我们可以删除“每日摘要”列，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="e035" class="ki kj hh ke b fi kk kl l km kn">train_X = train_X.drop('Daily Summary', axis = 1) <br/>test_X = test_X.drop('Daily Summary', axis = 1)# Dependent Feature so we can remove that</span></pre><h1 id="ec17" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤03数据标准化</h1><p id="af35" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">数据标准化是重新调整一个或多个要素的方式，以便它们的平均值为0，标准差为1。标准化假设您的数据具有高斯(钟形曲线)分布。但这并不一定是真的，但如果你的特征值分布属于高斯分布，这种技术被认为是更有效的。</p><p id="db4e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们必须在标准化之前删除分类特征。因此，通过遵循以下代码，您可以消除这种情况，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0689" class="ki kj hh ke b fi kk kl l km kn">Remove_columns_values = ['Formatted Date','Precip_Types_cat','Summary_cat','Apparent Temperature (C)','Wind_Bearing_cat']</span><span id="dc35" class="ki kj hh ke b fi ko kl l km kn">train_X_without_Cat=train_X.drop(Remove_columns_values, axis = 1)<br/>test_X_without_Cat=test_X.drop(Remove_columns_values, axis = 1)</span><span id="31a1" class="ki kj hh ke b fi ko kl l km kn">train_X_without_Cat.head(10) # For the verification</span></pre><p id="3fcf" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以看到删除分类特征后的输出，</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es na"><img src="../Images/9e779a011bfc35a0d73f1d1a847f37c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KFlGJ4o0PZV4j5em"/></div></div></figure><p id="1582" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">为了验证索引以避免将来的错误，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="086a" class="ki kj hh ke b fi kk kl l km kn">train_X.head()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nb"><img src="../Images/22a6f945bfa48a67a510a20cd9c84388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f7SU8Dpaqff1-PGC"/></div></div></figure><p id="bd04" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以通过调用标准定标器来应用标准化，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b0a8" class="ki kj hh ke b fi kk kl l km kn">scaler = StandardScaler() <br/></span><span id="7e0d" class="ki kj hh ke b fi ko kl l km kn">train_X_Except =train_X_without_Cat<br/>test_X_Except =test_X_without_Cat<br/></span><span id="c7e0" class="ki kj hh ke b fi ko kl l km kn">scaler.fit(train_X_Except)<br/></span><span id="6467" class="ki kj hh ke b fi ko kl l km kn">train_X_Scaled = scaler.transform(train_X_Except)<br/>test_X_Scaled = scaler.transform(test_X_Except)</span></pre><p id="7905" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">在上面的代码中，我们只需将train_X_Except放入scaler.fit()中，以避免数据泄漏</p><p id="432b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以将标准化的数据放入数据帧中，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="ab03" class="ki kj hh ke b fi kk kl l km kn">columns_value_new=train_X_without_Cat.columns<br/></span><span id="49b6" class="ki kj hh ke b fi ko kl l km kn">train_X_Scaled_Except = pd.DataFrame(train_X_Scaled, columns=columns_value_new)<br/>train_X_Scaled_Except.head(10) # data set after Standardization</span></pre><p id="1498" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">验证的输出，</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nc"><img src="../Images/4b71bccf51ece335cc400d3451e25a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ERkauX6ciYB2wB5H"/></div></div></figure><p id="9217" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">测试数据集也是如此。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2bd5" class="ki kj hh ke b fi kk kl l km kn">columns_value_new=test_X_without_Cat.columns<br/></span><span id="d00f" class="ki kj hh ke b fi ko kl l km kn">test_X_Scaled_Except = pd.DataFrame(test_X_Scaled, columns=columns_value_new)<br/>test_X_Scaled_Except.head(10) # data set after Standardization</span></pre><p id="28fb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">验证的输出，</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nd"><img src="../Images/64ab60bcbd6d740614d93906d9e799ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a7CxB4nXODsjQkEY"/></div></div></figure><p id="eb7b" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">查看直方图中的数据集，以显示缩放/标准化效果。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="d48b" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (24, 12)<br/>train_X_Scaled_Except.hist()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es my"><img src="../Images/69c09fe06b5594957afa0aef23f4fff3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QaW3nuwy63hsZysu"/></div></div></figure><h1 id="9a51" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤04相关矩阵和主成分分析(PCA)</h1><h2 id="c5b0" class="ki kj hh bd kr ne nf ng kv nh ni nj kz jz nk nl ld ka nm nn lh kb no np ll nq bi translated">识别重要和独立的特征</h2><p id="0969" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">通过以下代码，我们可以生成给定数据集的相关矩阵，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="de2d" class="ki kj hh ke b fi kk kl l km kn">import seaborn as sns<br/>plt.rcParams["figure.figsize"] = (24, 8)<br/>sns.heatmap(train_X_Scaled_Except.corr(),annot=True); #Seems they can be assuemed as independent</span></pre><p id="932e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">下图是表示特征相关性的输出</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nr"><img src="../Images/0785da101289f8013650e34e9021c162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lfJX_kerMa3Qej9J"/></div></div></figure><p id="bbf0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的相关矩阵我们可以得出结论，湿度和温度与其他特征相比有很高的相关性，但不是很高。因此我们可以保留该特征用于训练模型。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="da83" class="ki kj hh ke b fi kk kl l km kn"># By following those below and above , we can see the signifncance of the features compare to other features<br/></span><span id="ad13" class="ki kj hh ke b fi ko kl l km kn">train_X_Scaled_Except.corr()</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ns"><img src="../Images/614853b03a41781f36d09b8281bcc267.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zEzC4HC5QBpv3jmo"/></div></div></figure><p id="6abe" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上表中，我们可以看到每个特征之间的相关值。</p><p id="8e72" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">现在，我们必须将表观温度再次加入上述变量，以查看表观温度和其他特征之间的相关性。通过下面的代码，我们可以做到这一点，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="e810" class="ki kj hh ke b fi kk kl l km kn">train_X_Scaled_With_Y = train_X_Scaled_Except.join(train_X['Apparent Temperature (C)'])</span><span id="45cb" class="ki kj hh ke b fi ko kl l km kn">train_X_Scaled_With_Y.isnull().sum()</span><span id="afa0" class="ki kj hh ke b fi ko kl l km kn"># Check for the null values</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nt"><img src="../Images/33ae42d9b361f5fbe73349e5e3d9ec00.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/0*qJkD7E_XUlU8EdC1"/></div></figure><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7586" class="ki kj hh ke b fi kk kl l km kn">test_X_Scaled_With_Y = test_X_Scaled_Except.join(test_X['Apparent Temperature (C)'])<br/>test_X_Scaled_With_Y.isnull().sum()</span><span id="26c4" class="ki kj hh ke b fi ko kl l km kn"># Check for the null values</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nt"><img src="../Images/5f1349d46c9f4f7b12dfca2656b668ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/0*oxYN2eIp2Af1sSc_"/></div></figure><p id="2383" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以生成所有特征的相关矩阵，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="8b76" class="ki kj hh ke b fi kk kl l km kn">sns.heatmap(train_X_Scaled_With_Y.corr(),annot=True); #Seems they can be assuemed as independent</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nu"><img src="../Images/0fdc717d651abb92fe08269217366c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QrVy0UmrqRu6Oa9I"/></div></div></figure><p id="4e9c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">从上面的相关矩阵和下面的表格中，我们可以得出结论，湿度和温度与其他特征相比具有高度的负相关性。表观温度与温度有很高的正相关性，与湿度有很高的负相关性。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="af5e" class="ki kj hh ke b fi kk kl l km kn">#test the signifncance of the features<br/></span><span id="97db" class="ki kj hh ke b fi ko kl l km kn">train_X_Scaled_With_Y.corr()</span></pre><p id="6ad7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">按照上面的代码，我们可以生成一个表来详细查看相关值，</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nv"><img src="../Images/4ccbbf8554885faab70e96404d0c610d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_V1oggeVEwlR_orx"/></div></div></figure><p id="3985" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">对于训练数据集，我们必须联接回分类变量以进行PCA。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="d13b" class="ki kj hh ke b fi kk kl l km kn">train_X_For_PCA =train_X_Scaled_Except.join(train_X['Precip_Types_cat'])<br/>train_X_For_PCA = train_X_For_PCA.join(train_X['Summary_cat'])</span><span id="0fe9" class="ki kj hh ke b fi ko kl l km kn">train_X_For_PCA = train_X_For_PCA.join(train_X['Wind_Bearing_cat'])<br/>#train_X_For_PCA.isnull().sum()</span></pre><p id="30ae" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">对于测试数据集，我们必须将分类变量连接回PCA。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7018" class="ki kj hh ke b fi kk kl l km kn">test_X_For_PCA =test_X_Scaled_Except.join(test_X['Precip_Types_cat'])</span><span id="0a61" class="ki kj hh ke b fi ko kl l km kn">test_X_For_PCA = test_X_For_PCA .join(test_X['Summary_cat'])</span><span id="f4ae" class="ki kj hh ke b fi ko kl l km kn">test_X_For_PCA = test_X_For_PCA .join(test_X['Wind_Bearing_cat'])<br/>#test_X_For_PCA.isnull().sum()</span></pre><h2 id="2875" class="ki kj hh bd kr ne nf ng kv nh ni nj kz jz nk nl ld ka nm nn lh kb no np ll nq bi translated">主成分分析</h2><p id="c6af" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">主成分分析(PCA)是一种降维方法，通常用于降低大型数据集的维数，方法是将一个大型变量集转换为一个较小的变量集，该变量集仍包含大型数据集中的大部分信息。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b6c5" class="ki kj hh ke b fi kk kl l km kn">from sklearn.decomposition import PCA<br/>from sklearn.preprocessing import StandardScaler<br/></span><span id="e598" class="ki kj hh ke b fi ko kl l km kn">train_X_PCA_data =train_X_For_PCA<br/>test_X_PCA_data =test_X_For_PCA<br/></span><span id="c746" class="ki kj hh ke b fi ko kl l km kn">pca = PCA(n_components=7)<br/>pca.fit(train_X_PCA_data)<br/>train_X_pca = pca.fit_transform(train_X_PCA_data) <br/>test_X_pca = pca.fit_transform(test_X_PCA_data) <br/></span><span id="a922" class="ki kj hh ke b fi ko kl l km kn">train_X_principalDf = pd.DataFrame(data = train_X_pca)<br/>test_X_principalDf = pd.DataFrame(data = test_X_pca)<br/></span><span id="b71e" class="ki kj hh ke b fi ko kl l km kn">train_X_principalDf.head(10)</span></pre><p id="6bf9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">执行主成分分析后训练数据集X值</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nw"><img src="../Images/d5981527ab31283839784c5a6755787f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2rkUC-zKowk2R3wY"/></div></div></figure><p id="f317" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">执行主成分分析后测试数据集X值</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2110" class="ki kj hh ke b fi kk kl l km kn">test_X_principalDf.head(10)</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es nx"><img src="../Images/8a57c18833b01d94c6710ca055be2161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IkBf3PKfjTvYn-fD"/></div></div></figure><p id="25e9" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们可以看到在执行主成分分析之后训练数据集X值的形状，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="9636" class="ki kj hh ke b fi kk kl l km kn">print(train_X_principalDf.shape)</span></pre><p id="5474" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi">(76712, 7)</p><p id="94d5" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码我们可以看到主成分分析解释的方差比值，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="c7e6" class="ki kj hh ke b fi kk kl l km kn">pca.explained_variance_ratio_</span></pre><p id="c096" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">数组([0.49043775，0.40130885，0.03932747，0.02414914，0.01985586，0.01804037，0.00558572])</p><p id="34e6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">PCA . explained _ variance _ ratio _ parameter返回由每个维度解释的方差的向量。这里PCA . explained _ variance _ ratio _[I]将给出由I+1维解释的方差。</p><p id="8b20" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，您可以生成累积解释差异图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="4017" class="ki kj hh ke b fi kk kl l km kn">plt.plot(np.cumsum(pca.explained_variance_ratio_))<br/>plt.xlabel('number of components')<br/>plt.ylabel('cumulative explained variance');</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ny"><img src="../Images/9ae7df1754f8c88295373557835e4a5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*alFbCEelGwWjLvh3"/></div></div></figure><h1 id="fda5" class="kq kj hh bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">步骤05线性回归</h1><p id="ac3c" class="pw-post-body-paragraph ih ii hh ik b il ln in io ip lo ir is jz lp iv iw ka lq iz ja kb lr jd je jf ha bi translated">线性回归是一种监督机器学习算法，其中预测输出是连续的，并且具有恒定的斜率。它用于预测连续范围内的值，而不是试图将它们分类。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="d7a0" class="ki kj hh ke b fi kk kl l km kn">from sklearn import datasets, linear_model<br/>from sklearn.model_selection import train_test_split<br/>from matplotlib import pyplot as plt</span></pre><p id="24ea" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">我们必须在不泄漏数据的情况下创建训练和测试变量，因此我在转换和缩放之前将它们分开，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="564d" class="ki kj hh ke b fi kk kl l km kn">X_train = train_X_principalDf<br/>y_train =train_X['Apparent Temperature (C)']<br/></span><span id="99c8" class="ki kj hh ke b fi ko kl l km kn">X_test =test_X_principalDf<br/>y_test = test_X['Apparent Temperature (C)']<br/></span><span id="2209" class="ki kj hh ke b fi ko kl l km kn">print(X_train.shape, y_train.shape)<br/>print(X_test.shape, y_test.shape)</span></pre><p id="6783" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以将我们的数据集放入模型中，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="7a19" class="ki kj hh ke b fi kk kl l km kn">lm = linear_model.LinearRegression()<br/>model = lm.fit(X_train, y_train)<br/>y_hat = lm.predict(X_test)</span></pre><p id="dfa6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过以下代码，您可以将实际值、预测值放入数据框中，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0dd3" class="ki kj hh ke b fi kk kl l km kn">test_df =pd.DataFrame({<br/>              'actual':y_test,<br/>              'prediction':y_hat,<br/>              'diff':(y_test-y_hat)})<br/>test_df.head(10)</span></pre><p id="8f9e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">有时你可以从上面的数据框中看到，行索引可能没有按顺序排列，所以我们可以按照下面的代码重置索引，以避免将来出现问题。</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="b9dc" class="ki kj hh ke b fi kk kl l km kn">test_df=test_df.reset_index(drop=True)</span><span id="dc4a" class="ki kj hh ke b fi ko kl l km kn">test_df.head(10) # For Verification After reset the index you can see that its start from zero</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nz"><img src="../Images/7d94b8d16ce2966ac32be304888973ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*g0jKwRm262T_H7xO"/></div></figure><p id="b3da" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">您可以通过下面的代码获得模型的W参数，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="bc42" class="ki kj hh ke b fi kk kl l km kn">print(lm.coef_)</span></pre><p id="ace4" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出为[-0.10932573-0.36122572 6.42501305-2.51270569-0.80607153-4.50456051-6.51199797]。coef_给你一个由线性回归估计的权重数组。如果权重具有很大的值，我们必须归一化数据集特征，并对模型使用正则化来减少权重值。</p><p id="5a22" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">您可以通过下面的代码获得模型的截距，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="82f6" class="ki kj hh ke b fi kk kl l km kn">print(lm.intercept_)</span></pre><p id="24af" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是10.854332003684775，线性回归分析中的常数项似乎就是这么简单的一件事。也称为y截距，它就是拟合直线与y轴相交的值。</p><p id="c2d7" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以绘制图表来显示预测与实际的对比，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="96d6" class="ki kj hh ke b fi kk kl l km kn">plt.plot(test_df['prediction'][:500], label = "Pred")  # Load the 500 data points from prediction with label name 'Pred'<br/>plt.plot(test_df['actual'][:500], label = "Actual")    # Load the 500 data points from actual with label name 'Actual'<br/></span><span id="d5b2" class="ki kj hh ke b fi ko kl l km kn">plt.xlabel('x - axis')              # Set the x axis label of the current axis.<br/>plt.ylabel('y - axis')              # Set the y axis label of the current axis.<br/>plt.title('Predicitons vs Actual')  # Set a title of the current axes.<br/>plt.legend()                        # show a legend on the plot<br/>plt.show()                          # Display a figure.</span></pre><p id="1a00" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出图为:</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es oa"><img src="../Images/8c87d0aa80a1b31e9eeb1622ce0f7082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*b0Z356igZjle1qDU"/></div></div></figure><p id="7d1c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以计算训练模型的均方根误差，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="a44d" class="ki kj hh ke b fi kk kl l km kn">from math import sqrt<br/>from sklearn.metrics import mean_squared_error<br/>rmsq = sqrt(mean_squared_error(y_test, y_hat))<br/>rmsq</span></pre><p id="86aa" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是1.2070026749031717</p><p id="0c39" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以计算训练模型的均方误差，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="12ca" class="ki kj hh ke b fi kk kl l km kn">from sklearn.metrics import mean_squared_error<br/>mean_squared_error(y_test, y_hat)</span></pre><p id="d410" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是1.4568554572466</p><p id="6e58" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以计算预测的解释方差的百分比，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="0eba" class="ki kj hh ke b fi kk kl l km kn">print(lm.score(X_test,y_test))</span></pre><p id="f59c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">输出是0.9873271393527</p><p id="5ff0" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，我们可以计算模型的交叉预测精度，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="2af7" class="ki kj hh ke b fi kk kl l km kn"># Necessary imports: <br/>from sklearn.model_selection import cross_val_score, cross_val_predict<br/>from sklearn import metrics<br/>accuracy = metrics.r2_score(y_test, y_hat)<br/>print("Cross-Predicted Accuracy:", accuracy)</span></pre><p id="2ddb" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">交叉预测的准确度:0。36860 . 68686868686</p><p id="25de" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">通过下面的代码，您可以创建分布图，我们用它来查看模型的实际值与预测值的分布。可以使用sns.distplot()绘制分布图，</p><pre class="jh ji jj jk fd kd ke kf kg aw kh bi"><span id="70d0" class="ki kj hh ke b fi kk kl l km kn">plt.rcParams["figure.figsize"] = (24, 8)<br/>sns.distplot(y_test,hist=False,color ="r",label="Test")<br/>sns.distplot(y_hat,hist=False,color ="b",label="HAT")</span></pre><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jm jn di jo bf jp"><div class="er es ob"><img src="../Images/b2751c9ef44a30c0bdce9164dc370f5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S6bOlpjtutCQz8kB"/></div></div></figure><p id="7d28" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jz iu iv iw ka iy iz ja kb jc jd je jf ha bi translated">感谢您阅读我的文章Thanusan S .</p></div></div>    
</body>
</html>