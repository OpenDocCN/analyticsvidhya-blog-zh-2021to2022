<html>
<head>
<title>Predicting Laptop Prices Using ML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ML预测笔记本电脑价格</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-laptop-prices-using-ml-e60a0315b45a?source=collection_archive---------2-----------------------#2021-06-18">https://medium.com/analytics-vidhya/predicting-laptop-prices-using-ml-e60a0315b45a?source=collection_archive---------2-----------------------#2021-06-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8194" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">构建一个预测笔记本电脑价格的端到端web应用程序。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/94b88da969bcb3e064a55600e970aee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1SUvGQhI2ksFYTQY1kQWzQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由<a class="ae jt" href="https://unsplash.com/@xps?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> XPS </a>在<a class="ae jt" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><h1 id="58e7" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">最初动机</strong></h1><p id="0f4c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">作为机器学习/数据科学的绝对初学者，我想利用我的技能，更深入地钻研机器学习领域。在无数次尝试观看YouTube视频和参加Coursera的课程后，我决定通过构建一个预测笔记本电脑价格的<a class="ae jt" href="https://laptoppredictionml-api.herokuapp.com/?" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> web应用程序</strong> </a>来展示我所学到的东西。话虽如此，我还是把我的项目分成了8个不同的部分，因为这也让初学者(像我一样)可以跟进。请随意浏览我的<a class="ae jt" href="https://github.com/AndyFooGuoZhen/Laptop-Price-ML-Project-Deploy-" rel="noopener ugc nofollow" target="_blank"> Github repo </a>中的项目文件。</p><p id="0f88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">本文将讨论:</strong></p><p id="19bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.获取笔记本电脑价格数据集</p><p id="cdb2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.基础数据探索</p><p id="9477" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.特征工程</p><p id="4945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.解释性数据分析(EDA)</p><p id="989a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.数据预处理</p><p id="85ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6.系统模型化</p><p id="1dac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">7.构建web界面</p><p id="7c4e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">8.部署web应用程序</p><h1 id="f759" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">获取笔记本电脑价格数据集</strong></h1><p id="f2ad" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">对于这个项目，我已经从Kaggle获得了我的数据集(由<a class="ae jt" href="https://www.kaggle.com/ionaskel/laptop-prices" rel="noopener ugc nofollow" target="_blank"> Ionas Kelepouris </a>)。该数据集包含1300行数据和12列(特征),我们可以集中精力来构建预测模型。</p><h1 id="44e6" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">基础数据探索</strong></h1><p id="4c6a" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">通过Pandas加载数据集后，我们可以看到笔记本电脑列表以及与每台笔记本电脑相关的规格。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="528f" class="lc jv hi ky b fi ld le l lf lg">df=pd.read_csv('laptops.csv',encoding='ISO-8859–1')<br/>df</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lh"><img src="../Images/c5ff1fee234f68de1f91370e03697761.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Eb7cVoX1glxXotaloBOzkQ.jpeg"/></div></div></figure><p id="1d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看数据集，我们可以看到一些列(如ScreenResolution和Cpu)包含字母数字数据，而其他功能则由纯数字或字母值组成。这些数据需要在以后进行过滤和设计。</p><p id="7b22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了避免任何复杂性和容易出错的预测，将从数据集中移除无用的特征，如“未修改:0”、“公司”和“产品”。(拥有一台装有windows操作系统的苹果笔记本电脑似乎对价格预测没有任何意义。)</p><p id="ea56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们将检查数据集中是否存在任何缺失的值。我们不希望在以后的分析或建模中出现任何错误。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="bb9d" class="lc jv hi ky b fi ld le l lf lg">df.isnull().sum() </span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es li"><img src="../Images/604bc10084a8414f600c3762474b8320.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*-9cp0N3yVRgzwG6sqm5DOA.jpeg"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">该图显示所有列都没有空值。</figcaption></figure><h1 id="4bdc" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">特色工程</strong></h1><p id="5a16" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我们现在将提取并重新组织我们的数据，以更好地理解影响笔记本电脑价格的潜在因素。</p><p id="e909" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们看一下屏幕分辨率一栏，似乎有带触摸屏功能的笔记本电脑。众所周知，触摸屏笔记本电脑比没有触摸屏的笔记本电脑更贵，因此将增加一个触摸屏功能来标记具有这种功能的笔记本电脑。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="ba13" class="lc jv hi ky b fi ld le l lf lg">df.loc[df['ScreenResolution'].str.contains('Touchscreen'),<br/>'TouchScreen']="Yes"<br/>df.tail(10)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/c2409b4ea2800d47a6fe127c501e6f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KP-vs9SEg_1Z8WmeiidzJQ.jpeg"/></div></div></figure><p id="5fe1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们将使用正则表达式提取屏幕分辨率列，并用它们各自的像素数替换它。我发现正则表达式在提取/过滤字母数字值时非常有用。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="ab4e" class="lc jv hi ky b fi ld le l lf lg">df['ScreenResolution']=df['ScreenResolution'].str.<br/>extract('(\d\d\d\d?x\d\d\d\d?)',expand=True)<br/>df.tail(10)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/37da27a3963b958321a4225591a163a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qhduUAVJ0HXd7UJj_lU-A.png"/></div></div></figure><p id="ec52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们将应用相同的过程来设计Cpu、Ram和重量特性。我们的目标是最小化或删除任何对以后的分析不重要的单元和单词。</p><p id="7f5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在到了特征工程最累人的部分，处理记忆特征。仔细观察，内存列包含各种类型的内存(SSD、HDD、SSHD和闪存)。我们需要创建4个额外的列来表示不同的内存类型，并分别提取它们的内存容量。(对于使用相同内存类型的双内存配置的笔记本电脑，需要进行额外的处理。(例如:256GB固态硬盘+ 512GB固态硬盘)。这可以使用上面所示的类似过程来完成。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="d46b" class="lc jv hi ky b fi ld le l lf lg">df['HDD']=df['Memory'].str.extract('(\d\d\d?GB\sHDD|\dTB\sHDD|\d\.0TB\sHDD)',expand=True)</span><span id="c127" class="lc jv hi ky b fi ll le l lf lg">df['HDD']=df['HDD'].str.extract('(\d\d\d?|\dTB|\d\.0TB)',expand=True)</span><span id="2c47" class="lc jv hi ky b fi ll le l lf lg">df['HDD']=df['HDD'].str.replace('(TB|\.0TB)','000',regex=True)<br/>df['HDD'].fillna(0,inplace=True)</span><span id="5763" class="lc jv hi ky b fi ll le l lf lg">df.head(30)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lh"><img src="../Images/f3d1ee35e001630d946e598c092d1f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QWj4iYO_IkSkiCTd1TFgFA.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">第5行反映了HDD存储器的工程结果。</figcaption></figure><p id="0095" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">处理完这些内存配置后，我决定完全删除GPU列，因为它包含了大量的GPU。英特尔GPU是集成GPU，Nvidia GPUs是独立的，而AMD GPUs是集成或独立的。对每一个进行标记和分类将花费大量的精力和时间，这可能有助于也可能没有助于以后的建模过程。</p><p id="a6c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的全功能工程数据集如下所示:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="0ca7" class="lc jv hi ky b fi ld le l lf lg">df</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lm"><img src="../Images/9e7f4f21a0e2048a1a3cf9d823f35082.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkWUd4nY2Mr4bQaZrCEj9Q.jpeg"/></div></div></figure><p id="ace2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们将数据集保存到新的。csv文件并为解释性数据分析过程做准备。</p><h1 id="6528" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">解释性数据分析(EDA) </strong></h1><p id="3876" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">使用我们的功能设计数据集，我们现在可以绘制图表和计算表格，以可视化每个功能与笔记本电脑价格可变性的关系。</p><p id="4539" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过使用。从Matplotlib导入的barplot方法，我们可以测试和验证我们关于某些功能将如何影响笔记本电脑定价的假设或初步意见。以下是绘制特征类型名称(笔记本电脑类型)条形图的图示:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="477b" class="lc jv hi ky b fi ld le l lf lg">plt.subplots(figsize=(10,5))<br/>sns.barplot(x='TypeName',y='Price',data=df)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ln"><img src="../Images/6e6062895ced9239718e598a9bdd0f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*QTyegcnSM7uR-gGv7PwyWA.jpeg"/></div></figure><p id="21be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的柱状图中，我们可以纠正并得出结论，平均而言，工作站和游戏笔记本电脑的价格高于其他类型的笔记本电脑。这是意料之中的，因为这些类型的笔记本电脑通常具有更好的规格配置(更好的CPU、更大的内存等)，以满足专业工作空间中客户端的需求。笔记本和上网本由于低功耗配置，价格较低。</p><p id="cd96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">更高的Ram容量也反映了笔记本电脑更高的价格:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="a19c" class="lc jv hi ky b fi ld le l lf lg">plt.subplots(figsize=(20,10))<br/>sns.barplot(x='Ram',y='Price',data=df)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lo"><img src="../Images/1da946844ed467259065ec25f6a079f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-WAWMoRzksPUZlUO6DcJAQ.jpeg"/></div></div></figure><p id="4fd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">屏幕尺寸条形图显示不一致的价格:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="cbfe" class="lc jv hi ky b fi ld le l lf lg">plt.subplots(figsize=(10,10))<br/>sns.barplot(x='Inches',y='Price',data=df)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/ff4fe3f0d10bb939a59e6e72b60ee7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*LXd2y1MdsF7M0tXrdWWIIw.jpeg"/></div></figure><p id="62dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">绘制Cpu特性的条形图显示了一些有趣的结果。一般来说，高性能处理器的价格应该高于低性能处理器。英特尔处理器的价格通常遵循这一模式(至强&gt; i7&gt;i5&gt;i3)，同样的原则也适用于AMD CPUs(锐龙&gt; AMD A系列&gt; E系列)。从数据集获得的柱状图显示的情况与此不同。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="1fef" class="lc jv hi ky b fi ld le l lf lg">plt.subplots(figsize=(20,10))<br/>sns.barplot(x='Cpu',y='Price',data=df)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lq"><img src="../Images/c084923daed1a3ad6dfe85a565c0d3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JOGRck3F76pDceZvhmiOBg.jpeg"/></div></div></figure><p id="d427" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该图显示英特尔M系列笔记本电脑的平均价格高于i3和i5笔记本电脑。出于这个原因，需要对这种情况进行进一步的检查，以便更好地理解这种现象的发生。</p><p id="c1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">利用熊猫。grouby()方法，我们可以计算与i5和英特尔M笔记本电脑相关的平均特性。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="5bb5" class="lc jv hi ky b fi ld le l lf lg">standby_df = df.loc[df['Cpu'].str.contains('Intel M |Intel i5')]<br/>standby_df.groupby(['Cpu']).mean()</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/0e8830d96e8ba8c64fbb27f49ea7f572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*DloFFbKF53EyMLkrWmpaMw.jpeg"/></div></figure><p id="c57d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与i5笔记本电脑相比，英特尔M笔记本电脑的RAM容量更大，重量更轻，SSD内存容量更大。这些特性导致英特尔M系列笔记本电脑的价格较高。</p><h1 id="4b12" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">数据预处理</strong></h1><p id="b7b8" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">在本节中，我们将重新标记分类特征，并将其转换为数字特征。这对于训练我们的ML模型是必不可少的，因为ML模型只接受数值作为输入。</p><p id="b5b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们识别非数字特征(对象类型)并计算它们的基数(每个特征中存在的类别)。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="0f95" class="lc jv hi ky b fi ld le l lf lg">#Prints all columns that are of type object</span><span id="11e8" class="lc jv hi ky b fi ll le l lf lg">for i in df.columns:<br/>     if df[i].dtype=='object':<br/>             print("%-10s\n%-200s\n%-10d\n"%(i,df[i].unique(),df[i].nunique()))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ls"><img src="../Images/96e7ddeb8a4d9d909796f7c0e97d315f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lLH7gsBUAq6uhYUk3t0abQ.jpeg"/></div></div></figure><p id="3e56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">知道触摸屏功能只有2个类别，我们可以使用标签编码来编码这个功能。(也可以使用一键编码)使用Scikit-learn的标签编码功能，触摸屏上的变量(“否”、“是”)将被编码为0和1。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="3a9c" class="lc jv hi ky b fi ld le l lf lg">from sklearn.preprocessing import LabelEncoder</span><span id="fe5d" class="lc jv hi ky b fi ll le l lf lg">le=LabelEncoder()<br/>print(df['TouchScreen'].unique())<br/>print(le.fit_transform(df['TouchScreen'].unique())) <br/># to check what encoded values would be</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lt"><img src="../Images/c1bf3cd10f0249f8b24205c221c4181c.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*V1GnN_NK60O0Ih19HN-91w.jpeg"/></div></figure><p id="bc64" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">标注编码还处理基数较高的要素。将标签编码应用于Cpu特性，标签编码值(与其预编码变量相关联)被记录下来，以便以后进行预测。</p><p id="02fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他基数稍低的特性是通过one-hot-encoding方法编码的。通过熊猫的使用。getdummies()方法，将创建一个新列来指示每个分类变量的存在。</p><p id="7059" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的例子说明了一次热编码对TypeName特性的影响:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lu"><img src="../Images/f36c9b2c156619b3309c51a8d72502df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*61kMch-QtsBgOKRCN3o7CA.jpeg"/></div></div></figure><p id="9338" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在对TypeName和OpSys特性应用One-hot-encoding之后，如果我们知道变量的顺序，我们将使用手动编码来处理具有高基数的特性。</p><p id="4d2f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用python的字典和映射方法，根据它们的大小/顺序来指定和编码每个类别。下面显示的代码片段根据像素数对屏幕分辨率特性进行了编码。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="f460" class="lc jv hi ky b fi ld le l lf lg">Screen_Res_dict={'1366x768' : 1, '1440x900' : 2 , '1600x900': 3, '1920x1080': 4, '1920x1200': 5, '2160x1440': 6, <br/>                 '2304x1440': 7, '2256x1504': 8, '2560x1440': 9, '2400x1600':10, '2560x1600':11, '2880x1800':12, <br/>                  '3200x1800': 13, '3840x2160':14}</span><span id="1a6c" class="lc jv hi ky b fi ll le l lf lg">OH_df['ScreenResolution']=<br/>OH_df.ScreenResolution.map(Screen_Res_dict)</span></pre><p id="a444" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经历了所有必要的数据处理步骤后，我们现在可以将新数据集保存到一个. csv文件中，以便稍后进行建模。</p><h1 id="f916" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">造型</strong></h1><p id="d07d" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">加载预处理后。csv数据集，我们确定因变量(价格)并为目标变量分配单独的数据框。</p><p id="826c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以拆分数据集，用于训练和验证我们稍后要应用的模型的性能。大约30%的数据将用于测试我们的ML模型。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="b776" class="lc jv hi ky b fi ld le l lf lg">from sklearn.model_selection import train_test_split</span><span id="4da0" class="lc jv hi ky b fi ll le l lf lg">X_train, X_test, y_train, y_test = train_test_split(df, target, test_size=0.33, random_state=0)</span></pre><p id="d916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们开始训练和验证不同模型的性能。用于评估我们模型性能的两个主要指标是R平方得分和平均绝对误差(MAE)。总的来说，我们希望通过我们的模型获得更高的R平方分数和更低的MAE分数。</p><p id="b7e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不同节点数的RandomForestRegressor:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="bd9c" class="lc jv hi ky b fi ld le l lf lg">from sklearn.ensemble import RandomForestRegressor<br/>from sklearn.metrics import mean_absolute_error<br/>from sklearn.metrics import r2_score</span><span id="947f" class="lc jv hi ky b fi ll le l lf lg">def get_mae_random(max_leaf_nodes,X_train,X_test, y_train, y_test ):<br/>    model1 = RandomForestRegressor(max_leaf_nodes = max_leaf_nodes, random_state=0)<br/>    model1.fit(X_train,y_train)<br/>    model1_preds = model1.predict(X_test)<br/>    print("R2 score: %.2f"%(r2_score(y_test,model1_preds)))<br/>    mae = mean_absolute_error(y_test, model1_preds)<br/>    return (mae)</span><span id="43c5" class="lc jv hi ky b fi ll le l lf lg">for max_leaf_nodes in [5,10,20,50,100,200,300, 500]:<br/>    mae=get_mae_random(max_leaf_nodes,X_train,X_test,y_train,y_test)<br/>    print("Max leaf nodes: %d \t\t MAE: %d\n"%(max_leaf_nodes, mae))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lv"><img src="../Images/0e7b8d9080f26b415de17aa12ce98ef4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7_fuZEgFjRG56RwThGGDmA.jpeg"/></div></div></figure><p id="6688" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用决策树回归器进行培训:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="32fd" class="lc jv hi ky b fi ld le l lf lg">from sklearn.tree import DecisionTreeRegressor</span><span id="5cf1" class="lc jv hi ky b fi ll le l lf lg">def get_mae_decision(max_leaf_nodes,X_train,X_test,y_train, y_test):<br/>    model1 = DecisionTreeRegressor(max_leaf_nodes = max_leaf_nodes, random_state=0)<br/>    model1.fit(X_train,y_train)<br/>    model1_preds = model1.predict(X_test)<br/>    print("R2 score: %.2f"%(r2_score(y_test,model1_preds)))<br/>    mae = mean_absolute_error(y_test, model1_preds)<br/>    return (mae)</span><span id="7f13" class="lc jv hi ky b fi ll le l lf lg">for max_leaf_nodes in [5,10,20,50,100,200,300, 500]:<br/>    mae = get_mae_decision(max_leaf_nodes,X_train,X_test,y_train,y_test)<br/>    print("Max leaf nodes: %d \t\t MAE: %d\n"%(max_leaf_nodes, mae))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lw"><img src="../Images/3d8c3bbf3aa6d5bc03866212f10d5095.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*NYOXdmUvhH6bPAq1UyJp2Q.jpeg"/></div></figure><p id="320c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">线性回归模型:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="06af" class="lc jv hi ky b fi ld le l lf lg">from sklearn.linear_model import LinearRegression</span><span id="03e4" class="lc jv hi ky b fi ll le l lf lg">model2=LinearRegression()<br/>model2.fit(X_train,y_train)<br/>preds=model2.predict(X_test)<br/>r2score=r2_score(y_test,preds)<br/>MAE = mean_absolute_error(y_test, preds)</span><span id="8e35" class="lc jv hi ky b fi ll le l lf lg">print("R2 score: %.2f"%(r2score))<br/>print("MAE: %d"%(MAE))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lx"><img src="../Images/6d85542e06957fffd38bfdbc0c860bf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*jgnH_nH2KLVcvIOzvGbAHg.jpeg"/></div></figure><p id="2bb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">XGBoost型号:</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="917c" class="lc jv hi ky b fi ld le l lf lg">from xgboost import XGBRegressor</span><span id="f3dd" class="lc jv hi ky b fi ll le l lf lg">model3 = XGBRegressor()<br/>model3.fit(X_train,y_train)<br/>preds3=model3.predict(X_test)<br/>r2score=r2_score(y_test, preds3)<br/>MAE = mean_absolute_error(y_test, preds3)</span><span id="f251" class="lc jv hi ky b fi ll le l lf lg">print("R2 score: %.2f"%(r2score))<br/>print("MAE: %d"%(MAE))</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/2a3559221cf6efbf1f47b66ef0cc66a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/1*2882wrzP68uqwmtoR_Vy-Q.jpeg"/></div></figure><p id="6d81" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">XGBoost模型在所有模型中具有最高的R平方得分和最低的MAE得分，将被选为我们的最终ML模型。我们可以使用joblib保存训练好的模型。</p><h1 id="df3f" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak"> Web应用部署</strong></h1><p id="8af4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">由于对HTML和CSS毫无经验，我不得不依靠freeCodeCamp的初学者友好视频来构建我的web应用程序。经过几个小时的调试定位错误和与HTML和CSS的斗争，我终于得到了自己的功能web界面。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/caecd6c4c7a86ea3a467147f168b946c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHC8hhu42nkIvvbxDm1IoA.jpeg"/></div></div></figure><p id="2586" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这样一来，可以使用flask和python来处理web应用程序的后端。通过使用GET/POST方法从Flask中检索HTML表单数据并将数据存储到一个数组中，我们可以加载之前训练过的XGBoost模型，并开始预测笔记本电脑的价格。</p><pre class="je jf jg jh fd kx ky kz la aw lb bi"><span id="2ba1" class="lc jv hi ky b fi ld le l lf lg">model = joblib.load('XGB_model')</span><span id="c072" class="lc jv hi ky b fi ll le l lf lg">#predict price of laptop given the above dataset<br/>def predict(self, list):<br/>     arrToPredict = np.array([list])<br/>     self.totalPredicted = model.predict(arrToPredict)</span></pre><p id="af2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在确保所有测试和web应用程序都按预期工作后，我们可以将项目文件保存到Github repo中，并使用Heroku部署web应用程序。这里有一篇由<a class="ae jt" rel="noopener" href="/coding-blocks/deploy-machine-learning-model-on-heroku-dc799ef8ec86"> Naivedh Shah </a>写的很棒的文章，解释了在Heroku上部署ML web应用的来龙去脉。</p><h1 id="1ebd" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated"><strong class="ak">结论</strong></h1><p id="a0bf" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">我希望您对创建和部署ML web应用程序的基础有了一些有用的了解。如果第一次尝试不成功，不要给自己压力，这个项目花了我3个多月才完成:)</p><p id="437e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">也就是说，我永远感谢<a class="ae jt" href="https://www.youtube.com/user/krishnaik06" rel="noopener ugc nofollow" target="_blank">克里斯·纳伊克</a>和<a class="ae jt" href="https://www.freecodecamp.org/" rel="noopener ugc nofollow" target="_blank">自由代码营</a>为我完成这个项目提供了必要的知识。从你们身上学到新东西一直是(并将继续是)一件非常愉快的事情。</p><p id="52eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这篇文章，别忘了喜欢它:)让我们继续吧</p><p id="157b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">领英:<a class="ae jt" href="https://www.linkedin.com/in/andy-foo-guo-zhen-791a58174" rel="noopener ugc nofollow" target="_blank">linkedin.com/in/andy-foo-guo-zhen-791a58174</a></p><p id="1f29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">github:<a class="ae jt" href="https://github.com/AndyFooGuoZhen" rel="noopener ugc nofollow" target="_blank">https://github.com/AndyFooGuoZhen</a></p></div></div>    
</body>
</html>