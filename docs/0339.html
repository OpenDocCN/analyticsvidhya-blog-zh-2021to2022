<html>
<head>
<title>Machine Learning From Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始的机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-from-scratch-a3952180bade?source=collection_archive---------26-----------------------#2021-01-12">https://medium.com/analytics-vidhya/machine-learning-from-scratch-a3952180bade?source=collection_archive---------26-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="8ded" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">如何用c++从头开始写一个机器学习程序</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/63a3cb82283f3f41ca89e0cd6116e9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JiJ9BmM_LN9NPpqm"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">美国宇航局在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="e110" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">机器学习是这样一个话题，当你在谷歌上搜索它的时候，你要么会找到它的基本解释，要么会找到一个拥有五个T4统计学和计算机科学博士学位的人写的学术论文，而这两者之间什么也没有。<strong class="jp hi"> </strong>我们今天生活的世界喜欢这个<em class="kj">时髦词</em>，但是用一种不是python的语言从零开始创造东西需要什么呢？我开始做一个c++项目，在这个项目中，我想使用K-最近邻算法来制作手写数字分类器，我发现这是一种非常直观和容易理解的算法。</p><p id="ddf4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">注意:</strong>该项目依赖于<a class="ae jm" href="https://eigen.tuxfamily.org/index.php?title=Main_Page" rel="noopener ugc nofollow" target="_blank"> Eigen </a>外部库</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="2e1a" class="kr ks hh bd kt ku kv kw kx ky kz la lb in lc io ld iq le ir lf it lg iu lh li bi translated"><strong class="ak">从哪里开始？</strong></h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lj"><img src="../Images/789cfaf4fc1ed8e1ad98a93975945bd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z6MQt4ArjYw0XYRIx0cfbA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">由<a class="ae jm" href="https://markvanrijmenam.medium.com/?source=post_page-----78c7918cb35d--------------------------------" rel="noopener">马克·范·里梅纳姆</a>博士在<a class="ae jm" rel="noopener" href="/dataseries/7-steps-to-machine-learning-how-to-prepare-for-an-automated-future-78c7918cb35d">培养基</a>上绘制的图表</figcaption></figure><p id="cbf0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">根据机器学习的7个步骤，我们首先需要的是数据！因此，对于这个项目，我们将使用<a class="ae jm" href="http://yann.lecun.com/exdb/mnist/" rel="noopener ugc nofollow" target="_blank"> MNIST数据集</a>。该站点有四个我们将要使用的文件，train文件和t10k文件。训练文件包含所谓的具有60000个手写数字图像的训练数据集，而t10k文件包含具有10000个手写数字图像的测试数据集，这些图像不同于训练数据集中的60000个。</p><p id="ddef" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">您会注意到，我们有两个文件，对于训练和测试数据集来说，它们看起来彼此相似，这些是所谓的标签文件，它们只是范围从0到9的值，代表图像文件中对应的<em class="kj">图像</em>的<em class="kj">标签</em>。当你试图打开这些文件的时候，你可能已经注意到了，它们包含了看起来像是乱码的东西，但是真正酷的是你看到的是纯字节编码的数据！文件以idx文件格式存储，这是存储矩阵和其他数字数据的首选格式。我们需要编写一个算法来解析这些文件，以便从中获得一些有意义的数据。因此，我们进入了机器学习管道的下一步<strong class="jp hi">数据准备。</strong></p><h1 id="358c" class="kr ks hh bd kt ku lk kw kx ky ll la lb in lm io ld iq ln ir lf it lo iu lh li bi translated"><strong class="ak">数据准备</strong></h1><p id="6100" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">现在我们终于可以开始编程了。我写的这个项目将会用c++14来写，因为我觉得它会在一个足够低的层次上给出一个理解，但是有适量的抽象，一切都仍然有意义。</p><p id="b5c4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们需要解析的两种文件是图像数据文件和这些图像的标签文件。我们将编写以下函数:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="8902" class="lz ks hh lv b fi ma mb l mc md">public:<br/>void prepareData(const std::string&amp; image_file_path, <br/>const std::string&amp; label_file_path){</span><span id="25e6" class="lz ks hh lv b fi me mb l mc md">    read_Label_File(label_file_path);</span><span id="68aa" class="lz ks hh lv b fi me mb l mc md">    read_Image_File(image_file_path);<br/>}</span><span id="a846" class="lz ks hh lv b fi me mb l mc md">private:</span><span id="b11c" class="lz ks hh lv b fi me mb l mc md">void read_Image_File(const std::string&amp; image_file_path);<br/>void read_Label_File(const std::string&amp; label_file_path);</span></pre><p id="c3e3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">prepare data函数将是read_Image和read_Label函数的包装器，因为函数调用的顺序很重要，这一点在本教程的后面部分会变得很明显。</p><p id="d2c2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">让我们仔细看看read_Image_File函数，我们看到它有一个image_file_path字符串参数，这个参数就是我们下载的MNIST文件的绝对路径。我们要做的第一件事是创建一个代表我们文件的ifstream对象:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="d74f" class="lz ks hh lv b fi ma mb l mc md">std::ifstream image_file(image_file_path);</span><span id="21c9" class="lz ks hh lv b fi me mb l mc md">if(!image_file.is_open()){ // Ensure that it has found the file<br/>    std::cerr &lt;&lt; "Could not open image file\n";<br/>    return;<br/>}</span></pre><p id="bee5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在到了棘手的部分，在网站上我们看到数据是如何在MNIST图像文件中表示的</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="6c3f" class="lz ks hh lv b fi ma mb l mc md">[offset] [type]          [value]          [description] <br/>0000     32 bit integer  0x00000803(2051) magic number <br/>0004     32 bit integer  60000            number of images <br/>0008     32 bit integer  28               number of rows <br/>0012     32 bit integer  28               number of columns <br/>0016     unsigned byte   ??               pixel <br/>0017     unsigned byte   ??               pixel <br/>........ <br/>xxxx     unsigned byte   ??               pixel</span></pre><p id="15bb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这可能看起来很奇怪，但实际上非常简单和直观。查看表中的<em class="kj">第一行</em>，我们看到0000表示我们在文件的开头，我们期望在文件的这个位置找到的数据类型是一个32位整数，十六进制值为0x00000803或十进制值为2051。这就是所谓的幻数，它可以被看作是指示文件类型的签名。表中的<em class="kj">第二行</em>的偏移量为0004，表示我们已经将4个字节进一步移入文件，这是有意义的，因为幻数是4个字节的数据块。我们再次期望找到一个32位的整数，其值为60000，表示文件中图像的数量。移动到下两行，我们期望找到我们将要阅读的图像的尺寸。现在，在读取该元数据之后，我们可以继续读取图像的像素值，其具有一种无符号字节，这是由于图像是灰度的事实，这意味着像素将具有0到255之间的值，这是无符号8位(1字节)值可以表示的范围。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/978ac37d194449d855131e231e188513.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OLy9yLWOzi_6OHFKVqkhmQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">这些是图像的样子</figcaption></figure><p id="9f27" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，为了从文件中一次读取一定数量的字节，我们将从ifstream对象中使用<em class="kj"> read </em>方法。read方法接受两个参数:指向存储数据的变量的指针和从文件中读取的字节数。我们将首先从读取标签文件中的数据开始。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="c276" class="lz ks hh lv b fi ma mb l mc md">std::ifstream label_file(label_file_path);</span><span id="931a" class="lz ks hh lv b fi me mb l mc md">if(!label_file.is_open()){ // Check if the file is found<br/>    std::cerr &lt;&lt; "Could not open label file\n";<br/>    return;<br/>}</span><span id="aa69" class="lz ks hh lv b fi me mb l mc md">int magic_number_label = 0; // 32 bit int (4 bytes)<br/>int number_of_labels = 0;</span><span id="6316" class="lz ks hh lv b fi me mb l mc md">label_file.read((char*)&amp;magic_number_label,sizeof(magic_number_label));<br/>magic_number_label = reverseInt(magic_number_label); </span><span id="bdfe" class="lz ks hh lv b fi me mb l mc md">label_file.read((char*)&amp;number_of_labels,sizeof(number_of_labels));<br/>number_of_labels = reverseInt(number_of_labels); // Will explain this later</span></pre><p id="1783" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在我们有了文件元数据，可以开始读取实际的标签数据了:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="0f72" class="lz ks hh lv b fi ma mb l mc md">std::vector&lt;unsigned char&gt; labels;<br/>for(int i = 0; i &lt; number_of_labels; i++){<br/>   label_file.read((char*)&amp;label,sizeof(label));<br/>   labels[i] = label;<br/>}</span></pre><p id="3244" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从图像文件中读取元数据是类似的:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="2e29" class="lz ks hh lv b fi ma mb l mc md">std::ifstream image_file(image_file_path);</span><span id="c756" class="lz ks hh lv b fi me mb l mc md">if(!image_file.is_open()){ // Ensure that it has found the file<br/>    std::cerr &lt;&lt; "Could not open image file\n";<br/>    return;<br/>}</span><span id="6fc4" class="lz ks hh lv b fi me mb l mc md">image_file.read((char*)&amp;magic_number_image,sizeof(magic_number_image));<br/>magic_number_image = reverseInt(magic_number_image);</span><span id="b6e7" class="lz ks hh lv b fi me mb l mc md">image_file.read((char*)&amp;number_of_images,sizeof(number_of_images));<br/>number_of_images = reverseInt(number_of_images);</span><span id="e648" class="lz ks hh lv b fi me mb l mc md">image_file.read((char*)&amp;number_of_rows,sizeof(number_of_rows));<br/>number_of_rows = reverseInt(number_of_rows);</span><span id="4064" class="lz ks hh lv b fi me mb l mc md">image_file.read((char*)&amp;number_of_cols,sizeof(number_of_cols));<br/>number_of_cols = reverseInt(number_of_cols);</span></pre><p id="f010" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">您可能已经注意到了第二种方法的使用，那就是reverseInt函数，函数背后的逻辑并不重要，它用于将无符号的char值转换回有符号的整数值，实现方式如下:</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="0873" class="lz ks hh lv b fi ma mb l mc md">int reverseInt (int i){<br/>            unsigned char c1=0, c2=0, c3=0, c4=0;<br/>            c1 = i &amp; 255;<br/>            c2 = (i &gt;&gt; 8) &amp; 255;<br/>            c3 = (i &gt;&gt; 16) &amp; 255;<br/>            c4 = (i &gt;&gt; 24) &amp; 255;<br/>            return ((int)c1 &lt;&lt; 24) + ((int)c2 &lt;&lt; 16) + ((int)c3 &lt;&lt; 8) + c4;<br/>};</span></pre><p id="b2f2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，在我们读取像素数据之前，我们将创建一个Image类来简化事情。我们将使用特征矩阵将像素数据存储为整数值，以便进行更简单的数学运算，但是您可以使用任何选择的数据结构，这只是在我们实现ML算法时简化了事情。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="603d" class="lz ks hh lv b fi ma mb l mc md">class Image{</span><span id="4bc7" class="lz ks hh lv b fi me mb l mc md">public:<br/>        static const int rows = 28;<br/>        static const int cols = 28;</span><span id="3db1" class="lz ks hh lv b fi me mb l mc md">Image(std::vector&lt;std::vector&lt;unsigned char&gt;&gt;,unsigned char);<br/>        Image();<br/>        ~Image();<br/>        Eigen::Matrix&lt;int,rows,cols&gt; getPixelData() const;<br/>        int getLabel() const;</span><span id="e761" class="lz ks hh lv b fi me mb l mc md">private:<br/>        Eigen::Matrix&lt;int,rows,cols&gt; pixels;<br/>        int label;</span><span id="b8e6" class="lz ks hh lv b fi me mb l mc md">};</span><span id="4a9a" class="lz ks hh lv b fi me mb l mc md">Image::Image(){}</span><span id="c2b7" class="lz ks hh lv b fi me mb l mc md">Image::Image(std::vector&lt;std::vector&lt;unsigned char&gt;&gt; pixels, unsigned char label){<br/>    for(int i = 0; i &lt; rows; i++){<br/>        for(int j = 0; j &lt; cols; j++){</span><span id="cae0" class="lz ks hh lv b fi me mb l mc md">            // The () operator has been overloaded in the Eigen library to access specific elements</span><span id="64f8" class="lz ks hh lv b fi me mb l mc md">            this-&gt;pixels(i,j) = (int)pixels[i][j];<br/>        }<br/>    }<br/>    this-&gt;label = (int)label;<br/>}</span><span id="1c19" class="lz ks hh lv b fi me mb l mc md">Image::~Image(){}</span><span id="cd56" class="lz ks hh lv b fi me mb l mc md">Eigen::Matrix&lt;int,28,28&gt; Image::getPixelData() const{<br/>    return this-&gt;pixels;<br/>}</span><span id="90ea" class="lz ks hh lv b fi me mb l mc md">int Image::getLabel() const{<br/>    return this-&gt;label;<br/>}</span></pre><p id="5d0c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们可以开始从训练数据集文件中读入像素数据。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="f8f2" class="lz ks hh lv b fi ma mb l mc md">for (int num = 0; num&lt; number_of_images; num++) {</span><span id="13bb" class="lz ks hh lv b fi me mb l mc md">      // Creating a 28x28 vector to store pixel values<br/>      std::vector&lt;std::vector&lt;unsigned char&gt;&gt; pixels(number_of_rows,std::vector&lt;unsigned char&gt;(number_of_cols));</span><span id="5dbf" class="lz ks hh lv b fi me mb l mc md">      // Looping through file to construct 28x28 pixel matrix</span><span id="bdae" class="lz ks hh lv b fi me mb l mc md">      for (int j = 0; j &lt; number_of_rows; j++) {<br/>        for (int k = 0; k &lt; number_of_cols; k++) {<br/>            unsigned char temp;<br/>            image_file.read((char*)&amp;temp,sizeof(temp));<br/>            pixels[j][k] = temp;<br/>        }<br/>      }</span><span id="92a7" class="lz ks hh lv b fi me mb l mc md">      // Construct Image object with pixels and corresponding label<br/>      this-&gt;image_data[num] = Image(pixels,labels[num]);<br/>}</span></pre><p id="1f90" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们在这里使用无符号字符，因为它们相当于我们试图从文件中读取的无符号字节。</p><h1 id="1b81" class="kr ks hh bd kt ku lk kw kx ky ll la lb in lm io ld iq ln ir lf it lo iu lh li bi translated">模型设计</h1><p id="51ea" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">如前所述，我们将使用K-最近邻算法。它是一种受监督的机器学习算法，可用于分类或回归。监督学习指的是我们用示例数据训练算法的事实。这对我们的例子来说是完美的，因为我们希望它对<em class="kj">手写数字进行分类。所做的假设是，相似的事物存在于彼此附近，在我们的情况下，这意味着属于相同数字分类的数字将具有相似的<em class="kj">外观，坦率地说就是</em>。我们将声明以下函数:</em></p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="7962" class="lz ks hh lv b fi ma mb l mc md">// Choose k to be 10 because there are 10 possible digits 0-9<br/>bool Classify(std::vector&lt;Image&gt; data, Image query, int k=10);</span></pre><p id="8b01" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">因此，数据准备后算法的第一步是距离计算，我们将使用欧几里德公式，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mg"><img src="../Images/a97c427cde979f41dbac8913da4bd22c.png" data-original-src="https://miro.medium.com/v2/resize:fit:392/1*m1FvFIBVIbzPZG1j-3yOqQ.gif"/></div></figure><p id="d8c9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们有代表这些像素值的矩阵，所以我们将计算这些值之间的距离。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="857a" class="lz ks hh lv b fi ma mb l mc md">std::vector&lt;std::pair&lt;int, int&gt;&gt; dist_and_k;</span><span id="526d" class="lz ks hh lv b fi me mb l mc md">for (int i = 0; i &lt; data.size(); i++) {<br/>        dist_and_k.push_back(<br/>        std::make_pair(<br/>          (data[i].getPixelData()<br/>           -query.getPixelData()).array().pow(2).sum(),<br/>           data[i].getLabel())<br/>        );<br/>}</span></pre><p id="38f5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">上面的片段有点复杂，让我们从头到尾看一遍。首先，我们定义一个向量对，代表一个标量距离值和该图像的标签。我们开始遍历所有图像，取训练图像的像素值和查询图像的像素值之间的差。然后，我们将该矩阵转换为一维数组，这样我们就可以轻松地对值求平方，然后将所有值相加，得到一个标量值，并将其与相应的标签值配对。这是使用一些本征魔术来简化操作到一行。</p><p id="ac13" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在构建我们的向量对之后，我们需要按降序对其进行排序，以找到最短距离，这对应于与查询图像最接近的图像。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="6c91" class="lz ks hh lv b fi ma mb l mc md">sort(dist_and_k.begin(), dist_and_k.end(),<br/>           [](std::pair&lt;int, int&gt; p, std::pair&lt;int, int&gt; p2) {<br/>             return p.first &lt; p2.first; <br/>}); </span></pre><p id="9e1c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们使用排序算法，并向它传递一个lambda函数，根据距离对向量进行排序。</p><p id="bc43" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在我们存储排序向量中前k个标签的标签(记住k是作为参数给我们的)。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="605c" class="lz ks hh lv b fi ma mb l mc md">std::vector&lt;int&gt; k_labels(k); // Create vector of size k</span><span id="2fbc" class="lz ks hh lv b fi me mb l mc md">for (int i = 0; i &lt; k; i++) {<br/>   k_labels[i] = dist_and_k[i].second; // Only store the labels in vector<br/>}</span></pre><p id="b987" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们评估我们的猜测是否正确之前，我们需要定义一个选择函数来确定哪一个K标签最有可能是正确的。所以我们定义了一个函数，它采用标签的<em class="kj">模式</em>。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="bc16" class="lz ks hh lv b fi ma mb l mc md">#include &lt;algorithm&gt; </span><span id="f3ce" class="lz ks hh lv b fi me mb l mc md">int mode(std::vector&lt;int&gt; v) {</span><span id="8b09" class="lz ks hh lv b fi me mb l mc md">int maxCount = 1;<br/>int mode = v[0]; // Init mode value to first label</span><span id="77d2" class="lz ks hh lv b fi me mb l mc md">for_each(v.begin(), v.end(), [&amp;](int i) {<br/>       int d = std::count(v.begin(), v.end(), i); // Count each value<br/>       if (d &gt; maxCount) { // See if count is greater than max<br/>         maxCount = d;<br/>         mode = i; // Update mode to new label<br/>       }<br/>  });<br/>  return mode; <br/>}</span></pre><p id="ef09" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">上面的函数只是在我们选择的k个标签中寻找最常见的标签。</p><p id="86e2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在我们可以将下面的表达式添加到Classify函数的底部。</p><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="9447" class="lz ks hh lv b fi ma mb l mc md">return mode(k_labels)==query.getLabel();</span></pre><p id="1b24" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果我们的猜测与赋予函数的标签相匹配，则计算结果为true。</p><p id="2e43" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">就这样，现在我们可以看到我们的算法有多精确。</p><h1 id="154f" class="kr ks hh bd kt ku lk kw kx ky ll la lb in lm io ld iq ln ir lf it lo iu lh li bi translated">估价</h1><pre class="ix iy iz ja fd lu lv lw lx aw ly bi"><span id="02b0" class="lz ks hh lv b fi ma mb l mc md">dh.prepareData("path_to_images", "path_to_labels"); // Get image data<br/>// Read test data, you can implement your own function for this</span><span id="8842" class="lz ks hh lv b fi me mb l mc md">double count = 0;<br/>double iterNum = 10;</span><span id="77aa" class="lz ks hh lv b fi me mb l mc md">for(int i = 0; i &lt; iterNum; i++){<br/>     bool eval =   Classify(dh.get_Image_Data(),dh.get_Test_Image_Data([i],10);<br/>     if(eval) count++;<br/>}</span><span id="6ff9" class="lz ks hh lv b fi me mb l mc md">cout &lt;&lt; "Accuracy: " &lt;&lt; (count/(iterNum)*100) &lt;&lt; "%\n";</span><span id="2304" class="lz ks hh lv b fi me mb l mc md">// Output Example: Accuracy: 97.4%</span></pre><p id="ea76" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在需要添加的是读取测试数据，但这将使用我们用于读取训练数据的确切函数，我将实现留给读者。另外需要注意的是，执行需要一段时间，因为每次调用classify函数时，我们都要遍历60000张图像。</p><h1 id="3715" class="kr ks hh bd kt ku lk kw kx ky ll la lb in lm io ld iq ln ir lf it lo iu lh li bi translated">现在去哪里？</h1><p id="3489" class="pw-post-body-paragraph jn jo hh jp b jq lp ii js jt lq il jv jw lr jy jz ka ls kc kd ke lt kg kh ki ha bi translated">现在你可以找点乐子了，通过调整iterNum变量，试试k的值，看看它是如何影响结果的，或者看看在运行更大块的数据时，精度是如何变化的。通过试验不同的距离计算函数，有一些提高程序效率的方法，如果你想知道更多，请看这篇<a class="ae jm" href="https://springerplus.springeropen.com/articles/10.1186/s40064-016-2941-7" rel="noopener ugc nofollow" target="_blank">学术论文</a>。这是一个非常简单的项目，但我认为这是一个很好的起点，也许可以添加不同的算法，也许可以创建自己的ML库，但希望你喜欢！完整的项目在下面链接的我的Github上。</p><p id="d449" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><a class="ae jm" href="https://github.com/sKorpion19091/KNearestNeighbourFromScratch" rel="noopener ugc nofollow" target="_blank"> <strong class="jp hi">完整项目</strong> </a></p></div></div>    
</body>
</html>