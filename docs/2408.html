<html>
<head>
<title>MLOPS-building a deep learning project from end to end (part-1).</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ml ops-构建端到端的深度学习项目(第1部分)。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mlops-building-a-deep-learning-project-from-end-to-end-part-1-5ae1e6e76906?source=collection_archive---------5-----------------------#2021-04-22">https://medium.com/analytics-vidhya/mlops-building-a-deep-learning-project-from-end-to-end-part-1-5ae1e6e76906?source=collection_archive---------5-----------------------#2021-04-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3e5ca6947b570f0dbc21f5263ad0be56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kS7N0vIWlhcF2vXF.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">信用——valohai.com</figcaption></figure><p id="4199" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi js translated"><span class="l jt ju jv bm jw jx jy jz ka di"> F </span>在过去几年的软件行业中，我们已经听到了很多关于“DEVOps”的说法，由于它对传统方法(包括SDLC(软件开发生命周期))的改进得到了证实，因此已经被许多行业迅速采用。尽管最流行的“敏捷”方法在过去十年中为我们提供了很好的服务，但在它专注于弥合客户和开发人员团队之间的差距时，DevOps专注于弥合开发人员和进一步运营之间的差距，这也是自动化管道的形式，也称为CI-CD(持续集成和持续交付)。</p><p id="19db" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">另一方面，数据科学行业也经历了蓬勃发展，一些类似的实践将进一步增强它，因此，它采用了2015年提出的“MLOPS”(机器学习操作)。<br/>在本文中，我们将简要介绍一些基本概念，然后从端到端直至部署，继续构建一个简单的深度学习项目，为了简化，本文将分为两个部分。在第1部分中，将加载、分割和训练模型，在第2部分中将包括部署。</p><h1 id="841a" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">内容</strong></h1><ol class=""><li id="5cbe" class="kz la hi iw b ix lb jb lc jf ld jj le jn lf jr lg lh li lj bi translated">什么是MLOPS？</li><li id="3ee8" class="kz la hi iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">DVC简介</li><li id="4d43" class="kz la hi iw b ix lk jb ll jf lm jj ln jn lo jr lg lh li lj bi translated">项目实施和设计第1部分</li></ol></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="b314" class="kb kc hi bd kd ke lw kg kh ki lx kk kl km ly ko kp kq lz ks kt ku ma kw kx ky bi translated">1.什么是MLOPS？</h1><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/7b07d5eab3ec7fa69d0b12f8886babaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WoiCWz3N7QaYU77C.jpg"/></div></div></figure><p id="8d3c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">简单地说，这是一个数据科学/机器学习项目生命周期与运营的聚合，它基于DevOps，但有一些额外的附加内容，如构建<strong class="iw hj"> ci-cd管道</strong>和<strong class="iw hj">模型再培训方法</strong>。这些实践仅仅是为了减少构建完整项目所花费的时间，同时保证质量和强大的软件监控体验。MLOps只是帮助针对给定的问题建立更有效的业务解决方案。要详细了解它，请查看此<a class="ae mg" href="https://blogs.nvidia.com/blog/2020/09/03/what-is-mlops/" rel="noopener ugc nofollow" target="_blank">文章</a>。</p><h1 id="58ef" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">2.DVC简介</h1><p id="de8c" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">DVC(数据版本控制)是一个开源工具，用于机器学习项目的跟踪和版本控制。它用于与git协作创建ci-cd管道。如果你熟悉git，那么使用这个工具非常容易。该工具还涵盖了远程存储，如S3、Azure Blob存储、Google Drive、Google云存储、HDFS、HTTP、网络连接存储或存储数据的光盘。<br/>此外，它还集成了大数据，如HDFS、Hive和Apache Spark。</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/7e1d0a1a791e0252a84d39b5f3eb3ef8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nFJy_FSzwLmZxSX8.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">source-dvc.org</figcaption></figure><p id="7f66" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">DVC框架相当大，我可以写一篇关于DVC本身的单独文章，展示它的不同特性和功能。除了DVC，还有许多其他的MLOps工具，如MlFlow、DataBricks、云平台，如AWS、Azure和GCP等。在本文中，我们将使用DVC，因为它是一个简单而强大的入门工具。<br/>上图显示了DVC如何帮助建立完整的管道直至部署。</p><h1 id="ca4f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">3.项目实施第一部分</h1><p id="e39e" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">简介:-我们将在后面建立一个简单的分类模型，并在前面创建一个web应用程序，最后将其部署在云平台上，如Heroku。</p><p id="b363" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.1:创建一个anaconda环境并安装需求</p><p id="f8e1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在操作系统中打开终端或cmd，并键入以下命令</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="2158" class="mq kc hi mm b fi mr ms l mt mu">conda create -n 'env name' python==3.7</span></pre><p id="9485" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">创建环境后，键入</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="62a6" class="mq kc hi mm b fi mr ms l mt mu">conda activate 'env name'</span></pre><p id="4df1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">您将在cmd/terminal中的路径旁边看到您的环境名称</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mv"><img src="../Images/c7b4b00d5f640af42c6af7f6723a29e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bP8SJ6r4CqKdH2ww9IB6Og.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.1-创建并激活环境后</figcaption></figure><p id="a8f9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在从Github下载我的repo并安装requirements.txt文件，该文件包含项目的所有依赖项。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="3427" class="mq kc hi mm b fi mr ms l mt mu">pip install requirements.txt -r</span></pre><p id="bca2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">执行时，您可能会看到以下内容&amp;进入当前cmd工作目录。</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mw"><img src="../Images/187eca87369f7342f12dd800ad7c24d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jMtYLTeDqv_gyCJYFBKkog.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.2-安装软件包</figcaption></figure><p id="e8d7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.2了解我们的项目架构<br/>在继续之前，让我们浏览一下我们的项目架构，了解一下管道。</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mx"><img src="../Images/60c7c49572b5e92d1d1ea139b6d8b31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kse94G0gsUq8E6R_Rf4Lqg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.3-项目架构</figcaption></figure><p id="f111" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里，管道从数据收集开始，它可以来自任何来源，如任何云或实时数据流。在我们的案例中，我们将使用已经收集的数据。<br/>在下一阶段，我们将准备数据，特别是根据给定的比率将其分为训练和测试。<br/>接下来是模型构建阶段，我们将训练并保存我们的模型。<br/>一旦模型得到训练，我们将通过一些指标和图表来评估我们的模型表现如何。<br/>最后，在完成所有这些后，该模型将在Heroku上部署，在前端使用web-app，并与flask API配对。DVC负责跟踪数据和管道。<br/> Github操作有助于构建管道，并在部署前持续集成管道。最后，对于所有方式，git库是推送所有代码的基础库。</p><p id="98e0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.3初始化git和DVC并获取根目录中的数据(阶段1) <br/>我们将创建Git的本地repo并启动DVC。<br/>在终端/命令中键入以下命令。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="c2e7" class="mq kc hi mm b fi mr ms l mt mu">git init<br/>dvc init</span></pre><p id="e31d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成后，您将看到如下所示的两个文件</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es my"><img src="../Images/cf34f174fe9ff4406da891f0e0e02d25.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*rv3UOdT6ZFucF52823J9ZQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.4-运行以上两个命令后</figcaption></figure><p id="46ba" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，要开始跟踪cmd中的数据，请键入以下命令</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="af9d" class="mq kc hi mm b fi mr ms l mt mu">dvc add Data_Set/Bulbasaur<br/>dvc add Data_Set/Charmander<br/>dvc add Data_Set/Squirtle</span></pre><p id="71b9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行以上程序后，你会在下面显示的Data_Set目录中看到一些新文件。</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mz"><img src="../Images/e031fbca15d8f272b7ba2804b0af6e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LsfBykXekr3KtPti6DDM3w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.5- .运行以上3个命令后，创建了dvc文件</figcaption></figure><h2 id="e7a9" class="mq kc hi bd kd na nb nc kh nd ne nf kl jf ng nh kp jj ni nj kt jn nk nl kx nm bi translated">3.4创建“config.yaml”和其他文件夹</h2><p id="ff78" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">现在，我们需要一些配置文件和文件夹，我们可以从这些文件和文件夹开始构建管道。请看下图，并在cmd/terminal中键入命令</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/3704ae64a63809d79c3b4093aba8bbd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D47Yiq00bK7i3SfyDSU0cQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.6-创建所需文件和文件夹的命令</figcaption></figure><blockquote class="no np nq"><p id="de48" class="iu iv nr iw b ix iy iz ja jb jc jd je ns jg jh ji nt jk jl jm nu jo jp jq jr hb bi translated">注意-如果你使用的是Linux，使用命令“touch”而不是“type nul &gt; &gt;”，也不要运行“git init ”,因为我们之前已经运行过了。</p></blockquote><p id="89d9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，您将得到如下所示的目录结构</p><h2 id="33d6" class="mq kc hi bd kd na nb nc kh nd ne nf kl jf ng nh kp jj ni nj kt jn nk nl kx nm bi translated">3.5配置文件和数据准备(第二阶段)</h2><p id="38db" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">在“parameters.yaml”文件中复制粘贴以下参数，您可以使用文本编辑器或IDE。为此，我将使用VS代码。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="4a37" class="mq kc hi mm b fi mr ms l mt mu">base:<br/>  project: Deep Learning using MlOPS</span><span id="cc38" class="mq kc hi mm b fi nv ms l mt mu">data_source:<br/>  data_src: Data_Set</span><span id="c0cc" class="mq kc hi mm b fi nv ms l mt mu">load_data:<br/>  num_classes: 3<br/>  raw_data: Data_Set<br/>  preprocessed_data: Data\preprocessed<br/>  full_p: \MlOPS-DeepLearning\Data_Set</span></pre><p id="5d50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">以下是'中的以下参数。yaml '文件<br/> 1。' project ':代表项目名称<br/> 2。data_src:在我们的例子中，我们从哪里获取数据呢？是“Data_Set”文件夹。<br/> 3。num_classed:它是可用于分类的类的数量<br/> 4。预处理数据:分割数据将出现的目录<br/> 5。full_p:这是“数据集”文件夹的路径</p><blockquote class="no np nq"><p id="fd6f" class="iu iv nr iw b ix iy iz ja jb jc jd je ns jg jh ji nt jk jl jm nu jo jp jq jr hb bi translated">注意:因为这是我们将要构建的管道，所以任何更改都应该只在“parameter.yaml”中进行，除非我们想要更改完整的管道。例如，如果您有更多的类，如6或7，那么将值“num_classes”从3更改为6。</p></blockquote><p id="8183" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了读取配置文件，我创建了一个“getdata.py”文件，它从。yaml '文件基于提到的参数从该文件返回特定值。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="42b5" class="mq kc hi mm b fi mr ms l mt mu">import os<br/>import numpy as np<br/>import shutil<br/>import random<br/>import yaml<br/>import argparse</span><span id="8ee7" class="mq kc hi mm b fi nv ms l mt mu">def get_data(config_file):<br/>    config = read_params(config_file)<br/>    return config</span><span id="9d83" class="mq kc hi mm b fi nv ms l mt mu">def read_params(config_file):<br/>    with open(config_file) as conf:<br/>        config = yaml.safe_load(conf)<br/>        return config</span><span id="6beb" class="mq kc hi mm b fi nv ms l mt mu">if __name__ == '__main__':<br/>    args = argparse.ArgumentParser()<br/>    args.add_argument("--config", default = 'parameters.yaml')<br/>    passed_args = args.parse_args()<br/>    a = get_data(config_file = passed_args.config)</span></pre><p id="23f1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">下一步是为训练和测试准备数据(在我们的例子中是图像),所以下面的代码创建新的文件夹，如data-&gt;预处理-&gt;train，test<br/>train和test的每个子目录将包含3类图像。此外，分流比将在“parameters.yaml”中给出。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="7095" class="mq kc hi mm b fi mr ms l mt mu">import os<br/>import numpy as np<br/>import shutil<br/>import random<br/>import yaml<br/>import argparse<br/>from getdata import get_data</span><span id="5ae7" class="mq kc hi mm b fi nv ms l mt mu">####################method for creating folder#####################</span><span id="8f90" class="mq kc hi mm b fi nv ms l mt mu">def create_fold(config,img = None):<br/>    config = get_data(config)<br/>    dirr = config['load_data']['preprocessed_data']<br/>    cla = config['load_data']['num_classes']<br/>    print(dirr)<br/>    print(cla)</span><span id="489c" class="mq kc hi mm b fi nv ms l mt mu">if os.path.exists(dirr+'/'+'train'+'/'+'class_0') and os.path.exists(dirr+'/'+'test'+'/'+'class_0'):<br/>        print('train and test folders already exist...')<br/>        print('skipping it!')</span><span id="af0d" class="mq kc hi mm b fi nv ms l mt mu">else:<br/>        os.mkdir(dirr+'/'+'train')<br/>        os.mkdir(dirr+'/'+'test')<br/>        for i in range(cla):<br/>            <br/>            os.makedirs(os.path.join(dirr+'/'+'train','class_'+str(i)))<br/>            os.makedirs(os.path.join(dirr+'/'+'test','class_'+str(i)))</span><span id="b26a" class="mq kc hi mm b fi nv ms l mt mu">#####method for splitting the images for train and test####</span><span id="837a" class="mq kc hi mm b fi nv ms l mt mu">def train_test_split(config):<br/>    config =  get_data(config)<br/>    root_dir = config['data_source']['data_src'] <br/>    dest = config['load_data']['preprocessed_data']<br/>    p = config['load_data']['full_p']<br/>    cla = config['data_source']['data_src']<br/>    cla = os.listdir(cla)<br/>    cla = [i for i in cla if not i.endswith('.dvc') and cla if not i.startswith('.git')]<br/>    print(cla)<br/>    splitr = config['train_split']['split_ratio']<br/>    print(splitr)</span><span id="e54c" class="mq kc hi mm b fi nv ms l mt mu">for k in range(len(cla)):<br/>        print(cla[k])<br/>        per = len(os.listdir((os.path.join(root_dir,cla[k]))))<br/>        cnt = 0<br/>        for j in os.listdir(os.path.join(root_dir,cla[k])):<br/>            #per = len(os.path.join(root_dir,cla[k]))<br/>            #print(per)<br/>            pat = os.path.join(p+'/'+cla[k],j)<br/>            split_ratio = round((splitr/100)*per)<br/>            print(split_ratio)<br/>            if cnt != split_ratio:<br/>                #print(cnt)<br/>                shutil.copy(pat,dest+'/'+'train/class_'+str(k))<br/>                cnt = cnt+1</span><span id="d238" class="mq kc hi mm b fi nv ms l mt mu">            else:<br/>                shutil.copy(pat,dest+'/'+'test/class_'+str(k))</span><span id="9918" class="mq kc hi mm b fi nv ms l mt mu">print('done')</span><span id="df27" class="mq kc hi mm b fi nv ms l mt mu">if __name__ == '__main__':<br/>    args = argparse.ArgumentParser()<br/>    args.add_argument("--config", default = 'parameters.yaml')<br/>    passed_args = args.parse_args()<br/>    <br/>    create_fold(config=passed_args.config)<br/>    train_test_split(config = passed_args.config)</span></pre><blockquote class="no np nq"><p id="b517" class="iu iv nr iw b ix iy iz ja jb jc jd je ns jg jh ji nt jk jl jm nu jo jp jq jr hb bi translated">注意-把上面的两个代码放到src文件夹中，不要放在根文件夹中。</p></blockquote><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nw"><img src="../Images/131328da9f1abc643341cff4f547899d.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*DYFYt6X73ZjHdLb16L6fNA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.7-运行“split.py”文件</figcaption></figure><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es nx"><img src="../Images/7c9e91ea7f2dfdc7f0c3ddc7a9aa1ce1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*9fyXTUEVc21nmViPgbvxKQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.7-子目录已创建。</figcaption></figure><p id="d47b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面两张图片是运行“split.py”文件的结果，每个子目录都包含按拆分比例排列的图像(测试文件夹也是如此)。</p><h2 id="97b8" class="mq kc hi bd kd na nb nc kh nd ne nf kl jf ng nh kp jj ni nj kt jn nk nl kx nm bi translated">3.6模型构建和培训</h2><p id="3772" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">现在是构建和训练模型的时候了，在我们的例子中是VGG19。您可以使用您选择的任何其他模型。但是，即使是为了构建模型，我们也需要给出一些参数，我们将通过“parameters.yaml”文件给出这些参数。看看下面的片段。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="fa86" class="mq kc hi mm b fi mr ms l mt mu">model:<br/>  name: ResNet50<br/>  trainable: False<br/>  train_path: Data\preprocessed\train<br/>  test_path: Data\preprocessed\test<br/>  image_size: [225,225]<br/>  loss: 'categorical_crossentropy'<br/>  optimizer: 'adam' <br/>  metrics: ['accuracy']<br/>  epochs: 8<br/>  sav_dir : 'saved_models/trained.h5'</span><span id="7366" class="mq kc hi mm b fi nv ms l mt mu">img_augment:<br/>  rescale: 1./255,<br/>  shear_range: 0.2<br/>  zoom_range: 0.2<br/>  horizontal_flip: True<br/>  vertical_flip: True<br/>  batch_size: 18<br/>  class_mode: 'categorical'</span></pre><p id="1eb9" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上述配置文件中的每个属性都是用于训练模型及其扩充的参数。您可以根据自己的选择对该文件进行更改。是时候建立模型了。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="c38f" class="mq kc hi mm b fi mr ms l mt mu">import numpy as np<br/>from keras.applications.resnet import ResNet50<br/>from keras_preprocessing.image import ImageDataGenerator<br/>from keras.layers import Dense,Input,Flatten<br/>from keras.models import Model<br/>from glob import glob<br/>import os<br/>import argparse<br/>from getdata import get_data<br/>import matplotlib.pyplot as plt<br/>from keras.applications.vgg19 import VGG19</span><span id="dc1e" class="mq kc hi mm b fi nv ms l mt mu">def train_model(config_file):<br/>    <br/>    config = get_data(config_file)<br/>    train = config['model']['trainable']<br/>    if train == True:</span><span id="b92a" class="mq kc hi mm b fi nv ms l mt mu">img_size = config['model']['image_size']<br/>        trn_set = config['model']['train_path']<br/>        te_set = config['model']['test_path']<br/>        num_cls = config['load_data']['num_classes']<br/>        rescale = config['img_augment']['rescale']<br/>        shear_range = config['img_augment']['shear_range']<br/>        zoom_range  = config['img_augment']['zoom_range']<br/>        verticalf = config['img_augment']['vertical_flip']<br/>        horizontalf = config['img_augment']['horizontal_flip']<br/>        batch = config['img_augment']['batch_size']<br/>        class_mode = config['img_augment']['class_mode']<br/>        loss = config['model']['loss']<br/>        optimizer = config['model']['optimizer']<br/>        metrics = config['model']['metrics']<br/>        epochs = config['model']['epochs']</span><span id="9ca7" class="mq kc hi mm b fi nv ms l mt mu">#print(type(batch))</span><span id="a3fe" class="mq kc hi mm b fi nv ms l mt mu">resnet = VGG19(input_shape = img_size +[3], weights = 'imagenet', include_top = False)</span><span id="b077" class="mq kc hi mm b fi nv ms l mt mu">for p in resnet.layers:<br/>            p.trainable = False</span><span id="2d07" class="mq kc hi mm b fi nv ms l mt mu">op = Flatten()(resnet.output)<br/>        prediction = Dense(num_cls,activation = 'softmax')(op)</span><span id="c3be" class="mq kc hi mm b fi nv ms l mt mu">mod = Model(inputs = resnet.input,outputs = prediction)<br/>        print(mod.summary())<br/>        img_size = tuple(img_size)</span><span id="c599" class="mq kc hi mm b fi nv ms l mt mu">mod.compile(loss = loss ,optimizer = optimizer , metrics = metrics)</span><span id="ab28" class="mq kc hi mm b fi nv ms l mt mu">train_gen = ImageDataGenerator(rescale = 1./255,<br/>                                    shear_range = shear_range,<br/>                                    zoom_range =  zoom_range,<br/>                                    horizontal_flip = horizontalf,<br/>                                    vertical_flip = verticalf,<br/>                                    rotation_range = 90)</span><span id="4970" class="mq kc hi mm b fi nv ms l mt mu">test_gen = ImageDataGenerator(rescale = 1./255)</span><span id="71e6" class="mq kc hi mm b fi nv ms l mt mu">train_set = train_gen.flow_from_directory(trn_set,<br/>                                                target_size = (225,225),<br/>                                                batch_size = batch,<br/>                                                class_mode = class_mode<br/>                                                )</span><span id="df32" class="mq kc hi mm b fi nv ms l mt mu">test_set = test_gen.flow_from_directory(te_set,<br/>                                                target_size = (225,225),<br/>                                                batch_size = batch,<br/>                                                class_mode = class_mode<br/>                                                )</span><span id="c57d" class="mq kc hi mm b fi nv ms l mt mu">history = mod.fit(train_set,<br/>                                 epochs = epochs,<br/>                                validation_data = test_set,<br/>                                steps_per_epoch = len(train_set),<br/>                                validation_steps = len(test_set)<br/>        )</span><span id="01e6" class="mq kc hi mm b fi nv ms l mt mu">plt.plot(history.history['loss'], label='train_loss')<br/>        plt.plot(history.history['val_loss'],label='val_loss')<br/>        plt.legend()<br/>        plt.savefig('Reports/train_v_loss')</span><span id="afaf" class="mq kc hi mm b fi nv ms l mt mu">plt.plot(history.history['accuracy'], label='accuracy')<br/>        plt.plot(history.history['val_accuracy'],label='val_acc')<br/>        plt.legend()<br/>        plt.savefig('Reports/acc_v_vacc')</span><span id="f530" class="mq kc hi mm b fi nv ms l mt mu">mod.save('saved_models/trained.h5')<br/>        print('model saved')<br/>    <br/>    else:<br/>        print('Model not trained')</span><span id="0d40" class="mq kc hi mm b fi nv ms l mt mu">if __name__ == '__main__':</span><span id="7e18" class="mq kc hi mm b fi nv ms l mt mu">args_parser = argparse.ArgumentParser()<br/>    args_parser.add_argument('--config',default='parameters.yaml')<br/>    passed_args = args_parser.parse_args()<br/>    train_model(config_file=passed_args.config)</span></pre><p id="be3b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码中，我们根据我们的数据训练VGG16，并将模型文件保存到“保存的模型”目录中，精度损失将保存在“报告”目录中。</p><blockquote class="no np nq"><p id="094a" class="iu iv nr iw b ix iy iz ja jb jc jd je ns jg jh ji nt jk jl jm nu jo jp jq jr hb bi translated">注意:如果您不想再次训练模型，请在parameters.yaml文件中将“可训练”参数更改为“False”。</p></blockquote><p id="7416" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">训练后，您将看到以下输出。</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ny"><img src="../Images/0c9e94175239c8a3e539b163a9753ae2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7Id_MwXigvVMwnENLYZBpg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.8-培训后</figcaption></figure><p id="92d1" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在此之后，我们将把所有的更新推到我们的GitHub repo中，然后去GitHub创建一个新的repo并复制它的URL。然后执行以下步骤。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="b500" class="mq kc hi mm b fi mr ms l mt mu">git remote add origin 'paste your github repo url'<br/>git add .<br/>git commit -m "model training done"<br/>git push origin main</span></pre><blockquote class="no np nq"><p id="6796" class="iu iv nr iw b ix iy iz ja jb jc jd je ns jg jh ji nt jk jl jm nu jo jp jq jr hb bi translated">注意:可选地，你也可以在每个阶段之后继续将变更推送到github。</p></blockquote><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nz"><img src="../Images/66e38972693b6b0f5f21ea3d117abe12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PqvCBDc64vL6LT2nKePiOw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">1.9-将更新推送到GitHub repo后</figcaption></figure><p id="d5c7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，如果您检查报告目录，那么您将发现2个图像，它们是带有验证准确性的列车准确性和带有验证损失的列车损失图。</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es oa"><img src="../Images/1d37c579673eabe38c006d31c79182a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*CRojDUDTKo9vSiB1Bg1uvQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">2.0-保存的图</figcaption></figure><p id="da2f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">3.7评估</p><p id="83be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">完成培训后，我们将通过生成混淆矩阵和分类报告来评估性能。<br/>并将它们分别以图像和CSV格式保存在“报告”目录中。在源目录中创建一个名为“evaluate.py”的新文件，并粘贴下面的代码片段。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="e55d" class="mq kc hi mm b fi mr ms l mt mu">from keras.models import load_model<br/>from sklearn.metrics import confusion_matrix,classification_report<br/>import os<br/>import numpy as np<br/>import argparse<br/>from getdata import get_data<br/>from keras_preprocessing.image import ImageDataGenerator<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span><span id="aad1" class="mq kc hi mm b fi nv ms l mt mu">def m_evaluate(config_file):<br/>    config = get_data(config_file)<br/>    batch = config['img_augment']['batch_size']<br/>    class_mode = config['img_augment']['class_mode']<br/>    te_set = config['model']['test_path']<br/>    model = load_model('saved_models/trained.h5')<br/>    config = get_data(config_file)</span><span id="5938" class="mq kc hi mm b fi nv ms l mt mu">test_gen = ImageDataGenerator(rescale = 1./255)<br/>    test_set = test_gen.flow_from_directory(te_set,<br/>                                                target_size = (225,225),<br/>                                                batch_size = batch,<br/>                                                class_mode = class_mode<br/>                                                )</span><span id="cdae" class="mq kc hi mm b fi nv ms l mt mu">label_map = (test_set.class_indices)<br/>    print(label_map)<br/>    Y_pred = model.predict_generator(test_set, len(test_set))<br/>    y_pred = np.argmax(Y_pred, axis=1)<br/>    print('Confusion Matrix')<br/>    sns.heatmap(confusion_matrix(test_set.classes, y_pred ),annot = True)<br/>    plt.xlabel('Actual values, 0:Bulbasaur, 1:Charmander,2:Squirtle')<br/>    plt.ylabel('Predicted values, 0:Bulbasaur, 1:Charmander,2:Squirtle')<br/>    plt.savefig('Reports/Confusion Matrix')<br/>   # plt.show()<br/>    print('Classification Report')<br/>    target_names = ['Bulbasaur', 'Charmander', 'Squirtle']<br/>    df = pd.DataFrame(classification_report(test_set.classes, y_pred, target_names=target_names, output_dict=True)).T<br/>    df['support'] = df.support.apply(int)<br/>    df.style.background_gradient(cmap='viridis',<br/>                             subset=pd.IndexSlice['0':'9', :'f1-score'])<br/>    df.to_csv('Reports/classification_report')<br/>    print('Classification Report And Confusion Matrix Saved at Reports Directory')</span><span id="48cb" class="mq kc hi mm b fi nv ms l mt mu">if __name__ == '__main__':<br/>    args_parser = argparse.ArgumentParser()<br/>    args_parser.add_argument('--config',default='parameters.yaml')<br/>    passed_args = args_parser.parse_args()<br/>    m_evaluate(config_file=passed_args.config)</span></pre><p id="3475" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行后，您将看到如下所示的2个新文件</p><figure class="mc md me mf fd ij er es paragraph-image"><div class="er es ob"><img src="../Images/abf7abc60319513477ccf7b04b2d52b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*UE9WBvC7AMPDUYqxc-qpHQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">2.1-混淆矩阵和分类报告</figcaption></figure><p id="0dcf" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在是时候向GitHub推送更新了</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="5200" class="mq kc hi mm b fi mr ms l mt mu">git add .<br/>git commit -m "model evaluated and reports saved"<br/>git push origin main</span></pre><h2 id="5499" class="mq kc hi bd kd na nb nc kh nd ne nf kl jf ng nh kp jj ni nj kt jn nk nl kx nm bi translated">3.8建筑管道</h2><p id="f312" class="pw-post-body-paragraph iu iv hi iw b ix lb iz ja jb lc jd je jf mh jh ji jj mi jl jm jn mj jp jq jr hb bi translated">接下来，我们将开始制作管道，因为所有阶段都是按顺序执行的，为此我们需要在“dvc.yaml”文件中添加参数。<br/>打开‘DVC . YAML’文件，粘贴以下参数。该文件负责将所有阶段连接在一起，形成一个完整的管道。</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="c5dc" class="mq kc hi mm b fi mr ms l mt mu">stages:<br/>  load_data:<br/>    cmd: python src/split.py --config=parameters.yaml<br/>    deps:<br/>    - src/getdata.py<br/>    - src/split.py<br/>    - Data_Set/<br/>        <br/>      <br/>    outs:<br/>    - data/preprocessed:<br/>         persist: true</span><span id="2e36" class="mq kc hi mm b fi nv ms l mt mu">train_model:<br/>    cmd: python src/model_train.py --config=parameters.yaml<br/>    deps:<br/>    - src/getdata.py<br/>    - src/model_train.py<br/>    outs:<br/>    - saved_models:<br/>          persist: true<br/>    - Reports:<br/>          persist: true</span><span id="3eef" class="mq kc hi mm b fi nv ms l mt mu">evaluate:<br/>    cmd: python src/evaluate.py --config=parameters.yaml<br/>    deps:<br/>    - src/getdata.py<br/>    - src/evaluate.py</span></pre><p id="7543" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">' dvc.yaml '用于构建和执行管道，其中:<br/> 1。阶段:定义管道的阶段<br/> 2。load_data，train_model，evaluate:是阶段的名称<br/> 3。cmd:用于运行特定的python文件<br/> 4。deps:是运行我们的python文件<br/> 5所需的依赖项。outs:用于指定执行脚本的输出应该保存在哪里<br/> 6。persist:允许保留执行管道后所做的更改</p><p id="be5c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">因此，要运行管道中的所有阶段，只需在cmd/terminal中运行下面的命令</p><pre class="mc md me mf fd ml mm mn mo aw mp bi"><span id="3b0b" class="mq kc hi mm b fi mr ms l mt mu">dvc repro</span></pre><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es oc"><img src="../Images/7bda6d42f2db58fabed936715a64f1cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dTOZAgrJyZGj8FpFKlsSjw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">2.2-运行上述命令后</figcaption></figure><p id="7137" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">运行“dvc再现”命令后，所有管道将执行并生成一个“dvc.lock”文件，在该文件中跟踪管道中的所有更改</p><figure class="mc md me mf fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es od"><img src="../Images/4c04dac3974a30c3196e7dd980f23139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6P9wnmUVMv7vuzvEfJ7VQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">2.3-dvc.lock文件</figcaption></figure><p id="e206" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它还为管道中每个阶段的每个文件生成一个唯一的哈希值，即md5。</p><p id="1197" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">到目前为止，我们已经建立了准备数据、模型训练和评估的管道。但我们还没有完成，我们仍然需要使用flask构建一个web应用程序，并在GitHub actions的帮助下，使用“持续集成和部署”将其部署在Heroku中。<br/>由于这篇文章已经很长了，我将在下一部分继续，即第2部分，我们将继续部署这个模型。这是我目前项目的GitHub回购，你可以下载。</p><p id="74ea" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">也就是说，在我的下一篇文章，也就是非常有趣的第二部分，再见！….这是我文章第二部分的链接。如有任何疑问，您可以通过<a class="ae mg" href="https://www.linkedin.com/in/prathmesh-patil-b151051a3" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>联系我。</p></div></div>    
</body>
</html>