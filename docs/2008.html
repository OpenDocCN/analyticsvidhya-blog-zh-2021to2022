<html>
<head>
<title>Deep Learning Implementation with Keras and Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Keras和Tensorflow实现深度学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-learning-implementation-with-keras-and-tensorflow-c29ef21e5a1d?source=collection_archive---------10-----------------------#2021-03-31">https://medium.com/analytics-vidhya/deep-learning-implementation-with-keras-and-tensorflow-c29ef21e5a1d?source=collection_archive---------10-----------------------#2021-03-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="91cd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">喀拉斯和张量流</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/d324547e180a0cbd017336237ff3240b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wwnExqe720PPHykHhs5Hqw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">克拉斯</figcaption></figure><h1 id="5283" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">克拉斯</h1><p id="437d" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">Keras 是一个开源软件库，为人工神经网络提供了Python接口。Keras充当TensorFlow库的接口。</p><p id="bb39" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">Keras的开发重点是实现快速实验。正因为如此，它非常用户友好，让我们从想法到实现只需几步。</p><h1 id="d04f" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">先决条件</h1><p id="84d9" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">首先浏览一下我的关于带有Keras代码的<a class="ae lf" rel="noopener" href="/analytics-vidhya/deep-learning-fundamental-concept-with-keras-code-8293640699b">深度学习基本概念的文章。</a></p><p id="ded0" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我会推荐你使用Google Colab来执行本课程的代码。</p><p id="e2d0" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">使用此网站编码相关问题</p><ul class=""><li id="f399" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated"><a class="ae lf" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/</a></li></ul><h1 id="ac4f" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">代码的Github链接</h1><p id="cc8d" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><a class="ae lf" href="https://github.com/AbhishekAdarshMishra/Deep-Learning-Implementation-with-Keras-and-Tensorflow" rel="noopener ugc nofollow" target="_blank">https://github . com/AbhishekAdarshMishra/Deep-Learning-Implementation-with-Keras-and-tensor flow</a></p><h1 id="7329" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">历史</h1><p id="2735" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">从历史上看，Keras是一个高级API，位于三个低级神经网络API之一之上，充当这些低级库的包装器。这些库被称为Keras后端引擎。</p><p id="126c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">后来，Keras与TensorFlow库集成在一起，现在完全打包在一起了。</p><p id="1145" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">现在，当您安装TensorFlow时，您还会自动获得Keras，因为它现在是TensorFlow库的一部分。</p><h1 id="f35a" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">如何安装Keras</h1><blockquote class="lp lq lr"><p id="b7a1" class="ke kf ls kg b kh la ii kj kk lb il km lt lc kp kq lu ld kt ku lv le kx ky kz ha bi translated">pip安装张量流</p></blockquote><h1 id="e22c" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated"><strong class="ak">colab中的GPU设置</strong></h1><p id="6ab8" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">-&gt;任务栏</p><ul class=""><li id="f665" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">-&gt;运行时</li><li id="f286" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">----&gt;更改运行时类型</li><li id="622a" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">--------&gt;硬件= GPU</li></ul><p id="fb63" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">代码</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="68d2" class="mg jn hh mc b fi mh mi l mj mk">physical_devices = tf.config.experimental.list_physical_devices('GPU')<br/>print("Num GPUs Available: ", len(physical_devices))<br/>tf.config.experimental.set_memory_growth(physical_devices[0], True)</span></pre><h1 id="9887" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">数据准备和预处理</h1><p id="569a" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">参考:-</p><ul class=""><li id="1c31" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated"><a class="ae lf" href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential" rel="noopener ugc nofollow" target="_blank">https://www . tensor flow . org/API _ docs/python/TF/keras/Sequential</a></li></ul><p id="52b0" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">顺序模型</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="8f64" class="mg jn hh mc b fi mh mi l mj mk">fit(<br/>    x=None, <br/>    y=None,<br/>    batch_size=None,<br/>    epochs=1,<br/>    verbose=1,<br/>    callbacks=None,<br/>    validation_split=0.0,<br/>    validation_data=None,<br/>    shuffle=True,<br/>    class_weight=None,<br/>    sample_weight=None,<br/>    initial_epoch=0,<br/>    steps_per_epoch=None,<br/>    validation_steps=None,<br/>    validation_batch_size=None,<br/>    validation_freq=1,<br/>    max_queue_size=10,<br/>    workers=1,<br/>    use_multiprocessing=False<br/>)</span></pre><p id="1e5c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">数据准备</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="710c" class="mg jn hh mc b fi mh mi l mj mk">import numpy as np<br/>from random import randint<br/>from sklearn.utils import shuffle<br/>from sklearn.preprocessing import MinMaxScaler</span><span id="86a6" class="mg jn hh mc b fi ml mi l mj mk">train_labels = []<br/>train_samples = []</span></pre><ul class=""><li id="6bc6" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">在一项临床试验中，一种实验性药物在年龄从<code class="du mm mn mo mc b">13</code>到<code class="du mm mn mo mc b">100</code>不等的个体身上进行了测试。</li><li id="2ee4" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">该试验有<code class="du mm mn mo mc b">2100</code>名参与者。一半的参与者不到<code class="du mm mn mo mc b">65</code>岁，另一半是<code class="du mm mn mo mc b">65</code>岁或以上。</li><li id="5576" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">大约<code class="du mm mn mo mc b">95%</code>名<code class="du mm mn mo mc b">65</code>或以上的患者出现了药物副作用。</li><li id="33d0" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">在<code class="du mm mn mo mc b">65</code>以下的患者中，大约<code class="du mm mn mo mc b">95%</code>的患者没有出现副作用。</li></ul><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="6e04" class="mg jn hh mc b fi mh mi l mj mk">for i in range(50):<br/>    # The ~5% of younger individuals who did experience side effects<br/>    random_younger = randint(13,64)<br/>    train_samples.append(random_younger)<br/>    train_labels.append(1)<br/>    # 1 represent experice side effect</span><span id="be91" class="mg jn hh mc b fi ml mi l mj mk">    # The ~5% of older individuals who did not experience side effects <br/>    random_older = randint(65,100)<br/>    train_samples.append(random_older)<br/>    train_labels.append(0)<br/>    # 0 represent does not experience side effect</span><span id="ac9d" class="mg jn hh mc b fi ml mi l mj mk">for i in range(1000):<br/>    # The ~95% of younger individuals who did not experience side effects<br/>    random_younger = randint(13,64)<br/>    train_samples.append(random_younger)<br/>    train_labels.append(0)<br/><br/>    # The ~95% of older individuals who did experience side effects<br/>    random_older = randint(65,100)<br/>    train_samples.append(random_older)<br/>    train_labels.append(1)</span><span id="0946" class="mg jn hh mc b fi ml mi l mj mk">for i in train_samples:<br/>    print(i)</span><span id="8b13" class="mg jn hh mc b fi ml mi l mj mk">for i in train_labels:<br/>    print(i)</span></pre><p id="aac1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们现在将两个列表都转换成NumPy数组，这是因为我们讨论了<code class="du mm mn mo mc b">fit()</code>函数所期望的，然后我们对数组进行洗牌，以去除在创建过程中对数据施加的任何顺序。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="db05" class="mg jn hh mc b fi mh mi l mj mk">train_labels = np.array(train_labels)<br/>train_samples = np.array(train_samples)<br/>train_labels, train_samples = shuffle(train_labels, train_samples)</span></pre><p id="b8a0" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><code class="du mm mn mo mc b">MinMaxScaler</code>类将所有数据从<code class="du mm mn mo mc b">13</code>到<code class="du mm mn mo mc b">100</code>的范围缩小到<code class="du mm mn mo mc b">0</code>到<code class="du mm mn mo mc b">1</code>的范围。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="8e96" class="mg jn hh mc b fi mh mi l mj mk">scaler = MinMaxScaler(feature_range=(0,1))<br/>scaled_train_samples = scaler.fit_transform(train_samples.reshape(-1,1))</span></pre><p id="4d77" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">让我们迭代缩放后的数据</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="7496" class="mg jn hh mc b fi mh mi l mj mk">for i in scaled_train_samples:<br/>    print(i)</span></pre><h1 id="feae" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">使用TensorFlow的Keras API创建神经网络</h1><p id="14ae" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">使用TensorFlow中集成的Keras API中的<code class="du mm mn mo mc b">Sequential</code>模型创建一个简单的人工神经网络。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="30e1" class="mg jn hh mc b fi mh mi l mj mk">import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Activation, Dense<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.metrics import categorical_crossentropy</span><span id="4de2" class="mg jn hh mc b fi ml mi l mj mk">physical_devices = tf.config.experimental.list_physical_devices('GPU')<br/>print("Num GPUs Available: ", len(physical_devices))<br/>#(if available gpu uncomment) tf.config.experimental.set_memory_growth(physical_devices[0], True)</span><span id="319f" class="mg jn hh mc b fi ml mi l mj mk">model = Sequential([<br/>    Dense(units=16, input_shape=(1,), activation='relu'),<br/>    Dense(units=32, activation='relu'),<br/>    Dense(units=2, activation='softmax')<br/>])</span><span id="b8e1" class="mg jn hh mc b fi ml mi l mj mk">model.summary()</span></pre><ul class=""><li id="4f78" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">第一层=它包含一个有16个(任意值)节点的密集层，我们也定义了输入形状。</li><li id="cca5" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">第二层=它是隐藏层。</li><li id="2180" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">第三层=包含输出。</li><li id="777a" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">softmax和relu是激活函数。</li></ul><h1 id="c3a6" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">训练神经网络</h1><h2 id="c959" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">编译模型</h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="05c4" class="mg jn hh mc b fi mh mi l mj mk">model.compile(optimizer=Adam(learning_rate=0.0001), loss='sparse_categorical_crossentropy', metrics=['accuracy'])</span></pre><ul class=""><li id="0457" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">它包含学习率、损失函数和我们为准确性度量选择的度量。</li><li id="b0fc" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">Adam接受可选参数学习率。</li></ul><h2 id="21e6" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">训练模型</h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="65a6" class="mg jn hh mc b fi mh mi l mj mk">model.fit(x=scaled_train_samples, y=train_labels, batch_size=10, epochs=30, verbose=2)</span></pre><ul class=""><li id="2e0f" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">Epoch是所有数据到网络的一次传递。即整个数据被传递的次数。</li><li id="d94f" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">批量是指每次通过的样本数量。</li><li id="6b97" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">对于输出，verbose为1或2。主要是2用在里面。</li><li id="fe40" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">在输出中，我们将看到模型的训练精度几乎达到94%。</li></ul><h1 id="3744" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">构建验证集</h1><p id="3e8a" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">我们希望训练数据集更准确，并且具有低损失值。因此，为了检查这一点，我们使用了一个验证集。</p><p id="ce37" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">在训练开始之前，我们可以选择删除训练集的一部分，并将其放入<strong class="kg hi">验证集</strong>。</p><ul class=""><li id="cbaf" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">验证集显示了我们的数据集有多一般化。</li><li id="4984" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">如果准确度和验证准确度相似，那么我们的模型是一般化的。</li><li id="0571" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">否则，也许存在过度拟合的情况。</li></ul><p id="45a2" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">有两种类型的验证集。</p><h2 id="49f9" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">1 &gt;手动创建验证集</h2><p id="50a8" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">Numpy数组或张量的元组<code class="du mm mn mo mc b">valid_set = (x_val, y_val)</code>。</p><p id="9db6" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">当我们调用<code class="du mm mn mo mc b">model.fit()</code>时，除了训练集之外，我们还会传入验证集</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="5900" class="mg jn hh mc b fi mh mi l mj mk">model.fit(<br/>      x=scaled_train_samples<br/>    , y=train_labels<br/>    , validation_data=valid_set<br/>    , batch_size=10<br/>    , epochs=30<br/>    , verbose=2<br/>)</span></pre><h2 id="66e4" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">2 &gt;使用Keras创建验证集</h2><p id="6ae1" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">当我们调用<code class="du mm mn mo mc b">model.fit()</code>时，我们可以为<code class="du mm mn mo mc b">validation_split</code>参数设置一个值。它需要一个介于<code class="du mm mn mo mc b">0</code>和<code class="du mm mn mo mc b">1</code>之间的分数。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a018" class="mg jn hh mc b fi mh mi l mj mk">model.fit(<br/>      x=scaled_train_samples<br/>    , y=train_labels<br/>    , validation_split=0.1<br/>    , batch_size=10<br/>    , epochs=30<br/>    , verbose=2<br/>)</span></pre><h1 id="b949" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">神经网络预测</h1><p id="465f" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi"> <em class="ls">推论</em> </strong></p><p id="12d3" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">该模型使用从训练中获得的知识，并使用它来推断预测或结果。</p><p id="90d1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi"> <em class="ls">测试设置</em> </strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="c1ef" class="mg jn hh mc b fi mh mi l mj mk">test_labels =  []<br/>test_samples = []<br/><br/>for i in range(10):<br/>    # The 5% of younger individuals who did experience side effects<br/>    random_younger = randint(13,64)<br/>    test_samples.append(random_younger)<br/>    test_labels.append(1)<br/><br/>    # The 5% of older individuals who did not experience side effects<br/>    random_older = randint(65,100)<br/>    test_samples.append(random_older)<br/>    test_labels.append(0)<br/><br/>for i in range(200):<br/>    # The 95% of younger individuals who did not experience side effects<br/>    random_younger = randint(13,64)<br/>    test_samples.append(random_younger)<br/>    test_labels.append(0)<br/><br/>    # The 95% of older individuals who did experience side effects<br/>    random_older = randint(65,100)<br/>    test_samples.append(random_older)<br/>    test_labels.append(1)<br/><br/>test_labels = np.array(test_labels)<br/>test_samples = np.array(test_samples)<br/>test_labels, test_samples = shuffle(test_labels, test_samples)<br/><br/>scaled_test_samples = scaler.fit_transform(test_samples.reshape(-1,1))</span></pre><p id="c1e1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">预测</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="c71b" class="mg jn hh mc b fi mh mi l mj mk">predictions = model.predict(<br/>      x=scaled_test_samples<br/>    , batch_size=10<br/>    , verbose=0  # zero as we dont want this function to print #output, instead we want it to be stored in prediction only<br/>)</span><span id="3299" class="mg jn hh mc b fi ml mi l mj mk">for i in predictions:<br/>    print(i)</span></pre><p id="5a7a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">第一列包含每个患者未出现副作用的概率，用<code class="du mm mn mo mc b">0</code>表示。第二列包含每个患者出现副作用的概率，用一个<code class="du mm mn mo mc b">1</code>表示。</p><p id="67b1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">因此，舍入预测将给出哪个值为0或1的概率较高。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="d6d8" class="mg jn hh mc b fi mh mi l mj mk">rounded_predictions = np.argmax(predictions, axis=-1)<br/><br/>for i in rounded_predictions:<br/>    print(i)</span></pre><h1 id="925e" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">混淆矩阵</h1><p id="1347" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">这用于评估我们的模型训练w.r.t测试集的准确程度。</p><p id="8cca" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">对于混淆矩阵，我们传递真实标签<code class="du mm mn mo mc b">test_labels</code>以及测试集的网络预测标签<code class="du mm mn mo mc b">rounded_predictions</code>。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="42c2" class="mg jn hh mc b fi mh mi l mj mk">%matplotlib inline<br/>from sklearn.metrics import confusion_matrix<br/>import itertools<br/>import matplotlib.pyplot as plt</span><span id="8980" class="mg jn hh mc b fi ml mi l mj mk">cm = confusion_matrix(y_true=test_labels, y_pred=rounded_predictions)</span></pre><p id="5d9e" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">下面，我们有一个名为<code class="du mm mn mo mc b">plot_confusion_matrix()</code>的函数，它直接来自于<a class="ae lf" href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_confusion_matrix.html#sphx-glr-auto-examples-model-selection-plot-confusion-matrix-py" rel="noopener ugc nofollow" target="_blank"> scikit-learn的网站</a>。这是他们为了绘制混乱矩阵而提供的代码。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="7707" class="mg jn hh mc b fi mh mi l mj mk">def plot_confusion_matrix(cm, classes,<br/>                        normalize=False,<br/>                        title='Confusion matrix',<br/>                        cmap=plt.cm.Blues):<br/>    """<br/>    This function prints and plots the confusion matrix.<br/>    Normalization can be applied by setting `normalize=True`.<br/>    """<br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)<br/><br/>    if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    else:<br/>        print('Confusion matrix, without normalization')<br/><br/>    print(cm)<br/><br/>    thresh = cm.max() / 2.<br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, cm[i, j],<br/>            horizontalalignment="center",<br/>            color="white" if cm[i, j] &gt; thresh else "black")<br/><br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span></pre><p id="d37f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">标签的标题是“无副作用”和“有副作用”</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="25fd" class="mg jn hh mc b fi mh mi l mj mk">cm_plot_labels = ['no_side_effects','had_side_effects']</span><span id="d89a" class="mg jn hh mc b fi ml mi l mj mk">plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='Confusion Matrix')</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/54102911d0dd759147472fdd23fda7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:694/format:webp/0*6ltyljdg4oBCu-p_.jpg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">图:混淆矩阵</figcaption></figure><h2 id="32a5" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">阅读混淆矩阵</h2><p id="b32a" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">主对角线包含当前值，次对角线包含错误答案。</p><p id="aa7c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">因此，主对角线应包含最大值，次对角线应包含最小值。</p><h1 id="4cc6" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">保存并加载模型</h1><p id="d783" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi"> 1。model.save() </strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="9505" class="mg jn hh mc b fi mh mi l mj mk"># Check first to see if file exists already.<br/># If not , the model is saved to disk.</span><span id="cc90" class="mg jn hh mc b fi ml mi l mj mk">import os.path<br/>if os.path.isfile('models/medical_trial_model.h5') is False:<br/>model.save('models/medical_trial_model.h5')</span></pre><p id="3dbc" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">此保存功能保存:</p><ul class=""><li id="6d61" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">模型的架构，允许重新创建模型。</li><li id="8b40" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">模型的重量。</li><li id="9d11" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">训练配置(损耗、优化器)。</li><li id="25b4" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">优化器的状态，允许从您停止的地方重新开始训练。</li></ul><p id="f38a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi"> 2。负载_型号</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="7850" class="mg jn hh mc b fi mh mi l mj mk">from tensorflow.keras.models import load_model<br/>new_model = load_model('models/medical_trial_model.h5')</span><span id="48af" class="mg jn hh mc b fi ml mi l mj mk">new_model.summary()</span><span id="368e" class="mg jn hh mc b fi ml mi l mj mk">new_model.get_weights()</span><span id="fe35" class="mg jn hh mc b fi ml mi l mj mk">new_model.optimizer</span></pre><p id="ce4d" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi"> 3。model.to_json() </strong></p><p id="24fd" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">如果您只需要保存模型的架构，而不需要保存其权重或训练配置，您可以使用以下函数只保存架构。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="c275" class="mg jn hh mc b fi mh mi l mj mk"># save as JSON</span><span id="16be" class="mg jn hh mc b fi ml mi l mj mk">json_string = model.to_json()</span><span id="e920" class="mg jn hh mc b fi ml mi l mj mk"># save as YAML<br/># yaml_string = model.to_yaml()</span><span id="f76e" class="mg jn hh mc b fi ml mi l mj mk">json_string</span><span id="b0d3" class="mg jn hh mc b fi ml mi l mj mk"># model reconstruction from JSON</span><span id="5aa7" class="mg jn hh mc b fi ml mi l mj mk">from tensorflow.keras.models import model_from_json<br/>model_architecture = model_from_json(json_string)</span><span id="1510" class="mg jn hh mc b fi ml mi l mj mk"># model reconstruction form YAML<br/># from tensorflow.keras.models import model_from_yaml<br/># model = model_from_yaml(yaml_string)</span><span id="cdf9" class="mg jn hh mc b fi ml mi l mj mk">model_architecture.summary()</span></pre><p id="2ebf" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi"> 4。model.save_weights() </strong></p><p id="f150" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">如果你只需要保存一个模型的权重，你可以使用下面的函数只保存权重。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="8495" class="mg jn hh mc b fi mh mi l mj mk"># Check first to see if file exists already.<br/># If not , the model is saved to disk.</span><span id="3fea" class="mg jn hh mc b fi ml mi l mj mk">import os.path<br/>if os.path.isfile('models/medical_trial_model.h5') is False:<br/>model.save('models/medical_trial_model.h5')</span><span id="7fe3" class="mg jn hh mc b fi ml mi l mj mk">model2 = Sequential([<br/>Dense(units=16, input_shape=(1,), activation='relu'),<br/>Dense(units=32, activation='relu'),<br/>Dense(units=2, activation='softmax')<br/>])</span><span id="148a" class="mg jn hh mc b fi ml mi l mj mk">model2.load_weights('models/my_model_weights.h5')</span><span id="8363" class="mg jn hh mc b fi ml mi l mj mk">model2.get_weights()</span></pre><h1 id="6c52" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">卷积神经网络的图像准备</h1><p id="b760" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi"> Kagle数据集导入</strong></p><ul class=""><li id="7436" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">kaggle -&gt;帐户部分-&gt;生成API令牌</li><li id="a316" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">在python的下一步中将会用到这个令牌。</li><li id="49c5" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">将kaggle.json文件粘贴到我的驱动器/kaggle_dataset中</li></ul><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="0af0" class="mg jn hh mc b fi mh mi l mj mk">from google.colab import drive<br/>drive.mount('/content/gdrive')</span><span id="7287" class="mg jn hh mc b fi ml mi l mj mk">import os<br/>os.environ['KAGGLE_CONFIG_DIR']='/content/gdrive/My Drive/kaggle_dataset'</span><span id="094a" class="mg jn hh mc b fi ml mi l mj mk">%cd /content/gdrive/My Drive/kaggle_dataset</span><span id="27d6" class="mg jn hh mc b fi ml mi l mj mk">!kaggle competitions download -c dogs-vs-cats</span><span id="08e1" class="mg jn hh mc b fi ml mi l mj mk">!mkdir train<br/>!mv train.zip train</span><span id="346d" class="mg jn hh mc b fi ml mi l mj mk">%cd train<br/>!unzip train.zip</span></pre><p id="9e53" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">整理数据</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="b077" class="mg jn hh mc b fi mh mi l mj mk">import numpy as np<br/>import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras.models import Sequential<br/>from tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.metrics import categorical_crossentropy<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from sklearn.metrics import confusion_matrix<br/>import itertools<br/>import os<br/>import shutil<br/>import random<br/>import glob<br/>import matplotlib.pyplot as plt<br/>import warnings<br/>warnings.simplefilter(action='ignore', category=FutureWarning)<br/>%matplotlib inline<br/></span><span id="9175" class="mg jn hh mc b fi ml mi l mj mk"># Organize data into train, valid, test dirs<br/>os.chdir('data/dogs-vs-cats')<br/>if os.path.isdir('train/dog') is False:<br/>    os.makedirs('train/dog')<br/>    os.makedirs('train/cat')<br/>    os.makedirs('valid/dog')<br/>    os.makedirs('valid/cat')<br/>    os.makedirs('test/dog')<br/>    os.makedirs('test/cat')</span><span id="6384" class="mg jn hh mc b fi ml mi l mj mk"><br/>os.chdir('/content/gdrive/MyDrive/kaggle_dataset/train/train/')<br/>for i in random.sample(glob.glob('cat*'), 500):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/train/cat')<br/>for i in random.sample(glob.glob('dog*'), 500):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/train/dog')<br/>for i in random.sample(glob.glob('cat*'), 100):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/valid/cat')<br/>for i in random.sample(glob.glob('dog*'), 100):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/valid/dog')<br/>for i in random.sample(glob.glob('cat*'), 50):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/test/cat')<br/>for i in random.sample(glob.glob('dog*'), 50):<br/>shutil.move(i, '/content/gdrive/MyDrive/kaggle_dataset/test/dog')<br/>os.chdir('../../')</span></pre><p id="6d16" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">处理数据</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="55cf" class="mg jn hh mc b fi mh mi l mj mk">physical_devices = tf.config.experimental.list_physical_devices('GPU')<br/>print("Num GPUs Available: ", len(physical_devices))<br/>tf.config.experimental.set_memory_growth(physical_devices[0], True)<br/></span><span id="b77f" class="mg jn hh mc b fi ml mi l mj mk">train_path = 'data/dogs-vs-cats/train'<br/>valid_path = 'data/dogs-vs-cats/valid'<br/>test_path = 'data/dogs-vs-cats/test'</span></pre><ul class=""><li id="ac3b" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">我们使用Keras的<code class="du mm mn mo mc b">ImageDataGenerator</code>类从<code class="du mm mn mo mc b">train</code>、<code class="du mm mn mo mc b">valid</code>和<code class="du mm mn mo mc b">test</code>目录中创建批量数据。</li><li id="5697" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">我们使用vgg16格式处理数据。我们将进一步讨论它。</li><li id="cc4f" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">目标尺寸(224，224)用于设置所有图像的尺寸</li></ul><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="12f1" class="mg jn hh mc b fi mh mi l mj mk">train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \<br/>    .flow_from_directory(directory=train_path, target_size=(224,224), classes=['cat', 'dog'], batch_size=10)<br/>valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \<br/>    .flow_from_directory(directory=valid_path, target_size=(224,224), classes=['cat', 'dog'], batch_size=10)<br/>test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \<br/>    .flow_from_directory(directory=test_path, target_size=(224,224), classes=['cat', 'dog'], batch_size=10, shuffle=False)</span></pre><p id="8659" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">将数据可视化</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="0edf" class="mg jn hh mc b fi mh mi l mj mk">assert train_batches.n == 1000<br/>assert valid_batches.n == 200<br/>assert test_batches.n == 100<br/>assert train_batches.num_classes == valid_batches.num_classes == test_batches.num_classes == 2</span><span id="fa3f" class="mg jn hh mc b fi ml mi l mj mk">imgs, labels = next(train_batches)</span></pre><p id="372c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">下面的函数将以1行10列的网格形式绘制图像</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="88c8" class="mg jn hh mc b fi mh mi l mj mk">def plotImages(images_arr):<br/>    fig, axes = plt.subplots(1, 10, figsize=(20,20))<br/>    axes = axes.flatten()<br/>    for img, ax in zip( images_arr, axes):<br/>        ax.imshow(img)<br/>        ax.axis('off')<br/>    plt.tight_layout()<br/>    plt.show()</span><span id="e27e" class="mg jn hh mc b fi ml mi l mj mk">plotImages(imgs)<br/>print(labels)</span></pre><p id="517f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">因此在输出中,[0，1]代表狗,[1，0]代表猫。</p><h1 id="16da" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">CNN的代码更新</h1><p id="f8c4" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><code class="du mm mn mo mc b">DirectoryIterator</code>，使用<code class="du mm mn mo mc b">ImageDataGenerator.flow_from_directory()</code>功能。请注意，<code class="du mm mn mo mc b">DirectoryIterator</code>实际上是一个无限重复的数据集，因为只要我们希望，迭代器生成的成批数据将会无限地继续出现。</p><p id="f62c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">对于这种类型的数据，需要向<code class="du mm mn mo mc b">fit()</code>函数传递一个参数。该参数称为<code class="du mm mn mo mc b">steps_per_epoch</code>，应设置为在宣布一个时期结束并开始下一个时期之前从训练集中产生的步骤数(样本批次)。</p><p id="84c2" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">例如:100幅训练图像，我们的批量是5，那么我们将设置<code class="du mm mn mo mc b">steps_per_epoch= 20</code>。</p><p id="b5e3" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">如果我们也向模型传递验证数据，我们还需要指定一个名为<code class="du mm mn mo mc b">validation_steps</code>的参数。这个参数的行为与<code class="du mm mn mo mc b">steps_per_epoch</code>完全相同，除了在我们的验证集上。</p><p id="f702" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">同样，对于predict函数，我们必须使用steps函数。</p><h1 id="d8c3" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">建立和训练一个CNN</h1><p id="dcbf" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi">搭建一个简单的CNN </strong></p><p id="76fd" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们将使用Keras <code class="du mm mn mo mc b">Sequential</code>型号</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="34db" class="mg jn hh mc b fi mh mi l mj mk">model = Sequential([<br/>    Conv2D(filters=32, kernel_size=(3, 3), activation='relu', padding = 'same', input_shape=(224,224,3)),<br/>    MaxPool2D(pool_size=(2, 2), strides=2),<br/>    Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),<br/>    MaxPool2D(pool_size=(2, 2), strides=2),<br/>    Flatten(),<br/>    Dense(units=2, activation='softmax')<br/>])</span></pre><ul class=""><li id="255e" class="lg lh hh kg b kh la kk lb kn li kr lj kv lk kz ll lm ln lo bi translated">过滤器设置任意任意值</li><li id="7e7b" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">最常用的内核大小(3，3)。</li><li id="1b29" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">padding = 'same '启用零填充</li><li id="4ec4" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">MAXPOOLING删除了参数并减少了计算量。</li></ul><p id="1d37" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">训练一个简单的CNN </strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="5800" class="mg jn hh mc b fi mh mi l mj mk">model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])</span><span id="724c" class="mg jn hh mc b fi ml mi l mj mk">model.fit(x=train_batches,<br/>    steps_per_epoch=len(train_batches),<br/>    validation_data=valid_batches,<br/>    validation_steps=len(valid_batches),<br/>    epochs=10,<br/>    verbose=2<br/>)</span></pre><p id="205e" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">在输出中，我们可以看到准确率为100%，而验证准确率仅为68%，这意味着存在过度拟合的情况。</p><h1 id="c8bb" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">CNN预测</h1><p id="69ee" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi">准备测试数据</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="3543" class="mg jn hh mc b fi mh mi l mj mk">test_imgs, test_labels = next(test_batches)<br/>plotImages(test_imgs)<br/>print(test_labels)</span></pre><p id="c138" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">根据测试数据进行预测</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="fb95" class="mg jn hh mc b fi mh mi l mj mk">predictions = model.predict(x=test_batches, steps=len(test_batches), verbose=0)</span><span id="5b77" class="mg jn hh mc b fi ml mi l mj mk">np.round(predictions)</span></pre><p id="ef3f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">混淆矩阵</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="c14e" class="mg jn hh mc b fi mh mi l mj mk">cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))</span><span id="5780" class="mg jn hh mc b fi ml mi l mj mk">This function prints and plots the confusion matrix.<br/>    Normalization can be applied by setting `normalize=True`.<br/>    """<br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)<br/><br/>    if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    else:<br/>        print('Confusion matrix, without normalization')<br/><br/>    print(cm)<br/><br/>    thresh = cm.max() / 2.<br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, cm[i, j],<br/>            horizontalalignment="center",<br/>            color="white" if cm[i, j] &gt; thresh else "black")<br/><br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span></pre><p id="378b" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">绘制混淆矩阵。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="7039" class="mg jn hh mc b fi mh mi l mj mk">cm_plot_labels = ['cat','dog']<br/>plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='Confusion Matrix')</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nd"><img src="../Images/bed2fe798664fcb0cdd5ad5b4ced5654.png" data-original-src="https://miro.medium.com/v2/resize:fit:656/format:webp/1*gqKLWps8ZM4CjODEsYHRlA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">混淆矩阵</figcaption></figure><h1 id="4935" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">建立一个微调的神经网络</h1><h2 id="0bd1" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">VGG16和ImageNet</h2><p id="db55" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">我们将用来对猫和狗的图像进行分类的预训练模型被称为VGG16，这是赢得2014年<a class="ae lf" href="http://www.image-net.org/" rel="noopener ugc nofollow" target="_blank"> ImageNet </a>竞赛的模型。ImageNet图书馆收藏了成千上万张属于不同类别的图片。我们只需要2个类，将被用作狗和猫。</p><h2 id="5375" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated"><strong class="ak"> VGG16 </strong></h2><p id="ff2a" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">它仅通过从每个点减去在训练集上计算的平均RGB值来进行预处理。</p><h2 id="3915" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">构建微调模型</h2><p id="df91" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">下载vgg16型号</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="5ca7" class="mg jn hh mc b fi mh mi l mj mk">vgg16_model = tf.keras.applications.vgg16.VGG16()<br/>vgg16_model.summary()<br/>type(vgg16_model)</span></pre><p id="da1f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">制作一个新的顺序模型，包括vgg16的所有层，不包括最后一个密集层(输出)。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="2a76" class="mg jn hh mc b fi mh mi l mj mk">model = Sequential()<br/>for layer in vgg16_model.layers[:-1]:<br/>    model.add(layer)<br/>model.summary()</span></pre><p id="a1c5" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">使所有层可训练=假。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="1fbe" class="mg jn hh mc b fi mh mi l mj mk">for layer in model.layers:<br/>    layer.trainable = False</span></pre><p id="a2d2" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">添加一个有两个节点的密集层。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a50d" class="mg jn hh mc b fi mh mi l mj mk">model.add(Dense(units=2, activation='softmax'))<br/>model.summary()</span></pre><p id="c7df" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">因此，我们最终得到了最后一个包含2个节点的密集层(输出)。这允许从134268738个参数中训练大约8194个参数。</p><h1 id="4ffa" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">训练一个微调的神经网络</h1><p id="1a56" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi"> vgg16 </strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="0805" class="mg jn hh mc b fi mh mi l mj mk">model.compile(optimizer=Adam(learning_rate=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])<br/></span><span id="fc50" class="mg jn hh mc b fi ml mi l mj mk">model.fit(x=train_batches,<br/>          steps_per_epoch=len(train_batches),<br/>          validation_data=valid_batches,<br/>          validation_steps=len(valid_batches),<br/>          epochs=5,<br/>          verbose=2<br/>)</span></pre><p id="0756" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">由于vgg16是预训练的模型，所以我们从第一个时期获得85%的准确度。再多训练一点就能达到99%的准确率。</p><h1 id="a3bc" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">用微调的神经网络进行预测</h1><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="f761" class="mg jn hh mc b fi mh mi l mj mk">test_imgs, test_labels = next(test_batches)<br/>plotImages(test_imgs)<br/>print(test_labels)</span><span id="8d36" class="mg jn hh mc b fi ml mi l mj mk">predictions = model.predict(x=test_batches, steps=len(test_batches), verbose=0)</span></pre><h2 id="6de9" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">用混淆矩阵绘制预测</h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="fe4f" class="mg jn hh mc b fi mh mi l mj mk">cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))<br/>cm_plot_labels = ['cat','dog']<br/>plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='Confusion Matrix')</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ne"><img src="../Images/52512bc75a7ee8c1171d4aa1b425595c.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*xJVChs8AXOwqsFzINa4Rwg.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">混淆矩阵</figcaption></figure><h1 id="44f0" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">MobileNet图像分类</h1><p id="9ea7" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">MobileNets是一类小型、低延迟、低功耗的模型，可用于分类、检测和卷积神经网络擅长的其他常见任务。由于它们的体积小，这些被认为是在移动设备上使用的伟大的深度学习模型。</p><p id="43ea" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">VGG16= 553 mb</p><p id="eaca" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">移动网络= 17 mb</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a467" class="mg jn hh mc b fi mh mi l mj mk">import numpy as np<br/>import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras.layers import Dense, Activation<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.metrics import categorical_crossentropy<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from tensorflow.keras.preprocessing import image<br/>from tensorflow.keras.models import Model<br/>from tensorflow.keras.applications import imagenet_utils<br/>from sklearn.metrics import confusion_matrix<br/>import itertools<br/>import os<br/>import shutil<br/>import random<br/>import matplotlib.pyplot as plt<br/>%matplotlib inline</span><span id="e5c2" class="mg jn hh mc b fi ml mi l mj mk">physical_devices = tf.config.experimental.list_physical_devices('GPU')<br/>print("Num GPUs Available: ", len(physical_devices))<br/>tf.config.experimental.set_memory_growth(physical_devices[0], True)</span></pre><p id="b1af" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">下载mobilenet</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="6437" class="mg jn hh mc b fi mh mi l mj mk">mobile = tf.keras.applications.mobilenet.MobileNet()</span></pre><p id="a1a4" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><code class="du mm mn mo mc b">prepare_image()</code>接受一个图像<code class="du mm mn mo mc b">file</code>，并处理图像以得到模型期望的格式。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="d6b2" class="mg jn hh mc b fi mh mi l mj mk">def prepare_image(file):<br/>    img_path = '/content/gdrive/MyDrive/MobileNetSample/'<br/>    img = image.load_img(img_path + file, target_size=(224, 224))<br/>    img_array = image.img_to_array(img)<br/>    img_array_expanded_dims = np.expand_dims(img_array, axis=0)<br/>    return tf.keras.applications.mobilenet.preprocess_input(img_array_expanded_dims)</span></pre><h2 id="6c0f" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">使用MobileNet预测</h2><h2 id="7e21" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">移动网络蜥蜴预测</h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="fb14" class="mg jn hh mc b fi mh mi l mj mk">from IPython.display import Image</span><span id="a17f" class="mg jn hh mc b fi ml mi l mj mk">Image(filename='/content/gdrive/MyDrive/MobileNetSample/1.jpg', width=300,height=200)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nf"><img src="../Images/83dc3ce6ef65b46700ea083269ec132c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5JkZrrbLyK3O6wbv0N3Vpg.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">蜥蜴</figcaption></figure><p id="9013" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">将图像文件发送到prepare_data()函数并获得预测。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="1df6" class="mg jn hh mc b fi mh mi l mj mk">preprocessed_image = prepare_image('1.jpg')<br/>predictions = mobile.predict(preprocessed_image)</span><span id="6acc" class="mg jn hh mc b fi ml mi l mj mk">results = imagenet_utils.decode_predictions(predictions)</span><span id="6109" class="mg jn hh mc b fi ml mi l mj mk">results</span></pre><h2 id="931a" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated"><strong class="ak"> MobileNet浓缩咖啡预测</strong></h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="e81f" class="mg jn hh mc b fi mh mi l mj mk">from IPython.display import Image</span><span id="7367" class="mg jn hh mc b fi ml mi l mj mk">Image(filename='/content/gdrive/MyDrive/MobileNetSample/2.jpg', width=300,height=200)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ng"><img src="../Images/ca9bbeaf44506c81170a4ef300a7027b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*qM-9tTWkDJ40iMjW6G3Lgg.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">浓咖啡</figcaption></figure><p id="411a" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">将图像文件发送到prepare_data()函数并获得预测。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="9cad" class="mg jn hh mc b fi mh mi l mj mk">preprocessed_image = prepare_image('2.jpg')<br/>predictions = mobile.predict(preprocessed_image)</span><span id="117e" class="mg jn hh mc b fi ml mi l mj mk">results = imagenet_utils.decode_predictions(predictions)</span><span id="a4fb" class="mg jn hh mc b fi ml mi l mj mk">results</span></pre><h2 id="62aa" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated"><strong class="ak"> MobileNet草莓预测</strong></h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="7694" class="mg jn hh mc b fi mh mi l mj mk">from IPython.display import Image</span><span id="9c29" class="mg jn hh mc b fi ml mi l mj mk">Image(filename='/content/gdrive/MyDrive/MobileNetSample/3.jpg', width=300,height=200)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nh"><img src="../Images/c4a6f82daf523cfeebc9d3fe2121f458.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*onNMx5XuDI7H90NJnw7-qA.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">草莓</figcaption></figure><p id="ab8e" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">将图像文件发送到prepare_data()函数并获得预测。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="6b07" class="mg jn hh mc b fi mh mi l mj mk">preprocessed_image = prepare_image('3.jpg')<br/>predictions = mobile.predict(preprocessed_image)</span><span id="8dc2" class="mg jn hh mc b fi ml mi l mj mk">results = imagenet_utils.decode_predictions(predictions)</span><span id="ed04" class="mg jn hh mc b fi ml mi l mj mk">results</span></pre><h1 id="e998" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">为微调的MobileNet处理图像</h1><p id="daff" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">我们现在正在研究一个从未在移动网络上训练过的手语数据集，不像猫和狗以前在vgg16上训练过。</p><p id="8f9d" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">下载数据集= <a class="ae lf" href="https://github.com/ardamavi/Sign-Language-Digits-Dataset" rel="noopener ugc nofollow" target="_blank">数据集</a>。</p><p id="70e7" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">将此数据保存在文件夹中，并通过移动方法将数据提取到测试、训练和有效数据集中。</p><p id="1ae1" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">组织数据</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="cbf8" class="mg jn hh mc b fi mh mi l mj mk"># Organize data into train, valid, test dirs<br/>os.chdir('/content/gdrive/MyDrive/kaggle_dataset/sign/Dataset')<br/>if os.path.isdir('train/0/') is False: <br/>    os.mkdir('train')<br/>    os.mkdir('valid')<br/>    os.mkdir('test')<br/><br/>    for i in range(0, 10):<br/>        shutil.move(f'{i}', 'train')<br/>        os.mkdir(f'valid/{i}')<br/>        os.mkdir(f'test/{i}')<br/><br/>        valid_samples = random.sample(os.listdir(f'train/{i}'), 30)<br/>        for j in valid_samples:<br/>            shutil.move(f'train/{i}/{j}', f'valid/{i}')<br/><br/>        test_samples = random.sample(os.listdir(f'train/{i}'), 5)<br/>        for k in test_samples:<br/>            shutil.move(f'train/{i}/{k}', f'test/{i}')<br/>os.chdir('../..')</span></pre><p id="f0f8" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">处理数据</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="1596" class="mg jn hh mc b fi mh mi l mj mk">train_path = '/content/gdrive/MyDrive/kaggle_dataset/sign/Dataset/train'<br/>valid_path = '/content/gdrive/MyDrive/kaggle_dataset/sign/Dataset/valid'<br/>test_path = '/content/gdrive/MyDrive/kaggle_dataset/sign/Dataset/test'</span><span id="3671" class="mg jn hh mc b fi ml mi l mj mk">train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.mobilenet.preprocess_input).flow_from_directory(directory=train_path, target_size=(224,224), batch_size=10)</span><span id="a255" class="mg jn hh mc b fi ml mi l mj mk">valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.mobilenet.preprocess_input).flow_from_directory(directory=valid_path, target_size=(224,224), batch_size=10)</span><span id="da4c" class="mg jn hh mc b fi ml mi l mj mk">test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.mobilenet.preprocess_input).flow_from_directory(directory=test_path, target_size=(224,224), batch_size=10, shuffle=False)</span></pre><h1 id="61d2" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">在自定义数据集上微调MobileNet</h1><p id="c493" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated"><strong class="kg hi">修改型号</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="5bba" class="mg jn hh mc b fi mh mi l mj mk">mobile = tf.keras.applications.mobilenet.MobileNet()<br/>mobile.summary()</span></pre><p id="7737" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">接下来，我们将从模型的第六层到最后一层获取输出，并将其存储在变量x中。这将是一个密集层，有10个输出节点，对应于10个相应的类。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="f89a" class="mg jn hh mc b fi mh mi l mj mk">x = mobile.layers[-6].output<br/>output = Dense(units=10, activation='softmax')(x)<br/>model = Model(inputs=mobile.input, outputs=output)</span></pre><p id="7b46" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我做了一点实验，发现训练最后23层会给我们一个相当不错的模型。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="d872" class="mg jn hh mc b fi mh mi l mj mk">for layer in model.layers[:-23]:<br/>layer.trainable = False<br/>model.summary()</span></pre><p id="a0b5" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">训练模型</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a51d" class="mg jn hh mc b fi mh mi l mj mk">model.compile(optimizer=Adam(lr=0.0001), loss='categorical_crossentropy', metrics=['accuracy'])</span><span id="d705" class="mg jn hh mc b fi ml mi l mj mk">model.fit(x=train_batches,<br/>steps_per_epoch=len(train_batches),<br/>validation_data=valid_batches,<br/>validation_steps=len(valid_batches),<br/>epochs=30,<br/>verbose=2<br/>)</span></pre><p id="88ca" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">预测</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="2977" class="mg jn hh mc b fi mh mi l mj mk">test_labels = test_batches.classes<br/>predictions = model.predict(x=test_batches, steps=len(test_batches), verbose=0)</span></pre><p id="05fe" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">混淆矩阵</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="36d0" class="mg jn hh mc b fi mh mi l mj mk">cm = confusion_matrix(y_true=test_labels, y_pred=predictions.argmax(axis=1))</span></pre><p id="63dd" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">情节混乱矩阵</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="ad87" class="mg jn hh mc b fi mh mi l mj mk">def plot_confusion_matrix(cm, classes,<br/>                          normalize=False,<br/>                          title='Confusion matrix',<br/>                          cmap=plt.cm.Blues):<br/>    """<br/>    This function prints and plots the confusion matrix.<br/>    Normalization can be applied by setting `normalize=True`.<br/>    """<br/>    plt.imshow(cm, interpolation='nearest', cmap=cmap)<br/>    plt.title(title)<br/>    plt.colorbar()<br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)<br/><br/>    if normalize:<br/>        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    else:<br/>        print('Confusion matrix, without normalization')<br/><br/>    print(cm)<br/><br/>    thresh = cm.max() / 2.<br/>    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):<br/>        plt.text(j, i, cm[i, j],<br/>            horizontalalignment="center",<br/>            color="white" if cm[i, j] &gt; thresh else "black")<br/><br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')</span></pre><p id="b23e" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们为混淆矩阵创建标签。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="eca6" class="mg jn hh mc b fi mh mi l mj mk">test_batches.class_indices</span></pre><p id="f8d2" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">创建标签后，我们绘制混淆矩阵。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="0bf7" class="mg jn hh mc b fi mh mi l mj mk">cm_plot_labels = ['0','1','2','3','4','5','6','7','8','9']<br/>plot_confusion_matrix(cm=cm, classes=cm_plot_labels, title='Confusion Matrix')</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ni"><img src="../Images/bfcb1401e4121d1537fcc960839a3e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:638/format:webp/1*aQeNtoifxv4A4n0uokRQ9A.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">混淆矩阵</figcaption></figure><h1 id="b8d9" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated"><strong class="ak">数据增强</strong></h1><p id="5f71" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">特别是对于图像数据，数据扩充可以包括水平或垂直翻转图像、旋转图像、放大或缩小、裁剪或改变颜色。</p><h2 id="3cd1" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">为什么我们需要数据增强？</h2><ul class=""><li id="c08c" class="lg lh hh kg b kh ki kk kl kn nj kr nk kv nl kz ll lm ln lo bi translated">也许我们有一个小的训练集，或者也许我们只是想让我们的训练集更大。</li><li id="3630" class="lg lh hh kg b kh lw kk lx kn ly kr lz kv ma kz ll lm ln lo bi translated">使用数据扩充的另一个原因是减少过度拟合。</li></ul><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="4f1a" class="mg jn hh mc b fi mh mi l mj mk">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import os<br/>import random<br/>import tensorflow as tf<br/>from tensorflow import keras<br/>from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>%matplotlib inline</span><span id="9bc9" class="mg jn hh mc b fi ml mi l mj mk">def plotImages(images_arr):<br/>    fig, axes = plt.subplots(1, 10, figsize=(20,20))<br/>    axes = axes.flatten()<br/>    for img, ax in zip( images_arr, axes):<br/>        ax.imshow(img)<br/>        ax.axis('off')<br/>    plt.tight_layout()<br/>    plt.show()</span></pre><p id="ba31" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">使用图像生成器进行翻转、旋转、移动、缩放等操作。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a12b" class="mg jn hh mc b fi mh mi l mj mk">gen = ImageDataGenerator(rotation_range=10, width_shift_range=0.1, height_shift_range=0.1, shear_range=0.15, zoom_range=0.1, <br/>    channel_shift_range=10., horizontal_flip=True)</span></pre><p id="eb87" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">从数据集中选择一个随机图像。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="e5c3" class="mg jn hh mc b fi mh mi l mj mk">chosen_image = random.choice(os.listdir('/content/gdrive/MyDrive/kaggle_dataset/train/dog'))<br/>image_path = '/content/gdrive/MyDrive/kaggle_dataset/train/dog/' + chosen_image</span></pre><p id="941f" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated"><strong class="kg hi">获取图像</strong></p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="fa91" class="mg jn hh mc b fi mh mi l mj mk">image = np.expand_dims(plt.imread(image_path),0)<br/>plt.imshow(image[0])</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nm"><img src="../Images/16db2fa316a822b4c3a8c5f375928209.png" data-original-src="https://miro.medium.com/v2/resize:fit:506/format:webp/1*emePxxY7TkXXvLp9TQAdQg.jpeg"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">原始资料</figcaption></figure><p id="3728" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们将从原始图像中生成批量的增强图像</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="ef83" class="mg jn hh mc b fi mh mi l mj mk">aug_iter = gen.flow(image)</span></pre><p id="8a77" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们会得到十个增强图像的样本。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="ab9f" class="mg jn hh mc b fi mh mi l mj mk">aug_images = [next(aug_iter)[0].astype(np.uint8) for i in range(10)]</span></pre><p id="f77c" class="pw-post-body-paragraph ke kf hh kg b kh la ii kj kk lb il km kn lc kp kq kr ld kt ku kv le kx ky kz ha bi translated">我们将绘制增强图像。</p><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="fde3" class="mg jn hh mc b fi mh mi l mj mk">plotImages(aug_images)</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nn"><img src="../Images/8a8a18ccc3aed9f86991014f482b4d17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LgRtrurycPRicpFmI2r9Sw.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">扩充数据</figcaption></figure><h2 id="035e" class="mg jn hh bd jo mp mq mr js ms mt mu jw kn mv mw jy kr mx my ka kv mz na kc nb bi translated">保存扩充数据</h2><pre class="ix iy iz ja fd mb mc md me aw mf bi"><span id="a183" class="mg jn hh mc b fi mh mi l mj mk">aug_iter = gen.flow(image, save_to_dir='/content/gdrive/MyDrive/kaggle_dataset/train/dog', save_prefix='aug-image-', save_format='jpeg')</span></pre></div></div>    
</body>
</html>