<html>
<head>
<title>Stamp Detection using Computer Vision and Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于计算机视觉和Python的邮票检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stamp-detection-using-computer-vision-and-python-6038a0243429?source=collection_archive---------2-----------------------#2021-05-21">https://medium.com/analytics-vidhya/stamp-detection-using-computer-vision-and-python-6038a0243429?source=collection_archive---------2-----------------------#2021-05-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e1dc" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">我们将使用OpenCV来识别一张图片中的邮票数量。</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/e9047716e7f4a5605306dd5db8dd578c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLr8vm1lJSaK5d9pWitkxQ.jpeg"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">在<a class="ae jn" href="https://unsplash.com/s/photos/computer-vision?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae jn" href="https://unsplash.com/@photophilic_spook?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Garvit Jagga </a>拍摄的照片</figcaption></figure><h1 id="337d" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">背景</h1><p id="fc74" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我的一个朋友问我是否可以写一个程序来检测一个图像中的<a class="ae jn" href="https://en.wikipedia.org/wiki/Rubber_stamp" rel="noopener ugc nofollow" target="_blank">橡皮图章</a>的数量。显然，这些发票收据将根据上面的邮票数量进行分类。最初，我想到了建立一个深度学习细分模型，但很快我意识到这是不值得努力的。</p><p id="daee" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">这些图像是在受控环境中生成的，因此很少有计算机视觉算法能做到这一点。为了说明用于检测邮票的计算机视觉算法，我将使用从谷歌下载的样本图像，因为原始图像是公司财产。目标是识别样本图像中的两个邮票。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lh"><img src="../Images/74fcb0d64af9b55b456ee8a4ea4943ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*HP2U7mn-6rELAG5_TPBZbg.gif"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">印记检测</figcaption></figure><h1 id="4b64" class="jo jp hi bd jq jr js jt ju jv jw jx jy io jz ip ka ir kb is kc iu kd iv ke kf bi translated">解决办法</h1><p id="1ed5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">高级解决方案步骤包括:</p><p id="f923" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">1.阅读图像。<br/> 2。模糊&amp;检测边缘。<br/> 3。找出所有轮廓，并删除较小的轮廓。<br/> 4。填充轮廓内的区域&amp;关闭斑点。<br/> 5。过滤邮票。</p><p id="5829" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">在开始之前，让我们导入必要的包。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><h2 id="35b5" class="lk jp hi bd jq ll lm ln ju lo lp lq jy kp lr ls ka kt lt lu kc kx lv lw ke lx bi translated">1.阅读图像</h2><p id="d24d" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">使用<a class="ae jn" href="https://docs.opencv.org/master/d4/da8/group__imgcodecs.html#ga288b8b3da0892bd651fce07b3bbd3a56" rel="noopener ugc nofollow" target="_blank"> <em class="ly"> imread </em> </a>功能读取彩色图像。为了显示图像，我们将使用Matplotlib。Matplotlib期望彩色图像通道的顺序为RGB，但是OpenCV将图像读取为BGR，因此我们将为转换编写一个帮助函数。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/a92669780cd9f8702e264890bb9feada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJyq_G_AkPoL8LrgfCqWLQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">输入图像</figcaption></figure><h2 id="ec4b" class="lk jp hi bd jq ll lm ln ju lo lp lq jy kp lr ls ka kt lt lu kc kx lv lw ke lx bi translated">2.模糊和检测边缘</h2><p id="e845" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">首先，我们需要使用<a class="ae jn" href="https://docs.opencv.org/3.4/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab" rel="noopener ugc nofollow" target="_blank"> cvtColor </a>函数将图像转换成灰度。然后，我们将使用<a class="ae jn" href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga9d7064d478c95d60003cf839430737ed" rel="noopener ugc nofollow" target="_blank">双边滤波器</a>来降低图像中的噪声。双边滤波器优于高斯滤波器，因为它能更好地保留边缘。最后，我们将使用<a class="ae jn" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html" rel="noopener ugc nofollow" target="_blank"> canny </a>边缘检测器对图像进行阈值分割和边缘检测。正常的canny边缘检测器需要两个难以调整的阈值参数，因此我们将使用来自<a class="ae jn" href="https://www.pyimagesearch.com/2015/04/06/zero-parameter-automatic-canny-edge-detection-with-python-and-opencv" rel="noopener ugc nofollow" target="_blank">零参数的一个，通过Python和OpenCV </a>实现自动Canny边缘检测</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/75ad4cbef2f26e136b7e487f0811026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-IxaLsf1EiF80TF-bcdBig.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">边缘图像</figcaption></figure><h2 id="c20b" class="lk jp hi bd jq ll lm ln ju lo lp lq jy kp lr ls ka kt lt lu kc kx lv lw ke lx bi translated">3.找出所有轮廓，并删除较小的轮廓</h2><p id="cd63" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated"><a class="ae jn" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" rel="noopener ugc nofollow" target="_blank"> findContours </a>功能可以找到图像中的所有轮廓。最外面的轮廓对我们的用例来说已经足够好了，所以我们将使用检索模式<strong class="ki hj">RETR _外部</strong>。<strong class="ki hj"> CHAIN_APPROX_NONE </strong>模式是首选模式，因为我们不想因近似而丢失轮廓上的任何点。要移除不需要的较小轮廓，我们可以按区域过滤轮廓。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><blockquote class="ma mb mc"><p id="cb95" class="kg kh ly ki b kj lc ij kl km ld im ko md le kr ks me lf kv kw mf lg kz la lb hb bi translated">找到的等高线总数:408</p></blockquote><h2 id="45e1" class="lk jp hi bd jq ll lm ln ju lo lp lq jy kp lr ls ka kt lt lu kc kx lv lw ke lx bi translated">4.填充轮廓内部的区域并关闭斑点</h2><p id="686a" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">我们将在黑色背景的图像上绘制顶部轮廓，并以此为基础，而不是在原始的二值图像上工作。当使用<a class="ae jn" href="https://docs.opencv.org/3.4/d6/d6e/group__imgproc__draw.html#ga746c0625f1781f1ffc9056259103edbc" rel="noopener ugc nofollow" target="_blank">绘制轮廓</a>功能填充轮廓内部区域时，轮廓中的任何断开点更容易识别。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/2bed848ad701627faea7fe5e9336e63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMg9dWFjtIzsVZKb0u6vUg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">填充轮廓</figcaption></figure><p id="99fe" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">正如所怀疑的，最上面的邮票有一条细细的黑线穿过。我们需要关闭这个斑点，这样顶部的图章被认为是一个轮廓，而不是两个不同的轮廓。<a class="ae jn" href="https://docs.opencv.org/master/d4/d86/group__imgproc__filter.html#ga67493776e3ad1a3df63883829375201f" rel="noopener ugc nofollow" target="_blank">形态闭合</a>操作非常适合实现这一点。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/5c91a811c3cc338f85f173714d59063d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fTAn0USy7HFv7MguMhL9Yg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">闭合斑点</figcaption></figure><h2 id="4c35" class="lk jp hi bd jq ll lm ln ju lo lp lq jy kp lr ls ka kt lt lu kc kx lv lw ke lx bi translated">5.过滤邮票</h2><p id="63f5" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">为了分离印章轮廓，我们可以从最新的二进制图像中识别所有轮廓，并过滤超过5个点的轮廓(使用<a class="ae jn" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga0012a5fdaea70b8a9970165d98722b4c" rel="noopener ugc nofollow" target="_blank"> approxPolyDP </a>),因为印章是椭圆。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/d3c85fbee933fc99a5d011673254f583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IzRVjsq6sqC2XlEiM0QmpA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">邮票识别图像</figcaption></figure></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="db00" class="jo jp hi bd jq jr mn jt ju jv mo jx jy io mp ip ka ir mq is kc iu mr iv ke kf bi translated">奖励—突出显示已识别的图章</h1><p id="01ed" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">对于这个程序的演示来说，如果我们可以只突出显示图像的图章区域，那不是很酷吗？既然我们都认为这确实很酷，那就让我们看看如何实现这一点。</p><p id="ea67" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">涉及的步骤有:</p><p id="556b" class="pw-post-body-paragraph kg kh hi ki b kj lc ij kl km ld im ko kp le kr ks kt lf kv kw kx lg kz la lb hb bi translated">1.复制原始图像并模糊整个图像。<br/> 2。遍历模糊图像中的所有点，对于图章轮廓上或内部的点(使用<a class="ae jn" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga1a539e8db2135af2566103705d7a5722" rel="noopener ugc nofollow" target="_blank"> pointPolygonTest </a>进行检查)，我们用输出图像的像素值替换它。我们使用输出图像中的像素值，因为我们需要在邮票上绘制蓝线。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="li lj l"/></div></figure><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/3c24ebbcfaa9ab6811200baa6de15215.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l3aykODX7sR8RpvVRvQSgA.png"/></div></div></figure></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="d034" class="jo jp hi bd jq jr mn jt ju jv mo jx jy io mp ip ka ir mq is kc iu mr iv ke kf bi translated">结论</h1><p id="f995" class="pw-post-body-paragraph kg kh hi ki b kj kk ij kl km kn im ko kp kq kr ks kt ku kv kw kx ky kz la lb hb bi translated">是的，这就是这篇文章的内容。您可以从<a class="ae jn" href="https://github.com/6aravind/tidbits/blob/main/cv/Stamp%20detection%20using%20computer%20vision%20and%20python.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>访问该笔记本。</p></div></div>    
</body>
</html>