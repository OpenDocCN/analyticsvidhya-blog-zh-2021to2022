<html>
<head>
<title>Interactive Visualisation of Bitcoin Transactions made easy with Python and Pyvis</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Pyvis简化比特币交易的交互式可视化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/interactive-visualisation-of-bitcoin-transactions-made-easy-with-python-and-pyvis-109dea06b86e?source=collection_archive---------12-----------------------#2021-03-14">https://medium.com/analytics-vidhya/interactive-visualisation-of-bitcoin-transactions-made-easy-with-python-and-pyvis-109dea06b86e?source=collection_archive---------12-----------------------#2021-03-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div class="er es hg"><img src="../Images/222a34394df9a3e3a7ace1120c1f3b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*eMcrAH2mkxS0BauOtSFAnA.png"/></div></figure><div class=""/><p id="2654" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">需要更好地理解区块链交易结构？使用<a class="ae jk" href="https://pyvis.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> Pyvis </a>库很容易实现交互式图形可视化。</p><p id="adbd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文要求对比特币交易，Python编程有基本的了解(我用的是Jupyter笔记本)。此外，你应该了解网络图中的“节点”和“边”是什么。</p><p id="11cd" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">本文提供了一个使用<a class="ae jk" rel="noopener" href="/elliptic/the-elliptic-data-set-opening-up-machine-learning-on-the-blockchain-e0a343d99a14">椭圆数据集</a>进行比特币交易的简单示例，该数据集可从<a class="ae jk" href="https://www.kaggle.com/ellipticco/elliptic-data-set/activity" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>获得。由此你将能够进一步精炼和扩展你的观想。</p><p id="232e" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们加载数据集</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="7e9a" class="ju jv hp jq b fi jw jx l jy jz"><strong class="jq hq">import</strong> pandas <strong class="jq hq">as</strong> pd<br/><strong class="jq hq">import</strong> numpy <strong class="jq hq">as</strong> np<br/><strong class="jq hq">edges</strong> = <strong class="jq hq">pd.read_csv</strong>('elliptic_txs_edgelist.csv')<br/><strong class="jq hq">features</strong> = <strong class="jq hq">pd.read_csv</strong>('elliptic_txs_features.csv', <strong class="jq hq">header=None</strong>)</span></pre><p id="b8ff" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">edges表实际上包含了我们需要的一切，即事务节点(作为id)和边(由行表示):</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es ka"><img src="../Images/660fe2d8883267f4fa7d97ea32e087aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aRUgnTDjsOpIouHzTxCBIg.png"/></div></div></figure><p id="02e6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">但是，我们需要“features”表的简单目的是识别集合中事务的开始:Elliptic以49个不同的时间步长(由列“1”表示)表示数据，每个时间步长大约为。交易发生的3小时内:</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div class="ab fe cl kf"><img src="../Images/62ab98344eb596ffb0606763aef985bd.png" data-original-src="https://miro.medium.com/v2/format:webp/1*6TBRIVmlwbeznS-YP7kBSg.png"/></div></figure><p id="d74c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们选取一个节点子集(15)并构建前4个事务层，如下所示:</p><ul class=""><li id="67cc" class="kg kh hp io b ip iq it iu ix ki jb kj jf kk jj kl km kn ko bi translated">从属于时间步长的“特征”中获取第一小组节点</li><li id="7cb9" class="kg kh hp io b ip kp it kq ix kr jb ks jf kt jj kl km kn ko bi translated">使用Pyhton函数<code class="du ku kv kw jq b">isin()</code>，将它们的Id(列“0”)作为第一个节点，并将它们作为表“edges”中的“txId1”，获得相应的边。</li></ul><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="3883" class="ju jv hp jq b fi jw jx l jy jz">features.sort_values(by=[‘1’])<br/>nodes_1 = features[0:15][‘0’].to_numpy()<br/>edges_1 = edges[edges['txId1'].isin(nodes_1)]</span></pre><p id="e1c4" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我们需要使用函数<code class="du ku kv kw jq b">to_numpy()</code>稍微调整一下数据，然后我们可以将条目作为节点添加到Pyvis图中。现在，</p><ul class=""><li id="8836" class="kg kh hp io b ip iq it iu ix ki jb kj jf kk jj kl km kn ko bi translated">将“txId2”(即所收集的边的输出节点)视为输入节点(即现在是“txId1”)，我们提取相应的边，等等:</li></ul><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="0b18" class="ju jv hp jq b fi jw jx l jy jz">nodes_2 = edges_1[‘txId2’].to_numpy()<br/>edges_2 = edges[edges[‘txId1’].isin(edges_1[‘txId2’])]<br/>nodes_3 = edges_2[‘txId2’].to_numpy()<br/>edges_3 = edges[edges[‘txId1’].isin(edges_2[‘txId2’])]<br/>nodes_4 = edges_3[‘txId2’].to_numpy()<br/>edges_4 = edges[edges[‘txId1’].isin(edges_3[‘txId2’])]</span></pre><p id="10d0" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">为了构建我们的Pyvis图，我们需要使用函数<code class="du ku kv kw jq b">to_list()</code>将我们的列表(Numpy格式的currenyl)转换成简单的Python列表。除此之外，Pyvis图需要元组列表，我们通过函数<code class="du ku kv kw jq b">to_records()</code>提供了这些列表。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="23bb" class="ju jv hp jq b fi jw jx l jy jz">nodes_1 = nodes_1.tolist()<br/>nodes_2 = nodes_2.tolist()<br/>nodes_3 = nodes_3.tolist()<br/>nodes_4 = nodes_4.tolist()<br/>edges_1 = edges_1.to_records(index=False).tolist()<br/>edges_2 = edges_2.to_records(index=False).tolist()<br/>edges_3 = edges_3.to_records(index=False).tolist()<br/>edges_4 = edges_4.to_records(index=False).tolist()</span></pre><p id="674c" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">现在，我们准备生成图表:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="d3fe" class="ju jv hp jq b fi jw jx l jy jz">from pyvis import network as net<br/>from IPython.core.display import display, HTML</span><span id="6f50" class="ju jv hp jq b fi kx jx l jy jz">g=net.Network(directed=True, bgcolor=’#222222', font_color=’white’)<br/><em class="ky"># use 'directed=True' for arrows showing the direction of the edges</em></span><span id="0894" class="ju jv hp jq b fi kx jx l jy jz">g.add_nodes(nodes_1)<br/>g.add_nodes(nodes_2)<br/>g.add_nodes(nodes_3)<br/>g.add_nodes(nodes_4)</span><span id="a9b5" class="ju jv hp jq b fi kx jx l jy jz">g.add_edges(edges_1)<br/>g.add_edges(edges_2)<br/>g.add_edges(edges_3)</span></pre><p id="b6a6" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">将图表保存为单独的HTML文件:</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es kz"><img src="../Images/61ddef1eacae7e8069616153d34ce07b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5Tn8tbsF4A-DoRVes46k4w.gif"/></div></div></figure><p id="ff54" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">成功！我们有了第一个可以玩的互动网络。然而，安排节点组仍然有点棘手。Pyvis中有专门的选项按钮，我们可以在HTML文件中显示，如下所示:</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="a539" class="ju jv hp jq b fi jw jx l jy jz"># under the line 'g=net.Network(...' add<br/>g.show_buttons(filter_= ['physics'])</span></pre><p id="0dcc" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">再次生成HTML文件，并从Jupyter文件管理器中打开它。</p><figure class="jl jm jn jo fd hk er es paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="er es la"><img src="../Images/94cf0d6043c16bb4f8a30f4979a22f9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*P6Yr494oV_lH8OGynRM_LQ.gif"/></div></div></figure><p id="28c1" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是开始理解事务的更好的基础。放大和缩小以查看细节。此外，您可以添加更多的选项按钮，例如节点大小、颜色等。</p><h1 id="3909" class="lb jv hp bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">结论</h1><p id="933e" class="pw-post-body-paragraph im in hp io b ip ly ir is it lz iv iw ix ma iz ja jb mb jd je jf mc jh ji jj hb bi translated">从椭圆比特币交易数据集中，我们提取了一个交易子集，并生成了一个包含数据的交互式图表。</p><p id="de47" class="pw-post-body-paragraph im in hp io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">从这里很容易将我们制作的基本图形增强为更复杂的可视化。有fu <a class="ae jk" href="https://datasmithes.com/2021/04/09/interactive-visualisation-of-bitcoin-transactions-made-easy-with-python-and-pyvis/" rel="noopener ugc nofollow" target="_blank"> n </a>。</p></div></div>    
</body>
</html>