<html>
<head>
<title>How I am learning machine learning — week 4: python and numpy (part two)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我是如何学习机器学习的——第四周:python和numpy(第二部分)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-i-am-learning-machine-learning-week-4-python-and-numpy-part-two-afe036916260?source=collection_archive---------20-----------------------#2021-03-09">https://medium.com/analytics-vidhya/how-i-am-learning-machine-learning-week-4-python-and-numpy-part-two-afe036916260?source=collection_archive---------20-----------------------#2021-03-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cf5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本周我们将看到在我们的机器学习项目中使用numpy可能需要的所有函数的最后一部分。让我们开始吧！</p><h1 id="e8a7" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">查看操作性能</h1><p id="910b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在python中，使用numpy以及其他语言，我们将有很多方法来做同样的事情；在python中，我们有<em class="kf"> sum </em>函数，在numpy中，我们还必须有<em class="kf"> np.sum </em>函数。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/a58cacecaec930e1ae09bda8d79d7b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:598/format:webp/0*4xd1_MtGwS5tkEsf.png"/></div></figure><p id="0fce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，两者返回相同的结果，留下一个问题:</p><blockquote class="ko kp kq"><p id="5497" class="ie if kf ig b ih ii ij ik il im in io kr iq ir is ks iu iv iw kt iy iz ja jb ha bi translated"><em class="hh">什么时候一个功能比另一个好？</em></p></blockquote><p id="d52f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Num是对python列表求和的官方python函数，而np.sum函数是对<em class="kf"> numpy数组</em>求和的官方函数，它们在概念上是一样的，但不是在机器必须执行计算的时候。最好的方法是对python数据类型(在这里是列表)使用python函数，对numpy数据类型(numpy数组和类型)使用numpy函数。<br/>但除了这两个功能的<strong class="ig hi">性能</strong>之外，还有一个更重要的区别。通过一些特殊的numpy函数(以开头的%为特征)，我们可以显示机器执行操作所用的<em class="kf">时间</em>，在这种情况下，我们将使用<em class="kf"> %timeit </em>。<br/>我们首先创建一个大数组:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ku"><img src="../Images/b700d6e78fafa59dd651ed5db14f0690.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/0*OCFSSHx3us6uYds5.png"/></div></figure><p id="c8a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后使用timeit功能:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kv"><img src="../Images/a7520d2085a593a1882aae5f56f9e7df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1376/format:webp/0*LEZMngEF3AOrwZr7.png"/></div></figure><p id="abec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用google converter，我们可以看到python sum耗时2.28毫秒，而numpy sum耗时13微秒，比<em class="kf">快了500多倍</em>。</p><h1 id="8d54" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">重塑和移调</h1><p id="90d9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">正如我们已经说过的，在我们的机器学习载体中要确定的最重要的事情之一是数据<em class="kf">适合</em>其他数据，让我们看一个例子。<br/>让我们从创建两个不同形状的不同数组开始:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kw"><img src="../Images/35f47fce00817003c570670a97b88128.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*OWPyyZQa2pan1BIo.png"/></div></figure><p id="b6a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们试着把它们相乘:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/2f7de19ecc61cce982e08126211025e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NUqGThVcME9Z7zW4.png"/></div></div></figure><p id="92c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">错误说两个形状不同的数组不能<a class="ae lc" href="https://dev.to/gabrieleboccarusso/how-i-am-learning-machine-learning-week-3-python-and-numpy-part-one-27b4#manipulating-arrays" rel="noopener ugc nofollow" target="_blank">一起</a>播。如果我们继续看数字文档，我们可以看到广播的一般规则是:</p><p id="9339" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kf">当操作两个数组时，NumPy按元素比较它们的形状。它从尾部(即最右边的)维度开始，然后向左移动。两个尺寸在下列情况下兼容:</em></p><ul class=""><li id="de9a" class="ld le hh ig b ih ii il im ip lf it lg ix lh jb li lj lk ll bi translated">他们是平等的，或者</li><li id="daac" class="ld le hh ig b ih lm il ln ip lo it lp ix lq jb li lj lk ll bi translated">其中一个是1</li></ul><p id="2121" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着我们必须<strong class="ig hi">重塑</strong>我们的数组，我们可以用numpy <em class="kf">重塑</em>函数来完成:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lr"><img src="../Images/44541e207698d80dc03d62e0a9c47752.png" data-original-src="https://miro.medium.com/v2/resize:fit:878/format:webp/0*aquonoKTM5-CU4fa.png"/></div></figure><p id="ec35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然第一个数组对应于广播的主要规则，我们可以将两个数组相乘:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ls"><img src="../Images/d49d081deef454e78280ddc516aaaff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/0*40JUP0O_csmBLZUI.png"/></div></figure><p id="3a9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，整形函数遵循<a class="ae lc" href="https://numpy.org/doc/1.18/reference/generated/numpy.reshape.html" rel="noopener ugc nofollow" target="_blank">精确</a>规则，这只是一个例子，数组不能总是被整形成不同的形状。</p><p id="6083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经看到了整形函数，让我们看看<em class="kf">转置</em>函数。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lt"><img src="../Images/8d81cb96e18a3df84d248428e9d10049.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/0*N_bm1rvuSc-Jgt51.png"/></div></figure><p id="5047" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以调用transpose函数，我们称之为“T ”,简单地在它们之间交换一个数组的轴。</p><p id="2287" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kf">整形</em>和<em class="kf">转置</em>都是非常有用的函数，当我们必须做<em class="kf">两个或者更多矩阵的乘法</em>时，它们会非常方便</p><h1 id="b323" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">矩阵乘法</h1><p id="611b" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">将一个矩阵乘以一个数字或者一个一维数组是相当容易的，但是将一个矩阵乘以另一个矩阵可能有点难以理解，但是非常重要。<br/>数组互乘有两种方式:</p><h1 id="db76" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">元素方面</h1><p id="3528" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">逐元素乘法非常简单，只能在相同大小的数组之间进行:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lu"><img src="../Images/ced9b64fda97c2488ed64af6e6625ab5.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/0*-I57VXp0_Je1_VHW.png"/></div></figure><p id="84be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用numpy函数来实现:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lv"><img src="../Images/5779c097da3192d06a1bc2df628d8055.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/0*62Ar56_CWpZ1JGem.png"/></div></figure><h1 id="0abf" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">点积</h1><p id="1717" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">注意:在下面的例子中，矩阵中有一个错误:它有5而不是4，反之亦然。<br/>另一个是专门针对矩阵的，如果你第一次尝试不明白，不要担心，如果你<em class="kf">明白</em>发生了什么事情，就很简单了。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lw"><img src="../Images/c89d25092475ca864a8b867d186f0796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AysV1Ovy_pIGtqQ_.png"/></div></div></figure><p id="7492" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但这一点，乍一看，仍然令人困惑。让我们用一些颜色来看看:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lw"><img src="../Images/bf6d9af94a2bd5c393e172a7249d8162.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3kdzKXvFkv_rV8C3.png"/></div></div></figure><p id="803a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，我们采用了第一个数组，其中的矩阵包含“1”、“2”和“3”，并将其乘以“A”、“B”和“C”。这通常被称为<em class="kf">瀑布法</em>。你可以理解为什么在这里看动画<a class="ae lc" href="http://matrixmultiplication.xyz/" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="7ec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般来说，要将两个矩阵相乘，它们的T21需要对齐。让我们看看，如果我们使用<em class="kf">点</em>函数，尝试对元素相乘的矩阵使用点积，会发生什么:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es lx"><img src="../Images/add1158ccd796fb06f7eeb0d8574f8c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/0*OijZDo20N6g5bqZF.png"/></div></figure><p id="a9eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所见，它们没有对齐。当第一个矩阵的行o与另一个矩阵的列相同时，两个矩阵对齐，或:<code class="du ly lz ma mb b">m x n * n x p</code>。这样我们知道结果将是一个m×p的矩阵:</p><pre class="kh ki kj kk fd mc mb md me aw mf bi"><span id="e7f3" class="mg jd hh mb b fi mh mi l mj mk">m x n * n x p = m x p<br/>that in our case could be:<br/>3 x 2 * 2 * 3 = 3 * 3</span></pre><p id="bd39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着两个矩阵可以相乘。在我们的例子中，我们必须<strong class="ig hi">转置轴</strong>:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es ml"><img src="../Images/8cad3522a4833d3c45e79869b92ec2a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*XrPR7GlD87F3xpyX.png"/></div></figure><p id="3282" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，我们得到了一个2 x 2矩阵，正如我们已经看到的:</p><pre class="kh ki kj kk fd mc mb md me aw mf bi"><span id="270b" class="mg jd hh mb b fi mh mi l mj mk">2 x 3 * 3 x 2 = 2 x 2</span></pre><p id="7cb2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所料。如果我们转置第一个矩阵，结果将是一个3 x 3的矩阵。<br/>从<em class="kf">数学</em>的角度来看点积，你可以在这里阅读<a class="ae lc" href="https://www.mathsisfun.com/algebra/matrix-multiplying.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="f08e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">比较运算符</h1><p id="5af9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">在数组和矩阵之间，我们甚至可以做比较。结果将是另一个<em class="kf">布尔</em>数组。让我们看一个例子:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mm"><img src="../Images/998b0b0bf99160f447fca3db76ba5b8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*-n0D1aFNjcuQMp2W.png"/></div></figure><p id="0366" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用我们在编程载体中使用的所有逻辑运算符，但重要的是要知道比较遵循相同的传播规则:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mn"><img src="../Images/808dabd86e777b602263924541a77141.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/0*rmdoeJS4U2CAUkam.png"/></div></figure><h1 id="d1a2" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">排序数组</h1><p id="24bc" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">Numpy提供了各种查找元素和排序数组的函数。最常见的方法是<em class="kf">排序</em>，当应用于一个矩阵的每一个<em class="kf">行</em>时进行排序。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mo"><img src="../Images/059483ddb26f5972a53a2d0ad2f6c975.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*dMMwcR-SsLFtjL-y.png"/></div></figure><h1 id="4312" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">寻找数组的最小值</h1><p id="d9ce" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">为了找到数组的最小值，numpy提供了<em class="kf"> argmin </em>函数，该函数返回最小值的<em class="kf">索引</em>:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mp"><img src="../Images/d0f41cad5d484111484bdb261ab6a36c.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/0*7YGo_9JfTfDeqrLm.png"/></div></figure><h1 id="c2f9" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">寻找数组的最大值</h1><p id="e7d1" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">如果要找到最小值，我们使用argmin，要找到最大值，我们找到argmax:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es mq"><img src="../Images/9bf58df4beab551c5f5aa3fcee9f5670.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/0*qsG5nm_us1_rESvT.png"/></div></div></figure><h1 id="122f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">关于argmin和argmax的更多信息</h1><p id="0c5d" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">这两个函数都让我们输入数组的<em class="kf">轴</em>，这样我们就可以找到所有列或行的最大值或最小值，而不是所有数组的最大值或最小值:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mr"><img src="../Images/79a1ea4d7c9a6eba42c14f5a5c48fa28.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/0*rZERTIx5-DLIWdCT.png"/></div></figure><p id="a4cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当轴设置为0时，如果在所有行中设置为1，它将找到所有列中的最大值。</p><h1 id="65f6" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">最后的想法</h1><p id="ce41" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">上周我们看到了numpy库来操作数组和矩阵，我们将在机器学习中用到这些数据集。下周，我们将看到matplotlib将我们的数据可视化，然后专注于更实际的东西。如果您有任何疑问，请随时留下您的评论。</p></div><div class="ab cl ms mt go mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ha hb hc hd he"><p id="4469" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最初出现在<a class="ae lc" href="https://dev.to/gabrieleboccarusso/how-i-am-learning-machine-learning-week-4-python-and-numpy-part-two-4co4" rel="noopener ugc nofollow" target="_blank">发展到</a></p></div></div>    
</body>
</html>