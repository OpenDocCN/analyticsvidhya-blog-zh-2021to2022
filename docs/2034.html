<html>
<head>
<title>Forecasting Using Facebook’s Prophet Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用脸书先知库进行预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/forecasting-using-facebooks-prophet-library-ce628e76586b?source=collection_archive---------1-----------------------#2021-04-02">https://medium.com/analytics-vidhya/forecasting-using-facebooks-prophet-library-ce628e76586b?source=collection_archive---------1-----------------------#2021-04-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/7605b96123609ba4f8a5ba1042587a06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DgTzNBlef58K-qwTmr7Oxg.png"/></div></div></figure><div class=""/><h1 id="b46b" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">什么是先知？</h1><p id="d473" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">2017年，脸书开源了Prophet——一个配备了Python和R语言版本的易用工具的预测库。虽然它被认为是ARIMA模型的替代品，但当应用于具有强烈季节性影响的时间序列数据和几个季节的历史数据时，Prophet确实大放异彩。</p><p id="8aab" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">默认情况下，Prophet是一个加法回归模型。它还专门用于预测业务数据。根据Taylor和Letham的说法，Prophet模型有四个主要组成部分:</p><ol class=""><li id="e1a4" class="kr ks ht jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">分段线性或逻辑增长曲线趋势。Prophet通过从数据中选择变化点来自动检测趋势的变化。</li><li id="7bac" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">使用傅立叶级数模拟的年度季节性分量。</li><li id="bce0" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">使用虚拟变量的每周季节性成分。</li><li id="52fe" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">用户提供的重要节假日列表。</li></ol><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es lf"><img src="../Images/445c2e1dffbad867442f2a3970a1eff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*jUuGHJBls00dySdHD5ATCw.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">预言家的预测过程</figcaption></figure><p id="17dc" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">使用Prophet预测的过程是这样的:数据分析师将获得一个时间序列数据集，并将其设置为与Prophet库兼容。然后，分析师将开始建模，并手动输入他们认为最能产生最佳预测结果的参数。如果存在需要人工干预的问题，Prophet将标记这些问题并让分析师知道，以便他们可以重新检查预测并根据反馈重新调整模型。</p><h1 id="3c7b" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">预言家职业</h1><p id="8a34" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">“脸书预言家”值得了解和深入研究，它不仅易于实施，而且还针对具有以下任何特征的时间序列数据集进行了优化:</p><ol class=""><li id="f643" class="kr ks ht jq b jr km jv kn jz kt kd ku kh kv kl kw kx ky kz bi translated">异常值和/或缺失值</li><li id="e0b7" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">强烈的多重“人类尺度”季节性</li><li id="da7b" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">已知的重要节日</li><li id="3cbe" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">历史趋势变化</li><li id="13e4" class="kr ks ht jq b jr la jv lb jz lc kd ld kh le kl kw kx ky kz bi translated">至少有几个月(最好是一年)历史的每小时、每天或每周观察</li></ol><h1 id="e776" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn bi translated">在Google Colab上与Prophet合作</h1><p id="0661" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">在本节中，我们将使用Google Colab作为我们的环境。如果你以前从未使用过Google Colab，但想继续学习，请查看我制作的快速简单的Google Colab漫游,让你体验一下Google Colab！</p><h2 id="e111" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">安装我们的驱动器</h2><p id="a31d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，让我们在Google Colab的新笔记本中运行下面的单元格，以安装我们的Google Drive:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="dcf9" class="lp ir ht me b fi mi mj l mk ml">from google.colab import drive</span><span id="c58b" class="lp ir ht me b fi mm mj l mk ml">drive.mount(‘/content/drive’, force_remount=True)</span></pre><p id="bf70" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Google Colab已经安装了fbprophet，所以我们不需要担心pip安装任何东西。相反，我们可以立即将Prophet模型和其他基本库导入到下一个单元中:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="fa67" class="lp ir ht me b fi mi mj l mk ml">from fbprophet import Prophet<br/>import pandas as pd</span></pre><p id="21f9" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">现在我们已经设置好了，我们可以加载时间序列数据集了！如果你想使用与本博客相同的数据集，请在此下载时间序列数据集<a class="ae lo" href="https://github.com/Lewis34cs/fb_prophet_blog_notebook/blob/main/air_passenger.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="80a6" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">读取CSV文件</h2><p id="4f9a" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">首先，我们将设置一个变量来引用新数据帧的位置。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="3332" class="lp ir ht me b fi mi mj l mk ml">df = pd.read_csv(‘../datasets/air_passenger.csv’)</span></pre><p id="9337" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">接下来，我们通过查看前5行来检查数据帧。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="bee7" class="lp ir ht me b fi mi mj l mk ml">df.head()</span></pre><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mn"><img src="../Images/06978dfbffaaa7fe16cec544faaa3425.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*DfjNNZnWfvGKKM0nlRQxag.jpeg"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">查看前5行</figcaption></figure><h2 id="c8b2" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">设置列名</h2><p id="36a9" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">Prophet的一个奇怪之处是数据集的列必须被专门称为“ds”和“y”。为了使我们的数据框架与Prophet兼容，我们必须通过调用以下命令来更改我们的列名:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="7c0c" class="lp ir ht me b fi mi mj l mk ml">df.columns = [‘ds’, ‘y’]</span></pre><p id="ddb4" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">Prophet的另一个要求是，我们需要确保我们的“ds”列包含DateTime对象。我们可以通过调用以下命令来确保它包含DateTime对象:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="1d8e" class="lp ir ht me b fi mi mj l mk ml">df[‘ds’] = pd.to_datetime(df[‘ds’])</span></pre><h2 id="6051" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">创建训练集和测试集</h2><p id="2067" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在，我们已经成功地更改了列名，并将“ds”列转换为包含DateTime对象，我们现在可以创建我们的训练集和测试集了！对于这个博客，我们将让Prophet模型预测12个月后的训练集，然后将这些预测与我们的测试集进行比较。因此，让我们定义我们的训练和测试集:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="3da6" class="lp ir ht me b fi mi mj l mk ml"># defining the number of observations we want to predict<br/>nobs = 12</span><span id="701f" class="lp ir ht me b fi mm mj l mk ml">train = df[:-nobs]<br/>test = df[-nobs:]</span></pre><p id="454b" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">如果我们查看训练集和测试集的长度，我们应该看到测试集包含12个观察值，而训练集包含除这12个观察值之外的所有内容。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="632c" class="lp ir ht me b fi mi mj l mk ml">print(f"Length of dataframe: {len(df)}\n"<br/>      f"Length of train set: {len(train)}\n"<br/>      f"Length of test set: {len(test)}")</span></pre><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mo"><img src="../Images/1a204803589cf5d3094bdb46fbf41d19.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*_yWbDMblsKGyIbWDt1-jOQ.jpeg"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">查看每组的长度</figcaption></figure><h2 id="38c8" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">定义我们的先知模型</h2><p id="3d46" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">一旦我们确认了训练集和测试集的长度是正确的，我们就可以创建一个Prophet模型的实例，然后使模型适合训练集。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="576b" class="lp ir ht me b fi mi mj l mk ml"># Creating an instance of the Prophet model<br/>prophet = Prophet()</span><span id="f598" class="lp ir ht me b fi mm mj l mk ml"># fitting Prophet model to the train set<br/>prophet.fit(train)</span></pre><p id="39d7" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">下一步，我们必须创建一个存储Prophet模型预测的地方。幸运的是，fbprophet提供了一个非常有用的方法来创建一个新的数据框架来存储我们模型的预测。我们将创建一个名为“future”的变量，该变量将保存对一个新数据帧的引用，该数据帧包含训练集中所有值的日期以及我们希望从训练集中预测的观察值的数量:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="2cec" class="lp ir ht me b fi mi mj l mk ml">future = prophet.make_future_dataframe(periods=nobs, freq=’MS’)</span></pre><p id="e852" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了将模型的预测包含到这个新的数据框架中，我们将创建另一个名为“预测”的变量来保存模型的预测。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="7664" class="lp ir ht me b fi mi mj l mk ml">forecast = prophet.predict(future)</span></pre><p id="0f9e" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了方便地查看我们模型的预测信息，我们可以简单地说:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="2b2f" class="lp ir ht me b fi mi mj l mk ml">fig1 = prophet.plot(forecast)</span></pre><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/3097202237adc081aa1e5fd22bff6aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxYl1XYlRdDVyH2zm-OEhw.png"/></div></div></figure><p id="63a2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">此外，我们还可以通过导入和使用函数add_changepoints_to_plot来查看曲线中轨迹可能发生变化的变点:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="57cf" class="lp ir ht me b fi mi mj l mk ml">from fbprophet.plot import add_changepoint_to_plot</span><span id="019a" class="lp ir ht me b fi mm mj l mk ml">fig1 = prophet.plot(forecast)</span><span id="4290" class="lp ir ht me b fi mm mj l mk ml"># viewing the points in time where the trajectory of the price index changed<br/>a = add_changepoints_to_plot(fig1.gca(), prophet, forecast)</span></pre><figure class="lg lh li lj fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mp"><img src="../Images/008b889090f88a21f5d6d99d84f3343e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HXQE7a4cEk57vAy74wrijQ.png"/></div></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">浅蓝色是95%的置信区间</figcaption></figure><h2 id="e021" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">将预测值与实际值进行比较</h2><p id="bcac" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hb bi translated">现在我们已经在预测数据框架中获得了预测，我们可以将预测值绘制成测试集的真实值。要查看预测值和真实值，我们只需创建一个“ax”对象来绘制预测数据框，然后将轴链接到测试数据框。我们还可以设置x轴的限制，以便只查看目标12个月范围内的预测值和实际值。</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mq"><img src="../Images/99d9f8649533576100b3e753a1b52bae.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*RTePi_Gb_XVn_dv86JJPGQ.png"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">预测值与真实值的比较</figcaption></figure><p id="f6c2" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">太好了——但是我们怎么知道我们的模型是否真的表现良好呢？我们可以从statsmodels库中导入一个均方根误差函数，将我们预测的RMSE与真实值进行比较:</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="bcf3" class="lp ir ht me b fi mi mj l mk ml">from statsmodels.tools.eval_measures import rmse</span></pre><p id="18a7" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">为了确保我们将正确的变量输入到预测参数中，我们将创建一个名为“y_pred”的新变量。请记住，预测变量包含的最后12行以上是我们的预测，因此我们需要分隔我们的预测值并指定“yhat”列，以确保我们的“y_pred”变量是对包含12个月预测的数组的引用。我们还可以定义“y_true ”,以便在使用RMSE函数时看起来更好。</p><pre class="lg lh li lj fd md me mf mg aw mh bi"><span id="7139" class="lp ir ht me b fi mi mj l mk ml"># Remember nobs = 12</span><span id="746c" class="lp ir ht me b fi mm mj l mk ml">y_pred = forecast.iloc[-nobs:][‘yhat’]<br/>y_true = test['y']</span><span id="2b94" class="lp ir ht me b fi mm mj l mk ml">rmse(y_pred, y_true)</span></pre><p id="b41f" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">请记住，使用RMSE，很难判断一个模型的表现有多好——在比较一个模型是否比另一个模型表现得更好时，最好使用它。为了展示一个示例，让我们比较一下加法先知模型和乘法先知模型之间的RMSE，看看哪种季节性模型在我们的数据集上表现得更好:</p><figure class="lg lh li lj fd hk er es paragraph-image"><div class="er es mr"><img src="../Images/46e4d9d6ab4a7e1d5fff8a8845f557df.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*J6BaKH92teUxOxrjMMlSrg.jpeg"/></div><figcaption class="lk ll et er es lm ln bd b be z dx translated">比较加法和乘法季节性</figcaption></figure><p id="da15" class="pw-post-body-paragraph jo jp ht jq b jr km jt ju jv kn jx jy jz ko kb kc kd kp kf kg kh kq kj kk kl hb bi translated">在我们的时间序列数据集上进行训练时，使用加性季节性似乎比乘性季节性给我们的模型带来了稍好的结果。如果你想了解我在这篇博客中使用的笔记本，你可以在这里找到它。感谢阅读！</p></div><div class="ab cl ms mt gp mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="hb hc hd he hf"><h2 id="1349" class="lp ir ht bd is lq lr ls iw lt lu lv ja jz lw lx je kd ly lz ji kh ma mb jm mc bi translated">引文</h2><ol class=""><li id="3d73" class="kr ks ht jq b jr js jv jw jz mz kd na kh nb kl kw kx ky kz bi translated">泰勒，肖恩和本·勒撒姆。"预言家:大规模预测."research.fb.com/blog/2017/02/prophet-forecasting-at-scale.，2017年2月23日，脸书研究中心</li></ol></div></div>    
</body>
</html>