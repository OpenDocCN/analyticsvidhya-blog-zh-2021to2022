<html>
<head>
<title>The AOP-Routing library for Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向角度的AOP路由库</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d?source=collection_archive---------10-----------------------#2021-01-04">https://medium.com/analytics-vidhya/the-aop-routing-library-for-angular-9ada05f1741d?source=collection_archive---------10-----------------------#2021-01-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/dd404273cb7ab12a6295d02a91d57b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hSd75Z15NyR3ATTWB-eP8A.jpeg"/></div></div></figure><p id="d344" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有一个令人惊叹的新npm库，名为<a class="ae jo" href="https://www.npmjs.com/package/aop-routing" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> aop-routing </strong> </a>，它增强并为Angular应用程序中的导航和路由带来了许多简洁的功能。</p><h1 id="b6ed" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">aop路由到底是什么？</h1><p id="7f2e" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">直接取自文档:</strong> Aop-Routing通过<strong class="is hj">typescript decorator的易用性，提供了在Angular中执行<a class="ae jo" rel="noopener" href="/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54">命令式和Popstate导航</a>操作的能力，而不需要注入或导入Angular Router对象。</strong></p><p id="6dee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总而言之，aop-routing库允许您在组件之间执行导航，而不必将Router对象导入或注入到组件中，并且还提供了其他简洁的特性，比如在运行时动态更新路由表。执行导航就像在方法顶部放置一个装饰器一样简单，就是这样！</p><blockquote class="ks"><p id="b0b1" class="kt ku hi bd kv kw kx ky kz la lb jn dx translated">Aop-Routing提供了在Angular中执行<a class="ae jo" rel="noopener" href="/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54">命令性和Popstate导航</a>操作的能力，这是通过简单的typescript decorators实现的，不需要导入Angular Router对象。</p></blockquote><h2 id="b1f7" class="lc jq hi bd jr ld le lf jv lg lh li jz jb lj lk kd jf ll lm kh jj ln lo kl lp bi translated">以下是aop路由提供的功能列表:</h2><ul class=""><li id="ba7c" class="lq lr hi is b it kn ix ko jb ls jf lt jj lu jn lv lw lx ly bi translated">使用装饰器的命令式导航</li><li id="c06a" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">使用装饰器的PopState导航</li><li id="367b" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">覆盖默认导航逻辑的自定义导航逻辑</li><li id="7970" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">运行时向路由表动态添加新路径</li><li id="fbfc" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">在运行时动态更改路径的组成部分</li><li id="acbd" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">运行时动态添加/删除激活防护</li></ul></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h1 id="8920" class="jp jq hi bd jr js ml ju jv jw mm jy jz ka mn kc kd ke mo kg kh ki mp kk kl km bi translated">让我们看看如何将这个库安装并集成到我们的应用程序中</h1><p id="e389" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated"><strong class="is hj">注意</strong>:AOP库要求安装<strong class="is hj">angular 8.1</strong>或更高版本！</p><ol class=""><li id="95f0" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn mt lw lx ly bi translated">将aop路由库安装到您的angular应用程序中</li></ol><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="2f18" class="lc jq hi mz b fi nd ne l nf ng">npm install aop-routing</span></pre><p id="5ac0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.安装完库后，将<strong class="is hj"> AopRoutingModule </strong>添加到应用程序的顶层/根模块导入数组中。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="0231" class="lc jq hi mz b fi nd ne l nf ng">imports: [<br/>   ...<br/>    AopRoutingModule<br/>  ]</span></pre><p id="cdeb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.将<strong class="is hj"> AopNavigationService </strong>依赖关系添加到顶级/根模块构造函数中。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="2f9b" class="lc jq hi mz b fi nd ne l nf ng">export class AppModule {<br/>  constructor(private navigationService: AopNavigationService) {}<br/> }</span></pre><p id="8fc7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是将aop-routing库集成到angular应用程序所需的全部内容。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="92c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何使用aop-routing库和它很酷的特性！</p><h2 id="b5d8" class="lc jq hi bd jr ld nh lf jv lg ni li jz jb nj lk kd jf nk lm kh jj nl lo kl lp bi translated">我将使用下面的路由表来演示这些功能</h2><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="f26d" class="lc jq hi mz b fi nd ne l nf ng">const routes: Routes = [<br/><strong class="mz hj">{path: 'page1', component: Page1Component, canActivate: [TestGuard,]},<br/>{path: 'page2', component: Page2Component },<br/>{path: 'page3', component: Page3Component }</strong><br/>];</span></pre><p id="6279" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">转到下一页:</strong></p><p id="7def" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用aop-routing库，当您需要路由到下一个页面或组件时，只需在您想要执行导航的函数上使用<strong class="is hj"> RouteNext() </strong> decorator即可。</p><p id="b88b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下面的例子将在testMethod1执行结束时路由到第2页——注意没有注入或使用路由器对象</strong></p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="98c3" class="lc jq hi mz b fi nd ne l nf ng">import { Component} from '@angular/core';</span><span id="7686" class="lc jq hi mz b fi nm ne l nf ng">@Component({<br/>...<br/>})</span><span id="9111" class="lc jq hi mz b fi nm ne l nf ng">export class Page1Component {</span><span id="0133" class="lc jq hi mz b fi nm ne l nf ng">constructor() {}</span><span id="febd" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteNext('page2')</strong><br/>public testMethod1() {<br/>...some logic...<br/> }<br/>}</span></pre><p id="4e2e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您的导航是基于动态数据的，这也可以通过让您的方法返回一个'<strong class="is hj">字符串</strong>或'<strong class="is hj"> AopNavigator </strong>对象来实现。装饰器将使用返回值来执行路由。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="83cf" class="lc jq hi mz b fi nd ne l nf ng">//Routing dynamically with RouteNext Decorator by returning a string</span><span id="71df" class="lc jq hi mz b fi nm ne l nf ng">import { Component} from '@angular/core';</span><span id="f933" class="lc jq hi mz b fi nm ne l nf ng">@Component({<br/>...<br/>})</span><span id="44d6" class="lc jq hi mz b fi nm ne l nf ng">export class Page1Component {<br/>constructor() {}</span><span id="03d4" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteNext()</strong><br/>public testMethod1(): string {<br/>...some logic...<br/><strong class="mz hj">return 'page2';<br/> </strong>}<br/>}</span><span id="528f" class="lc jq hi mz b fi nm ne l nf ng">-----------------------------------------------------------------<br/>// Routing dynamically with RouteNext Decorator by returning an <br/>// AopNavigator</span><span id="be11" class="lc jq hi mz b fi nm ne l nf ng">import { Component} from '@angular/core';</span><span id="5c2c" class="lc jq hi mz b fi nm ne l nf ng">@Component({<br/>...<br/>})</span><span id="8d40" class="lc jq hi mz b fi nm ne l nf ng">export class Page1Component {<br/>constructor() {}</span><span id="abec" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteNext()</strong><br/>public testMethod1(): string {<br/>  <!-- -->...some logic...<br/>  <strong class="mz hj">const obj: AopNavigator = {<br/>     destinationPage: 'Test2',<br/>   };<br/>  return obj;<br/> </strong>}<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="1543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">aop-routing也有后缀为<strong class="is hj"> Async </strong>的decorators(例如<strong class="is hj"> RouteNextAsync </strong>)，可以与<a class="ae jo" rel="noopener" href="/analytics-vidhya/asynchronous-programming-in-a-nutshell-theory-d5fd07cf3b22">异步</a>方法一起使用。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="ec4b" class="lc jq hi mz b fi nd ne l nf ng">// The RouteNextAsync decorator will route to page2 by subscribing // to testMethod1 and using it's string value to perform the routing<br/><strong class="mz hj">@RouteNextAsync()</strong><br/>public testMethod1(): <strong class="mz hj">Observable&lt;string&gt;</strong> {<br/>  ...some logic...<br/><strong class="mz hj">  return of(1, 2, 3).pipe(<br/>   switchMap(x =&gt; {<br/>     return of('page2');<br/>   })<br/> );</strong><br/>}</span><span id="85bb" class="lc jq hi mz b fi nm ne l nf ng">----------------------------------------------------------------<br/>// The RouteNextAsync decorator will route to page2 by subscribing // to testMethod1 and using the returned AopNavigator object value // to perform the routing</span><span id="0056" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteNextAsync()</strong><br/>public testMethod1(): <strong class="mz hj">Observable&lt;AopNavigator&gt;</strong> {<br/>  ...some logic...<br/>  <br/>   <strong class="mz hj">const obj: AopNavigator = {<br/>    destinationPage: 'Test2',<br/>  };</strong><br/><br/><strong class="mz hj">  return of(1, 2, 3).pipe(<br/>   switchMap(x =&gt; {<br/>     return of(obj);<br/>   })<br/> );</strong><br/>}</span></pre><p id="dccd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> RouteBack </strong>和<strong class="is hj">route back sync</strong>decorator，可用于执行<a class="ae jo" rel="noopener" href="/analytics-vidhya/angular-routing-imperative-vs-popstate-7d254b495c54"> <strong class="is hj"> popstate </strong> </a>导航到上一页。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="e281" class="lc jq hi mz b fi nd ne l nf ng">//testMethod1 will navigate back to previous page after execution<br/><strong class="mz hj">@RouteBack()</strong><br/>public testMethod1() {<br/> ...some logic...<br/>}<br/>-------------------------------------------------------------------<!-- --> </span><span id="d563" class="lc jq hi mz b fi nm ne l nf ng">//Will navigate to the previous page after the asynchronous //execution of testMethod1<br/><strong class="mz hj">@RouteBackAsync()</strong><br/>public testMethod1() {<br/> return of(...some async operations).pipe(<br/> ...rxjs operators...)<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="fc4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">route state</strong>和<strong class="is hj">route state async<br/></strong>AOP-routing库还提供了使用popstate导航来路由到浏览器历史中特定状态的能力。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="18e2" class="lc jq hi mz b fi nd ne l nf ng">// W<!-- -->ill traverse 2 states <strong class="mz hj">backwards </strong>of the browser history state <br/>// equivalent to hitting the browser back button twice<strong class="mz hj"><br/>@RouteToState(-2)</strong><br/>public testMethod1() {<br/> ...some logic...<br/>}</span><span id="ee3b" class="lc jq hi mz b fi nm ne l nf ng">------------------------------------------------------------------</span><span id="23f3" class="lc jq hi mz b fi nm ne l nf ng">//<strong class="mz hj"> </strong>W<!-- -->ill traverse 2 states forward of the browser history state<strong class="mz hj"><br/>@RouteToState(2)</strong><br/>public testMethod1() {<br/> ...some logic...<br/>}</span><span id="2a3a" class="lc jq hi mz b fi nm ne l nf ng">------------------------------------------------------------------</span><span id="ef16" class="lc jq hi mz b fi nm ne l nf ng">// W<!-- -->ill subscribe to the targeted method and use the returned value to traverse 2 states backwards of the browser history state after end of targetted method.</span><span id="f8d0" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteToStateAsync()</strong><br/>public testMethod1(): <strong class="mz hj">Observable&lt;number&gt;</strong> {<br/>  ...some logic...<br/>  return of(1, 2, 3).pipe(<br/>   switchMap(x =&gt; {<br/>     return of(-2);<br/>   })<br/> );<br/>}<br/>------------------------------------------------------------------</span><span id="f303" class="lc jq hi mz b fi nm ne l nf ng">//<strong class="mz hj"> </strong>W<!-- -->ill make the decorator subscribe to the AopNavigator object returned from the targetted method and use the destinationPage property value to perform popstate navigation traversal of the browser history state.<strong class="mz hj"><br/>@RouteToStateAsync()</strong><br/>public testMethod1(): <strong class="mz hj">Observable&lt;AopNavigator&gt;</strong> {<br/>  ...some logic...<br/>  <br/>   <strong class="mz hj">const obj: AopNavigator = {<br/>    destinationPage: -2',<br/>  };</strong><br/><br/>  <strong class="mz hj">return of(1, 2, 3).pipe(<br/>   switchMap(x =&gt; {<br/>     return of(obj);<br/>   })<br/> );</strong><br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="2d69" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> AopNavigator </strong>接口具有其他可选属性，可用于增强aop-routing导航。</p><ul class=""><li id="2734" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn lv lw lx ly bi translated"><strong class="is hj"> destinationPage: </strong>可以向该属性传递一个字符串或数值，该字符串或数值可用于RouteNext、RouteNextAsync、RouteToState和RouteToStateAsync装饰器来执行导航。</li><li id="3861" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><strong class="is hj"> navigationExtra: </strong>该属性接受一个<a class="ae jo" href="https://angular.io/api/router/NavigationExtras" rel="noopener ugc nofollow" target="_blank"> Angular NavigationExtras对象</a>，以允许额外的选项来修改RouteNext和RouteNextAsync装饰器的路由器导航策略。</li><li id="fa9f" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><strong class="is hj">预处理:</strong>该属性采用引用函数。该函数将在装饰者执行任何导航之前执行。</li><li id="77e3" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><strong class="is hj"> param : </strong>该属性将接受任何类型的值，该值可用作预处理属性中传递的函数的参数。</li></ul></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><figure class="mu mv mw mx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/05c60864da675a9df9db443bd5af2646.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8yYM0qy9JnKc0AcAqxaclA.jpeg"/></div></div></figure><h2 id="3263" class="lc jq hi bd jr ld nh lf jv lg ni li jz jb nj lk kd jf nk lm kh jj nl lo kl lp bi translated">自定义逻辑</h2><p id="d3eb" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">如果你想更好地控制导航，这也是可以做到的。<strong class="is hj">AOP-routing库为用户提供了提供他们自己的定制实现来覆盖默认导航逻辑的能力</strong>。</p><p id="0bd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这可以通过简单的3个步骤来完成。</p><ol class=""><li id="7235" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn mt lw lx ly bi translated">创建一个扩展抽象类<strong class="is hj">aopbaseenavigation</strong>的类。</li></ol><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="8af1" class="lc jq hi mz b fi nd ne l nf ng">export class SampleClass extends <strong class="mz hj">AopBaseNavigation </strong>{}</span></pre><p id="34b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.实现AopBaseNavigation抽象类所需的抽象方法。</p><ul class=""><li id="a0c1" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn lv lw lx ly bi translated">goToNextPage()</li><li id="b5d0" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">goToPreviousPage()</li><li id="1606" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated">goToState()</li></ul><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="aafd" class="lc jq hi mz b fi nd ne l nf ng">export class SampleClass extends <strong class="mz hj">AopBaseNavigation </strong>{<br/> public <strong class="mz hj">goToNextPage</strong>(...) {<br/>  ...custom logic...<br/>}<br/><br/> public <strong class="mz hj">goToPreviousPage</strong>(...) {<br/>  ...custom logic...<br/>}<br/><br/> public <strong class="mz hj">goToState</strong>(...) {<br/>  ...custom logic...<br/>}</span></pre><p id="fff2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">3.在顶层/根模块中，将<strong class="is hj"> AopProxyNavigationService添加到providers数组中，并将useClass设置为新创建的类</strong></p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="d701" class="lc jq hi mz b fi nd ne l nf ng">@NgModule({<br/>  imports: [<br/>    ...<br/>    AopRoutingModule<br/>  ],<br/>  <strong class="mz hj">providers</strong>: [<strong class="mz hj">{provide: AopProxyNavigationService, useClass: SampleClass}</strong>],<br/>})</span></pre><p id="3063" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，SampleClass将覆盖默认的导航逻辑。所以装饰者将调用SampleClass的方法，而不是默认的逻辑。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><h2 id="6fae" class="lc jq hi bd jr ld nh lf jv lg ni li jz jb nj lk kd jf nk lm kh jj nl lo kl lp bi translated">动态变化</h2><p id="bef4" class="pw-post-body-paragraph iq ir hi is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hb bi translated">aop-routing库最酷的特性之一是能够在应用程序运行时修改路由表。</p><p id="efcb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注</strong>:文档页面上注明以下功能仍处于实验阶段。</p><p id="0120" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">要打开实验特性，您需要将一个将<strong class="is hj"> experimentalNav </strong>属性设置为true的对象传递给根方法的<strong class="is hj">AopRoutingModule</strong>到顶层/根模块:</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="980b" class="lc jq hi mz b fi nd ne l nf ng">@NgModule({<br/>  ...<br/>  imports: [<br/>    ...<br/>    AopRoutingModule.<strong class="mz hj">forRoot({expirementNav: true})</strong><br/>  ],<br/>  ...<br/>})</span></pre><p id="b811" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">向路由表添加新路径:</strong></p><p id="e07e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">场景:假设在应用程序运行时，对于特定的流，我们想要添加新的route path对象，以便应用程序导航到该对象。我们将使用aop-routing库在应用程序执行期间向上面创建的路由表添加一个新路径。</p><p id="e6d4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">路径将是<strong class="is hj">第4页</strong>并且它应该路由到<strong class="is hj">第4页组件:</strong></p><ol class=""><li id="59d6" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn mt lw lx ly bi translated">创建一个<strong class="is hj"> RouteTransform </strong>对象并设置path和* <em class="no"> component </em>属性:</li></ol><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="eb9f" class="lc jq hi mz b fi nd ne l nf ng">const routeTransform: RouteTransform = {<br/>    path: 'page4',<br/>    component: Page4Component<br/> };</span></pre><p id="01c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">2.在目标函数的RouteNext或RouteNextAsync声明器中，返回一个设置了<strong class="is hj"> routeTransform </strong>属性的<strong class="is hj"> AopNav </strong>对象。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="26ad" class="lc jq hi mz b fi nd ne l nf ng">// aop-routing library will use this object and add this new path to<br/>// the routing table at run time and navigate to it.</span><span id="1e59" class="lc jq hi mz b fi nm ne l nf ng"><strong class="mz hj">@RouteNext()</strong><br/>public testMethod() {<br/>  <strong class="mz hj">const routeTransform: RouteTransform = {<br/>    path: 'page4',<br/>    component: Page4Component<br/> };<br/>  return {routeTransform}</strong><br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="1ae6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在运行时改变路径的组件<br/> </strong>使用aop-routing，我们还可以在运行时改变现有路径的组件。回想一下上一节中我们的路由表，<strong class="is hj">页面1 </strong>将路由到<strong class="is hj">页面1组件。</strong></p><p id="62c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们想在运行时更改组件，转到<strong class="is hj"> Page4Component </strong>。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="8af4" class="lc jq hi mz b fi nd ne l nf ng">// aop-routing will override the default component(Page1Componet)  // set for page1 path and instead set attach Page4Component to page1<br/>@RouteNext()<br/>public testMethod() {<br/>  const routeTransform: RouteTransform = {<br/>   <strong class="mz hj"> path: 'page1',<br/>    component: Page4Component</strong><br/> };<br/>  return {routeTransform}<br/>}</span></pre></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="3573" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">阅读这篇文章以获得关于添加和移除激活防护的更详细的解释:<a class="ae jo" rel="noopener" href="/javascript-in-plain-english/dynamically-add-and-remove-canactivate-route-guards-in-angular-e7820ab4e061"> <strong class="is hj">在角度</strong> </a>中动态添加和移除激活防护</p><p id="97d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在运行时添加激活防护:<br/> </strong>我们也可以在运行时将激活防护添加到路由路径中</p><p id="4d5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下面的例子将把<strong class="is hj"> guard1 </strong>和<strong class="is hj"> guard2 </strong>动态添加到page2 route path并路由到它。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="32df" class="lc jq hi mz b fi nd ne l nf ng"><strong class="mz hj">@RouteNext()</strong><br/>public testMethod() {<br/>  <strong class="mz hj">const routeTransform: RouteTransform = {<br/>    path: 'page2',<br/>    canActivateGuards: [guard1, guard2]<br/> };<br/>  return {routeTransform}</strong><br/>}</span></pre><p id="262d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在运行时移除激活防护:<br/> </strong>激活防护也可以在运行时从路径中移除。它与上面的代码相同。aop-routing库能够检测并删除路由表中是否存在提供的保护。</p><p id="0955" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">运行时禁用所有可激活防护:</strong> <br/>删除与路径相关的所有可激活防护与添加防护的步骤相同。相反，应将canActivateGuards属性设置为空数组。</p><pre class="mu mv mw mx fd my mz na nb aw nc bi"><span id="1415" class="lc jq hi mz b fi nd ne l nf ng"><strong class="mz hj">@RouteNext()</strong><br/>public testMethod() {<br/>  const routeTransform: RouteTransform = {<br/>    path: 'page1',<br/>    <strong class="mz hj">canActivateGuards: []</strong><br/> };<br/>  return {routeTransform}}<!-- --> </span></pre><p id="e427" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">注意</strong>:对路由表的更改不会持久化。在导航之后，路由表恢复到其原始状态。</p></div><div class="ab cl me mf gp mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="hb hc hd he hf"><p id="6948" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">aop-routing library是一个伟大的工具，它极大地增强了angular开发人员的导航能力，并使导航变得更加容易。</p><p id="e016" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你用过aop路由库吗？在下面评论，让我知道你的想法！</p><figure class="mu mv mw mx fd ij er es paragraph-image"><div class="er es np"><img src="../Images/9e17bda49757f233a55bd03d712f39bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*t-51FyMcjSfheHsNB3xxEw.jpeg"/></div></figure><p id="88a0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你喜欢这篇文章，一定要点击几下拍手按钮，也看看我下面的其他文章！</p><ul class=""><li id="5adb" class="lq lr hi is b it iu ix iy jb mq jf mr jj ms jn lv lw lx ly bi translated"><a class="ae jo" rel="noopener" href="/p/b324d20cc277"> <strong class="is hj">地图vs WeakMap </strong> </a></li><li id="3326" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><a class="ae jo" rel="noopener" href="/javascript-in-plain-english/dynamically-add-and-remove-canactivate-route-guards-in-angular-e7820ab4e061"> <strong class="is hj">动态添加和移除角度</strong> </a>中的可激活防护</li><li id="6579" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><a class="ae jo" href="https://ericsarpong.medium.com/asynchronous-programming-in-a-nutshell-theory-d5fd07cf3b22" rel="noopener"> <strong class="is hj">简单地说异步编程(理论)</strong> </a></li><li id="d5f6" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><a class="ae jo" rel="noopener" href="/@ericsarpong/what-is-a-typescript-tuple-814a016f61fd"> <strong class="is hj">什么是类型脚本元组</strong> </a></li><li id="f490" class="lq lr hi is b it lz ix ma jb mb jf mc jj md jn lv lw lx ly bi translated"><a class="ae jo" rel="noopener" href="/@ericsarpong/deep-dive-into-javascript-map-object-24c012e0b3fe"> <strong class="is hj">深度潜入Javascript图</strong> </a></li></ul></div></div>    
</body>
</html>