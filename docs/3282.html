<html>
<head>
<title>Plotly Subplots &amp; Plot Layering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">情节曲折的次要情节和情节层次</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/plotly-subplots-plot-layering-2c31434da1bb?source=collection_archive---------2-----------------------#2021-06-23">https://medium.com/analytics-vidhya/plotly-subplots-plot-layering-2c31434da1bb?source=collection_archive---------2-----------------------#2021-06-23</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="baef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好，在这个故事中，我们将尝试涵盖支线剧情和情节层次。在我们开始之前，首先我需要解释一下我的情况。我正在努力学习英语，所以请不要对我的英语评头论足😅让我们试着涵盖支线剧情和剧情层次感。</p><h1 id="afd3" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">有哪些支线剧情</h1><p id="0739" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以说，排列在网格中的迷你图。我们</p><ul class=""><li id="9dd7" class="kg kh hi ih b ii ij im in iq ki iu kj iy kk jc kl km kn ko bi translated">可以显示来自同一数据集的不同图</li><li id="854c" class="kg kh hi ih b ii kp im kq iq kr iu ks iy kt jc kl km kn ko bi translated">可以显示数据集不同子集的相同图</li></ul><h2 id="9bab" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">怎么会使用支线剧情</h2><p id="e338" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们需要从<strong class="ih hj">下导入<strong class="ih hj">make _支线剧情</strong>.支线剧情</strong>。<strong class="ih hj">请不要忘记，在写这篇文章的时候，make_subplots不支持plotly.express. </strong>所以我们不能在plotly.express剧情中使用make_subplots。</p><p id="4754" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用这段代码将库导入到项目中。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="9d61" class="ku je hi ln b fi lr ls l lt lu">from plotly.subplots import make_subplots</span></pre><p id="be65" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我们将使用这些库，并且我们将使用seaborn下的<strong class="ih hj">提示</strong>数据集。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="895f" class="ku je hi ln b fi lr ls l lt lu">import pandas as pd # creating and manipulating dataframes<br/>import seaborn as sns # accessing to dataset<br/>import plotly.graph_objects as go # we can not use express plots<br/>from plotly.subplots import make_subplots # creating subplots</span></pre><h2 id="c3e0" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">让我们创建第一个支线剧情</h2><p id="a6bf" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我将创建条形图。因此，我将数据分组。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="ff88" class="ku je hi ln b fi lr ls l lt lu">df = sns.load_dataset('tips')<br/>grouped_df = df.groupby(['sex', 'day'], as_index=False).sum()<br/>grouped_df.head()</span></pre><p id="83c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我需要创建解析的网格。在这个例子中，我将创建1x2(列x行)网格。我是用make_subplots函数来做的。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="bd7d" class="ku je hi ln b fi lr ls l lt lu">fig = make_subplots(rows=1, cols=2)</span></pre><p id="0081" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后它会返回一个图形对象给我。我们从普罗特利那里知道了这件事。我们将使用add_trace函数在图形对象上添加我们的绘图。<strong class="ih hj">请不要忘记，我们需要给出我们创建的图形将出现的具体列和行号。</strong></p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="b7ae" class="ku je hi ln b fi lr ls l lt lu"># add the 1st graph by specifying which row and column it will come to<br/>fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex'] == 'Male']['day'], y=grouped_df[grouped_df['sex'] == 'Male']['tip'], name='Male'),row=1, col=1)</span><span id="7729" class="ku je hi ln b fi lv ls l lt lu"># add the 2nd graph<br/>fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex'] == 'Female']['day'], y=grouped_df[grouped_df['sex'] == 'Female']['tip'], name='Female'), row=1, col=2)</span></pre><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/e31d5daea7dc4389e7cc8ee6408c2477.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTHB7TWoABWHiSGDtg90kw.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">在执行我们编写的代码后，我们会看到这个图</figcaption></figure><h1 id="5d77" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">让我们为我们的情节做些补充</h1><h2 id="e5ea" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">设定每个支线剧情的标题</h2><p id="d2f9" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在这一部分，我们将设置每个支线剧情的标题。我们需要在make_subplots函数中使用<strong class="ih hj"> subplot_titles </strong>参数。这个参数接受一个包含子情节标题的列表。请不要忘记，标题必须在此列表中排队。0索引将是第一个图表的标题。</p><p id="3b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用相同的轨迹和数据集。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="2bf0" class="ku je hi ln b fi lr ls l lt lu">grouped_df = df.groupby(['sex', 'day'], as_index=False).sum()</span><span id="3814" class="ku je hi ln b fi lv ls l lt lu">fig = make_subplots(rows=1,<br/>                    cols=2,<br/>                    subplot_titles=[<br/>                        'Erkekler',  # 1. subplot title<br/>                        'Kadınlar'  # 2. subplot title<br/>])</span><span id="130a" class="ku je hi ln b fi lv ls l lt lu"><br/>fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex'] == 'Male']['day'], y=grouped_df[grouped_df['sex'] == 'Male']['tip'], name='Male'),row=1, col=1)</span><span id="0656" class="ku je hi ln b fi lv ls l lt lu"><br/>fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex'] == 'Female']['day'], y=grouped_df[grouped_df['sex'] == 'Female']['tip'], name='Female'), row=1, col=2)</span><span id="031c" class="ku je hi ln b fi lv ls l lt lu"><br/>fig.update_layout(title='Günlere Göre Toplam Bahşişler', title_x=0.5)</span></pre><p id="33c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">那么上面发生了什么？首先，我们创建了一个经过解析的网格。但与之前不同的是，我们给了<strong class="ih hj"> subplot_titles </strong>参数。因此，我们的图表拥有自己的标题。请记住，标题参数是update_layout中不是来自sub_plots的参数。它来自Plotly图。所以这个参数只影响主网格。</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/8814fa67b21385a0f1dd8444b8b6a3f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1AWyE8vxCYmGk-YJAqZ1tw.png"/></div></div></figure><h2 id="3ac2" class="ku je hi bd jf kv kw kx jj ky kz la jn iq lb lc jr iu ld le jv iy lf lg jz lh bi translated">共享每个图形的X轴</h2><p id="a81d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以共享每个图的x轴或y轴。在这个例子中，我们将对x轴这样做。我们需要在make_subplots函数中使用<strong class="ih hj"> shared_xaxes=True </strong>参数。如果想要共享y轴，我们可以使用<strong class="ih hj"> shared_yaxis=True </strong>参数。同样，我们将使用相同的数据集，但我们的数字创建风格不会像以前一样。我们将为每个类别使用for循环，在本例中网格将为2 x 1。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="06ec" class="ku je hi ln b fi lr ls l lt lu">grouped_df = df.groupby(['sex', 'day'], as_index=False).sum()</span><span id="4d93" class="ku je hi ln b fi lv ls l lt lu">fig = make_subplots(rows=len(grouped_df['sex'].unique()), cols=1, shared_xaxes=True)</span></pre><p id="601b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们创建了一个子情节网格，其中的行数是根据每个唯一的类别长度来计算的。因此，我们将为每个唯一值创建一个新行。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="e5e2" class="ku je hi ln b fi lr ls l lt lu">row = 1<br/>for trace in grouped_df['sex'].unique():<br/>    fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex'] == trace['day'], y=grouped_df[grouped_df['sex'] == trace]['tip'], name=trace), row=row, col=1)<br/>    row += 1</span></pre><p id="d4a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用行号创建了一个行变量来对齐图形。我们将它的值设置为1。因为支线剧情中的索引不像列表中的索引。从1开始。之后，我们为每个唯一的性别值添加了一个跟踪，并设置了它们的行号和列号。如图所示，我们共享每个图形的x轴。</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/059705956fa575a0c7fbffa34afea1ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6jMCP6lWl3lwd9TnKjbXIQ.png"/></div></div><figcaption class="me mf et er es mg mh bd b be z dx translated">每个图形共享x轴的图形</figcaption></figure><h1 id="564e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">情节分层</h1><p id="7281" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们可以说，对于情节分层，它是通过在同一个图形中反复创建图形来实现的。我们不需要解析网格。为此，我们将再次使用<strong class="ih hj"> add_trace </strong>函数。我们将使用相同的数据集和分组数据帧。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="46d0" class="ku je hi ln b fi lr ls l lt lu">grouped_df = df.groupby(['sex', 'day'], as_index=False)a.sum()</span><span id="8f6a" class="ku je hi ln b fi lv ls l lt lu">fig = go.Figure() # create empty figure</span><span id="6168" class="ku je hi ln b fi lv ls l lt lu">fig.add_trace(go.Bar(x=grouped_df[grouped_df['sex']=='Male']['day'], y=grouped_df[grouped_df['sex']=='Male']['tip'],name='Male'))</span></pre><p id="9de8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们创建了一个空的数字。之后，我们添加了一个条形图。如果执行它，我们会看到这个输出。</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/a49e27dbe666e0cd48eb16a89ec9692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jOQQ8uQh5T9IsvVMEpfgTw.png"/></div></div></figure><p id="1c5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们假设，我们想在这个条形图上添加一个折线图。我会再次使用同样的手法，<strong class="ih hj">添加_痕迹</strong>。</p><pre class="li lj lk ll fd lm ln lo lp aw lq bi"><span id="370b" class="ku je hi ln b fi lr ls l lt lu">fig.add_trace(go.Scatter(x=grouped_df[grouped_df['sex']=='Female']['day'], y=grouped_df[grouped_df['sex']=='Female']['tip'],mode='lines+markers',name='Female'))</span><span id="66de" class="ku je hi ln b fi lv ls l lt lu">fig.show()</span></pre><p id="ea3c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在如果执行这段代码，我们会看到这个输出。所以我们把我们的情节分层。</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/c4d7c7b91a724df1bfc2f34856287e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WIEoDyMCoRCu3s2qaVtVQ.png"/></div></div></figure><p id="3493" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以从<a class="ae mi" href="https://github.com/mebaysan/VeriBilimi/blob/master/Python/3-)KesifciVeriAnaliziVeVeriGorsellestirme/Plotly-Dash-Examples/Plotly-Subplots/Plotly-Subplots.ipynb" rel="noopener ugc nofollow" target="_blank">我的GitHub repo </a>获取代码。我希望它会有帮助。亲切的问候。</p></div></div>    
</body>
</html>