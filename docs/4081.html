<html>
<head>
<title>Searching Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">搜索算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/searching-algorithms-f98e0d3fa966?source=collection_archive---------7-----------------------#2021-08-24">https://medium.com/analytics-vidhya/searching-algorithms-f98e0d3fa966?source=collection_archive---------7-----------------------#2021-08-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/785ad1b66d22cabbfe211e6f779230d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXLvBVY09V95bAjy-Y-iDA.png"/></div></div></figure><p id="48f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">​</p><p id="cfa0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">搜索算法</strong>是计算中的一个基本步骤，通过逐步方法在数据集合中定位特定数据。</p><h1 id="d446" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是搜索算法？</h1><p id="811e" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">根据维基百科，搜索算法是-</p><blockquote class="kq kr ks"><p id="08d9" class="ip iq kt ir b is it iu iv iw ix iy iz ku jb jc jd kv jf jg jh kw jj jk jl jm ha bi translated">解决搜索问题的任何算法，即检索存储在某种数据结构中的信息，或在问题域的搜索空间中计算的具有离散或连续值的信息。</p></blockquote><p id="3552" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它们被设计成从存储元素的任何数据结构中检查或检索元素。他们在搜索空间中搜索目标(关键字)。</p><h1 id="fe0a" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">搜索算法的类型</h1><p id="f3f0" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在这篇文章中，我们主要讨论两个重要的算法-</p><ol class=""><li id="a1a9" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm lc ld le lf bi translated"><strong class="ir hi">线性或顺序搜索</strong></li><li id="103c" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm lc ld le lf bi translated"><strong class="ir hi">二分搜索法</strong></li></ol><p id="335d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们用例子、代码实现和时间复杂度分析来详细讨论这两个。</p><h1 id="3161" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">线性或顺序搜索</h1><p id="250d" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">该算法的工作方式是从一端开始依次遍历整个数组或列表，直到找到目标元素。如果找到该元素，则返回其索引，否则为-1。</p><p id="2e05" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们举个例子，试着去理解:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="c4c1" class="lu jo hh lq b fi lv lw l lx ly">arr = [2, 12, 15, 11, 7, 19, 45]</span></pre><p id="e849" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设要搜索的目标元素是<code class="du lz ma mb lq b">7</code>。</p><h1 id="c6ad" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法:</h1><ul class=""><li id="be63" class="kx ky hh ir b is kl iw km ja mc je md ji me jm mf ld le lf bi translated">从索引0开始，将每个元素与目标进行比较</li><li id="683b" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">如果发现目标等于元素，则返回其索引</li><li id="45ff" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">如果没有找到目标，返回-1</li></ul><h1 id="adb0" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码实现</h1><p id="b056" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><strong class="ir hi">在Java中</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="2984" class="lu jo hh lq b fi lv lw l lx ly">package algorithms.searching;</span><span id="b99f" class="lu jo hh lq b fi mg lw l lx ly">public class LinearSearch {<br/>    public static void main(String[] args) {<br/>        int[] nums = {2, 12, 15, 11, 7, 19, 45};<br/>        int target = 7;<br/>        System.out.println(search(nums, target));</span><span id="e9f5" class="lu jo hh lq b fi mg lw l lx ly">    }</span><span id="e33a" class="lu jo hh lq b fi mg lw l lx ly">    static int search(int[] nums, int target) {<br/>        for (int index = 0; index &lt; nums.length; index++) {<br/>            if (nums[index] == target) {<br/>                return index;<br/>            }<br/>        }<br/>        return -1;<br/>    }<br/>}</span></pre><p id="f685" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在Python中</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="d29d" class="lu jo hh lq b fi lv lw l lx ly">def search(nums, target):<br/>    for i in range(len(nums)):<br/>        if nums[i] == target:<br/>            return i<br/>    return -1</span><span id="941b" class="lu jo hh lq b fi mg lw l lx ly">if __name__ == '__main__':<br/>    nums = [2, 12, 15, 11, 7, 19, 45]<br/>    target = 7<br/>    print(search(nums, target))</span></pre><h1 id="c2ee" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂性分析</h1><ul class=""><li id="58dd" class="kx ky hh ir b is kl iw km ja mc je md ji me jm mf ld le lf bi translated"><strong class="ir hi">最佳情况:</strong>当目标元素是数组的第一个元素时，出现最佳情况。在这种情况下，比较的次数是1。所以，时间复杂度是<code class="du lz ma mb lq b">O(1)</code>。</li><li id="2f1d" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated"><strong class="ir hi">平均情况:</strong>平均来说，目标元素会在数组中间的某个地方。在这种情况下，比较的次数将是N/2。所以，时间复杂度将是<code class="du lz ma mb lq b">O(N)</code>(常量被忽略)。</li><li id="a2ea" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated"><strong class="ir hi">最坏情况</strong>:当目标元素是数组中的最后一个元素或者不在数组中时，出现最坏情况。在这种情况下，我们必须遍历整个数组，因此比较的次数将是n。因此，时间复杂度将是<code class="du lz ma mb lq b">O(N)</code>。</li></ul><h1 id="93ec" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">二进位检索</h1><p id="9feb" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">这种类型的搜索算法用于在排序数组中查找包含<strong class="ir hi">的特定值的位置。二分搜索法算法的工作原理是分治法，它被认为是最好的搜索算法，因为它的搜索速度更快。</strong></p><p id="1687" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们以一个排序数组为例，试着去理解:</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b763" class="lu jo hh lq b fi lv lw l lx ly">arr = [2, 12, 15, 17, 27, 29, 45]</span></pre><p id="d72e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设要搜索的目标元素是1个<code class="du lz ma mb lq b">7</code>。</p><h1 id="55aa" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法</h1><ul class=""><li id="bd2d" class="kx ky hh ir b is kl iw km ja mc je md ji me jm mf ld le lf bi translated">将目标元素与数组的中间元素进行比较。</li><li id="f681" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">如果目标元素大于中间的元素，则在右半部分继续搜索。</li><li id="fc98" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">否则，如果目标元素小于中间值，则在左半部分继续搜索。</li><li id="4c17" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">重复这个过程，直到中间元素等于目标元素，或者目标元素不在数组中</li><li id="2d40" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">如果找到目标元素，则返回其索引，否则返回-1。</li></ul><h1 id="a046" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码实现</h1><p id="ed1b" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><strong class="ir hi">在Java里</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="1348" class="lu jo hh lq b fi lv lw l lx ly">package algorithms.searching;</span><span id="822c" class="lu jo hh lq b fi mg lw l lx ly">public class BinarySearch {<br/>    public static void main(String[] args) {<br/>        int[] nums = {2, 12, 15, 17, 27, 29, 45};<br/>        int target = 17;<br/>        System.out.println(search(nums, target));<br/>    }</span><span id="d6fc" class="lu jo hh lq b fi mg lw l lx ly">    static int search(int[] nums, int target) {<br/>        int start = 0;<br/>        int end = nums.length - 1;</span><span id="9b59" class="lu jo hh lq b fi mg lw l lx ly">        while (start &lt;= end) {<br/>            int mid = start + (end - start) / 2;</span><span id="e25e" class="lu jo hh lq b fi mg lw l lx ly">            if (nums[mid] &gt; target)<br/>                end = mid - 1;<br/>            else if (nums[mid] &lt; target)<br/>                start = mid + 1;<br/>            else<br/>                return mid;<br/>        }<br/>        return -1;<br/>    }<br/>}</span></pre><p id="4fda" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在Python中</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="11f0" class="lu jo hh lq b fi lv lw l lx ly">def search(nums, target):<br/>    start = 0<br/>    end = len(nums)-1</span><span id="4fab" class="lu jo hh lq b fi mg lw l lx ly">    while start &lt;= end:<br/>        mid = start + (end-start)//2<br/></span><span id="839c" class="lu jo hh lq b fi mg lw l lx ly">        if nums[mid] &gt; target:<br/>            end = mid-1<br/>        elif nums[mid] &lt; target:<br/>            start = mid+1<br/>        else:<br/>            return mid</span><span id="154c" class="lu jo hh lq b fi mg lw l lx ly">    return -1<br/></span><span id="5876" class="lu jo hh lq b fi mg lw l lx ly">if __name__ == '__main__':<br/>    nums = [2, 12, 15, 17, 27, 29, 45]<br/>    target = 17<br/>    print(search(nums, target))</span></pre><h1 id="a216" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂性分析</h1><ul class=""><li id="cbc0" class="kx ky hh ir b is kl iw km ja mc je md ji me jm mf ld le lf bi translated"><strong class="ir hi">最佳情况:</strong>当目标元素是数组的中间元素时，出现最佳情况。在这种情况下，比较的次数是1。所以，时间复杂度是<code class="du lz ma mb lq b">O(1)</code>。</li><li id="b89d" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated"><strong class="ir hi">平均情况:</strong>平均来说，目标元素会在数组的某个地方。所以，时间复杂度将是<code class="du lz ma mb lq b">O(logN)</code></li><li id="26d6" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated"><strong class="ir hi">最坏情况:</strong>最坏情况发生在目标元素不在列表中或者远离中间元素的时候。所以，时间复杂度将是<code class="du lz ma mb lq b">O(logN)</code></li></ul><p id="7059" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">计算时间复杂度:</strong></p><ul class=""><li id="9a8b" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">假设二分搜索法的迭代在<strong class="ir hi"> k </strong>次迭代后终止。</li><li id="899a" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">在每次迭代中，数组被除以二。所以我们假设在任何迭代中数组的长度是<strong class="ir hi"> N </strong></li><li id="ac0a" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">在<strong class="ir hi">迭代1时，</strong></li></ul><p id="7ad8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lz ma mb lq b">Length of array = N</code></p><ul class=""><li id="52a1" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">在<strong class="ir hi">迭代2 </strong>时，</li></ul><p id="47a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lz ma mb lq b">Length of array = N/2</code></p><ul class=""><li id="c4e3" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">在<strong class="ir hi">迭代3 </strong>时，</li></ul><p id="a1e8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lz ma mb lq b">Length of array = (N/2)/2 = N/2^2</code></p><ul class=""><li id="d93c" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">在<strong class="ir hi">迭代k </strong>时，</li></ul><p id="eb54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lz ma mb lq b">Length of array = N/2^k</code></p><ul class=""><li id="a405" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">同样，我们知道经过k次除法运算后，数组的<strong class="ir hi">长度变为1 </strong></li><li id="b946" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">数组长度=<strong class="ir hi">n/2^k = 1</strong>=&gt;<strong class="ir hi">n = 2^k</strong></li><li id="c478" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">在两侧应用对数函数:</li><li id="159c" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">= &gt;<strong class="ir hi">log2(n)= log2(2^k)</strong>=&gt;<strong class="ir hi">log2(n)= k log2(2)</strong></li><li id="21f6" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">由于<strong class="ir hi"> (loga (a) = 1) </strong> <br/>因此</li><li id="c018" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">=&gt; <strong class="ir hi"> k = log2 (N) </strong></li><li id="de60" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated"><strong class="ir hi">因此，二分搜索法的时间复杂度为log2 (N) </strong></li></ul><p id="1416" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您也可以使用由<a class="ae mh" href="https://www.linkedin.com/in/dipesh-patil/" rel="noopener ugc nofollow" target="_blank"> Dipesh Patil </a> — <a class="ae mh" href="https://dipeshpatil.github.io/algorithms-visualiser/#/searching" rel="noopener ugc nofollow" target="_blank">算法可视化器</a>构建的简单工具来可视化上述两种算法</p><h1 id="3ca2" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">顺序不可知的二分搜索法</h1><p id="1ef2" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">假设，我们必须在一个排序数组中找到一个目标元素。虽然我们知道数组是排序的，但我们不知道它是按升序还是降序排序的。</p><h1 id="50f7" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">方法</h1><p id="e82c" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">实现类似于二分搜索法，只是我们需要确定数组是按升序还是降序排序，以决定是在数组的左半部分还是右半部分继续搜索。</p><ul class=""><li id="85f5" class="kx ky hh ir b is it iw ix ja kz je la ji lb jm mf ld le lf bi translated">我们首先将目标与中间元素进行比较</li><li id="4515" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">如果<em class="kt">数组按升序排序，并且目标小于中间元素</em> <strong class="ir hi">或</strong> <em class="kt">，数组按降序排序，并且目标大于中间元素</em>，那么我们通过设置<code class="du lz ma mb lq b">end=mid-1</code>继续在数组的下半部分搜索。</li><li id="6f12" class="kx ky hh ir b is lg iw lh ja li je lj ji lk jm mf ld le lf bi translated">否则，我们通过设置<code class="du lz ma mb lq b">start=mid+1</code>在数组的上半部分执行搜索</li></ul><p id="b0d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们唯一需要做的就是弄清楚数组是按升序排序还是降序排序。通过比较数组的第一个和最后一个元素，我们可以很容易地找到这一点。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="472e" class="lu jo hh lq b fi lv lw l lx ly">if arr[0] &lt; arr[arr.length-1]<br/>    array is sorted in ascending order <br/>else<br/>    array is sorted in descending order</span></pre><h1 id="a7e6" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">代码实现</h1><p id="13c9" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><strong class="ir hi">在Java中</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="3ca3" class="lu jo hh lq b fi lv lw l lx ly">package algorithms.searching;</span><span id="cd05" class="lu jo hh lq b fi mg lw l lx ly">public class OrderAgnosticBinarySearch {<br/>    public static void main(String[] args) {<br/>        int[] nums1 = {-1, 2, 4, 6, 7, 8, 12, 15, 19, 32, 45, 67, 99};<br/>        int[] nums2 = {99, 67, 45, 32, 19, 15, 12, 8, 7, 6, 4, 2, -1};<br/>        int target = -1;<br/>        System.out.println(search(nums1, target));<br/>        System.out.println(search(nums2, target));<br/>    }</span><span id="525d" class="lu jo hh lq b fi mg lw l lx ly">    static int search(int[] arr, int target) {<br/>        int start = 0;<br/>        int end = arr.length - 1;</span><span id="ba40" class="lu jo hh lq b fi mg lw l lx ly">        boolean isAscending = arr[start] &lt; arr[end];</span><span id="47d8" class="lu jo hh lq b fi mg lw l lx ly">        while (start &lt;= end) {<br/>            int mid = start + (end - start) / 2;</span><span id="bfcf" class="lu jo hh lq b fi mg lw l lx ly">            if (target == arr[mid])<br/>                return mid;</span><span id="7258" class="lu jo hh lq b fi mg lw l lx ly">            if (isAscending) {<br/>                if (target &lt; arr[mid]) {<br/>                    end = mid - 1;<br/>                } else {<br/>                    start = mid + 1;<br/>                }<br/>            } else {<br/>                if (target &lt; arr[mid]) {<br/>                    start = mid + 1;<br/>                } else {<br/>                    end = mid - 1;<br/>                }<br/>            }<br/>        }<br/>        return -1;<br/>    }<br/></span><span id="08d4" class="lu jo hh lq b fi mg lw l lx ly">}</span></pre><p id="72f0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">在Python中</strong></p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="1d79" class="lu jo hh lq b fi lv lw l lx ly">def search(nums, target):<br/>    start = 0<br/>    end = len(nums)-1</span><span id="9602" class="lu jo hh lq b fi mg lw l lx ly">    is_ascending = nums[start] &lt; nums[end]</span><span id="8721" class="lu jo hh lq b fi mg lw l lx ly">    while start &lt;= end:<br/>        mid = start + (end-start)//2</span><span id="ba65" class="lu jo hh lq b fi mg lw l lx ly">        if target == nums[mid]:<br/>            return mid</span><span id="adea" class="lu jo hh lq b fi mg lw l lx ly">        if is_ascending:<br/>            if target &lt; nums[mid]:<br/>                end = mid-1<br/>            else:<br/>                start = mid+1<br/>        else:<br/>            if target &lt; nums[mid]:<br/>                start = mid+1<br/>            else:<br/>                end = mid-1</span><span id="2986" class="lu jo hh lq b fi mg lw l lx ly">    return -1<br/></span><span id="c45a" class="lu jo hh lq b fi mg lw l lx ly">if __name__ == '__main__':<br/>    nums1 = [-1, 2, 4, 6, 7, 8, 12, 15, 19, 32, 45, 67, 99]<br/>    nums2 = [99, 67, 45, 32, 19, 15, 12, 8, 7, 6, 4, 2, -1]<br/>    target = -1<br/>    print(search(nums1, target))<br/>    print(search(nums2, target))</span></pre><h1 id="1e70" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间复杂性分析</h1><p id="84b5" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">时间复杂度没有变化，因此将与二分搜索法相同。</p><h1 id="c817" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">结论</h1><p id="e6b7" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">在这篇博客中，我们讨论了两个最重要的搜索算法。这篇博文不能不感谢那个激励了很多学生学习DSA的人，那也是免费的——Kunal Kushwaha和<a class="ae mh" href="https://www.linkedin.com/company/commclassroom/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">社区教室</strong> </a>。你也可以在这里访问他的免费DSA播放列表。</p><p id="6937" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最初发布在:<a class="ae mh" href="https://iread.ga/posts/39/searching-algorithms" rel="noopener ugc nofollow" target="_blank">https://iread.ga/posts/39/searching-algorithms</a>T24】我也将很快在<a class="ae mh" href="https://www.geeksforgeeks.org/" rel="noopener ugc nofollow" target="_blank"> GeeksforGeeks </a>上发布它。</p><p id="d862" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">​</p></div></div>    
</body>
</html>