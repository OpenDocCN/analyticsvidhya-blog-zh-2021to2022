<html>
<head>
<title>Customer Segmentation: Kmeans Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">客户细分:k均值聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/customer-segmentation-kmeans-clustering-7670e317b54c?source=collection_archive---------3-----------------------#2021-08-14">https://medium.com/analytics-vidhya/customer-segmentation-kmeans-clustering-7670e317b54c?source=collection_archive---------3-----------------------#2021-08-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7bd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用公共在线零售商数据集，通过K-means聚类，基于购买和频率对客户进行细分。</p><p id="3c4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">简介</strong></p><p id="302d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">什么是客户细分？</em></p><p id="df7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">顾名思义，根据购买次数、购买频率、购买的产品类型将客户划分到特定的组，再划分到同质的组。在任何一家<a class="ae jd" rel="noopener" href="/analytics-vidhya/customer-segmentation-with-rfm-analysis-kmeans-clustering-32c387d04dfe">企业</a>，分析和留住现有客户以及开发和吸引新客户都很重要。</p><p id="1f48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在一定程度上，人们发现，与开发新客户相比，留住客户会导致更多的努力。因为现有客户更有可能在产品上花费更多。满足这些<a class="ae jd" href="https://www.business2community.com/customer-experience/why-your-existing-customers-are-your-best-customers-02199165#:~:text=for%20your%20business.-,Your%20existing%20customers%20are%20more%20likely%20to%20spend%20more%20on,to%20buy%20from%20you%20again" rel="noopener ugc nofollow" target="_blank">客户</a>将有助于建立庞大、强大、可靠的客户群，也有助于你产品的重复购买。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c7e765f4bcedd431d6e3d074ffc2dc20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t6QwyIpez1oLPRzMHLGvnA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">图片来自<a class="ae jd" href="https://images.unsplash.com/photo-1521790797524-b2497295b8a0?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1049&amp;q=80" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="fdd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">用什么特征来区分顾客？</em></p><p id="9728" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据各自业务中使用的用例来划分客户。许多企业/组织使用客户细分来优化向myraid客户群销售产品的能力。</p><ul class=""><li id="f2a2" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Targeted_advertising" rel="noopener ugc nofollow" target="_blank">在线广告</a>:广告的类型，其中广告商使用来自社交媒体档案和使用、搜索引擎使用和习惯(烦人的cookies！)和网络浏览习惯，并据此对客户进行细分。有时，甚至社会经济条件、位置和行为也被用来为广告服务。</li><li id="121f" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">医疗保健:<a class="ae jd" href="https://www2.deloitte.com/us/en/insights/industry/health-care/healthcare-consumer-patient-segmentation.html" rel="noopener ugc nofollow" target="_blank"> Delloite </a>对10，000多名美国消费者进行了调查，以分析他们对医疗保健、健康保险和福祉的态度、行为和优先事项。每个消费者对医疗保健计划都有不同的方法和偏好，delloite将消费者分为4组。这种方法有助于医疗保健利益相关者了解和分析不同类型的消费者，并向期望的消费者提供合适的建议。</li><li id="8ced" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">汽车公司:在这个用例中，汽车不是细分的，而是客户根据他们的需求细分的，汽车的类型是满足客户需求的设计方案。有些群体是越野、环境意识、家庭需求、质量问题、突出人群等。这是一篇很好的<a class="ae jd" href="https://www.stephenzoeller.com/targetmarket-segment-porsche/" rel="noopener ugc nofollow" target="_blank">文章</a>,其中保时捷使用细分技术来锁定客户，销售他们独特的汽车。</li><li id="0829" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">还有各种其他行业，如银行和金融服务、护肤和美容产品制造商、电视和移动网络。等。</li></ul><p id="ef16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，客户细分有助于发展业务和满足客户需求。</p><p id="e817" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">现实中客户是如何细分的？</em></p><p id="b35b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在要了解客户是如何细分的，技术上来说，有很多无监督的算法来解决。这些机器学习算法中的许多可以帮助公司识别他们的用户/客户群，并创建所需的客户群。</p><p id="f059" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一种这样的算法是K-均值聚类算法。该算法有助于分析未标记的客户数据，并将每个数据点/客户分配到聚类中。</p><p id="9870" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">K-均值聚类</strong></p><p id="4efe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用从英国在线零售店获得的在线零售客户数据。我们将帮助他们选择最好的顾客群，他们将从商店购买独特的节日礼物。数据可在<a class="ae jd" href="https://www.kaggle.com/hellbuoy/online-retail-customer-clustering" rel="noopener ugc nofollow" target="_blank"> kaggle </a>中获得。</p><p id="310b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">所需库</strong></p><p id="4f6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">确保在分析数据之前安装了以下库:pandas、scikit-learn、matplotlib、seaborn。安装完成后，让我们来构建模型！</p><p id="55b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">读取数据帧</strong></p><p id="1cdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用以下代码导入所需的库:</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="79b7" class="kn ko hh kj b fi kp kq l kr ks">import pandas as pd<br/>from sklearn.cluster import KMeans<br/>from sklearn.preprocessing import StandardScaler<br/>import matplotlib.pyplot as plt<br/>import seaborn as sns<br/>from sklearn.decomposition import PCA</span></pre><p id="94cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行下面一行来读取<a class="ae jd" href="https://www.kaggle.com/hellbuoy/online-retail-customer-clustering" rel="noopener ugc nofollow" target="_blank">数据集</a>，然后让我们看看数据框:</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="fc50" class="kn ko hh kj b fi kp kq l kr ks">data = pd.read_csv('OnlineRetail.csv',<br/>                   encoding = 'unicode_escape')</span><span id="9b25" class="kn ko hh kj b fi kt kq l kr ks">data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ku"><img src="../Images/97892d9f1fe6415f7ef3480baaa0f366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JarQFoLGFiq9FGCLu7uuJA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="aa3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据集中有8个变量。</p><ul class=""><li id="d4cc" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">InvoiceNo:客户完成的交易的唯一标识符</li><li id="1cab" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">StockCode:因为它是一家批发零售商店，所以它对每种商品的库存都有唯一的标识符。</li><li id="b661" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">描述和数量不言自明(项目和项目数量)</li><li id="36d8" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">InnvoiceDate:客户完成付款的日期和时间</li><li id="098c" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">单价:项目的单位价格</li><li id="46c3" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">CustomerId:数据集中每个客户的唯一标识符</li></ul><p id="fd87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">数据预处理</strong></p><p id="f586" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们删除丢失的值，因为它对我们没有帮助。然而，并不总是要删除丢失的值。基于应用和用例，您需要做出相应的决定。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="6179" class="kn ko hh kj b fi kp kq l kr ks">data.info()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kv"><img src="../Images/7a52713866cc280231652a49ad21b8fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*JB5W7BqoNyMKXWWzMSkQOQ.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="683f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们看到的，缺少客户的值，没有CustomerId，我们就无法使用其他信息，所以我们可以删除它。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="6c3c" class="kn ko hh kj b fi kp kq l kr ks">data.dropna(inplace = True)<br/>data.isna().sum()<br/>data.info()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kw"><img src="../Images/81db0232dd2f8b6b7f70a93eab900262.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*hsad5wQbqtCZawc4esQ2bA.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="4a01" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建total_amount列，因为您将理解我们为什么在您进行此项目时创建此列。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="2997" class="kn ko hh kj b fi kp kq l kr ks">data['Total_Amount'] = data['Quantity']*data['UnitPrice']</span></pre><p id="cd1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在继续之前，让我们了解如何分析这个数据集。有许多方法来分析这个数据集，但我们将看到RFM分析。这种分析很久以前就被采纳并付诸实践了。它在营销工作中起着至关重要的作用。该分析中的三个主要变量:</p><ul class=""><li id="6b92" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated"><strong class="ig hi"> R </strong> (recency):它存储相对于数据集中最后一个日期，客户最后一次购买的天数。它只是查找特定顾客从商店购买的最后一件商品。</li><li id="62de" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> F </strong>(频率):它是通过计算每个顾客被看到购物的唯一innovice日期来计算每个顾客购物的次数。</li><li id="96ec" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated"><strong class="ig hi"> M </strong>(货币):是每位顾客消费的总金额。</li></ul><p id="7343" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来计算RFM值。</p><p id="4f8d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最简单的方法是计算M的货币价值。我们将使用之前创建的Total_Amount列。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="b47e" class="kn ko hh kj b fi kp kq l kr ks">m = data.groupby('CustomerID')['Total_Amount'].sum()<br/>m = pd.DataFrame(m).reset_index()<br/>m.head()</span></pre><p id="1287" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看新数据框架的前几行，我们可以看到我们计算了每个客户的货币价值！</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kx"><img src="../Images/c82b14e532cdabe8da70f5f59d0c0da8.png" data-original-src="https://miro.medium.com/v2/resize:fit:440/format:webp/1*f-dxb5NidzEL7T1F90pOhQ.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="7c77" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们计算一下每位顾客从商店购买的次数。我们将使用CustomerID和InvoiceDate列。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="cc94" class="kn ko hh kj b fi kp kq l kr ks">f = data.groupby('CustomerID')['InvoiceNo'].count()<br/>f =f.reset_index()<br/>f.columns = ['CustomerID','Frequency']<br/>f.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ky"><img src="../Images/2617d5fba33ee1eebf036196b4fc8c67.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*OkYlnUIEzyerqg85MttAPA.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="80ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们能够计算每个顾客从商店购买的总次数。</p><p id="4db4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，让我们计算每个客户的最近价值。</p><p id="fc93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们需要找到数据集中最后一次购买的时间。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="3170" class="kn ko hh kj b fi kp kq l kr ks">data['InvoiceDate'] = pd.to_datetime(data['InvoiceDate'],<br/>                                     format = '%d-%m-%Y %H:%M')<br/>last_day = max(data['InvoiceDate'])</span></pre><p id="6596" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最初，我们将给定InvoiceDate的格式和数据类型更改为指定的格式，然后计算最后的购买日期。</p><p id="21f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了找出每个顾客的最后购买日期</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="18f9" class="kn ko hh kj b fi kp kq l kr ks">data['difference'] = last_day - data['InvoiceDate']<br/>data.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es kz"><img src="../Images/3f8d5c587081d9f1a7e89d71722ffc3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6P71iu-QEIRLUotqpECwTA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="30aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们只需要天数，而不是时间和天数，只需要整数。这样，以后就可以更容易地根据每个客户进行分组。</p><p id="6c03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们可以用一个独立的函数来给出整数。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="8da2" class="kn ko hh kj b fi kp kq l kr ks">def get_days(x):<br/>    y = str(x).split()[0]<br/>    return int(y)</span><span id="8d15" class="kn ko hh kj b fi kt kq l kr ks">data['difference'] = data['difference'].apply(get_days)</span></pre><p id="41f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可以使用CustomerId和difference列对每个客户进行分组。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="115a" class="kn ko hh kj b fi kp kq l kr ks">r = data.groupby('CustomerID')['difference'].min()<br/>r = r.reset_index()<br/>r.columns = ['CustomerID','Recency']<br/>r.head()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es la"><img src="../Images/bf23fab3514c5da6af7d13b005d933d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*IjPn-xkk3t5dc934XvFcFw.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="4f65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经为最近(r)、频率(f)和货币(m)创建了三个独立的数据框架。让我们将这些数据帧分组。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="fc9c" class="kn ko hh kj b fi kp kq l kr ks">grouped_df = pd.merge(m, f, on = 'CustomerID',how = 'inner')<br/>RFM_df = pd.merge(grouped_df, r, on ='CustomerID', how = 'inner')<br/>RFM_df.columns = ['CustomerID','Monetary','Frequency','Recency']</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lb"><img src="../Images/6b47f9d3ce04b5b7d6edb5556424dc16.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*_Fhqgw-VfJZQlaDRU0SuXQ.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="fe7b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们正在做内部连接，以分组3个数据帧。</p><p id="2407" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于K-means聚类访问每个数据点以形成一个聚类，因此离群值会影响检测聚类的过程，所以首先让我们丢弃离群值，以便我们可以在以后获得更好的聚类。</p><p id="bd61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们来看每一列的箱线图。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="8834" class="kn ko hh kj b fi kp kq l kr ks">plt.boxplot(RFM_df['Monetary'])<br/>plt.xlabel('Monetary')<br/>plt.show()</span></pre><div class="jf jg jh ji fd ab cb"><figure class="lc jj ld le lf lg lh paragraph-image"><img src="../Images/1a51658102719951a9299e2077c66818.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*qou5nL9bNkemK-tpz9YZIg.jpeg"/></figure><figure class="lc jj li le lf lg lh paragraph-image"><img src="../Images/8d1a5e1fd54d0e90abe2061afb3866fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*fdbQxgPI89SaixOtd1l-uw.jpeg"/></figure><figure class="lc jj lj le lf lg lh paragraph-image"><img src="../Images/f3461aa6fa01f023dde18b241cd5e59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:566/format:webp/1*e-trAdZB5qrqB4GD7yKqFQ.jpeg"/></figure></div><p id="4552" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为每个变量都是离群值，所以让我们去掉它们。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="f84f" class="kn ko hh kj b fi kp kq l kr ks">outlier_vars = ['Monetary','Recency','Frequency']</span><span id="0260" class="kn ko hh kj b fi kt kq l kr ks">for column in outlier_vars:<br/>    <br/>    lower_quartile = RFM_df[column].quantile(0.25)<br/>    upper_quartile = RFM_df[column].quantile(0.75)<br/>    iqr = upper_quartile - lower_quartile<br/>    iqr_extended = iqr * 1.5<br/>    min_border = lower_quartile - iqr_extended<br/>    max_border = upper_quartile + iqr_extended<br/>    <br/>    outliers = RFM_df[(RFM_df[column] &lt; min_border) |     (RFM_df[column] &gt; max_border)].index<br/>    print(f"{len(outliers)} outliers detected in column {column}")<br/>    <br/>    RFM_df.drop(outliers, inplace = True)</span></pre><p id="08c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">标准化</strong></p><p id="ee5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们需要标准化数据，因为有更大的值可以支配定义的集群。</p><p id="6fab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于聚类算法基于数据点之间的距离，因此我们需要调整数据，使其符合均值为0、标准差为1的正态分布。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="9cbe" class="kn ko hh kj b fi kp kq l kr ks">scaled_df = RFM_df[['Monetary','Frequency','Recency']]<br/>scale_standardisation = StandardScaler()</span><span id="2957" class="kn ko hh kj b fi kt kq l kr ks">rfm_df_scaled = scale_standardisation.fit_transform(scaled_df)</span><span id="d58c" class="kn ko hh kj b fi kt kq l kr ks">rfm_df_scaled = pd.DataFrame(rfm_df_scaled)<br/>rfm_df_scaled.columns = ['monetary','frequency','recency']</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lk"><img src="../Images/7dd910394fbcd8f2c20c89a1670ce320.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*SDu0rlzYYsMeYYphwEUEWA.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="17bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">K-均值聚类</strong></p><p id="f12f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我们用<a class="ae jd" href="https://en.wikipedia.org/wiki/Elbow_method_(clustering)#:~:text=In%20cluster%20analysis%2C%20the%20elbow,number%20of%20clusters%20to%20use." rel="noopener ugc nofollow" target="_blank">肘法</a>找出星团的数量。肘方法或者由误差平方和(sse)使用，或者由误差聚类和(wcss)使用。我们将使用<a class="ae jd" href="https://www.linkedin.com/pulse/finding-optimal-number-clusters-k-means-through-elbow-asanka-perera/" rel="noopener ugc nofollow" target="_blank"> WCSS </a>来寻找最佳的集群数量。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="c909" class="kn ko hh kj b fi kp kq l kr ks">k_values = list(range(1,10))<br/>wcss_list = []</span><span id="106d" class="kn ko hh kj b fi kt kq l kr ks">for k in k_values:<br/>    kmeans = KMeans(n_clusters = k)<br/>    kmeans.fit_transform(rfm_df_scaled)<br/>    wcss_list.append(kmeans.inertia_)</span><span id="ec83" class="kn ko hh kj b fi kt kq l kr ks">plt.plot(k_values,wcss_list)<br/>plt.xlabel("k")<br/>plt.ylabel("WCSS Score")<br/>plt.title("Within Cluster Sum of Squares - by k")<br/>plt.tight_layout()<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ll"><img src="../Images/6621ce6ae4d01e48780a72d4646ae944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*cVSKQsEr0OA_X2eVpCNpGA.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="698b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上图我们可以清楚的看到，当x轴在3上时，graph明显有一个弯头。因此，我们将选择集群或客户群的数量为3。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="ef0e" class="kn ko hh kj b fi kp kq l kr ks">kmeans = KMeans(n_clusters = 3)<br/>kmeans.fit(rfm_df_scaled)</span></pre><p id="5a65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们来想象一下星团。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="ad28" class="kn ko hh kj b fi kp kq l kr ks">clusters = kmeans.labels_</span><span id="1747" class="kn ko hh kj b fi kt kq l kr ks">RFM = rfm_df_scaled <br/>RFM['labels'] = clusters</span><span id="42a6" class="kn ko hh kj b fi kt kq l kr ks">fig = plt.figure(figsize=(21,10))<br/>ax = fig.add_subplot(111, projection='3d')<br/>ax.scatter(RFM["monetary"][RFM.labels == 0], RFM["frequency"][RFM.labels == 0], RFM["recency"][RFM.labels == 0], c='blue', s=60)<br/>ax.scatter(RFM["monetary"][RFM.labels == 1],RFM["frequency"][RFM.labels == 1], RFM["recency"][RFM.labels == 1], c='red', s=60)<br/>ax.scatter(RFM["monetary"][RFM.labels == 2], RFM["frequency"][RFM.labels == 2], RFM["recency"][RFM.labels == 2], c='yellow', s=60)<br/>ax.view_init(30, 185)<br/>plt.show()</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lm"><img src="../Images/74b70e7ebf5930d73079c95e7bbdffb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*zCUW8q1xKLQBhhZuWf0Dog.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="18ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看RFM数据框架的分析。</p><pre class="jf jg jh ji fd ki kj kk kl aw km bi"><span id="1474" class="kn ko hh kj b fi kp kq l kr ks">rfm_df['Clusters'] = k_model.labels_</span><span id="06ad" class="kn ko hh kj b fi kt kq l kr ks">analysis = rfm_df.groupby('Clusters').agg({<br/>    'Recency':['mean','max','min'],<br/>    'Frequency':['mean','max','min'],<br/>    'Monetary':['mean','max','min','count']})</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es ln"><img src="../Images/3a8b52d7be63d6c4326ed0c5b3e9f3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OPNobZAhcjNx29-0no_D0A.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">作者图片</figcaption></figure><p id="f502" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的分析，我们可以解释如下。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/fda3ab78a03e54f28c2b3e7eff05e903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VdpuNSnI22Xp9PFbaE6M_A.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">解读RFM分析</figcaption></figure><p id="b6ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们可以向在线商店推荐聚类“0”中的客户。</p><p id="d923" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">进一步的工作…</p><ul class=""><li id="b4f7" class="ju jv hh ig b ih ii il im ip jw it jx ix jy jb jz ka kb kc bi translated">您可以通过使用RFM评分(1-5)来扩展这种分析，然后对客户进行分组。一定要看看这篇<a class="ae jd" rel="noopener" href="/@jackiekhuu.work/customer-segmentation-rfm-analysis-8007d62101cc">文章</a>。</li><li id="3f82" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">由于Kmeans对异常值很敏感，您可以使用对异常值很健壮的<a class="ae jd" rel="noopener" href="/mlearning-ai/demonstrating-customers-segmentation-with-dbscan-clustering-using-python-8a2ba0db2a2e"> DBSCAN </a>集群来尝试相同的数据。</li><li id="0c9d" class="ju jv hh ig b ih kd il ke ip kf it kg ix kh jb jz ka kb kc bi translated">您可以使用country列进一步分析，找出大多数客户来自哪里。</li></ul></div></div>    
</body>
</html>