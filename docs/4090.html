<html>
<head>
<title>R data.table Joins</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">r数据表连接</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/r-data-table-joins-48f00b46ce29?source=collection_archive---------0-----------------------#2021-08-26">https://medium.com/analytics-vidhya/r-data-table-joins-48f00b46ce29?source=collection_archive---------0-----------------------#2021-08-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a77fe3f9877a61f3a1311bc497e278e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IaIVFs7WhwCrumrq"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">照片由<a class="ae it" href="https://unsplash.com/@sammoqadam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Sam Moqadam </a>在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><h1 id="a571" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">介绍</h1><p id="dcec" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated"><code class="du kq kr ks kt b">Data.table</code>是古老的<code class="du kq kr ks kt b">data.frame</code>的强大现代更新。在引擎盖下，该包已经过调整，以惊人的速度和最小的内存使用量与一个圆滑和备用的语法。对于初学者来说，简洁的语法是一种福气，但对于新用户来说，这可能是一个障碍。</p><p id="98f0" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">对我来说，其中一个领域是连接多个<code class="du kq kr ks kt b">data.table</code>。这个包的设计使得<code class="du kq kr ks kt b">data.table</code>特别擅长连接，所以我发现努力掌握语法是非常值得的。据我所知，我找不到任何资源可以将我想要的所有信息收集到一个地方。这是我希望能找到的文件。我希望它能帮助你掌握这个最强大的R包的强大特性。</p><h1 id="3f16" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">入门指南</h1><p id="113a" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">要快速了解<code class="du kq kr ks kt b">data.table</code>包本身，你真的没有比阅读该项目的官方主页<a class="ae it" href="https://rdatatable.gitlab.io/data.table/index.html" rel="noopener ugc nofollow" target="_blank">上的介绍性简介更好的了。</a></p><p id="494a" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在这里，我将对从单个<code class="du kq kr ks kt b">data.table</code>中读取和操作数据的基础知识做一个最简短的概述，供那些可能是软件包新手或者只是生疏的人使用。已经具备基本知识的读者应该跳到下一节。</p><p id="25d9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">正如您在阅读官方文档时将会看到的，<code class="du kq kr ks kt b">data.table</code>包的创建者鼓励用户考虑对单个表进行操作，就像您考虑查询关系数据库一样。<code class="du kq kr ks kt b">data.table</code>、<em class="kz"> DT </em>的逗号分隔字段可以映射到SQL查询的相应特性。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/7ca0cdbeb3871349b41755b97d3805ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*wwyy-bA_xCz8H1Rc8pzQBg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">作者图片</figcaption></figure><p id="9161" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">第一个字段<em class="kz"> i </em>，对表格数据行进行排序或筛选。第二个<br/>字段<em class="kz"> j </em>选择用于计算或显示的数据列，而最后一个<br/> <em class="kz"> by </em>字段起到<em class="kz"> group-by </em>的作用。</p><p id="bdf8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在继续讨论连接之前，连接的语法与这个查询语法不同，让我们构建一个单独的查询来练习所有这些类似SQL的子句。</p><p id="4898" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">首先，让我们创建一些要处理的数据。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="24cd" class="lj iv hh kt b fi lk ll l lm ln"># Create a data.table to work with<br/>library(data.table)</span><span id="7fbc" class="lj iv hh kt b fi lo ll l lm ln">set.seed(42)<br/>x &lt;- data.table( <br/>  id = sample(LETTERS[1:3], 10, replace = TRUE),<br/>  value = sample(1:5, 10, replace = TRUE)<br/>)</span><span id="d08f" class="lj iv hh kt b fi lo ll l lm ln">x</span><span id="34e4" class="lj iv hh kt b fi lo ll l lm ln">##         id value<br/>##     &lt;char&gt; &lt;int&gt;<br/>##  1:      A     4<br/>##  2:      A     1<br/>##  3:      A     5<br/>##  4:      A     4<br/>##  5:      B     2<br/>##  6:      B     2<br/>##  7:      B     3<br/>##  8:      A     1<br/>##  9:      C     1<br/>## 10:      C     3</span></pre><p id="e9fe" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">为了说明一个使用所有类似SQL的主要操作的查询，让我们找到(<em class="kz"> select </em>)所有(<em class="kz">where</em>)B和C的值字段的平均值，用于每个<br/> ( <em class="kz"> group by </em> ) id。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="c49f" class="lj iv hh kt b fi lk ll l lm ln">x[ id &gt; 'A', .(mean_value = mean(value)), by = .(id)]</span><span id="5d4a" class="lj iv hh kt b fi lo ll l lm ln">##        id mean_value<br/>##    &lt;char&gt;      &lt;num&gt;<br/>## 1:      B   2.333333<br/>## 2:      C   2.000000</span></pre><p id="d147" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">我们过滤了<em class="kz"> x </em>的行，只给出了<em class="kz"> id </em>大于A的行，并且<br/>将这些行传递给选择步骤。在这里，我们取<em class="kz">值</em> <br/>字段的平均值，按<em class="kz"> id </em>字段分组，并将计算值命名为<br/> <em class="kz"> mean_value </em>。</p><p id="d4b8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">这是查询一个<code class="du kq kr ks kt b">data.table</code>的基本逻辑和语法的(超级压缩)演练。稍后，当我们对将要生成的合并的<code class="du kq kr ks kt b">data.table</code>执行一些基本操作时，我们将使用一些查询逻辑。如果这一部分的一些材料被你忽略了，你不应该感到难过。我只是试图为您提供一些必要的基本知识，让您能够理解本文的其余部分，而不会让那些想跳到表连接的读者感到厌烦。如果你觉得这一部分很难理解，那么这个包的官方介绍会让你很快上手。</p><h1 id="94dc" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">简单等值联接</h1><p id="d6a3" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">为了演示基于表之间变量相等(或其<br/>否定)的表之间的连接，让我们创建两个数据表来<br/>处理。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="9729" class="lj iv hh kt b fi lk ll l lm ln">set.seed(42)</span><span id="a7a4" class="lj iv hh kt b fi lo ll l lm ln">big &lt;- data.table( <br/>  id = LETTERS[2:11],<br/>  a = sample(101:105, 10, replace = TRUE),<br/>  b = sample(200:300, 10)<br/>)</span><span id="d781" class="lj iv hh kt b fi lo ll l lm ln">small &lt;- data.table(<br/>  id = LETTERS[1:5],<br/>  y = sample(1:5, 5, replace = TRUE),<br/>  z = sample(10:20, 5) <br/>)</span><span id="0b97" class="lj iv hh kt b fi lo ll l lm ln">big</span><span id="5a7b" class="lj iv hh kt b fi lo ll l lm ln">##         id     a     b<br/>##     &lt;char&gt; &lt;int&gt; &lt;int&gt;<br/>##  1:      B   101   288<br/>##  2:      C   105   236<br/>##  3:      D   101   219<br/>##  4:      E   101   225<br/>##  5:      F   102   202<br/>##  6:      G   104   240<br/>##  7:      H   102   300<br/>##  8:      I   102   226<br/>##  9:      J   101   235<br/>## 10:      K   104   204</span><span id="288e" class="lj iv hh kt b fi lo ll l lm ln">small</span><span id="a505" class="lj iv hh kt b fi lo ll l lm ln">##        id     y     z<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      A     4    10<br/>## 2:      B     2    19<br/>## 3:      C     4    17<br/>## 4:      D     3    15<br/>## 5:      E     2    12</span></pre><p id="b52a" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">我们将从一个带有默认参数的非常简单的连接开始。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="5cc2" class="lj iv hh kt b fi lk ll l lm ln"># Right outer join<br/>big[small, on = .(id)]</span><span id="df25" class="lj iv hh kt b fi lo ll l lm ln">##        id     a     b     y     z<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      A    NA    NA     4    10<br/>## 2:      B   101   288     2    19<br/>## 3:      C   105   236     4    17<br/>## 4:      D   101   219     3    15<br/>## 5:      E   101   225     2    12</span></pre><p id="b609" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">我们通过将<em class="kz">小</em>放入<em class="kz">大</em>的第一个<br/>槽中，并告诉<code class="du kq kr ks kt b">data.table</code>用关键字<code class="du kq kr ks kt b">on</code>连接哪个字段，从而连接了<em class="kz">大</em>和<em class="kz">小</em>表格。</p><p id="5f54" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">如果你习惯了<code class="du kq kr ks kt b">merge.data.frame()</code>的默认行为，这个加入的结果可能会让你大吃一惊。默认情况下，用这个<strong class="ju hi"> X[Y] </strong>语法连接<code class="du kq kr ks kt b">data.table</code> s会产生一个<strong class="ju hi">右外连接</strong>，其中<em class="kz">大</em>作为左表，而<em class="kz">小</em>作为右表。这里，<em class="kz"> small </em>中带有<em class="kz"> id </em> == 'A '的行出现在结果集中。由于在<em class="kz">大</em>中没有相应的记录，因此该<br/>记录的字段显示为<code class="du kq kr ks kt b">NA</code>。此时，唯一需要注意的是，结果表中的<br/>列反映了过程调用中表从左到右的顺序(即<em class="kz">即</em>，<em class="kz">大</em>列后面跟着<em class="kz">小</em>)。</p><p id="afc5" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">如果我们改变要连接的表的命名顺序，结果连接的性质可能会更加明显。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="b7ef" class="lj iv hh kt b fi lk ll l lm ln"># Right outer join<br/>small[big, on = .(id)]</span><span id="4583" class="lj iv hh kt b fi lo ll l lm ln">##         id     y     z     a     b<br/>##     &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;<br/>##  1:      B     2    19   101   288<br/>##  2:      C     4    17   105   236<br/>##  3:      D     3    15   101   219<br/>##  4:      E     2    12   101   225<br/>##  5:      F    NA    NA   102   202<br/>##  6:      G    NA    NA   104   240<br/>##  7:      H    NA    NA   102   300<br/>##  8:      I    NA    NA   102   226<br/>##  9:      J    NA    NA   101   235<br/>## 10:      K    NA    NA   104   204</span></pre><p id="4e70" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">正如我们已经看到的，在这个<strong class="ju hi">left _ table[right _ table]</strong>语法中，默认情况下，所有连接都是右外连接。我们需要设置参数<code class="du kq kr ks kt b">nomatch</code>来改变这种行为。要获得一个<strong class="ju hi">内部连接</strong>，您需要将<code class="du kq kr ks kt b">nomatch</code>参数设置为NULL或0。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="4d43" class="lj iv hh kt b fi lk ll l lm ln"># Inner join<br/>small[big, on = .(id), <strong class="kt hi">nomatch = NULL</strong>]</span><span id="3e85" class="lj iv hh kt b fi lo ll l lm ln">##        id     y     z     a     b<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      B     2    19   101   288<br/>## 2:      C     4    17   105   236<br/>## 3:      D     3    15   101   219<br/>## 4:      E     2    12   101   225</span></pre><p id="6321" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">内部连接是调用<code class="du kq kr ks kt b">merge.data.frame()</code>的默认结果。为了兼容，默认情况下，<code class="du kq kr ks kt b">merge.data.table()</code>也执行内部连接。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="afca" class="lj iv hh kt b fi lk ll l lm ln"># X[Y, nomatch = NULL] == merge(X,Y)<br/>all(small[big, on = .(id), nomatch = NULL] == merge(small, big))</span><span id="163e" class="lj iv hh kt b fi lo ll l lm ln">## [1] TRUE</span></pre><p id="cfc8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">既然<code class="du kq kr ks kt b">data.table</code>已经实现了自己的<code class="du kq kr ks kt b">merge()</code>函数，你可能会问自己为什么要放弃熟悉的<code class="du kq kr ks kt b">merge()</code>来使用这种更简单的语法。这是个很好的问题。一般来说，非合并<strong class="ju hi"> X[Y] </strong>语法是首选的、更像<code class="du kq kr ks kt b">data.table</code>的连接方式。原因是<code class="du kq kr ks kt b">data.table</code>自动询问<em class="kz"> j </em>字段，以检测完成<em class="kz"> j </em>中指定的计算所需的最小列集合。另一方面，使用<code class="du kq kr ks kt b">merge()</code>要么合并RHS表中的所有列，不管它们是否需要(浪费)，要么要求用户手动将RHS表中的列减少到最少的必要列(冗长且不必要)。</p><p id="e6e3" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">因此，例如，下面的连接/查询只合并来自<em class="kz"> big </em>的列<em class="kz"> a </em>，因为<em class="kz"> a </em>是RHS表中后续计算所需的唯一列。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="981b" class="lj iv hh kt b fi lk ll l lm ln"># data.table takes care of minimizing the number of <br/># joined columns<br/>small[big, on = .(id), .('a + z' = a + z)]</span><span id="a685" class="lj iv hh kt b fi lo ll l lm ln">##     a + z<br/>##     &lt;int&gt;<br/>##  1:   120<br/>##  2:   122<br/>##  3:   116<br/>##  4:   113<br/>##  5:    NA<br/>##  6:    NA<br/>##  7:    NA<br/>##  8:    NA<br/>##  9:    NA<br/>## 10:    NA</span></pre><p id="7d5d" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">显然，对于这个玩具示例来说，效率增益是最小的，但是<code class="du kq kr ks kt b">data.table</code>包是关于高效处理大型数据集的，这种优化可能意味着是否能够在内存中运行分析。</p><p id="a274" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">有两种所谓的连接，即<strong class="ju hi">反连接</strong>和<strong class="ju hi">半连接</strong>，它们并不真正从两个表中返回列的组合。只返回<em class="kz">大</em>中与<em class="kz">小</em>中的<em class="kz"> id </em>不匹配的行很简单。要获得这种反连接行为，只需对RHS表求反即可。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="512a" class="lj iv hh kt b fi lk ll l lm ln"># Anti-join <br/># (return rows of big with no match in small)<br/>big[!small, on = .(id)]</span><span id="45a0" class="lj iv hh kt b fi lo ll l lm ln">##        id     a     b<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      F   102   202<br/>## 2:      G   104   240<br/>## 3:      H   102   300<br/>## 4:      I   102   226<br/>## 5:      J   101   235<br/>## 6:      K   104   204</span></pre><p id="83cc" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">半连接有点像反反连接。它只返回LHS表中与RHS表匹配的行。这样做的语法有点笨拙，但是可以如下所示获得与<em class="kz">小</em>中的<em class="kz"> id </em> s匹配的<em class="kz">大</em>的元素。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="790e" class="lj iv hh kt b fi lk ll l lm ln"># Semi-join <br/># (return only rows of big that have a <br/># match in small)<br/>big[na.omit(big[small, on = .(id), which=TRUE])]</span><span id="6828" class="lj iv hh kt b fi lo ll l lm ln">##        id     a     b<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      B   101   288<br/>## 2:      C   105   236<br/>## 3:      D   101   219<br/>## 4:      E   101   225</span></pre><p id="0c9c" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated"><code class="du kq kr ks kt b">which</code>参数只是指示<code class="du kq kr ks kt b">data.table</code>返回<em class="kz">大</em>中与<em class="kz">小</em>匹配的行的索引，返回<code class="du kq kr ks kt b">NA</code>中与<em class="kz">大<em class="kz">小</em>不匹配的行的索引。</em>然后，我们将这些行索引减去<code class="du kq kr ks kt b">NA</code>值，输入到<em class="kz"> big </em>的外部查询的<em class="kz"> i </em>字段中。</p><p id="5beb" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">最后，如果想连接两个表中的所有可用数据，该怎么做呢？一个聪明的想法是用X[Y] 语法实现<strong class="ju hi">全外部</strong>连接，这个想法来自于<a class="ae it" href="https://stackoverflow.com/questions/12773822/why-does-xy-join-of-data-tables-not-allow-a-full-outer-join-or-a-left-join?rq=1&amp;newreg=c55095bfee4e4d67a6f52576549c939b" rel="noopener ugc nofollow" target="_blank">这个</a>经典的Stackoverflow交换。</p><p id="9fe9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">实现Stackoverflow的想法需要我们稍微绕道介绍一下<strong class="ju hi">键</strong>的想法。到目前为止，我们已经用<code class="du kq kr ks kt b">on</code>参数指定了每次加入的变量。我们可以通过将id<em class="kz">设置为两个表中的键，使其成为所有后续连接中的隐式连接变量。这使得连接速度非常快，代价是变量的前期引用排序非常小。它还简化了基于键选择行的语法。让我们先来看看这个特性。</em></p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="de71" class="lj iv hh kt b fi lk ll l lm ln">setkey(small, id)<br/>setkey(big, id)</span><span id="f371" class="lj iv hh kt b fi lo ll l lm ln"># With keys set, we don't need to specify <br/># columns to join on<br/>big[c('A','C', 'E' )]</span><span id="3390" class="lj iv hh kt b fi lo ll l lm ln">##        id     a     b<br/>##    &lt;char&gt; &lt;int&gt; &lt;int&gt;<br/>## 1:      A    NA    NA<br/>## 2:      C   105   236<br/>## 3:      E   101   225</span></pre><p id="56b9" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">上面，<code class="du kq kr ks kt b">data.table</code>“知道”我们想要对应于<em class="kz"> id </em> s A、C和e的<em class="kz"> big </em>的行。这种类型的行索引在下面的全外连接中起作用。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="1e57" class="lj iv hh kt b fi lk ll l lm ln"># Full outer join<br/>unique_ids = unique(c(big[, id], small[, id]))<br/>big[small[unique_ids]]</span><span id="b7de" class="lj iv hh kt b fi lo ll l lm ln">##         id     a     b     y     z<br/>##     &lt;char&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;<br/>##  1:      B   101   288     2    19<br/>##  2:      C   105   236     4    17<br/>##  3:      D   101   219     3    15<br/>##  4:      E   101   225     2    12<br/>##  5:      F   102   202    NA    NA<br/>##  6:      G   104   240    NA    NA<br/>##  7:      H   102   300    NA    NA<br/>##  8:      I   102   226    NA    NA<br/>##  9:      J   101   235    NA    NA<br/>## 10:      K   104   204    NA    NA<br/>## 11:      A    NA    NA     4    10</span></pre><p id="c86c" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">显然，无论<em class="kz"> big </em>是LHS表还是RHS表，都只会在我们执行完全外部连接时影响连接表中列的顺序。</p><p id="46c4" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在我们离开这一部分之前，让我们明确地演示一个<strong class="ju hi">自连接</strong>，一个表对它自己的连接来实现一些转换。我们在本教程中创建的第一个<code class="du kq kr ks kt b">data.table</code>，<em class="kz"> x </em>，在<em class="kz"> id </em>字段中有重复的值。假设我们只想挑选出每个<em class="kz"> id </em>值第一次出现的记录。这可以通过将<code class="du kq kr ks kt b">mult</code>(针对多个匹配)参数设置为‘first’来实现。<code class="du kq kr ks kt b">mult</code>的其他合法值为‘all’(默认值)和‘last’。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="8584" class="lj iv hh kt b fi lk ll l lm ln"># Self-join<br/>setkey(x, id)<br/>x[unique(id), mult = 'first']</span><span id="dd1d" class="lj iv hh kt b fi lo ll l lm ln">##        id value<br/>##    &lt;char&gt; &lt;int&gt;<br/>## 1:      A     4<br/>## 2:      B     2<br/>## 3:      C     1</span></pre><p id="ecfd" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">为了说明这是如何做到的，也因为出于教学目的，我更喜欢<code class="du kq kr ks kt b">on </code>语法的明确性，所以我将从这些表中删除这些键。不过，在真正的研究中，我几乎总是会使用按键。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="34eb" class="lj iv hh kt b fi lk ll l lm ln">setkey(x, NULL)<br/>setkey(small, NULL)<br/>setkey(big, NULL)</span><span id="cc64" class="lj iv hh kt b fi lo ll l lm ln"># Now when we try to access rows as we did when<br/>#  id was a key, we get an error ...<br/>big[c('A','C', 'E' )]</span><span id="317b" class="lj iv hh kt b fi lo ll l lm ln">## Error in `[.data.table`(big, c("A", "C", "E")): When i is a data.table (or character vector), the columns to join by must be specified using 'on=' argument (see ?data.table), by keying x (i.e. sorted, and, marked as sorted, see ?setkey), or by sharing column names between x and i (i.e., a natural join). Keyed joins might have further speed benefits on very large data due to x being sorted in RAM.</span></pre><p id="b25f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在进入下一部分之前，上面这个真正精心制作的错误消息值得您的尊敬。</p><h1 id="5fd1" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">非对等连接</h1><p id="3a90" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">到目前为止，我们看到的所有连接都涉及到连接列之间的相等性(或者相等性的否定)。基于不等式的连接也受<code class="du kq kr ks kt b">data.table</code>的本地支持。</p><p id="d2b8" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">让我们开始探索这个强大的功能，将红袜队2021年9月的主场时间表加载到一个带有<code class="du kq kr ks kt b">fread()</code>的<code class="du kq kr ks kt b">data.table</code>中，这个包是一个异常快速、异常智能的文件阅读器。在下面的代码片段中，花点时间来欣赏一下<code class="du kq kr ks kt b">fread()</code>的数据类型识别。每次都让我会心一笑。😄</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="f26e" class="lj iv hh kt b fi lk ll l lm ln"># Red Sox home schedule<br/>fenway &lt;- fread(<br/>    "Visitor, Start, End<br/>    Cleveland, 2021-09-03, 2021-09-05<br/>    Tampa Bay, 2021-09-06, 2021-09-08<br/>    Baltimore, 2021-09-17, 2021-09-19<br/>    NY Mets, 2021-09-21, 2021-09-22<br/>    NY Yankees, 2021-09-24, 2021-09-26")</span><span id="1185" class="lj iv hh kt b fi lo ll l lm ln">fenway</span><span id="9409" class="lj iv hh kt b fi lo ll l lm ln">##       Visitor      Start        End<br/>##        &lt;char&gt;     &lt;IDat&gt;     &lt;IDat&gt;<br/>## 1:  Cleveland 2021-09-03 2021-09-05<br/>## 2:  Tampa Bay 2021-09-06 2021-09-08<br/>## 3:  Baltimore 2021-09-17 2021-09-19<br/>## 4:    NY Mets 2021-09-21 2021-09-22<br/>## 5: NY Yankees 2021-09-24 2021-09-26</span></pre><p id="e997" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">让我们用2021年9月的所有日期生成一个<code class="du kq kr ks kt b">data.table</code>。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="a2b5" class="lj iv hh kt b fi lk ll l lm ln"># All the days of September 2021<br/>september &lt;- <br/>   data.table(date = seq(as.Date('2021-09-01'), <br/>   as.Date('2021-09-30'), 'days'))</span><span id="fded" class="lj iv hh kt b fi lo ll l lm ln">head(september)</span><span id="399d" class="lj iv hh kt b fi lo ll l lm ln">##          date<br/>##        &lt;Date&gt;<br/>## 1: 2021-09-01<br/>## 2: 2021-09-02<br/>## 3: 2021-09-03<br/>## 4: 2021-09-04<br/>## 5: 2021-09-05<br/>## 6: 2021-09-06</span></pre><p id="9766" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">通过使用每个主场的开始和结束日期的范围将<em class="kz"> fenway </em>表连接到每月的日期，并执行一点清理，我们可以获得红袜主场比赛的完整列表！</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="1c48" class="lj iv hh kt b fi lk ll l lm ln"># The dates of all Red Sox home games in September 2021<br/>home_games &lt;- <br/>  fenway[september, on = .(Start &lt;= date, End &gt;= date), <br/>  .(Visitor, Date = Start)][!is.na(Visitor)]</span><span id="d76d" class="lj iv hh kt b fi lo ll l lm ln">home_games</span><span id="904f" class="lj iv hh kt b fi lo ll l lm ln">##        Visitor       Date<br/>##         &lt;char&gt;     &lt;Date&gt;<br/>##  1:  Cleveland 2021-09-03<br/>##  2:  Cleveland 2021-09-04<br/>##  3:  Cleveland 2021-09-05<br/>##  4:  Tampa Bay 2021-09-06<br/>##  5:  Tampa Bay 2021-09-07<br/>##  6:  Tampa Bay 2021-09-08<br/>##  7:  Baltimore 2021-09-17<br/>##  8:  Baltimore 2021-09-18<br/>##  9:  Baltimore 2021-09-19<br/>## 10:    NY Mets 2021-09-21<br/>## 11:    NY Mets 2021-09-22<br/>## 12: NY Yankees 2021-09-24<br/>## 13: NY Yankees 2021-09-25<br/>## 14: NY Yankees 2021-09-26</span></pre><p id="d291" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">对于那些以前可能没有见过它的人，我应该注意到最后两个方括号(<code class="du kq kr ks kt b">[!is.na(Visitor)]</code>)之间的代码段是一种操作链形式，它允许我们在前面的操作中细化结果，这里删除了<em class="kz"> Visitor </em>字段为空的行。</p><p id="7677" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">在继续讨论滚动连接之前，我需要注意一个很大的语法问题:不等式(或等式，就此而言)中各项的顺序非常重要。这种逻辑上等价的——在我看来，更直观的——执行操作的尝试将会失败。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="a364" class="lj iv hh kt b fi lk ll l lm ln"># The dates of all Red Sox home games in September 2021<br/>fenway[september, on = .(date &gt;= Start, date &lt;= End), <br/>       .(Visitor, Date = Start)][!is.na(Visitor)]</span><span id="a4fc" class="lj iv hh kt b fi lo ll l lm ln">## Error in colnamesInt(x, names(on), check_dups = FALSE): argument specifying columns specify non existing column(s): cols[1]='date'</span></pre><p id="98c7" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">好了，<em class="kz">错误消息</em>有点难以理解，但是join语句中关系左侧必须对应于LHS表，反之亦然。<em class="kz">开始</em>是一个LHS字段，<em class="kz">日期</em>是一个RHS字段，所以排序必须是<em class="kz">开始</em> &lt;操作符&gt; <em class="kz">日期</em>，例如，仔细想想，这种行为是完全合理的。这两个表可能有名称冲突的列，这种术语排序方式便于消除歧义。</p><h1 id="1efc" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">滚动连接</h1><p id="cf40" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">一个<strong class="ju hi">滚动连接</strong>在表之间匹配，向前结转或向前看下一个匹配，直到匹配条件发生变化。让我们继续使用我们的<em class="kz"> home_games </em>和<em class="kz"> september </em>表来看一个公认的人为例子。我们将建立一个9月份所有日期的列表，对于每个日期，我们将跟踪最后一次面对的主场对手。很难想象为什么这可能有用，但是它锻炼了功能。</p><p id="115b" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">提醒一下，两个表之间简单的右外连接会在Visitor字段中产生间隙，这些间隙是我在上一节中通过将<code class="du kq kr ks kt b">[!is.na(Visitor)]</code>添加到不等式连接的末尾而消除的。我们现在希望用最后填充的值来填补这些空白。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="a977" class="lj iv hh kt b fi lk ll l lm ln"># Without !is.na(Visitor)</span><span id="86a5" class="lj iv hh kt b fi lo ll l lm ln">home_games[september, on = .(Date == date)]</span><span id="a61f" class="lj iv hh kt b fi lo ll l lm ln">##        Visitor       Date<br/>##         &lt;char&gt;     &lt;Date&gt;<br/>##  1:       &lt;NA&gt; 2021-09-01<br/>##  2:       &lt;NA&gt; 2021-09-02<br/>##  3:  Cleveland 2021-09-03<br/>##  4:  Cleveland 2021-09-04<br/>##  5:  Cleveland 2021-09-05<br/>##  6:  Tampa Bay 2021-09-06<br/>##  7:  Tampa Bay 2021-09-07<br/>##  8:  Tampa Bay 2021-09-08<br/>##  9:       &lt;NA&gt; 2021-09-09<br/>## 10:       &lt;NA&gt; 2021-09-10<br/>## 11:       &lt;NA&gt; 2021-09-11<br/>## 12:       &lt;NA&gt; 2021-09-12<br/>## 13:       &lt;NA&gt; 2021-09-13<br/>## 14:       &lt;NA&gt; 2021-09-14<br/>## 15:       &lt;NA&gt; 2021-09-15<br/>## 16:       &lt;NA&gt; 2021-09-16<br/>## 17:  Baltimore 2021-09-17<br/>## 18:  Baltimore 2021-09-18<br/>## 19:  Baltimore 2021-09-19<br/>## 20:       &lt;NA&gt; 2021-09-20<br/>## 21:    NY Mets 2021-09-21<br/>## 22:    NY Mets 2021-09-22<br/>## 23:       &lt;NA&gt; 2021-09-23<br/>## 24: NY Yankees 2021-09-24<br/>## 25: NY Yankees 2021-09-25<br/>## 26: NY Yankees 2021-09-26<br/>## 27:       &lt;NA&gt; 2021-09-27<br/>## 28:       &lt;NA&gt; 2021-09-28<br/>## 29:       &lt;NA&gt; 2021-09-29<br/>## 30:       &lt;NA&gt; 2021-09-30<br/>##        Visitor       Date</span></pre><p id="7f37" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">我们只要在之前加入的基础上加上<code class="du kq kr ks kt b">roll = TRUE</code>就可以把上一个主场对手的名字发扬光大。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="adfb" class="lj iv hh kt b fi lk ll l lm ln"># Roll the name of the last home opponent forward</span><span id="7fdd" class="lj iv hh kt b fi lo ll l lm ln">home_games[september, <br/>           on = .(Date == date), <strong class="kt hi">roll = TRUE</strong>]</span><span id="6519" class="lj iv hh kt b fi lo ll l lm ln">##        Visitor       Date<br/>##         &lt;char&gt;     &lt;Date&gt;<br/>##  1:       &lt;NA&gt; 2021-09-01<br/>##  2:       &lt;NA&gt; 2021-09-02<br/>##  3:  Cleveland 2021-09-03<br/>##  4:  Cleveland 2021-09-04<br/>##  5:  Cleveland 2021-09-05<br/>##  6:  Tampa Bay 2021-09-06<br/>##  7:  Tampa Bay 2021-09-07<br/>##  8:  Tampa Bay 2021-09-08<br/>##  9:  Tampa Bay 2021-09-09<br/>## 10:  Tampa Bay 2021-09-10<br/>## 11:  Tampa Bay 2021-09-11<br/>## 12:  Tampa Bay 2021-09-12<br/>## 13:  Tampa Bay 2021-09-13<br/>## 14:  Tampa Bay 2021-09-14<br/>## 15:  Tampa Bay 2021-09-15<br/>## 16:  Tampa Bay 2021-09-16<br/>## 17:  Baltimore 2021-09-17<br/>## 18:  Baltimore 2021-09-18<br/>## 19:  Baltimore 2021-09-19<br/>## 20:  Baltimore 2021-09-20<br/>## 21:    NY Mets 2021-09-21<br/>## 22:    NY Mets 2021-09-22<br/>## 23:    NY Mets 2021-09-23<br/>## 24: NY Yankees 2021-09-24<br/>## 25: NY Yankees 2021-09-25<br/>## 26: NY Yankees 2021-09-26<br/>## 27: NY Yankees 2021-09-27<br/>## 28: NY Yankees 2021-09-28<br/>## 29: NY Yankees 2021-09-29<br/>## 30: NY Yankees 2021-09-30<br/>##        Visitor       Date</span></pre><p id="33b0" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">通过指定<code class="du kq kr ks kt b">roll = -Inf</code>可以反转辊的方向。</p><h1 id="ab0f" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">重叠范围连接</h1><p id="0a70" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">我们已经看到了带有范围形式数据的<code class="du kq kr ks kt b">data.table</code>。芬威球台按日期范围列出了红袜队的主场比赛。比方说，我们想在主场比赛中关注扬基队的对手。<code class="du kq kr ks kt b">data.table</code>包提供了<code class="du kq kr ks kt b">foverlaps()</code>函数来通过重叠范围连接表。(函数名中的‘f’代表快速。对于<code class="du kq kr ks kt b">fread()</code>、<code class="du kq kr ks kt b">fwrite()</code>以及这个包中几乎所有其他以f开头的函数也是如此。速度是这个包的游戏名称。)</p><p id="6ffd" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">让我们建立一个九月洋基队前几场比赛的表格。</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="1916" class="lj iv hh kt b fi lk ll l lm ln">yankees &lt;- fread(<br/>  "NYY Opponent, Start, End<br/>  Anaheim, 2021-09-01, 2021-09-01<br/>  Baltimore, 2021-09-03, 2021-09-05<br/>  Toronto, 2021-09-06, 2021-09-09"<br/>)</span><span id="01b7" class="lj iv hh kt b fi lo ll l lm ln">setkey(yankees, Start, End)</span></pre><p id="686f" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">通过重叠日期连接这两个表再简单不过了。(困难的是将输出格式化，以便在介质上良好打印，但这是另一个故事了。)</p><pre class="lb lc ld le fd lf kt lg lh aw li bi"><span id="3ced" class="lj iv hh kt b fi lk ll l lm ln">foverlaps(fenway, yankees)</span><span id="c403" class="lj iv hh kt b fi lo ll l lm ln">NYY Opponent  Start   End        Visitor    i.Start    i.End<br/>&lt;char&gt;     &lt;IDat&gt;     &lt;IDat&gt;     &lt;char&gt;     &lt;IDat&gt;     &lt;IDat&gt;<br/>Baltimore  2021-09-03 2021-09-05 Cleveland  2021-09-03 2021-09-05<br/>Toronto    2021-09-06 2021-09-09 Tampa Bay  2021-09-06 2021-09-08<br/>&lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       Baltimore  2021-09-17 2021-09-19<br/>&lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       NY Mets    2021-09-21 2021-09-22<br/>&lt;NA&gt;       &lt;NA&gt;       &lt;NA&gt;       NY Yankees 2021-09-24 2021-09-26</span></pre><h1 id="c7d9" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">结论</h1><p id="9d71" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">所以这就是我所知道的(或认为我知道的)关于加入<code class="du kq kr ks kt b">data.table</code> s的全部情况。</p><p id="c879" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">就像它之前的杰出前辈R的<code class="du kq kr ks kt b">data.frame</code>，<code class="du kq kr ks kt b">data.table</code>包激发了Python世界的模仿，所以我们在这里讨论的一些内容可能会对你的Python工作有所帮助。</p><p id="6308" class="pw-post-body-paragraph js jt hh ju b jv ku jx jy jz kv kb kc kd kw kf kg kh kx kj kk kl ky kn ko kp ha bi translated">不管是用R还是用Python，希望这篇教程有所帮助。</p></div></div>    
</body>
</html>