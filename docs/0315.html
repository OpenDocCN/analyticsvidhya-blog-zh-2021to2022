<html>
<head>
<title>Bisect Module in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的二分模块</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bisect-module-in-python-6b78f8c37beb?source=collection_archive---------2-----------------------#2021-01-12">https://medium.com/analytics-vidhya/bisect-module-in-python-6b78f8c37beb?source=collection_archive---------2-----------------------#2021-01-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d88143a7c43625af40162656aefb12e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SoMNKyog418XkUwdKxkB8g.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">作者:CodeWithHarry</figcaption></figure><div class=""/><p id="869b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前几天在提升自己Python技能的搜索中，我发现了用Python写的<strong class="iw hy"> <em class="js">二分模块</em> </strong>，其源代码不超过80行。</p><p id="580b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">基本上，这个模块实现了二分法来寻找在排序列表中添加给定元素的插入点。值得一提的是，作为参数传递给这些函数的列表必须按升序排序，否则这些函数不会出现任何错误，但结果将是意想不到的。</p><p id="ae6d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，是时候更详细地了解每个函数了！</p><h2 id="2e36" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">等分_左(a，x，lo=0，hi =无)</h2><p id="a047" class="pw-post-body-paragraph iu iv hx iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">该方法返回索引<strong class="iw hy"> <em class="js"> i </em> </strong>，其中必须插入值<strong class="iw hy"> <em class="js"> x </em> </strong>，这样列表<strong class="iw hy"> <em class="js"> a </em> </strong>保持有序。在<strong class="iw hy"> <em class="js"> x </em> </strong>值已经出现在列表中的情况下，索引<strong class="iw hy"> <em class="js"> i </em> </strong>将正好在已经存在的最左边的<strong class="iw hy"> <em class="js"> x </em> </strong>值之前。通过下面的例子，这一点将看得很清楚。</p><p id="a230" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">注意:<strong class="iw hy"> <em class="js">平分模块</em> </strong>预装了Python发行版。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">1-平分_left函数。</figcaption></figure><p id="772d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在上面的代码片段中定义了一个列表<strong class="iw hy"> <em class="js"> a </em> </strong>，并且需要知道必须在哪里插入索引<strong class="iw hy"> <em class="js"> x </em> </strong> value (7)以便<strong class="iw hy"><em class="js"/></strong>保持有序。当<strong class="iw hy"> <em class="js">等分_左</em> </strong>被调用时，其返回值为3，该值是<strong class="iw hy"> <em class="js"> x </em> </strong>必须插入的索引。</p><p id="b56d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">继续前面的代码片段，让我们通过调用对象列表的<strong class="iw hy"> <em class="js"> insert </em> </strong>方法，在列表<strong class="iw hy"><em class="js"/></strong>中插入<strong class="iw hy"> <em class="js"> x </em> </strong>值。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">1.1-二等分_左功能</figcaption></figure><p id="de7d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意<strong class="iw hy"> <em class="js"> x </em> </strong>值是如何插入到<strong class="iw hy"> <em class="js"> a </em> </strong>列表的索引3处的。在后面的章节中将会说明，这可以通过使用<strong class="iw hy"> <em class="js">二等分模块</em> </strong>提供的方法来轻松完成。</p><p id="5af2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在让我们看一个例子，其中<strong class="iw hy"> <em class="js"> x </em> </strong>值已经出现在列表中，此外还有到目前为止还没有提到的参数<strong class="iw hy"> <em class="js"> lo </em> </strong>和<strong class="iw hy"> <em class="js"> hi </em> </strong>的使用。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">2-插入x值。</figcaption></figure><p id="eee4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如前所述，<strong class="iw hy"> <em class="js">平分_左</em> </strong>方法返回的索引对应于列表中<strong class="iw hy"> <em class="js"> x </em> </strong>值(8)的第一个匹配项。<strong class="iw hy"> <em class="js"> lo </em> </strong>和<strong class="iw hy"> <em class="js"> hi </em> </strong>参数用于指示您要考虑的列表的起始和结束索引，当这些参数没有传递给函数时，整个列表被视为与前面的示例相同。看看下面的例子，这里使用了参数<strong class="iw hy"> <em class="js"> lo </em> </strong>和<strong class="iw hy"> <em class="js"> hi。</em> </strong></p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">3- x值已经存在</figcaption></figure><p id="8c51" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如<strong class="iw hy"> <em class="js"> lo </em> </strong>和<strong class="iw hy"> <em class="js"> hi </em> </strong>被传递给<strong class="iw hy"> <em class="js">平分_离开</em> </strong>方法列表考虑的将是<strong class="iw hy"><em class="js"/></strong>【2:7】<strong class="iw hy"><em class="js">【5，6，7，9，10】</em></strong>。<strong class="iw hy">平分_左</strong>在这个片上找到索引<strong class="iw hy"> <em class="js"> i </em> </strong>然后返回基于整个列表的el索引。</p><h2 id="9e5b" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">等分_右(a，x，lo=0，hi =无)</h2><p id="c584" class="pw-post-body-paragraph iu iv hx iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">此功能与<strong class="iw hy"> <em class="js">平分_左</em> </strong>功能相同，但如果<strong class="iw hy"><em class="js">×x</em></strong>值已经出现在<strong class="iw hy"> <em class="js"> a </em> </strong>列表中，则索引I将位于已经存在的最右边的<strong class="iw hy"> <em class="js"> x </em> </strong>值之后。让我们看一个例子。</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">四等分_右函数</figcaption></figure><p id="9cef" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">请注意，列表中最右边的<strong class="iw hy"> <em class="js"> x </em> </strong>值(4)位于索引4处，因此，紧随其后的索引将是5。<strong class="iw hy"> <em class="js"> lo </em> </strong>和<strong class="iw hy"> <em class="js"> hi </em> </strong>参数的作用类似于<strong class="iw hy"> <em class="js">等分_左</em> </strong>功能。</p><h2 id="6271" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">insort_left(a，x，lo=0，hi =无)</h2><p id="92b0" class="pw-post-body-paragraph iu iv hx iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">在前面的代码片段中使用了<strong class="iw hy"> <em class="js">插入</em> </strong>对象列表的方法来插入<strong class="iw hy"> <em class="js">列表中的<strong class="iw hy"/></em></strong>x值通过使用index<strong class="iw hy"><em class="js"/></strong>返回的<strong class="iw hy"> <em class="js">等分_左</em> </strong>函数，嗯，<strong class="iw hy"> <em class="js"/></strong></p><p id="d3c8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">该功能中的<strong class="iw hy"> lo </strong>和<strong class="iw hy"> <em class="js"> hi </em> </strong>参数与之前的功能相同。这里没有什么新东西。</p><p id="4dc3" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看下面的例子:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">5-insort_left函数</figcaption></figure><p id="3659" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">上面的代码片段对应于第三个代码片段(<em class="js">2-插入x值</em>)，在<strong class="iw hy"> <em class="js">二等分_左</em> </strong>函数的解释中作为例子给出，注意结果是相同的。</p><h2 id="4ae4" class="jt ju hx bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">insort_right(a，x，lo=0，hi =无)</h2><p id="17f7" class="pw-post-body-paragraph iu iv hx iw b ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn ks jp jq jr hb bi translated">该函数的工作方式与<strong class="iw hy"> <em class="js"> insort_left </em> </strong>相同，除了它使用<strong class="iw hy"> <em class="js">平分_right </em> </strong>函数找到需要插入<strong class="iw hy"> <em class="js"> x </em> </strong>值的位置。</p><p id="5c04" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们看一个例子:</p><figure class="kt ku kv kw fd hk"><div class="bz dy l di"><div class="kx ky l"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">6- insort_right函数</figcaption></figure><p id="893c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">前面的代码片段在第<strong class="iw hy"> <em class="js">节中使用，请注意得到了相同的结果。</em></strong></p><p id="7dcd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是使用<strong class="iw hy"> <em class="js">的功能平分</em> </strong>模块的最简单方法。需要特别提到的是<strong class="iw hy"> <em class="js">平分_左</em> </strong>和<strong class="iw hy"> <em class="js">平分_右</em> </strong>的时间复杂度为<strong class="iw hy"><em class="js">O(log(n)</em></strong>由于它们的实现使用了<a class="ae kz" href="https://en.wikipedia.org/wiki/Binary_search_algorithm" rel="noopener ugc nofollow" target="_blank">二分搜索法算法</a>。<strong class="iw hy"> <em class="js"> insort_right </em> </strong>和<strong class="iw hy"> <em class="js"> insort_left </em> </strong>函数的时间复杂度取决于list类的<strong class="iw hy"> <em class="js"> insert </em> </strong>方法的复杂度，即<strong class="iw hy"><em class="js">【O(n)</em></strong>。</p><p id="b2b7" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">所有的例子都使用了整数列表，但是你也可以使用浮点数列表，甚至是字符串列表。也许你想知道如果我使用一个元组或者一个字符串会怎么样？好问题！。嗯，你可以在元组和字符串中使用<strong class="iw hy"> <em class="js">平分_左</em> </strong>和<em class="js">平分_右</em> 没有任何问题，但是如果你试图在这些对象上使用<strong class="iw hy"><em class="js">insort _左</em> </strong>和<strong class="iw hy"><em class="js">insort _右</em> </strong>你会得到一个错误。为什么呢？发生这种情况是因为元组和字符串是不可变的对象，并且这些类型的对象没有实现<strong class="iw hy"> <em class="js"> insert </em> </strong>方法，该方法将一个可变对象就地修改为列表。</p><p id="aafa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hy"> <em class="js">二等分_右</em> </strong>和<strong class="iw hy"> <em class="js"> insort_right </em> </strong>有别名，所以<strong class="iw hy"> <em class="js">二等分_右</em> </strong> t可以简称为<strong class="iw hy"> <em class="js">二等分</em> </strong>和i <strong class="iw hy"> nsort_right </strong>为<strong class="iw hy"> insort。</strong></p><p id="58f6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，看看当您试图在一个按降序排序的列表上或者甚至在一个未排序的列表上使用这些函数时会发生什么。你会很容易发现的！</p><p id="ccc6" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">切记不要多此一举！</p><p id="5d2d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果你对这篇文章有任何意见，请告诉我:)。</p><p id="39be" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">参考</p><ul class=""><li id="d454" class="la lb hx iw b ix iy jb jc jf lc jj ld jn le jr lf lg lh li bi translated"><a class="ae kz" href="http://bisect — Array bisection algorithm" rel="noopener ugc nofollow" target="_blank">二等分—数组二等分算法</a></li></ul></div></div>    
</body>
</html>