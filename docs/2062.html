<html>
<head>
<title>Introduction to probabilistic programming in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中的概率规划介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-probabilistic-programming-in-julia-33960c7929f0?source=collection_archive---------13-----------------------#2021-04-03">https://medium.com/analytics-vidhya/introduction-to-probabilistic-programming-in-julia-33960c7929f0?source=collection_archive---------13-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6161" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将使用<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/?utm_source=auto-email#MySubmissions" rel="noopener ugc nofollow" target="_blank">贷款批准预测</a>数据来说明如何使用Julia包<a class="ae jd" href="https://turing.ml/stable/" rel="noopener ugc nofollow" target="_blank">图灵</a>用概率编程进行贝叶斯推断。我将来自<a class="ae jd" href="https://turing.ml/dev/tutorials/2-logisticregression/" rel="noopener ugc nofollow" target="_blank">图灵教程</a>的代码应用于贷款分类问题。</p><h1 id="5da0" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">贝叶斯理论</h1><p id="5eb9" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">P(Y|X)P(X) = P(XY) = P(X|Y)P(Y)</p><p id="4dae" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果X是我们的数据，也叫证据，Y是我们的模型假设，P(Y)是我们看到任何证据之前的概率，叫先验概率。在实践中，我们通常假设均匀分布或正态分布。</p><p id="57c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(X|Y)是似然函数，这意味着如果我们知道模型假设/参数的值，那么我们可以通过使用似然函数来获得证据发生的概率。</p><p id="2a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">P(Y|X)是给定我们看到数据/证据X的情况下，我们的模型假设的概率，也称为后验概率。</p><p id="126c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贝叶斯推断是根据我们能观察到的数据样本X来估计后验概率P(Y|X)的过程。通常，我们会重复以下步骤:</p><ol class=""><li id="868a" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">假设先验概率为均匀或正态分布。</li><li id="0670" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">使用概率来生成模型参数Y’。</li><li id="4de0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">使用Y '的样本来生成数据X '。</li><li id="d6bd" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">将生成的X '与我们观察到的实际数据进行比较。</li><li id="55bb" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">根据X和X '的差值更新后验概率。例如，如果差值小于我们预设的阈值，我们将保持Y’的值。经过多次迭代后，我们通过使用我们保留的所有采样Y '来估计后验概率分布。</li></ol><p id="ec29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">概率编程</strong>是我们使用计算机语言建立贝叶斯模型的方式。它们提供了一种简单的方法来定义概率模型并自动求解。</p><p id="73e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Julia中，我们用来定义概率模型的包是<strong class="ih hj"> <em class="kv"> Turing.jl </em> </strong>。</p><h1 id="cf28" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">贝叶斯逻辑回归</h1><p id="5b3a" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们可以使用贝叶斯推断来估计逻辑回归的参数。这里，我将以<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/?utm_source=auto-email#MySubmissions" rel="noopener ugc nofollow" target="_blank">贷款审批预测</a>数据为例。</p><blockquote class="kw kx ky"><p id="45c5" class="if ig kv ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">家庭可支配收入=主要申请人收入+w1 *共同申请人收入-人均支出*家庭成员人数。</p><p id="3ebe" class="if ig kv ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">每期还贷额=贷款总额/贷款总期限</p><p id="209a" class="if ig kv ih b ii ij ik il im in io ip kz ir is it la iv iw ix lb iz ja jb jc hb bi translated">贷款批准状态与每期可支配收入与贷款支付的比率有关。</p></blockquote><p id="e9a4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">贷款审批状况还会受到信用记录、教育水平、居住区域的位置以及贷款是长期还是短期的影响。</p><p id="e01f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Julia使用宏<code class="du lc ld le lf b">@model</code>来定义概率模型。其中输入参数x是数据向量:</p><ol class=""><li id="7e8e" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">应用程序输入x[，1]，</li><li id="40c0" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">共同申请人x[，2]，</li><li id="acdd" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">估计家庭成员数x[，3](我用婚姻状况和赡养人数来估计)，</li><li id="f28d" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">每个贷款期限的贷款金额x[，4](即贷款总额/贷款期限)</li></ol><p id="9972" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述4个数据值将被馈入上述可有可无的收入公式。然后，它将由几个0-1变量乘以相应的权重进行调整。</p><ol class=""><li id="174e" class="kh ki hi ih b ii ij im in iq kj iu kk iy kl jc km kn ko kp bi translated">状态是否有信用记录x[，5]，</li><li id="0c7e" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">状态是否有研究生学历x[，6]，</li><li id="d5b8" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">是否为自雇人士x[，7]，</li><li id="b3f6" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">是否居住在x[，8]城区</li><li id="b292" class="kh ki hi ih b ii kq im kr iq ks iu kt iy ku jc km kn ko kp bi translated">贷款状态是否为长期x[，9](贷款期限≥ 360个月)</li></ol><p id="9096" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，将公式的全部输出提供给逻辑函数，以计算伯努利概率。最终分类(Y/N)可视为伯努利分布的0–1结果。</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="de60" class="lo jf hi lf b fi lp lq l lr ls"># Bayesian logistic regression (LR)<br/><a class="ae jd" href="http://twitter.com/model" rel="noopener ugc nofollow" target="_blank">@model</a> logistic_regression(x, y, n, σ) = begin<br/>    intercept ~ Normal(0, σ)<br/>    income1 ~ LogNormal(0, σ)<br/>    income2 ~ LogNormal(0, σ)<br/>    numfamily  ~ LogNormal(0, σ)<br/>    credit  ~ LogNormal(0, σ)<br/>    edu  ~ LogNormal(0, σ)<br/>    self_emp  ~ LogNormal(0, σ)<br/>    urban  ~ LogNormal(0, σ)<br/>    long  ~ LogNormal(0, σ)</span><span id="6fc5" class="lo jf hi lf b fi lt lq l lr ls">for i = 1:n<br/>        v = <br/>        logistic(intercept + income1*(x[i, 1] + income2*x[i,2] - numfamily*x[i,3]) / x[i,4] <br/>        + credit*x[i,5] + edu*x[i,6] + self_emp*x[i,7] + urban*x[i,8] + long*x[i,9]<br/>        )<br/>        y[i] ~ Bernoulli(v)<br/>    end<br/>end;</span></pre><p id="8ba4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://en.wikipedia.org/wiki/Hamiltonian_Monte_Carlo" rel="noopener ugc nofollow" target="_blank">哈密顿蒙特卡罗</a>采样器(HMC)用于抽取样本来估计后验分布。下面的代码将迭代并提取存储在“链”中的3000*5个样本，链的类型为:Vector{ChainDataFrame}。</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="1d6c" class="lo jf hi lf b fi lp lq l lr ls"># Retrieve the number of observations.<br/>n, _ = size(train)</span><span id="83f4" class="lo jf hi lf b fi lt lq l lr ls"># Sample using HMC.<br/>chain = mapreduce(c -&gt; sample(logistic_regression(train, train_label, n, 1), HMC(0.05, 10), 3000),<br/>    chainscat,<br/>    1:5<br/>)</span></pre><p id="6449" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过绘制“链”数据，我们可以得到模型参数的后验分布。下面是参数的示例图:“信用记录”和“教育背景”。一个看起来像正态分布，而另一个看起来像对数正态分布。</p><figure class="lg lh li lj fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lu"><img src="../Images/53efa19d843162014197527e36c01c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-xL15txoPSpTUIoBZZcncQ.png"/></div></div></figure><p id="d3f7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里是所有参数的平均值，以及其他统计数据。</p><figure class="lg lh li lj fd lv er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es mc"><img src="../Images/0b0ecec7a1df50d0cd22d8703ba82cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*av2tZT8KNifWybNh8ZNO3w.png"/></div></div></figure><p id="9205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以看到“信用历史”的参数是所有其他状态变量中最高的。这意味着申请人是否有信用记录比教育背景、就业和居住地区更重要。</p><p id="9c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，共同申请人收入的权重(w1)为0.64。参照公式部分:申请人-收入+w1 *共同申请人-收入。这意味着，与主申请人的全部收入相比，只有60%的共同申请人收入被考虑在内。</p><h1 id="3216" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">预言；预测；预告</h1><p id="d6ff" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">利用后验分布中每个参数的平均值，我们可以对测试集进行预测。</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="a7ad" class="lo jf hi lf b fi lp lq l lr ls">function prediction(x::Matrix, chain, threshold)<br/>    # Pull the means from each parameter's sampled values in the chain.<br/>    intercept = mean(chain[:intercept][:,])<br/>    income1 = mean(chain[:income1][:,])<br/>    income2 = mean(chain[:income2][:,])<br/>    numfamily = mean(chain[:numfamily][:,])<br/>    credit = mean(chain[:credit][:,])<br/>    edu = mean(chain[:edu][:,])<br/>    self_emp = mean(chain[:self_emp][:,])<br/>    urban = mean(chain[:urban][:,])<br/>    long = mean(chain[:long][:,])</span><span id="f916" class="lo jf hi lf b fi lt lq l lr ls"># Retrieve the number of rows.<br/>    n, _ = size(x)</span><span id="391a" class="lo jf hi lf b fi lt lq l lr ls"># Generate a vector to store our predictions.<br/>    v = Vector{Float64}(undef, n)</span><span id="65fd" class="lo jf hi lf b fi lt lq l lr ls"># Calculate the logistic function for each element in the test set.<br/>    for i in 1:n<br/>        num = <br/>        logistic(intercept + income1*(x[i, 1] + income2*x[i,2] - numfamily*x[i,3]) / x[i,4] <br/>        + credit*x[i,5] + edu*x[i,6] + self_emp*x[i,7] + urban*x[i,8] + long*x[i,9]<br/>        )<br/>        if num &gt;= threshold<br/>            v[i] = 1<br/>        else<br/>            v[i] = 0<br/>        end<br/>    end<br/>    return v<br/>end;</span></pre><p id="26f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将阈值设置为0.5，我们可以得到预测的输出。</p><pre class="lg lh li lj fd lk lf ll lm aw ln bi"><span id="43cd" class="lo jf hi lf b fi lp lq l lr ls">threshold = 0.5<br/>predictions = prediction(test, chain, threshold)</span></pre><p id="9287" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们在测试集上达到的准确率约为79%。挺好的！</p></div></div>    
</body>
</html>