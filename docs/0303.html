<html>
<head>
<title>Predicting the future using Machine Learning part IV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习预测未来第四部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-iv-8747b319be5c?source=collection_archive---------22-----------------------#2021-01-11">https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-iv-8747b319be5c?source=collection_archive---------22-----------------------#2021-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="7b91" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用正态高斯分布的贝叶斯分类器Python实现</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a69509a1b2a21f6b441b79f44a4f541c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Jh9EmVPryfRNgLEc"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">布莱克·康纳利在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c73e" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在这篇文章中，我将介绍监督学习算法的另一个主要类型，即分类。具体来说，我将展示如何使用正态高斯分布构建贝叶斯分类器来估计连续变量的可能性。</p><p id="03a2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">用于此的数据集是经典的<em class="kj">费舍尔虹膜数据集</em>，它包含了150朵花的萼片和花瓣的长度和宽度的测量值。<em class="kj"> Fisher的虹膜数据集</em>是一个非常经典的例子，它包含在机器学习库中，因此每个人都可以通过从<em class="kj"> scikit-learn </em>库中导入数据集来检索它。</p><h2 id="91d9" class="kk kl hh bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">分离和绘制数据</h2><p id="5830" class="pw-post-body-paragraph jn jo hh jp b jq lf ii js jt lg il jv jw lh jy jz ka li kc kd ke lj kg kh ki ha bi translated">第一步是检索数据集，这很容易导入，并将其命名为<em class="kj"> iris </em>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lk"><img src="../Images/239a84ec2375b56f128f1652c02c55be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*425Nmm76N-fi8tCZ_FKq9w.png"/></div></div></figure><p id="9bf4" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><em class="kj"> iris </em>变量现在包含各种信息，但最重要的属性是<em class="kj">目标</em>和<em class="kj">数据</em>，它们包含150朵花的标签和数据点。所以我提取了这些属性，创建了一个包含数据<em class="kj">和目标<em class="kj">的矩阵X和一个向量R。</em>通过使用向量R，现在可以将矩阵X分成不同的类，如下所示:</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ll"><img src="../Images/577b9814ff24fa6cf3282d9dbf301546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*owWnGXaBLxH4mV4p5AS_WQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">索引可以让你的生活更轻松…</figcaption></figure><p id="6d8f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">为了了解数据集的相关性和可分性，我们应该绘制这些数据。使用<em class="kj"> seaborn </em>库，可以可视化每个单一特征的分布，以及使用两个特征作为<em class="kj"> x </em>和<em class="kj"> y </em>轴的散点图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lm"><img src="../Images/74057cc824386acfaf6b4f8825b91a79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1QlcKnDtvDwBXWZgyYwNA.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/5be9259138569f91b9f9114b6090ed25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mVJW1unGcGgd0vAiR9_nw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">对角线图是所有特征的分布，散点图是两个特征的不同配置</figcaption></figure><p id="7f7b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">查看这些图，可以得出结论，刚毛藻物种比其他物种更容易分离。这确实表明，其他物种<em class="kj">云芝</em>和<em class="kj">海滨锦葵</em>的许多特征是相互关联的。</p><h2 id="8b08" class="kk kl hh bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">协方差</h2><p id="7251" class="pw-post-body-paragraph jn jo hh jp b jq lf ii js jt lg il jv jw lh jy jz ka li kc kd ke lj kg kh ki ha bi translated">变量之间相关性的一个度量是协方差。两个联合分布的实值随机变量<strong class="jp hi"> X </strong>和<strong class="jp hi"> Y </strong>之间的协方差被定义为它们与各自期望值的偏差的期望乘积；</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/e8c445f12b70962da8cfc0a211ec1853.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IlKw0bbMuYnZrYT-DuUrVg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">E[…]是期望值</figcaption></figure><p id="57df" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">当协方差为正时，则变量正相关:当一个变量的值增加时，另一个值可能也会增加。但当协方差为负时，变量会负相关:当一个变量增加时，另一个值可能会减少。最后，当协方差接近零时，变量之间没有相关性。</p><h2 id="6988" class="kk kl hh bd km kn ko kp kq kr ks kt ku jw kv kw kx ka ky kz la ke lb lc ld le bi translated">贝叶斯分类器</h2><p id="9796" class="pw-post-body-paragraph jn jo hh jp b jq lf ii js jt lg il jv jw lh jy jz ka li kc kd ke lj kg kh ki ha bi translated">熟悉数据后，现在可以建立一个模型，根据其他变量预测给定数据点属于哪一类(在本例中为<em class="kj">鸢尾物种</em>)。为了确定模型与数据的拟合程度，我们将使用<a class="ae jm" rel="noopener" href="/analytics-vidhya/predicting-the-future-using-machine-learning-part-iii-410e1a1742c7">交叉验证</a>方法。我使用了第三部分中的<em class="kj"> validation_split </em>函数作为灵感，但是这个<em class="kj"> validation_split </em>略有不同:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/795b22771ec0e58934efee10c5f55354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-BEkXnrc39LNeB7lHZmIw.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">输出给定比率的分割数据集</figcaption></figure><p id="7503" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">对3个类别中的每一个使用此函数，每个类别的比率为0.7，您将得到:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/3bab50eda89cccd9af571aede42096a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ESr-bfyx6itPWTqAjl4E_A.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">每个类的训练集和验证集</figcaption></figure><p id="a775" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从上述散点图可以得出，基于花瓣数据(花瓣宽度和花瓣长度)比基于萼片数据更容易区分不同的类，因为在该图中更容易区分不同的簇。我决定进一步缩小范围，开始只关注一个变量，即花瓣长度。这个变量本身非常有用，已经大大简化了模型。</p><p id="d7e0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用所有3个类的训练集，我开始计算每个类的花瓣长度属性的平均值和标准偏差。对于这些计算，用于平均值和标准差的内置Numpy函数将被认为是有用的:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lr"><img src="../Images/c9eb7a7d2e193f49d29cc78cff3efe22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CvktmzPmI1AgiL1XslX_lw.png"/></div></div></figure><p id="b6d7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，我们已经对3个类别的花瓣长度的平均值和标准偏差进行了估计，我们可以计算<em class="kj">概率密度函数(PDF) </em>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ls"><img src="../Images/e55212dc17bde6f0915028a42d332143.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*nY7zdaO-jCMWkFV4E3zQ2g.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">其中X是均值为μ、方差为σ的高斯正态分布</figcaption></figure><p id="2d7c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">Python中的实现如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lt"><img src="../Images/3da226c43170e26240ad613712d1b87b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A_aU7i7DdFzDXpgj0RgRpg.png"/></div></div></figure><p id="fe92" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">接下来，所有3类的概率密度函数可以使用linspace进行计算和可视化，就像在<a class="ae jm" rel="noopener" href="/analytics-vidhya/predicting-the-future-using-machine-learning-part-ii-fb45806e5b71">第二部分</a>中一样，对于一系列x值，通过应用<em class="kj"> PDF函数</em>计算相应的y值:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/d711cbcaf10c132c0d63ef36db05704d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--Z_nuFWFrM1Ogh8gGDbow.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lu"><img src="../Images/ccb44f96c0e3637ac912cc87884d236b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rnvmarl2QlARO67ujyWKmQ.png"/></div></div></figure><p id="b89b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">上图显示了x值的概率密度，前提是您知道特定类别的平均值和标准差的估计值。然而，对于分类，我们实际上需要的是给定数据的类别的后验概率。为了检索这个，可以使用<em class="kj">贝叶斯规则</em>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lv"><img src="../Images/674bdfb936f8c4ea5c7a0a0ce65682e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*fdoyrAqlyK1l6VTqWLI9aw.png"/></div></figure><p id="4bd5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这个等式可以通过分解出共同的先验来进一步简化:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lw"><img src="../Images/85fde86976430e7e4bd84d51f47443d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:696/format:webp/1*jj5NLEWYZaQ-PEpow5N4rg.png"/></div></figure><p id="d719" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在可以用<em class="kj">后验函数</em>计算后验。为了简化代码，我做了向量M和S，每类的所有均值和所有标准差。有了这些向量，一个参数就足以指定要计算后验概率的类别:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lx"><img src="../Images/c3b3e48d5f2b50b35de48faa5cd9e86a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o-3v1SCkbHxYYZ_qot6_OA.png"/></div></div></figure><p id="d44a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">将后验可视化会导致:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/2f480cef45cbbb3b641c1edd9c9dfd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KxCH3zqNA2QP6xqoTSiT7w.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lz"><img src="../Images/054948073bf6080a651aa90c5851264e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GpfsA1UUgoiOSeMDEIa5jQ.png"/></div></div></figure><p id="c312" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">构建分类器所需的所有工具现在都可以使用了！贝叶斯分类器定义为:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ma"><img src="../Images/fa8d51fee6489bf45f5643d8396a7706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*7Jqj4herM5CvJU4i6EEXYQ.png"/></div></figure><p id="4b75" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在Python中实现这一点，需要两个函数，即<em class="kj">分类</em>和<em class="kj">验证</em>。<em class="kj"> classify </em> <em class="kj">函数</em>将单个数据点x分类为3类中的一类，根据其所属的类返回0、1或2。<em class="kj">验证函数</em>获取每个数据点的所有预测类的验证集，并返回正确预测的数量:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mb"><img src="../Images/b874aadd2e433a06f0c16a00a73b1ba3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7KBji-fBbkRs_V04OL_q1g.png"/></div></div></figure><p id="9fc7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后，我使用这些函数来报告每个类的正确预测百分比以及正确百分比的平均值，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mc"><img src="../Images/c07501f0a04752e883195bbdaaff453e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sGDgXX2XZgVR6dy3_dKgtA.png"/></div></div></figure><p id="0d84" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这导致了:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es et"><img src="../Images/1fcf82487eb14ee986b4b4b2effd6f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rADgVQbq1_zjNaPffRtGRA.png"/></div></div></figure><p id="e2f8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在你知道了！请注意，这个分类器是使用单变量模型构建的，因为我们只使用了花瓣长度。但是我们可以做得更好，通过使用更多的变量，因此使用多变量模型。在我的下一篇文章中，我将讨论这些模型。</p></div></div>    
</body>
</html>