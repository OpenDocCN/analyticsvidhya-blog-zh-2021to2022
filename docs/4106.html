<html>
<head>
<title>Implementing a Deep Neural Network from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始实现深度神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementing-a-deep-neural-network-from-scratch-8ed9988d2e4d?source=collection_archive---------4-----------------------#2021-08-27">https://medium.com/analytics-vidhya/implementing-a-deep-neural-network-from-scratch-8ed9988d2e4d?source=collection_archive---------4-----------------------#2021-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/2dd5f835e67f3b8d992182a2e09b5078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*vKxA5UQwVEl_1YGVGTnWzQ.jpeg"/></div></figure><h1 id="a98e" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">介绍</h1><p id="cd1a" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">在我写的前一篇文章(<a class="ae kh" rel="noopener" href="/analytics-vidhya/new-to-neural-networks-544ca4d6dacd">https://medium . com/analytics-vid hya/new-to-Neural-Networks-544 ca 4d 6 dacd</a>)中，我回顾了神经网络的语义，并简要地谈到了深度神经网络的概念。这一次我将讨论用代码实现一个深度神经网络的实际实现，所以预计这将需要更多的动手操作。我再次假设读者提供了Python、Matplotlib、Keras和Numpy的基础知识。然而，我会尽可能地描述代码。</p><p id="9d61" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">这个实现的目标是建立一个可以对对象进行分类的深度神经网络。选择对象分类作为使用DNN解决的第一个问题的原因是，对象分类是人工智能领域中一些更复杂的用例及问题的重要基础。此外，在过去的十年中，对象分类已经成为神经网络新手入门应用的一个主要部分。</p><p id="d1a0" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">我将只使用Numpy来实现它，以便让您能够一窥究竟，并更仔细地了解事情实际上是如何工作的，但是还有更优化和更有效的方式来构建库和框架形式的模型，如Tensorflow和PyTorch(我们将在这里简单地使用Keras的Tensorflow实现来加载数据集，我将在以后的文章中仅使用Tensorflow或PyTorch来实现更健壮的模型)。</p><p id="8fc9" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">我有很多东西要看，我们在这里仅仅触及了DL或AI的皮毛，所以请耐心等待！</p></div><div class="ab cl kn ko go kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ha hb hc hd he"><h1 id="8742" class="il im hh bd in io ku iq ir is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji bi translated">导入库，加载和浏览数据集</h1><p id="9fc7" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">第一步是加载数据集来训练我们的算法。为了简单起见，我们将通过Keras使用CIFAR-10数据集。</p><p id="78a0" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">根据Keras文件:</p><blockquote class="kz la lb"><p id="bbfb" class="jj jk lc jl b jm ki jo jp jq kj js jt ld kk jw jx le kl ka kb lf km ke kf kg ha bi translated">这是一个由50，000张32x32颜色训练图像和10，000张测试图像组成的数据集，分为10个类别。</p></blockquote><p id="6228" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">数据集中可用的10个对象类(标签)是:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lg"><img src="../Images/8ae5916547a928114c88a0a3f179a8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZpMQJk00LoBN4Ur6mkk65w.jpeg"/></div></div></figure><p id="9759" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">现在，让我们创建一个Jupyter笔记本并导入numpy、matplotlib和tensorflow-keras的数据集模块:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/b5d51e49214eb6ae22117ec0fafe9f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0Skm2465jxoZ9vcAvTT3qQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图1:导入库</figcaption></figure><p id="40de" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">接下来，让我们从Keras加载数据集，并使用matplotlib从我们的训练数据中绘制一幅图像:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lu"><img src="../Images/5f6e5441e61db2dad2e3bc54a33acb98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EhYyZjBE6nS82sjOQPcwPw.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图2:加载数据集并将其可视化</figcaption></figure><p id="ddd5" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">请注意，该图像是一个对象(在本例中，是一匹马或标签7)的低分辨率表示。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lv"><img src="../Images/df35676b14013e813c87ac5cfef0049f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uVTTyr6cZg6JthBPKiy75Q.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图3:数据集形状</figcaption></figure><p id="bfce" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">我们的训练数据包含50000张32x32像素和3个通道的图像，而测试数据集包含10000张图像——正如文档中提到的。</p><p id="f2a2" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">这不是我们想要的数据，也就是说，图像的形式不适合输入到我们的算法中，我们希望将图像展平为一个矢量，并希望归一化数据集中的像素值。</p><p id="fcd6" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">让我们为此创建一个效用函数:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/78b84731779fe0b95a2e7d7ef3678878.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V-tc5vZmR2nuh1mF1XZ1vQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图4:预处理效用函数</figcaption></figure><p id="98ff" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">现在让我们使用这个函数来处理我们的数据集:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/cf785eb5d83618e5c855acf1140f48aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8UMn90N0lVUv7DECcsU7Qg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图5:数据预处理</figcaption></figure></div><div class="ab cl kn ko go kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ha hb hc hd he"><h1 id="5941" class="il im hh bd in io ku iq ir is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji bi translated">构建我们的DNN模型</h1><p id="1b21" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">我们将使用的深度神经网络架构基本上是:</p><p id="3cbc" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated"><strong class="jl hi"> <em class="lc">输入</em> →( <em class="lc">线性</em>→<em class="lc">RELU)</em>×<em class="lc">(L-1)</em>→<em class="lc">线性</em> → <em class="lc">乙状结肠</em> → <em class="lc">输出</em> </strong></p><h2 id="fbe2" class="ly im hh bd in lz ma mb ir mc md me iv ju mf mg iz jy mh mi jd kc mj mk jh ml bi translated"><strong class="ak">初始化我们的参数:</strong></h2><p id="b760" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">作为构建DNN的第一步，我们需要初始化稍后在模型中学习的参数。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/056e260505aeb7c803fda1158a6c5524.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*omqn1IcExz6Kcu2WbI1Wbw.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图6:初始化参数</figcaption></figure><p id="77cd" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">上面的函数将所有层的尺寸作为一个参数，然后返回一个字典“parameters ”,其中包含:</p><ol class=""><li id="4a5b" class="mm mn hh jl b jm ki jq kj ju mo jy mp kc mq kg mr ms mt mu bi translated">随机初始化的权重“w”</li><li id="f014" class="mm mn hh jl b jm mv jq mw ju mx jy my kc mz kg mr ms mt mu bi translated">初始化为零偏差“b”</li></ol><p id="b509" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">接下来，让我们定义一个效用函数来为我们计算激活函数，这在后面会非常有用:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es na"><img src="../Images/20689ce13d48fce32fb2f4bf68fa0cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5TiFlJajZm25YrVtS3o0Q.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图7:激活功能效用函数</figcaption></figure><p id="e8fc" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">上面的这个函数将预激活“z”和一个字符串“type”作为输入参数，并基于给定的类型，简单地计算z上的激活并返回它。</p><h2 id="8538" class="ly im hh bd in lz ma mb ir mc md me iv ju mf mg iz jy mh mi jd kc mj mk jh ml bi translated"><strong class="ak">实现正向传播:</strong></h2><p id="e7d1" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">现在，在我们编写正向传播函数之前，我们需要编写两个辅助函数，一个用于计算预激活，另一个用于计算激活。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/05235e9568cb764d8659c50cad8adccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gyOfuEGR2VNhG31fDFSt0g.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图8:预激活计算</figcaption></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nb"><img src="../Images/45b2f078a80e6c3b3507d8a90e285dd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FtKdxlB8CXeahctkM-KQzQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图9:激活计算</figcaption></figure><p id="ea9b" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">现在我们已经准备好了这些助手函数，我们可以编写我们的正向传播函数了。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nc"><img src="../Images/2ef9ed43ea0f6dd7f6124216ac4304d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F4rTtpFLnDNgLUF23sAbvQ.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图10:正向传播函数</figcaption></figure><h2 id="3813" class="ly im hh bd in lz ma mb ir mc md me iv ju mf mg iz jy mh mi jd kc mj mk jh ml bi translated">计算损失:</h2><p id="5237" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">现在我们已经实现了正向传播，我们需要计算正向传递的开销。我们将对此使用交叉熵损失，然后对数据进行平均以获得成本。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/a8330e07492d26f738803b9dec48a10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aXgVz05sHso3YCqmspthhg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图11:计算成本</figcaption></figure><h2 id="dd44" class="ly im hh bd in lz ma mb ir mc md me iv ju mf mg iz jy mh mi jd kc mj mk jh ml bi translated">实现反向传播:</h2><p id="810b" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">我们需要写一个函数来反向计算激活，也就是说，利用我们将要计算的导数。这是一个效用函数:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lx"><img src="../Images/c5a58e149aaa921a61e4125f4b51f60e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O3FRMhQsa_21pncRYc5gvg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图12:反向激活</figcaption></figure><p id="38bf" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">正如我们对前向传播所做的那样，在我们编写反向传播函数之前，让我们先编写一些辅助函数，将代码分成几段，使其更加健壮和易于理解。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nb"><img src="../Images/13f4a0254fab9bf9ea95d58409b7b25d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*po5w3GS5A-sQbEbQ2dMkyw.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图13:计算导数</figcaption></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nd"><img src="../Images/d91dd68ba66ec6fb734e0afc16bbdeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SpSngZkKMSKX9xCmCTAC-g.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图14:计算反向激活</figcaption></figure><p id="5944" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">最后，让我们用我们写的这三个函数来实现反向投影</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ne"><img src="../Images/7060d29c1aba6d8b76aa2544dfa7e86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9x23m_O1IQq45cdv11scQw.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图15:反向传播</figcaption></figure><p id="ff69" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">我们现在已经计算出梯度并存储在名为“梯度”的字典中。让我们用这些梯度来更新参数。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/f5c4bea8b592a5466dab984947a26412.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LMouKnKMc0vYhuaw5dodyA.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图16:更新参数</figcaption></figure><h2 id="96b7" class="ly im hh bd in lz ma mb ir mc md me iv ju mf mg iz jy mh mi jd kc mj mk jh ml bi translated">型号:</h2><p id="6933" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">现在，我们已经将所有的拼图放在了一起，准备放在一起——所以让我们在主模型函数中使用所有这些函数来生成深度神经网络。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lw"><img src="../Images/4709cfcb3cae70a8317a1450b347e014.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWknD9GZjDHqnRXMhFE19A.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图17:四层DNN模型</figcaption></figure><p id="7e2c" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">接下来，我们训练模型进行2000次迭代:</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nf"><img src="../Images/637683555dfc8ba9def7cbad053c6a91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kvn69sCdPg6n_5R3fV8chg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图18:训练模型</figcaption></figure><p id="9d6d" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">一旦模型完成训练，我们最终可以继续进行预测。</p><h1 id="c032" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">预言</h1><p id="b843" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">我们将使用从上一节中定义的Model()函数返回的训练参数来预测图像中的对象(标签)。</p><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es ng"><img src="../Images/9cfec36cde7c30474385cf521dd1c053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ok6QGr5rAPLG6k_wBl-Weg.jpeg"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">图19:做出预测</figcaption></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es lp"><img src="../Images/9d8ee2a3254d6bfbc7a2c7854151d1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUzXw77KOSWt6Cz5z80wTA.jpeg"/></div></div></figure><figure class="lh li lj lk fd ii er es paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="er es nf"><img src="../Images/ca90b4c37b5503c3c569fad842ab1277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-maCCV8-DlixVYz5m4e7wQ.jpeg"/></div></div></figure></div><div class="ab cl kn ko go kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="ha hb hc hd he"><h1 id="c37e" class="il im hh bd in io ku iq ir is kv iu iv iw kw iy iz ja kx jc jd je ky jg jh ji bi translated">结论</h1><p id="52c6" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">我们已经实现了一个4层DNN，看到了如何训练它，并使用训练值进行预测。</p><p id="013b" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">然而，当你自己尝试时，你会发现准确率达到了80% +-5%左右的上限，这不一定是坏的，但还有很大的改进空间。这可以通过超参数优化来实现。</p><p id="d205" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">此外，计算机视觉任务更适合更强大的算法，如CNN。它们有些复杂，从头开始训练需要更多的计算。这就是为什么通常的做法是使用预训练权重进行微调(迁移学习)，而不是自己从头开始训练模型。</p><p id="22d3" class="pw-post-body-paragraph jj jk hh jl b jm ki jo jp jq kj js jt ju kk jw jx jy kl ka kb kc km ke kf kg ha bi translated">我们将通过开源实现和预先训练的模型权重来回顾迁移学习的使用。就这样吧，我大概一个月后回来。</p></div></div>    
</body>
</html>