<html>
<head>
<title>Avoiding Leakage with Pipelines</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免管道泄漏</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-a-pipeline-anyways-e6a814d4888?source=collection_archive---------11-----------------------#2021-02-16">https://medium.com/analytics-vidhya/what-is-a-pipeline-anyways-e6a814d4888?source=collection_archive---------11-----------------------#2021-02-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b9f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道到底是什么？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/2ed3596fb5188da4593a40713de75961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*UVoy_ARn1ih3AonwlSJ1oQ.png"/></div></figure><p id="dd14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在数据科学领域，管道是以可重复的方式标准化和提取数据的过程，尽管它更多的是一个概念而不是一个公式。通常，管道是一个工作流。然而，具体来说，Sci-Kit Learn的Pipeline模块是一种有效的方式，可以通过Python中的预处理自动执行<a class="ae jk" href="https://towardsdatascience.com/validating-your-machine-learning-model-25b4c8643fb7" rel="noopener" target="_blank">模型验证</a>的良好实践。<a class="ae jk" href="https://machinelearningmastery.com/caret-r-package-for-applied-predictive-modeling/" rel="noopener ugc nofollow" target="_blank">如果你用R写代码，这可以用脱字符号包</a>来完成，尽管这里的代码示例可能对你没什么用。Pipeline允许用户将Sci-Kit Learn的其他模块中的许多有价值的方法打包到一个工作流中，该工作流可以在许多数据集上实施和重复，并减少了可能导致不准确建模和训练的潜在错误，尤其是在处理大型数据集时。它们不仅可以简化您的工作，而且管道还可以用作防止数据泄漏的预防措施。</p><p id="9c83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Sci-Kit Learn (也称为sklearn)是David Cournapeau于2007年开始的一个项目，同年晚些时候加入该项目的Matthieu Brucher也参与了该项目。它于2010年2月1日首次正式发布，目前是一个社区开发的库，拥有国际用户和贡献者基础。Sklearn被设计为在SciPy和NumPy Python库之上运行，但是对于Pandas、Matplotlib和Plotly也是高度功能化的。目前，它是预测分析的标准之一。</p><p id="74dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么是数据泄露，为什么说它不好？<br/> </strong>“当在构建模型时使用预测时不可用的信息时，就会发生数据泄漏”，这“导致乐观的性能估计……因此，当模型用于实际上新的数据时，性能会更差，例如在生产期间”(<a class="ae jk" href="https://scikit-learn.org/stable/common_pitfalls.html" rel="noopener ugc nofollow" target="_blank"> Sklearn常见陷阱</a>)。基本原则是永远不要将测试数据引入到应用于训练数据的特征提取和转换步骤中。作为一个推论，在特性选择和模型估计之前执行<a class="ae jk" href="https://machinelearningmastery.com/train-test-split-for-evaluating-machine-learning-algorithms/" rel="noopener ugc nofollow" target="_blank">训练/测试分割</a>或其他形式的模型验证可以确保不会发生数据泄漏，并且对您的测试数据没有影响(这听起来很乐观，但会导致不准确，在预测建模的情况下，我宁愿成为一个精确的怀疑者)。一些包含的链接进一步详细说明了模型验证，但其总体思想是将数据分为训练集和测试集-一个集是模型的基础，另一个集用于验证模型是否可以准确预测未知结果。</p><p id="0795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将测试数据引入训练数据转换会模糊算法准确预测未知数据的能力，因为它已经暴露在训练结构中，从而在自我强化循环中导致较差的<a class="ae jk" href="https://towardsdatascience.com/validating-your-machine-learning-model-25b4c8643fb7" rel="noopener" target="_blank">模型验证</a>。当训练信息渗透到测试数据中，使结果偏向训练集时，就会出现这种循环。反过来，这使得预测未知信息有偏差，并使模型离准确预测越来越远。突然，你的模型失控了，你不得不重新开始。数据泄漏在小范围内会导致不准确的预测模型，在大范围内会使它们完全失效。在专业环境中，它可能会延迟部署并造成严重的安全漏洞。</p><p id="3b88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为这在概念上很难想象，下面是一个简单的野外数据泄漏的例子:</p><blockquote class="jl jm jn"><p id="7049" class="ie if jo ig b ih ii ij ik il im in io jp iq ir is jq iu iv iw jr iy iz ja jb ha bi translated">“一个特征用于训练在预测时在生产中不可用的模型。例如，当入院后24小时内可能不会进行药物调节时，可以使用患者目前正在服用的口服药物数量来预测住院时间。”</p></blockquote><p id="248b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jk" href="https://healthcare.ai/data-leakage-in-healthcare-machine-learning/" rel="noopener ugc nofollow" target="_blank">此医疗保健示例</a>通过使用在预测时不存在于原始集合中的信息来计算目标而发生泄漏，这是无效的，因为它应用尚不可访问的信息来确定未来结果。</p><p id="8ebc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">那么管道如何解决这个问题呢？<br/></strong>Pipeline模块允许您打包特征选择、提取和估计，并有助于确保您只对训练数据进行操作——在上面的示例中，可以使用Pipeline来选择只在预测时间之前生成的数据。</p><p id="bdc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">管道也允许你只需要调用<strong class="ig hi">。fit() </strong>和<strong class="ig hi">。执行选择/标准化序列后预测()</strong>一次，而不是每次单独重复该过程。除了简化数据挖掘过程之外，它还通过消除与每个独立实例的硬编码相关的潜在人为错误，提供了一个额外的防泄漏层。</p><p id="e7f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">什么时候建造管道会有好处？</strong></p><p id="aee3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">预处理<br/>一旦你清理了你的数据，归一化可以强制它成为一个均值为零和单位方差的高斯(正态)分布，这是许多机器学习算法的必要条件(和假设)。如果不缩放数据，权重不同的特征可能会掩盖其他特征，并使算法无法准确预测测试子集的数据。除了缩放之外，预处理模块还有很多有用的工具，例如二值化和居中——访问sklearn的<a class="ae jk" href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.preprocessing" rel="noopener ugc nofollow" target="_blank">文档页面。预处理</a>了解更多特性。</strong></p><p id="fe37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">为标准化构建管道:<br/> </strong>构建管道涉及到使用一列<em class="jo">(键，值)</em>对，其中<em class="jo">键</em>是估计器步骤的字符串名称，<em class="jo">值</em>是估计器对象。一个例子可能是这样的:</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="6c3a" class="jx jy hh jt b fi jz ka l kb kc">&gt;&gt;&gt; from sklearn.pipeline import Pipeline</span><span id="6ea9" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler</span><span id="e35d" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; from sklearn.linear_model import LinearRegression</span><span id="8463" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; estimators = [('scale', StandardScaler()), ('linreg', LinearRegression())] #contains a list of scaling and estimator objects</span><span id="9618" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; pipe = Pipeline(estimators) #constructs a pipeline using the objects</span><span id="1632" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; pipe</span><span id="397e" class="jx jy hh jt b fi kd ka l kb kc">Pipeline(steps=[(‘scale’ , StandardScaler()), (‘linreg’, LinearRegression())]) #the output is a pipeline object containing the above methods</span></pre><p id="2f26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现这一点的一个简单方法(如果你真的不想给自己的对象命名)是调用<strong class="ig hi"> make_pipeline() </strong>:</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="8ddd" class="jx jy hh jt b fi jz ka l kb kc">&gt;&gt;&gt; from sklearn.pipeline import make_pipeline</span><span id="fe00" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; from sklearn.naive_bayes import MultinomialNB</span><span id="ac3c" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; from sklearn.preprocessing import Binarizer</span><span id="8ebb" class="jx jy hh jt b fi kd ka l kb kc">&gt;&gt;&gt; make_pipeline(Binarizer(), MultinomialNB()) #initializes a Pipeline object</span><span id="d379" class="jx jy hh jt b fi kd ka l kb kc">Pipeline(steps=[(‘binarizer’, Binarizer()), (‘multinomialnb’, MultinomialNB())]) #the contents of the Pipeline object</span></pre><p id="5102" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">构建特征选择的流水线</strong> : <br/>对于选择满足一定统计标准的特征，<a class="ae jk" href="https://scikit-learn.org/stable/modules/feature_selection.html" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi">sk learn . feature _ selection</strong></a>工具可以作为数据预处理步骤的一部分，集成到流水线中。例如:</p><pre class="jd je jf jg fd js jt ju jv aw jw bi"><span id="5eed" class="jx jy hh jt b fi jz ka l kb kc">clf = Pipeline([</span><span id="d3c1" class="jx jy hh jt b fi kd ka l kb kc">(‘feature_selection’, SelectFromModel(LinearSVC(penalty=”l1"))),</span><span id="1593" class="jx jy hh jt b fi kd ka l kb kc">(‘classification’, RandomForestClassifier())</span><span id="0505" class="jx jy hh jt b fi kd ka l kb kc">])</span><span id="b178" class="jx jy hh jt b fi kd ka l kb kc">clf.fit(X, y)</span></pre><p id="3ec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个Sklearn代码片段演示了如何初始化一个名为<strong class="ig hi"> clf </strong>的管道对象，其中包含一个<strong class="ig hi"> feature_selection </strong>工具和一个<strong class="ig hi">算法分类</strong>工具，它们将在所选特性上实现。然后，对数据X和y调用<strong class="ig hi"> clf.fit() </strong>将使模型适合所选和修改的数据。</p><p id="be7c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当谈到训练机器学习算法时，如果没有一套正确的工具来组织您的工作流程，这个过程可能会变得势不可挡、错综复杂和不精确。使用管道来构建信息处理和建模的方式有助于减少犯粗心错误的机会，并防止创建训练不足的模型。管理大型数据集已经是一项具有挑战性的任务，不存在许多可能遇到的障碍，因此了解在不牺牲您的理智的情况下避免它们的选项非常重要。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ke"><img src="../Images/253bd2e39cec5e511a96b4151709f8ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*99pQjxBMlIKeWhe6y-ZQnQ.png"/></div></figure><p id="942e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jo">有关推理和预测分析的更多信息，请访问:</em></p><p id="9977" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jk" href="https://scikit-learn.org/" rel="noopener ugc nofollow" target="_blank">https://scikit-learn.org/</a><br/><a class="ae jk" href="https://towardsdatascience.com/" rel="noopener" target="_blank">https://towardsdatascience.com</a>T22<a class="ae jk" href="https://machinelearningmastery.com/" rel="noopener ugc nofollow" target="_blank">https://machinelearningmastery.com/</a></p></div></div>    
</body>
</html>