<html>
<head>
<title>Array Two pointers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数组两个指针</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/array-two-pointers-4b8d62d2b8a?source=collection_archive---------10-----------------------#2021-01-12">https://medium.com/analytics-vidhya/array-two-pointers-4b8d62d2b8a?source=collection_archive---------10-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c6ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇博客解释了<em class="jc">数组双指针</em>方法背后的底层算法，并涵盖了LeetCode中的一些问题，这些问题可以使用相同的方法来解决。希望这篇博客对准备技术轮的人有所帮助。</p><p id="d1ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不再耽搁，让我们从正题开始。</p><h2 id="cd5e" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">两点</h2><p id="b4a7" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">有时我们会遇到这样的问题:</p><ol class=""><li id="ecbc" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">我们被<strong class="ig hi">给定了一个阵，</strong>和</li><li id="88d4" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">要么我们需要<strong class="ig hi">找到一个子阵列</strong>，</li><li id="054e" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">或者，我们需要<strong class="ig hi">找到一对</strong>，使得<strong class="ig hi">满足某些条件</strong>。</li></ol><p id="da4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们更喜欢使用双指针方法。下图提供了使用两个指针的两个例子:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/b3b08ff554fc5f075459b90369c8b26a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKkUPAz6jONa2QBLboM5Mw.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">我们使用双指针方法的例子</figcaption></figure><blockquote class="lh li lj"><p id="ecc0" class="ie if jc ig b ih ii ij ik il im in io lk iq ir is ll iu iv iw lm iy iz ja jb ha bi translated"><strong class="ig hi">那么，到底什么是<em class="hh">两个指针</em>的做法呢？</strong> <em class="hh"> </em>从上面给出的例子来看，两个指针的使用给出了该方法的名称——<em class="hh">两个指针</em>的方法<em class="hh">。</em>在<em class="hh">双指针</em>方法中，我们使用2个指针，并在数组上高效地移动它们<strong class="ig hi"><em class="hh"/></strong>以找到想要的解。</p></blockquote><p id="dcda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，仍然有一些问题需要澄清:“有效地”是什么意思？—在大多数情况下，两个指针都会遍历数组，对每个元素只访问一次。换句话说，每个元素被访问两次，每个指针访问一次。</p><p id="cb2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在大多数情况下，两点法的时间复杂度是O(n)。</p><p id="a48a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了帮助我们理解这种方法是如何工作的，让我们看一个例子。</p><h2 id="af82" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">例子</h2><p id="35d5" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">假设我们有一个数组= [1，2，3，4，5，6]，我们需要找到一个sum = 9的子数组。因此，我们得到了以下数据:</p><ul class=""><li id="472f" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ln kj kk kl bi translated">Array = [1，2，3，4，5，6]</li><li id="68ca" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ln kj kk kl bi translated">期望= 9</li></ul><p id="63ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从方法开始。我们将初始化两个指针——“beg”和“ed”beg代表开始，ed代表结束。顾名思义，“beg”和“ed”指针将分别用于标记子数组的开始和结束。</p><p id="6ed4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们首先将'<em class="jc"> beg </em>'和'<em class="jc"> ed </em>'放在数组的左边。如下图所示，子数组只包含一个值为1的元素。因此，子阵列的总和是1。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lo"><img src="../Images/485305ba6430ff2c4a660e04c346672c.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*B8c2uNp0m-btTfFMmgtSKw.png"/></div></figure><p id="cb15" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上图中，由于总和小于期望值，即9，我们决定扩展子数组。我们扩展子数组是因为我们想增加子数组中所有元素的总和。</p><p id="68cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">为了展开，我们做了以下工作:</strong></p><ul class=""><li id="35be" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ln kj kk kl bi translated">向右移动'<em class="jc"> ed </em>'指针，即(<em class="jc"> ed </em> ++)</li><li id="1711" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ln kj kk kl bi translated">将这个新元素添加到<em class="jc">总和</em>中，即<em class="jc">总和</em> += arr[ <em class="jc"> ed </em></li></ul><p id="ae9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">展开后，我们得到以下状态:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lp"><img src="../Images/70b7132867bd8fa1d06952e8c71b51fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*uzeO5oedVoCSc92aVwqdpQ.png"/></div></figure><p id="637f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上图中，总和的值是3。由于sum &lt; desired, we expand again.</p><p id="e586" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">After expanding, we get the following state:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lq"><img src="../Images/61172dd5c025cee364832677dcc26d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*NVcYJII5HuCf8u_q9CaDgw.png"/></div></figure><p id="5e0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">In the figure above, the value of the sum is 6. Since sum &lt; desired, we expand again.</p><p id="8b0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">After expanding, we get the following state:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lr"><img src="../Images/2012c9407ed274f8643a5b93885dfb47.png" data-original-src="https://miro.medium.com/v2/resize:fit:724/format:webp/1*EdqESvxAV4JVu5YVADEgwg.png"/></div></figure><p id="a93c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">In the figure above, the value of the sum is 10. Since the sum is greater than the desired value, i.e., 9, we decide to shrink the subarray. Shrinking the subarray will help us reduce the sum and increase the chances of finding the desired value.</p><p id="24bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">要收缩，我们做如下操作:</strong></p><ul class=""><li id="bef9" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ln kj kk kl bi translated">用'<em class="jc"> beg </em>所指向的元素的值减少<em class="jc"> sum </em>，即<br/><em class="jc">sum</em>-= arr[<em class="jc">beg</em>]</li><li id="f68d" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ln kj kk kl bi translated">向右移动'<em class="jc"> beg </em>'指针，即(<em class="jc"> beg </em> ++)</li></ul><p id="520c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">收缩后，我们得到以下状态:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es ls"><img src="../Images/1e9bcbd5b5304a7b22d354578062b2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*ZcfVmwxlDI2TkqQE6HXERg.png"/></div></figure><p id="a770" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此时，我们看到sum的值是9，等于期望值。</p><p id="3250" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，使用2指针方法，我们已经成功地找到了给出期望的和9的子阵列。</p><h2 id="6c0a" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">设计2指针方法时需要考虑的事项:</h2><p id="a274" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在使用2指针方法时，需要考虑的4个设计问题是:</p><ol class=""><li id="5a9a" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">什么时候扩大/缩小？</strong></li><li id="a98c" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">扩张/收缩将帮助我们实现什么？</strong></li><li id="f9ee" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">如何扩大/缩小？</strong></li><li id="04b9" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">数组的顺序正确吗？</strong></li></ol><p id="cdd2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们看看我们讨论过的例子，并试图回答这些问题；解决方案如下:</p><ol class=""><li id="a989" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">什么时候扩大/缩小？</strong>当总和&lt;需要时<br/>展开。<br/>当需要总和&gt;时收缩。</li><li id="61d8" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">扩张/收缩将帮助我们实现什么？ <br/>扩展帮助我们<strong class="ig hi">增加</strong>子阵列的大小和总和。<br/>缩小帮助我们<strong class="ig hi">减小</strong>子阵列的大小和总和。</li><li id="a2dd" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">如何扩大/缩小？</strong> <br/>通过<strong class="ig hi">增加<em class="jc"> ed </em> </strong>然后<strong class="ig hi">增加<em class="jc"> sum </em> </strong> <em class="jc">来展开。</em> <br/>收缩通过<strong class="ig hi">减少<em class="jc">总和</em> </strong> <em class="jc"> </em>然后<strong class="ig hi">递增<em class="jc">求</em> </strong> <em class="jc">。</em></li><li id="a8ea" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">数组的格式/顺序是否正确？</strong> <br/>如果数组格式不正确，那么将违反问题2的答案。换句话说，如果数组格式不正确，我们就不能很有信心地说:<br/> i .扩展增加了<em class="jc"> sum </em>，和，<br/> ii。缩小减少了<em class="jc">和</em></li></ol><p id="6c5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，因为我们只有正数，我们知道</p><ol class=""><li id="1d96" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">扩展将使<em class="jc"> ed </em>指向一个大于0的新值。由于该值将大于0，<em class="jc">和</em>的值将总是在扩展时增加。</li><li id="84e1" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">缩小将会删除由<em class="jc"> beg </em>指向的子数组的值。由于该值将大于0，<em class="jc"> sum </em>的值将总是随着收缩而减小。</li></ol><p id="b1c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们在解决2指针问题时需要记住的。有了这个细节，我们来试试LeetCode的几个问题。</p><h1 id="c6d1" class="lt je hh bd jf lu lv lw jj lx ly lz jn ma mb mc jq md me mf jt mg mh mi jw mj bi translated">LeetCode问题:</h1><h2 id="0d47" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">问题1:最小子阵列和</h2><p id="3451" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">请阅读下面链接中的问题，并尝试自己解决。只有在你完成尝试后，才阅读解决方案。</p><div class="mk ml ez fb mm mn"><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">最小尺寸子阵列和- LeetCode</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">给定一个由n个正整数和一个正整数s组成的数组，求…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">leetcode.com</p></div></div><div class="mw l"><div class="mx l my mz na mw nb lb mn"/></div></div></a></div><p id="6058" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我不会提供解决方案，因为它在LeetCode的<a class="ae nc" href="https://leetcode.com/problems/minimum-size-subarray-sum/solution/" rel="noopener ugc nofollow" target="_blank">解决方案</a>部分的方法#4中有很好的解释。我还建议您从那里阅读代码，因为这是一个框架良好的代码，可以让您不必考虑各种极端情况。</p><p id="e8f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不过，我会试着解释一个人遇到这样的问题应该如何思考。</p><p id="1596" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">问题中需要注意的几件事:</p><ol class=""><li id="d9d3" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">我们得到了一个<strong class="ig hi">数组，</strong>和<strong class="ig hi"> </strong>数组的每个元素都是一个<strong class="ig hi">正数。</strong></li><li id="8bd6" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">我们必须找到最小长度的<strong class="ig hi">子阵列</strong>。</li><li id="4406" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">使得子阵列的<strong class="ig hi">和≥ s </strong></li></ol><p id="8373" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着我们必须<strong class="ig hi">找到一个子阵列</strong>，使得<strong class="ig hi">满足条件</strong>即<strong class="ig hi"> sum ≥ s </strong>。这清楚地表明我们应该使用<strong class="ig hi"> 2指针方法</strong>。</p><p id="29da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">事实上，这个问题与我们上面讨论的例子非常相似。如果我们尝试回答上面看到的4个设计问题，我们看到的唯一区别是第一个问题的答案，即:</p><ol class=""><li id="5d2b" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">什么时候扩大/缩小？</strong> <br/>当总和&lt;需要时展开。<br/>收缩当<strong class="ig hi"> <em class="jc">总和≥期望</em> </strong>时。(注意区别)</li></ol><p id="3957" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除此之外，其他一切都保持不变。</p><p id="06d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">边题1: </strong>对于这个LeetCode问题，你认为数组的格式/顺序是正确的吗？<br/> <strong class="ig hi">提示:</strong>你能很有信心地说，膨胀时和增加，收缩时和减少吗？<br/> <strong class="ig hi">答:是的，</strong>因为所有的值都是正的，所以和在扩大时增加，在缩小时减少。因此，数组的格式/顺序是正确的。</p><p id="d071" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">附带问题2: </strong>如果数组有负值，你认为数组的格式/顺序是否正确？<br/> <strong class="ig hi"> Ans: </strong> <strong class="ig hi">不，</strong>那么，这个数组就不会有正确的顺序。我们可以扩展数组，使其包含一个可能会减少总和的负值。因此，在扩展时，总和会减少，因此我们可以得出结论，数组的格式不正确。</p><h2 id="61bd" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">问题2:数组中的K-diff对</h2><p id="3397" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">这个问题可以使用比2指针方法更好的方法来解决。然而，既然我们已经讨论了2指针方法，我将尝试使用2指针方法来解决它。以下是问题的链接:</p><div class="mk ml ez fb mm mn"><a href="https://leetcode.com/problems/k-diff-pairs-in-an-array/" rel="noopener  ugc nofollow" target="_blank"><div class="mo ab dw"><div class="mp ab mq cl cj mr"><h2 class="bd hi fi z dy ms ea eb mt ed ef hg bi translated">数组中的K-diff对- LeetCode</h2><div class="mu l"><h3 class="bd b fi z dy ms ea eb mt ed ef dx translated">给定整数数组nums和整数k，返回数组中唯一k-diff对的数量。一个k差分对…</h3></div><div class="mv l"><p class="bd b fp z dy ms ea eb mt ed ef dx translated">leetcode.com</p></div></div><div class="mw l"><div class="nd l my mz na mw nb lb mn"/></div></div></a></div><p id="6275" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要注意的几件事:</p><ol class=""><li id="301b" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">给定一个<strong class="ig hi">整数数组</strong></li><li id="836f" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">找到<strong class="ig hi">唯一的</strong>对，</li><li id="f35e" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">使得<strong class="ig hi">对之间的间隙为k </strong></li></ol><p id="ff91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们看到已经给了我们一个数组，我们需要找到一对。这是我们可以使用2指针方法的另一个迹象。</p><p id="c387" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们会想到一个解决方案，其中第一个指针将引用该对的第一个值，第二个指针将引用该对的第二个值。我们的差距将被定义为:<strong class="ig hi">差距= |arr[ed]-arr[beg]| </strong></p><p id="f29a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参考下图，以便更好地理解:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es ne"><img src="../Images/ca3afe5d104822ef573ccdbe96c19f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*ZqAK7aZ21gO5S8gDkOfcVw.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">执行期间数组和指针的假想快照</figcaption></figure><p id="a839" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们尝试阐明4个设计问题:</p><ol class=""><li id="ae4c" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated"><strong class="ig hi">什么时候扩大/缩小？<br/> </strong>当所需间隙&lt;时膨胀<br/>当所需间隙≥时收缩</li><li id="d45f" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">扩张/收缩将帮助我们实现什么？<br/> </strong>膨胀<strong class="ig hi">要么增大</strong>间隙，要么保持不变。<br/>收缩<strong class="ig hi">减小</strong>间隙或保持不变。</li><li id="e05d" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">如何扩大/缩小？<br/> </strong>递增扩展<em class="jc"> ed <br/> </em>递增收缩<em class="jc"> beg </em></li><li id="7174" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated"><strong class="ig hi">数组的格式/顺序是否正确？<br/> </strong>让我们想象一下，在执行我们的算法时，我们遇到了如下图所示的假设情况:</li></ol><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es ne"><img src="../Images/ca3afe5d104822ef573ccdbe96c19f7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:252/format:webp/1*ZqAK7aZ21gO5S8gDkOfcVw.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">执行期间数组和指针的假想快照</figcaption></figure><p id="59d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们遇到这样的情况，那么在扩展时，我们将增加<em class="jc"> ed </em>。这将导致<em class="jc"> ed </em>指向一个比之前指向的更小的值。这样一来，差距就会缩小。为了清楚起见，请看下图:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nf"><img src="../Images/5a5d6cbddbf177567250e2944fc797d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*_u2SYr_P4mqWTMP_UYMDcg.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">膨胀时间隙减小——违反了设计问题2。</figcaption></figure><p id="ecb3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者，如果我们收缩，<em class="jc"> beg </em>将开始指向一个比它之前指向的值更大的值，并且差距将增大。为了清楚起见，请看下图:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ng"><img src="../Images/bdacc55d21546cc4998f033dc230e0c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*m-x-plfb2lTQaynKVbAuyA.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">收缩时间隙增大——违反了设计问题2。</figcaption></figure><p id="9bba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着当前阵列违反了第二个设计问题。<strong class="ig hi">因此，数组的格式/顺序不正确。</strong></p><blockquote class="lh li lj"><p id="ed25" class="ie if jc ig b ih ii ij ik il im in io lk iq ir is ll iu iv iw lm iy iz ja jb ha bi translated">在这种情况下，我们用<strong class="ig hi">对</strong>数组进行排序，使其变成正确的格式。</p></blockquote><p id="3edb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将数组按升序排序后，可以说数组的顺序是正确的，不违反第二个设计问题的答案。通过查看下图可以更好地理解这一点:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nh"><img src="../Images/f72950a58d973ecbfb1e8afb1ea8ebbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*AU-DLTiS5Kh5DzbrqRHsyg.png"/></div></figure><p id="0e6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上图中，我们可以观察到:</p><ol class=""><li id="721d" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">在扩展时，<em class="jc"> ed </em>将开始指向一个大于或等于它所指向的值的值。因此，在膨胀时，间隙将增加或保持不变。</li><li id="2c6b" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">收缩时，<em class="jc"> beg </em>将开始指向一个大于或等于它所指向的值的值。因此，在膨胀时，间隙将减小或保持不变。</li></ol><p id="63fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止，我们已经处理好了几乎所有的事情，除了一件事:“我们还没有讨论处理这一对的独特性。”好吧，让我们试着想出一个算法，看看我们将如何处理这种情况:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ni"><img src="../Images/d76c6c24e8fe1cf942c296ece9f72a78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D5_r_PYqLFrYnVhaRMnzig.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">k-diff对的算法。</figcaption></figure><p id="5085" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们以array = [1，1，1，2，3]和k = 1为例，通过它找出解决方案。下图用这个例子来解释算法。在图的左上方，我们可以看到指针和数组的初始状态。箭头显示了算法的步骤(上面给出了图)。这些步骤将数组和指针的状态更改为新的状态。</p><p id="4796" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请花些时间浏览下面给出的图表并理解这种方法。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es nj"><img src="../Images/4e6fb26c57c5c4de723d82ba80189806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*b28BRz106bQNrCwiVhjTZQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">k-diff对2指针演示</figcaption></figure><p id="57ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们在上面的图像中看到的，唯一的对正在被自己处理。这是由于算法的步骤4a而发生的。它检查beg指向的前一个值是否与当前值相同，然后已经计算了该值的有效对，没有必要再次计算对。</p><p id="63a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">时间复杂度:</strong>由于排序，算法整体时间复杂度为<strong class="ig hi"> O(nlogn) </strong>。然而，只有双指针方法的复杂度是O(n ),因为两个指针— <em class="jc"> beg </em>和<em class="jc"> ed — </em>只遍历数组一次。</p><p id="f725" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">代码:</strong>代码参见<a class="ae nc" href="https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/995934/Java-two-pointers" rel="noopener ugc nofollow" target="_blank">此</a>链接。</p><p id="8391" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的代码将有助于理解解决方案。但是，在上面的代码中，<em class="jc">右</em>指针(或<em class="jc"> ed </em>)被初始化为<strong class="ig hi">右=左+ 1 </strong>。在我们的例子中，我们将其定义为<strong class="ig hi"> ed = max(ed，beg + 1) </strong>。这两种解决方案都可行，但进一步分析它们将是一个很好的练习。</p><p id="69a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我的感受</strong>:如果我考虑一个arr = [1，1，1，2，3，5，6]和k = 4的例子，我发现如果我们使用<br/> <strong class="ig hi"> ed = max(ed，beg + 1) </strong>可以避免一些多余的运算。然而，如果不是这样，请让我知道。我非常感谢你能提供的任何帮助。😃</p><h2 id="26e7" class="jd je hh bd jf jg jh ji jj jk jl jm jn ip jo jp jq it jr js jt ix ju jv jw jx bi translated">结论</h2><p id="9fb9" class="pw-post-body-paragraph ie if hh ig b ih jy ij ik il jz in io ip ka ir is it kb iv iw ix kc iz ja jb ha bi translated">在这篇博客中，我们试图理解解决与2指针相关的问题的方法。通过更多的练习，读者将会成功地识别一个两个指针的问题，并仔细思考4个设计问题，提出一个解决问题的算法。这种思考4个设计问题的技巧不是一个标准。这是我在试图解决此类问题时遵循的原则。请随意提出你自己处理这个问题的方法。</p></div></div>    
</body>
</html>