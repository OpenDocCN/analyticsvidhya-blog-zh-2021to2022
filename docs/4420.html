<html>
<head>
<title>Girvan–Newman — The Clustering Technique in Network Analysis Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">格文-纽曼——网络分析中的聚类技术第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/girvan-newman-the-clustering-technique-in-network-analysis-27fe6d665c92?source=collection_archive---------2-----------------------#2021-10-11">https://medium.com/analytics-vidhya/girvan-newman-the-clustering-technique-in-network-analysis-27fe6d665c92?source=collection_archive---------2-----------------------#2021-10-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/35ac0edba061925eabd6e6781f7b769a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ikdeKXxEfHDnTBTS"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">在<a class="ae hv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae hv" href="https://unsplash.com/@merakist?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Merakist </a>拍摄的照片</figcaption></figure><div class=""/><p id="9790" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">格文-纽曼方法根据边的介数来分离网络。</p><h1 id="5046" class="jt ju hy bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="d530" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如今，随着技术的进步，网络分析的重要性越来越受到人们的关注。许多系统都是以网络的形式出现的，我们可以在与网络相关的数据应用中使用网络分析。例如，我们可以在社交媒体平台(如脸书或Twitter)的好友建议中使用网络分析。此外，我们还可以根据CRM(客户关系管理系统)找到潜在客户。</p><p id="485f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">格文-纽曼方法是经典的社区聚类技术之一。通过使用该算法，我们可以将网络划分为社区，社区发现可以作为数据预处理的一个良好开端。</p><blockquote class="kw kx ky"><p id="8390" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">参考:格文M，纽曼ME (2002)社会和生物网络中的社区结构。美国国家科学院学报99(12):7821–7826</p></blockquote></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="6c37" class="jt ju hy bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">社区检测</h1><p id="7463" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">格文-纽曼将在每次迭代中移除具有最大<strong class="ix hz">边介数</strong>的边。</p><blockquote class="kw kx ky"><p id="78d5" class="iv iw kz ix b iy iz ja jb jc jd je jf la jh ji jj lb jl jm jn lc jp jq jr js hb bi translated">边介数:通过该边的最短路径数。</p></blockquote><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/11d02d7c06254739edce9abd05faeb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*ak3BbrzghPa_yO1cq_Fnww.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图一。GN示例</figcaption></figure><p id="bc3e" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从图中可以看出，边{D，E}将具有最大的边介数。通过去除边缘，它将形成两个社区。</p><h2 id="a1ce" class="lu ju hy bd jv lv lw lx jz ly lz ma kd jg mb mc kh jk md me kl jo mf mg kp mh bi translated"><strong class="ak">格文-纽曼迭代:</strong></h2><p id="f4ad" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，我们需要计算图中每条边的边介数</p><ol class=""><li id="cdab" class="mi mj hy ix b iy iz jc jd jg mk jk ml jo mm js mn mo mp mq bi translated">选择一个节点X，进行BFS，找出从节点X到每个节点的最短路径数，并将这些数作为得分分配给每个节点。</li><li id="08a7" class="mi mj hy ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">从叶节点开始，我们通过(1 +(节点的边信用的总和))*(目的节点的分数/起始节点的分数)来计算边的信用</li><li id="f096" class="mi mj hy ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">计算图G中所有边的边信用，并从步骤1开始重复。直到选择了所有的节点</li><li id="111b" class="mi mj hy ix b iy mr jc ms jg mt jk mu jo mv js mn mo mp mq bi translated">将我们在步骤2中计算的所有边信用值相加，然后除以2，结果就是边的边介数。</li></ol><p id="ec84" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们移除具有最高介数的边，并且重复直到我们找到好的社区分裂。</p><p id="e873" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">5.移除中间值最高的边</p><p id="91e1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">6.计算社区分裂的模块性Q</p><p id="472c" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">7.如果Q大于0.3–0.7，从步骤1开始重复。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/344787514c909276d3661f5cfc4eb7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oCvsgi-QMkYnmkn-pJKgA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">模块化公式</figcaption></figure><h2 id="8f71" class="lu ju hy bd jv lv lw lx jz ly lz ma kd jg mb mc kh jk md me kl jo mf mg kp mh bi translated">例子</h2><p id="2fd1" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将以下图为例。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es lp"><img src="../Images/91b73c1d2f877b143540e9d16f03f008.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*201q_zsik7XCPKMXK9_mHg.jpeg"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图二。示例图表</figcaption></figure><p id="ad26" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们选择节点H，找出从节点H到每个节点的最短路径数。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es mx"><img src="../Images/93c7d6f1b7d846a06cc4e58225a33f01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*7u-7DJGBI-5nEkfWCG6Zjw.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图3。第一步</figcaption></figure><p id="10a4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们把图表重新排列成树状，这样更容易理解。</p><p id="9e4a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">很明显，从节点G到H的最短路径只有一条，就是{GH}。因此，我们将1赋给节点G作为节点得分。</p><p id="d3f2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，从节点F有2条最短路径，它们是{FEH，FGH}。</p><p id="f48a" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">边EG和AC可以被忽略，因为它们的节点在BFS树中处于相同的深度，并且在计算最短路径时不会被考虑在内。</p><p id="d272" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要使用下面的公式计算从叶节点(节点B)开始的每条边的信用，其中分数是在步骤1中计算的。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es my"><img src="../Images/1e21f61820ba09edf70723aaab955efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/1*FeLlWlcJRbidSVkc5Nmk6g.gif"/></div></figure><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mz"><img src="../Images/7177901823b8db4b7a87e1d488614a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HzRHtT3rnNeB1qVVEQIieA.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图4。第二步</figcaption></figure><p id="c2d7" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们从叶节点(节点B)开始，没有到节点B的传入边，我们把最初的1拆分成两条边，所以BA = BC = 0.5。根据公式，我们可以计算上图中的每个边缘信用。</p><p id="b256" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们选择一个不同的节点，并重复相同的过程，直到所有的节点都被选中。图5显示了选择节点G的情况。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div class="er es na"><img src="../Images/d7ebaca4db6d0baa736ae179df7f8f7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*c2gfyHVzPg3P96ttyyjndg.png"/></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图5。选择节点G</figcaption></figure><p id="1ed5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">选择所有节点后，我们将步骤2中计算的所有边信用值(图中的红色数字)相加，然后除以2。图6显示了图的结果边介数中心性。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es nb"><img src="../Images/e2c0bb12055239db0d946066935abccc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bTPj9Id9nVegEnSZH2cLQ.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">图6。边介数中心性</figcaption></figure><p id="45ea" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不出所料，DE具有最高的边介数，从而我们去掉了边DE，形成了两个社区。</p><p id="9321" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">接下来，我们需要计算模块性Q，看看它是否是一个有效的分区。如果Q不满足模块化阈值，我们使用更新的图从第一步开始重复。</p><figure class="lq lr ls lt fd hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es mw"><img src="../Images/344787514c909276d3661f5cfc4eb7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-oCvsgi-QMkYnmkn-pJKgA.png"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">模块化公式</figcaption></figure><p id="13f0" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">，在哪里</p><ul class=""><li id="ec3b" class="mi mj hy ix b iy iz jc jd jg mk jk ml jo mm js nc mo mp mq bi translated">如果在原始图中节点I连接到节点j，A_ij = 1</li><li id="9fa4" class="mi mj hy ix b iy mr jc ms jg mt jk mu jo mv js nc mo mp mq bi translated">m =原始图中的边数</li><li id="8fc1" class="mi mj hy ix b iy mr jc ms jg mt jk mu jo mv js nc mo mp mq bi translated">k_i，k_j =更新图中节点I，j的度</li></ul></div><div class="ab cl ld le gp lf" role="separator"><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li lj"/><span class="lg bw bk lh li"/></div><div class="hb hc hd he hf"><h1 id="227c" class="jt ju hy bd jv jw lk jy jz ka ll kc kd ke lm kg kh ki ln kk kl km lo ko kp kq bi translated">结论</h1><p id="4217" class="pw-post-body-paragraph iv iw hy ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">聚类方法有很多，格文-纽曼聚类法是利用网络分析的经典划分聚类方法之一。在实践中，我们能够利用聚类技术来简化数据集，并进一步提高模型性能。</p><p id="52da" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">感谢您的阅读，祝您有美好的一天。</p><div class="hh hi ez fb hj nd"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/girvan-newman-the-clustering-technique-in-network-analysis-part-2-a62dfdde11e"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hz fi z dy ni ea eb nj ed ef hx bi translated">格文-纽曼——网络分析中的聚类技术第二部分</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">格文-纽曼方法根据边的介数来分离网络。</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr hp nd"/></div></div></a></div></div></div>    
</body>
</html>