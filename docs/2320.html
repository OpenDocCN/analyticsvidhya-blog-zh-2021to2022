<html>
<head>
<title>Classifying Clothing Categories using Deep Neural Network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用深度神经网络对服装类别进行分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classifying-clothing-categories-using-deep-neural-network-4594ad45ff36?source=collection_archive---------14-----------------------#2021-04-18">https://medium.com/analytics-vidhya/classifying-clothing-categories-using-deep-neural-network-4594ad45ff36?source=collection_archive---------14-----------------------#2021-04-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b9f9b3c89a6489a89dfc0cae3cffa5cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NWMxdPt_dCOUOfdt.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">时尚MNIST数据集</figcaption></figure><p id="5696" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">深度神经网络(DNN) </strong>是一种基本的神经网络，具有<em class="jr">快进</em>的特性，数据从输入层通过几个隐含层流向输出层，而不会倒退。</p><p id="4e36" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">DNN由一组被称为“人工神经元”的相互连接的“节点”组成。这些节点或人工神经元类似于生物大脑中的神经元。神经网络中连接节点的集合，称为“隐藏层”；这是处理输入数据以便产生输出的地方。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/5e1a1201825f4771c764542356fbd4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NK7RIrT7KabBxJVB.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">DNN建筑</figcaption></figure><p id="f49e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">正如你在上面看到的架构，神经元是分层排列的:一个输入层，一个或多个“隐藏”层，以及一个输出层。我们将你试图学习的内容的表示填充到输入层。这些被激活的神经元影响下一层神经元的权重。这些权重会影响该层神经元的激活方式，从而影响下一层的权重，以此类推，直到最终到达输出层，网络在那里进行预测。</p><h1 id="e88f" class="jx jy hh bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">时尚MNIST数据集-图像服装类别分类器</h1><p id="9ede" class="pw-post-body-paragraph it iu hh iv b iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm kz jo jp jq ha bi translated">在本教程中，我们将尝试构建一个简单的深度神经网络(显然使用Python)，它可以从服装图像中分类出10个类别。时尚MNIST是一个伟大的数据集开始建立这个图像分类器。它包含60，000个样本的训练集和10，000个样本的测试集。每个示例是一个28x28灰度图像，与来自10个类别的标签相关联。你可以在这里找到这个数据集的完整文档:<a class="ae la" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">时尚MNIST </a>。</p><blockquote class="lb lc ld"><p id="7aa7" class="it iu jr iv b iw ix iy iz ja jb jc jd le jf jg jh lf jj jk jl lg jn jo jp jq ha bi translated"><strong class="iv hi"> **免责声明:在本教程中，我们并不打算构建一个具有完美准确性的模型，本教程的目标只是通过练习使用Keras构建一个简单的模型来了解神经网络的架构和工作原理** </strong></p></blockquote><p id="ff78" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">好了，让我们跳到代码！</p><p id="92b6" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">导入库</strong></p><p id="fbd9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">首先，像我们一直要做的那样，导入所有需要的库，这样我们就可以继续输入了。</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="837f" class="lm jy hh li b fi ln lo l lp lq">import tensorflow as tf<br/>from tensorflow.keras.models import Sequential <br/>from tensorflow.keras.layers import Dense, Flatten<br/>import matplotlib.pyplot as plt</span></pre><p id="5df4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可以尝试打印Tensorflow版本，以确保我们在本练习中使用相同的版本。目前，我使用的是2.4.1版本。</p><p id="419a" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">导入数据集</strong></p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="ff18" class="lm jy hh li b fi ln lo l lp lq">mnist = tf.keras.datasets.fashion_mnist<br/>(training_images, training_labels), (test_images, test_labels) = mnist.load_data()</span></pre><p id="2db0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">时尚MNIST数据集附带Tensorflow库。您可以使用<code class="du lr ls lt li b">load_data()</code>功能导入数据集。它有四个对象；<em class="jr">训练图像，训练标签，测试图像，测试标签</em>。</p><p id="2168" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">让我们试着从training_images中打印一个数据。</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="a1b1" class="lm jy hh li b fi ln lo l lp lq">plt.imshow(training_images[42])<br/>print(training_labels[42])<br/>print(training_images[42])</span></pre><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/2ce7e5c97e6648f079817de0b78d964c.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*GLvm8YPnw_ZBWq-SXaKMqw.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">踝靴</figcaption></figure><p id="2ad4" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">正常化</strong></p><p id="cf81" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">在我们进一步进行建模之前，我们想先对我们的数据进行规范化，这样它将包含一个从0到1的一致的范围数。</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="eb88" class="lm jy hh li b fi ln lo l lp lq">training_images = training_images / 255.0<br/>test_images = test_images / 255.0</span></pre><p id="c654" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">为什么我们必须对数据进行标准化？很高兴你这么问。我们实际上不需要标准化数据，因为它是可选的。标准化数据消除了有偏差的权重，也降低了我们的网络试图解决的问题的复杂性。</p><p id="7192" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这么说吧，我们有两个属性的数据:年龄和收入。年龄通常在0到100之间。收入在10000到100000英镑之间。现在你明白问题所在了吧？如果我们直接将这种数据进行建模，那么我们将会有一个有偏见的权重，因为我们的模型将收入视为比年龄更重要的特征，因为它具有更大的价值。</p><p id="3e5d" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">建造模型</strong></p><p id="84e8" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">这是我们旅程的核心，建立一个模型，这样我们就可以训练我们的机器理解我们数据集中服装图像之间的差异。</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="6f71" class="lm jy hh li b fi ln lo l lp lq">model = Sequential()<br/>model.add(Flatten()) # takes a square and turns it into a 1-D vector<br/>model.add(Dense(128, activation='relu')) # neurons<br/>model.add(Dense(10, activation='softmax')) # another neurons</span></pre><p id="88c3" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">如果您想知道该模型中的术语是什么，下面是每行的简要解释:</p><ul class=""><li id="f062" class="lv lw hh iv b iw ix ja jb je lx ji ly jm lz jq ma mb mc md bi translated"><strong class="iv hi"> Sequential </strong>是一个神经网络(NN) API，它简单地将Keras层按顺序排列。大多数神经网络具有顺序的层，并且数据以给定的顺序从一层流到另一层，直到数据最终到达输出层。简单地说，你可以说Sequential是一个强制性的东西，必须放在你想要建立一个模型之前。</li><li id="af63" class="lv lw hh iv b iw me ja mf je mg ji mh jm mi jq ma mb mc md bi translated"><strong class="iv hi">扁平化</strong>，顾名思义，它会把我们的数据扁平化，变成一个一维向量(矩阵变成单个数组)。如果你仍然困惑，看看下面的图片:</li></ul><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/456562a6ae922bdbd48a5e28efd4cda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*231ZRsNiAIrKLqfF.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">展平解释</figcaption></figure><ul class=""><li id="c4b5" class="lv lw hh iv b iw ix ja jb je lx ji ly jm lz jq ma mb mc md bi translated"><strong class="iv hi">密集</strong>，它是我们的神经元，它是常规的深度连接的神经网络层，将完成所有计算。我们可以这样描述密集对简单的5行代码的实际影响:</li></ul><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="82e3" class="lm jy hh li b fi ln lo l lp lq">import numpy as np<br/>input = [ [1, 2], [3, 4] ] # input from our dataset<br/>kernel = [ [0.5, 0.75], [0.25, 0.5] ] # weight data<br/>result = np.dot(input, kernel) # calculations based on the activation<br/>result array([[1. , 1.75], [2.5 , 4.25]]) # output from dense</span></pre><p id="9b18" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们的模型还没完成。构建完美模型的最后一步是先编译。</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="2c72" class="lm jy hh li b fi ln lo l lp lq">model.compile(optimizer=tf.keras.optimizers.Adam(), loss='sparse_categorical_crossentropy', metrics=['accuracy'])</span></pre><p id="0d74" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">使模型适合训练集</strong></p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="096b" class="lm jy hh li b fi ln lo l lp lq">model.fit(training_images, training_labels, epochs=5)</span></pre><p id="285f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="jr">有哪些纪元？</em>基本上就是我们要从一个循环中循环计算多少次的步骤。一个时期是指整个数据集仅通过神经网络传递一次。</p><p id="713f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">运行上面的代码后，我们将得到如下输出:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es mk"><img src="../Images/40f57010f1e3c915632b37f07ffcc27c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*IgxGuLUFTeI5Gx5kSX50CQ.png"/></div></figure><p id="8cf9" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">每个历元有两个输出参数，分别是<em class="jr">损耗</em>和<em class="jr">精度</em>。就优化而言，损失是收敛指标；这意味着它会告诉您模型的预测值与输入的真实值之间的差距。然而，准确性被定义为测试数据或训练数据的正确预测的百分比，因为我们没有在拟合函数上设置验证测试。</p><p id="eec0" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">从上面的输出，我们可以看到我们的损失在减少，而精度在提高。这可能意味着我们的模型计算和学习时代的每一步。由于我们只使用了5个历元，我们在训练集上得到了89%的准确率；这是一个很好的百分比，但我们已经通过在我们的验证/测试集上测试来验证该模型。</p><p id="213b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">使用测试集</strong>验证模型</p><pre class="jt ju jv jw fd lh li lj lk aw ll bi"><span id="b6e2" class="lm jy hh li b fi ln lo l lp lq">model.evaluate(test_images, test_labels)</span></pre><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/2538792ebe2e5fef836aecb23c1d4453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*mgvvffNHnxVXS-vlb7pvRA.png"/></div></figure><p id="6a00" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我们从测试集中得到了最终的准确率，是86%。通过从准确性(训练和测试)进行比较，我们可以简单地说，我们有一个过拟合模型，因为我们的模型往往在训练上具有高准确性，但在测试上具有低准确性。这意味着我们的模型在训练中学习了很多好的东西，但却不能推广看不见的数据。但是在我看来，86%的测试和89%的训练仍然是一个可以接受的模型。</p><p id="171e" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">您可以通过减少网络层的数量或添加一个断开层来解决此类问题。但与此同时，我们在这之前都很好。</p></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="c46f" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><strong class="iv hi">未来改进</strong></p><ul class=""><li id="6882" class="lv lw hh iv b iw ix ja jb je lx ji ly jm lz jq ma mb mc md bi translated">使用一个<code class="du lr ls lt li b">Dropout</code>层来消除过度拟合问题</li><li id="58db" class="lv lw hh iv b iw me ja mf je mg ji mh jm mi jq ma mb mc md bi translated">使用卷积和池来提高模型的准确性</li><li id="abca" class="lv lw hh iv b iw me ja mf je mg ji mh jm mi jq ma mb mc md bi translated">添加一些层和时代(显然)将是一个伟大的想法</li></ul></div><div class="ab cl mm mn go mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ha hb hc hd he"><p id="c422" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated"><em class="jr">参考文献:</em></p><ul class=""><li id="1e45" class="lv lw hh iv b iw ix ja jb je lx ji ly jm lz jq ma mb mc md bi translated"><a class="ae la" href="https://www.tutorialspoint.com/keras/" rel="noopener ugc nofollow" target="_blank"> <em class="jr"> Keras教程—教程要点</em> </a></li><li id="5ffe" class="lv lw hh iv b iw me ja mf je mg ji mh jm mi jq ma mb mc md bi translated"><a class="ae la" href="https://www.tensorflow.org/tutorials/keras/classification" rel="noopener ugc nofollow" target="_blank"> <em class="jr">基本分类:对服装图像进行分类| TensorFlow Core </em> </a></li><li id="98d6" class="lv lw hh iv b iw me ja mf je mg ji mh jm mi jq ma mb mc md bi translated"><a class="ae la" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank"><em class="jr">zalandoresearch/fashion-mnist:一个类似mnist的时尚产品数据库。</em>基准(github.com)</a></li></ul></div></div>    
</body>
</html>