<html>
<head>
<title>Predicting the future using Machine Learning part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用机器学习预测未来第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-ii-fb45806e5b71?source=collection_archive---------19-----------------------#2021-01-07">https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-ii-fb45806e5b71?source=collection_archive---------19-----------------------#2021-01-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a1c7" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">Python中多项式模型+的实现</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/c5a44bd277ae977576676361de34a7ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uHKxXLKpLX5msWmY"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">照片由<a class="ae jm" href="https://unsplash.com/@ffstop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Fotis Fotopoulos </a>在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="9bd8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在“使用机器学习预测未来”系列的第二部分中，我将进一步阐述如何为我在<a class="ae jm" href="https://minasuntea.medium.com/predicting-the-future-using-machine-learning-part-i-48da5d48a40f" rel="noopener">的前一部分</a>中使用的相同数据集找到一个更好的通用模型。</p><h2 id="39f5" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">多项式模型</h2><p id="87c3" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">要形成多项式模型，需要多项式数据。这可以通过将我之前使用的线性数据集扩展为高阶多项式数据集来轻松检索，方法是将原始输入扩展为高阶多项式的幂，并为模型添加额外的权重。</p><p id="4973" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我编写了一个函数，在给定数据点和指定顺序的情况下，以矩阵的形式创建一个多项式数据集，我称之为<em class="lj"> k. </em>为了便于计算，我用一个1的向量扩展了数据集，它表示常数<em class="lj">权重w0 </em>:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lk"><img src="../Images/08d12b74ca73e98bdd9c313d278a86e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MNazZwDPqabL37mLZbEQLw.png"/></div></div></figure><p id="a6f7" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我选择了2阶，因此我的多项式数据集如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ll"><img src="../Images/10a24861bdc282312a886b8482231c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*DuxSKlvBhbvK3P81DLyUxw.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">使用numpy数组创建D_matrix</figcaption></figure><p id="fa5c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">单个输入的假设具有以下形式:</p><blockquote class="lm ln lo"><p id="213a" class="jn jo lj jp b jq jr ii js jt ju il jv lp jx jy jz lq kb kc kd lr kf kg kh ki ha bi translated">g(x ) <em class="hh"> = </em> ∑ᵢᵏ Dᵢ wᵢ</p><p id="1150" class="jn jo lj jp b jq jr ii js jt ju il jv lp jx jy jz lq kb kc kd lr kf kg kh ki ha bi translated">其中g(x ) =一般模型，i =迭代，beginvalue为0，k =多项式的阶，D = D_matrix，w =权重</p></blockquote><p id="47f0" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这可以写成一个等式中所有输入的矩阵乘法:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ls"><img src="../Images/e8760899c22e892f9cb87655c535cb27.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*x4MhDiHLHaWIDx71DT8SBQ.png"/></div></figure><p id="ea02" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我编写了两个函数来计算多项式模型，分别称为<em class="lj"> poly_val </em>和<em class="lj"> poly_model，</em>将计算分为两步。<em class="lj"> poly_val </em>函数使用上述矩阵乘法计算所有输入的值，而<em class="lj"> poly_model </em>函数获取D_matrix和权重向量，并计算相应的假设向量:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lt"><img src="../Images/d044dff3d89ba6ff952502f1411a0929.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q65nJ1ytQz6g8Ohc2AEXiQ.png"/></div></div></figure><p id="97da" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">下一步是用这个模型的<em class="lj">成本函数</em>计算成本。我调用了这个函数<em class="lj"> poly_cost </em>，它使用以下等式返回总成本:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lu"><img src="../Images/91dac45f5614052e48baa2a7d1379714.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*BySKSM0B3heUunE3G8ruTA.png"/></div></figure><p id="344f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在Python中实现这一点给出了:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lv"><img src="../Images/00b1dacfed2ce977e23a5d14ed2c342f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuMpt6gFxuOYPuapXlXfuw.png"/></div></div></figure><p id="f802" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">用矩阵运算可以很容易地解决每个重量的所有偏导数方程。原理和<a class="ae jm" href="https://minasuntea.medium.com/predicting-the-future-using-machine-learning-part-i-48da5d48a40f" rel="noopener">线性模型</a>完全一样，这里我们也只是计算<em class="lj"> w0 </em>和<em class="lj"> w1 </em>。因此，权重向量的最终等式的形式为:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lw"><img src="../Images/7a27b91b5a21ef6628646c9396d8e099.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*LeWBLyAV9zTJqzK_u1tLBQ.png"/></div></figure><p id="bb07" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用numpy内置的转置和求逆函数，这个等式可以很容易地在Python中实现，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lx"><img src="../Images/ae1b77321bdd3980f763e8b3ae73949c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nui2ll9eczjUFKOUOTeVXQ.png"/></div></div></figure><p id="77b8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后，我写了一个在图中绘制多项式的函数，叫做<em class="lj"> poly_plot </em>。我用这个做了一个函数，因为2点不足以绘制拟合，因为它不是线性的。解决这个问题最简单的方法是生成大量的x值作为样本，并计算相应的y值并绘制它们。函数linspace可用于生成样本，样本越多，线越平滑。对这些样本应用<em class="lj"> poly_val </em>函数将提供相应的y值:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/ef3178909223622f669f9cdcc36fdc23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lpLL_MJ0hBg_y7VVYTwMOw.png"/></div></div></figure><p id="7743" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在唯一剩下的事情就是想象合身:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lz"><img src="../Images/7ba9e722c649a5c960989927b23a60ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Gf9vD2ROIPOUXPaQ549fg.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ma"><img src="../Images/413bf62ff32ae05f91be46675aeb5d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*5BzcxxEds3ix__p5v5-B8g.png"/></div></figure><p id="1775" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从上图可以看出，多项式拟合比<a class="ae jm" href="https://minasuntea.medium.com/predicting-the-future-using-machine-learning-part-i-48da5d48a40f" rel="noopener">线性拟合</a>更适合这个数据集。多项式模型的缺点是容易过度拟合。在本系列的下一部分中，我将讨论一种可以应用的方法，该方法选择一种比多项式模型更不容易过度拟合的模型。</p></div></div>    
</body>
</html>