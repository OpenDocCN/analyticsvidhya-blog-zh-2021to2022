<html>
<head>
<title>Improve data processing speeds while using numpy arrays in Python through vectorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过矢量化在Python中使用numpy数组时提高数据处理速度</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/improve-data-processing-speeds-while-using-numpy-arrays-in-python-through-vectorization-49ea6cc9004e?source=collection_archive---------5-----------------------#2021-09-10">https://medium.com/analytics-vidhya/improve-data-processing-speeds-while-using-numpy-arrays-in-python-through-vectorization-49ea6cc9004e?source=collection_archive---------5-----------------------#2021-09-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e7fbdf9c4b2457de0d6ed0c5c461f8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F1vuFJg5UotXqRKVlUtWrA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated"><a class="it iu ge" href="https://medium.com/u/2053395ac335?source=post_page-----49ea6cc9004e--------------------------------" rel="noopener" target="_blank">去飞溅</a></figcaption></figure><p id="2fca" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在许多互联网公司在他们的后端服务器应用程序中使用python。当处理大量数据时，例如，一个为用户给定的大型数据集创建仪表板的应用程序，需要注意的是，数据处理是为用户提供快速响应的瓶颈。此外，在数据科学应用程序中，预处理数据和运行特征生成功能或清理数据集记录的操作对于大量记录来说可能非常耗时。从字面上看，矢量化是python性能提高的原因，因为numpy的矢量化函数使用了优化的预编译C代码。</p><h1 id="03d7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是矢量化？</h1><p id="1520" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">Python是一种动态类型的编程语言，这意味着数据的类型检查发生在运行时。c是一种静态类型的编程语言，所以类型检查发生在编译时。执行过程中的类型检查是一个耗时的过程，这也是python与C相比性能较低的原因，尤其是在for循环中。Numpy的矢量化函数不会为每次迭代执行显式类型检查，从而节省了宝贵的CPU和GPU资源时间。与传统的for循环不同，矢量化意味着函数现在可以并行应用于iterable的许多值。CPU使用SIMD(单指令多数据)来实现更快的速度，从而充分利用更多的内核和并行性。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/1b137b57f5e860d709d56e15077b504f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VZ5ZAHRxhSYZaw3w8a8JNw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated"><a class="it iu ge" href="https://medium.com/u/2053395ac335?source=post_page-----49ea6cc9004e--------------------------------" rel="noopener" target="_blank"> Unsplash </a></figcaption></figure><p id="7db8" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在本文中，我将讨论numpy库中最流行的矢量化函数，比较我的本地计算机与传统for循环相比的速度，以及我们如何对自定义函数进行矢量化</p><h1 id="b67a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">转换操作的矢量化</h1><p id="ce75" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">转换数据是数据预处理的重要部分。例如，对于神经网络，在0和1之间缩放图像像素值，在应用回归模型之前对数据集的某些特征进行对数变换，对数据集的特征进行归一化，等等。</p><p id="bcc3" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们使用sklearn库中的MNIST数据集来比较传统for循环和矢量化的速度。sklearn中的MNIST数据的形状为1797x64。每个图像存储在长度为64的一维numpy数组中</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="f3a4" class="lg ju hh lc b fi lh li l lj lk">Scaling images between 0 and 1 for deep learning applications</span><span id="1727" class="lg ju hh lc b fi ll li l lj lk">#######################################################</span><span id="8536" class="lg ju hh lc b fi ll li l lj lk">#Using traditional for-loops<br/>s = mnist.shape<br/>tic = time.time()<br/>for i in range(s[0]):<br/>    for j in range(s[1]):<br/>        mnist[i][j] = mnist[i][j]/255<br/>toc = time.time()<br/>print("Time taking with training loop is : {0}ms".format((toc-tic)*1000))</span><span id="f62e" class="lg ju hh lc b fi ll li l lj lk">Output - Time taking with training loop is : 96.99487686157227ms</span><span id="d9be" class="lg ju hh lc b fi ll li l lj lk">#Using vectorization<br/>tic = time.time()<br/>mnist = mnist/255<br/>toc = time.time()<br/>print("Time taking with Vectorization is : {0}ms".format((toc-tic)*1000))</span><span id="24d4" class="lg ju hh lc b fi ll li l lj lk">Output - Time taking with Vectorization is : 6.717443466186523ms</span></pre><p id="e1ac" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我们可以清楚地看到，扩展所需的时间提高了10倍。改进的速度取决于您的本地计算机，但是您肯定会看到执行时间的显著改进</p><p id="234a" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">+、-、*、/操作矢量化版本可以通过直接在numpy数组上执行操作来执行</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="c98f" class="lg ju hh lc b fi lh li l lj lk">print(arr * 3) #Multiply array by a number<br/>print((arr/4+100)*3) #Divide each element by 4, then +100 and /3<br/>#Performing vectorized operations on 2 arrays<br/>print(arr1 + arr2) # Element wise addition<br/>print(arr1 * arr2) # Element wise multiplication<br/>print((arr1-arr2)**2) # Eucledian distance<br/>#Ensure the 2 arrays have the same shape</span></pre><p id="bd19" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">通过在数组和标量(int，float对象)之间直接应用基本操作，我们可以节省代码行和执行时间。</p><p id="e83d" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">现在让我们看看日志转换。在执行回归时，尤其是在数据有偏差的情况下，日志转换是必不可少的</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lm"><img src="../Images/80b65790059ac967853c87597f852301.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jNR8-LxO4ySbzao9G8RISQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">波士顿住房数据特征成对绘图</figcaption></figure><p id="282b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">让我们应用波士顿住房数据的对数转换(可以在Kaggle中找到)。对数转换实质上意味着将对数应用于数据集中的每一项</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6235" class="lg ju hh lc b fi lh li l lj lk">#Using traditional for-loop<br/>s = data.shape<br/>tic = time.time()<br/>for i in range(s[0]):<br/>    for j in range(s[1]):<br/>        data[i][j] = math.log(data[i][j])<br/>toc = time.time()<br/>print("Time taken with For-loop: {0}ms".format((toc-tic)*1000))<br/>Output - Time taken with For-loop : 2.0296573638916016ms<br/>#Using vectorized numpy function<br/>tic = time.time()<br/>data = np.log(data)<br/>toc = time.time()<br/>print("Time taken with vectorization: {0}ms".format((toc-tic)*1000))<br/>Output - Time taken with Vectorization : 0.0ms</span></pre><p id="b42b" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">对数的矢量化版本几乎不需要任何时间，它是最小的时间单位。time()无法测量差异。在你自己的电脑上尝试一下，看看有什么不同</p><p id="b208" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">Numpy提供了一系列矢量化的变换函数。所有这些都可以在<a class="ae ln" href="https://numpy.org/doc/stable/reference/routines.math.html" rel="noopener ugc nofollow" target="_blank">https://numpy.org/doc/stable/reference/routines.math.html</a>的链接中找到</p><h1 id="f502" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">线性代数运算的向量化</h1><p id="db44" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">像矩阵乘法这样的线性代数运算被用于像神经网络这样的各种应用中。</p><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lo"><img src="../Images/c3cb1df8104c6c2a32c723f179f844f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0OKKMDca4XVOOxUr"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">通过一层神经网络的输入只不过是矩阵乘法</figcaption></figure><p id="8069" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在神经网络应用中，使用向量化函数将显著减少生产中的训练时间和执行时间。</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="a6f7" class="lg ju hh lc b fi lh li l lj lk">A = np.random.randn(10000).reshape((100, 100))<br/>B = np.random.randn(10000).reshape((100, 100))<br/>C = np.zeros((100, 100))<br/>tic = time.time()<br/>#Using traditional For-Loops<br/>for i in range(100):<br/>    for j in range(100):<br/>        for k in range(100):<br/>            C[i][j] += A[i][k]*B[k][j]<br/>toc = time.time()<br/>print("Time taken by For-Loop: {0}ms".format((toc - tic)*1000))</span><span id="693c" class="lg ju hh lc b fi ll li l lj lk">Output - Time taken by For-Loop: 1195.0178146362305ms</span><span id="8537" class="lg ju hh lc b fi ll li l lj lk">#Using vectorized function of numpy<br/>tic = time.time()<br/>C = np.dot(A, B)<br/>toc = time.time()<br/>print("Time taken by vectorization: {0}ms".format((toc - tic)*1000))</span><span id="9989" class="lg ju hh lc b fi ll li l lj lk">Output - Time taken by vectorization: 1.0304450988769531ms</span></pre><p id="0908" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">使用矢量化函数是一个巨大的改进。我们可以清楚地看到为什么深度学习应用程序更喜欢向量化代码，这可以节省大量的模型训练和部署时间</p><p id="5f73" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">访问https://numpy.org/doc/stable/reference/routines.linalg.html的<a class="ae ln" href="https://numpy.org/doc/stable/reference/routines.linalg.html" rel="noopener ugc nofollow" target="_blank">查看numpy库提供的所有linalg函数</a></p><h1 id="e31a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">向量化自定义函数</h1><p id="edc5" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">尽管numpy库提供了许多矢量化函数，但我们需要在整个数据集中为我们的应用程序应用一个自定义函数，这在numpy库中是不可用的。有一种方法可以让我们使用numpy库对自定义函数进行矢量化</p><p id="6ac0" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">将自定义函数分解成numpy库中可用的矢量化函数。举个例子，</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="6764" class="lg ju hh lc b fi lh li l lj lk">A = np.random.randn(1000)<br/>B = np.zeros(1000)<br/>def func(a):<br/>    return a**2 + 5*a +35 <br/>for i in range(1000):<br/>    B[i] = func(A[i])</span><span id="7111" class="lg ju hh lc b fi ll li l lj lk">#We can vectorize the above func as follows</span><span id="2202" class="lg ju hh lc b fi ll li l lj lk">B = A**2 + 5*A +35</span></pre><p id="b5b0" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如果我们无法在numpy中将自定义函数分解为矢量化函数，我们也可以使用numpy.vectorize函数</p><pre class="kx ky kz la fd lb lc ld le aw lf bi"><span id="57bb" class="lg ju hh lc b fi lh li l lj lk">A= np.random.randn(10000)<br/>C = np.zeros(10000)<br/>def f(a):<br/>    if a&gt;10:<br/>        return a**2<br/>    else:<br/>        return a<br/>tic = time.time() #Using for-loops<br/>for i in range(10000):<br/>    C[i] = f(A[i])<br/>toc = time.time()<br/>print("Time taken: {0}ms".format((toc-tic)*1000))</span><span id="f102" class="lg ju hh lc b fi ll li l lj lk">Output - 10ms</span><span id="7528" class="lg ju hh lc b fi ll li l lj lk">v = np.vectorize(f) #Vectorizing the function<br/>tic = time.time()<br/>C = v(A)<br/>toc = time.time()<br/>print("Time taken: {0}ms".format((toc-tic)*1000))</span><span id="8860" class="lg ju hh lc b fi ll li l lj lk">Output - 2ms</span></pre><h1 id="c9e7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><p id="343b" class="pw-post-body-paragraph iv iw hh ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js ha bi translated">在预处理数值数据时，速度是优先考虑的因素，建议使用通常矢量化的numpy函数，并使用预编译的C代码以获得更好的性能。当涉及大量数据时，这将显著提高后端API的响应时间。</p><p id="a3fb" class="pw-post-body-paragraph iv iw hh ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">在以下链接中找到本文的jupyter笔记本:<a class="ae ln" href="https://github.com/shivaditya-meduri/Articles/blob/ac614ff77bad275834b211813ae0fa2f946aa3e1/Vectorization.ipynb" rel="noopener ugc nofollow" target="_blank">https://github . com/shivaditya-meduri/Articles/blob/AC 614 ff 77 bad 275834 b 211813 AE 0 fa 2 f 946 aa 3 e 1/vectorization . ipynb</a></p></div></div>    
</body>
</html>