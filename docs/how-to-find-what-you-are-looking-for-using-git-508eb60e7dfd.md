# 如何使用 Git 找到你要找的东西

> 原文：<https://medium.com/analytics-vidhya/how-to-find-what-you-are-looking-for-using-git-508eb60e7dfd?source=collection_archive---------18----------------------->

![](img/52cc73bb471da76a1772e0dbcccc55f4.png)

Git 是一个令人难以置信的工具。今天，我们大多数程序员都无法想象没有它会怎样。但同时，它也不是最容易使用的。它有几十个命令，几百个选项，它迫使用户在一个相当低的水平上操作，并且知道它的内部细节。所以，并不是所有人都充分利用它的潜力，这并不奇怪。

因此，当一些程序员面临必须在他们的 Git 存储库中找到一些东西的挑战时，他们经常求助于 GUI Git 客户端中的搜索栏。不幸的是，这种应用程序中的搜索功能通常非常有限，而且在更复杂的场景中也没有用。

这就是为什么在本文中，我给出了几个在 Git 中搜索时会很方便的命令。文章分为现实生活中的用例，使其更加实用和易于使用。

消息中提到…的提交在哪里？

这是比较常见的场景之一。您知道您已经看到了一个提交，比如说，MessageBus，但是您不知道它是何时提交的，甚至不知道它是在哪个分支上提交的。或者，也许你只是在寻找所有提到一些吉拉门票的承诺。或者，您可能有兴趣知道项目历史中有多少修补程序。

在所有这些例子中，最适合使用的命令是 **git log** 。这个命令如此强大和通用，以至于在某种形式上，它是本文中大多数用例的解决方案。

**解决方案:**

> **git log [-i] [ - all] - grep <短语>**

-i -忽略大小写；使用它进行不区分大小写的搜索

- all -搜索所有引用；使用它来搜索所有提交，而不仅仅是那些可从当前分支访问的提交

**举例:**

> **git log-I-all-grep message bus**

上个月……在做什么？

如果我们希望看到由特定的人在特定的日期范围内提交的内容，那么这个选项非常有用。不管我们是否只是想刷新我们正在做的事情的记忆，或者是出于报告的目的，这个命令都给了我们想要的东西。

**解决方案:**

> **git log [ - pretty=fuller] -作者<作者姓名> -开始日期<之后> -结束日期<之前>**

- pretty=fuller - **之后**和**之前**选项根据作者的日期过滤提交，但是日志默认显示提交日期；使用 **pretty** 选项显示作者和提交日期

**例如:**

> **git log - pretty=fuller -作者" Junio C Hamano "-" 2021-01-01t 00:00:00+01:00 "之后"-" 2021-02-01t 00:00:00+01:00 "之前**

谁在何时最后一次修改了文件？

有时我们想知道我们正在看的文件最近是否被修改过，或者我们只需要知道它最后一次被编辑是什么时候，是谁做的。

**解决方案:**

> **git log -1 <文件路径>**

- <n>-要显示的提交数量</n>

**举例:**

> **git log -1 docs/README.md**

**文件的历史是什么？**

在某些情况下，查看一个文件的完整编辑历史是非常有用的，从它被创建开始，通过它的所有修改，直到当前点。我们可能有兴趣看看它是什么时候创建的，或者多久修改一次，或者谁对它的贡献最大。

这个解决方案只是前一个解决方案的概括:我们只需要删除提交次数选项。

**解决方案:**

> **git 日志<文件路径>**

**例如:**

> **git log docs/README.md**

**一个文件的历史是怎样的，包括重命名？**

前一个解决方案很好，但是它有一个缺点:它只显示文件从最后一次重命名以来的历史。

幸运的是，修复这个问题很简单:我们只需要在命令中添加一个选项， **- follow** 。

**解决方案:**

> **git 日志[ -摘要] -跟随<文件路径>**

- summary -显示关于提交的更多信息，在本例中是关于重命名的信息

- follow - continue 即使在文件重命名后仍会提交列表

**例如:**

> **git 日志-摘要-关注脚本/脚本. js**

被删除文件的历史记录是什么？

如果我们试图使用前面的命令来查看一个不再存在的文件的历史，Git 将会响应一个错误:

> > git 日志删除文件
> 
> 致命错误:不明确的参数“deletedFile”:未知版本或路径不在工作树中。
> 使用'-'将路径与修订分开，就像这样:
> 'git <命令> [ <修订>……]-[<文件>……]'

Git 告诉我们，它无法弄清楚“deletedFile”到底是什么。这是因为它无法在工作目录中查找，以确保我们试图提供一个文件名。毕竟，我们也可以传递一个分支名称。所以我们需要用 **-** 把修订和路径分开。

这里有一个很好的例子，可能有助于理解对 **-** 的需求。假设您有一个同名的文件和一个同名的分支，例如 dev。如果您想列出 dev 分支的所有提交，您可以使用下面的命令:

> git 日志开发-

但是如果您想列出所有修改了 dev *文件*的提交，命令应该是:

> git 日志开发

**解决方案:**

> **git log-<file path>**

**举例:**

> **git log - scripts/script.js**

**我不记得路径中已删除文件的历史记录是什么？**

如果你知道一个被删除文件的确切路径，前面的解决方案就像魔咒*一样管用。然而，通常我们只记得文件名或文件名的一部分。*

幸运的是， **git 日志**也接受正则表达式，所以我们可以使用一个模式来代替完整路径。

**解决方案:**

**git log - < regex >**

**示例:**

**git log - *script.js**

**这是谁写的台词！？**

让从来没有愤怒地喊过这些话的人投第一块石头。这一次 Git 又有了一个完美的命令来寻找这个问题的答案。

git fall 命令向我们展示了所选文件的内容，以及每一行最后一次编辑的信息——作者、日期和提交散列。

**解决方案:**

> **git 怪<file path>**

**例如:**

> **饭桶怪 index.html**

**哪个提交添加或删除了这个字符串/正则表达式？**

在某些情况下，git 责备是不够的——例如，我们可能正在检查某个关键行是何时(以及由谁和为什么)添加的，却发现修改它的最后一次提交是一个缩进修正。

这里是所谓的*鹤嘴锄*命令出现的地方。当我们将 **-S** 选项和一个短语一起提供时，Git 将向我们显示所有添加和/或删除包含该短语的行的提交。

然而，使用鹤嘴锄时有两个问题:

*   如果一个短语的出现次数没有变化，它不会显示 commit(例如:如果 commit 用该短语添加了一行，而用同一短语删除了另一行)，
*   它不适用于正则表达式。

解决这两个缺点的方法很简单:用 **-G** 代替 **-S** 即可。

请注意，这两个命令运行起来都很慢。因此，如果我们知道短语出现的具体文件(或路径),我们可以通过在命令末尾提供路径来缩小搜索范围。

**解决方案:**

> **git log -S <短语> [ <文件路径>]
> git log-G<regex>[<文件路径> ]**

**例子:**

> **git log-S Delegate gameview controller . swift
> git log-G UI * Delegate gameview controller . swift**

项目中有字符串吗？

我们可能有兴趣知道某个短语是否出现在当前检出的本地存储库中。

**解决方案:**

> **git grep [-i] <短语>**

-i -忽略大小写；使用它进行不区分大小写的搜索

**举例:**

> **git grep MyP4ssw0rd**

在这个项目中有没有一个字符串？

此外，我们可能想要检查给定的短语是否曾经出现在我们的项目中。

知道了 **git grep** 接受一个提交列表进行搜索，并且为了获得所有提交的散列，我们使用:

> git 版本-列表-全部

我们可能希望使用以下命令:

> git grep <phrase>$(git rev-list - all)</phrase>

不幸的是，如果您的存储库有很长的历史，那就不行了，并且会给您以下错误:

> 参数列表太长:git

那是因为 **git grep** 只能接受一定数量的参数，而 **git rev-list - all** 很容易产生超过这个限制的结果。为了解决这个限制，我们需要使用 **xargs** 。

**解决方案:**

> **git rev-list-all | xargs git grep[-I]<短语>**

**例如:**

> **git rev-list-all | xargs git grep myp 4 ss w0 rd**

对于这个场景，我们也可以使用鹤嘴锄命令，但是如果我们更关心的是 *if* 和 *where* 而不是 *when* **git grep** 会给我们带来稍微好一点的结果。

这种方法有什么历史？

有时，我们可能对整个文件的历史感兴趣，而只是其中的一部分，比如一个方法。Git 也可以做到这一点，它会尽最大努力只显示这些行之间的变化，即使代码在过去被移动过。

**解决方案:**

> **git log -L < startLine >，<end line>:<file path>**

**例子:**

> **git log-L 119233:index . html**

# 摘要

正如您在本文中看到的，在搜索存储库方面，Git 比大多数 GUI 应用程序提供了更多。

我真的希望您学到了一些东西，并且您将在将来更多地利用 Git 命令来挖掘搜索存储库的潜力。或者至少我帮你找到了你想要的解决方案。