<html>
<head>
<title>Optimize your code with Python Generator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python生成器优化您的代码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/optimize-your-code-with-python-generator-9498b6ea1fa4?source=collection_archive---------13-----------------------#2021-03-23">https://medium.com/analytics-vidhya/optimize-your-code-with-python-generator-9498b6ea1fa4?source=collection_archive---------13-----------------------#2021-03-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8ab8ddd095b5314d2ecc1b1c8a00e3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6ctggYHQYPYISxyM"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae it" href="https://unsplash.com/@cakirchoff?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Chad Kirchoff </a>拍摄的照片</figcaption></figure><p id="a0cf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您是否遇到过这样的问题:您的数据结构超出了内存，无法为下一次处理加载所有需要的中间数据，并且无法在每次调用它时维护内部状态？</p><p id="a24d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">听起来耳熟吗？🤔</p><h2 id="d27e" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">欢迎来到发电机的世界</h2><p id="a085" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">嗯，这种情况在编程中很正常，为了避免相同的问题，存在多个解决方案。</p><p id="1ef2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是为了更好地解决这类问题，Python有专门的函数/表达式，通常称为<code class="du ks kt ku kv b"><strong class="iw hi">Generator</strong></code> <strong class="iw hi">。</strong></p><p id="8609" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae it" href="https://wiki.python.org/moin/Generators" rel="noopener ugc nofollow" target="_blank"> python wiki </a>中定义为，</p><blockquote class="kw kx ky"><p id="9cd7" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr ha bi translated"><em class="hh">“生成器函数允许你声明一个行为类似迭代器的函数，也就是说，它可以在for循环中使用。”</em></p></blockquote><p id="7c01" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，Generator只不过是一个函数/表达式，它的行为类似于迭代器。这意味着生成器带有迭代器的属性，即类的<code class="du ks kt ku kv b"><strong class="iw hi">__iter__</strong></code>和<code class="du ks kt ku kv b"><strong class="iw hi">__next__</strong></code>方法。这在软件工程中也被称为<strong class="iw hi">生成器模式</strong>。</p><p id="8549" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们以下面的方式创建用于计算阶乘的生成器模式，</p><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ld"><img src="../Images/ef93267858fa855c79765bf8964d0ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vET3mSPYRmFWsKTUacfs5Q.png"/></div></div></figure><p id="084b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上面的代码为我们提供了一个很好的结构来处理factorial的生成器模式，但是它的实现有点冗长。再往前，问题就冒出来了，</p><p id="1557" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">能不能简单点？</strong></p><p id="186c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看另一个代码更少但实现更智能的代码片段</p><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es li"><img src="../Images/3345768e0799372d72bef43f97cc37a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Lpo9LFs04pn04WHYRNERQ.png"/></div></div></figure><p id="3b87" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们看到代码实现<strong class="iw hi">大大减少了</strong>，但它仍然以更智能的方式服务于相同的目的。</p><p id="824f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述代码片段的另一个有趣点是<code class="du ks kt ku kv b">yield</code> <strong class="iw hi">。这与函数中的<code class="du ks kt ku kv b">return</code>语句行为相同——但是有一个重要的区别</strong></p><blockquote class="kw kx ky"><p id="8ccf" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr ha bi translated">当遇到<code class="du ks kt ku kv b"><strong class="iw hi">yield</strong></code> <strong class="iw hi"> </strong>语句时，Python返回<code class="du ks kt ku kv b"><strong class="iw hi">yield</strong></code> <strong class="iw hi"> </strong>指定的任何值，但是<strong class="iw hi">暂停</strong>函数的执行。然后我们可以<strong class="iw hi">通过<strong class="iw hi"> next() </strong>再次调用</strong>相同的函数，它将<strong class="iw hi">从上次遇到<code class="du ks kt ku kv b"><strong class="iw hi">yield </strong></code>的地方恢复</strong>。</p></blockquote><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lj"><img src="../Images/7b8680ee02916e233343283683fb0c09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lnqds9_d7Tpdj7zF7HjxKQ.png"/></div></div></figure><h2 id="c009" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">生成器与迭代器</h2><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lk"><img src="../Images/3d4bf6a079387f95f6f13bdb8fc6d6fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8u2AVD1eabjC7UiX.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">图片来源:<a class="ae it" href="https://nvie.com/posts/iterators-vs-generators/" rel="noopener ugc nofollow" target="_blank">https://nvie.com/posts/iterators-vs-generators/</a></figcaption></figure><p id="a137" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们上面所讨论的，我们可以用以下几点来总结我们对目前所见的理解</p><p id="1824" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">★生成器是一个具有<strong class="iw hi">迭代器能力的函数/表达式(但反之不成立)</strong>，它提供了一个被称为<strong class="iw hi">生成器模式的设计的实现。</strong></p><p id="8b3e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python中有两种类型的生成器。</p><p id="1321" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">发生器功能</strong>和<strong class="iw hi">发生器表达式</strong>。</p><p id="98db" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">发生器函数是指函数体中出现关键字<code class="du ks kt ku kv b">yield</code>的任何函数。</p><p id="0808" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">生成器表达式是列表理解的一般等价物。对于有限的用例来说，它的语法非常优雅</p><p id="defa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过将列表理解放在括号()而不是列表[]中，可以将其转换为生成器</p><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ld"><img src="../Images/d108f7eff2b061b2a0293abf2080c0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F2ZtvU8m76l_wj7X6zvChg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">参见列表理解中<strong class="bd ju">()代替[] </strong>的用法—第4行</figcaption></figure><p id="16c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">★它是<strong class="iw hi">内存高效的</strong>，因为它不会一次存储所有内容，而是在迭代过程中执行，并保持内部状态。</p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><h1 id="353d" class="ls jt hh bd ju lt lu lv jy lw lx ly kc lz ma mb kf mc md me ki mf mg mh kl mi bi translated">用例与实施</h1><p id="3cc3" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">亚马逊简单队列服务(SQS)是一个消息传递系统，用于将生成的消息保存一段时间。任何希望使用这些保留消息的消费者都可以连接到SQS并处理它们。</p><p id="e1a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">更多关于AWS SQS的信息可以在<a class="ae it" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">这里</strong> </a>找到。</p><p id="05d8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们想象一下，如果作为一个消费者，我被要求消费来自SQS的消息，并处理它们以获得消息的一般摘要，例如，基于<strong class="iw hi"/>类型的<strong class="iw hi">值的总和(一旦我们将看到样本数据和示例，那么需求将非常清楚)，那么我们的实现步骤将是什么？</strong></p><p id="2247" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，也许可以采取以下步骤</p><ul class=""><li id="e9fb" class="mj mk hh iw b ix iy jb jc jf ml jj mm jn mn jr mo mp mq mr bi translated">连接到SQS自动气象站。</li><li id="487a" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">消费保持消息，并将它们存储在某个<strong class="iw hi">数据结构</strong>中，以便进一步处理。</li><li id="b0a0" class="mj mk hh iw b ix ms jb mt jf mu jj mv jn mw jr mo mp mq mr bi translated">对捕获的消息执行分析。</li></ul><p id="4863" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">到目前为止一切顺利。</p><p id="dc4e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">但是你认为第二点有什么问题吗？</p><p id="e071" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过在某一点消耗数据结构(例如列表或数组)中的所有消息，如果SQS中有大量消息，这些占位符会爆炸。在这个阶段，内存不足是一个明显且常见的问题。同意吗？？</p><p id="6bd1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，发电机的重要性开始显现。</p><h2 id="3ac5" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">步骤1-原始消息</h2><p id="1bed" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">让我们假设SQS的样本数据集如下所示</p><p id="9430" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">{ ' Messages ':[{ ' MessageId ':' 762 b5 a79–29 B2–72 b8-f788–606 CCF 806629 '，' receipt handle ':' urgtrhwtg '，' MD 5 ofbody ':' 91e 9 b5 c 6 e0f 9860130 e 56 f 575680744d '，<strong class="iw hi">' Body ':{ " type ":" page view "，" value": 1，" occurrence _ at ":" 2021–03–03</strong></p><h2 id="cdab" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">步骤2-解析的消息</h2><p id="dd96" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">现在，我们对上面消息中的斜体粗体部分感兴趣，以执行我们的分析，即下面的字符串</p><p id="8090" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kz"> {"type": "pageview "，" value": 1，" occurrence _ at ":" 2021–03–22 10:33:38 " } '，</em>'<em class="kz">Body ':{ " type ":" pageview "，" value": 1.5，" occurrent _ at ":" 2021–03–22 10:33:38 " } '，{"type": "doc-view "，" value": 4.5，" occurrence _ at ":" 2021–03</em></p><blockquote class="kw kx ky"><p id="3aed" class="iu iv kz iw b ix iy iz ja jb jc jd je la jg jh ji lb jk jl jm lc jo jp jq jr ha bi translated">如果我们一直把上面的消息累积到列表中，那就不理想了，因为如果我们的队列很大，这会花费<strong class="iw hi">很多内存</strong>。我们可能会耗尽内存，丢失所有的消息。但是如果我们将它重写为一个<strong class="iw hi">生成器</strong>，并且<strong class="iw hi">在我们收到消息时产生</strong>消息，那么代码将会变得更加完美、优化，并且内存效率更高。</p></blockquote><h2 id="0746" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">步骤3-类型及其总和</h2><p id="25da" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">一旦所有的消息都被解析，我们需要得到所有<strong class="iw hi">类型</strong>的总和，预期的输出应该是这样的</p><p id="26d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">{ " <strong class="iw hi"> <em class="kz">浏览量</em> </strong> ": 2.5，}，{ "<strong class="iw hi"><em class="kz">doc-view</em></strong>":4.5，} …..最多k条消息(其中k ≤ n)</p><p id="9553" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于这个用例实现，我将使用<a class="ae it" href="https://boto3.amazonaws.com/v1/documentation/api/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> boto3 SDK。</strong> </a> S的安装指南和配置设置可以在<a class="ae it" href="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/quickstart.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">这里找到</strong> </a></p><p id="3850" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看看代码中的实现。</p><figure class="le lf lg lh fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/cc76a05e71bd9331f99c8eb70e962520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZLhF00Rc1L8Q87gWYZcJJw.png"/></div></div></figure></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><p id="1a47" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，在这篇博客中，我们已经学习了生成器、用法以及它们的实现。为了使解释和实现简单，这里只捕获了最少的代码。然而，完整的实现包括AWS SQS消息删除(消费后)、对每种类型的统计数据求和、记录日志(控制台和<strong class="iw hi">TimedRotatingFileHandler</strong>→<em class="kz">一个重要的处理程序，如果您的作业长时间运行)</em>、在out文件中写入统计数据、单元测试(示例测试)、设置配置和Dockerfile是作为完整示例项目的一部分开发的，可以在<a class="ae it" href="https://github.com/saurabh2mishra/sqsapp" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi"> my github </strong> </a>上找到。</p><p id="3cc4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">感谢阅读</strong> ❤️</p></div><div class="ab cl ll lm go ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ha hb hc hd he"><h2 id="95d1" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">参考</h2><p id="e3fa" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated"><a class="ae it" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank">https://aws.amazon.com/sqs/</a><a class="ae it" href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sqs.html" rel="noopener ugc nofollow" target="_blank">https://boto 3 . Amazon AWS . com/v1/documentation/API/latest/reference/services/SQS . html</a></p></div></div>    
</body>
</html>