<html>
<head>
<title>A brief introduction to Binary Search Tree (BST) using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python的二叉查找树(BST)简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-brief-introduction-to-binary-search-tree-bst-in-python-2da1813abd7e?source=collection_archive---------12-----------------------#2021-02-09">https://medium.com/analytics-vidhya/a-brief-introduction-to-binary-search-tree-bst-in-python-2da1813abd7e?source=collection_archive---------12-----------------------#2021-02-09</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/2aea77e63fa8b5e1ff9d63c9888ffd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZwFiymjH10cG4aZCKqDBQA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">为了更好地理解，一个倒置的树干的插图。</figcaption></figure><h2 id="e08b" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">为什么叫树？</h2><p id="bcd1" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">它被称为“树”,因为它隐约像一个带树枝的倒树干。</p><ul class=""><li id="8c82" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km ku kv kw kx bi translated">单词“binary”表示树中的每个“节点”最多可以有2个子节点(左或右)。</li><li id="fc83" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km ku kv kw kx bi translated">节点可以有0、1或2个子节点。没有任何子节点的节点有时也被称为“叶子”。</li><li id="a514" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km ku kv kw kx bi translated">顶部的单个节点称为“根”节点，它通常是执行搜索、插入等操作的地方。开始吧。</li></ul><h1 id="875a" class="ld iv hi bd iw le lf lg ja lh li lj je lk ll lm ji ln lo lp jm lq lr ls jq lt bi translated">二叉树</h1><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es lu"><img src="../Images/775cfe41ec4c1f98be23accee25e2ac7.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*ISCf91KSoyuqic66iG_4CQ.png"/></div></figure><p id="d34c" class="pw-post-body-paragraph js jt hi ju b jv kp jx jy jz kq kb kc jf lz ke kf jj ma kh ki jn mb kk kl km hb bi translated">首先，我们将创建一个简单的二叉树(没有任何额外的属性),包含数字作为节点中的键。这里有一个例子:</p><figure class="lv lw lx ly fd ij er es paragraph-image"><div class="er es mc"><img src="../Images/21403a010f0561b80e39ae7a612bedb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/1*tKDISao07ijV07t4DQzJkA.png"/></div></figure><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="965f" class="iu iv hi me b fi mi mj l mk ml">#<!-- -->simple class representing a node within a binary tree.</span><span id="af07" class="iu iv hi me b fi mm mj l mk ml">class <strong class="me hj">TreeNode</strong>:<br/>    def <strong class="me hj">__init__</strong>(self, key):<br/>        self.key = key<br/>        self.left = None<br/>        self.right = None</span><span id="c302" class="iu iv hi me b fi mm mj l mk ml">#<!-- -->create objects representing each node of the above tree</span><span id="632a" class="iu iv hi me b fi mm mj l mk ml">node0 = TreeNode(3)<br/>node1 = TreeNode(4)<br/>node2 = TreeNode(5)</span><span id="26f6" class="iu iv hi me b fi mm mj l mk ml">#c<em class="mn">onnect</em> the nodes by setting the <!-- -->.left<!-- --> and <!-- -->.right<!-- --> properties of the root node. And we're done! We can create a new variable <em class="mn">tree</em> which simply points to the root node, and use it to access all the nodes within the tree.</span><span id="fd74" class="iu iv hi me b fi mm mj l mk ml">node0.left = node1<br/>node0.right = node2</span><span id="7b9b" class="iu iv hi me b fi mm mj l mk ml">#Going forward, we'll use the term "tree" to refer to the root node. The term "node" can refer to any node in a tree, not necessarily the root.</span></pre><h2 id="e2e3" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">遍历二叉树</h2><p id="9988" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">一个<em class="mn">遍历</em>指的是恰好访问一棵树的每个节点一次的过程。<em class="mn">访问一个节点</em>一般是指将该节点的键添加到一个列表中。有三种方法可以遍历二叉树并返回访问过的键的列表:</p><p id="41e9" class="pw-post-body-paragraph js jt hi ju b jv kp jx jy jz kq kb kc jf lz ke kf jj ma kh ki jn mb kk kl km hb bi translated"><strong class="ju hj"> <em class="mn">依次遍历</em> </strong></p><ol class=""><li id="533e" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km mo kv kw kx bi translated">以递归方式遍历左边的子树。</li><li id="325d" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">遍历当前节点。</li><li id="b82f" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">按顺序递归遍历右边的子树。</li></ol><p id="7323" class="pw-post-body-paragraph js jt hi ju b jv kp jx jy jz kq kb kc jf lz ke kf jj ma kh ki jn mb kk kl km hb bi translated"><strong class="ju hj"> <em class="mn">前序遍历</em> </strong></p><ol class=""><li id="4f86" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km mo kv kw kx bi translated">遍历当前节点。</li><li id="ad49" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">递归前序遍历左子树。</li><li id="5ec2" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">递归地遍历右边的子树。</li></ol><p id="5f7f" class="pw-post-body-paragraph js jt hi ju b jv kp jx jy jz kq kb kc jf lz ke kf jj ma kh ki jn mb kk kl km hb bi translated"><strong class="ju hj"> <em class="mn">后序遍历</em> </strong></p><ol class=""><li id="6966" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km mo kv kw kx bi translated">递归后序遍历左子树。</li><li id="d4e9" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">递归后序遍历右边的子树。</li><li id="f9d9" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">遍历当前节点。</li></ol><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="04c4" class="iu iv hi me b fi mi mj l mk ml">#implementation of inorder traversal of a binary tree</span><span id="4c8e" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">traverse_in_order</strong>(node):<br/>    if node is None: <br/>        return []<br/>    return(traverse_in_order(node.left) + <br/>           [node.key] + <br/>           traverse_in_order(node.right))</span></pre><h2 id="ceb8" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">二叉树的高度和大小</h2><p id="3184" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">二叉树的<em class="mn">高度/深度</em>定义为从其根节点到叶子的最长路径的长度。</p><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="52e2" class="iu iv hi me b fi mi mj l mk ml">#computation of height/depth of a binary tree</span><span id="d672" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">tree_height</strong>(node):<br/>    if node is None:<br/>        return 0<br/>    return 1 + max(tree_height(node.left), tree_height(node.right))</span><span id="e34f" class="iu iv hi me b fi mm mj l mk ml"># computation of number of nodes in a binary tree</span><span id="506f" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">tree_size</strong>(node):<br/>    if node is None:<br/>        return 0<br/>    return 1 + tree_size(node.left) + tree_size(node.right)</span></pre><h1 id="a64f" class="ld iv hi bd iw le lf lg ja lh li lj je lk ll lm ji ln lo lp jm lq lr ls jq lt bi translated">二叉查找树</h1><p id="816f" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">二叉查找树或BST是满足以下条件的二叉树:</p><ol class=""><li id="17bd" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km mo kv kw kx bi translated">任何节点的左子树只包含键小于该节点键的节点</li><li id="3ce2" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">任何节点的右子树只包含键大于该节点键的节点</li></ol><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="9e9b" class="iu iv hi me b fi mi mj l mk ml">#Function to check if a binary tree is a binary search tree and to find the minimum and maximum key in a binary tree</span><span id="d7a0" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">is_bst</strong>(node):<br/>    if node is None:<br/>        return True, None, None<br/>    <br/>    is_bst_l, min_l, max_l = is_bst(node.left)<br/>    is_bst_r, min_r, max_r = is_bst(node.right)<br/>    <br/>    is_bst_node = (is_bst_l and is_bst_r and <br/>              (max_l is None or node.key &gt; max_l) and <br/>              (min_r is None or node.key &lt; min_r))<br/>    <br/>    min_key = min(remove_none([min_l, node.key, min_r]))<br/>    max_key = max(remove_none([max_l, node.key, max_r]))<br/>    <br/>    <em class="mn">print(node.key, min_key, max_key, is_bst_node)</em><br/>        <br/>    return is_bst_node, min_key, max_key</span></pre><h2 id="a609" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">BST中的插入</h2><p id="ccd4" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">使用BST属性有效地执行插入:</p><ol class=""><li id="66cd" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km mo kv kw kx bi translated">从根节点开始，将要插入的键与当前节点的键进行比较</li><li id="e50f" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">如果键更小，递归地将它插入到左子树中(如果它存在的话),或者如果左子树不存在，将它作为左子树附加。</li><li id="7d40" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km mo kv kw kx bi translated">如果键比较大，递归地将它插入到右边的子树中(如果存在的话),或者如果右边的子树不存在，将它作为右边的子树附加。</li></ol><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="467b" class="iu iv hi me b fi mi mj l mk ml">#Implementation of insertion</span><span id="01d9" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">insert</strong>(node, key, value):<br/>    if node is None:<br/>        node = BSTNode(key, value)<br/>    elif key &lt; node.key:<br/>        node.left = insert(node.left, key, value)<br/>        node.left.parent = node<br/>    elif key &gt; node.key:<br/>        node.right = insert(node.right, key, value)<br/>        node.right.parent = node<br/>    return node</span></pre><h2 id="d804" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">在BST中查找特定的节点</h2><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="efb0" class="iu iv hi me b fi mi mj l mk ml">#Implementation of finding a node</span><span id="35ca" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">find</strong>(node, key):<br/>    if node is None:<br/>        return None<br/>    if key == node.key:<br/>        return node<br/>    if key &lt; node.key:<br/>        return find(node.left, key)<br/>    if key &gt; node.key:<br/>        return find(node.right, key)</span></pre><h2 id="b8b0" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">更新BST中的值</h2><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="d240" class="iu iv hi me b fi mi mj l mk ml">#Implementation of update</span><span id="7a96" class="iu iv hi me b fi mm mj l mk ml">def <strong class="me hj">update</strong>(node, key, value):<br/>    target = find(node, key)<br/>    if target is not None:<br/>        target.value = value</span></pre><h2 id="525b" class="iu iv hi bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">按照键的排序顺序检索BST中存储的所有键-值对</h2><pre class="lv lw lx ly fd md me mf mg aw mh bi"><span id="dd4c" class="iu iv hi me b fi mi mj l mk ml">def <strong class="me hj">list_all</strong>(node):<br/>    if node is None:<br/>        return []<br/>    return list_all(node.left) + [(node.key, node.value)] + list_all(node.right)</span></pre><h1 id="281d" class="ld iv hi bd iw le lf lg ja lh li lj je lk ll lm ji ln lo lp jm lq lr ls jq lt bi translated">二分搜索法树的应用</h1><p id="6d44" class="pw-post-body-paragraph js jt hi ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km hb bi translated">BST由于其有序的结构而被广泛应用。</p><ul class=""><li id="d8c7" class="kn ko hi ju b jv kp jz kq jf kr jj ks jn kt km ku kv kw kx bi translated">BST用于索引和多级索引。</li><li id="be89" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km ku kv kw kx bi translated">它们也有助于实现各种搜索算法。</li><li id="588d" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km ku kv kw kx bi translated">这有助于维护有序的数据流。</li><li id="4fc8" class="kn ko hi ju b jv ky jz kz jf la jj lb jn lc km ku kv kw kx bi translated">使用自平衡BST在内部实现TreeMap和TreeSet数据结构。</li></ul></div></div>    
</body>
</html>