<html>
<head>
<title>JPA Hibernate - Entity Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JPA Hibernate -实体继承</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/jpa-hibernate-entity-inheritance-1f6aa7ea2eea?source=collection_archive---------1-----------------------#2021-01-30">https://medium.com/analytics-vidhya/jpa-hibernate-entity-inheritance-1f6aa7ea2eea?source=collection_archive---------1-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4f05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JPA允许我们使用<strong class="ih hj"> @Entity </strong>注释轻松地在数据库中创建表格。使用Jpa，可以通过使用继承特性来创建实体。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/723b7721216ce3fd41a61067d12dbc2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*97NCGRr08agtj4-V"/></div></div></figure><p id="ffed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">JPA有一些有用的继承策略:</p><h1 id="7ec4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">1.mapped超类</h1><p id="cae7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">使用<strong class="ih hj"> @MappedSuperclass </strong>，可以创建一个非实体超类，并且可以创建继承这个超类的实体子类。使用这个注释，为每个子类创建一个单独的表。但是，不会为超类本身创建表。</p><p id="9b13" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超级课堂:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="6c13" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">@MappedSuperclass</strong><br/>public abstract class Devices {</span><span id="1be3" class="kx jq hi kt b fi lc kz l la lb">    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="ld">AUTO</em>)<br/>    private int id;    </span><span id="1bf6" class="kx jq hi kt b fi lc kz l la lb">    @Column(name="brand")<br/>    private String brand;<br/><br/>    @Column(name="name")<br/>    private String name;</span></pre><p id="21af" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承类:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="956d" class="kx jq hi kt b fi ky kz l la lb">@Entity<br/>@Table(name = "computer")<br/>public class Computer extends Devices {<br/>   //Any new object and field here</span><span id="0378" class="kx jq hi kt b fi lc kz l la lb">}</span><span id="6c7a" class="kx jq hi kt b fi lc kz l la lb">------------------------------------------------</span><span id="fcc2" class="kx jq hi kt b fi lc kz l la lb">@Entity<br/>@Table(name = "mobile_phone")<br/>public class MobilePhone extends Devices{<br/>   //Any new object and field here<br/>}</span></pre><h1 id="1792" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">2.单一表格</h1><p id="1e29" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">使用单一策略继承类型，您可以创建一个单一的表作为主实体。它不会为每个实体创建单独的表。我们添加了<a class="ae le" href="http://twitter.com/DiscriminatorValue" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">@鉴别值</strong> </a>符号来区分每个实体。如果我们不添加它，Hibernate默认使用实体名作为区别值。这使得我们很容易创建查询。这种方法的一个缺点是，在实体表中创建了未使用的列，它们接受空值。因此，不能进行非空定义。</p><p id="72ff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超级课堂:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="3da5" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">@Entity<br/>@Inheritance(strategy = InheritanceType.SINGLE_TABLE)<br/>@DiscriminatorColumn(name = "device")</strong><br/>public abstract class Devices {</span><span id="b5b7" class="kx jq hi kt b fi lc kz l la lb">    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="ld">AUTO</em>)<br/>    private int id;    </span><span id="d665" class="kx jq hi kt b fi lc kz l la lb">    @Column(name="brand")<br/>    private String brand;<br/><br/>    @Column(name="name")<br/>    private String name;</span></pre><p id="8c79" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承类:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="10ac" class="kx jq hi kt b fi ky kz l la lb">@Entity<br/>@DiscriminatorValue("computer")<br/>public class Computer extends Devices {<br/>   private String oS;</span><span id="6866" class="kx jq hi kt b fi lc kz l la lb">-----------------------------------------------</span><span id="d0f8" class="kx jq hi kt b fi lc kz l la lb">@Entity<br/>@DiscriminatorValue("mobilephone")<br/>public class MobilePhone extends Devices{<br/>   private String color;</span></pre><p id="8f16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用鉴别器值的查询示例:</p><p id="a2d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">设备表:id、品牌、名称、操作系统、颜色</p><p id="6d63" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">→ <strong class="ih hj">从</strong>设备<strong class="ih hj">中选择</strong> * <strong class="ih hj">，其中</strong>设备=“计算机”</p><h1 id="8ac3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">3.连接表</h1><p id="66c9" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">在这个策略中，为超类和子类创建单独的表。但是，超类中定义的对象不包括在子类的表中。超类的主键构成了子类的外键。另外，使用<a class="ae le" href="http://twitter.com/PrimaryKeyJoinColumn" rel="noopener ugc nofollow" target="_blank"> @PrimaryKeyJoinColumn </a>，我们可以为子类指定一个主键，这个主键是超类的外键。</p><p id="c4e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超级课堂:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="f38e" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">@Entity<br/>@Inheritance(strategy = InheritanceType.JOINED)</strong><br/>public abstract class Devices {</span><span id="a580" class="kx jq hi kt b fi lc kz l la lb">    @Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="ld">AUTO</em>)<br/>    private int id;<br/>    <br/>    @Column(name="brand")<br/>    private String brand;<br/><br/>    @Column(name="name")<br/>    private String name;</span></pre><p id="d40c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承类:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="aa77" class="kx jq hi kt b fi ky kz l la lb">@Entity<br/>@PrimaryKeyJoinColumn(name = "computerId")<br/>public class Computer extends Devices {<br/>   private String oS;</span><span id="3603" class="kx jq hi kt b fi lc kz l la lb">----------------------------------------------</span><span id="e55d" class="kx jq hi kt b fi lc kz l la lb">@Entity<br/>@PrimaryKeyJoinColumn(name = "mobilephoneId")<br/>public class MobilePhone extends Devices{<br/>   private String color;</span></pre><h1 id="97f3" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">4.每类表格</h1><p id="3719" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">该方法与MappedSuperclass方法非常相似，但与该方法不同的是，超类也是一个实体。这意味着还将为数据库中的超类创建一个表。这种继承结构允许我们创建与多态查询和子类的关系。但是当查询时，所有的子类都被扫描，这大大降低了性能。因此，在需要大量查询的作业中，应该避免使用这种方法。</p><p id="8a5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">超级课堂:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="e0aa" class="kx jq hi kt b fi ky kz l la lb"><strong class="kt hj">@Entity<br/>@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)</strong><br/>public abstract class Devices {</span><span id="7846" class="kx jq hi kt b fi lc kz l la lb">@Id<br/>    @GeneratedValue(strategy = GenerationType.<em class="ld">AUTO</em>)<br/>    private int id;<br/>    <br/>    @Column(name="brand")<br/>    private String brand;</span><span id="118b" class="kx jq hi kt b fi lc kz l la lb">    @Column(name="name")<br/>    private String name;</span><span id="1f51" class="kx jq hi kt b fi lc kz l la lb">    @Column(name="os")<br/>    private String oS;</span></pre><p id="8e07" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继承类:</p><pre class="je jf jg jh fd ks kt ku kv aw kw bi"><span id="02ae" class="kx jq hi kt b fi ky kz l la lb">@Entity<br/>public class Computer extends Devices {<br/>   private String color;</span></pre><p id="9e4d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数据库<strong class="ih hj">中，计算机</strong>表有:ID、品牌、名称、操作系统、颜色</p><p id="3fa1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">感谢您的阅读:)</p></div></div>    
</body>
</html>