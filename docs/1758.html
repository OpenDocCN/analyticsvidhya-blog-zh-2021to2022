<html>
<head>
<title>Golang — how it is different</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">golang——与众不同</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/golang-how-it-is-different-456729a23ba5?source=collection_archive---------8-----------------------#2021-03-16">https://medium.com/analytics-vidhya/golang-how-it-is-different-456729a23ba5?source=collection_archive---------8-----------------------#2021-03-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b60ec44e8c9ffd33484e8f9df54b2185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O6smhCYMidwDWWGk6HYD3w.jpeg"/></div></div></figure><p id="9743" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang易于理解，编译速度更快。围棋中有一个著名的笑话；Golang是在等待C++编译时创建的。这似乎是一个笑话，但它是真实的,《golang》的作者之一Rob Pike一直在等待C++代码编译，然后他决定，他再也不能处理它了，于是golang诞生了。</p><p id="a1d2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Golang适合工业项目，大多数公司开始转向golang和grpc服务。简单易懂，易于维护应该是golang项目的基础。如果我们用golang创建的代码被另一个程序员看了之后很难理解，那就是坏代码的例子，应该使用go工具及其强大的包进行重构。</p><p id="fdd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">StorieI在4年前开始学习golang，从那时起，我试图用它来使我的代码简单，同时有效和不稳定地添加功能。在golang之前，我自己也在从事node和python方面的工作。尽管来自OOPS背景的程序员试图学习go，仍然在结构化编程语言中实现面向对象的概念(这没什么错),但是如果它是通过记住OOPS而创建的，那么这种语言就不会是同样源自c的结构化语言。</p><p id="14e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">golang不能用作其他OOPS语言的一个重要例子是它处理接口的方式。我们都知道接口是作为方法的抽象来使用的。在golang中，我们以两种方式使用接口:-一种是作为接口来定义方法的行为，而不是像在其他面向对象语言中那样抽象方法。换句话说，它被用作一个泛型类型来存储和捕获任何原始或复杂数据类型的值。</p><p id="976d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们从go中的一个接口示例开始</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="8428" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在上面的例子中，我创建了一个具有Read方法的接口，由于它将实现reader接口，并且可以捕获任何实现reader接口的类型。</p><p id="3cd9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我实现了一个reader接口，并在CustomRead接口中使用它来解释golang与oops语言在接口方面的不同。在这段代码中，我定义了实现阅读器接口的CustomRead接口的行为。</p><p id="31c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Go更适合UNIX理念，创建小任务来完成更大的任务。试图在golang中实现oops概念有时会使项目代码变得更加混乱，并且将来难以维护。最好的例子是如何在golang viz中定义一个包或函数。阅读器接口或net/http包。Http可以是net包的一部分，但在golang中，它是作为net包中的一个单独的包创建的，只是为了处理http部分。</p><blockquote class="ju jv jw"><p id="8206" class="iq ir jx is b it iu iv iw ix iy iz ja jy jc jd je jz jg jh ji ka jk jl jm jn hb bi translated">下围棋时，要像地鼠那样做</p></blockquote><div class="kb kc ez fb kd ke"><a href="https://talks.golang.org/2014/readability.slide#1" rel="noopener  ugc nofollow" target="_blank"><div class="kf ab dw"><div class="kg ab kh cl cj ki"><h2 class="bd hj fi z dy kj ea eb kk ed ef hh bi translated">下围棋时，要像地鼠那样做</h2><div class="kl l"><h3 class="bd b fi z dy kj ea eb kk ed ef dx translated">编辑描述</h3></div><div class="km l"><p class="bd b fp z dy kj ea eb kk ed ef dx translated">talks.golang.org</p></div></div></div></a></div></div><div class="ab cl kn ko gp kp" role="separator"><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks kt"/><span class="kq bw bk kr ks"/></div><div class="hb hc hd he hf"><p id="278a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">golang的另一个独特之处是，一切都是按值传递的。Golang创建一个传递给方法的参数副本，并对其进行处理。无论是作为方法的参数还是方法的接收方，一切都被认为是通过值传递的。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="094b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上面的代码是一个很好的例子，展示了它通过值传递的一切。上面代码的问题是它不能工作并抛出一个错误:</p><pre class="jo jp jq jr fd ku kv kw kx aw ky bi"><span id="8736" class="kz la hi kv b fi lb lc l ld le">error.go:18:7: cannot use dog (type Dog) as type Animal in argument to Speak:<br/> Dog does not implement Animal (Speak method has pointer receiver)</span></pre><p id="c859" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">上述代码将通过将Dog struct作为指针而不是值来传递。但是如果我把cat作为指针传递，它会工作吗？令人惊讶的是，即使cat接收器不是指针类型，它也能工作。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="87ac" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">代码背后的原因是通过将cat struct作为指针传递，而不是将dog struct作为值传递——当将Dog struct作为值传递时，将创建一个副本，但它将指向新Dog struct值的不同地址，因此出现错误。当将Cat作为指针传递时，可以使用为Cat提供的地址指针来创建值。</p><p id="4aee" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">总而言之，在与golang合作时，有几点需要考虑</p><ul class=""><li id="bb4e" class="lf lg hi is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln bi translated">接口应该用于行为，而不是抽象。</li><li id="3aae" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">接口被用作空接口中的泛型类型。</li><li id="a7ed" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">接口应该包含特定行为的方法。</li><li id="1524" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">总是接受接口和返回结构。</li><li id="161f" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">指针类型变量可以调用值类型的方法，但反之则不行。</li><li id="a6c1" class="lf lg hi is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln bi translated">一切都是通过值传递的，即使是方法的接收者。</li></ul><p id="3e8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你对golang和理解它的架构有任何疑问。给我发关于himanshusdec8@gmail.com的邮件</p><p id="40cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关注<a class="ae lt" href="https://golang-geek.medium.com/" rel="noopener">https://golang-geek.medium.com/</a>了解最新消息…</p></div></div>    
</body>
</html>