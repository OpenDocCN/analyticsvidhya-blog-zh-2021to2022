<html>
<head>
<title>Splitting your data: growing beyond train_test_split</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">拆分数据:超越train_test_split</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/splitting-your-data-growing-beyond-train-test-split-dc0eb83d7dac?source=collection_archive---------26-----------------------#2021-01-27">https://medium.com/analytics-vidhya/splitting-your-data-growing-beyond-train-test-split-dc0eb83d7dac?source=collection_archive---------26-----------------------#2021-01-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/804967fcc41d241d166e246515b10151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcKZe4hkZyfRbDcQlEgogw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">简·安东宁·科拉尔在<a class="ae it" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="5efb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正确分割机器学习项目的数据对其成功至关重要。您希望用尽可能多的数据来训练模型，但也要确保它不是简单地记住了解决方案。<br/>通常，你把数据分成三类:<br/> ~80 %训练，10 %验证&amp; 10 %测试。<br/>然后，将模型与训练数据相匹配，直到验证误差开始增加，最后在测试集上进行测试。</p><h2 id="8c43" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">sk learn . model _ selection . train _ test _ split前往救援</h2><p id="8b33" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">幸运的是，有工具可以帮助我们实现这一点，我已经无数次导入了sklearns train_test_split来完成这项工作。</p><p id="6943" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种方法有一个缺点:如果您使用的不是一个静态数据集，而是一个随时间不断增长的数据集，那么每次添加新的示例时，您都会得到完全不同的分割。</p><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">再添加一个示例后，分布会发生变化。</figcaption></figure><p id="523c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">混洗数据意味着您不能比较两次运行的结果，因为您的验证分割可能只是由简单或非常困难的例子组成。这可能会在您的训练结果中添加大量噪声，尤其是在训练数据量很少的情况下。最终，这使得项目难以继续进行。</p><p id="beb5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了减少模型性能的噪声量，您可以使用<a class="ae it" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html" rel="noopener ugc nofollow" target="_blank"> k-fold-cross-validation </a>。在该方法中，数据分布在k个箱上，并且这些箱中的每一个被用作一次验证数据集，而其余的被用于训练。这种方法的缺点是训练k模型需要巨大的时间复杂度。<a class="ae it" href="https://www.youtube.com/watch?v=wjILv3-UGM8&amp;ab_channel=ritvikmath" rel="noopener ugc nofollow" target="_blank">在YouTube上有一个由Ritvikmath制作的很棒的视频，更详细地解释了这个策略</a>。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/4f6d1d7b1d7387cebbbfffabc10284ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*OWXgKpWZuD9jyclBdFHaZg.jpeg"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">Sklearn可以做更多的事情…？</figcaption></figure><p id="a1a6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我的例子中，完全训练我的分类器需要10个小时。每当我注释额外的数据时，运行我的训练脚本5或10次是不可行的，只是为了决定我是否需要改变我的模型或者我是否需要收集和注释特定的数据。</p><p id="b97a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kz">我需要不同的解决方案。</em></p><h2 id="4109" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">再见train_test_split —你好Splitter。</h2><p id="d435" class="pw-post-body-paragraph iu iv hh iw b ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn kr jp jq jr ha bi translated">我发现这个问题的解决方案是持久化测试序列分割，并使其可扩展。此外，我保留了k-fold-cross-validation的想法，将我的数据集分成k个大约相同大小的箱，或者我称之为“桶”。每当我注释额外的数据时，这段数据被分配到一个桶中，而所有以前的数据都像以前一样留在同一个桶中。<br/>桶的选择与桶中的数据量成反比，除以所有桶中的数据总量:<br/>实例较少的桶比实例较多的桶更容易被填满。</p><p id="f46d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通常，我会创建10个存储桶，并保留最后一个用于测试。在项目结束时，我可以简单地用我保留的测试集进行9重交叉验证，并在看不见的数据上获得良好的性能估计。</p><p id="06d0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我对我最初的实验很满意，当我开始下一个项目时，我创建了一个小的python类，它可以将数据点分配给任意数量的桶，并为您创建拆分。</p><p id="fe87" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我的工具只不过是一个字典、一个列表和一个k数大小的NumPy数组，所以它可以非常容易地持久化，以便在每次训练迭代中对split进行磁盘和重新加载。<br/>唯一的依赖是NumPy。</p><h2 id="9bf0" class="js jt hh bd ju jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km bi translated">用法示例</h2><div class="la lb ez fb lc ld"><a href="https://github.com/p-sodmann/splitter" rel="noopener  ugc nofollow" target="_blank"><div class="le ab dw"><div class="lf ab lg cl cj lh"><h2 class="bd hi fi z dy li ea eb lj ed ef hg bi translated">p-索德曼/分离器</h2><div class="lk l"><h3 class="bd b fi z dy li ea eb lj ed ef dx translated">具有持久性的k倍数据分裂。在GitHub上创建一个帐户，为p-sodmann/splitter的开发做出贡献。</h3></div><div class="ll l"><p class="bd b fp z dy li ea eb lj ed ef dx translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr in ld"/></div></div></a></div><figure class="ks kt ku kv fd ii"><div class="bz dy l di"><div class="kw kx l"/></div></figure></div></div>    
</body>
</html>