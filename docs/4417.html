<html>
<head>
<title>Search Engine in Python from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始用Python开发搜索引擎</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/search-engine-in-python-from-scratch-c3f7cc453250?source=collection_archive---------0-----------------------#2021-10-10">https://medium.com/analytics-vidhya/search-engine-in-python-from-scratch-c3f7cc453250?source=collection_archive---------0-----------------------#2021-10-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/f64863e664b91c00ffc42e9b27b7bf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*mY70Qzx_dO-p5Hmi32vJKQ.gif"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:-<a class="ae iq" href="https://www.pinterest.com/pin/847450854860596454/?amp_client_id=CLIENT_ID(_)&amp;mweb_unauth_id=&amp;simplified=true" rel="noopener ugc nofollow" target="_blank">https://www.pinterest.com/pin/847450854860596454/?amp _ CLIENT _ ID = CLIENT _ ID(_)&amp;mweb _ un auth _ ID =&amp;simplified = true</a></figcaption></figure><p id="276e" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi jp translated"><span class="l jq jr js bm jt ju jv jw jx di">在</span>这篇文章中，我将从头开始讲述使用维基百科转储(大约84GB大小)构建搜索引擎的所有细节。我将逐步介绍创建数据的主索引和辅助索引的过程，以及如何实现搜索功能，以便在最短的时间内输出结果。我将这篇文章分成两部分，即需求，维基转储细节，索引和搜索。所以系好安全带，让我们开始吧。</p><h1 id="cf56" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.要求</h1><blockquote class="kw kx ky"><p id="26e3" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">Python3</p><p id="0dc9" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">NLTK停用词</p><p id="3e8f" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">PyStemmer</p></blockquote><h1 id="5f7d" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">2.维基转储详细信息</h1><p id="72d1" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">为了创建搜索引擎，在这篇文章中，我将提到英语的<strong class="it hj">维基百科</strong>转储，其大小大约为<strong class="it hj"> 84GB </strong>。人们可以从下面给出的链接下载数据</p><blockquote class="kw kx ky"><p id="bbd8" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated"><a class="ae iq" href="https://dumps.wikimedia.org/enwiki/20210720/enwiki-20210720-pages-articles-multistream.xml.bz2" rel="noopener ugc nofollow" target="_blank">https://dumps . wikimedia . org/enw iki/2021 07 20/enw iki-2021 07 20-pages-articles-multi stream . XML . bz2</a></p></blockquote><p id="bb40" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">您需要下载并解压缩下载的转储文件。或者，您也可以处理压缩数据。我会解释所有关于提取转储的事情。</p><h1 id="ec44" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">3.为Wiki转储创建索引</h1><h2 id="4771" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">(I)解析XML转储</h2><p id="6494" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">首先，您需要解析XML并获得必要的数据。为此，python中有几个可用的解析器。其中一些是</p><blockquote class="kw kx ky"><p id="1f8d" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">萨克斯管</p><p id="f6d3" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">Etree</p><p id="b26f" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">数字正射影像图</p></blockquote><p id="258f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里我将使用SAX解析器来解析XML。您也可以尝试不同的其他解析器。在下面的要点中，我展示了如何使用SAX解析器来解析数据。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="a060" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上面的代码中，我只使用了XML中的两个字段，即标题和文本。我从变量num_pages中给出我自己的id。我是如何使用标题和正文的，在下面的不同部分有解释。</p><h2 id="81f2" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">(二)如何预处理文本</h2><p id="4c49" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">这是一项基本任务，因为这一步将确保我们不会向索引中添加不必要的术语。否则会吹大指数大小。主要是，我会删除停用词，标记文本，删除HTML标签，删除非ASCII字符等。如下面的代码所示。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h2 id="60a7" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈢提取不同的领域</h2><p id="964d" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">我们可以在不同的字段上进行查询搜索。我将使用六个字段:标题、正文、类别、信息框、链接和参考。用户可以使用这些字段搜索通用查询或特定于字段的查询。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h2 id="6afe" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈣建立一个中间指数</h2><p id="29b3" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">直接创建最终索引将是一项繁重的任务，并且还会占用大量内存。因此，我们将首先在数据节上创建一个中间索引，然后执行最后的合并来生成最终索引。我们将使用SPIMI方法。你可以通过下面的链接了解更多。</p><div class="mc md ez fb me mf"><a href="https://nlp.stanford.edu/IR-book/html/htmledition/single-pass-in-memory-indexing-1.html" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">单遍内存索引</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">下一步:分布式索引运行:索引构造上一步:阻塞的基于排序的索引内容索引阻塞…</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">nlp.stanford.edu</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt ik mf"/></div></div></a></div><p id="654b" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">下面的代码显示了如何创建一个中间索引。</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="3426" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在这里，我逐个处理文本，将其添加到字典中，然后写入中间文件。索引文件的格式现在看起来是这样的</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="9b49" class="li jz hi mv b fi mz na l nb nc">apple-2314:t3b6i2r1;6432:t5c8b3i1;</span></pre><p id="2926" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上面的例子中，“<em class="kz">苹果</em>”是一个令牌。然后在连字符后，每一对用“<strong class="it hj">隔开；</strong>”。“<strong class="it hj"> : </strong>前的第一个值代表文档的docID，然后对应的字符串和值代表频率。</p><blockquote class="kw kx ky"><p id="c64a" class="ir is kz it b iu iv iw ix iy iz ja jb la jd je jf lb jh ji jj lc jl jm jn jo hb bi translated">《出埃及记》:- t3b6i2r1表示token在标题中出现3次，在正文中出现6次，在信息框中出现2次，在引用中出现1次。</p></blockquote><h2 id="9c44" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈣合并中间索引</h2><p id="48f0" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">现在当我们写完中间索引。我们需要合并索引，因为在某些情况下，令牌会将其信息分割到多个文件中。我们需要合并它来创建最终的索引。下面的代码可以做到这一点</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="803f" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">最终索引的格式如下例所示:-</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="30d1" class="li jz hi mv b fi mz na l nb nc">apple-2141:5;1232:1;5432:78;</span></pre><p id="9d28" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在上面的例子中，“<em class="kz">苹果</em>”是一个令牌。然后在连字符后，每对用“<strong class="it hj">隔开；</strong>”。“<strong class="it hj"> : </strong>”前的第一个值表示文档的docID，第二个值表示字段文件中特定标记的标记频率。与中间索引不同，最终文件是按字段分开的文件。</p><p id="c4d4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">通过这种方式，最终的索引将类似于上面的示例。如果你想看完整的代码，你可以访问这篇博客最后给出的Github代码链接，也可以尝试不同的方法。</p><h2 id="bdee" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈤二级索引</h2><p id="9c3b" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">您可以根据需要创建辅助索引。这将有助于通过在二级索引中保存标记信息来进行快速搜索。我将使用以下格式的二级索引。人们也可以尝试其他可能的形式。</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="ba5b" class="li jz hi mv b fi mz na l nb nc">apple-563-1-3-4--2-4-6-</span></pre><p id="67f6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">按照上面的格式，<em class="kz">‘苹果’</em>将是令牌。那么值563将表示苹果在整个维基百科转储中的频率。此后，数字1将指示该令牌存在于哪个文件号中。令牌可以出现在任何字段中。数字1表示如果令牌出现在该字段中，它将只出现在该字段的特定文件编号中。之后，所有其他值都是可选的。我将详细介绍下面的字段值:-</p><p id="dd11" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如上所述，我将使用字段标题，正文，类别，信息框，链接，参考。因此'-'之间的值将表示最终索引文件中的行号。下面的例子说明了这一点</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="21d1" class="li jz hi mv b fi mz na l nb nc">'apple-563-1-3-4--2-4-6-'.split('-') ---&gt; ['apple', '563', '1', '3', '4', '', '2', '4', '6', '']</span></pre><p id="71af" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这里，第四个元素(‘3’)表示‘apple’出现在标题文件的文件号1的第3行。类似地，“4”将表明它将出现在主体文件的第4行；它不会出现在类别文件中，因为它是一个空字符串(")，它出现在infobox文件的第2行，链接文件的第4行，以及引用文件的第6行。所有文件共有的一点是，如果令牌出现在任何字段中，它将只出现在特定的文件编号中，而不会出现在其他地方。</p><h1 id="852a" class="jy jz hi bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">4.实现搜索功能</h1><p id="76bd" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">搜索功能需要的一个关键是实现排名功能，根据文档的相关性对文档进行排名。但在此之前，还需要一些其他的东西，我将在下面解释:-</p><h2 id="72da" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">(I)预处理查询</h2><p id="4d4d" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">预处理将与我们在索引阶段所做的相同。所有步骤将与初始步骤相同。然后我们将得到最终的预处理查询。</p><h2 id="e925" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈡确定查询类型</h2><p id="f317" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">这是模式有用的步骤之一，因为它将指导我们是否需要简单查询或字段查询或两者都需要。所以基本上一个查询可以有三种类型:-</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="92bf" class="li jz hi mv b fi mz na l nb nc">Type 1:- world war II<br/>Type 2:- t:world cup i:2012<br/>Type 3:- Sachin Tendulkar t:world cup i:2012</span></pre><p id="9446" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们可以使用下面的代码来识别查询的类型</p><figure class="lw lx ly lz fd ij"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h2 id="cc8c" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">㈢排名功能</h2><p id="6f99" class="pw-post-body-paragraph ir is hi it b iu ld iw ix iy le ja jb jc lf je jf jg lg ji jj jk lh jm jn jo hb bi translated">排名功能用于获得排名结果。这样相关结果就在最上面了。通常，tf-idf是对文档进行排名的度量。</p><p id="bdb8" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">那么什么是tf-idf呢？它由两个术语<strong class="it hj"> TF </strong>和<strong class="it hj"> IDF组成。</strong></p><p id="e904" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> TF(词频):- </strong>它告诉我们一个词在文档中出现的频率。</p><p id="80ab" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><strong class="it hj"> IDF(逆文档频率):- </strong>在文档中，出现的词很多，频率很大。但是这种高频率降低了该单词与该文档的相关性。因此，为了降低大频率字的影响，使用IDF。它基本上是文档总数除以该文档的单词频率的对数。</p><p id="3707" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以最终的tf-idf值是tf和idf值的乘积。</p><pre class="lw lx ly lz fd mu mv mw mx aw my bi"><span id="612a" class="li jz hi mv b fi mz na l nb nc">tf-idf = tf * idf</span></pre><h2 id="f436" class="li jz hi bd ka lj lk ll ke lm ln lo ki jc lp lq km jg lr ls kq jk lt lu ku lv bi translated">tf-idf的变体</h2><figure class="lw lx ly lz fd ij er es paragraph-image"><div class="er es nd"><img src="../Images/c1d9c31b1d7b9a04dfeedcf03b13b238.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*-MfyZN9X_9CkD0Dn3ijjGQ.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">来源:-<a class="ae iq" href="https://nlp.stanford.edu/IR-book/pdf/06vect.pdf" rel="noopener ugc nofollow" target="_blank">https://nlp.stanford.edu/IR-book/pdf/06vect.pdf</a></figcaption></figure><p id="d3ce" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">可以使用上面给出的任何一种tf-idf变体。这取决于他们的实施和选择。</p></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="ffa6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">所以，现在就从我这方面来说。如果你想看完整的代码，你可以访问下面的链接</p><div class="mc md ez fb me mf"><a href="https://github.com/DhavalTaunk08/Wiki-Search-Engine" rel="noopener  ugc nofollow" target="_blank"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">GitHub-dhavaltaunk 08/Wiki-搜索引擎</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在GitHub上创建一个帐户，为DhavalTaunk08/Wiki搜索引擎的开发做出贡献。</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">github.com</p></div></div><div class="mo l"><div class="nl l mq mr ms mo mt ik mf"/></div></div></a></div><p id="bedc" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">如果你想了解更多关于机器学习、深度学习的内容，请访问下面的链接</p><div class="mc md ez fb me mf"><a rel="noopener follow" target="_blank" href="/@taunkdhaval08"><div class="mg ab dw"><div class="mh ab mi cl cj mj"><h2 class="bd hj fi z dy mk ea eb ml ed ef hh bi translated">Dhaval Taunk培养基</h2><div class="mm l"><h3 class="bd b fi z dy mk ea eb ml ed ef dx translated">在我最近的一篇博客文章《如何在文本分类任务中微调bert》中，我解释了如何针对一个问题来微调BERT</h3></div><div class="mn l"><p class="bd b fp z dy mk ea eb ml ed ef dx translated">medium.com</p></div></div><div class="mo l"><div class="nm l mq mr ms mo mt ik mf"/></div></div></a></div></div><div class="ab cl ne nf gp ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="hb hc hd he hf"><p id="52c6" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">快乐阅读……</p></div></div>    
</body>
</html>