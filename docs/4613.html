<html>
<head>
<title>F1Archive: A Python Library for Analsying F1 Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">F1Archive:用于分析F1数据的Python库</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/f1archive-a-python-library-for-analsying-f1-data-e40f831633a9?source=collection_archive---------7-----------------------#2021-11-30">https://medium.com/analytics-vidhya/f1archive-a-python-library-for-analsying-f1-data-e40f831633a9?source=collection_archive---------7-----------------------#2021-11-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/50e750004f2285a812fd1e6f5b42ad14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*ux6G89n2QBZ_3DSfA-hjJA.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx translated">资料来源:Unsplash.com</figcaption></figure><p id="73ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我开始分析一些F1历史数据的前一篇博客文章的基础上，我在这篇文章中讨论的代码库背后的想法是让导入在<a class="ae jn" href="https://www.formula1.com/en/results.html" rel="noopener ugc nofollow" target="_blank">一级方程式网站</a>上可用的数据变得非常简单，这样你就可以开始做自己的数据科学项目。存储库由几个类组成，只需要一两次方法调用和最少的参数，就可以从网站中提取数据。在引擎盖下，代码主要基于美丽的汤和熊猫，首先提取数据，然后将其转换为易于使用的格式。</p><p id="d94c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">目前，代码库是围绕三个主要类形成的，这三个类对应于三个感兴趣的领域:</p><ol class=""><li id="a01c" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated"><strong class="ir hi">车手总冠军:</strong>每个车手在整个赛季中的排位和积分。</li><li id="bfad" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi">排位赛表现:</strong>绝对时间以及队友和赛场其他人之间的相对表现。</li><li id="3cd3" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated"><strong class="ir hi">车队总冠军:</strong>总积分、可用积分的百分比以及几个赛季的趋势。</li></ol><p id="36dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这三个领域都补充了数据转换和可视化功能，以帮助进行数据分析。在本文的剩余部分，我将更详细地介绍每一项，并演示一些可用的功能。</p><p id="71c9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个库可以在github 上获得，并且包括每个驱动、资格和构造类的单独的教程笔记本。下载zip格式的代码并在本地运行可能是最好的开始方式。</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h2 id="dcf7" class="kj kk hh bd kl km kn ko kp kq kr ks kt ja ku kv kw je kx ky kz ji la lb lc ld bi translated">车手锦标赛</h2><p id="e166" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">对于车手冠军赛，我们感兴趣的是整个赛季每场比赛中每位车手的名次和积分。为了使这变得简单，库包含了一个<strong class="ir hi"> DataExtractor </strong>类，用于从一级方程式网站提取数据，并将其格式化为适合熊猫的模式。除了单个季节，我们还可以给它传递一个季节列表。</p><p id="2296" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> DataExtractor </strong>类是提取数据的基类，限定类和构造类从它继承而来(见下文)。下面的代码片段显示了获得整个赛季的结果是多么简单。我们首先调用类。然后我们调用<strong class="ir hi"> get_race_urls </strong>方法，同时传递所需的年份或年份列表。年份可以作为整数或字符串传递。这个方法搜索所有指向该赛季逐场比赛结果网页的URL。从那里，我们简单地调用<strong class="ir hi"> seasons_results </strong>方法，该方法从页面中提取数据并将其格式化为DataFrame。每年的结果都存储在一个字典中，以年份作为键，以数据帧作为值。</p><figure class="lj lk ll lm fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="c50f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2005赛季的样本数据框架显示了结果是如何存储的。对于每个车手，我们存储他们在该赛季每场比赛中的位置，以及得分。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lp"><img src="../Images/eef5b22fb3734ae7a065fd5c41e17aff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*caoYAX_X9Y9hXuhe_mR97A.png"/></div></div></figure><p id="f4e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">加载了位置和积分数据后，我们可以选择删除位置数据，只考虑积分(一般来说，积分数据比我们对每场比赛的位置所做的任何事情都更能提供信息)。这使得我们可以在数据框中为每个车手在赛季中的总积分添加一个新的列，并按照最终的冠军位置对数据进行重新排序。</p><p id="a717" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你更喜欢一个视觉上的冠军分数如何分解为任何一个特定的赛季，有一个基本的功能来绘制一个结果条形图，显示冠军一直到非得分者。在这里，重新排序的数据图表和随后的柱状图清楚地表明，2005年是费尔南多·阿隆索和基米·莱科宁之间的两匹马的比赛。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/8f39fd2f04f16a6c7a798e09342fddfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*jomXEtavzDeJ3rjN_n7Now.png"/></div></figure><p id="5a2f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看待车手总冠军的另一个有趣的方式是想象整个赛季的进程。有可能看到一场冠军争夺战是如何在一整年中激烈展开的。2005年，虽然看起来可能不像(看纽博格林)，阿隆索和莱科宁之间的争斗在赛季的大部分时间里都保持着相当的静止。累积图表显示了最初几场比赛后，差距变化有多小。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lv"><img src="../Images/86ddb45f932e0f9b53eef0267cae8897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TlyxXq62_mN2-G-NdLOPDQ.png"/></div></div></figure><p id="1caf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于车手比赛和冠军成绩的更多功能可以在相关的<a class="ae jn" href="https://github.com/cfcooney/F1Archive/blob/main/DriversChampData.ipynb" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中查看。</p><h2 id="0805" class="kj kk hh bd kl km kn ko kp kq kr ks kt ja ku kv kw je kx ky kz ji la lb lc ld bi translated">合格结果</h2><p id="4312" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">排位赛表现是一级方程式赛车中对赛车和车手的黄金标准速度测试。我并不认为这是我们判断一名车手速度的唯一标准，但这无疑是最明确的。出于这个原因，有几种方法可以从每场比赛中提取排位赛结果，也有助于队友之间以及相对于整个赛季的比赛成绩进行比较。除了这里的简要概述，我还写了一篇关于为资格结果开发的代码的<strong class="ir hi">姐妹贴</strong>，因为它比其他类稍微复杂一些。</p><p id="6abf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">quality extractor</strong>类继承自<strong class="ir hi"> DataExtractor </strong>并有效地执行相同的功能来鉴定结果，只是在本质上有一些不同。一年后，它会找到相应的网页网址，提取信息，并相应地将其格式化成数据帧。下面的代码片段显示了这是多么简单。</p><figure class="lj lk ll lm fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="84cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在下面看到，代码返回了1998年赛季中每场比赛的排位和排位赛时间。你可能已经注意到，每场名为“Team-mate”的比赛都有一组空列。这些列可以填充每个车手与队友的相对时间，从而能够进行比较性能分析，以显示车手的速度。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lw"><img src="../Images/b706e3fcd0730fde1e130725840cb5e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zcVmXRMKJd8ZvBE1q8J-lg.png"/></div></div></figure><p id="873e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">用于计算不同类型分析的数据转换的函数在<strong class="ir hi">data _ transformations . transformations . py</strong>文件中，有几个在限定时间执行操作。计算合格的增量需要一点处理，从字符串到日期时间的转换有很多工作要做，我在<strong class="ir hi">其他帖子</strong>中对此进行了更详细的介绍。</p><p id="56d4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了获得相对于队友的时间，<strong class="ir hi"> qualy_differences </strong>函数获取上述数据帧和一系列比赛名称，按“汽车”(制造商)过滤数据帧，并计算一对排位赛时间之间的差异。这给了我们下面修改后的数据框架，现在“队友”一栏已经填写完毕。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es lx"><img src="../Images/1d4f2eb1356ab5bb53f62175cc8cf51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UOKllBzDgr1BmM6bDvsvKg.png"/></div></div></figure><p id="d4c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以用这些信息做很多事情，这个库为不同的可视化提供了一套功能(见下文)。其中之一，<strong class="ir hi">plot _ teammate _ comparison</strong>允许我们显示给定赛季每场比赛中队友之间的相对差值。首先，我们必须堆叠数据帧以获得正确的绘图格式。为此，我们使用了<strong class="ir hi">quality extractor</strong>类的<strong class="ir hi"> stack_qualy_results </strong>。</p><figure class="lj lk ll lm fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="edb8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由此产生的图给我们一个合理的指标，两个司机之间的速度差异。在这里，负数表示更快的圈速……舒马赫当然占优——除了一场比赛，其他比赛都比他快，在16场比赛中有11场超过0.5秒！</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es ly"><img src="../Images/fb531ca79e669967baad551e3647518f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sf1w5n5j6gAWr65F5hK_-w.png"/></div></div></figure><p id="ca03" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以设想用合格数据做许多其他事情，并且可以在Jupyter笔记本<a class="ae jn" href="https://github.com/cfcooney/F1Archive/blob/main/QualifyingComparisons.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>中浏览一些图书馆提供的便利。</p><h2 id="0fb3" class="kj kk hh bd kl km kn ko kp kq kr ks kt ja ku kv kw je kx ky kz ji la lb lc ld bi translated">制造商锦标赛</h2><p id="36cf" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">与排位赛数据一样，<strong class="ir hi">数据提取器</strong>有一个子类用于提取车队冠军数据，<strong class="ir hi">T5被称为<strong class="ir hi">车队数据提取器</strong>。调用该方法的基本语法与前面相同，最初返回一个包含一个或多个冠军表的数据帧字典。</strong></p><figure class="lj lk ll lm fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="lj lk ll lm fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/d9a25855341397d6ec3729b9d83f8efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/1*w0Gh5XikZFT6cZ6NG4TVpA.png"/></div></figure><p id="fa82" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的数据框中可以看到，<strong class="ir hi"> champ_standings </strong>方法返回每个构造者的总积分、可用总积分的百分比以及任何车队实际可以获得的最大积分的百分比，即每场比赛中获得第一名和第二名的积分。可视化文件中的每一个数字列都有可用的绘图功能，这些功能将在<a class="ae jn" href="https://github.com/cfcooney/F1Archive/blob/main/ConstructorsChampData.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>演示。</p><p id="d23d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在本帖中，我们将关注多个赛季中球队表现的一个有趣趋势。为此，<strong class="ir hi"> TeamsExtractor </strong>类也可以用于提取多个季节的结果。下面的代码片段演示了如何绘制几个赛季的构造者积分数据。</p><figure class="lj lk ll lm fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1ffa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们将一个年份列表传递给<strong class="ir hi"> champ_standings </strong>方法，该方法返回一个数据帧字典。然后<strong class="ir hi"> get_seasons_df </strong>用于将几个季节的结果合并到一个数据帧中。在此方法中，另一种方法(<strong class="ir hi"> generic_team_names </strong>)用于将车队名称中的季节差异转换为一个单一实体，例如“红牛车队豪雅”转换为“红牛”(<strong class="ir hi">注:</strong>目前此方法在演示之外并不完全有效)。接下来，我们将数据堆叠成绘图格式(<strong class="ir hi">stack _ constructor _ trends</strong>)，最后，使用<strong class="ir hi">plot _ constructors _ trend</strong>可视化函数生成下图。</p><figure class="lj lk ll lm fd ii er es paragraph-image"><div role="button" tabindex="0" class="lq lr di ls bf lt"><div class="er es ma"><img src="../Images/076b03007310564bba937bf1bdc55fc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KfDdUGLHVgWA89602Oikxg.png"/></div></div></figure><p id="af6f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不出所料，梅赛德斯、法拉利和红牛在这段时间内占据了积分百分比的主导地位。只有法拉利在2020年大幅下滑。这张图表确实有助于直观地显示出最好的赛车和其他赛车在性能上的差距，并表明F1在混合动力时代并不像我们所想的那样具有竞争力。</p><p id="8346" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与车手和排位赛结果一样，这里有一个附带的笔记本用于记录车队数据<a class="ae jn" href="https://github.com/cfcooney/F1Archive/blob/main/ConstructorsChampData.ipynb" rel="noopener ugc nofollow" target="_blank"/>。</p><h2 id="7d89" class="kj kk hh bd kl km kn ko kp kq kr ks kt ja ku kv kw je kx ky kz ji la lb lc ld bi translated">可视化工具</h2><p id="9114" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">显然，如果人们想将这些代码用于数据科学项目，可视化将是一个重要的特性。目前，代码包含几个绘制数据不同方面的函数。这些可以在<strong class="ir hi"> visualization.viz.py </strong>文件中找到，该文件目前有9个这样的绘图功能。其中包括绘制排位赛场地分布和车队积分榜积分的功能。</p><p id="6ea2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这些绘图功能都在比赛、资格赛和构造者数据提取课程随附的三本笔记本中演示过。目前，可视化使用标准的Matplotlib和Seaborn方法，还没有优化配置来表示球队颜色。这是要添加到增强列表中的东西，增强列表有很多。</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h2 id="4118" class="kj kk hh bd kl km kn ko kp kq kr ks kt ja ku kv kw je kx ky kz ji la lb lc ld bi translated">未来的增强</h2><p id="cb16" class="pw-post-body-paragraph ip iq hh ir b is le iu iv iw lf iy iz ja lg jc jd je lh jg jh ji li jk jl jm ha bi translated">我必须承认，在承担这个项目时，我意识到F1的历史数据比我预期的要混乱得多！在某些情况下，我可能应该知道这会有点尴尬。例如，车队每年都会根据赞助商的支持而改变他们的名字，像最快圈速积分之类的东西并没有被整合。其他问题不太容易预测。2020赛季引起了一些问题，因为几个赛道举办了多场比赛，这在我第一次通过代码时没有考虑到。</p><p id="e7bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">肯定还有一些遗漏，需要进一步的工作。例如，viz_utils.py中的缩写是不完整的，颜色编码会很好，并且需要概括2016年以后的旧团队名称。所以，当你发现少了什么的时候，请随意修改。</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="9e27" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，如果你觉得这个东西有趣、有用或者值得继续开发，请在<a class="ae jn" href="https://github.com/cfcooney/F1Archive" rel="noopener ugc nofollow" target="_blank"> github </a>上给它点个赞或者打个星。</p></div></div>    
</body>
</html>