<html>
<head>
<title>Deploying Jupyter notebook as a web app with Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Heroku将Jupyter notebook部署为web应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploying-jupyter-notebook-as-a-web-app-with-heroku-d157b68bcccc?source=collection_archive---------1-----------------------#2021-04-09">https://medium.com/analytics-vidhya/deploying-jupyter-notebook-as-a-web-app-with-heroku-d157b68bcccc?source=collection_archive---------1-----------------------#2021-04-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/559b8b24738726583d9fb021bdf56ebd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1oJ_SBKtsOCcgV5L"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx translated">在<a class="ae hu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上由<a class="ae hu" href="https://unsplash.com/@kmuza?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carlos Muza </a>拍摄的照片</figcaption></figure><div class=""/><p id="1d14" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有多少次，你已经用python建立了一个预测性或描述性的模型，现在你想与他人分享你的工作来访问它？当数据不变时，可以通过共享Jupyter笔记本本身或静态HTML文件来实现。当数据实时变化，并且您希望每次运行代码时都有一组不同的输出时，这些选项就没有用了，这时就有必要将Jupyter notebook部署为一个web应用程序，它可以在每次重新加载页面时运行，并生成一组新的输出。</p><p id="dda8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然有<strong class="iw hy"> AWS、GCP、Azure、</strong>等付费选项。但这些更适合商业级应用或复杂沉重的模型，但如果我们想部署一个不那么沉重的模型而又不花费我们任何钱，那就是像<strong class="iw hy"> Heroku </strong>和<strong class="iw hy"> Binder </strong>这样的平台成为一个相当可行的选择。</p><p id="201e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我将通过构建一个基本的交互式仪表板来解释整个过程，然后展示如何用Heroku部署它。为了创建仪表板，我们使用的数据通过使用<strong class="iw hy"> Pushshift </strong> API从<strong class="iw hy"> Reddit </strong>中检索，并且使用<strong class="iw hy"> Plotly </strong>创建图表。</p><p id="f756" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将学习以下概念:</p><ul class=""><li id="1aee" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">使用<strong class="iw hy"> Pushshift </strong> API获取实时<strong class="iw hy"> Reddit </strong>数据</li><li id="0992" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用<strong class="iw hy">创建仪表板Plotly </strong></li><li id="9311" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">创建应用程序并作为<strong class="iw hy">本地主机</strong>使用<strong class="iw hy">瞧</strong></li><li id="6ceb" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">使用<strong class="iw hy"> Heroku </strong>部署为web应用。</li></ul><p id="3504" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以跟着完整的代码一起找到<a class="ae hu" href="https://github.com/NaquibAlam/voila_heroku_demo_2/blob/master/notebooks/Dashboard.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> <em class="kg">这里</em> </strong> </a> <strong class="iw hy"> <em class="kg">。</em> </strong></p><h1 id="9bab" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.获取实时Reddit数据</h1><p id="ac2f" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">Reddit是一个信息或数据丰富的平台。虽然有很多方法可以访问Reddit数据，但我们将使用一个非常有用和简单的API，名为<strong class="iw hy"> Pushshift，</strong>相关文档可以在<strong class="iw hy"> </strong> <a class="ae hu" href="https://github.com/pushshift/api" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> <em class="kg">这里</em> </strong> </a> <strong class="iw hy"> <em class="kg">找到。</em>T51】</strong></p><p id="5a18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们将讨论如何使用<strong class="iw hy"> Pushshift </strong> API获取数据。有两个主要的端点用于搜索Reddit上所有公开的评论和提交内容:</p><ul class=""><li id="aa22" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">【https://api.pushshift.io/reddit/search/comment/】<strong class="iw hy"><em class="kg"/></strong>:搜索评论</li><li id="bb2a" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><a class="ae hu" href="https://api.pushshift.io/reddit/search/submission" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">【https://api.pushshift.io/reddit/search/submission】</em></strong></a><strong class="iw hy"><em class="kg">/</em>:</strong>搜索投稿</li></ul><p id="52d0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有关API和所用不同参数的更多详细信息，请参考Pushshift文档。</p><p id="27cc" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们编写一个函数，它将根据查询项和Pushshift支持的其他参数来获取数据。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="2f2d" class="lt ki hx lp b fi lu lv l lw lx"><strong class="lp hy">def</strong> get_reddit_data(data_type, **kwargs):<br/>    <em class="kg">"""</em><br/><em class="kg">    Gets data from the pushshift api and returns it as json.</em><br/><br/><em class="kg">    data_type can be 'comment' or 'submission'</em><br/><em class="kg">    The rest of the args are interpreted as payload.</em></span><span id="a854" class="lt ki hx lp b fi ly lv l lw lx"><em class="kg">    Read more: https://github.com/pushshift/api</em><br/><em class="kg">    """</em><br/><br/>    base_url = f"https://api.pushshift.io/reddit/search/<em class="kg">{</em>data_type<em class="kg">}</em>/"<br/>    payload = kwargs<br/>    request = requests.get(base_url, params=payload)<br/>    <strong class="lp hy">return</strong> request.json()</span></pre><p id="0fda" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们想要获得最近48小时内包含单词“<strong class="iw hy"> covid </strong>”的1000条评论，按得分或upvotes排序。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8d28" class="lt ki hx lp b fi lu lv l lw lx">get_reddit_data(data_type="comment",        <em class="kg"># give me comments</em><br/>                   q="covid",               <em class="kg"># that mention 'python'</em><br/>                   after="48h",             <em class="kg"># in the last 48 hours</em><br/>                   size=1000,               <em class="kg"># maximum 1000 comments</em><br/>                   sort_type="score",       <em class="kg"># sort them by score</em><br/>                   sort="desc")             <em class="kg"># sort descending</em></span></pre><p id="6b42" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在接下来的部分中，我们还将了解如何检索提交的内容。</p><h1 id="e68c" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">2.使用Plotly创建仪表板</h1><p id="f4fa" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">当谈到在<strong class="iw hy"> Python </strong>中制作<strong class="iw hy">交互式</strong>情节时，<strong class="iw hy"> Plotly </strong>非常容易使用，并且提供了更多的灵活性。</p><p id="2c93" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，让我们使用Pushshift从Reddit获取数据。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d5a3" class="lt ki hx lp b fi lu lv l lw lx">data = get_reddit_data(data_type="comment",<br/>                       q="covid",<br/>                       after="48h",<br/>                       size=1000,<br/>                       aggs="subreddit" #group by subreddit column)</span></pre><p id="e46f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Pushshift API中的<strong class="iw hy"><em class="kg">aggs</em></strong><em class="kg"/>参数是指在subreddit上对结果进行分组。</p><p id="70ec" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于上面的函数返回了一个<strong class="iw hy"> JSON </strong>，我们需要在JSON dict中导航一点来获得我们需要的数据。下一节将向您展示我们拥有的所有列，但是我们的应用程序只需要几个。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="7658" class="lt ki hx lp b fi lu lv l lw lx">data = data.get("data") #take the data part from JSON<br/>df = pandas.DataFrame(data) #convert it to a dataframe<br/>df.head()</span></pre><p id="84e4" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们用<strong class="iw hy"> Plotly Express绘制结果。</strong></p><h2 id="cf60" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">2.1评论活动</h2><p id="49ad" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">我们想要绘制出在过去48小时内具有最多<strong class="iw hy">评论</strong>的前10个子条目，作为一个条形图。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="f9a3" class="lt ki hx lp b fi lu lv l lw lx"><strong class="lp hy">import</strong> <strong class="lp hy">plotly.express</strong> <strong class="lp hy">as</strong> <strong class="lp hy">px</strong></span><span id="fcb2" class="lt ki hx lp b fi ly lv l lw lx">df_plt= df["subreddit"].value_counts()[0:10] #top 10 subreddits and their counts<br/>x = df_plt.keys() #subreddits<br/>y = df_plt.values #counts</span><span id="7cb6" class="lt ki hx lp b fi ly lv l lw lx">px.bar(df_plt,<br/>       x=x,<br/>       y=y,<br/>       title=f"Subreddits with most comments having the term covid in the last 48h",<br/>       labels={"x": "Subreddits", "y": "# comments"},<br/>       color_discrete_sequence=[COMMENT_COLOR],<br/>       height=500,<br/>       width=800)</span></pre><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mm"><img src="../Images/2b6e5cbe5b251c8c0496646ff5ba1c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vrzbhnvrwy-E1kDm51OQcg.png"/></div></div></figure><h2 id="e9d7" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">2.2提交活动</h2><p id="7f50" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">类似地，我们可以绘制出提交最多<strong class="iw hy">的前10个子主题。</strong></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="809f" class="lt ki hx lp b fi lu lv l lw lx">data = get_reddit_data(data_type="submission",<br/>                          q="covid",<br/>                          after="48h",<br/>                          size=1000,<br/>                          aggs="subreddit").get("data")</span><span id="11f3" class="lt ki hx lp b fi ly lv l lw lx">df = pandas.DataFrame(data)<br/>df_plt= df["subreddit"].value_counts()[0:10]<br/>x = df_plt.keys() <br/>y = df_plt.values </span><span id="5f78" class="lt ki hx lp b fi ly lv l lw lx">px.bar(df_plt,<br/>       x=x,<br/>       y=y,<br/>       title= f"Subreddits with most submissions having the term covid in the last 48h",<br/>       labels={"x": "Subreddits", "y": "# comments"},<br/>       color_discrete_sequence=[COMMENT_COLOR],<br/>       height=500,<br/>       width=800)</span></pre><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mn"><img src="../Images/1526f83bae8c2b7dab382d1a1093b4e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haeQlFCinJETCq-WnwND3w.png"/></div></div></figure><h2 id="096f" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">2.3最受欢迎的评论</h2><p id="d06c" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">现在，让我们找出十大最受欢迎的<strong class="iw hy">评论</strong>，其中包含单词<strong class="iw hy"> covid </strong>。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="dd86" class="lt ki hx lp b fi lu lv l lw lx">data = get_reddit_data(data_type="comment", q="covid", after=48h, size=10, sort_type="score", sort="desc").get("data")</span><span id="f353" class="lt ki hx lp b fi ly lv l lw lx"># retain only the relevant columns<br/>df = pandas.DataFrame(data)[["author", "subreddit", "score", "body", "permalink"]]</span><span id="4a10" class="lt ki hx lp b fi ly lv l lw lx"># we only keep the first 100 characters of the body <br/>df.body = df.body.str[0:100] + "..."</span><span id="4274" class="lt ki hx lp b fi ly lv l lw lx"># we append the string to all the permalink entries<br/>df.permalink = "<a class="ae hu" href="https://reddit.com" rel="noopener ugc nofollow" target="_blank">https://reddit.com</a>" + df.permalink.astype(str)</span><span id="ad46" class="lt ki hx lp b fi ly lv l lw lx">print(f"\nTop 10 most upvoted comments having term covid in the last 48 hours\n")</span><span id="9f4c" class="lt ki hx lp b fi ly lv l lw lx"># style the last column to be clickable and print<br/>df.style.format({'permalink': make_clickable})</span></pre><p id="7e3b" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要使一列可点击，我们可以对该列应用以下函数:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="03f2" class="lt ki hx lp b fi lu lv l lw lx">def make_clickable(val):<br/>    """<br/>    Makes a pandas column clickable.<br/>    """<br/>    <br/>    return '&lt;a href="{}"&gt;Link&lt;/a&gt;'.format(val)</span></pre><p id="7e37" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以上代码将返回过去48小时内<strong class="iw hy">投票最多的前10条评论</strong>:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mo"><img src="../Images/33659f3aa901380949ebf9f5a9781c5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KhInjMrjg-TNYpj9orynYw.png"/></div></div></figure><h2 id="3b7a" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">2.4评论最多的意见书</h2><p id="72e1" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">同样，我们可以获得过去48小时内评论最多的<strong class="iw hy">提交内容</strong>。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8264" class="lt ki hx lp b fi lu lv l lw lx">data = get_reddit_data(data_type="submission", q="covid", after=48h, size=10, sort_type="num_comments", sort="desc").get("data")</span><span id="c08a" class="lt ki hx lp b fi ly lv l lw lx"># retain only the relevant columns<br/>df = pandas.DataFrame(data)[["author", "subreddit", "num_comments", "title", "permalink"]]</span><span id="a967" class="lt ki hx lp b fi ly lv l lw lx"># we only keep the first 100 characters of the body <br/>df.body = df.body.str[0:100] + "..."</span><span id="09c3" class="lt ki hx lp b fi ly lv l lw lx"># we append the string to all the permalink entries<br/>df.permalink = "<a class="ae hu" href="https://reddit.com" rel="noopener ugc nofollow" target="_blank">https://reddit.com</a>" + df.permalink.astype(str)</span><span id="e24f" class="lt ki hx lp b fi ly lv l lw lx">print(f"\nTop 10 most commented submissions having the term covid in the last 48 hours\n")</span><span id="9818" class="lt ki hx lp b fi ly lv l lw lx"># style the last column to be clickable and print<br/>df.style.format({'permalink': make_clickable})</span></pre><p id="6590" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">上述代码将返回过去48小时内评论最多的前10个提交内容:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mp"><img src="../Images/53a6dff4577000286c80098d26c04c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*riyxqo9yx4cEWbY9M-pO_A.png"/></div></div></figure><h2 id="20d6" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">2.5/r/covid subreddit中的评论意见时间线</h2><p id="9f0b" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">让我们找出<a class="ae hu" href="https://www.reddit.com/r/COVID/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">/r/covid</em></strong></a>subreddit中的评论在某种时间线上的情绪，比如说48小时。我们已经知道如何检索评论，但是如何获得这些评论的情感呢？为此，我们将使用一个名为<a class="ae hu" href="https://textblob.readthedocs.io/en/dev/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">text blob</em></strong></a><strong class="iw hy"><em class="kg">的库。</em> </strong>文献资料为此找到了<strong class="iw hy"><em class="kg"/></strong><a class="ae hu" href="https://textblob.readthedocs.io/en/dev/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">这里的</em> </strong> </a> <strong class="iw hy"> <em class="kg">。</em> </strong></p><ul class=""><li id="0221" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iw hy"> TextBlob </strong>对象的<code class="du mq mr ms lp b"><a class="ae hu" href="https://textblob.readthedocs.io/en/dev/api_reference.html#textblob.blob.TextBlob.sentiment" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy">sentiment</strong></a></code>属性是一个形式为<code class="du mq mr ms lp b">Sentiment(polarity, subjectivity)</code>的命名元组。</li><li id="4a0e" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">极性</strong>分数在[-1.0，1.0]范围内浮动。</li><li id="4522" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iw hy">主观</strong>是在【0.0，1.0】范围内的浮动，其中0.0非常<strong class="iw hy">客观</strong>，1.0非常<strong class="iw hy">主观</strong>。</li><li id="018d" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">当情感极性大于或等于零时，我们称之为<strong class="iw hy">积极</strong>评论<strong class="iw hy">其他<strong class="iw hy">消极</strong>。</strong></li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="a435" class="lt ki hx lp b fi lu lv l lw lx">data = get_reddit_data(data_type="comment", after=48h, size=1000, sort_type="score", sort="desc", subreddit="covid").get("data")</span><span id="501e" class="lt ki hx lp b fi ly lv l lw lx">df = pandas.DataFrame(data)[["author", "body", "created_utc", "score", "permalink"]]</span><span id="3d80" class="lt ki hx lp b fi ly lv l lw lx">df["sentiment_polarity"] = df.apply(lambda row: textblob.TextBlob(row["body"]).sentiment.polarity, axis=1)</span><span id="32d0" class="lt ki hx lp b fi ly lv l lw lx">df["sentiment_subjectivity"] = df.apply(lambda row: textblob.TextBlob(row["body"]).sentiment.subjectivity, axis=1)</span><span id="432b" class="lt ki hx lp b fi ly lv l lw lx">df["sentiment"] = df.apply(lambda row: "positive" if row["sentiment_polarity"] &gt;= 0 else "negative", axis=1)</span><span id="a1c0" class="lt ki hx lp b fi ly lv l lw lx">df["preview"] = df["body"].str[0:100]</span><span id="f253" class="lt ki hx lp b fi ly lv l lw lx">df["date"] = pandas.to_datetime(df['created_utc'],unit='s')</span><span id="f675" class="lt ki hx lp b fi ly lv l lw lx">px.scatter(df, x="date", <br/>               y="sentiment_polarity",<br/>               hover_data=["author", "permalink", "preview"],<br/>               color_discrete_map={"positive": "lightseagreen", "negative": "indianred"},<br/>               color="sentiment",<br/>               size_max=10,<br/>               labels={"sentiment_polarity": "Comment positivity", "date": "Date, comment was posted"},<br/>               title=f"Comment sentiment in /r/covid for the past 48 hours",<br/>          )</span></pre><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/c62720bee57dfeaed854b3ac066b8583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULAAsWx1RuH6ls1mRA7pSw.png"/></div></div></figure><p id="5009" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的剧情中，我们可以看到最近48小时<strong class="iw hy"> <em class="kg"> /r/covid </em> </strong>中的评论。我们可以看到大多数评论都是积极的。</p><h1 id="3d23" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">3.将仪表板作为web应用程序创建和部署</h1><p id="1437" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">一旦我们有了基本的交互式仪表板，我们就可以使用<strong class="iw hy"> Voila </strong>创建应用程序，并使用<strong class="iw hy"> Heroku </strong>部署它。</p><h2 id="487d" class="lt ki hx bd kj lz ma mb kn mc md me kr jf mf mg kv jj mh mi kz jn mj mk ld ml bi translated">瞧，赫罗库</h2><p id="0964" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">一旦我们准备好笔记本，我们可以从终端运行下面的命令，但这将启动网站作为<strong class="iw hy"> localhost。</strong></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5705" class="lt ki hx lp b fi lu lv l lw lx">voila MyApp.ipynb</span></pre><p id="b67a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注</strong> : <strong class="iw hy">瞧</strong>隐藏笔记本的代码部分，只显示<strong class="iw hy">输出</strong>和<strong class="iw hy">降价</strong>单元格。这就是为什么当涉及到与那些技术上不熟练并且对查看代码不感兴趣的人分享工作时,<strong class="iw hy">瞧,</strong>会大放异彩。</p><p id="8f18" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">将我们的<strong class="iw hy"> Voila </strong>应用部署为一个公共网站，这样任何有链接的人都可以访问它，这时<strong class="iw hy"> Heroku </strong>就变得很方便了。</p><p id="4310" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">以下是使用Heroku部署笔记本电脑的步骤:</p><ul class=""><li id="13fd" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">首先，我们需要创建以下三个文件:</li></ul><ol class=""><li id="5a0c" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr mu jy jz ka bi translated"><strong class="iw hy"> requirements.txt: </strong>它告诉Heroku安装哪些Python包来运行web应用程序。</li><li id="436d" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mu jy jz ka bi translated">它指定了我们希望Heroku使用哪个Python版本。你必须在这里检查<a class="ae hu" href="https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-python" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg"/></strong></a>哪些python运行时选项是当前Heroku版本支持的，并且在runtime.txt中只提到其中一个。</li><li id="57f0" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr mu jy jz ka bi translated">Procfile: 它包括Heroku部署我们的<strong class="iw hy"> Voila </strong>应用程序的指令。它应该是这样的:</li></ol><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="1781" class="lt ki hx lp b fi lu lv l lw lx">web: voila --port=$PORT --no-browser --enable_nbextensions=True notebooks/Dashboard.ipynb</span></pre><p id="f550" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">它告诉Heroku拿着笔记本<strong class="iw hy"><em class="kg">notebooks/dashboard . ipynb</em></strong>，用<strong class="iw hy"> Voila </strong>创建一个app，作为<strong class="iw hy"> web app </strong>。</p><p id="5ea2" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在我的<a class="ae hu" href="https://github.com/NaquibAlam/voila_heroku_demo_2" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">Github</em></strong></a>repo上查看所有这些文件的内容。</p><p id="97cd" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意</strong>:您必须将这些文件放在Git repo的即时文件夹(顶层)中，并相应地在<strong class="iw hy"> Procfile </strong>中提供笔记本的路径。您的web应用程序文件夹应该如下所示:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="d474" class="lt ki hx lp b fi lu lv l lw lx">voila_heroku_demo_2/<br/>    ├── notebooks/<br/>    │   └── Dashboard.ipynb<br/>    ├── requirements.txt<br/>    ├── Procfile<br/>    └── runtime.txt</span></pre><ul class=""><li id="afad" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">创建一个远程Git repo，并使用通常的Git工作流推送所有这些文件。</li><li id="1b12" class="js jt hx iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">运行<em class="kg"> </em> <strong class="iw hy"> <em class="kg"> heroku登录</em> </strong>登录到您的heroku帐户然后<strong class="iw hy"> <em class="kg"> </em> </strong>运行<strong class="iw hy"> <em class="kg"> heroku创建</em> </strong>从终端<strong class="iw hy"> <em class="kg"> </em> </strong>为您创建web app。</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="7c55" class="lt ki hx lp b fi lu lv l lw lx">heroku login<br/>heroku create</span></pre><p id="3237" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出将如下所示:</p><figure class="lk ll lm ln fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mv"><img src="../Images/4fa87309833d66ce2dc8ca87ebfb8cd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4jt6tHfkkRzVWMNRXKRpoA.png"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx translated">heroku创建后的输出</figcaption></figure><ul class=""><li id="cc39" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">正如我们从上图中看到的，Heroku用一些随机的名字创建了应用程序，您应该通过从终端运行以下命令用一个更相关的名字来重命名它:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="8077" class="lt ki hx lp b fi lu lv l lw lx">heroku apps:rename reddit-monitoring-dashboard --app infinite-peak-81768</span></pre><ul class=""><li id="f6b0" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">现在，我们应该创建一个名为<strong class="iw hy"> <em class="kg"> heroku </em> </strong>的与git repo相关联的远程，如下所示:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="eb1c" class="lt ki hx lp b fi lu lv l lw lx">heroku git:remote -a reddit-monitoring-dashboard</span></pre><p id="1294" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，如果我们运行<strong class="iw hy"> <em class="kg"> git remote -v </em> </strong>，它应该输出两个remote:<strong class="iw hy"><em class="kg">origin</em></strong>和<em class="kg"> heroku </em> 。</p><ul class=""><li id="78e7" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">我们需要执行最后一步，通过运行以下命令来安装所有依赖项、构建源代码和部署应用程序:</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3ca5" class="lt ki hx lp b fi lu lv l lw lx">git push heroku master</span></pre><p id="e89a" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在部署应用程序时，我们可以运行<strong class="iw hy"> <em class="kg"> heroku log -t </em> </strong>来检查日志中是否有错误发生。</p><ul class=""><li id="0fe9" class="js jt hx iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">一旦应用程序部署完毕，您可以运行<strong class="iw hy"> <em class="kg"> heroku open </em> </strong>在网络浏览器中启动应用程序。这也可以通过浏览器中的Heroku仪表板来完成。</li></ul><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="e6d5" class="lt ki hx lp b fi lu lv l lw lx">heroku open</span></pre><p id="f87e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这将在浏览器中为您启动web应用程序。根据笔记本的重量，加载需要一点时间。</p><p id="1ab8" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你可以在这里  找到我的web app <a class="ae hu" href="https://reddit-monitoring-dashboard.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> <em class="kg">。每次重新加载页面时，它都会显示不同的输出。</em></strong></a></p><p id="2604" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">注意</strong>:这里，我已经用<strong class="iw hy"> Voila </strong>创建了web app，并用<strong class="iw hy"> Heroku </strong>部署了它。您可以选择任何其他框架，如<strong class="iw hy">烧瓶</strong>、<strong class="iw hy"> Django </strong>等。创建可以使用Heroku 的web应用程序。</p><h1 id="daa2" class="kh ki hx bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">结论</h1><p id="d64f" class="pw-post-body-paragraph iu iv hx iw b ix lf iz ja jb lg jd je jf lh jh ji jj li jl jm jn lj jp jq jr ha bi translated">我们已经讨论了使用<strong class="iw hy"> Pushshift </strong>从<strong class="iw hy"> Reddit </strong>中检索实时数据，使用<strong class="iw hy"> Plotly Express </strong>制作情节，使用<strong class="iw hy"> Voila </strong>创建应用程序，并使用<strong class="iw hy"> Heroku </strong>部署它。你可以在这里  找到Github repo <a class="ae hu" href="https://github.com/NaquibAlam/voila_heroku_demo_2/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> <em class="kg">，在这里</em> </strong> </a>找到已部署的live dashboard <a class="ae hu" href="https://reddit-monitoring-dashboard.herokuapp.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hy"> <em class="kg">。</em></strong></a></p><p id="c1af" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如有任何反馈或疑问，请随时联系我的<a class="ae hu" href="https://www.linkedin.com/in/naquib-alam-93804435/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hy"><em class="kg">LinkedIn</em></strong></a><strong class="iw hy"><em class="kg"/></strong>。</p></div></div>    
</body>
</html>