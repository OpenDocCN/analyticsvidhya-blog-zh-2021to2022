<html>
<head>
<title>Maze Problem In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的迷宫问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/maze-problem-in-python-b303797b03ee?source=collection_archive---------2-----------------------#2021-01-19">https://medium.com/analytics-vidhya/maze-problem-in-python-b303797b03ee?source=collection_archive---------2-----------------------#2021-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="d3d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将看看非常重要的面试观点问题(迷宫问题)以及如何用python一步一步地解决这个问题。</p><p id="6f3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如果你来这里只是为了节目滚动到文章的最后</em></p><p id="c721" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">迷宫是一个2D矩阵，其中一些细胞被堵塞。其中一个单元格是源单元格，我们必须从这里开始。另一个是目的地，我们必须到达的地方。我们必须找到一条从源到目的地的路径，而不进入任何被封锁的小区。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1f9b14d83efcf979a1c1b093ceb1b8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VQUIri4Y7OqHx7cHN0jpA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">迷惑</figcaption></figure><p id="f4f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无taions</p><blockquote class="ju jv jw"><p id="30fd" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">1:可步行路径</p><p id="95ff" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">0:不可行走的路径</p><p id="db4c" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">s:起点(起点将是(0，0))</p><p id="f901" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">目标(在程序中我们用整数9来表示目标)</p></blockquote><p id="317d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当你看到问题时，你首先想到的应该是如果起点不可行走怎么办(0)如果起点不可行走，那么你应该立即返回假或不可能。在解决问题时，思考边缘案例非常重要，因为在网上判断时，你不会因此出错，而在电话面试中，这表明你对问题有多清楚。</p><p id="7047" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的例子中，我们的起点是可步行的，所以我们可以开始我们的算法</p><p id="dcd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用BFS回溯，这个问题也可以用DFS解决。</p><p id="97e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">关键步骤:</p><p id="037c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1:定义全局(开始、结束、可行走、不可行走、迷宫维度)</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="96c3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里我们的迷宫大小是8 x 8</p><p id="ee2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2:BFS实施步骤</p><blockquote class="ju jv jw"><p id="f809" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">步骤1:初始化队列</p><p id="19ba" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">步骤2:初始化已访问列表/集合</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="37ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们初始化我们的队列，并看到设置。注意，我使用“seen”作为set，因为它提供了0(1)个查找时间。但是如果你需要输出路径，你也可以声明一个单独的列表来跟踪路径，因为集合是无序的，我们不能依赖它</p><blockquote class="ju jv jw"><p id="4cd8" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">第三步:检查我们是否达到目标</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ka kb l"/></div></figure><p id="a945" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这一步是不言自明的，我们正在检查我们是否在目的地，如果是，终止程序</p><blockquote class="ju jv jw"><p id="a484" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">步骤4:遍历所有可能的方向(东、西、北、南)</p><p id="9d86" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">第五步:检查条件</p></blockquote><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ka kb l"/></div></figure><blockquote class="ju jv jw"><p id="7905" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">在第1行，我们有允许方向的方向元组</p><p id="05b1" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">第2行:我们正在检查我们是否在有效列</p><p id="1dd4" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">第3行:我们正在检查我们是否在有效行</p><p id="3d67" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">在第4行，我们检查当前单元格是否是墙</p><p id="9f83" class="if ig jd ih b ii ij ik il im in io ip jx ir is it jy iv iw ix jz iz ja jb jc hb bi translated">在第5行，我们检查我们是否访问了这个单元</p></blockquote><p id="5db0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果所有4个条件都为真，那么我们知道我们在有效的单元，我们标记该单元被访问，并继续我们的循环，直到没有单元留下，如果路径存在，我们要么到达目标，否则程序将返回无</p><h1 id="fc91" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">完整的项目</h1><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="ka kb l"/></div></figure><pre class="jf jg jh ji fd la lb lc ld aw le bi"><span id="cdfc" class="lf kd hi lb b fi lg lh l li lj">Usage: Python filename.py</span></pre><p id="f262" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将要求输入粘贴在CMD块下面</p><pre class="jf jg jh ji fd la lb lc ld aw le bi"><span id="e3ba" class="lf kd hi lb b fi lg lh l li lj">8 8<br/>1 0 1 1 1 0 0 1<br/>1 0 0 0 1 1 1 1<br/>1 0 0 0 0 0 0 0<br/>1 0 1 0 9 0 1 1<br/>1 1 1 0 1 0 0 1<br/>1 0 1 0 1 1 0 1<br/>1 0 0 0 0 1 0 1<br/>1 1 1 1 1 1 1 1</span></pre><p id="ab28" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这样，祝贺你已经在矩阵上实现了BFS，现在像这样多练习。</p><p id="59fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个问题有很多变化，比如他们可能会给你自定义的目的地坐标，你只能向两个方向或四个方向移动等等。但是一旦你理解了基本的概念，就很容易实现其他的变化</p><p id="f45d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请继续关注下一篇文章，我们将在那里解决来自leet code/二分搜索法的问题</p></div></div>    
</body>
</html>