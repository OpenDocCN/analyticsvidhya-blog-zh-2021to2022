<html>
<head>
<title>General speaking about convolutional neural network</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积神经网络概述</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/general-speaking-about-convolutional-neural-network-f656e576a110?source=collection_archive---------9-----------------------#2021-09-17">https://medium.com/analytics-vidhya/general-speaking-about-convolutional-neural-network-f656e576a110?source=collection_archive---------9-----------------------#2021-09-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7fa0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上个月，我向一群物理学家介绍了CNN的工作原理。我尽可能简单地介绍了这一点，并收到了积极的反馈，所以我决定与更大的社区分享它。</p><ol class=""><li id="4d25" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">一般条款:</li></ol><p id="91cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.1.简单说说像素</p><p id="41e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">看下图。一张800乘800的普通图片，总共有640，000个像素。这张简单的图像由50多万像素组成。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es jl"><img src="../Images/59cb8d3057631dc4e314a66ee5e81e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oJS5nVJgbp5Spt0RDPse1Q.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图1 .常见图像尺寸</figcaption></figure><p id="8d0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们更仔细地观察图像的一部分(图2)，可以清楚地看到每个物体都是由许多不同颜色的像素组成的。并且每个像素本身是具有从0到255的不同强度的红、绿和蓝三种颜色的组合。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kb"><img src="../Images/cf11877770eea7285b227491891a0845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6EbKL9PWu6COMhQ2jluInA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图2 .图像及其像素</figcaption></figure><p id="5c61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每个像素中，通过组合从0到255的红色、绿色和蓝色中每种颜色的不同强度，可以产生各种颜色。在图3中，1号形状显示了一种状态，其中只有红光以最大强度存在，其他颜色关闭，在这种情况下，整个像素将完全为红色。类似地，图2、3和4显示了如何创建紫色、黑色和白色。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kc"><img src="../Images/66fcdb21d416e5e51e254d908976b1ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8H-mMZoXh4L-INrQzg8kKA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图3 .通过像素产生不同的颜色</figcaption></figure><p id="0f97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，当我们在谈论一个丰富多彩的形象时；在场景背后，我们有三个不同的数字矩阵，它们代表红色、绿色和蓝色的不同强度(图4)。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kd"><img src="../Images/dcfb285b42acbfe0d00e44c0c42fb8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*yxt6mHJWkQuQpCzhqPqKwg.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图4三个颜色通道</figcaption></figure><p id="de23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，当我们谈论黑白图像时，我们只有一个矩阵，没有必要进一步的维度。因为在黑白图像中，红色、绿色和蓝色的强度彼此相等(图5)。为了更简单，我们将继续讨论黑白图像。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ke"><img src="../Images/98160e13f56204882e8e4d7a44b1a8cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*OO3nj-tfqHqMshCTofGb0Q.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图5 .黑白图像矩阵</figcaption></figure><p id="a26a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，像素是如何工作的已经很清楚了，我们知道每幅图像背后都有一个数字矩阵(图6 ),代表监视器屏幕像素的光强度。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kf"><img src="../Images/caa6a67bc29088e7dce5be849f73ba57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXWn0hbY07OOtiiEWniJYQ.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图6 .图像及其强度矩阵</figcaption></figure><p id="6961" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">1.2.内核简介</p><p id="63cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">内核是什么？维基百科说:“在图像处理中，内核、卷积矩阵或遮罩是一个小矩阵，用于模糊、锐化、浮雕、边缘检测等。”通常，可以使用内核对图片进行一些操作。在图7中，我们试图使用内核从原始图像生成一个图像(转换后的图像)。以这种方式，内核的所有数字在原始图像数字的第一部分上相乘，并且结果将是转换的图像强度的第一个数字。我们将对图8、9和10做同样的事情，但是移动内核并覆盖原始图像的所有部分。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kg"><img src="../Images/f01b554fbc5e31f295f7802a16eda4c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BODFdT3eYPKejehZFq7UKw.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图7 .内核功能步骤1</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kh"><img src="../Images/37d7d3a7a9e9269417d2a0dac5e24643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1lZlGm4_74m21NKN63SXug.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图8 .内核功能步骤2</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ki"><img src="../Images/c622b9be774c5fda4c480936c1329b64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5_HffEoiOdXg3EgSSnOOMA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图9 .内核功能步骤3</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ki"><img src="../Images/e19577420bd231c596835e7a8060e350.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXeq1EzXZ_SFXCSROG1XNA.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图10 .内核功能步骤4</figcaption></figure><p id="b9e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以在图11中看到一个内核在图像上移动的例子。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kj"><img src="../Images/0717ea3f9d40e0093b8068aac4d5c8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*5q5pzDNRvI6KPgqeoODZqQ.gif"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图11 .内核在原始图像上的移动示例</figcaption></figure><p id="1546" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图12是图11图像的转换图像。在图12的右侧，有一个垂直内核。换句话说，第一列的所有数字都等于1，第二列等于0，最后一列是-1。使用这个内核，可以准确地看到垂直线，并删除水平线。这就是为什么你看不到红盒子里面的水平线。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kk"><img src="../Images/30fca18e46c46a2df624781a54684328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/1*eq6wH6gD7LP4I-aACNmJBw.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图12 .垂直内核的功能</figcaption></figure><p id="0fc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图13中的一切都是一样的，但是这个内核是水平的，这对于精确研究原始图像的水平线是一个很好的选择。同样，你看不到红框内的垂直线。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kl"><img src="../Images/5f9bc06f37cd740c069e397093a1e788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*PiKkAX7xXyQD0IMKf67Vcg.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图13 .水平内核的功能</figcaption></figure><p id="5474" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用不同的内核，可以生成各种类型的图像来研究图像的不同方面。在下面的三张图中，你可以看到更多不同内核的例子。另外，如果你有兴趣制作你的内核并在你的图片上试用，你可以使用这个网站:<a class="ae km" href="https://setosa.io/ev/image-kernels/" rel="noopener ugc nofollow" target="_blank">https://setosa.io/ev/image-kernels/</a></p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kn"><img src="../Images/b1b3c18b4f4330654688ea8ba1f25d9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebFv9HPDfxBJf3SGGNj8Gw.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图14 .内核能力的例子</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es ko"><img src="../Images/2f9e33b7dfa43c8b975fb6b0f51e3682.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_NNMTy5LydeSqSydWpuLyw.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图15 .内核能力的例子</figcaption></figure><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kp"><img src="../Images/fc6e33799fd366e2a2520097de1495ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nsOnoMdMbl25Ujh6S-rU7A.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图16 .内核能力的例子</figcaption></figure><p id="cda4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.卷积神经网络</p><p id="501d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在传统模型中，图像处理研究人员(大多数是电气工程师)一起研究不同的核组合，以根据他们的目标找到最佳的核组合。很明显，这非常耗时耗力，而且肯定不是所有有效的内核组件都能被识别。CNN最重要的能力之一是，它可以根据定义的目标自动检查内核的不同组合(数千或数百万)，并使用最好的组合。图17显示了CNN模型的不同部分。第一部分是特征提取器。在这一部分中，模型能够获得图像并进行搜索以找到核的最佳组合，并基于最终目标提取最佳特征。展平图层是特征提取部分的输出。可以将展平图层视为一个表示输入图像关键特征的数字框。因此，CNN的特征提取部分能够将输入图像转换成一盒有意义的数字。接下来，像神经网络这样的简单分类器能够根据这些数字进行分析和决策。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kq"><img src="../Images/68364611b444845b7c6bada979de9991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qzr6J3fvih2sFZ2MS1QTg.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图17 .卷积神经网络部分</figcaption></figure><p id="e27b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个名为AlexNet的CNN模型于2012年推出(图18)，成功赢得了ImageNet大规模视觉识别挑战赛(ILSVRC)。使用这种模式，与前一年相比，错误率降低了10%以上。更重要的是，这个模型成为图像处理进一步飞跃的基础。第二次飞跃发生在2015年，当时微软推出了名为ResNet的模型。这个模型比人的眼睛更准确，并且由于其架构的一些创新，与以前的模型(GoogLeNet有22层)相比，它能够使用大量的层(152层)。</p><p id="2714" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2014年推出的VGG16是一款精确的模型，架构简单，易于实现。这些特征使得该模型成为其他领域的研究和科学工作的良好选择。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kr"><img src="../Images/a5fe1ddd800c7cfb1256fac62e90263f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LopjC7ZwXH85_TTt30F88A.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图17 .基于年份的ILSVRC错误率</figcaption></figure><p id="96ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">深度模型的使用一直有两个主要问题，对大型数据集的需求和解释它们如何工作的困难。基于图18，使用深度模型有可能达到非常精确的结果，但是它需要大量的数据。否则，使用机器学习算法或经典统计会更加准确和合理。但是，使用迁移学习，CNN模型中对大数据集的需求得到了很好的回答。这种能力使得CNN即使与其他类型的深度模型相比也非常强大和有用。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es ks"><img src="../Images/b94115dbf2e9c98952c71eea2c819436.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*q-b169QwupCWREXY6TJeEQ.png"/></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图18 .基于数据量的不同方法</figcaption></figure><p id="a517" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设，如图19所示，开发了一个CNN模型来识别大量人的面部。在这种情况下，模型的第一层负责识别颜色、线条和一般的简单实体。中间层负责识别更复杂的实体，如眼睛、耳朵和嘴唇等面部组件。这个例子中的最后几层负责识别面部成分的组合，并且通常同时考虑所有面部成分。</p><p id="dd5a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你想做另一个项目时，例如在汽车模型识别领域，你可以使用开发的模型的第一层来识别面部。因为这些层负责识别线条和颜色等简单的实体，顺便教他们是问题的一大部分。因此，现有模型的第一层，有时是在数十亿张图像上训练的，可以用于其他新问题，并可以显著提高新模型的性能。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="jr js di jt bf ju"><div class="er es kt"><img src="../Images/0a1cc74cc4b2d6fec7c9dbaaa7843899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNCCFwY8f-n354HGe_wGjw.png"/></div></div><figcaption class="jx jy et er es jz ka bd b be z dx translated">图19 . CNN模型的不同层</figcaption></figure><p id="4560" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，你可以看一个视频，在这个视频中，我试着用我用迁移学习法开发的CNN模型玩超级马里奥。这个视频是两类分类问题的一个实用而简单的例子。所以，只有两类。扬眉=第一跳然后连续跑，皱眉=停下来不动</p><p id="89fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae km" href="https://youtu.be/_h15_uBuL70" rel="noopener ugc nofollow" target="_blank">https://youtu.be/_h15_uBuL70</a></p></div></div>    
</body>
</html>