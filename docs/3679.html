<html>
<head>
<title>The best reference guide to master Classes in Python in 2021.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年Python中大师类的最佳参考指南。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-best-reference-guide-to-master-classes-in-python-in-2021-60dbe4482f40?source=collection_archive---------8-----------------------#2021-07-17">https://medium.com/analytics-vidhya/the-best-reference-guide-to-master-classes-in-python-in-2021-60dbe4482f40?source=collection_archive---------8-----------------------#2021-07-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="7971" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">用新方法与python中的类交互。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/fc03a648a758c4a246ef79218f2ce0a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*hUaaVlT9ZwBl32nt.jpeg"/></div></div></figure><p id="92c1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在市场上看到许多不同的蔬菜。它们有不同的形状、颜色和大小。然而，它们都属于蔬菜类。我们可以用类似的方式思考Python中的类。一个类代表一种类型(蔬菜)，我们可以创建该类型的许多实例(市场上不同的蔬菜，如胡萝卜、西红柿等)。</p><p id="a974" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">面向对象编程(OOP)模型是围绕拥有属于特定类型的对象的思想而构建的。类型是解释对象的东西。</p><p id="5e19" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">对一个对象的解释对理解OOP很重要。我们需要彻底了解:</p><ul class=""><li id="b9f4" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated">一个物体意味着什么</li><li id="95a9" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">该对象存储什么类型的数据</li><li id="9739" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">我们如何与物体互动</li><li id="c5b9" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">我们如何在代码中执行对象</li></ul><p id="2ce3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">构成对象解释的这些点是用类定义的。Python中的一切都是不同类型的对象，如整数、列表、字典、函数等。我们使用类来定义这些类型的对象。</p><p id="712d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">今天在这篇文章中，我们将回顾Python中的类的含义，如何在Python中创建和使用类，以及使用类能给我们带来什么样的好处。</p><p id="135c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ks">那么，没有任何进一步的到期让我们开始吧！！！</em>T3】</strong></p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><p id="fbc9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">类别拥有以下内容:</p><ul class=""><li id="10fe" class="ke kf hh jk b jl jm jo jp jr kg jv kh jz ki kd kj kk kl km bi translated"><strong class="jk hi">数据属性</strong>:创建类的实例时需要</li><li id="170b" class="ke kf hh jk b jl kn jo ko jr kp jv kq jz kr kd kj kk kl km bi translated">方法:这显示了我们与类的实例交互的方式。</li></ul><p id="baf0" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们使用Python中的类最多。例如，当我们创建一个列表时，我们创建了一个类型列表的实例。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="1536" class="lf lg hh lb b fi lh li l lj lk">words = ['data', 'science', 'machine', 'learning']</span></pre><p id="69d1" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们实际上对list类是如何创建的并不感兴趣。我们只需要知道如何与列表交流，并在代码中有效地使用它们。这是一个<strong class="jk hi">抽象</strong>。</p><p id="770c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，我们也可以使用remove方法从列表中删除一个条目。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="95ea" class="lf lg hh lb b fi lh li l lj lk">words.remove('data')print(words)<br/>['science', 'machine', 'learning']</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="4c94" class="ll lg hh bd lm ln lo lp lq lr ls lt lu in lv io lw iq lx ir ly it lz iu ma mb bi translated">创建一个类</h1><p id="b29a" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">下面的代码创建了一个名为Book的类。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="be7c" class="lf lg hh lb b fi lh li l lj lk">class Book():  <br/>    def __init__(self, name, writer, word_length):<br/>        self.name = name<br/>        self.writer = writer<br/>        self.word_length = word_length</span></pre><p id="0b86" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">__init__是一个特殊的函数，当创建一个类的实例时，它会自动执行。它也被称为构造函数。</p><p id="1a3a" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">__init__函数的参数表示类的数据属性。</p><p id="6e0b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">自我指的是实例。你可以用任何词代替“自我”,我们用“自我”是因为它很常见。</p><p id="f0c2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">创建实例</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="5ae5" class="lf lg hh lb b fi lh li l lj lk">b1 = Book("Pandas", "John Doe", 100000)print(type(b1))<br/>&lt;class '__main__.Book'&gt;</span></pre><p id="f627" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">代码中的b1是一个属于Book类的对象。</p><p id="e45e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们也可以用下面的方法修改类的属性。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="b537" class="lf lg hh lb b fi lh li l lj lk">print(b1.name)<br/>Pandasb1.name = 'NumPy' #updates the name attributeprint(b1.name)<br/>NumPy</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="19cd" class="ll lg hh bd lm ln lo lp lq lr ls lt lu in lv io lw iq lx ir ly it lz iu ma mb bi translated">定义类方法</h1><p id="338c" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">该类只有数据属性。我们应该添加一些方法来使它变得有用和实用。</p><p id="999f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">例如，我们可以实现一个方法，返回给定字体大小的页数。我们通过计算字数来测量这本书的长度。该方法将根据长度和字体大小计算页数。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="b888" class="lf lg hh lb b fi lh li l lj lk">def number_of_pages(self, fontsize=12):<br/>  word_length = self.word_length<br/>  if fontsize == 12:<br/>    words_in_page = 300<br/>  else:<br/>    words_in_page = 300 - (fontsize - 12) * 10<br/>  return round(word_length / words_in_page)</span></pre><p id="8485" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在课堂上增加了页数。它根据字数和字体大小来计算一本书的页数。</p><p id="cdd3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果一个函数是在一个类定义中声明的，那么它需要访问一个实例的数据属性，我们需要告诉这个函数如何访问它们。这就是我们在number_of_pages函数的第一行中所做的。我们可以从类中访问一个方法。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="8020" class="lf lg hh lb b fi lh li l lj lk">b1 = Book("Pandas", "John Doe", 100000)b1.number_of_pages()<br/>Book.number_of_pages(b1)</span></pre><p id="1f03" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们需要为我们的类定义一些方法来使用Python的一些内置函数。考虑打印功能。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="5af4" class="lf lg hh lb b fi lh li l lj lk">print(b1)</span></pre><p id="80c5" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">print函数返回对象的类型和内存位置。但是，我们可以通过在我们的类中实现__str__方法来改变它的行为。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="2024" class="lf lg hh lb b fi lh li l lj lk">def __str__(self):<br/>  return "&lt;" + self.name + ", by " + self.writer + "&gt;"</span></pre><p id="4589" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们在类定义中添加了__str__方法。下面的代码是打印函数如何为我们的类工作的:</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="4822" class="lf lg hh lb b fi lh li l lj lk">print(b1)&lt;Pandas, by John Doe&gt;</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="6ae6" class="ll lg hh bd lm ln lo lp lq lr ls lt lu in lv io lw iq lx ir ly it lz iu ma mb bi translated">类与实例变量</h1><p id="1234" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">类变量是在类内部声明的，但它们应该在函数外部。实例变量是在构造函数内部声明的。</p><p id="017e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">类变量更加通用，可以应用一个类的所有实例。实例变量更加具体，并且为每个实例单独定义。在类和实例变量之间有一个对比差异是非常有用的。</p><p id="c3da" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">考虑我们前面定义的Book类。如果我们将它们定义为类变量，我们就不必为每个创建的实例专门声明。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="628b" class="lf lg hh lb b fi lh li l lj lk">class Book():  <br/>    page_width = 14<br/>    cover_color = "blue"  <br/>def __init__(self, name, writer, word_length):<br/>    self.name = name<br/>    self.writer = writer<br/>    self.word_length = word_length</span></pre><p id="1428" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们将page_width和cover_color实现为类变量，因为它们在类定义中。</p><p id="8715" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们创建这本书的一个实例。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="62c7" class="lf lg hh lb b fi lh li l lj lk">b2 = Book("Machine Learning", "Jane Doe", 120000)</span></pre><p id="91d9" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">创建此实例时，我们没有定义类变量。然而，b2保存了这些变量，我们可以访问它们。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="dd74" class="lf lg hh lb b fi lh li l lj lk">b2.page_width<br/>b2.cover_color<br/>'blue'</span></pre><p id="d21f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">我们可以选择更改特定实例的类变量。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="2be5" class="lf lg hh lb b fi lh li l lj lk">b2.cover_color = 'red'b2.cover_color<br/>'red'</span></pre><p id="5b7d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">特定实例中的更改对类变量没有任何影响。</p><pre class="ix iy iz ja fd la lb lc ld aw le bi"><span id="6063" class="lf lg hh lb b fi lh li l lj lk">Book.cover_color<br/>'blue'</span></pre></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><h1 id="fe6b" class="ll lg hh bd lm ln lo lp lq lr ls lt lu in lv io lw iq lx ir ly it lz iu ma mb bi translated">结论</h1><p id="36ab" class="pw-post-body-paragraph ji jj hh jk b jl mc ii jn jo md il jq jr me jt ju jv mf jx jy jz mg kb kc kd ha bi translated">我们在本文中讨论的内容可以被认为是对Python类的全面介绍。我们已经提到了类对于面向对象编程的重要性，以及类如何展示抽象和继承等关键概念。</p><p id="fd78" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">Python类中包含了更多的内容。一旦你熟悉了基础知识，就可以随意进入更高级的话题了。</p></div><div class="ab cl kt ku go kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ha hb hc hd he"><p id="0851" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><em class="ks">原发表于</em><a class="ae mh" href="https://fittechie.in/the-best-reference-guide-to-master-classes-in-python-in-2021/" rel="noopener ugc nofollow" target="_blank"><em class="ks">https://fitter chie . in</em></a><em class="ks">。</em></p></div></div>    
</body>
</html>