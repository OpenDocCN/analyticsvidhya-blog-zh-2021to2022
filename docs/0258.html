<html>
<head>
<title>NullPointerException</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NullPointerException</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/nullpointerexception-a869bc49b50d?source=collection_archive---------15-----------------------#2021-01-10">https://medium.com/analytics-vidhya/nullpointerexception-a869bc49b50d?source=collection_archive---------15-----------------------#2021-01-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/73ea06e640f8c5b710fb9816e8b16dab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/0*FY2qTRIjuEDFsICN.png"/></div><figcaption class="il im et er es in io bd b be z dx translated"><a class="ae ip" href="http://www.devsanon.com/language-agnostic/checking-for-nulls-not-anymore/" rel="noopener ugc nofollow" target="_blank">http://www . devs anon . com/language-agnostic/checking-for-nulls-not-more/</a></figcaption></figure><p id="39e8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当你试图使用一个不指向内存中任何位置(空)的引用，就好像它在引用一个对象时，就会出现异常。对空引用调用方法或试图访问空引用的字段将触发<code class="du jo jp jq jr b">NullPointerException</code>。这些是最常见的，但是其他的方法在<code class="du jo jp jq jr b"><a class="ae ip" href="http://docs.oracle.com/javase/7/docs/api/java/lang/NullPointerException.html" rel="noopener ugc nofollow" target="_blank">NullPointerException</a></code> javadoc页面上列出。</p><p id="8645" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当你声明一个引用变量(即一个对象)时，你实际上是在创建一个指向一个对象的指针。考虑下面的代码，其中声明了一个原始类型的变量<code class="du jo jp jq jr b">int</code>:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="c62d" class="ka kb hh jr b fi kc kd l ke kf">int x;<br/>x = 10;</span></pre><p id="d48f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在这个例子中，变量<code class="du jo jp jq jr b">x</code>是一个<code class="du jo jp jq jr b">int</code>，Java会将它初始化为<code class="du jo jp jq jr b">0</code>。当你在第二行赋值<code class="du jo jp jq jr b">10</code>时，你的<code class="du jo jp jq jr b">10</code>值被写入<code class="du jo jp jq jr b">x</code>引用的内存位置。</p><p id="b190" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">但是，当你试图声明一个引用<em class="kg">类型</em>时，一些不同的事情发生了。以下面的代码为例:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="2eb2" class="ka kb hh jr b fi kc kd l ke kf">Integer num;<br/>num = new Integer(10);</span></pre><p id="d1fe" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">第一行声明了一个名为<code class="du jo jp jq jr b">num</code>的变量，但是它实际上还不包含一个原始值。相反，它包含一个指针(因为类型是引用类型<code class="du jo jp jq jr b">Integer</code>)。既然你还没有说指向什么，Java就把它设置为<code class="du jo jp jq jr b">null</code>，意思是“<strong class="is hi">我在指向<em class="kg">无</em> </strong>”。</p><p id="49b3" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在第二行中，<code class="du jo jp jq jr b">new</code>关键字用于实例化(或创建)一个类型为<code class="du jo jp jq jr b">Integer</code>的对象，指针变量<code class="du jo jp jq jr b">num</code>被分配给该<code class="du jo jp jq jr b">Integer</code>对象。</p><p id="36b2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">当您声明了一个变量，但在尝试使用该变量的内容之前没有创建一个对象并将它赋给该变量时，就会发生<code class="du jo jp jq jr b">NullPointerException</code>(称为<em class="kg">解引用</em>)。所以你指向的东西实际上并不存在。</p><p id="7fa4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">解引用通常发生在使用<code class="du jo jp jq jr b">.</code>访问方法或字段，或者使用<code class="du jo jp jq jr b">[</code>索引数组的时候。</p><p id="0864" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果你试图在创建对象之前取消引用<code class="du jo jp jq jr b">num</code>，你会得到一个<code class="du jo jp jq jr b">NullPointerException</code>。在最琐碎的情况下，编译器会捕捉到问题并让你知道“【T2”，但有时你可能会编写不直接创建对象的代码。</p><p id="7ce4" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">例如，您可能有如下方法:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="9e0f" class="ka kb hh jr b fi kc kd l ke kf">public void doSomething(SomeObject obj) {<br/>   //do something to obj, assumes obj is not null<br/>   obj.myMethod();<br/>}</span></pre><p id="3858" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在这种情况下，您不是在创建对象<code class="du jo jp jq jr b">obj</code>，而是假设它是在调用<code class="du jo jp jq jr b">doSomething()</code>方法之前创建的。请注意，可以这样调用该方法:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="8330" class="ka kb hh jr b fi kc kd l ke kf">doSomething(null);</span></pre><p id="28c2" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在这种情况下，<code class="du jo jp jq jr b">obj</code>就是<code class="du jo jp jq jr b">null</code>，语句<code class="du jo jp jq jr b">obj.myMethod()</code>会抛出一个<code class="du jo jp jq jr b">NullPointerException</code>。</p><p id="760e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">如果该方法像上面的方法一样打算对传入的对象做些什么，抛出<code class="du jo jp jq jr b">NullPointerException</code>是合适的，因为这是一个程序员错误，程序员将需要该信息用于调试目的。</p><p id="9d4e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">除了作为方法逻辑结果抛出的<code class="du jo jp jq jr b">NullPointerException</code>之外，您还可以检查<code class="du jo jp jq jr b">null</code>值的方法参数，并通过在方法开头附近添加类似下面的内容来显式抛出npe:</p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="a787" class="ka kb hh jr b fi kc kd l ke kf">//Throws an NPE with a custom error message if obj is null<br/>Objects.requireNonNull(obj, "obj must not be null");</span></pre><p id="e205" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">请注意，在您的错误消息中清楚地说明<em class="kg">哪个</em>对象不能是<code class="du jo jp jq jr b">null</code>是有帮助的。验证这一点的好处是1)您可以返回自己更清晰的错误消息，2)对于方法的其余部分，您知道除非<code class="du jo jp jq jr b">obj</code>被重新分配，否则它不为空，可以安全地取消引用。</p><p id="25e9" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">或者，可能有这样的情况，方法的目的不仅仅是对传入的对象进行操作，因此空参数可能是可接受的。在这种情况下，您需要检查一个空参数<strong class="is hi">和不同的行为。您还应该在文档中解释这一点。例如，<code class="du jo jp jq jr b">doSomething()</code>可以写成:</strong></p><pre class="js jt ju jv fd jw jr jx jy aw jz bi"><span id="a871" class="ka kb hh jr b fi kc kd l ke kf">/**<br/>  * @param obj An optional foo for ____. May be null, in which case <br/>  *  the result will be ____.<br/>  */<br/>public void doSomething(SomeObject obj) {<br/>    if(obj == null) {<br/>       //do something<br/>    } else {<br/>       //do something else<br/>    }<br/>}</span></pre><p id="9b11" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">最后，<a class="ae ip" href="https://stackoverflow.com/q/3988788/2775450" rel="noopener ugc nofollow" target="_blank">如何使用堆栈跟踪</a>查明异常&amp;的原因</p><blockquote class="kh ki kj"><p id="e769" class="iq ir kg is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn ha bi translated"><em class="hh">可以使用什么方法/工具来确定原因，从而阻止异常导致程序提前终止？</em></p></blockquote><p id="2b3a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">带有查找窃听器的声纳可以探测到NPE。</p><p id="6589" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在Java 14增加了一个新的语言特性来显示NullPointerException的根本原因。自2006年以来，这种语言特性一直是SAP商业JVM的一部分。下面是2分钟阅读，了解这个惊人的语言功能。</p><p id="42e8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae ip" href="https://jfeatures.com/blog/NullPointerException" rel="noopener ugc nofollow" target="_blank">https://jfeatures.com/blog/NullPointerException</a></p><p id="a84f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在java 14中，以下是示例NullPointerException异常消息:</p><blockquote class="kh ki kj"><p id="d0d0" class="iq ir kg is b it iu iv iw ix iy iz ja kk jc jd je kl jg jh ji km jk jl jm jn ha bi translated"><em class="hh">在线程“main”Java . lang . nullpointerexception中:无法调用“java.util.List.size()”，因为“List”为空</em></p></blockquote><h1 id="a9d7" class="kn kb hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">避免NullPointerException的Java技巧和最佳实践</strong></h1><ol class=""><li id="4f0d" class="lk ll hh is b it lm ix ln jb lo jf lp jj lq jn lr ls lt lu bi translated">对已知字符串而非未知对象调用equals()和equalsIgnoreCase()方法</li><li id="ac21" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">更喜欢valueOf()而不是toString()，两者都返回相同的结果</li><li id="8a02" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用空安全方法和库</li><li id="4bab" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">避免从方法返回null，而是返回空集合或空数组。</li><li id="fbb7" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用注释@NotNull和@Nullable</li><li id="641a" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">避免代码中不必要的自动装箱和取消装箱</li><li id="22e6" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">遵循合同并定义合理的默认值</li><li id="4673" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用空对象模式</li><li id="0c17" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用Java 8 Optional作为方法中返回值，Optional类提供了表示可选值而不是空引用的解决方案。</li><li id="c2b2" class="lk ll hh is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu bi translated">使用final修饰符来强制执行良好的初始化。</li></ol></div></div>    
</body>
</html>