<html>
<head>
<title>Matrix Multiplication — Normal Function to an Optimised Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">矩阵乘法——优化代码的正常功能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matrix-multiplication-normal-function-to-an-optimised-code-3d0fb9ddf6e9?source=collection_archive---------7-----------------------#2021-04-16">https://medium.com/analytics-vidhya/matrix-multiplication-normal-function-to-an-optimised-code-3d0fb9ddf6e9?source=collection_archive---------7-----------------------#2021-04-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="93a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将学习不同的矩阵乘法方法，从一个易读的函数到一个优化的代码。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/c246ed12842953c30f1af056e342a84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HXb46WD45xLFSWAF"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">由<a class="ae js" href="https://unsplash.com/@archduk3?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Carl Nenzen Loven </a>在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="beb5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="4d4b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如果你读过我以前关于矩阵运算的文章，现在你应该已经知道什么是矩阵了。是的，矩阵是一个有<code class="du kw kx ky kz b">M</code>行和<code class="du kw kx ky kz b">N</code>列的数组的<code class="du kw kx ky kz b">2D</code>表示。矩阵的形状通常被称为维度。因此，任何典型矩阵的形状被表示或假设为具有(<code class="du kw kx ky kz b">M</code> x <code class="du kw kx ky kz b">N</code>)维。</p><ul class=""><li id="5166" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated">行矩阵——存储在<code class="du kw kx ky kz b">1</code>行和<code class="du kw kx ky kz b">N</code>列中的相同元素或对象的集合。</li><li id="684d" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">列矩阵——存储在<code class="du kw kx ky kz b">N</code>行和<code class="du kw kx ky kz b">1</code>列中的相同元素或对象的集合。</li></ul><p id="245b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注</strong> —形状(<code class="du kw kx ky kz b">1</code> x <code class="du kw kx ky kz b">N</code>)和(<code class="du kw kx ky kz b">N</code> x <code class="du kw kx ky kz b">1</code>)的矩阵一般分别称为行向量和列向量。</p><h1 id="4e7c" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">算法解释</h1><p id="bdff" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">例如，假设我们有两个矩阵<code class="du kw kx ky kz b">A</code>和<code class="du kw kx ky kz b">B</code>。乘法运算前的一般规则是<code class="du kw kx ky kz b">A</code>的<strong class="ig hi">列</strong>的数量应该正好等于<code class="du kw kx ky kz b">B</code>的<strong class="ig hi">行</strong>的数量。如果满足此规则，则-</p><p id="767a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将计算<code class="du kw kx ky kz b">A</code>的每行相对于<code class="du kw kx ky kz b">B</code>的每列的点积。这个过程一直持续到没有元素需要计算为止。</p><ul class=""><li id="396b" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kw kx ky kz b">A</code>的每一行都被认为是一个行向量。</li><li id="4fef" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kw kx ky kz b">B</code>的每一列都被认为是一个列向量。</li><li id="baa9" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">点积—这是一种代数运算，对两个大小相等的向量进行计算，得到一个数字。它也被称为标量积。数学上，我们用以下形式表示它-</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lo"><img src="../Images/d4fe7bee2989bea6e1c87d5c9e567344.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*vXk55ZFyqCz-Xcdqf6u3OA.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者图片</figcaption></figure><p id="404e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果矩阵的(运算后)大小将等于<code class="du kw kx ky kz b">A</code>的<strong class="ig hi">行</strong>的数量和<code class="du kw kx ky kz b">B</code>的<strong class="ig hi">列</strong>的数量。</p><p id="eaaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong> —当我们处理大型矩阵时，计算可能会有风险或很慢。这个可以用<code class="du kw kx ky kz b">NumPy</code>轻松搞定。</p><h1 id="00db" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">GIF解释</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/46c24b6013114289e0faf780a88a54ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/1*rW1VuiWhK7i-J4gEH2VQmg.gif"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者GIF</figcaption></figure><h1 id="2e03" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">易于阅读的功能</h1><p id="561e" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如果我们试图分解整个算法，我们必须做的第一件事就是转置一个矩阵，并计算矩阵的每一行与另一个矩阵的每一列的点积或标量积。</p><p id="2506" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">矩阵转置</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="9edc" class="lu ju hh kz b fi lv lw l lx ly">def transpose(m):<br/>    trans_mat = [[row[i] for row in m] for i in range(len(m[0]))]<br/>    return trans_mat</span></pre><p id="642d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">点积</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="f6dd" class="lu ju hh kz b fi lv lw l lx ly">def scalar_product(r, c):<br/>    ps = [i * j for (i, j) in zip(r, c)]<br/>    return sum(ps)</span></pre><p id="0714" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">矩阵乘法</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="9e35" class="lu ju hh kz b fi lv lw l lx ly">def mats_product(m1, m2):<br/>    m2_t = transpose(m=m2)<br/>    mats_p = [[scalar_product(r=r, c=c) for c in m2_t] for r in m1]<br/>    return mats_p</span></pre><p id="0cb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将所有的功能打包在一起，我们可以做以下事情-</p><p id="f166" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">总结</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="5fe6" class="lu ju hh kz b fi lv lw l lx ly">def easy_product(m1, m2):    <br/>    def transpose(m):<br/>        trans_mat = [<br/>            [row[i] for row in m]<br/>            for i in range(len(m[0]))<br/>        ]<br/>        return trans_mat</span><span id="8d01" class="lu ju hh kz b fi lz lw l lx ly">    def scalar_product(r, c):<br/>        ps = [i * j for (i, j) in zip(r, c)]<br/>        return sum(ps)</span><span id="2bbe" class="lu ju hh kz b fi lz lw l lx ly">    def mats_product(m1, m2):<br/>        m2_t = transpose(m=m2)<br/>        mats_p = [<br/>            [scalar_product(r=r, c=c) for c in m2_t]<br/>            for r in m1<br/>        ]<br/>        return mats_p</span><span id="ab2d" class="lu ju hh kz b fi lz lw l lx ly">    return mats_product(m1, m2)</span></pre><h1 id="7aaa" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">更简化的代码—(优化的)</h1><p id="9d3b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">上面的<code class="du kw kx ky kz b">easy_product()</code>还是可以利用Python的内置方法进行优化。方法上需要更好的改进<code class="du kw kx ky kz b">transpose()</code>。</p><p id="e18f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">矩阵转置</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="308e" class="lu ju hh kz b fi lv lw l lx ly">transpose = lambda m : list(map(list, zip(*m)))</span></pre><p id="c765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">点积</strong></p><p id="f2f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的<code class="du kw kx ky kz b">scalar_product()</code>还是可以减少，维持像-</p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="2d8b" class="lu ju hh kz b fi lv lw l lx ly">scalar_product = lambda r, c: sum([i * j for (i, j) in zip(r, c)])</span></pre><p id="b7aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">矩阵乘法</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="e72a" class="lu ju hh kz b fi lv lw l lx ly">def mats_product(m1, m2):<br/>    m2_t = transpose(m=m2)<br/>    mats_p = [[scalar_product(r=r, c=c) for c in m2_t] for r in m1]<br/>    return mats_p</span></pre><p id="ea56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了将所有的功能打包在一起，我们可以做以下事情-</p><p id="0f4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">总结</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="a2ea" class="lu ju hh kz b fi lv lw l lx ly">def optimized_product(m1, m2):<br/>    transpose = lambda m : list(map(list, zip(*m)))<br/>    scalar_product = lambda r, c: sum([i * j for (i, j) in zip(r, c)])</span><span id="c5a7" class="lu ju hh kz b fi lz lw l lx ly">    def mats_product(m1, m2):<br/>        m2_t = transpose(m=m2)<br/>        mats_p = [<br/>            [scalar_product(r=r, c=c) for c in m2_t]<br/>            for r in m1<br/>        ]<br/>        return mats_p</span><span id="e1fb" class="lu ju hh kz b fi lz lw l lx ly">    return mats_product(m1, m2)</span></pre><p id="da39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">厉害！这两个函数都准备好进行测试了。为了进行测试，我们需要定义矩阵。我们将创建随机矩阵(函数)，它可以进一步帮助检查两个函数的速度兼容性。</p><p id="24b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">随机矩阵创建</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="07ce" class="lu ju hh kz b fi lv lw l lx ly">import random</span><span id="8c2a" class="lu ju hh kz b fi lz lw l lx ly">def create_matrix(rcount, ccount):<br/>    random.seed(10)<br/>    m = [<br/>            [random.randint(10, 80) for i in range(ccount)] <br/>            for j in range(rcount)<br/>    ]<br/>    return m</span></pre><h1 id="3824" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">测试阶段</h1><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="9384" class="lu ju hh kz b fi lv lw l lx ly">&gt;&gt;&gt; nr = 2<br/>&gt;&gt;&gt; nc = 3<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; m1 = create_matrix(nr, nc)<br/>&gt;&gt;&gt; m2 = create_matrix(nc, nr)<br/>&gt;&gt;&gt; m1<br/>[[14, 64, 71], [11, 36, 69]]<br/>&gt;&gt;&gt; m2<br/>[[14, 64], [71, 11], [36, 69]]</span></pre><p id="5919" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">正常功能</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="bbbb" class="lu ju hh kz b fi lv lw l lx ly">&gt;&gt;&gt; mm = easy_product(m1, m2)<br/>&gt;&gt;&gt; print(mm)<br/>[[7296, 6499], [5194, 5861]]</span></pre><p id="e672" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">改进代码</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="e15d" class="lu ju hh kz b fi lv lw l lx ly">&gt;&gt;&gt; mm = optimized_product(m1, m2)<br/>&gt;&gt;&gt; print(mm)<br/>[[7296, 6499], [5194, 5861]]</span></pre><h1 id="aa96" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">速度和计算—比较</h1><p id="4cc6" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">现在，这两个功能似乎都足够好。但是检查算法在快速计算和时间方面的性能也很重要。</p><p id="91fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们将针对一组定义的矩阵形状循环运行这两个函数，并存储每个函数所需的时间。我们也将绘制相同的图形来直观地表示它。</p><p id="14ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">性能检查</strong></p><pre class="jd je jf jg fd lq kz lr ls aw lt bi"><span id="ce55" class="lu ju hh kz b fi lv lw l lx ly">import time<br/>from matplotlib import pyplot as plt</span><span id="aece" class="lu ju hh kz b fi lz lw l lx ly">def check_speed():<br/>    shapes = [<br/>        (3, 2), (5, 4),<br/>        (10, 9), (20, 5),<br/>        (30, 8), (40, 2),<br/>        (50, 10), (2, 10),<br/>        (5, 80), (100, 34),<br/>        (200, 100), (300, 200)<br/>    ]</span><span id="9cad" class="lu ju hh kz b fi lz lw l lx ly">    x = [str(i) for i in shapes]<br/>    y1 = []; y2 = [];</span><span id="900b" class="lu ju hh kz b fi lz lw l lx ly">    for sp in shapes:<br/>        m1 = create_matrix(sp[0], sp[1])<br/>        m2 = create_matrix(sp[1], sp[0])</span><span id="6ce1" class="lu ju hh kz b fi lz lw l lx ly">        start_e = time.time()<br/>        res_easy = easy_product(m1, m2)<br/>        end_e = time.time()<br/>        easy_elapse = end_e - start_e</span><span id="5e08" class="lu ju hh kz b fi lz lw l lx ly">        start_o = time.time()<br/>        res_opt = optimized_product(m1, m2)<br/>        end_o = time.time()<br/>        opt_elapse = end_o - start_o</span><span id="0124" class="lu ju hh kz b fi lz lw l lx ly">        y1.append(easy_elapse)<br/>        y2.append(opt_elapse)</span><span id="1ec6" class="lu ju hh kz b fi lz lw l lx ly">    plt.figure(figsize=(15, 6))<br/>    plt.plot(x, y1, 'o-', label='Normal Function')<br/>    plt.plot(x, y2, 'o-', label='Optimized Code')<br/>    plt.legend()<br/>    plt.show()</span><span id="0097" class="lu ju hh kz b fi lz lw l lx ly">    return None</span></pre><p id="8c28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">性能图表</strong></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/9735a95ae2b321e0e9897be67efc75f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdT-ACGlW9Vp9m2mu2tZow.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者图片</figcaption></figure><p id="9151" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了少数情况，这两种算法的工作原理似乎相似。但是有一个问题，我们是从个人角度来写这些函数的。如果我们引进<code class="du kw kx ky kz b">NumPy</code>来做同样的事情，性能会更好。下图也包括了<code class="du kw kx ky kz b">NumPy</code>的性能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es ma"><img src="../Images/5139b4503153e88ef8b4912c59277cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vz1doDLwRmipBWJ257PP7Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者图片</figcaption></figure><p id="5073" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是啊！NumPy快多了。无论大小如何，NumPy在计算相同的操作时消耗的时间非常少。</p><h1 id="776b" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">我学到的东西</h1><ul class=""><li id="14c6" class="la lb hh ig b ih kr il ks ip mb it mc ix md jb lf lg lh li bi translated">分解一个给定的问题，解决每个问题，最终解决原来的问题。</li><li id="acd1" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">比较算法和跟踪计算。</li></ul></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><p id="ce6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢我的文章，你可以在这里买些咖啡支持我。这将激励我去写作和学习更多我所知道的东西。即使你不这样做也完全没关系。</p></div></div>    
</body>
</html>