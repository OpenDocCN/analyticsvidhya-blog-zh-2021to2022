<html>
<head>
<title>Write Kubernetes manifests for python flask app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为python flask应用程序编写Kubernetes清单</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/write-kubernetes-manifests-for-python-flask-app-aa9e3bee710b?source=collection_archive---------1-----------------------#2021-04-27">https://medium.com/analytics-vidhya/write-kubernetes-manifests-for-python-flask-app-aa9e3bee710b?source=collection_archive---------1-----------------------#2021-04-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="9ca9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这篇文章是系列<a class="ae jd" href="https://augustasberneckas.medium.com/prepare-and-deploy-python-app-to-kubernetes-736b13fe4cef" rel="noopener"> <strong class="ih hj">准备和部署python应用到Kubernetes </strong> </a>的一部分</p><p id="8263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://augustasberneckas.medium.com/containerizing-python-flask-application-19faa9db031c" rel="noopener">👈前一篇文章:容器化python flask应用程序</a></p><p id="887c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://augustasberneckas.medium.com/getting-to-know-minikube-e93f9676dea7" rel="noopener">👈前贴:了解Minikube </a></p><p id="656d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这个系列的最后，我们将在Kubernetes中拥有一个完全可用的flask应用程序。我们正在使用的应用程序本身，可以在这里找到:<a class="ae jd" href="https://github.com/brnck/k8s-python-demo-app/tree/docker" rel="noopener ugc nofollow" target="_blank">https://github.com/brnck/k8s-python-demo-app/tree/docker</a></p></div><div class="ab cl je jf gp jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="hb hc hd he hf"><h1 id="ddf4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">先决条件</h1><p id="706a" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">我们将使用<code class="du ko kp kq kr b">minikube</code>将我们的应用程序部署到Kubernetes。如果你对它不熟悉，请到<a class="ae jd" href="https://augustasberneckas.medium.com/getting-to-know-minikube-e93f9676dea7" rel="noopener">这篇文章</a>了解更多，因为我们将在这里讨论如何使用Minikube等话题。</p><h1 id="1df2" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">定义用例</h1><p id="5f11" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">在我们开始编写Kubernetes清单之前，我们需要为自己清楚地定义我们的应用程序用例。确定我们需要向Kubernetes部署什么资源会更容易。</p><p id="78dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们有一个应用程序:</p><ul class=""><li id="2a6b" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">处理我们的应用程序用户的HTTP请求并返回一些内容；</li><li id="f5c6" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">有一个CLI命令，它也能做一些事情。这可能是一次性的工作或cronjob。假设我们需要一份一次性工作。</li></ul><p id="9744" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这意味着我们需要:</p><ul class=""><li id="47cd" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">从群集外部访问应用程序；</li><li id="1040" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">能够独立扩展应用程序；</li><li id="f839" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">能够运行一次性的工作。</li></ul><p id="27a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些用例清楚地表明了我们的应用程序将使用什么样的<a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/" rel="noopener ugc nofollow" target="_blank">工作负载</a>。现在，我不打算深入解释工作负载，因为我假设您已经或多或少地了解了它们之间的区别。除了工作负载，我们还必须围绕它们添加额外的资源，以便金融机构客户能够访问我们的应用。</p><p id="d65f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">总而言之，这些是我们将要部署到我们的Kubernetes集群的Kubernetes资源:</p><ul class=""><li id="eed9" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/" rel="noopener ugc nofollow" target="_blank">名称空间</a></li><li id="7743" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" rel="noopener ugc nofollow" target="_blank">部署</a></li><li id="b70c" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">工作</a></li><li id="8c99" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/service/" rel="noopener ugc nofollow" target="_blank">服务</a></li><li id="f682" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/ingress/" rel="noopener ugc nofollow" target="_blank">入口</a></li></ul><h1 id="742d" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">准备目录和文件</h1><p id="7d18" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">为清单创建一个目录，并添加空(目前)文件:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="1fe6" class="lt jm hi kr b fi lu lv l lw lx">mkdir k8s-manifests<br/>touch k8s-manifests/namespace.yaml<br/>touch k8s-manifests/deployment.yaml<br/>touch k8s-manifests/job.yaml<br/>touch k8s-manifests/service.yaml<br/>touch k8s-manifests/ingress.yaml</span></pre><p id="c00a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，将<code class="du ko kp kq kr b">k8s-manifests</code>文件夹添加到<code class="du ko kp kq kr b">.dockerignore</code>文件中，因为将清单添加到映像中没有意义。如果您使用Kubernetes已经有一段时间了，您可能会注意到一些公共供应商只使用一个文件来保存所有的清单。虽然这没有什么错，但它产生的结果与将所有内容放在单独的文件中并一个接一个地部署是一样的。事实上，将所有清单放在一个文件中有助于资源部署的排序，因为必须首先部署名称空间。然而，为了清晰和可读性，我们将按资源分割文件。</p><h1 id="81aa" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">正在创建命名空间清单</h1><p id="5069" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">创建名称空间通常基于上下文。最常见的大概就是团队或者项目。您可以为整个开发团队创建一个名称空间，它将用于部署所有类型的应用程序。他们甚至可能根本没有关系。另一种方法是只为项目创建一个名称空间。这也是我们将对我们的应用程序做的事情。为一个项目而不是一个团队创建一个名称空间可以防止类似“如果这个团队与其他团队合作管理应用程序会怎么样？”甚至不会出现，因为从管理员的角度来看，我们可以更容易地控制访问，并将它们只授予开发人员或团队需要访问的应用程序。</p><p id="748c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的应用叫做<strong class="ih hj"> k8s-python-demo-app </strong>。我们可以去掉前缀<code class="du ko kp kq kr b">k8s-</code>，将我们的名称空间命名为<code class="du ko kp kq kr b">python-demo-app</code>。</p><p id="982e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们最终的<code class="du ko kp kq kr b">namespace.yaml</code>文件应该是这样的:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="3a85" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: python-demo-app</span></pre><h1 id="dee2" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">正在创建部署清单</h1><p id="38be" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">为了更好地理解应用程序的web部分需要什么，让我们更深入地研究并定义用例，就像我们对整个应用程序所做的那样。这将有助于更好地理解如何编写部署清单。</p><p id="5454" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从一开始，必须在名称空间<code class="du ko kp kq kr b">python-demo-app</code>中创建一个名为<code class="du ko kp kq kr b">python-demo-app-web</code>的部署。它应该使用<code class="du ko kp kq kr b">python-demo-app</code>作为图像，使用<code class="du ko kp kq kr b">init</code>作为图像标签。此外，容器必须作为没有权限提升的<code class="du ko kp kq kr b">app</code> (id 1000)用户启动。容器应该请求128Mi内存和100个CPU周期。此外，资源应该限制在256Mi和200个CPU周期。应该有2个副本部署到Kubernetes。最后，必须进行健康检查。<a class="ae jd" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes" rel="noopener ugc nofollow" target="_blank">准备就绪探针</a>应不断检查<code class="du ko kp kq kr b">8000</code>端口和<code class="du ko kp kq kr b">/</code>端点。<a class="ae jd" href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command" rel="noopener ugc nofollow" target="_blank">活性探测器</a>应寻找Gunicorn主进程并确保其正常运行。</p><p id="25f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用例已定义。现在开始将它转换成部署资源清单。</p><p id="d689" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，从添加元数据开始:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="aa8d" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app</span></pre><p id="3d3d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">继续进行<code class="du ko kp kq kr b">.spec</code>部分。将<code class="du ko kp kq kr b">replicas: 2</code>添加到<code class="du ko kp kq kr b">.spec</code>:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="0539" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  replicas: 2</span></pre><p id="2ee8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还需要加上<code class="du ko kp kq kr b">.spec.selector</code>。根据文档，<code class="du ko kp kq kr b">.spec.selector</code>字段定义了部署如何找到要管理的pod。在这种情况下，您选择在Pod模板中定义的标签(<code class="du ko kp kq kr b">app: python-demo-app</code>和<code class="du ko kp kq kr b">role: web</code>)。然而，更复杂的选择规则是可能的，只要Pod模板本身满足该规则。</p><p id="9221" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来定义这两者:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="8391" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: python-demo-app<br/>      role: web<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: web</span></pre><p id="e07d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">进一步移动到<code class="du ko kp kq kr b">.spec.template.spec</code>。在定义容器之前，让我们先处理安全性。我们可以通过添加值为<code class="du ko kp kq kr b">runAsGroup: 1000</code>和<code class="du ko kp kq kr b">runAsUser: 1000</code>的<code class="du ko kp kq kr b">securitycontext</code>键来做到这一点(因为我们的图像用户是app (id 1000))。为一个pod定义<code class="du ko kp kq kr b">securitycontext</code>将使Kubernetes为该pod中的所有容器应用该上下文。继续添加容器名称、图像、标签和容器端口。还记得docker的前一课吗？我们已经讨论过默认监听端口<code class="du ko kp kq kr b">gunicorn</code>，即<code class="du ko kp kq kr b">8000</code>。它应该被定义并命名为<code class="du ko kp kq kr b">gunicorn</code>。虽然命名端口是可选的，但它稍后会对我们有所帮助。</p><p id="e01c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">经过上述更改后，部署文件现在应该如下所示:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="9f14" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: python-demo-app<br/>      role: web<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: web<br/>    spec:<br/>      securityContext:<br/>        runAsGroup: 1000<br/>        runAsUser: 1000 <br/>      containers:<br/>        - name: python-demo-app-web<br/>          image: python-demo-app:init<br/>          ports:<br/>            - name: gunicorn <br/>              containerPort: 8000</span></pre><p id="57d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要为容器分配和限制的资源。默认情况下，工作负荷可以没有已定义的资源。这意味着您的应用程序有可能接管整个集群。想象一下，一个应用程序出现了内存泄漏。这将在临时集群中造成问题，并可能在生产集群中造成灾难。这就是为什么为所有容器分配和限制资源通常是一个非常好的做法。然而，这是一个非常深入的话题，需要很好地了解您的应用程序，以及它在启动和空闲时如何在大负载下工作。设置低限制将导致不必要的应用程序重新启动。另一方面，不要设置太高的限制，因为这是一种资源浪费，会降低集群的效率。考虑到这只是一个指南，而且我们正在学习，我们不要在这里集中精力，只定义一些逻辑资源<code class="du ko kp kq kr b">requests</code>和<code class="du ko kp kq kr b">limits</code>。正如我上面提到的:</p><blockquote class="ly lz ma"><p id="94c6" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">容器应该请求128Mi内存和100个CPU周期。此外，资源应限制在256Mi和200个CPU周期内</em></p></blockquote><p id="36ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后再补充一下<code class="du ko kp kq kr b">liveness</code>和<code class="du ko kp kq kr b">readiness</code>健康检查。使用<code class="du ko kp kq kr b">readiness</code>我们将检查我们的web服务器是否响应状态为<code class="du ko kp kq kr b">200</code>的HTTP请求，使用<code class="du ko kp kq kr b">liveness</code>我们将检查<code class="du ko kp kq kr b">gunicorn</code>进程的PID以确保它正在运行。此外，让我们给它一些初始延迟，以便<code class="du ko kp kq kr b">gunicorn</code>工人可以启动。</p><p id="775a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最终的部署清单应该如下所示:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="547b" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  replicas: 2<br/>  selector:<br/>    matchLabels:<br/>      app: python-demo-app<br/>      role: web<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: web<br/>    spec:<br/>      securityContext:<br/>        runAsGroup: 1000<br/>        runAsUser: 1000<br/>      containers:<br/>        - name: python-demo-app-web<br/>          image: python-demo-app:init<br/>          ports:<br/>            - name: gunicorn<br/>              containerPort: 8000<br/>          resources:<br/>            requests:<br/>              memory: 128Mi<br/>              cpu: 100m<br/>            limits:<br/>              memory: 256Mi<br/>              cpu: 200m<br/>          readinessProbe:<br/>            initialDelaySeconds: 10<br/>            httpGet:<br/>              port: gunicorn<br/>              path: /<br/>          livenessProbe:<br/>            initialDelaySeconds: 10<br/>            exec:<br/>              command:<br/>                - /bin/sh<br/>                - -c <br/>                - "pidof -x gunicorn"</span></pre><h1 id="1ca5" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">正在创建服务清单</h1><p id="00d1" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">一种将运行在一组pod上的应用程序公开为网络服务的抽象方式。Kubernetes为一组pod提供它们自己的IP地址和一个DNS名称，并可以在它们之间进行负载平衡。</p><p id="735f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通常，首先创建元数据:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="22b1" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app</span></pre><p id="db52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">转到<code class="du ko kp kq kr b">.spec</code>，需要定义<code class="du ko kp kq kr b">selector</code>。它的工作原理和《T2》中的差不多。服务需要知道哪些pod有资格将流量路由到。甚至可以添加相同的<code class="du ko kp kq kr b">labels</code>:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="6ad2" class="lt jm hi kr b fi lu lv l lw lx">spec:<br/>  selector:<br/>    app: python-demo-app<br/>    role: web</span></pre><p id="2fab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，服务不仅需要知道流量路由到哪个pod，还需要知道流量路由到公开端口中的哪个端口。虽然它可以将任何端口映射到目标pod端口，但为了方便起见，targetPort被设置为与端口字段相同的值。让我们将80端口用于服务，将其命名为<code class="du ko kp kq kr b">http</code>，并将流量路由到pod中的<code class="du ko kp kq kr b">gunicorn</code>(是的，我们可以使用名称而不是端口号)端口。如果您做的一切都正确，您的最终服务清单应该如下所示:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="a70a" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  selector:<br/>    app: python-demo-app<br/>    role: web<br/>  ports:<br/>    - name: http<br/>      port: 80<br/>      targetPort: gunicorn</span></pre><p id="4c25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们现在部署应用程序，那么在集群中运行的任何其他应用程序都可以通过使用<code class="du ko kp kq kr b">service-name.namespace-name</code>语法访问这个应用程序。您可以在此阅读更多关于内部集群DNS解析<a class="ae jd" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/#namespaces-of-services" rel="noopener ugc nofollow" target="_blank">的信息。然而，我们的目标是让我们的客户消费应用程序。这就是<code class="du ko kp kq kr b">ingress</code>发挥作用的地方</a></p><h1 id="a445" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">正在创建入口清单</h1><p id="7eef" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">入口基本上是HTTP和HTTPS路由器从集群外部提供的服务。路由是基于规则的，因此您可以使用一个域并基于规则路由到完全不同的pod。这只有一个路由<code class="du ko kp kq kr b">/</code>，所以我们不打算深入研究通过一个入口路由到多个服务。相反，当对Kubernetes的HTTP请求带有一个主机<code class="du ko kp kq kr b">python-app.demo.com</code>和<code class="du ko kp kq kr b">/</code>端点时，我们将配置ingress将流量路由到<code class="du ko kp kq kr b">python-demo-app-web</code>服务</p><p id="a079" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我想在这里放一个大大的<strong class="ih hj">免责声明</strong>。<strong class="ih hj"> Nginx </strong>入口控制器中有一个<a class="ae jd" href="https://github.com/kubernetes/ingress-nginx/pull/6187" rel="noopener ugc nofollow" target="_blank"> bug </a>。将在minikube集群中使用的那个。这就是为什么旧的<strong class="ih hj"> apiVersion </strong>会被使用(当应用ingress时你会得到一个警告)。你可以把它当作一个挑战，用修复了这个错误的镜像版本部署入口控制器。</p><p id="29e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你已经知道程序了。元数据:)</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="15f2" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app</span></pre><p id="544f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在<code class="du ko kp kq kr b">.spec</code>部分，我们将定义入口类名，我已经在声明中提到过了。另外，<code class="du ko kp kq kr b">rules</code>数组必须被定义。我们可以从添加主持人<code class="du ko kp kq kr b">python-app.demo.com</code>的规则开始</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="4441" class="lt jm hi kr b fi lu lv l lw lx">spec:<br/>  rules:<br/>    - host: python-app.demo.com</span></pre><p id="194f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">主持完毕。现在我们需要添加一个端点并将服务附加到该规则。在<code class="du ko kp kq kr b">host</code>同胞- <code class="du ko kp kq kr b">http</code>下，一切都是可定义的。最终结果应该是这样的:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="f441" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: networking.k8s.io/v1beta1<br/>kind: Ingress<br/>metadata:<br/>  name: python-demo-app-web<br/>  namespace: python-demo-app<br/>spec:<br/>  rules:<br/>    - host: python-app.demo.com<br/>      http:<br/>        paths:<br/>          - path: /<br/>            pathType: Prefix<br/>            backend:<br/>              serviceName: python-demo-app-web<br/>              servicePort: http</span></pre><p id="9f03" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因为键名很容易解释，所以您可能已经知道这个清单可以翻译为:</p><blockquote class="ly lz ma"><p id="09e7" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">通过入口控制器、主机python-app.demo.com和以/开头的端点发出的所有http请求必须转发到名为python-demo-app的服务及其端口http，该端口http(如果我们再次查看服务清单)应将流量转发到其中一个应用:python-demo-app，role: web标签的pods及其gunicorn端口8000 </em></p></blockquote><p id="cde9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络流量处理的一切都准备好了。让我们为运行一次性作业创建最后一个清单</p><h1 id="1e81" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">正在创建作业清单</h1><p id="3d32" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated"><a class="ae jd" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/" rel="noopener ugc nofollow" target="_blank">作业</a>基本上是一个或多个pod，它们被安排运行直到成功完成或被删除。人工智能作业可用于运行数据库模式更新，执行某种维护任务。我们在这个应用程序中的工作非常简单——打印出<code class="du ko kp kq kr b">Hello, world from CLI!</code>。</p><p id="5f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与所有其他清单一样，如上所述，作业需要apiVersion、kind和metadata字段。</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="7a49" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: hello-world-job<br/>  namespace: python-demo-app</span></pre><p id="3629" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ko kp kq kr b">.spec.template</code>是<code class="du ko kp kq kr b">.spec</code>的唯一必填字段。更何况<code class="du ko kp kq kr b">.spec.template</code>是一个pod模板。它与pod具有完全相同的模式，除了它是嵌套的并且没有<code class="du ko kp kq kr b">apiVersion</code>或<code class="du ko kp kq kr b">kind</code>。事实上，当我们完成创建这个文件时，您会注意到<code class="du ko kp kq kr b">deployment</code>和<code class="du ko kp kq kr b">job</code>有许多相似之处。</p><p id="8fa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如<code class="du ko kp kq kr b">deployment</code>所示，我们将<code class="du ko kp kq kr b">labels</code>添加到<code class="du ko kp kq kr b">template</code>中:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="bc56" class="lt jm hi kr b fi lu lv l lw lx">spec:<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: hello-world-job</span></pre><p id="a976" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加<code class="du ko kp kq kr b">.spec.template.spec.securityContext</code>继续。我们希望这个容器也能作为用户<strong class="ih hj">应用</strong>运行。你想过如果工作失败会发生什么吗？Kubernetes会重启作业吗？或者它只是将其标记为失败而什么也不做？根据文件记载:</p><blockquote class="ly lz ma"><p id="2ff5" class="if ig mb ih b ii ij ik il im in io ip mc ir is it md iv iw ix me iz ja jb jc hb bi translated"><em class="hi">作业仅适用于重启策略等于OnFailure或Never的pod。(注意:如果没有设置RestartPolicy，默认值总是</em></p></blockquote><p id="f02d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者换句话说，Kubernetes默认将<code class="du ko kp kq kr b">restartPolicy</code>设为<code class="du ko kp kq kr b">Always</code>。如果在没有设置适当的<code class="du ko kp kq kr b">restartPolicy</code>的情况下部署作业，部署本身就会失败。为了解决这个问题，我们还可以添加<code class="du ko kp kq kr b">restartPolicy: OnFailure</code></p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="49c1" class="lt jm hi kr b fi lu lv l lw lx">spec:<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: hello-world-job<br/>    spec:<br/>      securityContext:<br/>        runAsGroup: 1000<br/>        runAsUser: 1000<br/>      restartPolicy: OnFailure</span></pre><p id="83aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于容器部分，会有一些不同。首先，我们不需要公开任何容器端口，因为这是一个CLI命令。接下来，我们不会做任何<code class="du ko kp kq kr b">readiness</code>检查，因为该容器不接受任何流量。此外，为了这个指南，我们不要做<code class="du ko kp kq kr b">liveness</code>检查，因为这个命令会运行得很快，所以在这种情况下没有用。</p><p id="8ac4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用更改<code class="du ko kp kq kr b">containers</code>后，零件应如下所示:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="bc07" class="lt jm hi kr b fi lu lv l lw lx">      containers:<br/>        - name: python-demo-app-hello-world-job<br/>          image: python-demo-app:init<br/>          command:<br/>            - python3<br/>          args:<br/>            - cli.py<br/>          resources:<br/>            requests:<br/>              memory: 128Mi<br/>              cpu: 100m<br/>            limits:<br/>              memory: 256Mi<br/>              cpu: 200m</span></pre><p id="be88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可能已经注意到有两个新的键(<code class="du ko kp kq kr b">command</code>和<code class="du ko kp kq kr b">args</code>，它们在<code class="du ko kp kq kr b">deployment</code>中没有出现)。让我解释一下我们在这里做什么。如果您从一开始就遵循本指南，您可能会记得我们使用了相同的映像来运行我们的web服务器和CLI命令。唯一的不同是我们改变了容器<code class="du ko kp kq kr b">entrypoint</code>和<code class="du ko kp kq kr b">cmd</code>。这也是我们在这里所做的。关于<code class="du ko kp kq kr b">command</code>和<code class="du ko kp kq kr b">args</code>的更多解释可以在<a class="ae jd" href="https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。像这样的方法并不总是好的。大多数情况下，专门为CLI创建单独的映像会更好，但我们不要讨论细节，因为这超出了本指南的范围。</p><p id="953b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的最终工作应该是这样的:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="eb56" class="lt jm hi kr b fi lu lv l lw lx">apiVersion: batch/v1<br/>kind: Job<br/>metadata:<br/>  name: hello-world-job<br/>  namespace: python-demo-app<br/>spec:<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: python-demo-app<br/>        role: hello-world-job<br/>    spec:<br/>      securityContext:<br/>        runAsGroup: 1000<br/>        runAsUser: 1000<br/>      restartPolicy: OnFailure<br/>      containers:<br/>        - name: python-demo-app-hello-world-job<br/>          image: python-demo-app:init<br/>          command:<br/>            - python3<br/>          args:<br/>            - cli.py<br/>          resources:<br/>            requests:<br/>              memory: 128Mi<br/>              cpu: 100m<br/>            limits:<br/>              memory: 256Mi<br/>              cpu: 200m</span></pre><h1 id="803e" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">部署到Kubernetes</h1><p id="57c5" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">是时候将应用程序部署到Kubernetes了。</p><p id="f32a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，创建一个<code class="du ko kp kq kr b">minikube</code>集群。我将为我的Kubernetes集群提供<code class="du ko kp kq kr b">virtualbox</code>驱动程序和<code class="du ko kp kq kr b">kubernetes-version</code>版本1.20.5 。强烈建议使用与我相同的命令，否则，某些部分可能不会产生我们期望的结果。只有当你知道你在做什么的时候，才进行不同的配置。</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="01ad" class="lt jm hi kr b fi lu lv l lw lx">minikube start --driver=virtualbox --kubernetes-version=1.20.5</span></pre><p id="24b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">启用入口插件:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="4f55" class="lt jm hi kr b fi lu lv l lw lx">minikube addons enable ingress</span></pre><p id="b2ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确认群集已启动并正在运行:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="c7a9" class="lt jm hi kr b fi lu lv l lw lx">kubectl get nodes                                        <br/>NAME       STATUS   ROLES                  AGE   VERSION<br/>minikube   Ready    control-plane,master   81s   v1.20.5</span></pre><p id="482d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本指南不介绍如何构建一个映像并将其推送到私有或公共注册中心。相反，为了简单起见，我们将直接在minikube虚拟机上构建一个映像。确保您位于终端的应用程序目录中:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="147c" class="lt jm hi kr b fi lu lv l lw lx">eval $(minikube docker-env)<br/>docker build -t python-demo-app:init .<br/>&lt;...&gt;<br/>Successfully built 22008520508b<br/>Successfully tagged python-demo-app:init</span></pre><p id="af49" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">确认:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="9353" class="lt jm hi kr b fi lu lv l lw lx">minikube ssh docker images | grep python-demo-app<br/>python-demo-app                           init         22008520508b   About a minute ago   125MB</span></pre><p id="7f50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一切准备就绪。继续创建一个名称空间并确认它:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="2e6a" class="lt jm hi kr b fi lu lv l lw lx">kubectl apply -f k8s-manifests/namespace.yaml<br/>kubectl get namespaces<br/>NAME              STATUS   AGE<br/>default           Active   11m<br/>ingress-nginx     Active   10m<br/>kube-node-lease   Active   11m<br/>kube-public       Active   11m<br/>kube-system       Active   11m<br/>python-demo-app   Active   12s # &lt;-- Here is our namespace</span></pre><p id="b9ee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在部署应用程序的其余部分:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="7b56" class="lt jm hi kr b fi lu lv l lw lx">kubectl apply -f k8s-manifests/deployment.yaml \<br/>  -f k8s-manifests/service.yaml \<br/>  -f k8s-manifests/ingress.yaml \<br/>  -f k8s-manifests/job.yaml</span></pre><p id="dafd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Kubectl将返回一个输出:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="7ba0" class="lt jm hi kr b fi lu lv l lw lx">deployment.apps/python-demo-app-web created<br/>service/python-demo-app-web created<br/>Warning: networking.k8s.io/v1beta1 Ingress is deprecated in v1.19+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress<br/>ingress.networking.k8s.io/python-demo-app-web created<br/>job.batch/hello-world-job created</span></pre><p id="ada9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我已经提到了为什么我们使用<code class="du ko kp kq kr b">networking.k8s.io/v1beta1</code>而不是<code class="du ko kp kq kr b">networking.k8s.io/v1</code></p><p id="5da8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查是否所有资源都已部署并正在运行:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="f1d9" class="lt jm hi kr b fi lu lv l lw lx">kubectl get pods,jobs,service,ingress -n python-demo-app<br/>NAME                                      READY   STATUS      RESTARTS   AGE<br/>pod/hello-world-job-9l9w9                 0/1     Completed   0          10s<br/>pod/python-demo-app-web-5f756fbcc-628cd   0/1     Running     0          10s<br/>pod/python-demo-app-web-5f756fbcc-cz5kl   0/1     Running     0          10s</span><span id="3d47" class="lt jm hi kr b fi mf lv l lw lx">NAME                        COMPLETIONS   DURATION   AGE<br/>job.batch/hello-world-job   1/1           3s         10s</span><span id="9dde" class="lt jm hi kr b fi mf lv l lw lx">NAME                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE<br/>service/python-demo-app-web   ClusterIP   10.100.245.172   &lt;none&gt;        80/TCP    10s</span><span id="7d9f" class="lt jm hi kr b fi mf lv l lw lx">NAME                                            CLASS   HOSTS                 ADDRESS   PORTS   AGE<br/>ingress.networking.k8s.io/python-demo-app-web   nginx   python-app.demo.com             80      10s</span></pre><p id="45b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络豆荚还在启动。让我们再等几秒钟。在我们等待的时候，我们可以检查<code class="du ko kp kq kr b">job</code>箱<code class="du ko kp kq kr b">pod/hello-world-job-9l9w9</code>，因为工作被标记为已完成:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="f093" class="lt jm hi kr b fi lu lv l lw lx">kubectl logs hello-world-job-9l9w9 -n python-demo-app                         <br/>Hello, world from CLI!</span></pre><p id="7397" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">完美！一次性作业成功运行并完成。返回web窗格:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="f644" class="lt jm hi kr b fi lu lv l lw lx">kubectl get deployment,replicaset,pods -n python-demo-app<br/>NAME                                  READY   UP-TO-DATE   AVAILABLE   AGE<br/>deployment.apps/python-demo-app-web   0/2     2            0           6m9s</span><span id="22d1" class="lt jm hi kr b fi mf lv l lw lx">NAME                                            DESIRED   CURRENT   READY   AGE<br/>replicaset.apps/python-demo-app-web-5f756fbcc   2         2         0       6m9s</span><span id="e6cb" class="lt jm hi kr b fi mf lv l lw lx">NAME                                      READY   STATUS      RESTARTS   AGE<br/>pod/hello-world-job-9l9w9                 0/1     Completed   0          6m9s<br/>pod/python-demo-app-web-5f756fbcc-628cd   0/1     Running     0          6m9s<br/>pod/python-demo-app-web-5f756fbcc-cz5kl   0/1     Running     0          6m9s</span></pre><p id="3b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">pod正在运行，但未标记为就绪。有点不对劲。我们需要检查一个豆荚的日志:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="f402" class="lt jm hi kr b fi lu lv l lw lx">kubectl logs python-demo-app-web-5f756fbcc-628cd -n python-demo-app<br/>[2021-04-22 21:22:32 +0000] [1] [INFO] Starting gunicorn 20.0.4<br/>[2021-04-22 21:22:32 +0000] [1] [INFO] Listening at: http://127.0.0.1:8000 (1)<br/>[2021-04-22 21:22:32 +0000] [1] [INFO] Using worker: sync<br/>[2021-04-22 21:22:32 +0000] [7] [INFO] Booting worker with pid: 7</span></pre><p id="63a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">没什么奇怪的。描述一下那个豆荚怎么样:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="b882" class="lt jm hi kr b fi lu lv l lw lx">kubectl describe pod python-demo-app-web-5f756fbcc-628cd -n python-demo-app<br/>&lt;...&gt;<br/>Events:<br/>  Type     Reason     Age                     From               Message<br/>  ----     ------     ----                    ----               -------<br/>  Normal   Scheduled  9m5s                    default-scheduler  Successfully assigned python-demo-app/python-demo-app-web-5f756fbcc-628cd to minikube<br/>  Normal   Pulled     9m3s                    kubelet            Container image "python-demo-app:init" already present on machine<br/>  Normal   Created    9m3s                    kubelet            Created container python-demo-app-web<br/>  Normal   Started    9m3s                    kubelet            Started container python-demo-app-web<br/>  Warning  Unhealthy  3m55s (x30 over 8m45s)  kubelet            Readiness probe failed: Get "http://172.17.0.3:8000/": dial tcp 172.17.0.3:8000: connect: connection refused</span></pre><p id="3e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过检查两个输出，我们可以发现问题。<code class="du ko kp kq kr b">gunicorn</code>清楚地显示它在<code class="du ko kp kq kr b">localhost</code>监听，而<code class="du ko kp kq kr b">Readiness</code>试图向容器IP发出HTTP请求。解决方案是将<code class="du ko kp kq kr b">gunicorn</code>绑定到所有接口。这可以通过向带有<code class="du ko kp kq kr b">--bind 0.0.0.0</code>标志的<code class="du ko kp kq kr b">container</code>添加<code class="du ko kp kq kr b">args</code>部分来解决。当然，有更多的方法来解决这个问题，但是我将把那个留给你，以防这个太容易。</p><p id="61fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从<code class="du ko kp kq kr b">Dockerfile</code>我们知道，提供给<code class="du ko kp kq kr b">entrypoint</code>的参数是<code class="du ko kp kq kr b">app:app</code>。这意味着它也必须添加到<code class="du ko kp kq kr b">args</code>中。</p><p id="efa4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前往<code class="du ko kp kq kr b">deployment</code>清单，并在<code class="du ko kp kq kr b">image</code>键下添加<code class="du ko kp kq kr b">args</code>:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="0fb1" class="lt jm hi kr b fi lu lv l lw lx">&lt;...&gt;<br/>          image: python-demo-app:init<br/>          args:<br/>            - '--bind'<br/>            - '0.0.0.0'<br/>            - 'app:app'<br/>          ports:<br/>&lt;...&gt;</span></pre><p id="2795" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重新部署</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="4dd2" class="lt jm hi kr b fi lu lv l lw lx">kubectl apply -f k8s-manifests/deployment.yaml<br/>deployment.apps/python-demo-app-web configured</span></pre><p id="0966" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">30-60秒后，pod应该开始运行</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="c2d5" class="lt jm hi kr b fi lu lv l lw lx">kubectl get pods -n python-demo-app                      <br/>NAME                                   READY   STATUS      RESTARTS   AGE<br/>hello-world-job-9l9w9                  0/1     Completed   0          22m<br/>python-demo-app-web-6c4cc75ddc-tmxjl   1/1     Running     0          67s<br/>python-demo-app-web-6c4cc75ddc-wb79r   1/1     Running     0          87s</span></pre><p id="ea23" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">的确如此。我们走吧。我们发现并修复了一个错误！</p><p id="9aee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从外部访问我们的应用程序吗？让我们检查一下:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="7cb2" class="lt jm hi kr b fi lu lv l lw lx">curl -H "Host: python-app.demo.com" $(minikube ip)/<br/>Hello, World!</span></pre><p id="5569" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">HTTP请求成功，返回答案！没有别的事可做了。我们现在可以清除集群中的所有内容:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="30a3" class="lt jm hi kr b fi lu lv l lw lx">kubectl delete -f k8s-manifests/deployment.yaml \<br/>  -f k8s-manifests/service.yaml \<br/>  -f k8s-manifests/ingress.yaml \<br/>  -f k8s-manifests/job.yaml</span></pre><p id="ba05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">此外，删除名称空间:</p><pre class="ll lm ln lo fd lp kr lq lr aw ls bi"><span id="042c" class="lt jm hi kr b fi lu lv l lw lx">kubectl delete -f k8s-manifests/namespace.yaml</span></pre><h1 id="d0dd" class="jl jm hi bd jn jo ks jq jr js kt ju jv jw ku jy jz ka kv kc kd ke kw kg kh ki bi translated">结论</h1><p id="5f50" class="pw-post-body-paragraph if ig hi ih b ii kj ik il im kk io ip iq kl is it iu km iw ix iy kn ja jb jc hb bi translated">恭喜你写了你自己的Kubernetes清单。如果这太简单了，而你想要更多，这里有几个可以额外完成的任务:</p><ul class=""><li id="c406" class="kx ky hi ih b ii ij im in iq kz iu la iy lb jc lc ld le lf bi translated">修改CLI命令以读取名为<code class="du ko kp kq kr b">MESSAGE</code>的<code class="du ko kp kq kr b">environment variable</code>，并使用<a class="ae jd" href="https://kubernetes.io/docs/concepts/configuration/configmap/" rel="noopener ugc nofollow" target="_blank">配置图</a>传递值</li><li id="37b5" class="kx ky hi ih b ii lg im lh iq li iu lj iy lk jc lc ld le lf bi translated">使用<code class="du ko kp kq kr b">configmap</code>创建<code class="du ko kp kq kr b">gunicorn</code>配置文件，并将其安装到<code class="du ko kp kq kr b">web</code>吊舱。确保<code class="du ko kp kq kr b">bind</code>是通过配置文件传递的，而不是通过<code class="du ko kp kq kr b">args</code></li></ul><p id="ee46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">应用程序的清单可以在<a class="ae jd" href="https://github.com/brnck/k8s-python-demo-app/tree/manifests" rel="noopener ugc nofollow" target="_blank">这里</a>找到。继续下一个指南，我们将<a class="ae jd" href="https://augustasberneckas.medium.com/write-helm-charts-for-python-flask-app-ee2777fb458c" rel="noopener">将清单包装到舵图</a></p></div></div>    
</body>
</html>