<html>
<head>
<title>Java 16 — 25+ years and the lifecycle ahead</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Java 16-25年及其未来的生命周期</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/java-25-years-of-evolution-and-the-lifecycle-ahead-8ea1f792f6da?source=collection_archive---------9-----------------------#2021-06-06">https://medium.com/analytics-vidhya/java-25-years-of-evolution-and-the-lifecycle-ahead-8ea1f792f6da?source=collection_archive---------9-----------------------#2021-06-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><figure class="im in io ip fd iq er es paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><div class="er es il"><img src="../Images/2acf34da8a4b3ed1788e5661caa3d214.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JndMraGbb8HKzj3oLkc2DQ.jpeg"/></div></div></figure><p id="6bed" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">他的开始听起来像是一个狂热爱好者，但是Java已经出现了，如果不是在软件这个术语被创造出来后不久就处于软件革命的中心的话。开发生命周期和社区支持一直是一种必须克服其前辈的缺点的语言(就软件行业中最受珍视但又被诅咒的语言而言)。本文将介绍Java 8到Java 16发布后发生的所有变化，并重点介绍一些帮助Java变得更加活跃和对开发人员友好的关键变化。</p><h1 id="29a8" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">🚼初始版本</h1><p id="dde2" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">从第一次修订到第八次迭代，它一直是主要版本走出沙箱的障碍，并在社区中引起巨大的反弹，同时也破坏了贡献和功能、补丁或仅仅是反馈实现的速度，而它对其他编程语言是无缝的。</p><p id="3d9d" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">从Java 7到Java 8的过渡持续了3年，足以发布一些主要特性来改进语言。更不用说，也是Java 7缺少了很多主要的特性，这些特性帮助了同时代的其他语言在发布迭代中不断发展。</p><h1 id="14a9" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">📅什么变了？</h1><p id="b4c6" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">幸运的是，在一系列糟糕的更新之后，hiccup填补了特性发布周期，以及Oracle发布节奏问题带来的所有负面影响。随着从Java 7到8的过渡，更新周期的逐步调整有助于Java通过开发人员和贡献者早期缺乏的支持而发展。</p><p id="c8e8" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">值得称赞的是，它现在拥有一些最广泛、最方便的特性，这些特性易于挑选和使用，并且不会转移对业务逻辑的关注(是的，在JDK10中提供了lambda表达式、谓词和<code class="du ky kz la lb b">var</code>声明语法)。公平地说，像这样的特性实现将需要比六个月更长的周期，但是可以在后续版本中发布，而不是延长到三年的发布周期。</p><h1 id="e70e" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">🔄🛣️路线图</h1><p id="a06e" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">自从Java 9发布以来，发布节奏在每个Java版本的时间表方面都有了很大的改进。Java的开发周期变得更加灵活<a class="ae lc" href="https://agilemanifesto.org" rel="noopener ugc nofollow" target="_blank"/>。这使得它在社区中更容易维护，并导致更快的采用，而不是花费几个月的时间来学习一种全新版本的语言，以赶上一个装满新功能的包。</p><figure class="im in io ip fd iq er es paragraph-image"><div class="er es ld"><img src="../Images/fd2d79a6f880db7d232787df6db4e4df.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*49aizgvHvHFi28XMEcy4rw.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated">Java发布路线图，来源:<a class="ae lc" href="https://en.wikipedia.org/wiki/Java_version_history" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Java_version_history</a></figcaption></figure><p id="e43b" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">自从新的生命周期开始以来，社区采取了一种更加开放源代码的方法，让用户在开放源代码和Java商业发行版之间进行选择。因此，开源和基于社区的JDK发行版(OpenJDK)已经成为主要的开发选择。但是，Oracle JDK发行版正在扩展对其旧版本和当前长期支持(LTS)版本的支持，下一轮计划是每隔几个迭代就发布一个主要的LTS版本。</p><h2 id="be88" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">TLDR？跳到变更日志？<br/>快速链接:<a class="ae lc" href="#dcc0" rel="noopener ugc nofollow"> Java 9 </a>、<a class="ae lc" href="#d2e5" rel="noopener ugc nofollow"> Java 10 </a>、<a class="ae lc" href="#d3ee" rel="noopener ugc nofollow"> Java 11 </a>、<a class="ae lc" href="#86ea" rel="noopener ugc nofollow">Java 12–13</a>、<a class="ae lc" href="#febb" rel="noopener ugc nofollow"> Java 14 </a>、<a class="ae lc" href="#1fa6" rel="noopener ugc nofollow"> Java 15 </a>、<a class="ae lc" href="#a5f8" rel="noopener ugc nofollow"> Java 16 </a></h2><figure class="im in io ip fd iq er es paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><div class="er es lw"><img src="../Images/12da15269c454f03dabc6be6ac46cb99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R65EMjacIWJ0id1-iZXWgQ.jpeg"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated">来源:<a class="ae lc" href="https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-16/" rel="noopener ugc nofollow" target="_blank">https://advanced web . Hu/a-categorized-list-of-all-Java-and-JVM-features-since-JDK-8-to-16/</a></figcaption></figure><p id="342e" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">从JDK8到16正在实施的增强建议达到了前所未有的180条，这已经成为整个周期的游戏规则改变者，并为更快、更顺畅的持续改进和增强打开了一扇新的大门。让我们看看从Java 9到最新的Java 16的所有重要特性。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="dcc0" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 9</h1><p id="fb49" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java 9于2017年9月发布，有三个<strong class="iz hi">最重要的变化:</strong></p><h2 id="62bd" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 1。</strong> <a class="ae lc" href="https://www.youtube.com/watch?v=DItYExUOPeM" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">模块化</strong> </a></h2><ul class=""><li id="e70f" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">作为<a class="ae lc" href="https://openjdk.java.net/projects/jigsaw/" rel="noopener ugc nofollow" target="_blank">拼图项目</a><strong class="iz hi"><em class="ml"/></strong>的一部分介绍了一个<strong class="iz hi"> <em class="ml">模块</em> </strong>是一组具有共同特征的代码。这增加了对现有Java包的封装，减少了版本冲突，增加了更多的安全性和性能，并开发了更小的定制JDK。</li><li id="5190" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">它重申了一个更加安全的契约的想法:被实现的<strong class="iz hi">依赖模块</strong>需要公开什么，以及<strong class="iz hi">依赖模块实现需要什么</strong>，以便只有相关代码是公共的(<strong class="iz hi">或者更确切地说是公共和导出的</strong>)。</li></ul><h2 id="41cc" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak">一个模块:</strong></h2><ul class=""><li id="8eaa" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">可以是命名的、未命名的或自动的(由编译器定义)</li><li id="7014" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">一般是写在module-info.java的文件里面<code class="du ky kz la lb b">src/main/java</code></li></ul><h2 id="5509" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 2。接口中的私有方法</strong></h2><p id="31d6" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">这使得能够在接口中编写私有和私有静态方法，以避免冗余代码，例如编写异常，这些异常可能在实现类缺少从接口重写方法的情况下引发。</p><figure class="im in io ip fd iq er es paragraph-image"><div class="er es mr"><img src="../Images/d1f762c6392bc9cf71d4f61960120e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*kGGIPEOUguK4j5qQNaZe2w.jpeg"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jx"> JShell命令示例</strong></figcaption></figure><h2 id="1872" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">3.<a class="ae lc" href="https://docs.oracle.com/javase/9/jshell/introduction-jshell.htm" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> JShell </strong> </a></h2><p id="8f3c" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Oracle开发了<strong class="iz hi">一个REPL( </strong> <em class="ml">读取-评估-打印-循环)</em> <strong class="iz hi"> </strong>工具，非常类似于Python的IDLE或者Scala的shell又名<strong class="iz hi"> JShell </strong>。顾名思义，它可以用来运行命令、创建变量、类、方法，并快速测试它们。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="d2e5" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 10</h1><p id="67ec" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">6个月后，也就是2018年3月，Java 10仅带来了两项重大变化:</p><h2 id="d1c5" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 1。甲骨文JDK vs公开赛JDK </strong></h2><p id="a1ba" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">作为对开发人员友好的一步，社区决定增强OpenJDK发行版，并将其作为主要的JDK进行推广。然而，如果一个人想要一个Oracle JDK发行版和对旧的LTS版本(如8和11)的扩展支持，就需要从Oracle订阅一个商业许可证。</p><figure class="im in io ip fd iq er es paragraph-image"><div class="er es ms"><img src="../Images/7f166fd3ff1b2a02b4b4766af0f85700.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*qaZTEtVjLL30fEjOOnTNYg.jpeg"/></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jx"> var关键字用于字符串值的用法</strong></figcaption></figure><h2 id="51af" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">2.<strong class="ak">变量推断</strong></h2><p id="2261" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java 10带来了非常需要的关键字<code class="du ky kz la lb b">var</code>，<strong class="iz hi">消除了定义每个变量类型的礼仪需要。本质上，人们可以将任何类型的值赋给变量，而不用担心类型。然而，需要注意的是，一旦定义了，类型就不能改变，这并不能说明<strong class="iz hi">仍然是静态类型语言</strong>。</strong></p><h2 id="c90b" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak">注意:变量应该是</strong></h2><ul class=""><li id="44a9" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">一经声明就被定义</li><li id="9f24" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">只有局部变量<em class="ml">(既不是类成员也不是函数参数)</em></li></ul></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="d3ee" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 11</h1><p id="e9cc" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">2018年9月，Java 11的发布带来了<strong class="iz hi">两个</strong>关键性的变化。这也是第一个长期支持到2026年的版本。</p><h2 id="3875" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 1。局部参数的类型推断</strong></h2><p id="7781" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">对lambda表达式的形参使用<code class="du ky kz la lb b">var</code>会导致参数的类型被推断出来。这允许在带有注释验证的谓词中使用变量时有更多的自由语法。</p><h2 id="caf6" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">2.<strong class="ak"> javac更新</strong></h2><p id="910e" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">消除了传统的两步编译-运行过程，从Java 11开始不再需要<code class="du ky kz la lb b">javac</code>命令来编译Java文件。相反，编译和运行过程可以通过运行<code class="du ky kz la lb b">java</code>命令一步完成。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="86ea" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 12和13</h1><h2 id="6f9c" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 1。开关情况表达式</strong></h2><p id="db57" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java 12为<strong class="iz hi"> switch-case块的风格带来了一个单一但语法优雅的变化，</strong>消除了switch-case中多余的中断，语法与lambda表达式同义。</p><div class="im in io ip fd ab cb"><figure class="mt iq mu mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/23d8e91af618a1790998e64b0ef7eb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*XEfcwxRcCFUKWyzdn88sKQ.png"/></div></figure><figure class="mt iq mz mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/2765cc1925f3a69fd5c96caf6e371411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*y13oSngCLGiwUdZt15SGhA.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx na di nb nc translated"><strong class="bd jx">更新switch case语句(Java12，13) </strong></figcaption></figure></div><figure class="im in io ip fd iq er es paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><div class="er es nd"><img src="../Images/800e3a662e5a6be0de229ec8aae89e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y7vNr3ggMaQoTo0H51EAgg.png"/></div></div><figcaption class="le lf et er es lg lh bd b be z dx translated"><strong class="bd jx"> Java 13用yield关键字切换表达式</strong></figcaption></figure><p id="48e0" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><strong class="iz hi"> Java 13 </strong>进一步改进了<strong class="iz hi"> switch-case块中的表达式定义，</strong>允许每个case使用<code class="du ky kz la lb b">yield</code>关键字返回值。这提高了可读性，而不是在早期的case表达式中使用箭头(→)操作符。注意，<strong class="iz hi"> break仍然可以和</strong>任何表达式类型一起使用。</p><h2 id="68ad" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">2.多行文本块(预览🔬)</h2><blockquote class="ne nf ng"><p id="91ee" class="ix iy ml iz b ja jb jc jd je jf jg jh nh jj jk jl ni jn jo jp nj jr js jt ju ha bi translated"><em class="hh">文本块的基本原则是通过最小化呈现跨越多行的字符串所需的Java语法来提供清晰度。<br/> </em> <a class="ae lc" href="https://docs.oracle.com/en/java/javase/15/text-blocks/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi"> <em class="hh">甲骨文</em> </strong> </a></p></blockquote><div class="im in io ip fd ab cb"><figure class="mt iq nk mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/c51dc5afe62b36d8a80ca87d3e43f8e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*siBjGBJxdke8QvBD7-1NeA.png"/></div></figure><figure class="mt iq nl mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/e520d0541e5022bdea3748dff579cb09.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*8nmFrp-uUE4esHOG1Zc3sA.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx nm di nn nc translated"><strong class="bd jx">Java 13中的多行文本块预览</strong></figcaption></figure></div><p id="2392" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">简单地说，文本块的目的是允许以更简单的方式定义包含换行符(\n)和回车符(\r)的字符串，这与python定义多行字符串的方式非常相似。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="febb" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 14</h1><p id="a687" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java 14的发布带来了语法和内部的大量改进(是的，是重大的改进)。</p><figure class="im in io ip fd iq er es paragraph-image"><div class="er es no"><img src="../Images/6c88da2aee6935110ebf8b47e7aca1ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:526/format:webp/1*nGsd5FnYzuBcF09eCY2mIw.jpeg"/></div></figure><h2 id="acf9" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 1。空指针异常(如释重负)</strong></h2><p id="7097" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">空指针异常(NPE)一直是一个活生生的Java开发人员的噩梦，也是发生最频繁的问题。Optional在一定程度上对修正带有变量或值的NPE问题有很大的帮助，但是不能解决一个核心问题—<strong class="iz hi">npe没有有意义的消息。</strong></p><div class="im in io ip fd ab cb"><figure class="mt iq np mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/2771c37902f6402a3996110455a97ade.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*wYEv_rZ7r8-6NUMm8rpFDQ.png"/></div></figure><figure class="mt iq np mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/b7dddfeff48c742ab9be5b962c32ed72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*mVP2vWpIc287A5CsWjlccw.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx nq di nr nc translated"><strong class="bd jx">增强了Java 14中的NullPointerException冗长性</strong></figcaption></figure></div><p id="3af7" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">这里，<strong class="iz hi"> getUser </strong>()或<strong class="iz hi"> getName </strong>()可能会返回空值，从而导致NullPointerException。这里的问题是，异常并没有详细说明是什么导致了异常的发生。如果使用以下标志，JVM现在会在NullPointerExceptions中隐式生成有意义的消息。<code class="du ky kz la lb b"><strong class="iz hi"><em class="ml">-XX:+ShowCodeDetailsInExceptionMessages</em></strong></code> <em class="ml">突出显示导致异常发生的变量</em>。</p><h2 id="5a26" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated"><strong class="ak"> 2。记录(预览</strong>🔍<strong class="ak"> ) </strong></h2><ul class=""><li id="16bc" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">向Java添加新特性背后的驱动因素大部分(如果不是一直的话)是为了<strong class="iz hi">减少开发人员为实际编写核心业务逻辑而执行的准备工作的过程</strong>，而不是不断地关注每个所需实体的声明，只贡献了不到1%。一个这样的例子是在Java中定义POJOs或实体类，它们通常满足对实体建模或对正在执行的一些动作建模的需要。</li><li id="85c4" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">这就是Records的用武之地，它大大减少了传统的Java类定义样板文件，此外，还允许更新现有的方法(比如参数化的构造函数)。</li></ul><h2 id="fa38" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">TLDR？</h2><ul class=""><li id="be49" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">简化的类别定义</li><li id="885d" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">显著减少POJOs的样板代码</li><li id="66e7" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">仅实现需要定制业务逻辑的内容</li></ul><div class="im in io ip fd ab cb"><figure class="mt iq ns mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/c06dff6e6c7444a5c2f3a8d7cec9b83e.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*dA72Fs01vF9RMzrt6aqRHQ.png"/></div></figure><figure class="mt iq nt mv mw mx my paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><img src="../Images/366e35f68c195de83a3ada141402319e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*hL5vgPya0TkLyCJvcQbL-Q.png"/></div><figcaption class="le lf et er es lg lh bd b be z dx nu di nv nc translated"><strong class="bd jx">Java 14中使用Record进行类代码简化</strong></figcaption></figure></div><h2 id="b32a" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">3.模式匹配的实例(预览🔍)</h2><p id="aaee" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">一个古老(但最常用)特性的有趣更新是在条件检查中使用变量名。这防止了额外的造型，从而减少了代码工作量。例如，在下面的代码块中，它执行两个主要任务:—</p><ol class=""><li id="7c9b" class="mc md hh iz b ja jb je jf ji nw jm nx jq ny ju nz mi mj mk bi translated">变量的类型检查(如instanceof之前所做的)</li><li id="7efa" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju nz mi mj mk bi translated">消除对正在检查类型的变量进行强制转换</li></ol></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="1fa6" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 15</h1><p id="4f4d" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java最近的迭代给语言带来了三个主要的变化，或者增强了面向对象编程的思想，或者为开发人员增强了语言的安全性，另外，文本块(在preview的早期)现在是语言的标准部分。</p><h2 id="be6f" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">1.密封和非密封classes❗</h2><p id="b72c" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">在增强面向对象编程方面向前迈了一步，密封和非密封关键字是Java 15的预览版。</p><p id="e1a4" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated"><code class="du ky kz la lb b"><strong class="iz hi">sealed</strong></code>(听起来像某种形式的打包，因为这正是它所做的)确保接口可以创建一个契约，指定哪些类可以扩展或实现它，并且所有类都遵守它，而<code class="du ky kz la lb b"><strong class="iz hi">non-sealed</strong></code>做的正好相反，打破契约，允许扩展和实现类</p><figure class="im in io ip fd iq er es paragraph-image"><div role="button" tabindex="0" class="ir is di it bf iu"><div class="er es oa"><img src="../Images/a29c8f57463ae3f48a2c81f6c2286b10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zFbaewVcdBj60aCUuab5Ug.jpeg"/></div></div></figure><h2 id="af0c" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">2.爱德华兹曲线数字签名🔒</h2><p id="cce3" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated"><strong class="iz hi">edd sa</strong>(<em class="ml">Edwards-Curve数字签名算法</em>)<a class="ae lc" href="https://tools.ietf.org/html/rfc8032" rel="noopener ugc nofollow" target="_blank">RFC 8032</a>是通过<a class="ae lc" href="https://openjdk.java.net/jeps/339" rel="noopener ugc nofollow" target="_blank"> JEP 339 </a>最新增加的Java 15的签名方案。虽然它没有取代JDK现有的<em class="ml">椭圆曲线数字签名算法</em> ( <strong class="iz hi"> ECDSA </strong>)，但是它:</p><ul class=""><li id="51bf" class="mc md hh iz b ja jb je jf ji nw jm nx jq ny ju mh mi mj mk bi translated">提供独立于平台的EdDSA实现。</li><li id="fb27" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">执行时间不变，与密钥长度无关。</li><li id="2eff" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">提供标准化的参数设置<strong class="iz hi"> Ed25519 </strong>和<strong class="iz hi"> Ed448 </strong></li><li id="dc50" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">是TLS 1.3中允许的三种签名方案之一。</li></ul><p id="805d" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">一些库已经提供了这一功能，但现在它是Java本身的核心特性，并且比现有的ECDSA实现更好。</p><h2 id="4d90" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">4.隐藏类🔍</h2><p id="5888" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">这些是比普通功能更高级的功能。这些防止了与框架无关的框架类的使用，这些类被定义为在字节码级别使用(通过反射)。</p><h2 id="74eb" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">性能</h2><ul class=""><li id="2334" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">不能命名为超类型</li><li id="391a" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">不能是声明字段类型</li><li id="9015" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">不能是参数类型或返回类型</li><li id="7f2d" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated">无法通过<code class="du ky kz la lb b">Class::forName</code>、<code class="du ky kz la lb b">ClassLoader::loadClass</code>、<code class="du ky kz la lb b">Lookup::findClass</code>被类加载器找到</li></ul></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="a5f8" class="jv jw hh bd jx jy lx ka kb kc ly ke kf kg lz ki kj kk ma km kn ko mb kq kr ks bi translated">Java 16🆕</h1><p id="9ee8" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java 16是最近发布的语言版本，引入了主要的孵化API和C++ 14语言特性。本次迭代共有<a class="ae lc" href="https://openjdk.java.net/projects/jdk/16/" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi"> 17个特性</strong> </a>。</p><h2 id="e1a2" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">1.原料药(孵化)</h2><ul class=""><li id="b2de" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated"><strong class="iz hi"> Vector API <br/> </strong>是定义的向量模块的初始模型。这不是传统系列的一部分，而是全新的<code class="du ky kz la lb b">jdk.incubator.vector</code>套装。它的主要目标是在执行非常类似于Python-Numpy(或Pandas) vectors的矢量化操作时减少CPU的计算开销。它表达了编译成最佳硬件指令的矢量计算。</li><li id="258e" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated"><a class="ae lc" href="https://openjdk.java.net/jeps/389" rel="noopener ugc nofollow" target="_blank"> <strong class="iz hi">外来链接器API </strong> </a> <strong class="iz hi"> <br/> </strong>这个API提供外来函数支持，不需要任何中间的JNI胶水代码。这是通过将外部函数公开为方法句柄来实现的，方法句柄可以在纯Java代码中声明和调用。编写、构建和分发依赖于外来库的Java库和应用程序被大大简化了。</li><li id="f6ef" class="mc md hh iz b ja mm je mn ji mo jm mp jq mq ju mh mi mj mk bi translated"><strong class="iz hi">外来内存访问API <br/> </strong>这为Java程序提供了对Java堆外外来内存的安全有效的访问。<strong class="iz hi">外部链接器API </strong>与此一起，为第三方本地互操作框架提供了一个有效的基础。</li></ul><h2 id="ad5d" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">2.<a class="ae lc" href="https://openjdk.java.net/jeps/347" rel="noopener ugc nofollow" target="_blank"> C++ 14的特性</a></h2><ul class=""><li id="688d" class="mc md hh iz b ja kt je ku ji me jm mf jq mg ju mh mi mj mk bi translated">这样做的目的是允许在JDK内对C++源代码进行修改，以利用C++14语言的特性，并给出关于哪些特性可以在热点代码中使用的具体指导。</li></ul><h1 id="fa35" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">将来的</h1><h2 id="8b1f" class="li jw hh bd jx lj lk ll kb lm ln lo kf ji lp lq kj jm lr ls kn jq lt lu kr lv bi translated">现代LTS Java版本</h2><p id="30b6" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated"><strong class="iz hi"> Java 17(LTS发布)</strong>将于2021年9月发布。根据时间表，这将成为下一个长期支持的版本，并将带来大量的预览功能和一直到JDK16的增强功能，进一步增强Java平台的稳定性、安全性和性能。</p><h1 id="19f1" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结论</h1><p id="9be5" class="pw-post-body-paragraph ix iy hh iz b ja kt jc jd je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ha bi translated">Java一直处于开发周期的风口浪尖，因为许多关键任务和企业应用程序都是基于它开发的大量框架。敏捷方法直接或间接地从社区和语言特性的丰富性两方面推动了Java平台的发展。</p><p id="4b4a" class="pw-post-body-paragraph ix iy hh iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju ha bi translated">就您喜欢或希望在即将到来的迭代中看到哪个特性，写下您的想法。</p></div></div>    
</body>
</html>