<html>
<head>
<title>Human Verification Using MNIST Dataset (with Code)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MNIST数据集的人工验证(带代码)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/human-verification-using-mnist-dataset-with-code-dc3477c17909?source=collection_archive---------19-----------------------#2021-05-12">https://medium.com/analytics-vidhya/human-verification-using-mnist-dataset-with-code-dc3477c17909?source=collection_archive---------19-----------------------#2021-05-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="4b60" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="a2db" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在本文中，我们将使用多层神经网络对手写数字进行分类。我们将使用这种分类来构建人工验证系统，因为我们要求人工书写一个3位数的数字，检查书写是否正确，并验证用户输入的数字。因为他们有很多方法来写一些数字，他们可以写在盒子的任何地方，我们使用open CV来获得完美的大小图像，使用ML来预测数字，并使用JavaScript来验证数字。对于预测，我们使用一个3隐层神经网络。在MNIST数据集中，我们得到一个28*28大小的图像数据集，其中每个数据集在每个方向上都被4个像素包围。我们在MNIST数据集上取得了97.23%的数字分类成功率。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es ka"><img src="../Images/c52d562abbb35b1780d44eeb16528830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*RXPBVHakdTDP78MYACEKkA.gif"/></div></figure><p id="835f" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated"><a class="ae kn" href="https://github.com/srinivaskool/Human_Verification" rel="noopener ugc nofollow" target="_blank"> GitHub </a></p><p id="0eec" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated"><a class="ae kn" href="https://srinivaskool.github.io/Human_Verification/" rel="noopener ugc nofollow" target="_blank"> <em class="ko">现场试玩</em> </a></p><h1 id="379c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">数据分析和可视化</h1><p id="ec24" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">MNIST数据由70，000张手写数字图像组成。我们将遵循从预处理到预测数字的步骤。我们将从理解计算机如何理解图像开始。</p><p id="df44" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">我们将图像转换成整数数组。我们可以用红、蓝、绿三个数字来表示图像的每一个像素。但是MNIST数据图像是灰度的，所以我们只有两个通道，白色和黑色。因此，如果数组元素值是255，这意味着像素是白色的，而值0表示黑色。0到255之间的其他值代表灰色。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es kp"><img src="../Images/731a2d36d0668f788c22032103a1ac34.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/0*WkwMcjE4cuUEehFU"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">图:带标签的MNIST数据集的前16位数字。</figcaption></figure><p id="1864" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">现在让我们看看MNISTS数据集中数字之间的分布。下面是分布的频率表和圆环图(70，000张图片)。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es ku"><img src="../Images/3b7490b450cef75d2e723832b8b31a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/0*JGQwOPpaHm86JQwI"/></div></figure><p id="0fe9" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">当数据的范围是0到1而不是0到255时，机器学习得更好，因此对于归一化，我们使用最小-最大归一化，这种情况下导致每个数组元素除以255。在日常生活中，我们可以用不同的方式书写一个数字，所以很难预测这个数字。我们需要将60，000幅图像的数据分成训练集、测试集和验证集。我用50，000张图像训练我们的模型，为了验证，我们使用10，000张图像和剩余的10000张图像进行测试。这里的验证样本帮助我们选择最佳模型和约束条件。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es kv"><img src="../Images/0c5d5a5ff41578b180d4482bf3d3d58a.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/0*ctuA16hTCbFtzMNq"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">表格:表格显示了70.000个手写图像的MNIST数据集的分布</figcaption></figure><p id="30b6" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">清理和预处理数据的主要部分已经由修改后的<a class="ae kn" href="https://www.blogger.com/u/3/blog/post/edit/6845097395694165650/453712064123607061#" rel="noopener ugc nofollow" target="_blank">国家标准与技术研究院</a>完成。图像的大小是28*28，但数字将只有20*20大小，所以图像被放在中间，所有4个边上都有4px填充。让我们看看测试数据集中数字的分布。数字9出现的频率最高，这意味着在测试数据集中有很多手写的9位数字。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es kw"><img src="../Images/8cabdcfd7d15333504e6e164db437217.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/0*SddJdOL0ESuXTju5"/></div></figure><p id="00b8" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">表:上表显示了测试集中数字的分布。</p><h1 id="aea6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">神经网络</h1><p id="3a7a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这是一个带有输入和输出层的3隐层神经网络。这叫做多层感知器。我们可以在反向传播的帮助下计算每两个神经元之间的关联权重，以获得更好的结果。除了最后一层是SoftMax，所有层都使用Relu作为激活函数，因为我们需要进行分类，所以我们希望在最后一步中获得概率，以确定最高概率作为预测数字。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es kx"><img src="../Images/59c152844e2bec2b90c0eaa1f71ff645.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oxNZCKuMyON_I7Zf"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">图:我创建的多层层感知器的完整图。</figcaption></figure><p id="5575" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">我们没有使用Keras来实现分类，因为我们需要使用tensorboard来查看每个时期的损失/成本函数。从张量板上看到损失函数，我们可以得到学习率和几个历元的最佳值。</p><h1 id="9d57" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">准确性分析</h1><p id="ee80" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以从不同颜色的描述表中看到，该表显示了不同模型的准确性和成本，训练集和验证集的学习率分别为0.0001和0.001。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lc"><img src="../Images/ce3dc1f1aa1501e30d7e21f38d734555.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/0*OcsffxuVU7HQgp5J"/></div></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es ld"><img src="../Images/7a4c66c7b1234c0fec9664f1e13ca912.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dov-o2R5IdHlMAxB"/></div></div></figure><p id="aa72" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">从上面的图中我们可以看到，在前15个时期精度增加了很多，然后我们可以看到精度几乎保持不变，直到第50个时期。所以我们用了25个纪元来训练这个模型。为了获得更高的精度，我们将0.0001作为学习率。当学习率为0.001时，精度从较高的点开始，并且总是高于学习率为0.0001时的精度。在两种学习率下，验证集的准确度总是低于训练集。这里没有过度拟合。</p><h1 id="b7ff" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">成本函数分析</h1><p id="9830" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们可以从不同颜色的描述表中看到，该表显示了不同模型的准确性和成本，训练集和验证集的学习率分别为0.0001和0.001。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lc"><img src="../Images/1d5548235f4c0b71d1003ce7a9e8a93c.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/0*AdECl_TfofvKJA9p"/></div></figure><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es le"><img src="../Images/71044c179517faf47e5b4247acd8f9b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QiJev8iMxqGzvmef"/></div></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">图:该图显示了训练和验证集的学习率为0.001，0.0001的不同时期的成本函数。</figcaption></figure><p id="7766" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">从上图可以看出，当学习率为0.001时，成本函数的起点比学习率为0时低。0001.50个纪元的成本也和25个纪元差不多。所以我们继续25个纪元，学习率为0.001。验证集的成本总是高于训练集。从成本函数中，我们可以确定，随着我们在开始时高度增加时期，成本降低，但是在15个时期之后降低。总的来说，我们可以看到成本函数随着更多的时期而降低，而精确度随着时期的数量而增加。当学习率为0.001而不是0.0001时，我们可以看到精度的巨大提高和成本函数的巨大降低。下表给出了模型的最终约束条件。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lf"><img src="../Images/e203f06ea6b9a053ebb74cbe848137b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:674/0*bDS_UmZZ3L48Lv8s"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">表:模型考虑的所有值。</figcaption></figure><p id="f0f6" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">在对数据进行预处理时，像数字2、5、9…这样的标签都将被转换为one-hot-encoding，这意味着在该行中，只有数字的索引是1，而所有其他的都是0。为了包括来自外层的内层的输入，使用所有外层与它们和内层之间的权重的矩阵乘法。初始权重和偏差取自标准偏差为0.01的截断正态分布，这里我们使用偏差，因为它改变了激活函数。我们使用Adam优化器，对于损失函数，我使用SoftMax交叉熵函数。</p><h1 id="ba2b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">数字分类的结果:-</h1><p id="981a" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">下表显示了历元数的精度，我们可以看到，随着历元数的增加，精度会增加，但随着时间的推移，精度增加的差异会减小。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lg"><img src="../Images/78c5bb88e96839eefd0b7c1bc3a4be74.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/0*kywcHKCZJFzURSw4"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">表:该表显示了25个历元的精度。</figcaption></figure><p id="e607" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi lh translated">测试数据集的准确率为0.9723或97.23%。</p><p id="913b" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">数字分类的混淆矩阵如下所示。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lq"><img src="../Images/c1ec26f5706e486ed67207f5292e7fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/0*z66oiTru0l7Asur-"/></div></figure><p id="8536" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">如果我们有真阳性(TP)、真阴性(TN)、假阳性(FP)、假阴性(FN)，那么计算不同的度量就很容易了。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es lr"><img src="../Images/007055731a967ba5a908a0d24dc586f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/0*40Cp6r95cpDsDyQK"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">表格:表格显示了真实的积极，真实的消极</figcaption></figure><p id="c887" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">为了计算不同的度量，如准确度、F值和精确度，我们可以使用需要知道它们的公式。这是公式表，通过查看上表或混淆矩阵中的值来计算每个数字的不同度量。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div class="er es ls"><img src="../Images/aae92d466ff88998d4e5cbf4e2a8b774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*DaxdadOPZjlTjiJN"/></div></figure><p id="d0fc" class="pw-post-body-paragraph jc jd hh je b jf ki jh ji jj kj jl jm jn kk jp jq jr kl jt ju jv km jx jy jz ha bi translated">例如，如果我们想计算数字9的F1分数，我们可以得到(2 * 0.987)/((2 * 0.987)+0.00289+0.090989)= 0.9546。同样，我们可以找到每个数字的精确度和F1分数。</p><h1 id="f904" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">我们对真实手写数字图像的模型预测(不是来自数据集)</h1><p id="1a41" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">下图分别显示了4、7、6的不同写法。该模型预测第一行中的每个数字为4，第二行中的每个数字为7，最后一行中的每个数字为6。</p><figure class="kb kc kd ke fd kf er es paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="er es lt"><img src="../Images/7a796b5d1ce3ff0270830f6711dd9451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hLm2RG4QzfPE1w3g"/></div></div></figure></div></div>    
</body>
</html>