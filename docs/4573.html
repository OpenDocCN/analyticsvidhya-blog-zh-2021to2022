<html>
<head>
<title>to .apply or not to .apply…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">敬。适用或不适用。应用…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/to-apply-or-not-to-apply-13271d10f892?source=collection_archive---------0-----------------------#2021-11-19">https://medium.com/analytics-vidhya/to-apply-or-not-to-apply-13271d10f892?source=collection_archive---------0-----------------------#2021-11-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b1e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">本文与</em> <a class="ae jd" rel="noopener" href="/@jacobdodd94"> <em class="jc">雅各布·多德</em> </a>合作</p><blockquote class="je jf jg"><p id="87cc" class="ie if jc ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">熊猫烂透了</p><p id="dc02" class="ie if jc ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">如果你没有正确使用它</p><p id="d650" class="ie if jc ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">这是一百万美元</p><p id="4c8a" class="ie if jc ig b ih ii ij ik il im in io jh iq ir is ji iu iv iw jj iy iz ja jb ha bi translated">比宾利还值钱</p></blockquote><p id="35c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不太喜欢，我们喜欢熊猫。</p><p id="8bca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本帖中，我们将向您展示如何将您的熊猫代码的日期相关计算速度提高10，000倍以上！</p><h1 id="6090" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">介绍</h1><p id="1b24" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我们不是在谈论<a class="ae jd" href="https://nationalzoo.si.edu/animals/news/pandastory-bubble-bath-wrestling-match" rel="noopener ugc nofollow" target="_blank">这些</a>熊猫(可爱)，而是<a class="ae jd" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> python库</a>我们所有的数据科学家每天都在使用它来做任何与数据相关的事情。</p><p id="6711" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">来自不同背景的新用户对熊猫很熟悉。</p><p id="e37b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您是Excel用户，那么在pandas中可以通过调用<code class="du kn ko kp kq b">DataFrame.sum</code>或<code class="du kn ko kp kq b">DataFrame.cumsum</code>方法来完成<a class="ae jd" href="https://towardsdatascience.com/intro-to-pandas-for-excel-super-users-dac1b38f12b0" rel="noopener" target="_blank">操作，例如</a>查找数组中所有列的总和或累计总和。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="412e" class="kz jl hh kq b fi la lb l lc ld">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>print(df.sum())<br/>print(df.cumsum())</span></pre><p id="a295" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你是SQL用户，像 select或join语句这样的<a class="ae jd" href="https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html" rel="noopener ugc nofollow" target="_blank">操作可以通过调用<code class="du kn ko kp kq b">DataFrame.query</code>或<code class="du kn ko kp kq b">DataFrame.merge</code>方法来完成。</a></p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="dbbc" class="kz jl hh kq b fi la lb l lc ld">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>bf = pd.DataFrame({"a": [6,5,4], "b": [3,2,1]})<br/>print(df.query("a == 1"))<br/>print(df.merge(bf, how="inner", left_on='a', right_on='b'))</span></pre><p id="904e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您是R、Stata、SAS、SPSS或其他统计语言的用户，可以通过调用<code class="du kn ko kp kq b">DataFrame.corr</code>、<code class="du kn ko kp kq b">DataFrame.std</code>或<code class="du kn ko kp kq b">DataFrame.ewm</code>方法来完成寻找相关性、标准差甚至指数加权函数等操作。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="c76d" class="kz jl hh kq b fi la lb l lc ld">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2,3], "b": [4,5,6]})<br/>print(df.ewm(com=0.8))</span></pre><p id="e5e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后但同样重要的是，矩阵乘法可以通过使用<code class="du kn ko kp kq b">DataFrame.dot</code>方法来完成。</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="42a6" class="kz jl hh kq b fi la lb l lc ld">import pandas as pd<br/>df = pd.DataFrame({"a": [1,2], "b": [3,4]})<br/>bf = pd.DataFrame({"a": [5,6], "b": [7,8]})<br/>print(df.dot(bf.T))</span></pre><p id="d2a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">或者真的任何一个<a class="ae jd" href="https://numpy.org/doc/stable/reference/ufuncs.html" rel="noopener ugc nofollow" target="_blank"> NumPy的通用函数</a>又名<em class="jc"> ufunc </em>都可以被熊猫用来尽可能多地利用<em class="jc">矢量化运算</em>。</p><p id="d2f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">尽管你运气很好，什么事都想用熊猫。</p><h1 id="31ef" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">例如日期-时间操作</h1><p id="203c" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">一个常见的操作是计算两个日期之间的间隔，比如说以年为单位。首先，让我们创建一个简单的函数和一些全局变量:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="c0f1" class="kz jl hh kq b fi la lb l lc ld">import pandas as pd<br/>from datetime import date, timedelta</span><span id="2deb" class="kz jl hh kq b fi le lb l lc ld">def calc_age_function(start_date: date, end_date: date):<br/>		"""Calculate difference between 2 dates in years."""<br/>		return (end_date - start_date)/timedelta(days=365.25)</span></pre><p id="70ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们定义一些示例日期，并计算它们之间的年龄:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="1781" class="kz jl hh kq b fi la lb l lc ld">[In]:<br/>start = date(<br/>    year=1930,<br/>    day=10,<br/>    month=5<br/>)<br/>end = date(<br/>    year=2020,<br/>    day=10,<br/>    month=8<br/>)<br/>print(calc_age_function(start, end))</span><span id="0a14" class="kz jl hh kq b fi le lb l lc ld">[Out]: 90.2532511978097</span></pre><p id="4c3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而在实践中，很可能你有不止一个日期需要做这个操作。让我们用上面列出的例子数量创建一个系列，用于计时，以及一个<code class="du kn ko kp kq b">DataFrame</code>:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="5f8f" class="kz jl hh kq b fi la lb l lc ld">from datetime import datetime, timedelta<br/>from random import randint, seed</span><span id="d1b1" class="kz jl hh kq b fi le lb l lc ld">import pandas as pd</span><span id="0d1d" class="kz jl hh kq b fi le lb l lc ld">seed(42)<br/>N_SAMPLES = 1_000_000<br/>start_date_list = [<br/>	datetime.fromisoformat("2019-01-01") + timedelta(days=randint(0,365))<br/>	for _ in range(N_SAMPLES )<br/>]<br/>end_date_list = [<br/>	datetime.fromisoformat("2020-01-01") + timedelta(days=randint(0,365))<br/>	for _ in range(N_SAMPLES )<br/>]<br/>start_dates = pd.Series(start_date_list, name="start", dtype="datetime64[ns]")<br/>end_dates = pd.Series(end_date_list, name="end", dtype="datetime64[ns]")</span><span id="34db" class="kz jl hh kq b fi le lb l lc ld">age_df = pd.DataFrame(<br/>  {<br/>    "start_date":start_dates,<br/>    "end_date": end_dates<br/>	}<br/>)</span></pre><p id="5404" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们使用lambda函数(非最佳)对数据帧中的列使用我们的函数来计算年龄</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="f3c0" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/># slow, for loop apply<br/>age_df["age"] = age_df.apply(<br/>	lambda x: calc_age_function(x["start_date"], x["end_date"]),<br/>	axis=1,<br/>)</span><span id="2523" class="kz jl hh kq b fi le lb l lc ld">20.6 s ± 63.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="62b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">作为一个python新手，<em class="jc">应用</em>可能是一件容易上手的事情。你需要记住的只是一个<em class="jc"> apply </em>方法以及如何编写一个python函数。</p><p id="ee21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是可行的，尽管对我们来说还不够快。</p><p id="c2d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有了pandas，我们可以在序列对象上使用算术运算，这比循环要快得多(通常apply会这样做，例外情况我们稍后会谈到)。</p><p id="c09a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们通过我们的函数来传递这个序列呢？</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="5b4b" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/># with date series, vectorized<br/>ages = calc_age_function(start_dates, end_dates)</span><span id="36aa" class="kz jl hh kq b fi le lb l lc ld">10.3 ms ± 104 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="4917" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">直接在序列上运行计算使这个操作<strong class="ig hi">快了2000倍</strong>！</p><p id="7bb7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们能让它更快吗？</p><p id="303b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码片段中，我们使用pandas日期-时间操作来获取两个日期之间的天数，并将其除以一个代表一年中天数的<code class="du kn ko kp kq b">timedelta</code>对象。</p><p id="0772" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们尝试使用整数运算进行相同的计算，将开始和结束日期表示为<a class="ae jd" href="https://en.wikipedia.org/wiki/Epoch_(computing)" rel="noopener ugc nofollow" target="_blank"> epoch </a>整数，而不是DateTime对象，会怎么样？</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="1f02" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/>SECONDS_TO_YEARS = 60*60*24*365.25*1_000_000_000<br/>(end_dates.astype(int) - start_dates.astype(int))/SECONDS_TO_YEARS</span><span id="6f38" class="kz jl hh kq b fi le lb l lc ld">2.22 ms ± 32.6 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</span></pre><p id="816c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是否使我们的计算速度比apply快了10，000倍？</p><p id="3059" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没错。</p><h1 id="cfb4" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">压力测试</h1><p id="285a" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">使用样本大小:100，1000，10000，100000，500000，1000000</p><figure class="kr ks kt ku fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lf"><img src="../Images/e66e8075f294055da47009d997174dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eOkgsOm7o52b3GcVwyDQxQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">应用vs矢量化datetime64[ns] vs矢量化epoch操作</figcaption></figure><p id="fb3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">令人惊讶的是apply方法的性能相对于数据大小的线性程度，在上图中显示为O(n)。此外，它比datetime64[ns]和epoch矢量化计算的规模大得多。我们无法真正比较所有三种计算的性能。让我们在这里放大到datetime64[ns]和epoch(矢量化)计算:</p><figure class="kr ks kt ku fd lg er es paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="er es lr"><img src="../Images/c23fa357f93914505312d85b41273765.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rZKt4b2aUor_uMtwsIshug.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">矢量化datetime64[ns]与矢量化epoch操作</figcaption></figure><p id="e521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用历元的好处确实在100k左右的样本中显现，因为datetime64[ns]性能是O(log n ),而历元计算几乎是<em class="jc">O(1)。</em></p><h1 id="c802" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">关于用日期时间数据类型进行序列实例化的说明</h1><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="4bef" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/># format series WITHOUT numpy dates<br/>start_dates = pd.Series([start]*N_SAMPLES, name="start")<br/>end_dates = pd.Series([end]*N_SAMPLES, name="end")</span><span id="6e07" class="kz jl hh kq b fi le lb l lc ld">1.59 s ± 6.91 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="770d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过指定Numpy datetime64:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="87a0" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/># format series WITH numpy datetime<br/>start_dates = pd.Series([start]*N_SAMPLES, name="start", dtype="datetime64[ns]")<br/>end_dates = pd.Series([end]*N_SAMPLES, name="end", dtype="datetime64[ns]")</span><span id="ef46" class="kz jl hh kq b fi le lb l lc ld">1.73 s ± 4.04 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><p id="494a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相差140 ms，但是如果您要对这些色谱柱进行多次操作，这些成本是非常值得的。</p><p id="8ad2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你愿意，也可以使用熊猫内置的<code class="du kn ko kp kq b">to_datetime</code>功能，性能差不多:</p><pre class="kr ks kt ku fd kv kq kw kx aw ky bi"><span id="e0ac" class="kz jl hh kq b fi la lb l lc ld">%%timeit<br/># format series WITH pandas datetime<br/>start_dates = pd.to_datetime(pd.Series([start]*N_SAMPLES, name="start"))<br/>end_dates = pd.to_datetime(pd.Series([end]*N_SAMPLES, name="end"))</span><span id="72f4" class="kz jl hh kq b fi le lb l lc ld">1.76 s ± 4.57 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</span></pre><h1 id="66c7" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">结论</h1><ol class=""><li id="81a2" class="ls lt hh ig b ih ki il kj ip lu it lv ix lw jb lx ly lz ma bi translated">在pandas系列(或数据帧)上运行算术运算利用了pandas中可用的矢量化功能，并且比按行应用相同的运算要快得多</li><li id="6954" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">使用pandas本地dtypes(在本例中是datetime64[ns])可以使您的操作速度大大加快</li><li id="aef5" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">对纪元日期时间的算术运算比DateTime对象开销小</li><li id="b11f" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">对于1，000，000个数据点的情况也是如此。增益并不与数据点的数量成线性比例，所以不要期望它们会这样。Travis Oliphant在与Lex Friedman的播客中指出，pandas矢量化操作的性能增益始于10，000点</li><li id="ec1a" class="ls lt hh ig b ih mb il mc ip md it me ix mf jb lx ly lz ma bi translated">熊猫的收获并不局限于它的表现。数据管道的易用性是使用pandas的一个巨大优势。如果性能对于您的生产过程不是非常重要，那么使用任何容量的pandas都可以为您节省数天或数周的数据管道开发、分析或操作时间</li></ol><h1 id="dcf7" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">下一步是什么</h1><p id="671e" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">敬请期待我们下一篇熊猫的博文。我们将更深入地研究NumPy的<em class="jc"> ufunc </em>，并分析Andrej Karpathy的<a class="ae jd" href="https://twitter.com/karpathy/status/1430316576016793600?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed&amp;ref_url=https%3A%2F%2Fwww.notion.so%2Fprestonventures%2FProjects-54ba0256df63447cbc9f7de5821da879%3Fp%3D0fc8f1ed6b1b41d0ad22ae229529ad3a" rel="noopener ugc nofollow" target="_blank">关于NumPy的<em class="jc"> sqrt </em>函数的臭名昭著的tweet </a>！</p><figure class="kr ks kt ku fd lg"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div></div>    
</body>
</html>