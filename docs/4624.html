<html>
<head>
<title>Creating Neuro-Symbolic Sudoku Solver</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建神经符号数独解算器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-neuro-symbolic-sudoku-solver-cc94c431d10b?source=collection_archive---------1-----------------------#2021-12-01">https://medium.com/analytics-vidhya/creating-neuro-symbolic-sudoku-solver-cc94c431d10b?source=collection_archive---------1-----------------------#2021-12-01</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7396137843d2bbbc5c791ec0bc31dfbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6JMir9xZnAZo14bzj9D3iw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">神经逻辑机器体系结构(参考:NLM论文)</figcaption></figure><p id="82a6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用深度学习和符号人工智能的结合来解决数独网格是一个非常奇特的想法。我们在这里使用了这样一种方法。这个模型的代码是开源的，可以在<a class="ae js" href="https://github.com/ashutosh1919/neuro-symbolic-sudoku-solver" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中获得。</p><p id="05b7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">深度学习模型在语音识别、图像分类、机器翻译等任务中取得了巨大成功。但是深度学习的一个缺点就是缺乏系统性。它不能理解解决问题的基本规则。它试图找到能逼近解的函数。</p><p id="1c23" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">如果说另一面的话，<a class="ae js" href="https://arxiv.org/abs/2008.07912" rel="noopener ugc nofollow" target="_blank">归纳逻辑编程</a>是在自然语言理解和推理中，能够自然处理符号规则的逻辑系统。它是为从例子中学习逻辑规则而开发的。它创造了一个符号模型，满足正面的例子，并反驳负面的例子。但是由于指数级的大搜索空间，ILP无法处理复杂的问题。</p><p id="8fe0" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">结合上述两种方法可以减少缺点并创建非常健壮的模型。这就是为什么它在人工智能中被称为神经符号域。我们已经使用了一种叫做<a class="ae js" href="https://arxiv.org/pdf/1904.11694.pdf" rel="noopener ugc nofollow" target="_blank">的神经逻辑机器</a>的神经符号架构来解决一个数独难题。</p><h1 id="50f1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">神经逻辑机器</h1><p id="9f70" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">NLM是逻辑机器的神经实现。给定一组基于一组对象(前提)的基本谓词，NLMs依次应用一阶规则来得出结论，例如关于对象的属性。它是一种深度强化学习架构，使用在符号张量上计算的布尔谓词。<a class="ae js" href="https://arxiv.org/pdf/1904.11694.pdf" rel="noopener ugc nofollow" target="_blank"> NLM论文</a>展示了解决基本系统问题的多种应用，如排序数组、寻找图中最短路径、解决积木世界难题等。</p><p id="02d4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有人可能认为创造一个RNN可以解决这些问题。是的，可以。但是用长度为10的数组(排序)训练的RNN不能排序长度为15的数组。这就是深度学习失败的地方。神经逻辑机器使用提升的规则，这些规则利用一阶逻辑的能力来表示系统，然后这些基于一组对象的一阶逻辑谓词可以被输入到神经网络中。</p><p id="566f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">例如，如果我们考虑一个积木世界的难题，我们可以提取一组规则来定义难题的核心系统性，如下图所示。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kw"><img src="../Images/e06ff2505338092195fa1a733b9f0240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O0ld3X6UPLYj94xqK6V-SA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图1积木世界拼图规则示例(参考:NLM论文)</figcaption></figure><p id="473b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们首先计算系统中所有对象的布尔谓词规则，然后将它们输入到NLM网络中。</p><p id="6667" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了更好地理解，作为先决条件，我们强烈建议在阅读下一节之前通读一下<a class="ae js" href="https://arxiv.org/pdf/1904.11694.pdf" rel="noopener ugc nofollow" target="_blank"> NLM论文</a>。它不仅会使主题清晰，还会引入一个与神经网络相结合的完全不同的符号域。</p><h1 id="7392" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">为数独创建布尔谓词</h1><p id="6009" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">正如规则所描述的，我们需要用没有出现在同一行、列和3x3子网格中的数字来填充数独网格中的所有空白单元格，以解决这个难题。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div class="er es lb"><img src="../Images/3bc909dab2a066c2dabbfe9d487611f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*ORxDJxnaY7exQlirrlx-WA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">图2数独拼图</figcaption></figure><p id="73d4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们可以推导出三个基本规则来解决这个难题。假设我们想将数字<strong class="iw hj"> <em class="lc"> x </em> </strong>放入单元格<strong class="iw hj"> <em class="lc"> (r，c) </em> </strong>。下面是一组规则，必须满足这些规则才能得到一个有效的数独网格。</p><ol class=""><li id="2b96" class="ld le hi iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated"><strong class="iw hj"> <em class="lc"> isRow(r，x) </em> </strong>:行<strong class="iw hj"> <em class="lc"> r </em> </strong>是否包含数字<strong class="iw hj"> <em class="lc"> x </em> </strong>？</li><li id="785f" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hj"> <em class="lc"> isColumn(c，x) </em> </strong>:列<strong class="iw hj"> <em class="lc"> c </em> </strong>是否包含数字<strong class="iw hj"> <em class="lc"> x </em> </strong>？</li><li id="fc3a" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hj"> <em class="lc"> isSubMatrix(r，c，x) </em> </strong>:以行<strong class="iw hj"> <em class="lc"> r </em> </strong>和列<strong class="iw hj"> <em class="lc"> c </em> </strong>开头的子矩阵是否包含数字<strong class="iw hj"> <em class="lc"> x </em> </strong>？</li></ol><p id="d7d7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">谓词<strong class="iw hj"> <em class="lc"> isRow(r，x) </em> </strong>和<strong class="iw hj"> <em class="lc"> isColumn(c，x) </em> </strong>是二元谓词，而<strong class="iw hj"> <em class="lc"> isSubMatrix(r，c，x) </em> </strong>是三元谓词。对于数独难题，我们没有任何一元和一元谓词。我们为数独网格的每个单元计算上述三个谓词。</p><h1 id="0bfd" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">深度强化学习和培训</h1><p id="1079" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">我们使用带有策略梯度计算的<a class="ae js" href="https://proceedings.neurips.cc/paper/1999/file/464d828b85b0bed98e80ade0a5c43b0f-Paper.pdf" rel="noopener ugc nofollow" target="_blank">增强算法</a>来训练模型。NLM需要计算上述布尔谓词作为输入。</p><p id="01e2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们使用了深度为5  和宽度为3  的NLM。NLM的输入层有4个节点(第一个输入空谓词，第二个输入一元谓词，第三个输入二元谓词，第四个输入三元谓词)。我们将<strong class="iw hj"> <em class="lc"> isRow(r，x) </em> </strong>和<strong class="iw hj"> <em class="lc"> isColumn(c，x) </em> </strong>的结果进行堆栈，作为二元谓词输入。同样，我们输入<strong class="iw hj"> <em class="lc"> isSubMatrix(r，c，x) </em> </strong>的结果作为三元谓词。对于这个问题，我们没有空谓词和一元谓词。所以，我们只为那些节点传递<em class="lc"> None </em>。</p><p id="8f04" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦我们将这些数据传递给NLM，最后一层计算softmax并执行动作来生成网格的下一个状态。这些操作是使用操作参数执行的，操作参数由空单元格的位置和要放入单元格的目标值组成。在将数字放入特定的单元格后，我们通过检查该数字是否产生有效的网格来执行操作。基于此，我们执行一个动作并返回一个奖励。我们使用的奖励方案与最初的NLM项目中使用的相同。</p><p id="470e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们已经使用了一个课程培训方案来对模型进行端到端的培训。我们首先使用较少的空单元来训练网格模型，然后逐渐增加空单元的数量。</p><p id="1470" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">同样，选择动作和执行动作步骤也不是没有限制的。它们受到有限代理步骤的限制。这意味着我们已经使用超参数作为模型可以用来解决数独网格的最大步骤数。</p><h1 id="1903" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">评估和结果</h1><p id="fc51" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">我们用不同数量的有限代理步骤训练了模型，下面是我们获得的结果。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lr"><img src="../Images/3bf3597a625a57f9c99339dc4214fcfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N5eZTM4Nu94IJ9xLQ7HTmg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图3模型评估结果</figcaption></figure><p id="dea6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">从上面的评估，我们得出结论，我们已经实现了使用NLM数独难题的可解性。</p><p id="de16" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我们构建了自己的代码，以便从训练好的模型中获得推论。下面是推断结果的样子。</p><figure class="kx ky kz la fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ls"><img src="../Images/ddedeec4cbb2d4c584449ed296949fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pwrxyz4VSjgNjk4eewgerA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图4推理结果</figcaption></figure><p id="df50" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">此外，该模型不仅仅给出一个求解的网格，它还给出求解它的步骤(轨迹),这可以导致解释。</p><h1 id="dfcc" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">未来的工作</h1><p id="6c15" class="pw-post-body-paragraph iu iv hi iw b ix kr iz ja jb ks jd je jf kt jh ji jj ku jl jm jn kv jp jq jr hb bi translated">基于我们当前工作的结果和性能，NLM模型解决了数独网格，但是它没有以最优的步骤数解决数独网格。我们计划改进和开发更健壮的谓词，帮助模型以最佳的步骤数求解网格。</p><p id="1f92" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这个模型的代码是开源的，可以在<a class="ae js" href="https://github.com/ashutosh1919/neuro-symbolic-sudoku-solver" rel="noopener ugc nofollow" target="_blank"> GitHub仓库</a>中获得。</p><h1 id="0fe6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">参考</h1><ol class=""><li id="73ef" class="ld le hi iw b ix kr jb ks jf lt jj lu jn lv jr li lj lk ll bi translated">董、毛、林、王、李、周。神经逻辑机器。2019.</li><li id="014c" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">萨顿麦卡勒斯特辛格曼苏尔。函数逼近强化学习的策略梯度方法。1999.</li><li id="1d5c" class="ld le hi iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated">王，唐蒂，怀尔德，科特。SATNet:使用可微分可满足性求解器桥接深度学习和逻辑推理。2019.</li></ol></div></div>    
</body>
</html>