<html>
<head>
<title>How to change Image background using Deeplabv3 in Tensorflow in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中使用Tensorflow中的Deeplabv3更改图像背景</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-change-image-background-using-tensorflow-in-python-62b1b2d570b9?source=collection_archive---------1-----------------------#2021-08-21">https://medium.com/analytics-vidhya/how-to-change-image-background-using-tensorflow-in-python-62b1b2d570b9?source=collection_archive---------1-----------------------#2021-08-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5bdbb875828ba77f02d7672d865f834d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rXxm_j46-xlt5r_bImqgQQ.jpeg"/></div></div></figure><p id="b6ea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">图像背景去除是图像处理中最常见的任务之一。</p><p id="1bc4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果图像背景是统一的颜色，那么opencv可以用来改变图像背景。为了从所有其他图像中去除背景，可以使用神经网络来分割图像。</p><p id="c86c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">经过语义分割训练的神经网络可以将图像的像素分类。</p><p id="a847" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我使用了来自Deeplabv3架构的预先训练的分段权重。加载模型并绘制其预测的代码如下所示:</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="7e5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行上述代码后，它将加载模型。我们可以通过运行下面的代码来查看模型的预测</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="1a67" class="jz ka hi jv b fi kb kc l kd ke">path = 'filepath of image to predict'<br/>run_visualization_local(path)</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kf"><img src="../Images/67381417ca49e44030bac15d9a085eb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*trNafK6bbmT9axGxiNCHNg.png"/></div></div></figure><p id="49f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行上述代码后，它使用神经网络为图像创建分割图。图像的每个像素被分配一个对应于检测到的类别的值。由于网络是在COCO数据集上训练的，因此person类的值等于15。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="fc1c" class="jz ka hi jv b fi kb kc l kd ke">resized_im, seg_map = run_local(path)<br/>image = np.array(resized_im)</span></pre><p id="21bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">运行上述代码将分割图和图像保存为numpy数组。神经网络要求图像的最大尺寸为513像素。因此分割图和调整尺寸_im具有513像素的最大尺寸。接下来，我们加载背景图像。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="4d53" class="jz ka hi jv b fi kb kc l kd ke">background = 'rainbow.jpeg'<br/>bg_image = Image.open(background)<br/>INPUT_SIZE = 513<br/>width, height = bg_image.size<br/>resize_ratio = 1.0 * INPUT_SIZE / max(width, height)<br/>target_size = (int(resize_ratio * width), int(resize_ratio * height))<br/>bg = bg_image.convert('RGB').resize(target_size, Image.ANTIALIAS)<br/>bgimage = np.array(bg)</span></pre><p id="baf7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我已经调整了背景图像的大小，使其最大尺寸为513像素，并且在调整大小时图像的纵横比保持不变。</p><p id="82ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，使用分段图对于人类别具有值15的事实。我用没有检测到人物类别的背景图像替换预测图像。</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="896d" class="jz ka hi jv b fi kb kc l kd ke">merged = np.zeros(image.shape)<br/>if image.shape[0]&gt;bgimage.shape[0]:<br/>    bgimage = np.pad(bgimage,((image.shape[0]-bgimage.shape[0],0),    <br/>                     (0,0),(0,0)))<br/>merged[:,:,0] = np.where(seg_map==15, image[:,:,0], <br/>                  bgimage[:image.shape[0],:image.shape[1]][:,:,0])<br/>merged[:,:,1] = np.where(seg_map==15, image[:,:,1],<br/>                  bgimage[:image.shape[0],:image.shape[1]][:,:,1])<br/>merged[:,:,2] = np.where(seg_map==15, image[:,:,2], <br/>                  bgimage[:image.shape[0],:image.shape[1]][:,:,2])</span></pre><p id="3596" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果调整大小后的背景图像小于预测图像，则它会对背景图像进行零填充，使其与预测图像具有相同的尺寸。然而，如果调整后的背景图像大于预测图像，则将其裁剪为相同的大小。</p><p id="17ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用下面的代码可以看到最终的图像</p><pre class="jo jp jq jr fd ju jv jw jx aw jy bi"><span id="d21b" class="jz ka hi jv b fi kb kc l kd ke">final = Image.fromarray(merged.astype(np.uint8))<br/>final</span></pre><figure class="jo jp jq jr fd ij er es paragraph-image"><div class="er es kg"><img src="../Images/049479056989ea28c530022419360b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*XTPLUrDyr55a69-sBqCYnw.jpeg"/></div></figure></div></div>    
</body>
</html>