<html>
<head>
<title>Game of Tic-Tac-Toe with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python玩井字游戏</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/game-of-tic-tac-toe-with-python-913e25667e4c?source=collection_archive---------7-----------------------#2021-03-28">https://medium.com/analytics-vidhya/game-of-tic-tac-toe-with-python-913e25667e4c?source=collection_archive---------7-----------------------#2021-03-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6d27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">井字游戏。一个我们都熟悉的游戏，也是一个非常简单的游戏。但是用Python创建井字游戏有多难呢？嗯！这很简单。可以使用基本的python编程语言创建井字游戏。这里，在这篇文章中，我将演练用python创建你自己的井字游戏的步骤。</p><p id="129f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">源代码:<a class="ae jc" href="https://github.com/pujesh/TicTacToe" rel="noopener ugc nofollow" target="_blank">https://github.com/pujesh/TicTacToe</a></p><p id="f9d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，让我向您展示我的文件结构。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/8b39717f4aec4a20001772fe883bee6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*HUXg2-iPPN2AF5V346Ea2Q.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:文件夹结构</figcaption></figure><p id="f6e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们的主项目是TicTacToe，在src目录下，我创建了4个模块。我们的程序从main.py开始，它让玩家在X和O之间选择，并显示初始棋盘。然后从interact.py模块调用<strong class="ig hi"> user_interact() </strong>函数。互动模块用于与玩家互动，并获取每一步棋在棋盘中的位置。这是大部分工作发生的地方。每次用户输入更新后的电路板时，该模块都会打印出来，并通过check.py模块中的<strong class="ig hi"> check_position() </strong>函数检查所提供的位置是否可用。通过调用<strong class="ig hi"> update_board() </strong>更新板卡，并通过调用board.py模块中的<strong class="ig hi"> display_board() </strong>函数显示更新后的板卡。在用户第四次输入后，程序通过从检查模块调用<strong class="ig hi"> check_result() </strong>函数开始检查可能的赢。如果check_result函数找到一个赢家，它会宣布一个赢家，并通过跨越所有三个位置来显示棋盘。电路板上的十字标记通过电路板模块的<strong class="ig hi"> cross_board() </strong>函数执行。</p><p id="c7ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这只是对整个程序如何运行的概述。让我们从main.py开始，深入了解每个模块的更多细节。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jp"><img src="../Images/fa1ddfeaf43768c5ea553ed40b67b9d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NM0RIceRyWZFxpyCqioHwA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:main.py</figcaption></figure><p id="c9de" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> main.py: </strong></p><p id="65f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主模块是我们程序的起点，我们从欢迎玩家开始，并让玩家1选择X或o。一旦用户提供了选项，它就会显示初始棋盘并调用user_interact()函数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ju"><img src="../Images/08c7ccb7d603c6c371610583d2f8f1fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*OdD1n5Rxui-0LKm1XL3FYQ.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:main.py输出</figcaption></figure><p id="ad0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上图是从main.py模块获得的输出。图中突出显示的部分显示了程序要求用户输入的步骤。一旦用户提供“X ”,程序就会显示井字游戏棋盘。我们可以看到有两块展板正在展示。这是因为，左边的板显示可供用户选择的位置，一旦用户在板上输入位置，右边的板就会显示。现在让我们看看user_interact()函数在被主模块调用后做了什么。</p><p id="fd19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> interact.py </strong></p><p id="b0f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个interact.py只包含一个函数(user_interact())，我将分两部分来描述它。<br/>第一部分:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jv"><img src="../Images/f6a99d5ecc9f1ccacfd321d5679894e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KOct0qZFRl9xdfhTWZAqyQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:interact.py (a)</figcaption></figure><p id="f709" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一部分只包含导入和初始化语句。在这里，我们初始化了一个位置板(pos_board ),玩家可以在其中查看板和游戏板(game_board)中的可用位置，其中所有字段最初都是空白的。然后，根据玩家1所做的选择，给每个玩家分配一个符号“X”或“O”。我们也给游戏赋值False，这表示程序需要循环直到游戏结束。变量turn表示循环执行的圈数/次数。<br/>第二部分:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jw"><img src="../Images/2adbd62ca31bde0b9374fda59dddbfb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_FZ1sNN5DV5GMLbXqTt1Q.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:interact.py (b)</figcaption></figure><p id="692c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，主要逻辑从本模块的第二部分开始。我们知道只有两个玩家，游戏在9步中结束，因此，我们将运行一个循环，直到它循环9次或当游戏找到一个赢家。每次，它都要求玩家在位置板上选择一个可用的位置。玩家可以通过选择1到9之间的一个数字和位置板上的一个数字来选择位置。如果号码超出范围或者是一个字母，或者如果玩家选择了一个位置牌上没有列出的号码，我们会要求玩家重新输入该号码。这是通过check_position()函数完成的。例如:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jx"><img src="../Images/a23d9aceab0a7b9090a68300995dce11.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*B-ozAcZ1jn43iqt7bTc0dA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:1号玩家选择了位置6</figcaption></figure><p id="09a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们可以看到玩家1选择了位置6，它在范围之下，在位置板上可用。因此，程序接受输入并打印出更新的电路板。它从位置棋盘(左边的棋盘)上删除位置，并在游戏棋盘(右边的棋盘)上插入一个“X”标记。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es jy"><img src="../Images/5c93bcde5ca1e33a4b86c3498ed9998b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsNJUN5i84bvRdLPKcueIw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图2:玩家2选择了错误的位置</figcaption></figure><p id="53fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，当玩家2试图选择玩家1选择的位置6时，程序通知用户该位置已经有人了。在第二次尝试时，玩家2试图选择位置表中不存在的数字10，类似地，当玩家2试图选择一个字母时，游戏重复地要求一个有效的位置，并且直到得到一个位置才前进。<br/>每次输入后，程序用“X”或“O”标记更新位置/游戏棋盘，并显示更新后棋盘的输出。<br/>因为，我们知道游戏只能在第四回合或之后找到赢家，这是我们在变量“回合”大于或等于4之后开始检查赢家的时候。我们通过调用check_result()函数来实现这一点。当满足获胜标准时，该函数返回一个真值和一个划掉了行/列/对角线的游戏棋盘。当游戏有赢家时，它显示棋盘，并通过将变量“game”更新为True来结束循环。如果未达到获胜标准，游戏将继续进行，直到以平局结束。<br/>这是交互模块的整体流程。它进入一个循环，直到游戏找到一个赢家或以平局结束。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jz"><img src="../Images/a2b65c99d162b93c3b0c6de432489488.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*cA3USNakQtD80-PqoK1tMA.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:比赛以胜利者结束</figcaption></figure><p id="ae92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上图中，我们可以看到玩家1已经赢得了比赛，位置3，6，9被划掉。在draw的情况下，我们可以看到以下方式的输出:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ka"><img src="../Images/9d3f41748c6b6fbcab1eefc7f827c036.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*DjGvo8iBCKfFlCt_iKE7vg.png"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:比赛以平局结束</figcaption></figure><p id="d9d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> check.py </strong></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kb"><img src="../Images/1e324ed044e205d1d505c7cedd39a51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZLdkRNeouOLVeZOzjYtDg.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:check.py</figcaption></figure><p id="6500" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，这里我们有check.py模块，它主要用于检查可用位置和结果。我们可以看到，每当玩家进入一个位置时，check_position()函数都会被调用。这确保了玩家提供的位置是有效的和可用的。如果该位置可用，则该函数返回True，否则该函数返回False。</p><p id="525e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模块中定义的另一个函数是check_result()函数。该功能用于在玩家选择位置后检查游戏是赢还是平。因为，游戏只有在第4次运行后才能拥有，我们还增加了在转数大于4后检查的功能。您可以在上面的interact.py模块中看到这一点(图:interact.py (b)，第35 &amp; 36行)。<br/>我们已经定义了一个名为“移动”的元组，它包含了棋盘上赢得游戏的所有可能的位置组合。然后，我们运行一个循环，检查棋盘上任何有提到的移动的位置是否有相同的符号(“X”或“O”)。如果我们在任何一步中发现任何位置都有相同的符号，我们就宣布游戏获胜，否则游戏继续进行，直到所有的位置都被填满，游戏以平局结束。</p><p id="2707" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> board.py </strong></p><p id="99c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们必须创建的最后一个模块是board.py模块。该模块处理显示、更新和划掉板上的位置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kc"><img src="../Images/f88f7d353d73aac11d66498b0cbc1e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVInysAwHtewxYiCwo2K-Q.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:board.py (a)</figcaption></figure><p id="2971" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，我们有两个函数— display_board()和update_board()。顾名思义，函数display_board()显示电路板。该函数接受两个参数— pos_board(位置板—显示板中的可用位置)和game_board(游戏板—显示X和O的位置)。每次展示棋盘时，都有两个棋盘在展示，就像我们在上面看到的那样。一个显示棋盘上的可用位置(位置棋盘)，而另一个(游戏棋盘)显示玩家已经占据的位置。我们得到的参数pos_board，game_board总是在每回合后更新。这些板是通过update_board()函数更新的。<br/>update _ board()函数带四个参数——pos _ board、game_board、n(要更新的位置)和mark(第n个位置要填充的标记‘X’或‘O’)。一旦该函数被调用，它就开始在位置板内循环，并在第n个位置值与位置板中的位置号匹配时删除该位置号。在这里，因为我们已经不同地实现了位置板和游戏板，所以游戏板通过一行代码更新了标记(图:board.py (a)，第21行)。<br/> <strong class="ig hi">注:</strong>我们可以看到我们定义的game_board的方式更容易实现。我们也可以对pos_board这样做，去掉多余的代码行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kd"><img src="../Images/67d21871bcaf69e640aef34192eef3ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K3nVBctqsFIpEhHR4nE1bQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:board.py (b)</figcaption></figure><p id="f81d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">board.py模块的另一部分由cross_board函数组成。一旦我们确认游戏已经结束并且其中一个玩家赢了(当我们从check.py模块中的check_result()函数获得True值时)，我们就调用这个函数来划掉赢得游戏的位置。我们使用“-”、“|”、“/”和“\”符号根据移动来划掉位置。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es ke"><img src="../Images/aa81d4d61a6ca222e40b05f24e96d80c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tlvmUwPsOhESZvNt8_ZPjQ.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图:1、2、3位用“-”号划掉，表示比赛获胜。</figcaption></figure><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jq jr di js bf jt"><div class="er es kf"><img src="../Images/980b83ca89b04b374e6c41202fbd117f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*chVuORGsvOd57-j9r8LCjA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图5:另一个游戏获胜的例子，位置1，5和9用“O”标记填充，但用“\”标记划掉。</figcaption></figure><p id="a28e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，这总结了python编程创建井字游戏。有不同的方法可以用来实现这个目标。我希望你能尝试一下你的方法，让我知道我是否能做得更好。这都是关于优化我们的代码和冗余。希望你喜欢我关于用python玩井字游戏的帖子。</p><p id="5a1c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Dhanyabaad！！</strong>🙏🏼</p></div></div>    
</body>
</html>