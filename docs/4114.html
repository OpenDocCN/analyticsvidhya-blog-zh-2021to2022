<html>
<head>
<title>Transform a PyTorch model to onnx</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将PyTorch模型转换为onnx</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/transform-a-pytorch-model-to-onnx-90e581258997?source=collection_archive---------4-----------------------#2021-08-28">https://medium.com/analytics-vidhya/transform-a-pytorch-model-to-onnx-90e581258997?source=collection_archive---------4-----------------------#2021-08-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d94a7fe44aa03d50f2e0021e80c52907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RmbN2a7cJwv9D0H6"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">安迪·布鲁纳在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="b32f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本教程中，我想展示如何轻松地将PyTorch模型转换为onnx格式。但首先，你为什么要这么做？根据我的经验，有几个原因可能会对您有用:</p><ul class=""><li id="f32b" class="js jt hh iw b ix iy jb jc jf ju jj jv jn jw jr jx jy jz ka bi translated">你的发展区域和你的生产区域是不同的。以我的经验来看，往往是这样。当我们有大量数据要进行批量推断时，首先将数据从一个源转移到python服务器，在那里进行推断，然后再将数据放回去，这通常不是最好的主意。onnx可以让你直接使用你的深度学习模型，这是一个巨大的好处。</li><li id="a048" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">onnx通过他们的API在Java上运行，这意味着你可以用Python训练你的模型，但是要在Java上部署它。这有很大的不同，因为您可以直接在集群中部署您的模型。</li><li id="49b6" class="js jt hh iw b ix kb jb kc jf kd jj ke jn kf jr jx jy jz ka bi translated">onnx支持所有流行的深度学习框架，如PyTorch、TensorFlow或Caffe(以及更多)。这意味着在团队中，一些人觉得使用TensorFlow更舒服，而另一些人觉得使用PyTorch更舒服，部署过程仍然可以是相同的。</li></ul><p id="9ba6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在<a class="ae it" rel="noopener" href="/analytics-vidhya/time-series-classification-with-convolutions-ed5cb33b1e3b">之前的教程</a>中，我已经向你展示了卷积神经网络在时间序列方面的强大。我使用意大利电力需求数据集做了一个分类任务，这是为了区分哪一天来自。为了向您展示如何部署您的模型，我将用PyTorch在CPU上训练这个模型，并向您展示如何将它保存为onnx模型。onnx的工作方式是，它首先需要一个示例数据点(张量)的“样本”,我们曾经用它来做推理部分。因此，让我们首先加载数据，只取我们想要进行预测的第一个示例。</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="kk kl l"/></div></figure><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es km"><img src="../Images/40b8f2ea7048ba2bf11f782aa107bc2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*RRJvateszD3GLN0wkK9P0w.png"/></div></figure><p id="f1ee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">提醒一下，这个numpy数组表示24小时内的用电量，我们试图预测这一天是从10月到3月(含)，还是从4月到9月。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kn"><img src="../Images/87295c0c65498abfe79995a66b393cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ROMDSLaskMAM87DXTsGFDw.png"/></div></div></figure><p id="e72a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在将这个numpy数组转换成PyTorch张量。在建立我们的模型时，我们唯一需要记住的是张量必须遵循一定的形状。现在这个形状看起来像这样:</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/5ee3908c8df92a770f9cc84825a1e30d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qAZMDU6LhKjM4M27xUINKw.png"/></div></div></figure><p id="6137" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，模型期望的形状是这样的:[批量大小，变量个数，观察个数]。在我们的例子中，我们希望batch_size为1，我们只有1个变量需要预测(功耗),我们有24个观察值，每小时一个。此外，在这种情况下，我们需要使张量类型为float，因为在训练模型时，我们使用float类型作为输入。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/a32f61b6efbb6768dce6b0f49beeb1a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b7YwvDSkMnTmxoUCs_zFJA.png"/></div></div></figure><p id="6fd6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们需要重新加载我们的模型。保存模型的最佳实践是只保存state_dict()。然而，这意味着当重新分配模型时，如果您愿意，我们首先需要定义模型的“骨架”，然后它将由保存的state_dict()中相应的权重和偏差进行更新。同样，如果你还没有读过如何建立模型的教程，我强烈推荐你再读一遍。</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="86ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">记住，我们只有一个变量来预测两个类中的一个(0或1)。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/8aa9026e4f13fc5b6d75f6318b5e7c17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0oR1-uwFhoE6fvb5KaScXg.png"/></div></div></figure><p id="0bc2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经快完成了。最后缺少的是推理部分。为此，我们首先必须将模式置于评估模式(否则它也会将目标变量作为模型的输入)，并且为了更快的推断，我们还会告诉模型不要每次都计算梯度。</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/d77c02a49918ab969854dda79a854b1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvpcwXelfN-4WgH05kt_gQ.png"/></div></div></figure><p id="613a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们准备将我们的模型保存为onnx模型。请记住，对输出所做的任何更改(例如应用sigmoid函数)都不会保存在onnx模型中。然后需要在应用模型的地方进行后续操作，例如，在Java设置中使用模型时，需要使用sigmoid的Java功能。</p><figure class="kg kh ki kj fd ii"><div class="bz dy l di"><div class="kk kl l"/></div></figure><p id="4c38" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！我们现在已经用onnx保存了我们的模型，可以直接部署到其他框架上。在下一篇教程中，我想向您展示如何使用这个onnx模型，并让它在Java上运行。</p><p id="4d94" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">拉塞</p><p id="5d1e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="kr">原载于2021年8月28日</em><a class="ae it" href="https://lschmiddey.github.io/fastpages_/2021/04/10/DeepLearning_TabularDataAugmentation.html" rel="noopener ugc nofollow" target="_blank"><em class="kr">https://lschmiddey . github . io</em></a><em class="kr">。<br/> Git回购:</em><a class="ae it" href="https://github.com/lschmiddey/pytorch_to_onnx" rel="noopener ugc nofollow" target="_blank">https://github.com/lschmiddey/pytorch_to_onnx</a></p></div></div>    
</body>
</html>