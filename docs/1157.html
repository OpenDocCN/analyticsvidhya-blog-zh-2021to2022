<html>
<head>
<title>Android Services: A Tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Android服务:教程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/android-services-a-tutorial-a4fb8b5ae7d7?source=collection_archive---------24-----------------------#2021-02-16">https://medium.com/analytics-vidhya/android-services-a-tutorial-a4fb8b5ae7d7?source=collection_archive---------24-----------------------#2021-02-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="f491" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是服务</h1><p id="89ab" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">服务就是正在运行的</em> </strong>代码，而这个代码，没有GUI。除非代码创建了一个可运行的线程，或者在一个单独的进程中运行，否则代码在它的应用程序(宿主进程)的主线程上运行。</p><p id="f3df" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">代码可以显示一个通知，表明它正在运行，在这种情况下，它是<strong class="je hi"> <em class="ka">前台代码</em> </strong>。当使用麦克风或摄像机时，必须显示通知。</p><p id="e11f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">代码可以不显示它正在运行的指示，在这种情况下，它是<strong class="je hi"> <em class="ka">后台代码</em> </strong>，例如清空应用程序的缓存文件夹。</p><p id="d958" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">代码可以被交互，例如发送特定的请求，或者接收给定的结果。在这种情况下，代码是可用的，只要与它交互的代码是可用的。这是<strong class="je hi"> <em class="ka">绑定码</em> </strong>。</p><p id="115d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">代码可以</em> </strong> <em class="ka">被</em>绑定，并且显示通知，或者显示不通知，或者一个代码可以被解除绑定，并且显示通知，或者显示不通知。</p><p id="6d24" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个服务，所以可以绑定的代码，或未绑定的，或显示的，或不显示通知的，<strong class="je hi"> <em class="ka">使用</em></strong><em class="ka"/><code class="du kg kh ki kj b">Service</code>类创建，并使用<code class="du kg kh ki kj b">Intent</code>启动。</p><h1 id="b14c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">服务寿命和生命周期</h1><p id="1ce9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个类的实例的代码有<strong class="je hi"> <em class="ka">一个生命期</em> </strong>，这是该实例存在的周期。所以一役也，有一生。</p><p id="d0f4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个生命周期<strong class="je hi"> <em class="ka">有一个周期</em> </strong>，这个周期就是实例第一次被创建，最后一次被销毁，以及两者之间发生的事情。</p><p id="1144" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">来自<a class="ae kk" href="https://developer.android.com/guide/components/services.html" rel="noopener ugc nofollow" target="_blank"> android开发者</a>的服务生命周期如下</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><figure class="kl km kn ko fd kp er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/c2238ed78e2e71b3073104afb07c7355.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*KT9fXIxtzQHFP-eNxKi2sA.png"/></div></div></figure><p id="49e0" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">例如，当<code class="du kg kh ki kj b">startService</code>被调用时，<code class="du kg kh ki kj b">onStartCommand</code>中指定的代码将被执行，它可以用来显示一个通知，所以服务将是一个<strong class="je hi"> <em class="ka">前台服务</em> </strong>，或者没有通知，所以服务将是一个<strong class="je hi"> <em class="ka">后台服务</em> </strong>。</p><p id="0edb" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">之后，可以调用<code class="du kg kh ki kj b">bindService</code>。将执行<code class="du kg kh ki kj b">onBindService</code>中指定的代码。它必须返回一个接口，该接口允许与代码进行通信。代码被绑定到客户端的生命周期，因此这被称为<strong class="je hi"> <em class="ka">绑定服务</em> </strong> <em class="ka"> </em>。</p><h1 id="2bc4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">生存期标志</h1><p id="7dcd" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个<code class="du kg kh ki kj b">Service</code>的实例，可以设置一些标志。这些<strong class="je hi"> <em class="ka">标志控制<code class="du kg kh ki kj b">Service</code>实例的</em> </strong>生存期。</p><p id="1890" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">这些标志仅适用于通过调用<code class="du kg kh ki kj b">startService </code>启动的服务。当所有绑定的客户端都解除绑定时，只调用了<code class="du kg kh ki kj b">bindService() </code>方法的服务被销毁。</p><p id="b32f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b"><strong class="je hi"><em class="ka">START_STICKY</em></strong></code> <em class="ka">标志</em>声明，当<code class="du kg kh ki kj b">Service</code>的一个实例被销毁时，例如在低内存上，该服务的另一个实例将被创建，这样<code class="du kg kh ki kj b">onCreate</code>和<code class="du kg kh ki kj b">onStartCommand</code>将被调用。正在执行的代码从零开始重新启动，不保留任何状态。最初的<code class="du kg kh ki kj b">Intent</code>启动了<code class="du kg kh ki kj b">Service</code>的第一个实例，没有被重新传递给<code class="du kg kh ki kj b">onStartCommand</code>，因此为空。</p><p id="cd01" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b"><strong class="je hi"><em class="ka">START_REDELIVER_INTENT</em></strong></code> <em class="ka">标志</em>规定，当一个<code class="du kg kh ki kj b">Service</code>的实例被销毁时，所发生的是<code class="du kg kh ki kj b">Service</code>的另一个实例被创建。正在执行的代码从零开始重新启动，执行<code class="du kg kh ki kj b">onCreate</code>和<code class="du kg kh ki kj b">onStartCommand</code>功能，在这种情况下，<code class="du kg kh ki kj b">onStartCommand </code>将接收服务的初始<code class="du kg kh ki kj b">Intent</code>，它启动了较早的实例。</p><p id="e52b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b"><strong class="je hi"><em class="ka">START_NOT_STICKY</em></strong></code> <em class="ka">标志</em>表示，当<code class="du kg kh ki kj b">Service</code>的实例被销毁时，它不会被重新创建，因此必须手动重新创建。</p><p id="d781" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">显示通知 的<strong class="je hi"> <em class="ka">服务与在前台运行的应用程序具有相同的优先级，因此它不太可能因内存不足而被终止，但需要记住的重要一点是，这并不重要。</em></strong></p><h1 id="f320" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">注册服务</h1><p id="575f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">服务<strong class="je hi"> <em class="ka">必须在应用程序的清单中声明</em> </strong>，方法是将<code class="du kg kh ki kj b">service</code>元素作为子元素添加到<code class="du kg kh ki kj b">application</code>元素中。</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="82e6" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果服务是前台服务，那么<code class="du kg kh ki kj b"><strong class="je hi"><em class="ka">uses-permission</em></strong></code>前台服务，必须在manifest中指定。</p><p id="fa51" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">同样，如果服务是前台服务，那么使用<code class="du kg kh ki kj b">foregroundServiceType</code>，它必须<strong class="je hi"> <em class="ka">声明它的类型</em> </strong>，可以是一个或多个，例如<code class="du kg kh ki kj b">camera</code>或<code class="du kg kh ki kj b">camera | microphone</code></p><p id="c138" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">唯一必需的属性，是<strong class="je hi"><em class="ka"/></strong><code class="du kg kh ki kj b"><strong class="je hi"><em class="ka">name</em></strong></code><strong class="je hi"><em class="ka">属性</em> </strong>，它指定了实现服务的类的名称。类名可以是完全限定的，通过指定这个类所属的包，或者它可以以点<code class="du kg kh ki kj b">.</code>开始，在这种情况下，它属于清单中指定的包。</p><p id="3c52" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个服务可以运行在一个不同的进程上，然后默认为应用程序创建的进程，通过使用<strong class="je hi"><em class="ka"/></strong><strong class="je hi"><em class="ka">属性</em> </strong>。如果process属性中的字符串名称以冒号<code class="du kg kh ki kj b">:</code>开头，那么服务将在一个新创建的进程中运行，该进程专用于它的应用程序。如果字符串名称以小写字母开头，则服务将在全局进程中运行，并具有指定的名称。</p><h1 id="a8db" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">启动和停止服务</h1><p id="8f87" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个服务<strong class="je hi"> <em class="ka">可以通过调用</em> </strong> <code class="du kg kh ki kj b">startService</code>启动，一个服务通过调用<code class="du kg kh ki kj b">startService</code>启动，被称为一个<strong class="je hi"> <em class="ka">启动的服务</em> </strong>。</p><pre class="kl km kn ko fd kz kj la lb aw lc bi"><span id="59d1" class="ld if hh kj b fi le lf l lg lh">Intent intent = new Intent (this , Service_ClassName.class );<br/>startService (intent );</span></pre><p id="fc93" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">数据可以添加</em> </strong>到一个意向中，像指定一些选项一样，给服务。</p><pre class="kl km kn ko fd kz kj la lb aw lc bi"><span id="b49f" class="ld if hh kj b fi le lf l lg lh">Intent intent = new Intent (this , Service_ClassName.class );<br/>intent .putExtra ("do" , "what" );<br/>intent .putExtra ("what-arg" , 0.5 );<br/>startService (intent );</span></pre><p id="5c4b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b">startService</code>法，可多次称为<strong class="je hi"><em class="ka"/></strong>，同样的<code class="du kg kh ki kj b">onStartCommand</code>，也可多次称为。</p><p id="3467" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">使用<code class="du kg kh ki kj b">startService</code>方法启动的服务，<strong class="je hi"> <em class="ka">可以使用</em></strong><code class="du kg kh ki kj b">stopService</code>方法停止。</p><pre class="kl km kn ko fd kz kj la lb aw lc bi"><span id="6fc7" class="ld if hh kj b fi le lf l lg lh">Intent intent = new Intent (this , Service_ClassName.class );<br/>stopService (intent );</span></pre><p id="5fd9" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">它<strong class="je hi"> <em class="ka">也可以自行停止</em> </strong>，使用:<code class="du kg kh ki kj b">stopSelf (int startId )</code>。<code class="du kg kh ki kj b">stopSelf</code>中的<code class="du kg kh ki kj b">startId</code>，是从<code class="du kg kh ki kj b">onStartCommand </code>接收的。如果发出了新的<code class="du kg kh ki kj b">startService</code>调用，它用于防止服务自行停止，但是如果使用了最近的<code class="du kg kh ki kj b">startId</code>，那么服务将自行停止，而不考虑任何先前的<code class="du kg kh ki kj b">startService</code>调用。</p><p id="8b66" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">已启动的服务可以显示其正在运行的通知，并且<strong class="je hi"> <em class="ka">通过使用<code class="du kg kh ki kj b">startForeground</code>方法将其自身提升为前台</em> </strong>服务，该方法将用户定义的通知id和实际通知作为参数显示给用户。</p><pre class="kl km kn ko fd kz kj la lb aw lc bi"><span id="106e" class="ld if hh kj b fi le lf l lg lh">startForeground (int id,  Notification notification)</span></pre><p id="58dc" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">要<strong class="je hi"> <em class="ka">将前台服务</em> </strong>降级，恢复为后台服务，可以调用<code class="du kg kh ki kj b">stopForeground</code>方法。这不会停止服务的运行。也可以向<code class="du kg kh ki kj b">stopForeground</code>方法传递<code class="du kg kh ki kj b">boolean</code> true，以移除任何显示的通知。现在该服务被降级为后台服务，可以使用<code class="du kg kh ki kj b">stopSelf</code>或<code class="du kg kh ki kj b">stopService</code>如前所述停止它。</p><p id="e03f" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">服务可以通过调用<code class="du kg kh ki kj b">bindService</code>方法来启动</em> </strong>，该方法有如下签名:</p><pre class="kl km kn ko fd kz kj la lb aw lc bi"><span id="a9c4" class="ld if hh kj b fi le lf l lg lh">public abstract boolean bindService (Intent intent, <br/>                ServiceConnection events, <br/>                int options)</span></pre><p id="b080" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">意图仅仅是<strong class="je hi"> <em class="ka">一个常规意图</em> </strong>来启动一个服务，如前所示。</p><p id="b96d" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">事件，只是一个接口的实例，它必须响应<strong class="je hi"> <em class="ka">不同的绑定事件</em> </strong>，例如发生<code class="du kg kh ki kj b">onBindingDied</code>，或者<code class="du kg kh ki kj b">onServiceConnected</code>，或者<code class="du kg kh ki kj b">onServiceDisconnected</code>。</p><p id="c245" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">options只是对<strong class="je hi"> <em class="ka">控制绑定过程的选项</em> </strong>，例如flag <code class="du kg kh ki kj b">BIND_AUTO_CREATE</code>，会自动创建服务。</p><p id="dce4" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果服务类存在，并且允许客户端绑定到它，则<code class="du kg kh ki kj b">bindService</code> <strong class="je hi"> <em class="ka">方法返回</em> </strong> true，否则返回false。</p><p id="8242" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">当执行绑定时，调用<code class="du kg kh ki kj b">onBind</code>方法，它必须返回一个<code class="du kg kh ki kj b">IBinder</code>接口的实例。<strong class="je hi"> <em class="ka">绑定更多的是与</em> </strong>进程间的通信相关，所以不同进程之间可以进行通信，但是可以在所有情况下使用。binder类实现了允许执行进程间通信的方法，我们可以扩展它，以提供我们自己的方法，作为对客户端的服务。</p><p id="13ec" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">一个绑定的服务，<strong class="je hi"> <em class="ka">可以解除绑定</em> </strong>，使用<code class="du kg kh ki kj b">unbindService</code>方法停止。</p><p id="ff74" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">只调用了其bindService方法的服务，<strong class="je hi"> <em class="ka">会自动销毁</em> </strong>，当所有绑定的客户端解除绑定后，调用<code class="du kg kh ki kj b">onUnbind</code>方法。</p><p id="f69b" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">如果已经使用<code class="du kg kh ki kj b">startService</code>方法、<strong class="je hi">方法、<em class="ka">方法启动了一个服务，并且还使用<code class="du kg kh ki kj b">bindService</code>方法启动了</em>方法和</strong>方法，那么调用<code class="du kg kh ki kj b">stopService</code>或<code class="du kg kh ki kj b">stopSelf</code>方法将不会销毁该服务，直到所有绑定的客户端都已解除绑定，反之亦然，当所有客户端都已解除绑定，但未调用<code class="du kg kh ki kj b">stopSelf</code>或<code class="du kg kh ki kj b">stopService</code>方法时，该服务将不会被销毁。</p><h1 id="a2b3" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">从服务中获取结果</h1><p id="028b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个服务使用<code class="du kg kh ki kj b">startService</code>方法开始，<strong class="je hi"> <em class="ka">可以使用</em> </strong>例子一个祝酒词，或者一个通知，或者一个广播…来提供或显示一些结果。它也可以被绑定，以便在必要时检索结果。</p><h1 id="b182" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">演示应用程序</h1><p id="d5fa" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">这个应用<strong class="je hi"> <em class="ka">说明了</em> </strong>的所有要点，前面讲过。它有三个服务，一个用于清除缓存目录的内容，第二个用于录制音频，第三个用于与一些代码进行交互，所以只是为了计算<code class="du kg kh ki kj b">n</code>数字的加法，以及停止一个已经开始的录制会话。</p><p id="7eac" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">服务源代码</em> </strong> <em class="ka"> </em>如下:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="922a" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">主要活动</em> </strong>源代码如下:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="e835" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">而<strong class="je hi"> <em class="ka">清单源代码</em> </strong>如下:</p><figure class="kl km kn ko fd kp"><div class="bz dy l di"><div class="kq kr l"/></div></figure><h1 id="6beb" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">IntentService</h1><p id="e45f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka"> IntentService，是</em> </strong>一个服务，是<code class="du kg kh ki kj b">IntentService</code>类的一个实例。<code class="du kg kh ki kj b">IntentService</code>类是<code class="du kg kh ki kj b">Service</code>类的子类。</p><p id="3b12" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b">IntentService</code>类<em class="ka">，</em> <strong class="je hi"> <em class="ka">使用单个工作线程</em> </strong>，当调用<code class="du kg kh ki kj b">startService</code>时，不执行自己的线程。该线程不同于应用程序主线程。</p><p id="b895" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated">在这个新创建的线程上，对<code class="du kg kh ki kj b">startService</code>的调用被依次处理，一个接一个，并且当不再有<strong class="je hi"> <em class="ka">工作要做时<code class="du kg kh ki kj b">IntentService</code>自动停止。</em></strong></p><p id="f506" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><code class="du kg kh ki kj b">IntentService</code> <strong class="je hi"> <em class="ka">已弃用</em> </strong> <em class="ka">，必须改用</em><code class="du kg kh ki kj b">JobIntentService</code>。</p></div><div class="ab cl li lj go lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ha hb hc hd he"><p id="2cea" class="pw-post-body-paragraph jc jd hh je b jf kb jh ji jj kc jl jm jn kd jp jq jr ke jt ju jv kf jx jy jz ha bi translated"><em class="ka">原载于2021年2月16日</em><a class="ae kk" href="https://twiserandom.com/android/android-services-a-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="ka">https://twiserandom.com</em></a><em class="ka">。</em></p></div></div>    
</body>
</html>