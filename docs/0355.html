<html>
<head>
<title>Probability and Simulation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">概率与模拟</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/probability-and-simulation-cd8704896e8e?source=collection_archive---------12-----------------------#2021-01-13">https://medium.com/analytics-vidhya/probability-and-simulation-cd8704896e8e?source=collection_archive---------12-----------------------#2021-01-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3902" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">使用Python计算一手扑克的概率</h2></div><p id="1379" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本文给出了一个简单的程序，演示了如何使用Python计算概率。该代码模拟一组5张牌，然后计算两手牌的概率:</p><ul class=""><li id="aa75" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iy hi">四张一类的牌</strong>，一手牌包含四张一种等级的牌和一张另一种等级的牌，如j♣j♠jj♥9♥(“四张一类，j”)。</li><li id="9187" class="js jt hh iy b iz kb jc kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iy hi">满堂彩</strong>，一手牌包含三张一种级别的牌和两张另一种级别的牌，如3♣3♠36♣6♥(一张“满堂彩”，三张全是六)。</li></ul><h2 id="c29f" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">1.生成副牌和手牌</h2><p id="efd7" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">最初，我们需要生成一副由52张牌组成的完整牌组，以及一个生成5手牌组的方法。我们可以通过创建一个将每个名字和所有排名结合起来的列表(笛卡尔积)来做到这一点。然后，我们使用Python函数从整副牌中随机生成一手牌，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="c97f" class="kg kh hh ll b fi lp lq l lr ls">from random import sample</span><span id="6208" class="kg kh hh ll b fi lt lq l lr ls">NAMES = ['Spade','Club', 'Heart', 'Diamond']<br/>names = ['S','C','H','D']<br/>ranks = ['K','Q','J', '1','2','3','4','5','6','7','8','9','10']</span><span id="986a" class="kg kh hh ll b fi lt lq l lr ls">Full_Deck = [k+c for k in names for c in ranks] <br/> <br/>def Generate_Hands(num_hands = 3):    <br/>    """ generate a set of 5-card hands ['CJ','SJ','D3','DK','H9']"""<br/>    for i in range (num_hands):<br/>        hand = sample(Full_Deck, 5)     # generate random hand<br/>        yield (hand)</span></pre><p id="00e3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">“生成器”功能<strong class="iy hi"> <em class="lu"> Generate_Hands </em> </strong>从<em class="lu">整副牌</em>中随机抽取5张牌，并将其交还给调用者。</p><h2 id="1661" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">2.电脑扑克手</h2><p id="76bb" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">现在我们知道了如何生成一手牌，让我们编写一个简单的for循环来计算并分组相似的排名，如下所示:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="480e" class="kg kh hh ll b fi lp lq l lr ls"># Using a defaultdict to assign 0 if card entry does not exists <br/># when we try to access it via an index []<br/>groups  = defaultdict(int)<br/>for card in hand:    <br/>    groups[card[1:]] += 1</span></pre><p id="5ae2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，如果给我们以下三手牌，上述for循环将产生以下3组牌:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="6d01" class="kg kh hh ll b fi lp lq l lr ls">hand = [‘CJ’,’SJ’,’D3',‘DK’,‘H9’]<br/>groups -&gt; {'J':2, '3':1, 'K':1, '9':1} </span><span id="5810" class="kg kh hh ll b fi lt lq l lr ls">hand = [‘CJ’,’SJ’,’DJ’, ‘DJ’, ‘HK’]<br/>groups -&gt; {'J':4, 'K':1}     # four of a kind</span><span id="d310" class="kg kh hh ll b fi lt lq l lr ls">hand = [‘CJ’,’SJ’,’DJ’,‘DK’,‘HK’] <br/>groups -&gt; {'J':3, 'K':2}     # full house</span></pre><h2 id="f093" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">3.检查扑克手</h2><p id="fc68" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">让我们将上面的for循环插入一个函数，该函数检查分组并计算一手牌是同类型的四点还是满堂红。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="aac5" class="kg kh hh ll b fi lp lq l lr ls">from collections import defaultdict </span><span id="b269" class="kg kh hh ll b fi lt lq l lr ls">def check(hand):<br/>    groups  = defaultdict(int)<br/>    for card in hand:    <br/>        groups[card[1:]] += 1<br/>    <br/>    if len(groups) == 2:<br/>        if max(groups.values()) == 4 :  # four-of-a-kind<br/>            return (1,0)<br/>        else:   <br/>            return (0,1)    # max=3 and min=2 -&gt; full house<br/>    return (0,0)   # all other cases</span></pre><p id="636f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">检查手的代码非常简单。基本上，我们检查组字典是否包含2个项目，如果不包含，则意味着这手牌不能是四个一类或满堂红。但是，如果组包含2个项目，则它只能是以下两种形式:</p><ul class=""><li id="5ad0" class="js jt hh iy b iz ja jc jd jf ju jj jv jn jw jr jx jy jz ka bi translated"><strong class="iy hi"> {Rank: 4，Rank: 1} </strong> <em class="lu">(四个一类)</em>或者</li><li id="8e13" class="js jt hh iy b iz kb jc kc jf kd jj ke jn kf jr jx jy jz ka bi translated"><strong class="iy hi">{等级:3，等级:2} </strong> <em class="lu">(满堂彩)</em></li></ul><h2 id="75d7" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">4.主程序</h2><p id="46ef" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">有了这些，现在我们的主程序看起来非常简单。</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="ca16" class="kg kh hh ll b fi lp lq l lr ls">def main():<br/>    print (Full_Deck)<br/>    four_kind = 0<br/>    full_house =0<br/>    iterations = 300_000</span><span id="d157" class="kg kh hh ll b fi lt lq l lr ls">    for hand in Generate_Hands(iterations):<br/>        four, full = check (hand)<br/>        four_kind += four<br/>        full_house += full<br/>    <br/>    print ("Probability four of a kind:", four_kind/iterations)  <br/>    print ("Probability full house:", full_house/iterations)</span><span id="b6f8" class="kg kh hh ll b fi lt lq l lr ls"># on my computer I get the following output<br/>Probability four of a kind: 0.000238911<br/>Probability full house: 0.00145329</span></pre><h2 id="c41a" class="kg kh hh bd ki kj kk kl km kn ko kp kq jf kr ks kt jj ku kv kw jn kx ky kz la bi translated">5.比较计算</h2><p id="4070" class="pw-post-body-paragraph iw ix hh iy b iz lb ii jb jc lc il je jf ld jh ji jj le jl jm jn lf jp jq jr ha bi translated">为了理解这些数字，我们需要看看用组合学计算的真实概率。在52张牌的游戏中，我们有2，598，960手可能的5张牌。在这些可能性中，有624手四张同类型的牌和3744手满座牌。因此，真实概率如下:</p><pre class="lg lh li lj fd lk ll lm ln aw lo bi"><span id="8e06" class="kg kh hh ll b fi lp lq l lr ls">    Hand          Possible Hands          Probability<br/> Four of a Kind        624           624 /2,598,960 = 0.000240096<br/> Full House           3744           3744/2,598,960 = 0.00144058</span></pre><p id="a1cb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">那么为什么用模拟计算出来的，和用组合学计算出来的不一样。简单地说，在我们的Python代码中，我们执行了300，000次迭代。为了更接近真实的概率，我们需要进行更多的模拟。用300万次迭代试一下，检查一下差别！</p><p id="c26b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="lu">要查看完整的Python程序，请查看Github repo: </em></p><p id="fa6b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><a class="ae lv" href="https://github.com/abbas-taher/Probability-and-Simulation" rel="noopener ugc nofollow" target="_blank">https://github.com/abbas-taher/Probability-and-SimulationT21</a></p></div></div>    
</body>
</html>