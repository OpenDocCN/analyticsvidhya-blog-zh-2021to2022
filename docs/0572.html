<html>
<head>
<title>Predicting Financial Market Trends with CNNs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用CNN预测金融市场趋势</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-financial-market-trends-with-cnns-bb3982c7396?source=collection_archive---------11-----------------------#2021-01-22">https://medium.com/analytics-vidhya/predicting-financial-market-trends-with-cnns-bb3982c7396?source=collection_archive---------11-----------------------#2021-01-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/de5dfe197617744f6895f1794e4c42ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oR5P4fyvGBQsSMb_6G4PQ.jpeg"/></div></div></figure><h1 id="a186" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="9bd5" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在钻研预测和用神经网络预测时，我发现了对时间序列预测的直接兴趣。我决定开始着手一个项目，试图预测金融市场的积极和消极趋势。早期我选择尝试预测趋势，而不是未来价格。许多交易者更喜欢根据任何给定市场的总体积极或消极趋势进行交易，而不是使用非常具体的价格预测。这种方法还简化了神经网络的学习目标，因为正趋势和负趋势可以用0和1来表示。使用二元分类方法让我避免了回归问题。</p><p id="bd81" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">虽然递归神经网络(RNN)是时间序列预测的典型选择，但我发现卷积神经网络(CNN)对于我所追求的目的更有效。这并不是说，随着进一步的研究，不能使用本文中概述的实践来开发有效的RNN。</p><h1 id="b6ac" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">数据收集和预处理</h1><p id="f212" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">对我来说，收集高质量的数据并对其进行适当的处理是一个艰难的过程。仅仅使用股票或货币对的连续价格数据是不够有效的；价格的变化会受到许多因素的影响，而神经网络无法获得这些信息。为了预测积极和消极的价格趋势，动量指标是一个显而易见的选择。虽然有很多可供选择，但我决定使用我更熟悉的方法:<a class="ae kq" href="https://www.investopedia.com/terms/s/sma.asp" rel="noopener ugc nofollow" target="_blank">简单移动平均线</a>(SMA)<a class="ae kq" href="https://www.investopedia.com/terms/e/ema.asp" rel="noopener ugc nofollow" target="_blank">指数移动平均线</a>(EMA)<a class="ae kq" href="https://www.investopedia.com/terms/m/macd.asp" rel="noopener ugc nofollow" target="_blank">移动平均线收敛发散</a>(MACD)<a class="ae kq" href="https://www.investopedia.com/terms/r/rsi.asp" rel="noopener ugc nofollow" target="_blank">相对强弱指数</a> (RSI)，以及<a class="ae kq" href="https://www.investopedia.com/terms/b/bollingerbands.asp" rel="noopener ugc nofollow" target="_blank">布林线</a> (BB)。</p><p id="7ec7" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我使用了Kaggle用户<em class="kr"> Imetomi </em>的<a class="ae kq" href="https://www.kaggle.com/imetomi/eur-usd-forex-pair-historical-data-2002-2019" rel="noopener ugc nofollow" target="_blank">欧元美元外汇对历史数据(2002–2020)</a>数据集。在数据集中是一个包含超过500万个时间步长的分钟分辨率文件，这对于深度学习来说是一个有利可图的选择，因为模型随着数据的增加而学习得更好。其他API，如Oanda或AlphaVantage，有大量高质量的数据可用于各种应用程序。</p><p id="9827" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">将文件导入并格式化到程序中是一个简单的过程。我下载了CSV文件，并把它作为熊猫的数据帧导入。然后，我每隔五分钟遍历一次开价，以获得五分钟的数据。以下代码导入了将在本教程中使用的库，并说明了如何处理和绘制数据帧。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="a500" class="lb iq hh kx b fi lc ld l le lf"><strong class="kx hi">import</strong> <strong class="kx hi">tensorflow</strong> <strong class="kx hi">as</strong> <strong class="kx hi">tf</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">matplotlib.pyplot</strong> <strong class="kx hi">as</strong> <strong class="kx hi">plt</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">requests</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">pandas</strong> <strong class="kx hi">as</strong> <strong class="kx hi">pd</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">csv</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">numpy</strong> <strong class="kx hi">as</strong> <strong class="kx hi">np</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">time</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">scipy</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">math</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">time</strong><br/><strong class="kx hi">import</strong> <strong class="kx hi">datetime</strong><br/><strong class="kx hi">from</strong> <strong class="kx hi">scipy</strong> <strong class="kx hi">import</strong> stat</span><span id="48e8" class="lb iq hh kx b fi lg ld l le lf">df = pd.read_csv('/content/EURUSD_MN.csv') <br/><br/>df = np.array(df['BO'][::5], dtype=np.float32) </span><span id="812e" class="lb iq hh kx b fi lg ld l le lf">print('Dataframe Shape: ' + str(df.shape))<br/><br/>plt.plot(df)<br/>plt.show()</span></pre><p id="2fa8" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">导入数据帧并将其设置为numpy数组后，下一步是计算指标。我为每个指标编写了一个函数，它将数据帧作为输入，并输出一个计算出的指标数组。我不打算深入讨论每个指标的数学公式，因为它们在前面的部分有超链接。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="09e8" class="lb iq hh kx b fi lc ld l le lf"><strong class="kx hi">def</strong> calc_macd_and_ema(X, display=<strong class="kx hi">False</strong>):<br/>  <em class="kr">'''Calculates the Moving Average Convergence Divergence Indicator</em><br/><em class="kr">     and the Exponential Moving Average Indicator'''</em><br/>  macd, ema = [-.1], [1.]<br/><br/>  <strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(1, len(X)):<br/>    e26 = X[i] * (2 / 27) + X[i-1] * (1 - (2 / 27))<br/>    e12 = X[i] * (2 / 27) + X[i-1] * (1 - (2 / 13))<br/>    m = e12 - e26<br/><br/>    ema.append(e12)<br/>    macd.append(m)<br/><br/>  <strong class="kx hi">if</strong> display:<br/>    plt.plot(macd)<br/>    plt.title('MACD')<br/>    plt.show()<br/><br/>    plt.plot(ema)<br/>    plt.title('EMA')<br/>    plt.show()<br/><br/>  <strong class="kx hi">return</strong> np.array(macd), np.array(ema)<br/><br/><br/><strong class="kx hi">def</strong> calc_sma(X, window, display=<strong class="kx hi">False</strong>):<br/>  <em class="kr">'''Calculates the Simple Moving Average Indicator'''</em><br/>  sma = [1.]<br/>  <strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(1, len(X)):<br/>    <strong class="kx hi">if</strong> i &lt; window:<br/>      sma.append((sum(X[:i])) / i)<br/>    <strong class="kx hi">else</strong>: <br/>      sma.append((sum(X[i-window:i])) / window)<br/><br/>  <strong class="kx hi">if</strong> display:<br/>    plt.plot(sma)<br/>    plt.title('SMA')<br/>    plt.show()  <br/><br/>  <strong class="kx hi">return</strong> np.array(sma)<br/><br/><strong class="kx hi">def</strong> calc_rsi(X, display=<strong class="kx hi">False</strong>):<br/>  <em class="kr">'''Calculates the Relative Strength Index'''</em><br/>  look_back = 24<br/>  rsi = np.zeros((len(X)), dtype=np.float32)<br/>  rsi[0] = 50.<br/>  avu = [.001]<br/>  avd = [.001]<br/>  <strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(1, len(X)):<br/><br/>    <strong class="kx hi">if</strong> X[i] &gt; X[i-1]:<br/>      avu.append(X[i]/X[i-1])<br/>      <strong class="kx hi">if</strong> len(avu) &gt; look_back: avu.pop(0)<br/><br/>    <strong class="kx hi">else</strong>:<br/>      avd.append(X[i]/X[i-1])<br/>      <strong class="kx hi">if</strong> len(avd) &gt; look_back: avd.pop(0)<br/>    r = (100 - (100 / (1 + (np.mean(avu) / np.mean(avd)))))<br/>      <br/>    <strong class="kx hi">if</strong> 50. &lt; r &lt; 50.1: rsi[i] = (r) <br/>    <strong class="kx hi">else</strong>: rsi[i] = 50.<br/><br/>  <strong class="kx hi">if</strong> display:<br/>    plt.plot(rsi)<br/>    plt.title('RSI')<br/>    plt.show()<br/><br/>  <strong class="kx hi">return</strong> np.array(rsi)<br/><br/><strong class="kx hi">def</strong> calc_BB(X, ma, display=<strong class="kx hi">False</strong>):<br/>  <em class="kr">'''Calculates the Bollinger Bands Indicator'''</em><br/>  window = 48<br/>  bbu, bbd = np.zeros((len(X))), np.zeros((len(X)))<br/>  bbu[0] = 0.<br/>  bbd[0] = 0.<br/><br/>  <strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(1, len(X)):<br/>    <strong class="kx hi">if</strong> i &lt; window:<br/>      bbu[i] = (ma[i]* np.mean(X[:window]) + 2 * np.std(X[:window]))<br/>      bbd[i] = (ma[i]* np.mean(X[:window]) - 2 * np.std(X[:window]))<br/>    <strong class="kx hi">else</strong>:<br/>      bbu[i]= (ma[i]*np.mean(X[i-window:i])+2*np.std(X[i-window:i]))<br/>      bbd[i]= (ma[i]*np.mean(X[i-window:i])-2*np.std(X[i-window:i]))<br/><br/>  <strong class="kx hi">if</strong> display:<br/>    plt.plot(bbu)<br/>    plt.plot(bbd)<br/>    plt.title('BBands')<br/>    plt.show()<br/><br/>  <strong class="kx hi">return</strong> np.array(bbu), np.array(bbd)</span><span id="483b" class="lb iq hh kx b fi lg ld l le lf">macd, ema = calc_macd_and_ema(df, display=<strong class="kx hi">False</strong>) <br/>sma = calc_sma(df, window=32, display=<strong class="kx hi">False</strong>) <br/>rsi = calc_rsi(df, display=<strong class="kx hi">False</strong>) <br/>bbu, bbd = calc_BB(df, sma, display=<strong class="kx hi">False</strong>)</span></pre><p id="7589" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我使用Google Colab来执行我的所有代码，并且我发现内存限制在这一步造成了一个问题。如果使用了所有五百万个数据点，那么当调用指示器函数时，会话将由于缺少可用RAM而崩溃。我发现减少使用的点数可以让程序无缝运行(因此以五分钟的间隔遍历数据帧)。</p><p id="0899" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">下一段代码显示了如何对我们到目前为止收集的数据进行整形、规范化、堆叠、拆分和标记。标准化输入是创建有效神经网络的关键步骤。如果没有标准化的输入，模型在计算损失和优化预测方面的效率会大大降低。Scipy是python的一个科学库，它有大量的工具，它们的z-score工具可以很好地标准化数据。</p><p id="35b3" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">分裂矩阵是一个特别适合于时间序列应用的卷积神经网络的过程。该函数在堆叠矩阵上滑动一个窗口，实质上是在窗口内所有值的每个时间步长拍摄快照。这个快照然后被堆叠到一个比输入矩阵大一个维度的数组中。这些快照充当CNN解读的图像。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="c280" class="lb iq hh kx b fi lc ld l le lf"><strong class="kx hi">def</strong> split_sequences(xs, ys, n_steps):<br/>  <em class="kr">'''</em><br/><em class="kr">  Takes an input sequence and splits it into multiple windows</em><br/><em class="kr">  Input array will be shape [examples, features, 1]</em><br/><em class="kr">  Output array will be shape [examples, time steps, features, 1]</em><br/><em class="kr">  '''</em><br/>  X = np.zeros((xs.shape[0], n_steps, xs.shape[1], 1))<br/>  Y = np.zeros((ys.shape[0], n_steps, 1))<br/>  <strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(len(xs)):<br/>    end_ix = i + n_steps<br/>    <strong class="kx hi">if</strong> end_ix == len(xs):<br/>      <strong class="kx hi">break</strong><br/><br/>    seq_x = xs[i:end_ix, :]<br/>    seq_y = ys[i:end_ix]<br/>    zeros = np.zeros((n_steps, 7, 1))<br/><br/>    <strong class="kx hi">if</strong> np.array_equal(seq_x, zeros):<br/>      <strong class="kx hi">break</strong><br/>    X[i] = seq_x<br/>    Y[i] = seq_y<br/><br/>  <em class="kr">#print(f'Split X Shape: {np.array(X).shape}')</em><br/>  <em class="kr">#print(f'Split Y Shape: {np.array(Y).shape}')</em><br/>  <strong class="kx hi">return</strong> np.array(X), np.array(Y)</span></pre></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><pre class="kw kx ky kz aw la bi"><span id="0cfb" class="lb iq hh kx b fi lo lp lq lr ls ld l le lf">macd = macd.reshape(df.shape[0], 1)<br/>sma = sma.reshape(df.shape[0], 1)<br/>ema = ema.reshape(df.shape[0], 1)<br/>rsi = rsi.reshape(df.shape[0], 1)<br/>bbu = bbu.reshape(df.shape[0], 1)<br/>bbd = bbd.reshape(df.shape[0], 1)<br/>price = df.reshape(df.shape[0], 1)<br/>bin = np.zeros((df.shape[0], 1))<br/><br/><em class="kr">#Normalize the data</em><br/>macd = scipy.stats.zscore(macd)<br/>sma =  scipy.stats.zscore(sma)<br/>ema = scipy.stats.zscore(ema)<br/>rsi =  scipy.stats.zscore(rsi)<br/><br/><em class="kr">#Create Binary Labels</em><br/><strong class="kx hi">for</strong> i <strong class="kx hi">in</strong> range(df.shape[0]-1):<br/>  <strong class="kx hi">if</strong> price[i+1] &gt; price[i]:<br/>    bin[i] = 1<br/>  <strong class="kx hi">elif</strong> price[i+1] &lt; price[i]:<br/>    bin[i] = 0<br/>  <strong class="kx hi">else</strong>: bin[i] = 1<br/>  <strong class="kx hi">if</strong> i == df.shape[0]:<br/>    bin[i] = 1<br/><br/>test_range = price.shape[0] - 100000<br/>val_range = price.shape[0] - 50000<br/><br/>data = np.stack((macd,sma,ema,rsi,bbu,bbd,price), axis=1)<br/>train = data[:test_range,...]<br/>test = data[test_range:val_range,...]<br/>val = data[val_range:,...]<br/><br/><em class="kr">#Inputs</em><br/>X_train, _ = split_sequences(train, bin[:test_range], 32)<br/>Y_train = bin[:test_range]<br/>X_test, _ = split_sequences(test, bin[test_range:val_range], 32)<br/>Y_test = bin[test_range:val_range]<br/>X_val, _ = split_sequences(val, bin[val_range:], 32)<br/>Y_val = bin[val_range:]</span></pre><h1 id="cc44" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">建立和训练CNN</h1><p id="c7cc" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">现在所有的输入都已经定义好了，是时候创建CNN了。我决定使用两个块的CNN，每个块包含一个Conv2D和一个MaxPool2D层。然后，第二个模块的输出被平坦化，并被馈送到具有s形激活的单一密集单元中。这使得CNN可以预测二进制输出。我没有特别的理由使用内核大小和过滤器数量，因为我只是发现它们是有效的。每个卷积层也使用一个核正则化子。如果没有正则项，模型似乎会不断地找到局部极小值，并且不会收敛。然而，通过正则化，模型能够相当快地收敛。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="208a" class="lb iq hh kx b fi lc ld l le lf"><strong class="kx hi">def</strong> run_conv(X, Y):<br/>  model = tf.keras.models.Sequential([<br/>          tf.keras.layers.Conv2D(128, kernel_size=(7,16)            ,            padding='same'                                                                                                                        ,            kernel_regularizer=tf.keras.regularizers.l2(0.0001)),<br/>          tf.keras.layers.MaxPool2D((2,2)),<br/>          tf.keras.layers.Conv2D(32, kernel_size=(7,4)              ,            padding='same'                                         ,            kernel_regularizer=tf.keras.regularizers.l2(0.0001)),<br/>          tf.keras.layers.MaxPool2D((2,2)),<br/>          tf.keras.layers.Flatten(),<br/>          tf.keras.layers.Dense(1, activation='sigmoid')<br/>  ])<br/><br/>  model.compile(optimizer=tf.keras.optimizers.Adam(lr=0.001,)        ,               loss='binary_crossentropy', metrics=['accuracy'])<br/>  history = model.fit(X,Y, validation_data = (X_val, Y_val)         ,               epochs=128, batch_size=32, callbacks=[callback])<br/>  <strong class="kx hi">return</strong> history, model</span><span id="c55b" class="lb iq hh kx b fi lg ld l le lf">history, model = run_conv(X_train, Y_train)</span></pre><p id="b55b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">CNN的损耗很快从0.7%收敛到0.2%，之后变得更慢。到第四或第五个纪元时，它已经将其准确度提高到90%以上。虽然这些指标似乎表明取得了重大成功，但在模型训练时查看真实值和预测值也有助于衡量它是如何学习的。在模型编译时将这两个函数添加到度量列表中，将显示它在猜测什么以及它是如何学习的。</p><pre class="ks kt ku kv fd kw kx ky kz aw la bi"><span id="46fa" class="lb iq hh kx b fi lc ld l le lf">def true(y_true, y_pred):<br/>  return y_true<br/>def pred(y_true, y_pred):<br/>  return y_pred</span><span id="4209" class="lb iq hh kx b fi lg ld l le lf">model.compile(optimizer=opt, loss=loss, metrics=['accuracy', true,     pred]</span></pre><p id="20e8" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这是我参与过的最大的项目，它测试了我的知识和面对失败时的学习能力。我认为这个项目是成功的，因为该模型能够达到97%的准确性，并在使用实时数据进行模拟交易时获得利润(我将很快就此写另一篇文章)。我对深度学习相当陌生，我知道这些代码中的大部分都可以简化和改进。因此，不要犹豫，主动提出建议、修改或新想法。</p><p id="6fb0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">电子邮件:ajrogers3654@gmail.com</p><p id="8863" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">github:<a class="ae kq" href="https://github.com/ajrogers17/Forex_Prediction/blob/main/Forex_Prediction.ipynb" rel="noopener ugc nofollow" target="_blank">https://github.com/ajrogers17</a></p><p id="4356" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">领英:【https://www.linkedin.com/in/alexrogers17/ T2】</p></div></div>    
</body>
</html>