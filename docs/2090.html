<html>
<head>
<title>Movie Recommendation System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">电影推荐系统</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/movie-recommendation-system-aa204f0700eb?source=collection_archive---------3-----------------------#2021-04-04">https://medium.com/analytics-vidhya/movie-recommendation-system-aa204f0700eb?source=collection_archive---------3-----------------------#2021-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c30f1121de71c8c2c95d03a52302a978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jFBPZckFlemXOF1JGit9Pw.png"/></div></div></figure><p id="08ee" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嘿！！极客。我们都知道看电影很有趣。我们都像网飞一样在不同的平台上看了很多电影。我一直在思考，像网飞这样基于电影的平台，甚至是medium，是如何根据用户兴趣来推荐任何东西的。基于我们的兴趣，这些建议是如何起作用的。让我们获取知识。！</p><p id="e3dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个博客中，我们将讨论推荐系统。并使用电影数据库数据集创建一个电影推荐系统。</p><blockquote class="jn jo jp"><p id="14a3" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">听听谷歌对此的看法。</p></blockquote><p id="2c9e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">推荐系统，</strong>或推荐系统，是信息过滤系统的一个子类，它试图预测用户对某个项目的“评分”或“偏好”。</p><p id="f067" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">简单来说，<strong class="ir hi">推荐系统</strong>旨在预测用户的兴趣，并推荐他们很可能感兴趣的产品。</p><blockquote class="jn jo jp"><p id="50b4" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">推荐值</p></blockquote><p id="9e39" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">网飞</strong>:观看电影的2/3被推荐</p><p id="4185" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">谷歌新闻:推荐产生38%的点击率</p><p id="335a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">亚马逊 : 35%的销售额来自推荐</p><p id="1970" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，从商业角度来看，用户在平台上找到的相关产品越多，他们的参与度就越高。它增加了各种平台的收入。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h1 id="f420" class="kb kc hh bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">推荐系统的类型</h1><p id="239a" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">通常，机器学习算法适合于推荐系统的两个类别。</p><ol class=""><li id="48cd" class="le lf hh ir b is it iw ix ja lg je lh ji li jm lj lk ll lm bi translated">基于内容的推荐系统</li></ol><p id="6ace" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.协同过滤推荐系统</p><p id="5086" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">虽然，现代推荐使用这两种方法，称为混合推荐。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ln"><img src="../Images/63f75853d0d6d95328d11468a65338ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQvD0rDEWzhhx-Eiurhung.png"/></div></div></figure><h2 id="6534" class="ls kc hh bd kd lt lu lv kh lw lx ly kl ja lz ma kp je mb mc kt ji md me kx mf bi translated">基于内容的过滤</h2><p id="b15f" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">基于特定项目建议相似的项目。该系统使用项目元数据，例如流派、导演、描述、演员等。对于电影，提出这些建议。这些推荐系统背后的一般思想是，如果一个人喜欢一个特定的项目，他或她也会喜欢与之相似的项目。前任。<strong class="ir hi"> YouTube </strong></p><h2 id="cd4c" class="ls kc hh bd kd lt lu lv kh lw lx ly kl ja lz ma kp je mb mc kt ji md me kx mf bi translated">协同过滤</h2><p id="6752" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">这些系统被广泛使用，它们试图根据其他用户过去的评分和偏好来预测用户对某个项目的评分或偏好。协作过滤器不像基于内容的过滤器那样需要项目元数据。</p><p id="be37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CF分为两类:</p><ul class=""><li id="ddc3" class="le lf hh ir b is it iw ix ja lg je lh ji li jm mg lk ll lm bi translated"><strong class="ir hi">基于用户</strong>:衡量目标用户与其他用户的相似度</li><li id="2d51" class="le lf hh ir b is mh iw mi ja mj je mk ji ml jm mg lk ll lm bi translated"><strong class="ir hi">基于项目</strong>:衡量目标用户评价/交互的项目与其他项目之间的相似性</li></ul><p id="2115" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CF背后的关键思想是相似的用户分享相同的兴趣，并且相似的项目被用户喜欢。这样的例子可以在<strong class="ir hi">网飞</strong>和<strong class="ir hi"> Spotify </strong>的推荐系统中找到。</p><p id="3d6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">详情点击<a class="ae mm" href="https://hackernoon.com/introduction-to-recommender-system-part-1-collaborative-filtering-singular-value-decomposition-44c9659c5e75" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">此处</strong> </a>。</p><h2 id="aa8f" class="ls kc hh bd kd lt lu lv kh lw lx ly kl ja lz ma kp je mb mc kt ji md me kx mf bi translated"><strong class="ak">混合动力发动机</strong></h2><p id="e063" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">我们将来自内容和协作过滤的想法结合在一起，构建了一个引擎，该引擎根据内部为特定用户计算的估计评级，向该用户提供电影建议。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><blockquote class="jn jo jp"><p id="d8cc" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">让我们开始实现部分..</p></blockquote><p id="78cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我使用了一个<a class="ae mm" href="https://www.kaggle.com/tmdb/tmdb-movie-metadata" rel="noopener ugc nofollow" target="_blank"> tmdb_5000_dataset。包含近5000部电影，包括它们的标题、名字、类型、演员等等。信息。</a></p><p id="8afa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用pandas和numpy进行数据预处理，使用sklearn进行机器学习任务。</p><p id="16d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">导入所有需求和数据集..</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="ddd6" class="ls kc hh mo b fi ms mt l mu mv">import pandas as pd<br/>import numpy as np<br/>movies = pd.read_csv('datasets/tmdb_5000_movies.csv')<br/>df = pd.read_csv('datasets/tmdb_5000_credits.csv')<br/>df.columns = ['id', 'tittle', 'cast', 'crew']<br/>movies = movies.merge(df, on='id')</span><span id="2f28" class="ls kc hh mo b fi mw mt l mu mv">movies.info()</span></pre><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es mx"><img src="../Images/986015806438acbc2e3bbd9b124518c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1038/format:webp/1*tb6d5J4Y0Gd3knRQ_fMjMw.png"/></div></figure><p id="95d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上图中我们可以看到有4803部电影和23个带有tmdb id的列。</p><blockquote class="jn jo jp"><p id="dcae" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">让我们从<strong class="ir hi">基于内容的推荐引擎开始。为此，我们需要关于这部电影的信息，在<strong class="ir hi">概述</strong>栏中有描述。</strong></p></blockquote><p id="0c7d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将使用sklearn的<a class="ae mm" rel="noopener" href="/@cmukesh8688/tf-idf-vectorizer-scikit-learn-dbc0244a911a"> TF-IDF矢量器</a>来获取电影的特征，并基于TF-IDF矩阵找到电影之间的相似之处。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="6e82" class="ls kc hh mo b fi ms mt l mu mv">from sklearn.feature_extraction.text import TfidfVectorizer</span><span id="598e" class="ls kc hh mo b fi mw mt l mu mv"># removing english stop word like a, and , the <br/>tfidf = TfidfVectorizer(analyzer = ‘word’,stop_words = ‘english’)</span><span id="6412" class="ls kc hh mo b fi mw mt l mu mv">#NaN -&gt; ‘’<br/>movies[‘overview’] = movies[‘overview’].fillna(‘’)</span><span id="37bf" class="ls kc hh mo b fi mw mt l mu mv">tfidf_matrix = tfidf.fit_transform(movies[‘overview’])</span><span id="42d1" class="ls kc hh mo b fi mw mt l mu mv">tfidf_matrix.shape # outputs: (4803, 20978)</span></pre><p id="77b0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">TF-IDF矩阵的形状是(4803，20978)。这意味着这里有20978个不同的词被用来描述一部4803电影。</p><p id="a3e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将找到这个矩阵的相似性得分。</p><p id="5eb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们有一个TF_IDF矢量器，直接计算点积将会得到余弦相似度。这里我们使用余弦相似性得分，因为它相对容易和快速计算。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="cc85" class="ls kc hh mo b fi ms mt l mu mv">from sklearn.metrics.pairwise import linear_kernel</span><span id="a8be" class="ls kc hh mo b fi mw mt l mu mv">cosin_sim = linear_kernel(tfidf_matrix, tfidf_matrix)</span></pre><p id="01c3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将为电影和标题的索引做反向映射。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="5874" class="ls kc hh mo b fi ms mt l mu mv">index_of_movies = pd.Series(movies.index,   index=movies['title']).drop_duplicates()</span></pre><p id="f404" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们来写函数求推荐吧。</p><ol class=""><li id="2e64" class="le lf hh ir b is it iw ix ja lg je lh ji li jm lj lk ll lm bi translated">会得到这个头衔</li><li id="88e6" class="le lf hh ir b is mh iw mi ja mj je mk ji ml jm lj lk ll lm bi translated">从cosin_sim矩阵中查找电影的相似性得分</li><li id="de69" class="le lf hh ir b is mh iw mi ja mj je mk ji ml jm lj lk ll lm bi translated">对相似性得分排序</li><li id="47d4" class="le lf hh ir b is mh iw mi ja mj je mk ji ml jm lj lk ll lm bi translated">基于输入返回顶级电影</li></ol><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="07c0" class="ls kc hh mo b fi ms mt l mu mv">def get_recommendations(title, cosin_sim=cosin_sim):<br/>    idx = index_of_movies[title]<br/>    <br/>    sim_scores = list(enumerate(cosin_sim[idx]))<br/>    # sorting of moviesidx based on similarity score<br/>    sim_scores = sorted(sim_scores, key = lambda x:x[1], reverse = True)<br/>    # get top 10 of sorted <br/>    sim_scores = sim_scores[1:31]<br/>    <br/>    movies_idx = [i[0] for i in sim_scores]<br/>    <br/>    return movies['title'].iloc[movies_idx]</span></pre><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es my"><img src="../Images/918dd94e952e9683e1bed344404da073.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*QnXzR-wAO7_At_BAkGSfOQ.png"/></div><figcaption class="mz na et er es nb nc bd b be z dx translated">推荐电影的输出</figcaption></figure><p id="197c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">用另一个元数据改进推荐器</strong></p><p id="b5d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，我们获得演员、工作人员、关键字和流派列数据。然后，我们将对数据进行一些预处理，以获取最有用的信息，例如，我们将从“crew”列中获取Director。</p><p id="1399" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将创建这些信息的大杂烩。并应用<a class="ae mm" href="https://www.educative.io/edpresso/countvectorizer-in-python" rel="noopener ugc nofollow" target="_blank">计数矢量器</a>。</p><p id="b6c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一个重要的区别是我们使用了<strong class="ir hi"> CountVectorizer() </strong>而不是TF-IDF。这是因为我们不想贬低一个演员/导演的存在，如果他或她演过或导演过相对更多的电影。没有太大的直观意义。</p><p id="1901" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一步是基于计数矩阵计算余弦相似矩阵。</p><p id="fa2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是相同的代码..</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="29af" class="ls kc hh mo b fi ms mt l mu mv">from ast import literal_eval</span><span id="903f" class="ls kc hh mo b fi mw mt l mu mv">features = ['cast', 'crew', 'keywords', 'genres']<br/>for f in features:<br/>    movies[f] = movies[f].apply(literal_eval)</span><span id="f1fc" class="ls kc hh mo b fi mw mt l mu mv"># to get director from job<br/>def get_director(x):<br/>    for i in x:<br/>        if i['job'] == 'Director':<br/>            return i['name']<br/>    return np.nan</span><span id="5284" class="ls kc hh mo b fi mw mt l mu mv"># get top 3 elements of list<br/>def get_list(x):<br/>    if isinstance(x, list):<br/>        names = [ i['name'] for i in x]<br/>        <br/>        if len(names)  &gt; 3:<br/>            names = names[:3]<br/>        return names<br/>    return []</span><span id="a4e7" class="ls kc hh mo b fi mw mt l mu mv">#apply all functions<br/>movies['director'] = movies['crew'].apply(get_director)</span><span id="b4c6" class="ls kc hh mo b fi mw mt l mu mv">features = ['cast', 'keywords', 'genres']<br/>for f in features:<br/>    movies[f] = movies[f].apply(get_list)</span><span id="f711" class="ls kc hh mo b fi mw mt l mu mv">#striping<br/>def clean_data(x):<br/>    if isinstance(x, list):<br/>        return [str.lower(i.replace(' ', '')) for i in x]<br/>    else:<br/>        if isinstance(x, str):<br/>            return str.lower(x.replace(' ', ''))<br/>        else:<br/>            return ''</span><span id="c78b" class="ls kc hh mo b fi mw mt l mu mv">features = ['cast', 'keywords', 'director', 'genres']<br/>for f in features:<br/>    movies[f] = movies[f].apply(clean_data)</span><span id="4fe7" class="ls kc hh mo b fi mw mt l mu mv">#creating a SOUP<br/>def create_soup(x):<br/>    return ' '.join(x['keywords'])+' '+' '.join(x['cast'])+' '+x['director']+' '+' '.join(x['genres'])</span><span id="460a" class="ls kc hh mo b fi mw mt l mu mv">movies['soup'] = movies.apply(create_soup, axis=1)</span><span id="536b" class="ls kc hh mo b fi mw mt l mu mv">#count Vectorizer<br/>from sklearn.feature_extraction.text import CountVectorizer<br/>count = CountVectorizer(stop_words = 'english')<br/>count_matrix = count.fit_transform(movies['soup'])</span><span id="c2cf" class="ls kc hh mo b fi mw mt l mu mv"># finding similarity matrix<br/>from sklearn.metrics.pairwise import cosine_similarity<br/>cosin_sim2 = cosine_similarity(count_matrix, count_matrix)</span></pre><p id="d4bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们使用相同的get_recommendation()函数，您可以看到我们的电影的改进推荐。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es nd"><img src="../Images/7c2e184b69ae8f38b5a6deda233aadaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*rqXMzs_vEE3-1Z1oRhFpEA.png"/></div><figcaption class="mz na et er es nb nc bd b be z dx translated">改进的建议</figcaption></figure><p id="459a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是我们如何创建一个基于内容的推荐引擎。</p><p id="ffa0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但是，我们的基于内容的引擎受到一些严重的限制。它只能建议与某部电影相近的电影。也就是说，它不能捕捉口味并提供跨流派的推荐。</p><p id="3a5c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此外，我们构建的引擎并不是真正个性化的，因为它没有捕捉到用户的个人品味和偏好。任何人基于电影向我们的引擎查询推荐，都会收到同样的电影推荐，不管她/他是谁。因此，现在，我们将使用一种协同过滤来对电影进行推荐。</p><blockquote class="jn jo jp"><p id="9fe0" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">现在，让我们来看看另一种基于<strong class="ir hi">协同过滤</strong>的类型</p></blockquote><p id="790a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于我们之前使用的数据集没有userId(这是协同过滤所必需的),让我们加载另一个数据集。我们将使用<strong class="ir hi"> Surprise </strong>库来实现SVD。你可以从<a class="ae mm" href="https://www.kaggle.com/rounakbanik/the-movies-dataset" rel="noopener ugc nofollow" target="_blank">这里</a>下载数据集。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="ddf1" class="ls kc hh mo b fi ms mt l mu mv">from surprise import Reader, Dataset, SVD<br/>from surprise.model_selection import cross_validate</span><span id="387c" class="ls kc hh mo b fi mw mt l mu mv">reader = Reader()<br/>ratings = pd.read_csv(‘datasets/ratings_small.csv’)<br/></span></pre><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es ne"><img src="../Images/413fdb0506787830d3dceae5b21a4e32.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*7gwLNEZ_2nt3KT0SNTfxkA.png"/></div><figcaption class="mz na et er es nb nc bd b be z dx translated">评级_小型数据集</figcaption></figure><p id="a2a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">交叉验证我们的数据。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es nf"><img src="../Images/e92c9ca32bd1442b51d7e5eed43643c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*nBIuXBBLtaM3NboA4OnsOg.png"/></div><figcaption class="mz na et er es nb nc bd b be z dx translated">交互效度分析</figcaption></figure><p id="b2b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们得到大约0.89的均方根误差，这对于我们的情况来说已经足够好了。现在让我们在数据集上进行训练并得出预测。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="1f01" class="ls kc hh mo b fi ms mt l mu mv">train = data.build_full_trainset()<br/>svd.fit(train)</span></pre><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es ng"><img src="../Images/115bf316036c1b2afaf7c58df0e4c1bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*nnZrR7mkcET2hjkJ5LcRuw.png"/></div></figure><p id="9857" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们预测用户1对电影Id=302的评级</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="b760" class="ls kc hh mo b fi ms mt l mu mv">svd.predict(1, 302)</span></pre><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es nh"><img src="../Images/1d1544eca171e4bd364710fcdf501799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*mZXtSoQXb62csS-RTxiBhQ.png"/></div></figure><p id="df37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里你可以看到<strong class="ir hi"> est=2.6280 </strong>意味着用户1可能给Id为302的电影评分2.63。</p><p id="b301" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是我们如何在不知道用户过去行为的情况下，根据用户档案预测电影评级，并向他们推荐最佳电影。这被称为协同过滤。</p><h1 id="f439" class="kb kc hh bd kd ke ni kg kh ki nj kk kl km nk ko kp kq nl ks kt ku nm kw kx ky bi translated">混合推荐器</h1><p id="be96" class="pw-post-body-paragraph ip iq hh ir b is kz iu iv iw la iy iz ja lb jc jd je lc jg jh ji ld jk jl jm ha bi translated">现在，让我们把基于内容和基于内容的推荐放在一起，做一个强有力的推荐器。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="2432" class="ls kc hh mo b fi ms mt l mu mv">movie_id = pd.read_csv(‘datasets/links.csv’)[[‘movieId’, ‘tmdbId’]]<br/>movie_id['tmdbId'] = movie_id[‘tmdbId’].apply(conv_int)<br/>movie_id.columns = [‘movieId’, ‘id’]<br/>movie_id = movie_id.merge(movies[[‘title’, ‘id’]], on=’id’).set_index(‘title’)<br/>print(movie_id.shape) # o/p: (4599, 2)</span></pre><p id="779d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的movie_id数据帧将如下所示。</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es nn"><img src="../Images/80d4e67fa5ca419a2012c52615ef61c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*Zo1hG9X6mgogYw0Ph_XT4Q.png"/></div></figure><p id="c310" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">制作一个index_map来查找一部电影的索引。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="e7b8" class="ls kc hh mo b fi ms mt l mu mv">index_map = movie_id.set_index('id')</span></pre><p id="bb85" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，让我们定义我们的推荐函数。它具有基于内容和CF两种技术的能力。</p><pre class="lo lp lq lr fd mn mo mp mq aw mr bi"><span id="0221" class="ls kc hh mo b fi ms mt l mu mv">def recommend_for(userId, title):<br/>    index = index_of_movies[title]<br/>    tmdbId = movie_id.loc[title]['id']<br/>    <br/><br/>    #content based<br/>    sim_scores = list(enumerate(cosin_sim2[int(index)]))<br/>    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)<br/>    sim_scores = sim_scores[1:30]<br/>    movie_indices = [i[0] for i in sim_scores]<br/><br/>    mv = movies.iloc[movie_indices][['title', 'vote_count', 'vote_average', 'id']]<br/>    mv = mv[mv['id'].isin(movie_id['id'])]</span><span id="c760" class="ls kc hh mo b fi mw mt l mu mv">    # CF<br/>    mv['est'] = mv['id'].apply(lambda x: svd.predict(userId, index_map.loc[x]['movieId']).est)<br/>    mv = mv.sort_values('est', ascending=False)<br/>    return mv.head(10)</span></pre><p id="6dc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们对我们的工作有公正的评价；)</p><figure class="lo lp lq lr fd ii er es paragraph-image"><div class="er es no"><img src="../Images/6a368621b0c6d9184f0ac5a8e76a3c21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*2wYxmMRLy-vQcGfLVl5vQA.png"/></div><figcaption class="mz na et er es nb nc bd b be z dx translated">对用户4的建议</figcaption></figure><blockquote class="jn jo jp"><p id="e35f" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">结论</p></blockquote><p id="a264" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用基于内容的协同过滤来创建推荐器。<strong class="ir hi">混合系统</strong>可以利用基于内容和协作过滤，因为这两种方法被证明几乎是互补的。这个模型非常基础，只提供了一个基本的框架。</p><blockquote class="jn jo jp"><p id="b553" class="ip iq jq ir b is it iu iv iw ix iy iz jr jb jc jd js jf jg jh jt jj jk jl jm ha bi translated">你可以在这里找到这个项目<a class="ae mm" href="https://github.com/AshishTrada/Movie-Recommendation-system" rel="noopener ugc nofollow" target="_blank">。去和它玩吧；)</a></p></blockquote><p id="3cdb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">快乐学习！！</p></div></div>    
</body>
</html>