<html>
<head>
<title>Generating skull image with DCGAN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用DCGAN生成颅骨图像</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/generating-skull-image-with-dcgan-b4459a7289a8?source=collection_archive---------7-----------------------#2021-08-27">https://medium.com/analytics-vidhya/generating-skull-image-with-dcgan-b4459a7289a8?source=collection_archive---------7-----------------------#2021-08-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/0b4412e5832208ec3a2304ed41cde168.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hXl-7XzK9PzLjyLS"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">马修·施瓦茨在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="47dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我告诉你，在为数据世界做贡献的同时享受乐趣是一种有趣的方式，会怎么样？是啊！是真的。你听说过快，画！这是一款由谷歌开发的在线游戏，它收集玩家绘制的图片，然后使用神经网络人工智能，模型试图猜测这些图片代表什么。</p><p id="323a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，让我们开始吧！</p><p id="2d54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们调用必要的库:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/d92ae01769c62c105f7fc9c0df86a358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zpeLZjPwl8898bUJyrUVxg.png"/></div></div></figure><p id="1309" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后是一些日常家务:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jx"><img src="../Images/efe111934a71038edd8c04f096ab051e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*msYzENb7K-h5-jWxKQHHLg.png"/></div></figure><p id="936d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如你在这里看到的，我正在使用Quick，Draw的skull.npy数据集！数据集可以在这里获得<a class="ae it" href="https://console.cloud.google.com/storage/browser/_details/quickdraw_dataset/full/numpy_bitmap/skull.npy" rel="noopener ugc nofollow" target="_blank">。数据集中总共有126，174幅图像。然后我们将图像标准化。</a></p><p id="d467" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们生成一个可视化的随机图像。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es jy"><img src="../Images/6a65b2de8cc75ab54c116f2467989d62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*sWO1_4LkDNtolX8ZldhXIA.png"/></div></figure><p id="7b18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯。看起来很棒。接下来，我们定义我们的<a class="ae it" href="https://stackoverflow.com/questions/64372390/what-does-buffer-size-do-in-tensorflow-dataset-shuffling" rel="noopener ugc nofollow" target="_blank">缓冲区大小</a>和批量大小，并创建我们的训练数据集。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jz"><img src="../Images/1faa2a417637ddadbad54b6a3ae90831.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HfoagJOrsmvvvhgfAi_oNg.png"/></div></div></figure><p id="d538" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们应该开始构建我们的生成器和鉴别器。在此之前，让我们导入一些库。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ka"><img src="../Images/076c8c472089ea137493ae9e5a113e99.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*NZknqZjmqosHQRrxuQDI7Q.png"/></div></figure><p id="fb01" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里将创建的生成器使用Conv2DTranspose(上采样)层从种子生成图像。从密集层开始，将该种子作为输入，然后向上采样几次，直到它达到所需的28x28x1的图像大小。LeakyReLU激活用于每一层，除了使用tanh的输出层。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kb"><img src="../Images/0990d00524a9dcdbf2a058466fd64e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFmtI08vbSaSmHQHyKkJMg.png"/></div></div></figure><p id="bf18" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们尝试使用生成器生成一个图像。注意，在这一点上，生成器还没有被训练。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kc"><img src="../Images/4e2e9731630ac83562e6e592c1ab4281.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*hCKrGfEjOWO_bM64vEhGyA.png"/></div></figure><p id="2d85" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嗯。显然需要做一些训练。继续构建我们的鉴别器模型。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kd"><img src="../Images/d658231511423044bc52e43bb2698735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*cL7uf5yA69Ff6f-htCUtZQ.png"/></div></figure><p id="9a3a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该模型将用于将生成的图像分类为真实或伪造。正值代表实像，负值代表假像。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ke"><img src="../Images/8263ac2c3199f25df1b816e9309326d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*jQSwBObMwOh2Lw3YM550BA.png"/></div></figure><p id="e2a8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们定义损失和优化器。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kf"><img src="../Images/1e1e8f0251309950bd2d720d51bb5afa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*duTdW-9veKWnFC-F8NocZw.png"/></div></figure><p id="0cf8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们正在对真实和虚假图像(正值和负值)进行分类，所以使用了<a class="ae it" href="https://www.tensorflow.org/api_docs/python/tf/keras/losses/BinaryCrossentropy" rel="noopener ugc nofollow" target="_blank">二进制交叉熵</a>。现在现在。为了评估我们的鉴别器模型在分类任务中的表现，我们需要通过将其对真实图像的预测与1的数组进行比较，以及将对伪图像(生成的)的预测与0的数组进行比较，来计算鉴别器损失。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kg"><img src="../Images/80ff188638b1082005b83c2d19f82390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*9ykCkac6KndoKBVtpDWT_A.png"/></div></figure><p id="036d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">one_like返回与给定数组形状和类型相同的1的数组，zero_like返回与给定数组形状和类型相同的0的数组。</p><p id="b546" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，当然，我们将不得不评估我们的发电机的性能，是否足够好，在欺骗甄别。如果生成器运行良好，鉴别器将把假图像分类为真实图像(表示为1)。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kh"><img src="../Images/fcce198780b5a0c0f23a3b83051f9bb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*tDITid1eYvsFNIwZTqyTRg.png"/></div></figure><p id="794e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于两个网络将被分别训练，所以优化器被分别定义。这里使用了Adam优化。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ki"><img src="../Images/bf0b733cb8c8403111fd66f04e7489eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*WM3TxXtPQi_BfZ8IbfCGdw.png"/></div></figure><p id="8743" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了保存模型参数，我们将创建检查点。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kj"><img src="../Images/cbf713045101dd5790ef9dda861dfe9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*_t7NIpdWUsdmsD2GxSHzeQ.png"/></div></figure><p id="44b2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好吧。我们即将开始训练我们的模型。这里通常的内务处理流程是:</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kk"><img src="../Images/f36f05162004ad3c53ff41ed407c8a50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1018/format:webp/1*byjnneSqEvz9FITsayuJKg.png"/></div></figure><p id="bd31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，让我们尝试用10个纪元训练模型，看看它做得有多好。在此之前，让我们创建一个训练循环。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/2f6c7c56f963c1f9c30ecb933afadbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sKZ4JByqhmjGhLeDXaSEBQ.png"/></div></div></figure><p id="7ed0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该循环从生成器接收随机种子作为输入并生成图像开始。然后，鉴别器试图对真实和伪造的图像进行分类。计算两个模型的损失，并使用梯度来更新模型。</p><blockquote class="km kn ko"><p id="6bc2" class="iu iv kp iw b ix iy iz ja jb jc jd je kq jg jh ji kr jk jl jm ks jo jp jq jr ha bi translated">人生就是不断完善自己！—简·康多尔</p></blockquote><p id="1989" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后我们将保存这些生成的图像，用于我们的gif创建。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kt"><img src="../Images/42e221ae492c6af06881cc3b39e99b34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*Rd4-2Bzyj9s7frICnOERMQ.png"/></div></figure><p id="0ecd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，创建一个训练函数。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es ku"><img src="../Images/f8a73d36aa371c542d6b03a9f5575df5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*DHs7hsZRArELoykiPOQOww.png"/></div></figure><p id="2812" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好吧！我们终于在训练我们的模型了！从10个纪元开始。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/2e74aad0f79b6d22ed9611bf7f7a1460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*ffxSlwuSnZ1sospMQGq_vg.png"/></div></figure><p id="c03e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们试着调用我们的gif来看看生成的图像是如何进行的。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/b685c2f21e9ce46cd2fd6154c87d24e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:914/format:webp/1*6nWpGDDFZghD3XHTKcMBkg.png"/></div></figure><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/77d1817902c8c30017a78a488aa4151a.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*lMATWGIg8tyS8dvptcAGMA.gif"/></div></figure><p id="1838" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">很明显，只有10个时期，不足以生成一个基本的头骨图像。但是框架是有的。我们用192个纪元试试。</p><figure class="jt ju jv jw fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/d81c5a606108ddbf7b45afe2f3f6e74f.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/1*5ha5VrhnKRgLiZrI57h4Qw.gif"/></div></figure><p id="6cf3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">答！很多！更好！</p><p id="8c55" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看到生成的图像不断改进真的很有趣。甘确实是一个有趣的合作模式。</p><p id="6f9b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！尝试使用另一个数据集创建另一个模型。这个项目是使用<a class="ae it" href="https://www.tensorflow.org/tutorials/generative/dcgan" rel="noopener ugc nofollow" target="_blank">这里</a>的代码创建的。</p><p id="675b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完整代码<a class="ae it" href="https://github.com/gyiernahfufie/DCGAN-for-Skull-Image/blob/main/DCGAN_Skull_Generator.ipynb" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>