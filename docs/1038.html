<html>
<head>
<title>The Ultimate Swiss Army Knife of ‘apply’ Family in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“应用”系列的终极瑞士军刀</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-ultimate-swiss-army-knife-of-apply-family-in-r-27ed5ef09f43?source=collection_archive---------9-----------------------#2021-02-11">https://medium.com/analytics-vidhya/the-ultimate-swiss-army-knife-of-apply-family-in-r-27ed5ef09f43?source=collection_archive---------9-----------------------#2021-02-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="47ab" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">概观</h1><ul class=""><li id="2f85" class="jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">数据操作是机器学习生命周期中最关键的步骤之一</li><li id="84a9" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">让我们学习使用最广泛使用的一组<strong class="je hi"> apply </strong>函数来转换R中的数据</li></ul><h1 id="6d82" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="6338" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">数据操作是机器学习生命周期中最关键的步骤之一。它需要转换所提供的数据，以便可以用于构建预测模型。</p><p id="3dd7" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">此外，在这里，一个熟练的数据科学家运用他们的直觉和经验，从数据中提取尽可能多的信息。因此，毫不奇怪，Python和R中有太多的函数和工具来帮助我们完成这项任务。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/511353c7bbc02545847de79a2a859d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NK5xpWVVHkmEIVuz.jpg"/></div></div></figure><p id="9483" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">今天，我们将使用R并了解最广泛使用的一组用于在R中转换数据的'<strong class="je hi"/>'函数。这一系列函数提供了高效快速的数据操作。当我们只想处理某些列时，这尤其有用。这组函数称为apply()函数。以及它的变体如sapply()、mapply()等。我们得到了一把多用途的瑞士军刀用于数据处理。</p><p id="986c" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated"><em class="lf">如果你有兴趣从事数据科学方面的职业并了解这些令人惊叹的事情，我推荐你查看我们的</em> <a class="ae lg" href="https://blackbelt.analyticsvidhya.com/accelerate?utm_source=blog&amp;utm_medium=the-ultimate-swiss-army-knife-of-apply-family-in-r" rel="noopener ugc nofollow" target="_blank"> <em class="lf">认证AI &amp; ML黑带加速</em> </a> <em class="lf">计划。</em></p><h1 id="172a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">目录</h1><p id="2e82" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">该系列中的各种功能包括:</p><ul class=""><li id="83ef" class="jc jd hh je b jf ko jh kp jj lh jl li jn lj jp jq jr js jt bi translated">应用</li><li id="8550" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">拉普利</li><li id="73eb" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">伤感的</li><li id="a2e4" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">vapply</li><li id="231d" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">塔普利</li><li id="0998" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">地图</li></ul><h1 id="969c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">设置背景</h1><p id="907f" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">我将首先使用简单的数据集介绍上面的每个函数是如何工作的，然后我们将使用一个真实的数据集来使用这些函数。</p><p id="1437" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">所以，打开你的笔记本或R studio，让我们开始吧！</p><p id="46ff" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们不需要安装任何其他库来使用apply函数。让我们从创建一个简单的矩阵开始，矩阵中的数值从1到20分布在5行4列中:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="62dd" class="lp if hh ll b fi lq lr l ls lt">data &lt;- matrix(c(1:20), nrow = 5, ncol = 4) <br/>data</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lu"><img src="../Images/37c32e3c74fe662340e102aec24b14fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*H8GT8bVbfK73xvV7.png"/></div></figure><p id="ae0d" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">这是我们矩阵的样子。现在，让我们从apply()函数开始</p><h1 id="2ab0" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">应用()</h1><p id="ea1a" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">使用帮助部分可以获得apply()函数的一般语法。只需执行这段代码就可以获得详细的文档</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="fc06" class="lp if hh ll b fi lq lr l ls lt">?apply</span></pre><p id="141c" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们可以看到，apply函数的结构是apply(X，MARGIN，FUN，…)。这里，</p><ul class=""><li id="d592" class="jc jd hh je b jf ko jh kp jj lh jl li jn lj jp jq jr js jt bi translated">x指的是我们将要应用操作的数据集(在我们的例子中是矩阵)</li><li id="6fd2" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">MARGIN参数允许我们指定是按行还是按列应用操作(对于行，MARGIN = 1；对于列，边距= 2)</li><li id="0cae" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">FUN指的是我们想在X上‘应用’的任何用户定义的或内置的函数</li></ul><p id="8d66" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们看看计算每行平均值的简单示例:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="3df7" class="lp if hh ll b fi lq lr l ls lt">mean_rows &lt;- apply(data, 1, mean) <br/>mean_rows</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lv"><img src="../Images/95cbc3f624c021178ad9696db8ca617a.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/0*CPsg_RRRSwf6yLUr.png"/></div></figure><p id="24fa" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">这相当简单！我们可以看到如何使用apply()函数来总结我们的数据。同样，让我们试着沿着每一列寻找e和:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="eb1d" class="lp if hh ll b fi lq lr l ls lt">sum_cols &lt;- apply(data, 2, sum)<br/>sum_cols</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lw"><img src="../Images/d866dfad91c62c2845c0e2d9cfde174e.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/0*bO2TVjscfe9bl9up.png"/></div></figure><p id="15d7" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">如果我们想在所有元素上应用这个函数，我们只需像这样编写apply函数:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="a615" class="lp if hh ll b fi lq lr l ls lt">all_sqrt &lt;- apply(data, 1:2, sqrt)<br/>all_sqrt</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lx"><img src="../Images/96b2e686ed507d14d6545f0576e6c0a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:714/format:webp/0*Zaiuz-V9mpwu5yxT.png"/></div></figure><p id="460b" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">如果我们想对数据应用用户定义的函数，该怎么办？例如，我有一个函数可以为每一行找到(x-1)的平方根:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="66a1" class="lp if hh ll b fi lq lr l ls lt">fn = function(x) { return(sqrt(x - 1)) }</span></pre><p id="9027" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">然后，我们对每一行应用该函数:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="90c1" class="lp if hh ll b fi lq lr l ls lt">apply(data, 1, fn)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ly"><img src="../Images/6a3bf18f46fa21c7299a687efedef455.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/0*YQkN1RKowotXPpY3.png"/></div></figure><p id="963c" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">到目前为止，我们已经使用了只有一个参数的函数，并将它们应用于数据。apply系列最好的一点是，它们还可以处理具有多个参数的函数！让我们应用一个带有3个参数的用户定义函数:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="86ae" class="lp if hh ll b fi lq lr l ls lt">fn = function(x1, x2, x3) { return(x1^2 + x2 * x1 + x3) }</span></pre><p id="9cea" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们将x1作为“数据”中的每个值，将x2、x3作为其他参数，这些参数将首先声明，然后通过apply函数传递:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="587d" class="lp if hh ll b fi lq lr l ls lt">b = 2<br/>c = 1 <br/># apply along each row:<br/>row_fn &lt;- apply(data, 1, fn, x2 = b, x3 = c)<br/># apply along each column:<br/>col_fn &lt;- apply(data, 2, fn, x2 = b, x3 = c)</span></pre><p id="d7af" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们检查row_fn和col_fn</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="2eb7" class="lp if hh ll b fi lq lr l ls lt">row_fn</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lz"><img src="../Images/819e0d6e43a92be496f74fba6fb25e16.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/0*TYsIG046XlZkampp.png"/></div></figure><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="82a4" class="lp if hh ll b fi lq lr l ls lt">col_fn</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ma"><img src="../Images/bb7030570a6bc10daa2906f62bc8fc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:366/format:webp/0*bIfu2q5vaLJ8ruOx.png"/></div></figure><p id="dbb0" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">apply()系列的其余部分遵循类似的结构，具有类似的参数，只是有一些变化。接下来让我们使用lapply()函数。</p><h1 id="35c5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">拉普利()</h1><p id="bfdb" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">上面的apply()函数有一个约束条件，即数据必须是一个至少二维的矩阵，才能对其执行apply()函数。lapply()函数消除了这个约束。list-apply的缩写，可以在list或vector上使用lapply函数。无论是一个向量列表还是一个简单的向量，lapply()都可以使用。因为我们现在处理的是向量/列表，所以lapply函数也不需要MARGIN参数。也就是说，lapply的返回类型也是list。</p><p id="5b92" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">它只将数据和函数作为基本参数:</p><p id="e987" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">lapply(X，FUN)</p><p id="45a6" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们看一些例子:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="ad99" class="lp if hh ll b fi lq lr l ls lt"># define a list<br/>cart &lt;- c("BREAD","BUTTER","MILK","COOKIES")<br/><br/># use lapply to convert all to lower case<br/>cart_lower &lt;- lapply(cart, tolower)<br/><br/>#output<br/>cart_lower</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mb"><img src="../Images/f7a03f84fda11f1f9912e6d4d5c4de47.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/0*pYmB1qHpNtrBE6Yk.png"/></div></figure><p id="7c4a" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们现在来看一个更复杂的列表:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="0502" class="lp if hh ll b fi lq lr l ls lt">data &lt;- list(l1 = c(1, 2, 3, 4),<br/>             l2 = c(5, 6, 7, 8),<br/>             l3 = c(9, 10, 11, 12))<br/><br/># apply the 'sum' function on data:<br/>sum_list &lt;- lapply(data, sum)<br/><br/>#output<br/>sum_list</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lu"><img src="../Images/f638d8eebb2f17014ac040f50ca5ca02.png" data-original-src="https://miro.medium.com/v2/resize:fit:260/format:webp/0*Gzx49o33_GRhs4K6.png"/></div></figure><h1 id="a95e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">萨普利()</h1><p id="0501" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">sapply()函数(简化应用的缩写)类似于lapply函数。唯一的区别是输出的返回类型——s apply()根据返回值简化了输出。我创建了一个简单的表，告诉我们返回的是什么类型:</p><p id="ab67" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们将看到上述所有场景的示例:</p><h2 id="ef04" class="lp if hh bd ig mc md me ik mf mg mh io jj mi mj is jl mk ml iw jn mm mn ja mo bi translated">场景1:每个元素的长度= 1</h2><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="7c81" class="lp if hh ll b fi lq lr l ls lt">data &lt;- list(l1 = c(1, 2, 3, 4))<br/><br/># apply the 'sum' function on data:<br/>sum_sapply1 &lt;- sapply(data, sum)<br/><br/>#output<br/>sum_sapply1</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mp"><img src="../Images/2940934271121110ef224afb1d96a365.png" data-original-src="https://miro.medium.com/v2/resize:fit:166/format:webp/0*JYYE6-OZHxY4g2Ow.png"/></div></figure><p id="1fe3" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">使用lapply查看输出差异:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="e30e" class="lp if hh ll b fi lq lr l ls lt">sum_lapply1 &lt;- lapply(data, sum) sum_lapply1</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mq"><img src="../Images/abdf530754dc35645f6f5fff24be1a8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:190/format:webp/0*WHvtxmb8DH2P0szC.png"/></div></figure><h2 id="b143" class="lp if hh bd ig mc md me ik mf mg mh io jj mi mj is jl mk ml iw jn mm mn ja mo bi translated">场景2:每个元素的长度&gt; 1且相同</h2><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="53cd" class="lp if hh ll b fi lq lr l ls lt">sum_lapply1 &lt;- lapply(data, sum)<br/>sum_lapply1</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mr"><img src="../Images/d8bc94b6bf317ad528e5f17212c9003c.png" data-original-src="https://miro.medium.com/v2/resize:fit:336/format:webp/0*Kx7aA5apfSicamJ1.png"/></div></figure><p id="df1a" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">lapply()给了我们什么输出？</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="35a6" class="lp if hh ll b fi lq lr l ls lt">sum_lapply2 &lt;- lapply(data, sum)<br/>sum_lapply2</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ms"><img src="../Images/1df312370242885ac9d14de0c79b1d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:208/format:webp/0*0M-f4c-SWW1-17RX.png"/></div></figure><h2 id="b446" class="lp if hh bd ig mc md me ik mf mg mh io jj mi mj is jl mk ml iw jn mm mn ja mo bi translated">场景3:每个元素的长度&gt; 1且不同</h2><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="e9f4" class="lp if hh ll b fi lq lr l ls lt">data &lt;- list(l1 = c(1, 2, 3),<br/>l2 = c(5, 6, 7, 8),<br/>l3 = c(9, 10))<br/><br/># apply the 'sum' function on data:<br/>sum_sapply3 &lt;- sapply(data, sum)<br/><br/>#output<br/>sum_sapply3</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mt"><img src="../Images/aa231c1f185c999e024fcdeb24fd2c53.png" data-original-src="https://miro.medium.com/v2/resize:fit:312/format:webp/0*XWUbAxsHRFSOgl46.png"/></div></figure><p id="28ef" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们将它与lapply()在相同数据上的输出进行比较:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="3eba" class="lp if hh ll b fi lq lr l ls lt">sum_lapply3 &lt;- lapply(data, sum) </span><span id="92b7" class="lp if hh ll b fi mu lr l ls lt">#output<br/>sum_lapply3</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mv"><img src="../Images/76796d2d6b1001fede326712b4e27e89.png" data-original-src="https://miro.medium.com/v2/resize:fit:278/format:webp/0*YjkSwTFh6GiANXjQ.png"/></div></figure><h1 id="0112" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">vapply()</h1><p id="3dea" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">来到vapply()函数。lapply()、apply()和vapply()三者是专门为所有类型的向量定制的。与lapply()和sapply()为我们决定输出的数据类型不同，vapply()允许我们选择输出结构的数据类型。因此，vapply()的参数是:</p><p id="8add" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated"><strong class="je hi"> vapply(X，好玩，好玩。值)</strong></p><p id="f86b" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">这里好玩。值用于提供所需的数据类型。</p><p id="c4b7" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">当我们的列表/向量包含数字和字符串的混合时，这是最有用的:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="dde1" class="lp if hh ll b fi lq lr l ls lt">data &lt;- list(l1 = c(1, 2, 3, 4),<br/>             l2 = c(5, 6, 7, 8),<br/>             l3 = c(9, 10, 11, 12),<br/>             l4 = c("a", "b", "c", "a"))<br/><br/># apply the 'max' function on data:<br/>sum_vapply &lt;- vapply(data, max, numeric(1))</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mw"><img src="../Images/85b438c83626d73df452c3ac3e727844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UlyhgJr79uJXS0sF.png"/></div></div></figure><p id="2aa0" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">不出所料，我们得到了一个错误，因为不可能从字符列表中计算最大值。numeric(1)指定我们希望输出为单个数值，其中每个元素的长度为1。如果我们用lapply()或者sapply()会怎么样？</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="e586" class="lp if hh ll b fi lq lr l ls lt">lapply(data, max)<br/>sapply(data, max)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mx"><img src="../Images/8a4eb032733695f5267df9ae4b79e98f.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*YuJkrK3-u1yJlwRqEO44qw.png"/></div></figure><p id="ceca" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">因此，我们可以看到lapply()和sapply()实际上为相同的。事实上，sapply()甚至将输出转换为character类型的向量。理想情况下，这不是我们想要的。一般来说，这就是我们使用vapply()函数的方式</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="2e97" class="lp if hh ll b fi lq lr l ls lt">data &lt;- list(l1 = c(1, 2, 3, 4),<br/>             l2 = c(5, 6, 7, 8),<br/>             l3 = c(9, 10, 11, 12),<br/>             l4 = c("a", "b", "c", "a"))<br/><br/># apply the 'max' function on data:<br/>sum_vapply &lt;- vapply(data, max, numeric(1))</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es my"><img src="../Images/901f8f51bd2f023cb3f44796cf13892a.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/0*GR0Ju83mm-LhbKq9.png"/></div></figure><p id="1482" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">因此，在处理具有不同要素数据类型的数据框时，使用vapply()总是更好。</p><h1 id="f2e4" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">塔普利()</h1><p id="5b71" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">用最简单的话来说，tapply()允许我们将数据分组，并对每个组执行操作。因此，当您提供一个向量作为输入时，tapply()对向量的每个子集执行指定的操作。它需要的参数是:</p><p id="7a44" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated"><strong class="je hi"> tapply(X，INDEX，FUN) </strong></p><p id="f340" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">其中INDEX表示要用于分隔数据的因子。听起来很熟悉？是的，tapply()只是一个简单的方法来执行分组操作，并对分组数据应用一些函数！</p><p id="ed2f" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">为了观察tapply()如何工作，让我们创建两个简单的向量</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="09d8" class="lp if hh ll b fi lq lr l ls lt">item_cat &lt;- c("HOME", "SNACKS", "BEVERAGE", "STORAGE", "CLEANING", "STORAGE", "HOME", "BEVERAGE", "ELECTRONICS", "SNACKS")</span><span id="a10b" class="lp if hh ll b fi mu lr l ls lt">item_qty &lt;-c(25, 30, 45, 66, 15, 50, 35, 20, 15, 35)</span></pre><p id="5819" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在让我们使用tapply来获得每个项目类别的平均数量:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="4d7a" class="lp if hh ll b fi lq lr l ls lt">tapply(item_qty, item_cat, mean)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mz"><img src="../Images/d95fabf364a34e14ecd36f237beb13bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/0*UXJZcOVBbRzm0Mz3.png"/></div></figure><p id="e9ff" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">tapply()函数做了什么？我们按照item_cat向量对item_qty向量进行分组，以创建向量的子集。然后我们计算每个子集的平均值。</p><p id="cd1d" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">使用tapply()之所以如此简单，是因为它自动从item_cat向量中获取唯一值，并几乎立即对数据应用我们想要的函数。我们甚至可以在每个子集上获得多个值:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="28bb" class="lp if hh ll b fi lq lr l ls lt">tapply(item_qty, item_cat, function(x) c(mean(x), sum(x)))</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es na"><img src="../Images/cb2b65828481d0c5bd85fa19508af196.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/format:webp/0*tVYtitbk18klKEwW.png"/></div></figure><p id="e848" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，我们来看apply()函数族中的最后一个函数mapply()函数。</p><h1 id="887c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">地图应用()</h1><p id="e6d8" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">mapply()代表多元应用，基本上是sapply()的多元版本。mapply函数最好通过例子来解释——所以让我们先使用它，然后试着理解它是如何工作的。</p><p id="5a49" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们首先来看一个函数，它通常不接受2个列表或2个向量作为参数——例如，max函数。我们先看两个列表:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="67a8" class="lp if hh ll b fi lq lr l ls lt">list1 &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))</span><span id="5815" class="lp if hh ll b fi mu lr l ls lt">list2 &lt;- list(a = c(10, 11, 12), b = c(13, 14, 15), c = c(16, 17, 18))</span></pre><p id="bb5d" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，如果我们想找到每对列表元素之间的最大值呢？</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="7c83" class="lp if hh ll b fi lq lr l ls lt">max(list1$a, list2$a)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es nb"><img src="../Images/c73fb19e587c44343a17bbfb84017048.png" data-original-src="https://miro.medium.com/v2/resize:fit:304/format:webp/0*SJ7I_3jgWO_jyTw6.png"/></div></figure><p id="043a" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，这个函数不能同时应用于list1和list2的所有元素。在这种情况下，我们使用mapply()函数:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="daa3" class="lp if hh ll b fi lq lr l ls lt">mapply(function(num1, num2) max(c(num1, num2)), list1, list2)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es nc"><img src="../Images/a1bc45e206bbf6b701edfd285064360f.png" data-original-src="https://miro.medium.com/v2/resize:fit:264/format:webp/0*L0VOmNxH3rn7rTA3.png"/></div></figure><p id="09cc" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">因此，mapply函数用于对通常不接受多个列表/向量作为参数的数据执行函数。当您想要创建新列时，它也很有用。让我们首先从我们最初定义的矩阵创建一个数据帧:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="fbc0" class="lp if hh ll b fi lq lr l ls lt">df &lt;- as.data.frame(data)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es nd"><img src="../Images/980c0f7ad59895c61a8095a5ec430c56.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/0*zY9t7il5xRtA6J29.png"/></div></figure><p id="cbdb" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们现在将创建一个新变量，它包含列V1和V3的乘积:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="77de" class="lp if hh ll b fi lq lr l ls lt">mapply(function(x, y) x/y, df$V1, df$V3)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ne"><img src="../Images/bda5e04f611bb664b032929cbbe1c1c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/0*jslxI15_OIufIRax.png"/></div></figure><p id="b597" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">因此，我们看到在处理数据框时，mapply是一个非常方便的功能。</p><p id="b545" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，让我们看看如何在真实数据集上使用这些函数。为简单起见，我们来看看虹膜数据集:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="10e4" class="lp if hh ll b fi lq lr l ls lt">iris_df&lt;-datasets::iris head(iris_df)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es nf"><img src="../Images/eda7842825b90d76968ca1803b7452b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1188/format:webp/0*LmLzo5XS7RY4RVPI.png"/></div></figure><p id="6b10" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们现在可以使用apply()函数计算每行的萼片长度和萼片宽度的平均值:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="20b7" class="lp if hh ll b fi lq lr l ls lt">iris_df['Sepal_mean'] &lt;- apply(iris_df[c("Sepal.Length", "Sepal.Width")], 1, mean)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ng"><img src="../Images/44a7bde38d8beed28962e45659e8da85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nw03FycXrR1DnZeW.png"/></div></div></figure><p id="4702" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">类似地，我们可以获得数据框架中每个物种的每个列的汇总值:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="2809" class="lp if hh ll b fi lq lr l ls lt">tapply(iris_df$Sepal.Width, iris_df$Species, mean)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es nh"><img src="../Images/4268c56069a4f33a833220d76fa3a88f.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/0*KpKqZdER9MoyLPk2.png"/></div></figure><p id="435a" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我们还可以使用mapply()函数创建一个显示花瓣长度和花瓣宽度之和的新列:</p><pre class="ku kv kw kx fd lk ll lm ln aw lo bi"><span id="8c45" class="lp if hh ll b fi lq lr l ls lt">iris_df['Sum_Petal'] &lt;- mapply(function(x, y) x+y, iris_df$Petal.Length, iris_df$Petal.Width)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ni"><img src="../Images/2d0a63a0bfedb86fa75068cd2d53a0fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WtKLsU-9r1elMkrn.png"/></div></div></figure><h1 id="1e73" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结束注释</h1><p id="8fa7" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">到目前为止，我们已经学习了r中apply()函数族中的各种函数。这些函数集提供了在瞬间对数据应用各种操作的极其有效的方法。本文涵盖了这些函数的基础知识，目的是让您理解这些函数是如何工作的。</p><p id="9535" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">我鼓励你在更复杂的数据集上尝试更复杂的函数，以充分理解这些函数有多有用。这些函数对您在R中处理数据集有什么帮助？请在下面分享你的回复和任何问题！</p><p id="ae93" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">您也可以在我们的移动应用程序上阅读这篇文章</p></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="f905" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated"><em class="lf">原载于2021年2月11日</em><a class="ae lg" href="https://www.analyticsvidhya.com/blog/2021/02/the-ultimate-swiss-army-knife-of-apply-family-in-r/" rel="noopener ugc nofollow" target="_blank"><em class="lf">【https://www.analyticsvidhya.com】</em></a><em class="lf">。</em></p></div></div>    
</body>
</html>