<html>
<head>
<title>Rising Heat in the City — A Machine Learning Problem</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">城市升温——一个机器学习问题</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/rising-heat-in-the-city-a-machine-learning-problem-4e40c0974c4d?source=collection_archive---------18-----------------------#2021-03-09">https://medium.com/analytics-vidhya/rising-heat-in-the-city-a-machine-learning-problem-4e40c0974c4d?source=collection_archive---------18-----------------------#2021-03-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4c42" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近，我参加了由特里希(NITT)国家理工学院计算机科学与工程(CSE)系组织的机器学习竞赛。这是一场名为Data Crunch的<a class="ae jc" href="https://www.hackerearth.com/datacrunch-vortex" rel="noopener ugc nofollow" target="_blank">比赛</a>，我们得到了一个<a class="ae jc" href="https://he-s3.s3.ap-southeast-1.amazonaws.com/media/hackathon/datacrunch-vortex/test-40/0c4d3086-7-25871c56-7-dataset.zip?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;X-Amz-Expires=3600&amp;X-Amz-SignedHeaders=host&amp;X-Amz-Signature=d81c7b6903922c4c4b71de358cf445ec7cd5755a85386726ee1499e74de0bcb8&amp;X-Amz-Date=20210308T064136Z&amp;X-Amz-Credential=AKIA6I2ISGOYH7WWS3G5%2F20210308%2Fap-southeast-1%2Fs3%2Faws4_request" rel="noopener ugc nofollow" target="_blank">数据集</a>，我们必须使用机器学习模型来预测“热量”变量。还提供了一个测试集来进行一些预测并提交它们。这些提交的正确性基于R2分数来判断。在这篇文章中，我将谈谈我是如何处理这个问题的，并概述我对这个问题的解决方案。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/f341af58e637d6208f90495dcc976081.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*TWHB12sV5ppa-HE6.jpg"/></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">图片:<a class="ae jc" href="https://timesofindia.indiatimes.com/city/chennai/hot-days-ahead-for-chennai-to-last-till-weekend/articleshow/73716720.cms" rel="noopener ugc nofollow" target="_blank">印度时报</a></figcaption></figure><p id="9966" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将从竞赛链接中的确切问题陈述开始。声明如下:</p><p id="59d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jp">“jaya VI在这座城市里四处走动，她觉得夏天即将来临，这座城市需要为越来越热的天气做好准备。因此，她决定使用提供给她的数据建立一个模型，根据数据集中的给定因素预测热量。帮助她建立模型。</em></p><p id="eddd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jp">数据集有训练和测试数据集。在训练数据集上训练您的模型，并在测试数据集上运行它以生成提交文件。评分将基于R2分数。”</em></p><p id="e5df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我已经在介绍中链接了数据集和竞争。我们将使用Jupyter笔记本在Python 3中编写代码。让我们从导入一些库开始。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f354" class="jv jw hh jr b fi jx jy l jz ka">import pandas as pd<br/>import numpy as np</span></pre><p id="a795" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后我们用熊猫来读取数据。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="f86a" class="jv jw hh jr b fi jx jy l jz ka">data = pd.read_csv("/content/drive/MyDrive/Datasets/Data Crunch Vortex/TRAIN.csv")<br/>test = pd.read_csv("/content/drive/MyDrive/Datasets/Data Crunch Vortex/TEST.csv")</span></pre><p id="d5fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看训练数据集的前几列是什么样的。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="7412" class="jv jw hh jr b fi jx jy l jz ka">data.head()</span></pre><p id="9914" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kb"><img src="../Images/122054e37292a1d2e15eab011295fd10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ecv2QCdpFQNijDzOXEL-ow.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">前几行训练数据。</figcaption></figure><p id="8a0e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到我们的目标变量<strong class="ig hi">热量</strong>。我们还将其他因素定义如下:</p><ul class=""><li id="f47f" class="kg kh hh ig b ih ii il im ip ki it kj ix kk jb kl km kn ko bi translated"><strong class="ig hi"> idx </strong>:每次观察的Id。</li><li id="2463" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi"> UNIXTime </strong>:指定特定的时刻。具体来说，它是自1970–01–01 00:00:00 GMT以来经过的秒数。在该数据集中，观测时间为格林威治时间1970–01–01 00:00:00。</li><li id="d710" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">数据</strong>:指定观察的日期。</li><li id="eb87" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">时间</strong>:指定一天中进行观测的时间。</li><li id="2e73" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">湿度</strong>:湿度是空气中水蒸气含量的量度。</li><li id="28b3" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">温度</strong>:观察时记录的温度。</li><li id="2816" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">压力:</strong>是观察时记录的压力。</li><li id="a28c" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi"> WindDegree </strong>:指定观测时的风向。</li><li id="1e04" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">风速</strong>:表示观测时的风速。</li><li id="fc1d" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">日出时间</strong>:观察日出的时间。</li><li id="3036" class="kg kh hh ig b ih kp il kq ip kr it ks ix kt jb kl km kn ko bi translated"><strong class="ig hi">日落时间</strong>:观察到日落的时间。</li></ul><p id="f53a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将继续对这些数据进行一些基本的观察。让我们从任何缺失的值开始。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8027" class="jv jw hh jr b fi jx jy l jz ka">data.isnull().mean()</span></pre><p id="273b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="940c" class="jv jw hh jr b fi jx jy l jz ka">idx            0.0<br/>UNIXTime       0.0<br/>Data           0.0<br/>Time           0.0<br/>Heat           0.0<br/>Temperature    0.0<br/>Pressure       0.0<br/>Humidity       0.0<br/>WindDegrees    0.0<br/>WindSpeed      0.0<br/>RiseTime       0.0<br/>SetTime        0.0<br/>dtype: float64</span></pre><p id="04b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不错！所以没有丢失的值。我们来看一些数据的描述性统计。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="9825" class="jv jw hh jr b fi jx jy l jz ka">data.describe()</span></pre><p id="d2cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es ku"><img src="../Images/1a866fe32baf97a90bd3edcace76f8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiCV55XVEI5pe5ns8JJKwA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">描述统计学</figcaption></figure><p id="f2db" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到数据集有26，149个观察值。还可以观察到其他细节，如平均值、第25百分位、最小值和最大值。让我们检查每个变量的数据类型。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5bdc" class="jv jw hh jr b fi jx jy l jz ka">data.dtypes</span></pre><p id="a697" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="6c1b" class="jv jw hh jr b fi jx jy l jz ka">idx              int64<br/>UNIXTime         int64<br/>Data            object<br/>Time            object<br/>Heat           float64<br/>Temperature      int64<br/>Pressure       float64<br/>Humidity         int64<br/>WindDegrees    float64<br/>WindSpeed      float64<br/>RiseTime        object<br/>SetTime         object<br/>dtype: object</span></pre><p id="b54f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在数据的前几行中，我们可以观察到观察时间是以UNIX时间和24小时制表示的。他们可能来自不同的时区。让我们看看我们是不是对的。为此，我们必须从数据列中提取日期，并将其与时间列相结合，以获得UTC格式的观测时间。然后我们必须从UNIX时间中减去这个时间(转换成UTC格式)。如果差值为零，则所有观测都是在同一时区进行的，即GMT(在这种情况下)。我们将创建数据的副本，以避免更改原始数据。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="14f4" class="jv jw hh jr b fi jx jy l jz ka">temp = data.copy()<br/>temp[['Date','Midnight','AM or PM']] = temp['Data'].str.split(' ',expand=True)<br/>temp['Data'] = pd.to_datetime(temp['Date'] + ' ' + temp['Time'])<br/>temp['UNIXTimeDate'] = pd.to_datetime(temp['UNIXTime'],unit='s')<br/>temp['ZoneDiff'] = temp['UNIXTimeDate'] - temp['Data']<br/>temp.head()</span></pre><p id="cfce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8e75" class="jv jw hh jr b fi jx jy l jz ka">0   0 days 10:00:00<br/>1   0 days 10:00:00<br/>2   0 days 10:00:00<br/>3   0 days 10:00:00<br/>4   0 days 10:00:00<br/>Name: ZoneDiff, dtype: timedelta64[ns]</span></pre><p id="5f27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们注意到GMT比这个时区早10个小时。因此，我们必须对观测时间、设定时间和上升时间进行时区校正。同样，处理日期列也非常困难。所以最好将它们转换成更容易处理的数据类型。在这种情况下，我们可以将日期转换成UNIX格式，这将确保我们所有的时间都是GMT格式，更重要的是，它们将是整数。我们在下面的函数中完成所有这些预处理。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8410" class="jv jw hh jr b fi jx jy l jz ka">def cleanData(temp):<br/>   temp[['Date','Midnight','AM or PM']] = temp['Data'].str.split(' ',expand=True)<br/>   temp['Data'] = pd.to_datetime(temp['Date'] + ' ' + temp['Time'])<br/>   temp['SetTime'] = pd.to_datetime(temp['Date'] + ' ' + temp['SetTime'])<br/>   temp['RiseTime'] = pd.to_datetime(temp['Date'] + ' ' + temp['RiseTime'])<br/>   temp = temp.drop(['Date','Time','Midnight','AM or PM'],axis=1)<br/>   temp['UNIXTimeDate'] = pd.to_datetime(temp['UNIXTime'],unit='s')<br/>   temp['ZoneDiff'] = temp['UNIXTimeDate'] - temp['Data']<br/>   temp['Data'] = temp['UNIXTimeDate'] - temp['ZoneDiff']<br/>   temp['SetTime'] = temp['SetTime'] + temp['ZoneDiff']<br/>   temp['RiseTime'] = temp['RiseTime'] + temp['ZoneDiff']<br/>   temp = temp.drop(['UNIXTime','ZoneDiff'],axis=1) <br/>   temp['Data'] = pd.to_datetime(temp['Data']).astype(int) / 10**9<br/>   temp['SetTime'] = pd.to_datetime(temp['SetTime']).astype(int) / 10**9<br/>   temp['UNIXTimeDate'] = pd.to_datetime(temp['UNIXTimeDate']).astype(int) / 10**9<br/>   temp['RiseTime'] = pd.to_datetime(temp['RiseTime']).astype(int) / 10**9<br/>   return temp</span><span id="c545" class="jv jw hh jr b fi kv jy l jz ka">train_clean = data.copy()<br/>train_clean = cleanData(data)<br/>train_clean.head()</span></pre><p id="10d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kw"><img src="../Images/4abcf75c30ff78ee9b9ac9f805fa8f1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dZUtCzavNtAl1g6NwxhBlw.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">已清理训练集。</figcaption></figure><p id="ef5c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的数据集现在看起来整洁多了。我们可以开始模拟我们的数据。让我们导入所需的库。我们将使用一个梯度助推器(特别是XGBoost)来建模我们的数据。梯度增强器是处理结构化数据的最佳模型之一。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="6810" class="jv jw hh jr b fi jx jy l jz ka">from sklearn.model_selection import train_test_split,RandomizedSearchCV<br/>from sklearn.preprocessing import StandardScaler,MinMaxScaler<br/>from sklearn.metrics import r2_score<br/>from sklearn.pipeline import Pipeline<br/>from xgboost import XGBRegressor</span></pre><p id="374a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将创建三个数据子集。80%用于培训，10%用于验证，10%用于测试(除了可提交的测试集)。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="004b" class="jv jw hh jr b fi jx jy l jz ka">X_train, X_test, y_train, y_test = train_test_split(train_clean.drop(['Heat','idx'],axis=1),train_clean['Heat'],test_size=0.1,random_state=42)</span><span id="6de9" class="jv jw hh jr b fi kv jy l jz ka">X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.11, random_state=42)</span><span id="a3ab" class="jv jw hh jr b fi kv jy l jz ka">X_train.head()</span></pre><p id="27f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="kc kd di ke bf kf"><div class="er es kx"><img src="../Images/dce4f488968aa6f6d9fd5a8668cb9ae7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9n0nm7QR-QcYIzY0jCdyCA.png"/></div></div><figcaption class="jl jm et er es jn jo bd b be z dx translated">训练数据。</figcaption></figure><p id="ec07" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于任何数值数据，最好对数据进行缩放，以免影响模型性能。为此，我们将使用最小最大缩放器。我们还将声明一个基本模型来进行一些预测，看看性能是否可以提高。我们将使用scikit-learn管道来完成所有这些工作。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="9c56" class="jv jw hh jr b fi jx jy l jz ka">heat_pipe = Pipeline([</span><span id="d544" class="jv jw hh jr b fi kv jy l jz ka">('scaler', MinMaxScaler()),</span><span id="75c4" class="jv jw hh jr b fi kv jy l jz ka">('model', XGBRegressor())</span><span id="da26" class="jv jw hh jr b fi kv jy l jz ka">])</span></pre><p id="eb71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们拟合我们的管道并做一些预测。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5402" class="jv jw hh jr b fi jx jy l jz ka">heat_pipe.fit(X_train,y_train)<br/>X_train_preds = heat_pipe.predict(X_train)<br/>X_val_preds = heat_pipe.predict(X_val)<br/>X_test_preds = heat_pipe.predict(X_test)<br/>print("Train R2_score: {}".format(r2_score(y_train,X_train_preds)))<br/>print("Validtation R2_score: {}".format(r2_score(y_val,X_val_preds)))<br/>print("Test R2_score: {}".format(r2_score(y_test,X_test_preds)))</span></pre><p id="e144" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="5f2b" class="jv jw hh jr b fi jx jy l jz ka">Train R2_score: 0.7713148026068124<br/>Validtation R2_score: 0.7629794446793128<br/>Test R2_score: 0.7561512410326393</span></pre><p id="618a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于一个基本模型来说，我们的分数看起来还不错。但正如他们所说，如果有改进的空间，不要退而求其次:)。</p><p id="5c49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将尝试调整我们的模型，并创建一些新的功能，这可能有助于我们获得更好的结果。现在在这个结合点上，我想提一下，特征工程是基于直觉和领域知识的。没有硬性规定。有一些像<a class="ae jc" href="https://www.featuretools.com/" rel="noopener ugc nofollow" target="_blank"> featuretools </a>这样的工具，可以通过在列之间执行所有可能的操作来帮助您稍微自动化这个过程。如果你想探索更多关于featuretools的东西，我建议你去看看这篇<a class="ae jc" href="https://www.analyticsvidhya.com/blog/2018/08/guide-automated-feature-engineering-featuretools-python/" rel="noopener ugc nofollow" target="_blank">的帖子</a>。这篇文章非常详细，涉及了featuretools的使用。</p><p id="b2a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是说，使用您的领域知识创建的功能几乎总是会给出更好的结果。所以，我建议花点时间更好地理解你的变量，这样你就可以使用它们创建更好的特性。</p><p id="a6d9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，我们可以看到我们的数据谈到了天气条件，特别是热量属性。在这里运用一点常识会告诉你，热量的多少取决于太阳升起后的时间。例如，下午比早上热。当然，我们可以利用这些信息，对吗？让我们创建一个新变量“TimeSinceSunRise”来存储太阳升起后的时间。cleanData函数修改如下:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8897" class="jv jw hh jr b fi jx jy l jz ka">def cleanData(temp):</span><span id="fb58" class="jv jw hh jr b fi kv jy l jz ka">   temp[['Date','Midnight','AM or PM']] = temp['Data'].str.split(' ',expand=True)<br/>   temp['Data'] = pd.to_datetime(temp['Date'] + ' ' + temp['Time'])<br/>   temp['SetTime'] = pd.to_datetime(temp['Date'] + ' ' + temp['SetTime'])<br/>   temp['RiseTime'] = pd.to_datetime(temp['Date'] + ' ' + temp['RiseTime'])<br/>   temp = temp.drop(['Date','Time','Midnight','AM or PM'],axis=1)<br/>   temp['UNIXTimeDate'] = pd.to_datetime(temp['UNIXTime'],unit='s')<br/>   temp['ZoneDiff'] = temp['UNIXTimeDate'] - temp['Data']<br/>   temp['Data'] = temp['UNIXTimeDate'] - temp['ZoneDiff']<br/>   temp['SetTime'] = temp['SetTime'] + temp['ZoneDiff']<br/>   temp['RiseTime'] = temp['RiseTime'] + temp['ZoneDiff']<br/>   temp = temp.drop(['UNIXTime','ZoneDiff'],axis=1) <br/>   temp['Data'] = pd.to_datetime(temp['Data']).astype(int) / 10**9<br/>   temp['SetTime'] = pd.to_datetime(temp['SetTime']).astype(int) / 10**9<br/>   temp['UNIXTimeDate'] = pd.to_datetime(temp['UNIXTimeDate']).astype(int) / 10**9<br/>   temp['RiseTime'] = pd.to_datetime(temp['RiseTime']).astype(int) / 10**9<br/>   temp['TimeSinceSunRise'] = temp['RiseTime'] - temp['Data']<br/>   return temp</span></pre><p id="ce06" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用它来清理我们的训练数据，并如上所述对其建模。对这个新数据集进行预测会得到以下结果。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="ee76" class="jv jw hh jr b fi jx jy l jz ka">Train R2_score: 0.8975578362931129<br/>Validtation R2_score: 0.8889480708391524<br/>Test R2_score: 0.8849217036129068</span></pre><p id="4722" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">哇哦。我们的R2分数有了巨大的提升！看起来我们的特色“日出时间”帮助我们的模型做出了非常好的预测！</p><p id="ef1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们不要就此打住！我们可以通过调整模型的参数来进一步改善这一点。XGBoost有很多可以调优的超参数。我们将重点关注其中的五个，并对它们进行如下调整:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="da09" class="jv jw hh jr b fi jx jy l jz ka">params={<br/>"learning_rate": [0.1, 0.01 ,0.001],<br/>"n_estimators": [100,250,500,1000],<br/>"gamma" : [0.01, 0.1, 0.3, 0.5, 1, 1.5, 2],<br/>"max_depth": [2,4,7,10],<br/>"min_child_weight" : [1,3,5,7]<br/>}<br/>model = XGBRegressor()<br/>xgb_rscv = RandomizedSearchCV(model, param_distributions=params, scoring='r2', cv=10, verbose=3, random_state=42)<br/>model_xgboost=xgb_rscv.fit(X_train,y_train)</span><span id="b8ed" class="jv jw hh jr b fi kv jy l jz ka">print("Learning Rate: ", model_xgboost.best_estimator_.get_params()["learning_rate"])</span><span id="5e57" class="jv jw hh jr b fi kv jy l jz ka">print("Gamma: ", model_xgboost.best_estimator_.get_params()["gamma"])</span><span id="fdc0" class="jv jw hh jr b fi kv jy l jz ka">print("Max Depth: ", model_xgboost.best_estimator_.get_params()["max_depth"])</span><span id="4de7" class="jv jw hh jr b fi kv jy l jz ka">print("Minimum Sum of the Instance Weight Hessian to Make a Child: ",model_xgboost.best_estimator_.get_params()["min_child_weight"])</span><span id="5b5b" class="jv jw hh jr b fi kv jy l jz ka">print("Number of Trees: ", model_xgboost.best_estimator_.get_params()["n_estimators"])</span></pre><p id="e46b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="35af" class="jv jw hh jr b fi jx jy l jz ka">Learning Rate: 0.1<br/>Gamma: 0.5<br/>Max Depth: 10<br/>Minimum Sum of the Instance Weight Hessian to Make a Child: 1<br/>Number of Trees: 100</span></pre><p id="d99d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们将这些值插入管道，看看会得到什么结果。</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="c6df" class="jv jw hh jr b fi jx jy l jz ka">heat_pipe = Pipeline([</span><span id="086d" class="jv jw hh jr b fi kv jy l jz ka">('scaler', MinMaxScaler()),</span><span id="302c" class="jv jw hh jr b fi kv jy l jz ka">('model', XGBRegressor(n_estimators=100, gamma=0.5,</span><span id="1d3c" class="jv jw hh jr b fi kv jy l jz ka">learning_rate=0.1, max_depth=10,</span><span id="9b39" class="jv jw hh jr b fi kv jy l jz ka">min_child_weight=1))</span><span id="78ce" class="jv jw hh jr b fi kv jy l jz ka">])</span><span id="af59" class="jv jw hh jr b fi kv jy l jz ka">heat_pipe.fit(X_train,y_train)<br/>X_train_preds = heat_pipe.predict(X_train)<br/>X_val_preds = heat_pipe.predict(X_val)<br/>X_test_preds = heat_pipe.predict(X_test)<br/>print("Train R2_score: {}".format(r2_score(y_train,X_train_preds)))<br/>print("Validtation R2_score: {}".format(r2_score(y_val,X_val_preds)))<br/>print("Test R2_score: {}".format(r2_score(y_test,X_test_preds)))</span></pre><p id="4d43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到以下输出:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="9967" class="jv jw hh jr b fi jx jy l jz ka">Train R2_score: 0.9908897998162235<br/>Validtation R2_score: 0.941652850962926<br/>Test R2_score: 0.9312753509058348</span></pre><p id="02b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">瞧啊。这进一步将我们在测试集上的分数提高到0.93，在验证集上的分数提高到0.94。也许我们可以进一步提高我们的成绩，但那是以后的事了。:)</p><p id="1295" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了对竞赛中提交的测试集进行预测，我们可以执行以下操作:</p><pre class="je jf jg jh fd jq jr js jt aw ju bi"><span id="8b06" class="jv jw hh jr b fi jx jy l jz ka">submission = test_clean.drop(['idx'],axis=1)<br/>X_submission_preds = heat_pipe.predict(submission)<br/>submission_df = pd.DataFrame(X_submission_preds)<br/>submission_df.rename(columns={0 : "Heat"},inplace=True)<br/>submission_df['idx'] = test_clean['idx']<br/>submission_df = submission_df[['idx','Heat']]<br/>submission_df.to_csv("/content/drive/MyDrive/Datasets/Data Crunch Vortex/submission_1.csv",index=False)</span></pre><p id="c305" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建的CSV文件可以提交给比赛，以获得我们的表现得分。</p><p id="dd39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们分析了提供给我们的数据集，并对其进行了一些很好的预测。谢谢你坚持到这里！干杯！回头见！</p></div></div>    
</body>
</html>