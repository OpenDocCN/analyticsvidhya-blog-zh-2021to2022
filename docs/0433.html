<html>
<head>
<title>How many patterns are there to lock your android smartphone?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有多少种模式可以锁住你的安卓智能手机？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-many-patterns-are-there-to-lock-your-android-smartphone-8af69256eca?source=collection_archive---------14-----------------------#2021-01-16">https://medium.com/analytics-vidhya/how-many-patterns-are-there-to-lock-your-android-smartphone-8af69256eca?source=collection_archive---------14-----------------------#2021-01-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="fb10" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">android锁屏机制分析</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/839dc1c075270db29f2bc6c2045693b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IxhdaQXsLedbib9idwkXtQ.jpeg"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">照片由<a class="ae jm" href="https://www.pexels.com/@brett-sayles?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jn">布雷特·赛勒斯</strong> </a>发自<a class="ae jm" href="https://www.pexels.com/photo/black-combination-alarm-system-1990764/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"> <strong class="bd jn">佩克斯</strong> </a></figcaption></figure><p id="ea23" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">如果你有一部安卓智能手机，你应该很熟悉你选择用来锁定手机的模式。每次，你拿起手机，机械地在屏幕上画出这些线，将点连接起来，形成解锁图案。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es kk"><img src="../Images/53560d19a5de8efa64726f0adf3a2b8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*lwDH-QD3gInrINpbm_O9Nw.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">安卓锁屏</figcaption></figure><p id="1094" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">这种锁定机制比使用数字序列(如PIN)更直观，但也有缺点，因为研究论文显示了如何有效地猜测解锁模式</p><ul class=""><li id="b3d4" class="kl km hh jq b jr js ju jv jx kn kb ko kf kp kj kq kr ks kt bi translated">人们通常使用从左上角开始的解锁模式。这种假设大大减少了攻击者的搜索空间</li><li id="2588" class="kl km hh jq b jr ku ju kv jx kw kb kx kf ky kj kq kr ks kt bi translated">你手指上油渍留下的痕迹，因为这是你最常画的图案</li></ul><p id="6baf" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">这两种对锁机制的攻击通常被称为<em class="kz">启发式攻击</em>和<em class="kz">涂抹攻击</em><a class="ae jm" href="https://dl.acm.org/doi/abs/10.1145/2462096.2462098" rel="noopener ugc nofollow" target="_blank">【1】</a><a class="ae jm" href="https://www.emerald.com/insight/content/doi/10.1108/ICS-01-2015-0001/full/html" rel="noopener ugc nofollow" target="_blank">【2】</a><a class="ae jm" href="https://www.usenix.org/legacy/event/woot10/tech/full_papers/Aviv.pdf" rel="noopener ugc nofollow" target="_blank">【3】</a>。</p><p id="0f1d" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">现在的问题是有多少种解锁模式，真的吗？389,112.</p><p id="8c11" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">好吧，等等。这个数字来自<a class="ae jm" href="https://www.usenix.org/legacy/event/woot10/tech/full_papers/Aviv.pdf" rel="noopener ugc nofollow" target="_blank">这篇研究论文</a>【3】。但是，现在我们的目标是验证这一点！</p><h1 id="1c22" class="la lb hh bd jn lc ld le lf lg lh li lj in lk io ll iq lm ir ln it lo iu lp lq bi translated">有效模式的规则</h1><p id="4e60" class="pw-post-body-paragraph jo jp hh jq b jr lr ii jt ju ls il jw jx lt jz ka kb lu kd ke kf lv kh ki kj ha bi translated">正如本文 [3]中所解释的，有效模式有三个简单的规则</p><ol class=""><li id="5a1a" class="kl km hh jq b jr js ju jv jx kn kb ko kf kp kj lw kr ks kt bi translated">该模式必须连接至少四个点</li><li id="762f" class="kl km hh jq b jr ku ju kv jx kw kb kx kf ky kj lw kr ks kt bi translated">在模式中，一个点最多只能使用一次</li><li id="839e" class="kl km hh jq b jr ku ju kv jx kw kb kx kf ky kj lw kr ks kt bi translated">除非之前已经连接过，否则中间点会成为接触点</li></ol><p id="e5b2" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">规则1和2意味着图案中至少应该有一个方向变化，所以你不能有像直线一样明显的图案。然而，规则3是最有趣的，因为…对不起什么？哦，别担心！这也是一个简单的规则，这里有一个图解说明。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lx"><img src="../Images/b44f7ae53d2559b47dbe570706e8554d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*Dc3kx-Sbng6ecBarmn4y7Q.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">有效和无效模式的示例。不连接先前未连接的点，你就不能穿越。</figcaption></figure><p id="43fa" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">该规则告诉你必须始终包括你在路上穿过的点，除非它们之前已经被包括在内。这就是我所说的“中间”点。现在，这个规则有趣的部分在于它使得数学推导可能模式的数量变得多么复杂。</p><h1 id="beaf" class="la lb hh bd jn lc ld le lf lg lh li lj in lk io ll iq lm ir ln it lo iu lp lq bi translated">数学解析尝试</h1><p id="0a45" class="pw-post-body-paragraph jo jp hh jq b jr lr ii jt ju ls il jw jx lt jz ka kb lu kd ke kf lv kh ki kj ha bi translated">我们先忽略规则3。通过这种简化，连接<em class="kz"> k </em>点的模式等同于从所有九个可用点中选取的那些<em class="kz"> k </em>点的排列。通过从包含9个点的袋中依次选择k个点<em class="kz">来获得排列。不同排列的数量是</em></p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/a32610e2e11289c7b991c4b47962c12c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bxmd5yTMzcvYEM46k02VLQ.png"/></div></div></figure><p id="077c" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">然后，我们可以通过将所有具有4个或更多点的模式相加，得出模式的总数(规则1)。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/a60b3cc65b4c873a84f73a50d48dabdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NAt1S3jfaN_SDRjYN-GkUw.png"/></div></div></figure><p id="d6fa" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">现在让我们考虑规则3，想想它改变了什么。我们现在必须考虑应该从总数中减去的无效排列。这对于1、2或3点的模式来说是可以管理的，但是对于更长的模式来说就变得困难多了。这种复杂性可以通过使用强力算法来克服，该算法将测试所有模式并计算有效的模式。让我们使用Python代码。</p><h1 id="6b42" class="la lb hh bd jn lc ld le lf lg lh li lj in lk io ll iq lm ir ln it lo iu lp lq bi translated">程序分辨率</h1><p id="20b5" class="pw-post-body-paragraph jo jp hh jq b jr lr ii jt ju ls il jw jx lt jz ka kb lu kd ke kf lv kh ki kj ha bi translated">在我们的代码中，我们用一个数字标记每个点。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lz"><img src="../Images/45ff2ef0565d11080aad8400b8a59c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:380/format:webp/0*ffpM_JsJr81lEmoz.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">标记点</figcaption></figure><p id="7bff" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">根据这些标签，我们需要构建一个跨越中间点的连接字典。这将有助于检查规则3</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="1796" class="mf lb hh mb b fi mg mh l mi mj">INTERMEDIATE_POINT = {<br/>"13": "2",<br/>"46": "5",<br/>"79": "8",<br/><br/>"17": "4",<br/>"28": "5",<br/>"39": "6",<br/><br/>"19": "5",<br/>"37": "5"<br/>}</span></pre><p id="6cbd" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我们如何知道一个给定的模式是有效的？让我们编写一个函数来实现这个功能。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="4294" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我们已经拥有了编写主算法所需的一切。我认为使用递归函数是最自然的选择。递归有两个停止条件</p><ol class=""><li id="fd2d" class="kl km hh jq b jr js ju jv jx kn kb ko kf kp kj lw kr ks kt bi translated">如果模式无效</li><li id="c4db" class="kl km hh jq b jr ku ju kv jx kw kb kx kf ky kj lw kr ks kt bi translated">如果模式有最大长度，也就是说，它包含所有点(因为规则2)</li></ol><p id="0134" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">我们跟踪一个变量<code class="du mm mn mo mb b">count</code>来计算我们找到的有效模式的数量，并对增加了可用点中的一个点的模式进行递归调用。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mk ml l"/></div></figure><p id="afac" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">让我们运行它。</p><pre class="ix iy iz ja fd ma mb mc md aw me bi"><span id="bdb7" class="mf lb hh mb b fi mg mh l mi mj">count_patterns("", "123456789", max_length=9, min_length=4)</span></pre><p id="c515" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">这将输出389，112。这证实了论文中的结果！</p><h1 id="6c46" class="la lb hh bd jn lc ld le lf lg lh li lj in lk io ll iq lm ir ln it lo iu lp lq bi translated">规则3的影响</h1><p id="ee49" class="pw-post-body-paragraph jo jp hh jq b jr lr ii jt ju ls il jw jx lt jz ka kb lu kd ke kf lv kh ki kj ha bi translated">下面的代码演示了规则3对有效模式数的影响。我根据连接点的数量打印并绘制图案的数量。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mk ml l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mp"><img src="../Images/aee97307efa6381e468c911e2cb42b44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sc_BiOfo65cRWBybXFgaHA.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">模式和排列的数量与连接点的数量</figcaption></figure><p id="f5e8" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">[1]关于模式屏幕锁定方法和软侧信道攻击的安全性的初步研究。Panagiotis Andriotis，Theo Tryfonas，George Oikonomou，Can伊尔迪兹。2013年4月。</p><p id="1ce6" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">Android模式锁屏的可用性和安全性研究。Panagiotis Andriotis，George Oikonomou，Alexios Mylonas，Theo Tryfonas。2016年3月。</p><p id="268c" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated">[3]智能手机触摸屏上的污迹攻击，Adam J. Aviv，Katherine Gibson，Evan Mossop，Matt Blaze和Jonathan M. Smith。2010年8月。</p></div><div class="ab cl mq mr go ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ha hb hc hd he"><p id="f0d4" class="pw-post-body-paragraph jo jp hh jq b jr js ii jt ju jv il jw jx jy jz ka kb kc kd ke kf kg kh ki kj ha bi translated"><em class="kz">原载于2021年1月16日</em><a class="ae jm" href="https://adamoudad.github.io/posts/lock_pattern/" rel="noopener ugc nofollow" target="_blank"><em class="kz">https://adamoudad . github . io</em></a><em class="kz">。</em></p></div></div>    
</body>
</html>