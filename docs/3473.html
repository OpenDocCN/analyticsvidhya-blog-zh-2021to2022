<html>
<head>
<title>BRUSH UP YOUR NUMPY SKILLS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高你的数字技能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/brush-up-your-numpy-skills-936be9593fe?source=collection_archive---------9-----------------------#2021-07-02">https://medium.com/analytics-vidhya/brush-up-your-numpy-skills-936be9593fe?source=collection_archive---------9-----------------------#2021-07-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="3fef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据科学关注的是成比例的结构化数据表。scikit-learn包需要二维NumPy数组作为输入表。</p><p id="bf47" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将修改NumPy库的非常基本的概念，它可以成为更大项目中的帮手。</p><h1 id="977e" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">NumPy阵列的形状和尺寸</strong></h1><ol class=""><li id="ca6f" class="ka kb hh ig b ih kc il kd ip ke it kf ix kg jb kh ki kj kk bi translated">首先，导入NumPy:</li></ol><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b415" class="ku jd hh kq b fi kv kw l kx ky">import numpy as np</span></pre><p id="819f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.构造一个10位数的NumPy数组，相当于Python的range(15)技术:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="83c5" class="ku jd hh kq b fi kv kw l kx ky">np.arange(10)<br/> <br/>Output: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></pre><p id="01fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.只有一对括号，该数组类似于Python列表。这表明它只有一维。通过存储数组来确定形状。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2b4a" class="ku jd hh kq b fi kv kw l kx ky">array_one = np.arange(10) <br/>array_one.shape </span><span id="f33a" class="ku jd hh kq b fi kz kw l kx ky">Output: (10,)</span></pre><p id="f4a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.Shape是数组中的数据属性。在array_one中，形状是一个长度为1的元组(10)。元组的长度决定维度的数量，在这种情况下是1:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="4854" class="ku jd hh kq b fi kv kw l kx ky">array_one.ndim   #Find total number of dimensions of array_one</span><span id="57fd" class="ku jd hh kq b fi kz kw l kx ky">Output: 1</span></pre><p id="980f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.数组中有十个条目。调用整形机制来整形数组:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="a53b" class="ku jd hh kq b fi kv kw l kx ky">array_one.reshape((5,2)) </span><span id="1ae2" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[0, 1],  <br/>               [2, 3],  <br/>               [4, 5], <br/>               [6, 7],  <br/>               [8, 9]])</span></pre><p id="016a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.该数组被整形为一个5 x 2的数据项，看起来像一个列表的列表(一个类似列表的列表的三维NumPy数组)。修改未被存储。只需以下列格式保存整形后的数组:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="4142" class="ku jd hh kq b fi kv kw l kx ky">array_one = array_one.reshape((5,2))</span></pre><p id="6e88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.值得注意的是，array_one变成了二维。这是意料之中的，因为它的形状包含两个数字，类似于Python列表中的列表:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="b7bb" class="ku jd hh kq b fi kv kw l kx ky">array_one.ndim </span><span id="c411" class="ku jd hh kq b fi kz kw l kx ky">Output: 2</span></pre><h1 id="845a" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">数字广播</h1><p id="2cad" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">8.通过广播，可以给每个数组元素加任意数(取1)。请务必注意，对阵列的更新不会保存:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6cfa" class="ku jd hh kq b fi kv kw l kx ky">array_one + 1</span><span id="a087" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[ 1, 2],  <br/>               [ 3, 4], <br/>               [ 5, 6],<br/>               [ 7, 8], <br/>               [ 9, 10]])</span></pre><p id="f10b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">较短的阵列被拉伸或广播到较大的阵列上，这被称为<strong class="ig hi">【广播】</strong>。</p><p id="2ae8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">9.创建一个名为array_two的新数组。检查当您将数组本身相乘时会发生什么(这是基于元素的数组乘法，而不是矩阵乘法):</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="0e3f" class="ku jd hh kq b fi kv kw l kx ky">array_two = np.arange(10)<br/>array_two * array_two</span><span id="9a19" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</span></pre><p id="a196" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">10.每个分量都被平方了。这里，一个元素接一个元素地相乘。这里有一个稍微复杂一点的例子:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6999" class="ku jd hh kq b fi kv kw l kx ky">array_two = array_two ** 2 <br/>#Note that this is equivalent to array_two * array_two <br/>array_two = array_two.reshape((5,2)) <br/>array_two</span><span id="bf00" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[ 0, 1],  <br/>               [ 4, 9],<br/>               [16, 25], <br/>               [36, 49], <br/>               [64, 81]])</span></pre><p id="bb96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">11.让我们也修改array_one:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="f28a" class="ku jd hh kq b fi kv kw l kx ky">array_one = array_one + 1 <br/>array_one</span><span id="2134" class="ku jd hh kq b fi kz kw l kx ky">Output:array([[ 1, 2],  <br/>              [ 3, 4],  <br/>              [ 5, 6], <br/>              [ 7, 8],<br/>              [ 9, 10]])</span></pre><p id="4aa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">12.只需在两个数组之间添加一个加号，就可以逐个元素地添加array_one和array_two:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="01e5" class="ku jd hh kq b fi kv kw l kx ky">array_one + array_two </span><span id="4bbd" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[ 1, 3], <br/>               [ 7, 13],<br/>               [21, 31],<br/>               [43, 57],<br/>               [73, 91]])</span></pre><h1 id="a960" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">dtypes和NumPy数组的初始化</h1><p id="f34c" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">除了np.arange，还有各种其他方法来初始化NumPy数组:</p><p id="ec2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">13.使用np.zeros创建一个零数组。命令np.zeros((2，5))产生一个2×5的零数组:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="53a6" class="ku jd hh kq b fi kv kw l kx ky">np.zeros((2,5))</span><span id="752a" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[0., 0., 0., 0., 0.],<br/>               [0., 0., 0., 0., 0.]])</span></pre><p id="dbab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">14.使用np.ones，创建一个1的数组。要验证它们是否为NumPy整数类型，请添加一个值为np.int的dtype参数。值得注意的是，scikit-learn要求数组有np.float参数。NumPy数组中的每个元素都有一个由dtype指定的类型。数组中的每一条路都是一样的。np.int整数类型用于数组中的每个元素，如下所示:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="a915" class="ku jd hh kq b fi kv kw l kx ky">np.ones((2,5), dtype = np.int)</span><span id="1118" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[1, 1, 1, 1, 1],<br/>               [1, 1, 1, 1, 1]])</span></pre><p id="d509" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">15.要为具有特定大小和数据类型但没有特定填充值的数组分配内存，请使用np.empty:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="2ad6" class="ku jd hh kq b fi kv kw l kx ky">np.empty((2,5), dtype = np.float)</span><span id="79fb" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[0., 0., 0., 0., 0.],<br/>               [0., 0., 0., 0., 0.]])</span></pre><p id="0135" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">16.要为具有不同先前值的NumPy数组分配内存，请使用np.zeros、np.ones和np.empty。</p><h1 id="62b6" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">数字索引</h1><p id="a122" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">17.使用索引，检索二维数组的值:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="bf2c" class="ku jd hh kq b fi kv kw l kx ky">array_one[0,0] #Finds value in first row and first column</span><span id="8794" class="ku jd hh kq b fi kz kw l kx ky">Output: 1</span></pre><p id="1401" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">18.请看第一行:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="37eb" class="ku jd hh kq b fi kv kw l kx ky">array_one[0,:] </span><span id="e0f6" class="ku jd hh kq b fi kz kw l kx ky">Output: array([1, 2])</span></pre><p id="d2f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">19.现在，让我们看看第一列:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="c5da" class="ku jd hh kq b fi kv kw l kx ky">array_one[:,0] </span><span id="69db" class="ku jd hh kq b fi kz kw l kx ky">Output: array([1, 3, 5, 7, 9])</span></pre><p id="13ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">20.具体数值可以在两个轴上看到。也看看第二到第四排:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="330b" class="ku jd hh kq b fi kv kw l kx ky">array_one[2:5, :] </span><span id="8312" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[ 5, 6], <br/>               [ 7, 8], <br/>               [ 9, 10]])</span></pre><p id="c6b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">21.只看第一列的第二到第四行:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="21de" class="ku jd hh kq b fi kv kw l kx ky">array_one[2:5,0] </span><span id="1571" class="ku jd hh kq b fi kz kw l kx ky">Output: array([5, 7, 9])</span></pre><h1 id="64c6" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">布尔数组</h1><p id="6560" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">NumPy还使用布尔逻辑来控制索引:</p><p id="e341" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">22.最初创建一个布尔数组:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="3028" class="ku jd hh kq b fi kv kw l kx ky">array_one &gt; 5</span><span id="56c8" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[False, False], <br/>               [False, False],<br/>               [False, True], <br/>               [ True, True],<br/>               [ True, True]], dtype=bool)</span></pre><p id="2e61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">23.将圆括号放在布尔数组的两边将允许您根据它进行筛选:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="db48" class="ku jd hh kq b fi kv kw l kx ky">array_one[array_one &gt; 5] </span><span id="3d17" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 6, 7, 8, 9, 10])</span></pre><h1 id="bbbe" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">基于算术的运算</h1><p id="504f" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">24.sum方法将数组中的所有元素相加。返回array_one:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="fcd0" class="ku jd hh kq b fi kv kw l kx ky">array_one</span><span id="2691" class="ku jd hh kq b fi kz kw l kx ky">Output: array([[ 1, 2], <br/>               [ 3, 4], <br/>               [ 5, 6],<br/>               [ 7, 8], <br/>               [ 9, 10]])</span><span id="686f" class="ku jd hh kq b fi kz kw l kx ky">array_one.sum()</span><span id="db58" class="ku jd hh kq b fi kz kw l kx ky">Output: 55</span></pre><p id="1def" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">25.按行查找所有的总和:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="8105" class="ku jd hh kq b fi kv kw l kx ky">array_one.sum(axis = 1)  </span><span id="0319" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 3, 7, 11, 15, 19])</span></pre><p id="eb5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">26.要按列计算所有总和，请使用以下公式:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="1663" class="ku jd hh kq b fi kv kw l kx ky">array_one.sum(axis = 0) </span><span id="8409" class="ku jd hh kq b fi kz kw l kx ky">Output: array([25, 30])</span></pre><p id="3c93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">27.以类似的方式，计算每列的平均值。值得注意的是，averages数组的dtype是np.float:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="7b94" class="ku jd hh kq b fi kv kw l kx ky">array_one.mean(axis = 0)</span><span id="6dcb" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 5., 6.])</span></pre><h1 id="6f0b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">空值或NaN值</h1><p id="1db2" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">28.Scikit-learn不接受np.nan值。以array_three为例:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="9f74" class="ku jd hh kq b fi kv kw l kx ky">array_three = np.array([np.nan, 0, 1, 2, np.nan])</span></pre><p id="2936" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">29.np.isnan方法创建一个特定的布尔数组，可用于查找nan值:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="8b9c" class="ku jd hh kq b fi kv kw l kx ky">np.isnan(array_three)</span><span id="32c7" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ True, False, False, False, True], dtype=bool)</span></pre><p id="6e2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">30.通过用符号~对布尔数组求反并用括号将表达式括起来来消除NaN值:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="cbdf" class="ku jd hh kq b fi kv kw l kx ky">array_three[~np.isnan(array_three)] </span><span id="2ccf" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 0., 1., 2.])</span></pre><p id="418f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">31.作为一个选项，将NaN值设置为零:</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="287c" class="ku jd hh kq b fi kv kw l kx ky">array_three[np.isnan(array_three)] = 0 <br/>array_three</span><span id="c60b" class="ku jd hh kq b fi kz kw l kx ky">Output: array([ 0., 0., 1., 2., 0.])</span></pre><h1 id="be5d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="f544" class="pw-post-body-paragraph ie if hh ig b ih kc ij ik il kd in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">数据最基本的形式是由NumPy擅长处理的2D数字表组成的。如果您忘记了NumPy语法，请考虑这一点，Scikit-learn只接受没有丢失np.nan值的绝对值的2D NumPy数组。</p><p id="42da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我看来，将np.nan更改为一个值而不是传递数据似乎效果最好。最好跟踪布尔表达式并保持数据形式的一致性，因为这样可以减少编码错误，从而提高编码的通用性。</p></div></div>    
</body>
</html>