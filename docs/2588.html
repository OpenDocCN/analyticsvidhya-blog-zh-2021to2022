<html>
<head>
<title>Best Machine Learning “Hack” of 2021</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2021年最佳机器学习“黑客”</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/best-linear-layer-hack-of-2021-9747014b490e?source=collection_archive---------3-----------------------#2021-05-05">https://medium.com/analytics-vidhya/best-linear-layer-hack-of-2021-9747014b490e?source=collection_archive---------3-----------------------#2021-05-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="288c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">线性层(或致密层)对于深度学习就像火箭对于宇宙飞船一样:必不可少。迄今为止，我见过的大多数(如果不是全部)模型都以这样或那样的方式使用它们。但是谚语所说的轮子还能改进吗？在这篇文章中，我们将会看到一个简单的方法来给你的线状图层添加类固醇。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/64e42bd3fb81c66afdcc5c9780e8435e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JJL4anDLnALa-Ci1"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">达米尔·斯班尼克在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1511" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在线性层中，我们将所有数据视为一个矩阵(或张量),并与训练权重矩阵相乘，然后添加一个训练偏差向量。矩阵乘法的运算次数随规模呈指数增长。然而，如果我们将数据分割成更小的、平行的部分，然后通过一个更有深度的线性层运行，会发生什么呢？让我们在CIFAR10上测试一下。</p><p id="dec6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将在这里修改Pytorch教程中的分类模型，这样我们就可以快速上手并运行:<a class="ae js" href="https://pytorch.org/tutorials/beginner/blitz/cifar10_tutorial.html#sphx-glr-beginner-blitz-cifar10-tutorial-py" rel="noopener ugc nofollow" target="_blank">https://py torch . org/tutorials/beginner/blitz/cifar 10 _ tutorial . html # sphx-glr-beginner-blitz-cifar 10-tutorial-py</a></p><p id="3e90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Github对所用脚本的链接在文章末尾。</p><p id="a13e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于Keras/Tensorflow用户来说，如果你能完成这个Pytorch例子，同样的好处可以通过<a class="ae js" href="https://keras.io/api/layers/core_layers/dense/" rel="noopener ugc nofollow" target="_blank">密集层</a>在Keras中实现。密集层也允许任意数量的维度作为输入。</p><p id="ba08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们将转换并加载我们的图像:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">转换和数据加载器</figcaption></figure><p id="e8cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们将定义我们的模型:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">控制模式</figcaption></figure><p id="21d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们有两个Conv2d层，后跟两个线性层。很简单。</p><p id="1031" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，是训练和测试迭代。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">培训和测试</figcaption></figure><p id="b0e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行这个命令，您应该会得到如下结果:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">控制模型性能</figcaption></figure><p id="08ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">性能指标是56%的准确度和2个时期后的1.184最佳损失。</p><p id="8bc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的模型获取了最终Conv2D层的输出，并将其转换为尺寸为<em class="jv"> (batch_size，out_features) </em>的<strong class="ig hi"> <em class="jv">二维</em> </strong>视图。对于我们的“黑客”，我们将把Conv2D输出的视图大小改变成一个三维张量。然后通过fc1运行数据。接下来，我们将在通过fc3之前，将fc1输出视图更改为二维张量。</p><p id="e15a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们把这个视图做成一个有10个裂口的三维张量。模型中更改的行在中进行了注释。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">试验模型</figcaption></figure><p id="6c67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果排除注释，我们只修改了2行代码，增加了2行代码。打印出来，我们可以看到这大大减少了fc1的大小。我们现在应该有这样的东西:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">测试模型大小</figcaption></figure><p id="9fe9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这使得总参数从62，186 → 8，618。让我们再添加一些参数，使大小回到62k左右，这样我们就可以比较苹果和苹果了。</p><p id="61fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以将它们放入Conv2D层。但这并不能真正证明这种变化是否带来了好处，或者更大的Conv2D层是否更适合这种模型。因此，我们将只增加线性层。将n3从120更改为120x31=3，720，得到的总参数大小为61，178。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">调整测试模型大小</figcaption></figure><p id="4af4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以只是比我们要对比的控制模型小了一根头发:62，186 → 61，178参数。现在，让我们看看这是如何执行的。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="jt ju l"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">测试模型性能</figcaption></figure><p id="d587" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，仅在第一个时期之后，它已经具有与原始模型的最终结果几乎相同的精度。到了第二个纪元，它的表现超过了第一个模型！</p><p id="f53e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最佳损失:1.184 → 1.090</p><p id="faf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">准确率:56% → 62%</p><p id="2855" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这到底是怎么回事？</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jw"><img src="../Images/1ecff1394c7628d4b19e4a67a6a544d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tjQLOWga89jj2TJ-"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">德克斯·伊齐基尔在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="4cec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们试着想象一下，从第一层开始。</p><ol class=""><li id="caca" class="jx jy hh ig b ih ii il im ip jz it ka ix kb jb kc kd ke kf bi translated"><strong class="ig hi"> (conv1) Conv2D </strong> —比如说，一只猫的图像进入conv1，它通过13个经过训练的过滤器。</li><li id="39bd" class="jx jy hh ig b ih kg il kh ip ki it kj ix kk jb kc kd ke kf bi translated"><strong class="ig hi"> (pool) MaxPool2D </strong> —然后我们使用max pooling图层，从所有13个过滤图像的每个2x2区域中提取最高值像素，将它们缩小到1/4大小。</li><li id="6060" class="jx jy hh ig b ih kg il kh ip ki it kj ix kk jb kc kd ke kf bi translated"><strong class="ig hi"> (conv2) Conv2D </strong> —然后，我们的猫的13个较小的图像通过conv2，它有18个经过训练的过滤器。</li><li id="82b1" class="jx jy hh ig b ih kg il kh ip ki it kj ix kk jb kc kd ke kf bi translated"><strong class="ig hi"> (pool) MaxPool2D </strong> —另一个池层。每次我们使用过滤器和池，我们的猫的图像尺寸变得更小。因此，最终的水池通过了18个较小的5x5图像，突出了我们毛茸茸的虎斑猫的不同特征。</li><li id="90eb" class="jx jy hh ig b ih kg il kh ip ki it kj ix kk jb kc kd ke kf bi translated"><strong class="ig hi"> x.view() </strong> —在<strong class="ig hi">原始</strong>模型中，这些被展平并传递到我们总共有450个特征(5x5x18)的线性层。但是使用我们的<strong class="ig hi">第二个</strong>模型，那450个数据点被夹在<strong class="ig hi"> <em class="jv"> 10个特征集中，每个</em></strong><em class="jv">45宽。(批量大小、分割、内部特征)</em></li><li id="d230" class="jx jy hh ig b ih kg il kh ip ki it kj ix kk jb kc kd ke kf bi translated"><strong class="ig hi"> (fc1)线性</strong> —然后这些集合中的每一个都被传递到45个特征宽的fc1层，3720个权重深。因此，较小的fc1层被连续10次馈送Conv2D层的数据，而不是一次全部馈送。</li></ol><p id="fb09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似于较大的批处理大小可以产生较好的结果，这迫使较小的fc1层输入更加一般化。这10个集合的梯度与每个图像一起累积，并在反向通过之前一起平均。因此，这种方法也有助于缓解过拟合问题，从而产生更高的精度。</p><p id="6df2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">理论上，假设总参数大小保持大致相等，这在大多数用例中应该可以改善线性图层。请随意在你的模型上试用，如果有帮助，我很乐意听听。留下评论让我知道！感谢您的阅读。</p><p id="f9dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有一个包含控制和测试Pytorch脚本的存储库，如果您想使用它们的话:</p><div class="kl km ez fb kn ko"><a href="https://github.com/therealjjj77/Linear-Layer-Parallelization" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab dw"><div class="kq ab kr cl cj ks"><h2 class="bd hi fi z dy kt ea eb ku ed ef hg bi translated">therealjj 77/线性层并行化</h2><div class="kv l"><h3 class="bd b fi z dy kt ea eb ku ed ef dx translated">通过在GitHub上创建帐户，为therealjj 77/线性层并行化开发做出贡献。</h3></div><div class="kw l"><p class="bd b fp z dy kt ea eb ku ed ef dx translated">github.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc jm ko"/></div></div></a></div></div></div>    
</body>
</html>