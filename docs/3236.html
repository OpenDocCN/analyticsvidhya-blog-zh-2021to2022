<html>
<head>
<title>Simple CNN using NumPy Part II (Convolution Operation)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用NumPy的简单CNN第二部分(卷积运算)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-cnn-using-numpy-part-ii-convolution-operation-b8c5a02b0844?source=collection_archive---------9-----------------------#2021-06-20">https://medium.com/analytics-vidhya/simple-cnn-using-numpy-part-ii-convolution-operation-b8c5a02b0844?source=collection_archive---------9-----------------------#2021-06-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/b50d9b3b815a314def60a6af9b28fa3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*EEFoFFQXh_T2g9hmrdAVIw.png"/></div></figure><div class=""/><p id="26d6" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上一篇文章中，我简要介绍了卷积神经网络以及将展平图像的CSV数据转换为实际形状的代码。在这篇文章中，我将试着解释以下几点</p><ul class=""><li id="45e6" class="jk jl ho in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">卷积运算</li><li id="4915" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">为什么需要卷积？</li><li id="dd89" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">使用NumPy实现它</li></ul><h1 id="296b" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">卷积运算</h1><p id="db78" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">在ConvNets环境中，卷积运算涉及<strong class="in hp">计算固定矩阵和图像不同区域之间的点积</strong>。固定矩阵也被称为<strong class="in hp">卷积滤波器</strong>。图像的不同区域具有与固定矩阵相同的形状。这些区域主要由三个参数决定；跨距、过滤器的宽度和过滤器的高度。</p><p id="2e79" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hp">步幅</strong>参数决定每次点积计算之间的步数。</p><p id="4b33" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">以下示例展示了卷积运算</p><p id="c178" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于跨距=1和通道数= 1</p><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es lb"><img src="../Images/3124fc6c9d6fd4b15d856d03720a2260.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/1*K-3AN65gDSxoLmqX299UVw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">过滤器和示例图像之间的卷积</figcaption></figure><p id="f12e" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上面的示例中，滤镜以1为步长在图像上移动，对于每一步，计算点积。</p><p id="a4c5" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于跨距= 1和通道数= 2</p><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es lk"><img src="../Images/99b590632c583d18894feffe83010b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*yATK_eI7PQ6e6LQHDtBTtw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">多通道图像的卷积运算。图像通道的数量应等于滤镜通道的数量。</figcaption></figure><p id="12a9" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对于多通道卷积运算，图像通道的数量和滤波器通道的数量应该相等。</p><p id="69ac" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">卷积运算的结果维数可以使用下面的等式来计算:</p><p id="fed8" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hp"> <em class="ll">合成高度或宽度=((图像高度或宽度-过滤器高度或宽度)/步幅)+ 1 </em> </strong></p><h1 id="433b" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">为什么需要卷积？</h1><p id="59b6" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">卷积运算通过选择性地增加和减少像素强度来帮助去除图像的有用特征。这些有用的特征有助于将一幅图像与另一幅图像区分开来，从而使图像识别的任务更加高效。</p><p id="836f" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，在上面的第一个例子中，卷积运算检测向左倾斜的对角线。第二个示例检测向左和向右倾斜的对角线。以下示例有助于检测卡纳达语数字9(“omba tu”)中的垂直线和水平线。</p><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es lm"><img src="../Images/9e9cebbbdde2b214ca0f9de2fc38fb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:632/format:webp/1*ma2Ox_Mbm0MKUcyyVF_fZw.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">描绘数字9的28X28图像</figcaption></figure><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es ln"><img src="../Images/40a24740579ae0e0d9dc7522bad74965.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*2l2ZviUdvC1AN-A4Mn6p3w.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">帮助检测垂直线的卷积运算</figcaption></figure><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es lo"><img src="../Images/bd53f563a6b7c7b89cd0d08afc26fe65.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*MFZu7SQiLhc1Nnu8SsG1QQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">帮助检测水平线的卷积运算</figcaption></figure><h1 id="301c" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">使用NumPy实现它</h1><p id="2a9b" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">在执行卷积运算之前，我想初始化我的卷积滤波器。卷积运算将发生在1×1×28×28的图像和2个维度(1×5×5)的滤波器之间。该操作的结果将是尺寸为(1X2X24X24)的图像。</p><pre class="lc ld le lf fd lp lq lr ls aw lt bi"><span id="4c3c" class="lu jz ho lq b fi lv lw l lx ly">import numpy as np<br/>conv1 = np.random.randn(2,1,5,5) * np.sqrt(1. / 5)</span></pre><p id="b72a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是卷积运算的朴素实现的伪代码<strong class="in hp"> </strong>。</p><p id="ece2" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hp"> <em class="ll">设N为图像数量</em> </strong></p><ol class=""><li id="ddab" class="jk jl ho in b io ip is it iw jm ja jn je jo ji lz jq jr js bi translated">创建维数为零的结果矩阵(R )( nx2x 24x 24)</li><li id="7c2a" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">选择给定的图像</li><li id="cbea" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">选择一个过滤器。假设这是带有过滤器的<strong class="in hp">。这将具有尺寸(1X5X5)</strong></li><li id="a6a1" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">从选择的图像中，选择一个尺寸为(1X5X28)的矩形部分</li><li id="9260" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">从这个矩形部分中，水平地连续选择尺寸为(1X5X5)的部分。</li><li id="4435" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">取所选过滤器和(1X5X5)图像部分的点积，并将结果附加到矩阵r。</li><li id="7570" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">对下一个(1X5X28)部分重复步骤4，该部分是通过将滤波器移动步长量得到的。</li><li id="ebe5" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">重复步骤5和6，直到覆盖整个图像。</li><li id="c226" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji lz jq jr js bi translated">对所有图像重复步骤3至8</li></ol><p id="bb26" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">代码如下所示</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h2 id="b858" class="lu jz ho bd ka mc md me ke mf mg mh ki iw mi mj km ja mk ml kq je mm mn ku mo bi translated">用im2col实现卷积运算</h2><p id="daeb" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">另一种实现卷积的方法是<strong class="in hp">将图像上卷积滤波器的每一步转换成矩阵的一列</strong>。</p><p id="27d7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">具有跨距=1的(3X2X2)卷积滤波器的三通道图像具有以下im2col表示</p><figure class="lc ld le lf fd hj er es paragraph-image"><div class="er es mp"><img src="../Images/d19a6c8def73d1b40dd34c1941adfc61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*X6ASFRYXAFIJU0XwN8knjQ.png"/></div><figcaption class="lg lh et er es li lj bd b be z dx translated">im2col表示</figcaption></figure><p id="49d9" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">设im2col矩阵为X_im2col。那么计算如下</p><ul class=""><li id="c382" class="jk jl ho in b io ip is it iw jm ja jn je jo ji jp jq jr js bi translated">在多个滤波器中展平卷积滤波器。我们称之为conv1_flatten</li><li id="a969" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">计算C = conv1_flatten@X_im2col，其中@是矩阵乘法。</li><li id="b4de" class="jk jl ho in b io jt is ju iw jv ja jw je jx ji jp jq jr js bi translated">重塑C以适应矩阵的最终形状</li></ul><p id="78b1" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">im2col实现和卷积结果可以按以下方式编码。</p><figure class="lc ld le lf fd hj"><div class="bz dy l di"><div class="ma mb l"/></div></figure><h1 id="9cfc" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">健全性检查</h1><p id="feb3" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">之间的卷积</p><pre class="lc ld le lf fd lp lq lr ls aw lt bi"><span id="af24" class="lu jz ho lq b fi lv lw l lx ly">X = np.array([[1,0,0],[1,2,3],[3,4,5]])<br/>X = X.reshape(1,1,3,3)</span></pre><p id="28a5" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">和</p><pre class="lc ld le lf fd lp lq lr ls aw lt bi"><span id="d739" class="lu jz ho lq b fi lv lw l lx ly">conv1 = np.array([[1,0],[0,1]])<br/>conv1 = conv1.reshape(1,1,2,2)</span></pre><p id="c744" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">应该会产生一个具有形状(1，1，2，2)和以下条目的矩阵</p><p id="e20e" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi">(1*1)+(0*0)+(0*1)+(2*1) = 3</p><p id="0fae" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi">(1*0) + (0*0)+(2*0)+(3*1) = 3</p><p id="7baf" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi">(1*1)+(2*0)+(3*0)+(4*1) = 5</p><p id="f3db" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi">(2*1)+(3*0)+(4*0)+(5*1) = 7</p><p id="6b4c" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">正常卷积的输出为</p><pre class="lc ld le lf fd lp lq lr ls aw lt bi"><span id="fbd6" class="lu jz ho lq b fi lv lw l lx ly">array([[[[3., 3.],<br/>         [5., 7.]]]])</span></pre><p id="984c" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">im2col卷积的输出是</p><pre class="lc ld le lf fd lp lq lr ls aw lt bi"><span id="9767" class="lu jz ho lq b fi lv lw l lx ly">array([[[[3. 3.]<br/>   [5. 7.]]]])</span></pre><p id="a241" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hp"> <em class="ll">注:</em> </strong></p><p id="7f3e" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">卷积滤波器的条目在开始时被随机化。对于每一批数据，通过反向传播逐渐调整条目，以便最小化损失函数。这里使用的损失函数是交叉熵损失，这是分类问题中常见的。</p><h1 id="7c9f" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">反馈</h1><p id="90b0" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">感谢阅读！如果您有任何反馈/建议，请发电子邮件到padhokshaja@gmail.com给我。我会尽最大努力给你回复。</p><h1 id="081e" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">我提到的资源</h1><ul class=""><li id="76a4" class="jk jl ho in b io kw is kx iw mq ja mr je ms ji jp jq jr js bi translated"><a class="ae jj" href="https://hackmd.io/@bouteille/B1Cmns09I" rel="noopener ugc nofollow" target="_blank">详述CNN运作和实施的博客</a></li></ul><h1 id="c375" class="jy jz ho bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">下一篇文章</h1><p id="90f7" class="pw-post-body-paragraph il im ho in b io kw iq ir is kx iu iv iw ky iy iz ja kz jc jd je la jg jh ji ha bi translated">ReLU，最大池，最大软件</p><p id="0ae7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jj" rel="noopener" href="/@PAdhokshaja/simple-cnn-using-numpy-part-iii-relu-max-pooling-softmax-c03a3377eaf2">https://medium . com/@ PAdhokshaja/simple-CNN-using-numpy-part-iii-relu-max-pooling-soft max-c 03a 3377 EAF 2</a></p></div></div>    
</body>
</html>