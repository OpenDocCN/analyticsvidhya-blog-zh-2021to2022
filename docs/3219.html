<html>
<head>
<title>Understanding Cross Validation for Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">初学者了解交叉验证</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-cross-validation-for-beginners-31e0c606ebe0?source=collection_archive---------9-----------------------#2021-06-19">https://medium.com/analytics-vidhya/understanding-cross-validation-for-beginners-31e0c606ebe0?source=collection_archive---------9-----------------------#2021-06-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8125" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">无论您是在构建回归模型还是分类器，如果不进行测试，就很难知道您的模型做得有多好。我们希望模型的模式尽可能接近数据的真实关系，而不会受到太多噪音的影响。因此，测试我们的模型是重要的，因为它可能有助于揭示我们的模型的适当性。更不用说，<em class="jc">不</em>测试我们的模型也会导致过度拟合。过度拟合是一种错误，当模型非常擅长预测或建模数据集中特定区间的数据集，但对数据集外的值却很糟糕时，就会出现这种错误。</p><p id="cf72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">那么，我们如何帮助打击过度拟合？通过交叉验证！</p><h1 id="aaa7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">什么是交叉验证？</strong></h1><p id="af2c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">交叉验证(CV)是一种用于训练我们的模型的技术。在CV中，我们将把数据集一分为二:测试数据集和训练数据集。这个想法是，我们将使用训练集来训练我们的模型，然后在测试集上测试我们的模型，看看它做得有多好。“看看它做得有多好”可以通过许多方法来完成，但我在开始时使用的一种方法是比较均方差(MSE)值。因此，我们将有一个训练集MSE和一个测试集MSE。通常，我们“更”关心测试集的MSE，因为我们期望训练集的MSE相当低，因为模型是在那个特定集上训练的。请注意，与训练集MSE相比，非常高的测试集MSE可能表示过度拟合。</p><p id="1a65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们已经回答了为什么要分割数据集，现在的问题在于<em class="jc">如何</em>分割数据集。理想情况下，我们希望有一个好的分割，我们有足够的数据来尽可能好地训练我们的模型，也有足够的数据来正确地测试它。</p><h1 id="1624" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">五五开</strong></h1><p id="02c5" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">让我们假设将数据简单地分成50-50份，也就是说，50%的数据用于训练模型(训练数据集)，另外50%的数据保留用于在训练后测试模型(测试数据集)。</p><p id="71c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我们有50%的时间来测试我们的模型，但50%的时间仍然不足以帮助训练模型。测试的50%部分可能包含有价值的信息，如果我们使用这种分割，我们的模型将会遗漏这些信息。这可能会导致我们的预测/估计与实际相差甚远时出现更大的偏差。</p><p id="d254" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">有用文档</em>:<a class="ae kg" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . model _ selection . train _ test _ split . html</a></p><h1 id="05b3" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated"><strong class="ak">留一法交叉验证(LOOCV) </strong></h1><p id="6ea5" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">想象一下，我们只有很少的数据点，比如说10个。那么50-50分割甚至更不利，因为遗漏50%是5个非常有影响的数据点。把LOOCV作为一个选择。</p><p id="6df1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在LOOCV，我们在整个数据集上训练模型，只排除一个数据点。我们将遍历整个数据集，这样每次我们都将从训练集中排除不同的数据点。因此，测试集将只包含在每次迭代中改变的唯一点。然后，我们将在训练集上拟合模型并重复。本质上，如果我们总共有<em class="jc"> n </em>个数据点，模型将在每次迭代中在<em class="jc"> n-1 </em>个数据点上拟合。这将在下面进一步说明:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/20115f56446044b174ea5594d7bab891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yCjpEw44H_Q3qoMs"/></div></div></figure><p id="bc29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，如果我们有一个非常大的数据集，LOOCV是非常耗时的，因为我们正在经历<em class="jc"> n </em>次迭代。</p><h1 id="07c7" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">k倍交叉验证</h1><p id="8f16" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">LOOCV是K重交叉验证的一个特例(<em class="jc"> k=n，数据集的大小</em>)。在K-fold交叉验证中，我们将数据集分成<em class="jc"> k </em>个Fold(一个Fold可以被认为是一个组/子集，而<em class="jc"> k </em>是一些组)。从<em class="jc"> k个</em>褶中保留1个作为测试集，剩余的<em class="jc"> k -1个</em>褶作为训练集。褶皱的分割如下图所示，k=2，k=3，k=6，数据集有6个数据点:</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kt"><img src="../Images/a44db0608f978352ba8c3a71e4ecd359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KW8ApVPHBUDHFBmP"/></div></div></figure><p id="dc23" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以将K-Fold交叉验证的步骤分解为四个步骤:</p><ol class=""><li id="5d69" class="ku kv hh ig b ih ii il im ip kw it kx ix ky jb kz la lb lc bi translated">首先，我们将把数据分成k个T21折叠。</li><li id="bb00" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">然后，我们将保留<strong class="ig hi">一个</strong>折叠作为测试集。</li><li id="c9c2" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">然后我们将在其他<strong class="ig hi"> <em class="jc"> k -1 </em> </strong>褶皱上训练模型。</li><li id="4d1d" class="ku kv hh ig b ih ld il le ip lf it lg ix lh jb kz la lb lc bi translated">重复，遍历所有的褶皱，直到所有的褶皱都被测试过(总共<em class="jc"> k </em>次)。这在下面用6个点的相同数据集和<em class="jc"> k=3 </em>来描述</li></ol><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es li"><img src="../Images/0acc52c416e01a82dd11cb3d2178c77a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6zkoVw0MkKizmL2ybOE9_Q.png"/></div></div></figure><p id="5d8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在执行K-Fold交叉验证之前，您应该混洗数据，以便每个折叠都代表数据集。注意MSEs是在<em class="jc"> k </em>次迭代中平均的。</p><p id="a169" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在实践中，我们通常使用<em class="jc"> k=5 </em>或<em class="jc"> k=10 </em>，但是您可以选择任何合适的<em class="jc"> k </em>值。</p><p id="4b4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，由于我们分成了<em class="jc"> k </em>个折叠，通过使用<em class="jc"> k≠n </em>并且不执行LOOCV，K-Folds CV在时间上并不昂贵。</p><p id="4bbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">有用文档</em>:<a class="ae kg" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html" rel="noopener ugc nofollow" target="_blank">https://sci kit-learn . org/stable/modules/generated/sk learn . model _ selection。KFold.html</a></p><p id="4b72" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过执行交叉验证，我们试图提高我们的模型的性能。以上方法可以通过自己写函数练习或者通过Scikit-Learn (Python)轻松实现。在考虑用于特定数据集的正确模型时，我们很可能必须做出权衡，以获得最合适的模型。最终，交叉验证是一个很好的工具，可以用来实现我们选择最合适模型的目标。</p></div></div>    
</body>
</html>