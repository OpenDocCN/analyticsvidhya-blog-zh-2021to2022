<html>
<head>
<title>Mask and Social Distancing Detector: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面具和社会距离探测器:第一部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mask-detection-and-social-distancing-detector-part-1-b6ed4a3a4274?source=collection_archive---------31-----------------------#2021-05-27">https://medium.com/analytics-vidhya/mask-detection-and-social-distancing-detector-part-1-b6ed4a3a4274?source=collection_archive---------31-----------------------#2021-05-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/6eae9eea2c410b7a08046e00381e5c76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vmj94hAspmNsseS5.jpg"/></div></div></figure><p id="664a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi jn translated">对大多数印度人来说，纪律是一个巨大的问题。人们不愿意在外出时保持社交距离或戴口罩。我们大多数人都不注意自己的口罩卫生，导致印度爆发致命的冠状病毒，导致10万人死亡。</p><p id="0db0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一个问题是印度的警察暴行和权势人物的麻木不仁。每天我们都读到一个可怜的人因为没有戴口罩而被警察殴打甚至杀害。在印度，几乎没有中间立场。所以我在想，我们是否可以让机器来识别和惩罚违反电晕规则的人。</p><p id="96d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">我们将设计一个算法来识别</strong></p><ol class=""><li id="d576" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated">如果小组保持安全距离。</li><li id="f16a" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated">照片中的人是否戴着面具。</li></ol></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="013e" class="kr ks hh bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo bi translated">人脸检测</h1><p id="dc0b" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">我们可以从设计人脸检测器开始。让我们导入所有需要的库。稍后会用到其中的一些库，所以不要担心。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="bb94" class="md ks hh lz b fi me mf l mg mh"><br/>import seaborn as sns<br/>import os<br/>from sklearn.utils import shuffle<br/>import matplotlib.pyplot as plt<br/>from keras.preprocessing.image import ImageDataGenerator, img_to_array, load_img<br/>import cv2<br/>from scipy.spatial import distance</span></pre><p id="65ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们不必编写和训练一个Haar分类器，因为它已经被训练过了。从这里下载Haar cascade XML文件<a class="ae mi" href="https://www.kaggle.com/gpreda/haar-cascades-for-face-detection" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a><strong class="ir hi">。</strong>我们将使用一个已经训练好的分类器正面人脸分类器。我们已经为所有特征预先训练了分类器，但是我们现在只需要一个人脸检测器。</p><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/0b8466d5468b52c9b12e48006550a720.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*tylVaHdBO_FChBgXYGfztw.png"/></div></div></figure><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="d66d" class="md ks hh lz b fi me mf l mg mh">face_model = cv2.CascadeClassifier('mask/haarcascade_frontalface_default.xml')<br/></span><span id="6f6f" class="md ks hh lz b fi mk mf l mg mh">img = cv2.imread('images/GOPR1592.JPG')<br/>img = cv2.cvtColor(img, cv2.IMREAD_GRAYSCALE)<br/>faces = face_model.detectMultiScale(img,scaleFactor=1.2, minNeighbors=2, minSize=(100, 50))<br/><br/>img_2 = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)</span><span id="5832" class="md ks hh lz b fi mk mf l mg mh">for (x,y,w,h) in faces:<br/>    cv2.rectangle(img_2,(x,y),(x+w,y+h),(250,0,0),40)<br/>    <br/>plt.figure(figsize=(12,12))<br/>plt.imshow(img_2)</span></pre><figure class="lu lv lw lx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ml"><img src="../Images/ecc1c5e9a8e1b5c7afa72b8194997e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rey9eXjLM9K1p0LCxfLzeQ.png"/></div></div></figure><p id="28ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以看到标记在人脸周围的矩形，用于人脸检测。让我们通读代码并理解提到的术语</p><h2 id="c231" class="md ks hh bd kt mm mn mo kx mp mq mr lb ja ms mt lf je mu mv lj ji mw mx ln my bi translated">1.哈尔分类器</h2><p id="dc60" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">这是一种对象检测算法，可用于通过定位特征之间的边缘和像素颜色差异来检测人脸。例如，你的眼睛会比邻近的五官更黑，你的鼻子、嘴唇和眉毛也是如此。</p><p id="3d27" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要全面了解，可以从这里 看<a class="ae mi" href="https://docs.opencv.org/3.4/db/d28/tutorial_cascade_classifier.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">。</strong></a></p><h2 id="8c50" class="md ks hh bd kt mm mn mo kx mp mq mr lb ja ms mt lf je mu mv lj ji mw mx ln my bi translated">2.检测多尺度</h2><p id="aa12" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">该功能用于检测人脸。该函数将返回一个矩形，坐标为(x，y，w，h ),围绕检测到的人脸。<strong class="ir hi"> faces </strong>变量具有矩形坐标，将围绕检测到的面绘制。这个函数采用的不同参数是</p><p id="cc9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这需要三个共同的论点</p><ol class=""><li id="d8f7" class="jw jx hh ir b is it iw ix ja jy je jz ji ka jm kb kc kd ke bi translated"><strong class="ir hi">图像</strong></li><li id="bb88" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi">比例因子</strong>:指定每种比例下图像缩小多少</li><li id="1c88" class="jw jx hh ir b is kf iw kg ja kh je ki ji kj jm kb kc kd ke bi translated"><strong class="ir hi">最小邻居</strong>:指定每个候选矩形应该有多少邻居来保留它</li></ol><h1 id="a936" class="kr ks hh bd kt ku mz kw kx ky na la lb lc nb le lf lg nc li lj lk nd lm ln lo bi translated">社交距离探测器</h1><p id="456e" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">既然我们的面部被检测到，我们现在将检测社交距离是否被保持。</p><pre class="lu lv lw lx fd ly lz ma mb aw mc bi"><span id="1b1c" class="md ks hh lz b fi me mf l mg mh">MIN_DISTANCE = 1000</span><span id="116b" class="md ks hh lz b fi mk mf l mg mh">if len(faces)&gt;=2:<br/>    label = [0 for i in range (len(faces))]<br/>    for i in range(len(faces)-1):<br/>        for j in range(i+1, len(faces)):<br/>            dist = distance.euclidean(faces[i][:2], faces[j][:2]) <br/>            if dist&lt;MIN_DISTANCE:<br/>                label[i] = 1<br/>                label[j] = 1<br/>                <br/>    new_img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)<br/>    for i in range(len(faces)):<br/>        (x,y,w,h)=faces[i]<br/>        if label[i]==1:<br/>            cv2.rectangle(new_img,(x,y), (x+w, y+h),(255,0,0),10)</span><span id="c701" class="md ks hh lz b fi mk mf l mg mh">#if distance&lt;MIN_DISTANCE then red box showing social distancing not maintained<br/>        else:<br/>            cv2.rectangle(new_img,(x,y),(x+w,y+h),(0,255,0),15)#else green box showing Social distancing maintained<br/>    plt.figure(figsize=(10,10))<br/>    plt.imshow(new_img)<br/>else:<br/>    print("No. of faces detected is less than 2")</span></pre><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es ne"><img src="../Images/5217a3cca6af88c95dfe491010cb5dae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*5UvQargmKwvmF944hw-JPA.png"/></div></figure><blockquote class="nf ng nh"><p id="ec30" class="ip iq ni ir b is it iu iv iw ix iy iz nj jb jc jd nk jf jg jh nl jj jk jl jm ha bi translated">分类器正确地检测到我在社交上是疏远的，而其他两个人不是。我的脸是绿色的</p><p id="9e3c" class="ip iq ni ir b is it iu iv iw ix iy iz nj jb jc jd nk jf jg jh nl jj jk jl jm ha bi translated">矩形，而其他两个有红色的矩形围绕着他们的脸。</p></blockquote><p id="5e2e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们通读代码并理解它。</p><h2 id="7aaf" class="md ks hh bd kt mm mn mo kx mp mq mr lb ja ms mt lf je mu mv lj ji mw mx ln my bi translated">1.Scipy</h2><p id="ed24" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">我们使用Scipy库中的距离函数来计算两个一维数组之间的欧氏距离</p><h2 id="fe25" class="md ks hh bd kt mm mn mo kx mp mq mr lb ja ms mt lf je mu mv lj ji mw mx ln my bi translated">2.环</h2><p id="ca9c" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">因为我们必须计算照片中所有人脸(3)之间的距离，所以需要比较所有人脸并计算距离。“I”将具有范围(0，2)，而“j”将具有范围(1，3)。因此，当迭代时，每个面的距离将被逐一比较。</p><p id="83e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于距离小于可接受社交距离的人脸，标签将从零更新为1。</p><p id="54bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于所有标签，值为1的标签表面周围将显示一个红色矩形。</p><h1 id="ed33" class="kr ks hh bd kt ku mz kw kx ky na la lb lc nb le lf lg nc li lj lk nd lm ln lo bi translated">结论</h1><p id="c308" class="pw-post-body-paragraph ip iq hh ir b is lp iu iv iw lq iy iz ja lr jc jd je ls jg jh ji lt jk jl jm ha bi translated">到目前为止，我们已经完成了一个面部和距离检测器。我们可以从第2部分继续，设计一个屏蔽检测器。</p></div></div>    
</body>
</html>