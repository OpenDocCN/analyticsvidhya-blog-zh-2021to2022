<html>
<head>
<title>Paper Review — How to write a fast image blur kernel in C++ ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">论文综述——如何用C++写一个快速的图像模糊内核？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/understanding-the-trade-offs-between-locality-parallelism-and-redundant-re-computation-de834a2221e?source=collection_archive---------15-----------------------#2021-05-19">https://medium.com/analytics-vidhya/understanding-the-trade-offs-between-locality-parallelism-and-redundant-re-computation-de834a2221e?source=collection_archive---------15-----------------------#2021-05-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="67d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大家好！今天，我想和大家分享我从阅读<a class="ae jc" href="https://people.csail.mit.edu/jrk/halide-pldi13.pdf" rel="noopener ugc nofollow" target="_blank">这篇</a>精彩论文<em class="jd"> Halide:一种用于优化图像处理流水线中的并行性、局部性和重新计算的语言和编译器中所学到的东西。</em></p></div><div class="ab cl je jf go jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="ha hb hc hd he"><p id="0540" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文的主要观点(至少对我来说)是，在优化对常规2D或3D网格状数据结构(例如图像处理流水线、模板计算)进行操作的程序时，您必须在局部性、并行性和冗余重新计算之间做出复杂的权衡。我不想扔给你一堆技术术语，也不想用这篇论文的每一个细节来烦你。因此，让我们深入研究本文中使用的运行示例，并理解为什么我们需要担心局部性、并行性和冗余重新计算。</p></div><div class="ab cl je jf go jg" role="separator"><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj jk"/><span class="jh bw bk ji jj"/></div><div class="ha hb hc hd he"><h1 id="66d4" class="jl jm hh bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">两阶段模糊核</h1><p id="127e" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">两阶段模糊算法在两个过程中对2D图像应用3×3平均滤波器。在第一步中，我们在图像上应用1×3平均滤波器，这给我们提供了输入的水平模糊。然后在第二遍中，我们对结果应用3×1平均滤波器来获得垂直模糊。</p><p id="3273" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">实现这种模糊算法的简单方法是首先计算中间图像<em class="jd"> blurx </em>，这是对整个图像应用1×3水平模糊的结果，然后对<em class="jd"> blurx </em>应用3×1垂直模糊以计算最终输出(图1)。注意，我们在计算出<em class="jd">中的任何元素之前，先计算出<em class="jd"> blurx </em>的所有元素。</em>所以这个策略叫做<em class="jd">广度优先</em>策略。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/8804d1fb550034736f0ad12bd90977fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*-Cn4u4BSTEDKKovwqFIbZQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图1:广度优先策略(<a class="ae jc" href="https://people.csail.mit.edu/jrk/halide-pldi13.pdf" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="54aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面给出的(清单1)是广度优先策略的C++实现。第一个循环嵌套计算<em class="jd"> blurx </em>，第二个循环嵌套使用<em class="jd"> blurx </em>计算输出。在此实现中没有应用显式并行化或矢量化优化。对于大小为8192×8192的输入图像，这个版本用<em class="jd"> gcc-9.3.0 </em>(用-O3)编译，在我的笔记本电脑上用了279毫秒(5次运行的中值),它采用了英特尔i5–8250 u(1.60 GHz)CPU。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">清单1:广度优先策略的C++代码</figcaption></figure><p id="2c08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在<em class="jd"> blurx c </em>计算中，内循环和外循环的所有迭代都是独立的。通常在这种情况下，并行化外部循环和矢量化内部循环可以获得良好的性能。这可以对两个循环嵌套进行。我使用OpenMP编译指令来并行化外部循环和矢量化内部循环。并行宽度优先版本运行时间为204毫秒，仅比非并行宽度优先版本提高1.37倍！不是很好，对吧？</p><h1 id="f517" class="jl jm hh bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">环路融合</h1><p id="3e72" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">在广度优先策略中，我们先计算整个<em class="jd">模糊</em>网格，然后将其用于计算<em class="jd"> o </em> ut。因此，生产者-消费者的位置很低。例如，我们在<em class="jd"> blurx </em>计算的第一次迭代中计算<em class="jd"> blurx(0，0) </em>，并在<em class="jd"> out </em>计算的第一次迭代中使用它。中间有8192×8192次循环迭代！所以当我们需要使用它时，<em class="jd"> blurx(0，0) </em>不太可能在一级缓存中。本地性对于从现代硬件中获得良好性能非常重要，而我们在广度优先战略中却忽略了这一点。</p><p id="9bb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好吧，<em class="jd">计算blurx </em>并立即用它来计算<em class="jd">怎么样？</em>这就是循环融合的思想(图2)。对于<em class="jd">或</em>中的每个点，我们需要3个<em class="jd">模糊值。</em>这些值在我们需要的时候被计算出来并立即使用。实现这一点需要融合两个循环嵌套。基本上，我们保留了广度优先策略中的<em class="jd"> out </em>计算，并加入了一个新的循环来计算所需的3个<em class="jd"> blurx </em>值(清单2)。这个实现具有高度的局部性，因为我们直接使用了<em class="jd"> blurx </em>值。也没有循环携带依赖！因此，外循环可以并行化，内循环可以矢量化以提高性能。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lh"><img src="../Images/d0eb57968fdc4624fd112a45741020b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:590/format:webp/1*AIRHRzjIZIOpjsdoeb9qRw.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图2:回路融合(<a class="ae jc" href="https://people.csail.mit.edu/jrk/halide-pldi13.pdf" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="910e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好极了，那么它能跑多快？非并行版loop fusion耗时489ms (0.43x减速)，并行版耗时354ms (0.21x减速)。刚刚发生了什么？我们成功地让代码运行得更慢了！</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">清单2:循环融合的C++代码</figcaption></figure><p id="e3d1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">循环融合改进了数据局部性，但是我们引入了冗余的重新计算来实现这一点。在迭代中没有重复使用<em class="jd"> blurx </em>，并且由于1×3平均窗口中的重叠，我们计算<em class="jd"> blurx </em>的任何给定点3次。这是很多多余的工作，导致速度变慢。</p><p id="6597" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有没有一种方法既能避免重新计算，又能获得良好的数据局部性？</p><p id="c19f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是的…</p><h1 id="7ab2" class="jl jm hh bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">推拉窗</h1><p id="ef89" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">为了计算任何给定的<em class="jd"> out </em>值，我们需要沿着<em class="jd"> y </em>维度的3个<em class="jd"> blurx </em>值。因此，我们可以只保留一个<em class="jd"> blurx </em>值的缓冲区，并使用滑动窗口更新缓冲区，而不是将<em class="jd"> blurx </em>的所有值存储在一个全尺寸的网格中(图3)。缓冲区必须至少有3个× <em class="jd"> image_width </em>元素的空间，因为我们需要3个<em class="jd"> blurx的水平值。</em>滑动窗口比原始网格小得多，因此我们得到了很好的局部性。另请注意，没有冗余的重新计算，即每个<em class="jd"> blurx </em>值只计算一次。为了计算<em class="jd"> out(x，y) </em>我们只需要计算<em class="jd"> blurx(x+1，y) </em>并将其存储在缓冲区中。我们需要的所有其他值都已经在滑动窗口中了。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es li"><img src="../Images/020ac6a2672fc5808c75e259e6b83923.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*XXGzhZIqAJ8wTVqJk0XV0A.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图3:滑动窗口(<a class="ae jc" href="https://people.csail.mit.edu/jrk/halide-pldi13.pdf" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="89b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">滑动窗口策略实现需要两个嵌套循环(清单3)。在清单3中，您可以注意到在<em class="jd"> blurx </em>中有一个循环携带的依赖。我们不得不引入循环相关来消除冗余的重新计算。所以这个循环不能并行化！我的滑动窗口实现需要252毫秒(1.11倍的改进)，它仍然比并行宽度优先策略慢。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">清单3:滑动窗口的C++代码</figcaption></figure><p id="42ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">到目前为止讨论的3个策略都是极端情况。广度优先没有冗余的重新计算，但是具有最差的局部性。循环融合具有最好的局部性，但是伴随着最大量的冗余重新计算。滑动窗口具有良好的局部性和零重计算，但不能并行化。</p><p id="7089" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显然，最好的策略应该介于这两个极端之间，对吗？</p><h1 id="895d" class="jl jm hh bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">盖瓦</h1><p id="4cc6" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">我们在宽度优先策略中得到了较差的局部性，因为对整个图像网格相继计算了<em class="jd"> blurx </em>和<em class="jd"> out </em>。平铺基本上是将网格分割成多个矩形块。现在，您可以将平铺视为多个较小的图像。对于每个较小的图块，您可以应用广度优先策略(图4)。因为拼贴比原始图像小得多(通常为32×32 ),所以可以获得很好的局部性。然而，在分块边界会有一些冗余的重新计算。但是与环路融合相比，冗余量要低得多。我们只是注入了一些多余的工作，并大大改善了局部性，即良好的权衡。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lj"><img src="../Images/30fb967ee6adda54aaccb3413f05f6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*0hd-wUduXDJHI3r94Pu-qA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图4:平铺</figcaption></figure><p id="0627" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">平铺策略的实现(清单4)有一个双重嵌套的循环，它在<em class="jd"> x </em>和<em class="jd"> y </em>维度上迭代所有的平铺块。为了处理每个瓦片，我们应用宽度优先策略。注意，在<em class="jd"> blurx </em>的任何读和写操作之间只有32×32次循环迭代(清单4中的第14行和第23行)。相当不错的地方，对不对？这段代码需要182毫秒才能完成。这比广度优先策略提高了1.53倍。</p><p id="9614" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">平铺的好处是我们可以独立处理每个平铺，这意味着我们可以并行处理它。我们也可以向量化最里面的循环。我通过并行化外部循环(<em class="jd"> t </em> i <em class="jd"> l </em> oop)和最内部两个循环(<em class="jd"> j l </em> oops)获得了最佳性能。性能最佳的并行平铺版本仅需56毫秒(性能提升4.98倍)。这很棒，对吧？</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">清单4:平铺的C++代码</figcaption></figure><p id="73dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">相同的原理可以应用于滑动窗口策略，以便将其并行化。</p><h1 id="b6f8" class="jl jm hh bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">分区滑动窗口</h1><p id="b2c2" class="pw-post-body-paragraph ie if hh ig b ih kj ij ik il kk in io ip kl ir is it km iv iw ix kn iz ja jb ha bi translated">请记住，我们不能并行滑动窗口策略，因为有一个循环携带的依赖。然而，我们可以沿着<em class="jd"> y </em>维度对图像进行分区，并对每个分区并行应用滑动窗口策略(图5)。原始滑动窗口策略具有零冗余重新计算。分区滑动窗口策略沿分区边界有一些重新计算(类似于平铺)，但我们可以并行化并提高性能。因此，我们放弃了一些冗余的重新计算，以换取高并行性。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lk"><img src="../Images/9626cb84d3e1b00a2b36576d0d7b0041.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*kePpqeRDlxFqUtVe2H5wrA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图5:分区滑动窗口(<a class="ae jc" href="https://people.csail.mit.edu/jrk/halide-pldi13.pdf" rel="noopener ugc nofollow" target="_blank">来源</a>)</figcaption></figure><p id="127b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">清单5展示了分区滑动窗口策略的非并行C++实现。这需要145毫秒(提高1.92倍)才能完成。我通过并行化外部循环(分区)和矢量化内部循环(<em class="jd"> j循环)获得了最佳性能。</em>水货版只需要48 ms(5.81倍提升)，这是我拿到的最快的版本。</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">清单5:分区滑动窗口的C++代码</figcaption></figure><h1 id="1281" class="jl jm hh bd jn jo lc jq jr js ld ju jv jw le jy jz ka lf kc kd ke lg kg kh ki bi translated">一些想法</h1><ul class=""><li id="6928" class="ll lm hh ig b ih kj il kk ip ln it lo ix lp jb lq lr ls lt bi translated">我们通过5种不同的方法(以及4种平行的变体)来计算同一件事情，一个简单的3×3图像模糊。计算什么(即算法)和如何计算(即时间表)之间有明显的区别。这是Halide或任何像DSL这样的海德的核心思想之一。</li><li id="991e" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated">找到一个有效的时间表是非常具有挑战性的。这是由多重原因造成的。首先，这些算法可能具有复杂的数据访问模式和计算阶段之间的依赖性。其次，我们用来运行它们的硬件也很复杂(深度缓存层次、多核、矢量单元等等！).</li><li id="6c72" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated">仅在一个维度上进行优化几乎肯定不会产生最佳性能。您将不得不在局部性、并行性和重新计算之间进行复杂的多维权衡，以找到一个好的计算调度。这意味着最佳时间表可能是无限多个有效时间表中的一个。</li><li id="4785" class="ll lm hh ig b ih lu il lv ip lw it lx ix ly jb lq lr ls lt bi translated"><a class="ae jc" href="https://github.com/halide/Halide" rel="noopener ugc nofollow" target="_blank"> Halide </a>，通过允许我们从它的调度中单独指定算法，解决了这个难题。它允许用户在短时间内为给定的算法尝试大量有效的时间表(几天内，而如果您必须手动完成，则需要几周时间！)然后挑一个最好的！</li></ul><p id="903b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文中报告的所有性能改进都与非并行宽度优先策略有关。图6显示了我得到的所有版本的加速。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lz"><img src="../Images/300f65355a4c8afd349420e350ff1515.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*ivw4Owwl2oFREvxVdR9Xng.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">图6:加速</figcaption></figure><p id="d20f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天到此为止！如果你想试试我的代码，这里有<a class="ae jc" href="https://github.com/charitha22/workspace/blob/master/halide_two_stage_blur/blur.cpp" rel="noopener ugc nofollow" target="_blank"/>。我很想收到你的回复，所以别忘了评论。</p></div></div>    
</body>
</html>