<html>
<head>
<title>Higher-Order Functions — Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶函数— Python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/higher-order-functions-python-716f508a8f41?source=collection_archive---------4-----------------------#2021-09-23">https://medium.com/analytics-vidhya/higher-order-functions-python-716f508a8f41?source=collection_archive---------4-----------------------#2021-09-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/f6f4058bd9b95a0c7a43c008f2dd3e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxDhmsq9LG0p4au_RULnVA.png"/></div></div></figure><p id="0602" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果一种编程语言将函数视为一级对象，就可以说它支持一级函数。根据定义，程序实体中的“一级对象”是可以像其他对象一样传递的对象。它具有以下特点:</p><ul class=""><li id="5e36" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">可以有属性和方法。</li><li id="c6ca" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">可以赋给一个变量。</li><li id="736e" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">可以作为参数传递给函数。</li><li id="8e17" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">可以作为另一个函数的结果返回。</li></ul><p id="9466" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们试着通过代码来理解每一个属性。</p><ol class=""><li id="ec31" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm kb jt ju jv bi translated"><strong class="ir hi">属性和方法</strong></li></ol><p id="131c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您在Python中创建的每个方法/函数都有一组默认的属性和方法，可以使用<code class="du kc kd ke kf b">dir()</code>方法进行检查。在下面的例子中，我定义了一个hello_world函数来打印字符串<code class="du kc kd ke kf b">Hello World!</code>。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="f3c7" class="ko kp hh kf b fi kq kr l ks kt">def hello_world():<br/>   print("Hello World!")</span></pre><p id="e78b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们在hello_world方法上调用<code class="du kc kd ke kf b">dir()</code>函数时，我们可以看到所有的默认方法都是它的一部分。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="292b" class="ko kp hh kf b fi kq kr l ks kt">print(dir(hello_world))<br/>['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__']</span></pre><p id="235f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以调用这些与函数绑定的方法中的任何一个。例如:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="51f4" class="ko kp hh kf b fi kq kr l ks kt">hello_world.__name__<br/># 'hello_world'</span></pre><p id="9a71" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">也可以用<code class="du kc kd ke kf b">type</code>来理解我们创建的函数是function类的一个实例。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="1867" class="ko kp hh kf b fi kq kr l ks kt">print(type(hello_world))<br/># &lt;class 'function'&gt;</span></pre><p id="eabf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2。将函数分配给变量</strong></p><p id="43cc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们也可以给变量分配函数。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="b16c" class="ko kp hh kf b fi kq kr l ks kt">def hello_world_function(name):<br/>   print("Hello " + name + "!")</span><span id="fee0" class="ko kp hh kf b fi ku kr l ks kt">hello_world_variable = hello_world_function</span></pre><p id="81d2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们将<code class="du kc kd ke kf b">hello_world_function</code>函数赋给变量<code class="du kc kd ke kf b">hello_world_variable</code>。现在<code class="du kc kd ke kf b">hello_world_variable</code>是一个函数对象，这意味着，我们可以像调用<code class="du kc kd ke kf b">hello_world_function</code>一样调用它。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="ff12" class="ko kp hh kf b fi kq kr l ks kt">hello_world_variable("Tharun")<br/># Hello Tharun!</span></pre><p id="5f7f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该赋值并不调用函数，而是采用由<code class="du kc kd ke kf b">hello_world_function</code>引用的函数对象，并创建指向它的第二个名称。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="4c42" class="ko kp hh kf b fi kq kr l ks kt">hello_world_function<br/># &lt;function hello at 0x0000020127C982F0&gt;</span><span id="7015" class="ko kp hh kf b fi ku kr l ks kt">hello_world_variable<br/># &lt;function hello at 0x0000020127C982F0&gt;</span></pre><p id="4b9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3。用作参数</strong></p><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/406384850de76b5bf25084881f37846e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*Ku2iFqeZS1X9B_ER.png"/></div></figure><p id="294b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为Function是一个对象，所以你可以像传递变量一样传递它。</p><p id="20de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们考虑遍历一个条目列表，并按顺序打印它们。我们可以很容易地构建一个<code class="du kc kd ke kf b">iterate</code>函数。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="ce26" class="ko kp hh kf b fi kq kr l ks kt">def iterate(items):<br/>   for item in items:<br/>      print(item)</span></pre><p id="4c11" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是常见的东西。如果我们想做一些不同于打印项目的事情呢？这就是高阶函数的用武之地。我们可以创建一个函数<code class="du kc kd ke kf b">iterate_custom</code>,它接受项目列表和需要应用于每个项目的函数。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="ad16" class="ko kp hh kf b fi kq kr l ks kt">def iterate_custom(items, function):<br/>   for item in items:<br/>      function(item)</span></pre><p id="4c28" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过这样做，我们创建了一个函数，它可以对列表做任何涉及顺序迭代的事情。这是一个更高层次的抽象，这也使得我们的代码可以重用。</p><p id="6559" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 4。从函数</strong>返回函数</p><figure class="kg kh ki kj fd ii er es paragraph-image"><div class="er es kv"><img src="../Images/724e7a04bdc473a4d16382d43e6b1482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*_yipt4yF0Qvslwuf.png"/></div></figure><p id="fa49" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样做通常是为了有一个决定控制流的包装函数，或者决定应该调用哪个函数。例如:</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="c452" class="ko kp hh kf b fi kq kr l ks kt">def square(num):<br/>   return num * num</span><span id="76af" class="ko kp hh kf b fi ku kr l ks kt">def cube(num):<br/>   return square(num) * num</span><span id="3d71" class="ko kp hh kf b fi ku kr l ks kt">def power_of_num(power):<br/>   if power == 2:<br/>      return square<br/>   elif power == 3:<br/>      return cube</span><span id="582f" class="ko kp hh kf b fi ku kr l ks kt">num_powers = power_of_num(2)<br/># num_powers is assigned with the square method</span><span id="ee30" class="ko kp hh kf b fi ku kr l ks kt">num_powers(5)<br/># 25</span></pre><p id="00d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们已经定义了非常常见的方法<code class="du kc kd ke kf b">square</code>和<code class="du kc kd ke kf b">cube</code>。第三个方法<code class="du kc kd ke kf b">power_of_num</code>是一个包装函数，它根据变量值返回前两个方法中的任意一个。在这种情况下，用变量值<code class="du kc kd ke kf b">2</code>调用<code class="du kc kd ke kf b">power_of_num</code>。<code class="du kc kd ke kf b">Square</code>方法现在将被返回并在变量<code class="du kc kd ke kf b">num_powers</code>中赋值。现在，如果我们调用<code class="du kc kd ke kf b">num_powers</code>变量，它将充当<code class="du kc kd ke kf b">square</code>方法。</p><pre class="kg kh ki kj fd kk kf kl km aw kn bi"><span id="1a38" class="ko kp hh kf b fi kq kr l ks kt">num_powers = power_of_num(3)<br/># num_powers is assigned with the cube method</span><span id="9e73" class="ko kp hh kf b fi ku kr l ks kt">num_powers(5)<br/># 125</span></pre><p id="b5ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有问题吗？在这里随意评论。</p><p id="a6de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你喜欢这篇文章，请点击👏所以其他人会在媒体上看到它。</p></div></div>    
</body>
</html>