<html>
<head>
<title>How to find weather data using NLP (Natural Language Processing)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用NLP(自然语言处理)查找天气数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-find-weather-data-using-nlp-natural-language-processing-3093f7544a5f?source=collection_archive---------5-----------------------#2021-06-11">https://medium.com/analytics-vidhya/how-to-find-weather-data-using-nlp-natural-language-processing-3093f7544a5f?source=collection_archive---------5-----------------------#2021-06-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a781" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://en.wikipedia.org/wiki/Natural_language_processing" rel="noopener ugc nofollow" target="_blank">自然语言处理(NLP) </a>是一种人工智能过程，由计算机系统用来寻找文本内容的含义。这允许人类用户使用用正常句子以自然方式书写的句子来提问。成功的NLP系统将允许用户以不同的方式提问，并且仍然能够理解所提问题的含义。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/abdaa912106582d7c60209c2703a1364.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*px_niUcnOZjGqRB_yU7ePg.jpeg"/></div></figure><p id="f31b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们使用自然语言处理(NLP)来创建一个示例Java应用程序，它可以使用“自然语言”文本问题来查找天气数据。这允许用户使用查询来查找天气数据，例如:</p><ul class=""><li id="1542" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated"><em class="ju">告诉我1975年1月6日日本东京的天气。</em></li><li id="d3c9" class="jl jm hh ig b ih jv il jw ip jx it jy ix jz jb jq jr js jt bi translated"><em class="ju">下周三英国伦敦的天气会怎么样？</em></li><li id="5b74" class="jl jm hh ig b ih jv il jw ip jx it jy ix jz jb jq jr js jt bi translated">去年7月4日DC华盛顿州的天气如何？</li></ul><p id="c0ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju">关于这个例子的完整源代码，请从GitHub资源库下载:</em><a class="ae jc" href="https://github.com/visualcrossing/WeatherApi/tree/master/Java/com/visualcrossing/weather/samples" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/visual crossing/weather API/tree/master/Java/com/visual crossing/weather/samples</a></p><h1 id="bfff" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">创建一个简单的NLP天气回答机器人的步骤</h1><p id="872d" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">在我们的示例中，我们将把我们的NLP处理限制为识别用户是否在询问关于天气数据的问题。支持的问题将是找出即将到来的天气预报或查找历史天气观测。</p><p id="7ac8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们需要识别两条信息:</p><ol class=""><li id="af2c" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb ld jr js jt bi translated">用户试图查找天气信息的位置。</li><li id="ef63" class="jl jm hh ig b ih jv il jw ip jx it jy ix jz jb ld jr js jt bi translated">天气数据的日期或日期范围。</li></ol><p id="081e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们找到这些信息，我们就可以查找天气数据。为此，我们将使用<a class="ae jc" href="https://www.visualcrossing.com/resources/documentation/weather-api/timeline-weather-api/" rel="noopener ugc nofollow" target="_blank">可视交叉天气API </a>。这个时间线天气API可以很容易地查找过去和未来的天气数据，因为它会自动调整到我们要求的日期范围。如果我们询问未来的日期，它会给我们天气预报。如果我们要求过去的数据，那么它会给我们历史天气观测。</p><p id="5852" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju">要运行示例代码，您需要一个免费的Weather API密匙。如果您没有API密钥，请前往</em> <a class="ae jc" href="https://www.visualcrossing.com/weather/weather-data-services" rel="noopener ugc nofollow" target="_blank"> <em class="ju">免费注册页面</em> </a> <em class="ju">创建您的密钥。</em></p><h1 id="c212" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第一步—设置NLP处理</h1><p id="ce38" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">有许多优秀的开源Java库可用于NLP处理。其中包括由<a class="ae jc" href="https://nlp.stanford.edu/" rel="noopener ugc nofollow" target="_blank">标准NLP小组</a>创建的<a class="ae jc" href="https://opennlp.apache.org/" rel="noopener ugc nofollow" target="_blank"> Apache OpenNLP </a>和<a class="ae jc" href="https://stanfordnlp.github.io/CoreNLP/" rel="noopener ugc nofollow" target="_blank"> CoreNLP </a>。在这个示例中，我们将使用CoreNLP，因为它提供了一种简单的入门方式，并且包括针对我们需要API来回答的许多问题的预训练模型。</p><h2 id="1816" class="le kb hh bd kc lf lg lh kg li lj lk kk ip ll lm ko it ln lo ks ix lp lq kw lr bi translated">确定位置和日期</h2><p id="d639" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我们将使用NLP处理从用户问题中找到两条信息，这样我们就可以找到合适的天气数据——位置和日期。因此，我们将关注适当地使用命名实体识别来查找文本中的实体提及。实体提及表示文本中特别感兴趣的项目，例如人、位置、日期或时间。</p><p id="b2a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们正在寻找实体提及，确定天气数据的目标位置(如城市，州或省或国家)和我们应该找到天气数据的日期。</p><p id="2bd2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们需要NLP处理器能够从文本中定位。让我们考虑几个例子。</p><p id="cafc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，处理器应该识别位置是日本东京，并且用户已经提供了确切的日期——1975年1月6日。CoreNLP包括一个演示sit  e，提供文本的图形解释:</p><p id="6b03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，库正确地将位置识别为城市和国家的组合，然后正确地识别和解析预期日期。</p><p id="8635" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将能够把“日本东京”的位置和日期传递给天气API来查找天气信息。</p><p id="ce80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju">英国伦敦</em><strong class="ig hi"><em class="ju"/></strong><em class="ju"/><strong class="ig hi"><em class="ju">下周三</em> </strong> <em class="ju">天气如何？</em></p><p id="70ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种情况下的地点是英国伦敦。这个日期有点棘手，因为它不是一个简单的日期(尽管用户可能有许多方式要求日期，所以即使这也不是一个微不足道的练习！)我们希望NLP能够将“下周三”解释为询问日期，然后将其转换为确切的日期。</p><p id="1ae1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们通过在线文本运行上面的文本，我们可以看到图书馆再次正确地找到了位置和预定日期:</p><p id="1e4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以将NLP处理视为正确理解了“下周三”的概念。从那里，图书馆找到当前日期之后的下一个星期三。</p><p id="2d96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju"/><strong class="ig hi"><em class="ju">华盛顿州</em> </strong> <em class="ju"> </em> <strong class="ig hi"> <em class="ju">去年7月4日</em> </strong> <em class="ju">？</em></p><p id="becc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们看最后一个例子，我们再次看到NLP库正确地处理了位置和目标日期:</p><p id="d669" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">图书馆再次能够识别DC的华盛顿州，并解释“最后”是指7月4日的最后一次事件。</p><h1 id="ebff" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">第二步-创建NLP Java代码</h1><p id="372d" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我们现在准备创建Java样本的第一部分。我们的simple将是一个Java应用程序，它提示用户输入文本，处理所请求的位置和日期的文本，然后查找天气数据。为了简单起见，这将通过Java system.out来处理。</p><p id="4248" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在进入代码之前，首先从CoreNLP下载所需的库。这些示例是使用版本4.2.2编写的，但是任何最新的版本都应该可以工作。</p><p id="7e97" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您使用maven配置您的Java项目，您可以在这里找到所需的maven依赖项<a class="ae jc" href="https://search.maven.org/artifact/edu.stanford.nlp/stanford-corenlp" rel="noopener ugc nofollow" target="_blank"/>。我们添加的maven依赖项有:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="9792" class="le kb hh lt b fi lx ly l lz ma">&lt;dependency&gt; <br/> &lt;groupId&gt;edu.stanford.nlp&lt;/groupId&gt; <br/> &lt;artifactId&gt;stanford-corenlp&lt;/artifactId&gt; <br/> &lt;version&gt;4.2.2&lt;/version&gt; <br/>&lt;/dependency&gt; <br/>&lt;dependency&gt; <br/> &lt;groupId&gt;edu.stanford.nlp&lt;/groupId&gt;<br/> &lt;artifactId&gt;stanford-corenlp&lt;/artifactId&gt;<br/> &lt;version&gt;4.2.2&lt;/version&gt;<br/> &lt;classifier&gt;models&lt;/classifier&gt;<br/> &lt;/dependency&gt;</span></pre><h2 id="4c2f" class="le kb hh bd kc lf lg lh kg li lj lk kk ip ll lm ko it ln lo ks ix lp lq kw lr bi translated">设置NLP管道</h2><p id="dfdd" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我们代码的第一部分是主要的Java方法。在这个方法中，我们首先设置CoreNLP管道，并为用户输入文本创建一个基本循环。有关CoreNLP设置和配置的更多信息，请参见<a class="ae jc" href="https://stanfordnlp.github.io/CoreNLP/api.html" rel="noopener ugc nofollow" target="_blank"> CoreNLP API示例。</a></p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="ee67" class="le kb hh lt b fi lx ly l lz ma">public static void main(String[] args) {<br/> // set up pipeline properties<br/> Properties props = new Properties();<br/> // set the list of annotators to run<br/> props.setProperty("annotators","tokenize,ssplit,pos,lemma,ner");<br/> <br/> // set to use the neural algorithm<br/> props.setProperty("coref.algorithm", "neural");<br/>        props.setProperty("ner.docdate.usePresent", "true");<br/>        props.setProperty("sutime.includeRange", "true");<br/>        props.setProperty("sutime.markTimeRanges", "true");<br/>        <br/> // build pipeline<br/> System.out.printf("Starting pipeline...%n");<br/> StanfordCoreNLP pipeline = new StanfordCoreNLP(props);<br/> System.out.printf("Pipeline ready...%n%n");<br/><br/> }<br/>}</span></pre><p id="6301" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们减少了示例中注释器的数量，因为我们主要关注‘ner’注释器的输出。“ner”是“NERCombinerAnnotator”的缩写，它负责命名实体处理，我们需要找到位置和日期。其余的注释器是ner正常工作所必需的。</p><p id="d3c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在向上面的main方法添加一个循环，以允许用户输入文本并让示例处理数据。</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="3769" class="le kb hh lt b fi lx ly l lz ma">public static void main(String[] args) {<br/> // set up pipeline properties<br/> Properties props = new Properties();<br/> // set the list of annotators to run<br/> props.setProperty("annotators","tokenize,ssplit,pos,lemma,ner");<br/> <br/> // set to use the neural algorithm<br/> props.setProperty("coref.algorithm", "neural");<br/>        props.setProperty("ner.docdate.usePresent", "true");<br/>        props.setProperty("sutime.includeRange", "true");<br/>        props.setProperty("sutime.markTimeRanges", "true");<br/>        <br/> // build pipeline<br/> System.out.printf("Starting pipeline...%n");<br/> StanfordCoreNLP pipeline = new StanfordCoreNLP(props);<br/> System.out.printf("Pipeline ready...%n%n");<br/> <br/> //loop for ever asking the user for text to process<br/> try (Scanner in = new Scanner(System.in)) {<br/>  while (true) {<br/>  System.out.printf("Enter text:%n%n");<br/>  <br/>  String text = in.nextLine();<br/>  try {<br/>   processText(pipeline, text);<br/>  } catch (Throwable e) {<br/>   // TODO Auto-generated catch block<br/>   e.printStackTrace();<br/>  }<br/>  <br/>  }<br/> }<br/>}</span></pre><p id="793a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用户输入文本后，该示例将配置的管道和文本传递给第二个方法“processText”来处理文本。</p><h2 id="9e91" class="le kb hh bd kc lf lg lh kg li lj lk kk ip ll lm ko it ln lo ks ix lp lq kw lr bi translated">处理位置和日期的文本</h2><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="2ad0" class="le kb hh lt b fi lx ly l lz ma">private static void processText(StanfordCoreNLP pipeline, String text) throws Exception {<br/> CoreDocument document = new CoreDocument(text);<br/> // annnotate the document<br/> pipeline.annotate(document);<br/> <br/> if (document.entityMentions()==null || document.entityMentions().isEmpty()) {<br/>  System.out.println("no entities found");<br/>  return;<br/> }<br/> <br/> String city=null;<br/> String state=null;<br/> String country=null;<br/> LocalDate startDate=null;<br/> LocalDate endDate=null;<br/>     for (CoreEntityMention em : document.entityMentions()) {<br/>      <br/>      <br/>      if (DATE.equals(em.entityType())) {<br/>      Timex timex=em.coreMap().get(TimeAnnotations.TimexAnnotation.class);<br/>      Calendar t1=timex.getRange().first;<br/>      if (t1!=null) {<br/>       startDate=LocalDateTime.ofInstant(t1.toInstant(), ZoneId.systemDefault()).toLocalDate();<br/>      }<br/>      Calendar t2=timex.getRange().second;<br/>      if (t2!=null) {<br/>       endDate=LocalDateTime.ofInstant(t2.toInstant(), ZoneId.systemDefault()).toLocalDate();<br/>      }<br/>      } else if (LOCATION_CITY.equals(em.entityType())) {<br/>      city=em.text();<br/>      } else if (LOCATION_STATE_OR_PROVINCE.equals(em.entityType())) {<br/>      state=em.text();<br/>      } else if (LOCATION_COUNTRY.equals(em.entityType())) {<br/>      country=em.text();<br/>      }<br/>     }<br/>     String location="";<br/>     if (city!=null) location+=location.isEmpty()?city:(","+city);<br/>     if (state!=null) location+=location.isEmpty()?state:(","+state);<br/>     if (country!=null) location+=location.isEmpty()?country:(","+country);<br/>     System.out.printf("Location=%s; fromDate=%s, toDate=%s%n", location,<br/>      startDate!=null?startDate.format(DateTimeFormatter.ISO_LOCAL_DATE):"[Null]",<br/>       endDate!=null?endDate.format(DateTimeFormatter.ISO_LOCAL_DATE):"[Null]"<br/>       );<br/>     <br/>     if (location==null || location.isEmpty()) {<br/>      System.out.println("no location information found");<br/>      return;<br/>     }<br/>     timelineRequestHttpClient(location, startDate, endDate);<br/> }</span></pre><p id="3b8e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，代码通过创建一个文档来处理文本，然后使用我们上面配置的管道对其进行注释。注释完成后，我们可以检查结果，看是否有任何请求的实体被提及。</p><p id="55d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了找到可能提到的实体，我们在处理过程中循环遍历找到的列表。我们使用实体类型来帮助识别我们接收的信息。如果我们发现我们有一个日期，我们使用Timex实例来查找开始和结束日期。</p><p id="4048" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们寻找与位置相关的注释(城市、州或省名或国家)。如果我们找到他们中的任何一个，我们会记住他们。</p><p id="f835" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">检查完所有实体后，我们构建一个位置字符串，它代表我们找到的位置实体的组合(就像地址是城市、州、国家等的组合一样)。我们需要一个字符串将这个位置信息传递给Weather API，以帮助API识别所请求的确切位置。</p><h2 id="959e" class="le kb hh bd kc lf lg lh kg li lj lk kk ip ll lm ko it ln lo ks ix lp lq kw lr bi translated">从天气API中检索信息</h2><p id="59f1" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">我们现在有了请求的位置和日期或日期范围，所以我们可以继续从Weather API读取天气数据。有关如何在Java中使用天气API以及通过网络读取数据的不同方式的更多信息，请查看<a class="ae jc" href="https://www.visualcrossing.com/resources/documentation/weather-api/how-to-use-timeline-weather-api-to-retrieve-historical-weather-data-and-weather-forecast-data-in-java/" rel="noopener ugc nofollow" target="_blank">如何在Java中使用时间轴天气API检索历史天气数据和天气预报数据</a>。</p><p id="52e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，我们还需要一些maven依赖项来处理网络请求和JSON解析:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="6668" class="le kb hh lt b fi lx ly l lz ma">&lt;dependency&gt; <br/> &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;<br/> &lt;artifactId&gt;httpclient&lt;/artifactId&gt;<br/> &lt;version&gt;4.5.12&lt;/version&gt;<br/> &lt;/dependency&gt;<br/>&lt;dependency&gt;<br/> &lt;groupId&gt;org.json&lt;/groupId&gt;<br/> &lt;artifactId&gt;json&lt;/artifactId&gt;<br/> &lt;version&gt;20200518&lt;/version&gt;<br/>&lt;/dependency&gt;</span></pre><p id="3270" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">天气API用于请求JSON格式的天气数据:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="0880" class="le kb hh lt b fi lx ly l lz ma">public static void timelineRequestHttpClient(String location, LocalDate startDate, LocalDate endDate ) throws Exception {<br/> //set up the end point<br/> String apiEndPoint="<a class="ae jc" href="https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/" rel="noopener ugc nofollow" target="_blank">https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/</a>";<br/> <br/> <br/> String unitGroup="us";<br/> <br/> <br/> StringBuilder requestBuilder=new StringBuilder(apiEndPoint);<br/> requestBuilder.append(URLEncoder.encode(location, StandardCharsets.UTF_8.toString()));<br/> <br/> if (startDate!=null) {<br/>  requestBuilder.append("/").append(startDate.format(DateTimeFormatter.ISO_DATE));<br/>  if (endDate!=null &amp;&amp; !startDate.equals(endDate)) {<br/>  requestBuilder.append("/").append(endDate.format(DateTimeFormatter.ISO_DATE));<br/>  }<br/> }<br/> <br/> URIBuilder builder = new URIBuilder(requestBuilder.toString());<br/> <br/> builder.setParameter("unitGroup", unitGroup)<br/>  .setParameter("key", API_KEY)<br/>  .setParameter("include", "days")<br/>  .setParameter("elements", "datetimeEpoch,tempmax,tempmin,precip");</span><span id="0fe8" class="le kb hh lt b fi mb ly l lz ma">HttpGet get = new HttpGet(builder.build());<br/> <br/> CloseableHttpClient httpclient = HttpClients.createDefault();<br/> <br/> CloseableHttpResponse response = httpclient.execute(get);    <br/> <br/> String rawResult=null;<br/> try {<br/>  if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {<br/>  System.out.printf("Bad response status code:%d%n", response.getStatusLine().getStatusCode());<br/>  return;<br/>  }<br/>  <br/>  HttpEntity entity = response.getEntity();<br/>     if (entity != null) {<br/>      rawResult=EntityUtils.toString(entity, Charset.forName("utf-8"));<br/>     }<br/>     <br/>     <br/> } finally {<br/>  response.close();<br/> }<br/> <br/> parseTimelineJson(rawResult);<br/> <br/> }</span></pre><p id="7350" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">代码的第一部分创建时间线天气API请求URL。首先，位置被添加到请求中。如有必要，可添加日期。如果只要求一个日期，则该日期会自动添加，否则会添加两个日期。如果请求中没有添加日期，将返回15天的预测。</p><p id="a830" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单个日期请求将如下所示:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="98f9" class="le kb hh lt b fi lx ly l lz ma"><a class="ae jc" href="https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/Washington,DC/2020-07-04?unitGroup=us&amp;key=YOUR_API_KEY&amp;include=dates&amp;elements=datetimeEpoch,tempmax,tempmin,precip" rel="noopener ugc nofollow" target="_blank">https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/Washington,DC/2020-07-04?unitGroup=us&amp;key=YOUR_API_KEY&amp;include=dates&amp;elements=datetimeEpoch,tempmax,tempmin,precip</a></span></pre><p id="c613" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">日期范围请求将如下所示:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="8951" class="le kb hh lt b fi lx ly l lz ma"><a class="ae jc" href="https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/Washington,DC/2020-07-04/2020-08-04?unitGroup=us&amp;key=YOUR_API_KEY&amp;include=dates&amp;elements=datetimeEpoch,tempmax,tempmin,precip" rel="noopener ugc nofollow" target="_blank">https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/Washington,DC/2020-07-04/2020-08-04?unitGroup=us&amp;key=YOUR_API_KEY&amp;include=dates&amp;elements=datetimeEpoch,tempmax,tempmin,precip</a></span></pre><p id="4022" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还要注意可选的“元素”和“包含”参数的使用。这些参数用于过滤从请求中返回的数据量。</p><p id="479d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju"> include=dates </em>告诉API只给我们日期级别的信息(否则也会包括每小时的信息)。</p><p id="e44d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju"> elements=datetimeEpoch，tempmax，tempmin，precip </em>指示API只返回这四条天气数据。风、压力等其他信息将不包括在内。</p><h2 id="62f8" class="le kb hh bd kc lf lg lh kg li lj lk kk ip ll lm ko it ln lo ks ix lp lq kw lr bi translated">显示天气数据</h2><p id="7a0d" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">代码的最后一部分向命令行显示了一个非常简单的天气数据表:</p><pre class="je jf jg jh fd ls lt lu lv aw lw bi"><span id="ef38" class="le kb hh lt b fi lx ly l lz ma">private static void parseTimelineJson(String rawResult) {<br/> <br/> if (rawResult==null || rawResult.isEmpty()) {<br/>  System.out.printf("No raw data%n");<br/>  return;<br/> }<br/> <br/> JSONObject timelineResponse = new JSONObject(rawResult);<br/> <br/> ZoneId zoneId=ZoneId.of(timelineResponse.getString("timezone"));<br/> <br/> System.out.printf("Weather data for: %s%n", timelineResponse.getString("resolvedAddress"));<br/> <br/> JSONArray values=timelineResponse.getJSONArray("days");<br/> <br/> System.out.printf("Date\tMaxTemp\tMinTemp\tPrecip\tSource%n");<br/> for (int i = 0; i &lt; values.length(); i++) {<br/>  JSONObject dayValue = values.getJSONObject(i);<br/>        ZonedDateTime datetime=ZonedDateTime.ofInstant(Instant.ofEpochSecond(dayValue.getLong("datetimeEpoch")), zoneId);<br/>            <br/>        double maxtemp=dayValue.getDouble("tempmax");<br/>        double mintemp=dayValue.getDouble("tempmin");<br/>        double precip=dayValue.getDouble("precip");<br/>          <br/>        System.out.printf("%s\t%.1f\t%.1f\t%.1f%n", datetime.format(DateTimeFormatter.ISO_LOCAL_DATE), maxtemp, mintemp, precip );<br/>    }<br/>}</span></pre><p id="507b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这段代码解析从Weather API传入的JSON数据。从那里，代码遍历days数组中的值，并从每一天中提取datetime、tempmax、tempmin和precip值。</p><p id="e2ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过使用自纪元以来的秒数读取日期并提供位置时区ID来处理时间。这将创建一个ZonedDateTime实例。</p><p id="1b6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最终结果是原始文本中请求的地点和日期的简单天气数据。</p><p id="fd30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢您的阅读。如果您有任何意见或问题，请告诉我！</p></div><div class="ab cl mc md go me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ha hb hc hd he"><p id="0dce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="ju">原载于2021年6月11日</em><a class="ae jc" href="https://www.visualcrossing.com/resources/documentation/weather-api/how-to-find-weather-data-using-nlp/" rel="noopener ugc nofollow" target="_blank"><em class="ju">【https://www.visualcrossing.com】</em></a><em class="ju">。</em></p></div></div>    
</body>
</html>