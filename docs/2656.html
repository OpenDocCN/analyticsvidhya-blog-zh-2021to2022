<html>
<head>
<title>Anomaly Detection in Python — Part 1; Basics, Code and Standard Algorithms</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的异常检测——第1部分:基础知识、代码和标准算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/anomaly-detection-in-python-part-1-basics-code-and-standard-algorithms-37d022cdbcff?source=collection_archive---------0-----------------------#2021-05-11">https://medium.com/analytics-vidhya/anomaly-detection-in-python-part-1-basics-code-and-standard-algorithms-37d022cdbcff?source=collection_archive---------0-----------------------#2021-05-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="3c0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">异常/异常值是明显偏离正常/常规数据的数据点。异常检测问题可以分为3种类型:</p><ol class=""><li id="7b08" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">监督:</strong>在这些问题中，数据包含异常和干净的数据，以及告诉我们哪些例子是异常的标签。我们使用分类算法来执行异常检测。</li><li id="f6f0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">半监督:</strong>在这里，我们只能在培训期间访问“干净”的数据。该模型试图捕捉“正常”数据的样子，并在预测过程中将看起来“异常”的数据标记为异常值。自动编码器在这一类中被广泛使用。</li><li id="447a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">无监督:</strong>这里，数据包含干净的和异常的例子——但是没有标签告诉我们哪些例子是异常的。这是最常遇到的类别。</li></ol><p id="19b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jr">在本文中，我们将讨论</em> <strong class="ih hj"> <em class="jr">无监督</em> </strong> <em class="jr">执行异常/异常值检测的方法。我将在以后的文章中讨论半监督和监督方法。</em></p><p id="0bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">无监督异常检测问题可以通过3种方法解决:</strong></p><ol class=""><li id="b220" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">基于业务/领域的EDA </strong></li><li id="0845" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">单变量方法(图基方法、z得分等)</strong></li><li id="68ec" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">多元方法(马氏距离(使用MCD)、一类SVM、隔离森林等)</strong></li></ol><p id="ee69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用fastcd讨论<strong class="ih hj">马氏距离法，这是一种相对更详细的多变量方法，因为多变量方法不太为人所知，但非常有用。让我们看看每一类，并从实用的角度来理解它们。</strong></p><p id="30b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还应该记住，异常点需要进一步关注——必须从领域的角度进行分析。因此，在大多数情况下，当我们说一个点是异常时，我们的意思是它值得更多的分析。</p><h1 id="71b4" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">基于业务/领域的EDA</h1><p id="2608" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">这是必须尝试的第一种方法——它应该是贯穿整个异常检测或ML管道的持续过程。目标是通过数据可视化执行领域分析来识别异常行为。以下是一些好的开始方式:</p><ol class=""><li id="594d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">制作箱线图和直方图，以确定稀缺数据和极值的状态。如图所示，稀缺数据也可能存在于两种模式之间。</li><li id="5f86" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">可视化散点图——特别是因变量(因变量或共线变量)之间的散点图。当模式已经存在时，很容易发现偏差。</li></ol><div class="kv kw kx ky fd ab cb"><figure class="kz la lb lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/e031c17afdefeee20efcd1fdf96a9d9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1430/format:webp/1*-iM9ShPgBOh7Jm7aJekxlA.png"/></div></figure><figure class="kz la lm lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/815dc852e6e197cddfe31d1808e711c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/1*5unwcw7iUC4gbAu73UeW7Q.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx lr di ls lt translated">一些常见的潜在异常可以用简单的EDA检测出来。</figcaption></figure></div><p id="e655" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">散点图显示了一个有趣的场景——如果只看边缘直方图，两个孤立的高亮点看起来不像异常。只有当我们在散点图中绘制这两个变量时，我们才会看到Var1、Var2的值的组合是不寻常的，而不是Var1或Var2的单个值。<strong class="ih hj">这是一个绘制单变量直方图无法识别异常情况的例子。</strong>这种异常是一种<strong class="ih hj">多元异常</strong>，将在本文后面讨论。</p><h1 id="a7c3" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">单变量方法</h1><p id="0b95" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">单变量方法易于实现，执行速度快。他们的结果也很容易向商业利益相关者解释。这个想法是一次查看一个变量<strong class="ih hj"/>,并确定以下任一区域:</p><ol class=""><li id="bc31" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">稀缺数据存在<em class="jr">(和/或)</em></li><li id="cecf" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">数据取极值</li></ol><p id="3962" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将简要讨论<strong class="ih hj">图基的方法</strong>，该方法将数据中的极值视为异常值/异常值:</p><p id="8e75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在Tukey的方法中，我们定义了一个下限和一个上限。在这些限制范围内的数据被认为是“干净的”。下限和上限以<strong class="ih hj">鲁棒</strong>的方式确定。这意味着上限和下限不会受到异常值的影响。这是与其他一些方法(如z分数法)的区别，z分数法的下限和上限受异常值的影响。一般来说，最好使用健壮的方法。</p><p id="3700" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上限和下限定义如下:</p><p id="ad84" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">下限=第25百分位— k*IQR </strong></p><p id="2b37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">上限=第75百分位+ k*IQR </strong></p><p id="c298" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中，k通常为1.5，但如果需要，必须进行调整。IQR是变量的四分位数范围(IQR =第75个百分点-第25个百分点的数据)。数据中低于下限或高于上限的值称为异常值。</p><figure class="kv kw kx ky fd la er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es lu"><img src="../Images/b08264bd5561bd4993ea942de1d496c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vzUuSNXhzr8iITI2HdjO3w.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">通过tukey的方法发现的异常值可以使用典型的箱线图可视化。剧情举例。在这种方法中，极值被认为是异常的。</figcaption></figure><p id="ff2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下函数用<strong class="ih hj"> NaN </strong>替换tukey方法识别的异常值(超出上述定义的限值):</p><pre class="kv kw kx ky fd lv lw lx ly aw lz bi"><span id="ff3d" class="ma jt hi lw b fi mb mc l md me">def tukey(x, k = 1.5):<br/>    x = np.array(x).copy().astype(float)<br/>    first_quartile = np.quantile(x, .25)<br/>    third_quartile = np.quantile(x, .75)<br/>    <br/>    # Define IQR<br/>    iqr = third_quartile - first_quartile<br/>    <br/>    ### Define the allowed limits for 'Normal Data'<br/>    lower_allowed_limit = first_quartile - (k * iqr)<br/>    upper_allowed_limit = third_quartile + (k * iqr)<br/>    <br/>    #set values below the lower limit/above the upper limit as nan<br/>    x[(x&lt;lower_allowed_limit) | (x&gt;upper_allowed_limit)] = np.nan<br/>    return x</span></pre><p id="3ca5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其他一些单变量方法是z-score方法和中位数绝对偏差方法-各有利弊。</p><h1 id="7a9e" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">多元方法</h1><p id="d04a" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">让我们理解什么是多元异常值。考虑一辆汽车，想象我们测量的两个特征:</p><ol class=""><li id="ce46" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">odo:它显示汽车上的里程表读数，并以英里/小时为单位测量汽车的速度。</li><li id="98ea" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">每分钟转数:它测量汽车车轮每分钟转动的次数。</li></ol><p id="043e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设<em class="jr"> odo </em>取值范围为0–50英里/小时，而<em class="jr"> rpm </em>取值范围为0–650 rpm。我们希望这两个特征的读数相互关联，即大的转速会导致里程表记录更高的速度。</p><p id="ecf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，假设我们在rpm传感器上记录了一个0值。我们断定汽车没有移动。同样，比方说在开车时，如果里程表显示25英里/小时，我们可以断定汽车正在行驶。然而，这些值都不是异常值，因为它们代表了完全正常的操作模式。</p><p id="d8d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，让我们想象一下，我们注意到odo读数为25，但同时<em class="jr"/>，rpm读数为0。这看起来不合理。25的odo值本身不是不合理的；而rpm为0也不是不合理的(如上所述)<em class="jr">但是对他们来说同时取那些值是不合理的。</em> <strong class="ih hj">这是一个多元异常值的例子。多元异常值是指特征值组合不太可能出现的观测值。</strong>这里重要的是同时考虑所有特性的值，而不是像我们讨论单变量方法时那样一次只考虑一个特性。<strong class="ih hj"> <em class="jr">多元异常值需要专门的方法——并且通常无法通过单变量方法检测到，除非特征单独取极值。它们也很难检测到——上面的例子有2个变量(odo和rpm ),这就是为什么我们可以很容易地发现异常值——但是，当我们有数百个变量时，这个问题就不可能手动解决了。即使在处理数百个变量时，使用多变量方法也可以使过程变得简单。</em>T9】</strong></p><p id="43b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们来看一个检测多元异常/异常值的算法。正如开始时所讨论的，我们将讨论无监督的情况——已知数据被异常值污染，但不知道精确的异常观察值。</p><h2 id="16e5" class="ma jt hi bd ju mf mg mh jy mi mj mk kc iq ml mm kg iu mn mo kk iy mp mq ko mr bi translated">使用FastMCD算法的马氏距离法；</h2><p id="0a29" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们将使用sklearn实现这个方法。让我们首先讨论这种方法的机制。<em class="jr"> <br/>马氏距离可以有效地被认为是一种度量点与分布之间距离的方法。</em>当使用它来检测异常时，我们将“干净”数据视为分布。<strong class="ih hj">如果一个点与“干净”数据的马氏距离很大，我们认为这是一个异常。</strong>该方法假设干净数据是多元正态的，但在实践中，它甚至可以用于各种其他情况。</p><p id="3875" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">马氏距离与多元正态分布密切相关。以下是它的一些特征:</p><ol class=""><li id="b0b7" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如果数据遵循多元正态分布，则具有相同概率的所有点与分布平均值的马氏距离相同。</li><li id="74d9" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">一个点离正态分布均值的马氏距离越高，该点的概率越低。现在，从统计学的角度来看，这是有意义的-至于为什么具有大马氏距离的点是潜在的异常-因为它们对应于低概率。</li></ol><p id="c662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正态分布由其均值和协方差矩阵唯一确定，需要根据数据进行估计。但是，我们使用<strong class="ih hj"> FastMCD算法</strong>来确定正态分布的均值和协方差矩阵。我们使用<strong class="ih hj"> FastMCD </strong>算法，因为我们想要对均值和协方差进行稳健的估计。如果我们使用均值和协方差的直接公式，那么异常值也会有助于计算均值和协方差——这不是我们想要的。以下是了解FastMCD的一个好资源:【https://onlinelibrary.wiley.com/doi/epdf/10.1002/wics.1421 T4】</p><p id="3094" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">幸运的是，Scikit-learn有一个非常方便的方法来使用这个方法。以下是步骤:<br/> 1。<strong class="ih hj">将sklearn .协方差. EllipticEnvelope()拟合到数据:</strong>这将使用FastMCD算法计算数据的稳健平均值和协方差。我们需要将<strong class="ih hj">污染</strong>的值传递给它，这是我们预计异常的数据部分的估计值。<br/> 2。<strong class="ih hj">预测:</strong>预测每个数据点的异常值/异常状态。由算法标记为-1的点是异常，+1不是异常。</p><p id="8875" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是之前的例子:</p><figure class="kv kw kx ky fd la er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mt"><img src="../Images/28fb835b51af85a3ba3e77e8fb18d12a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gOVHxR7ArREf2eF0ghR20w.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">我们希望使用Mahalanobis距离方法将左上角的2个点检测为异常值。</figcaption></figure><pre class="kv kw kx ky fd lv lw lx ly aw lz bi"><span id="4a81" class="ma jt hi lw b fi mb mc l md me">### Create the Data<br/>d1 = np.random.multivariate_normal(mean = np.array([-.5, 0]),<br/>                               cov = np.array([[1, 0], [0, 1]]), size = 100)</span><span id="1a14" class="ma jt hi lw b fi mu mc l md me">d2 = np.random.multivariate_normal(mean = np.array([15, 10]),<br/>                               cov = np.array([[1, 0.3], [.3, 1]]), size = 100)</span><span id="a6cd" class="ma jt hi lw b fi mu mc l md me">outliers = np.array([[0, 10],[0, 9.5]])<br/>d = pd.DataFrame(np.concatenate([d1, d2, outliers], axis = 0), columns = ['Var 1', 'Var 2'])</span><span id="922b" class="ma jt hi lw b fi mu mc l md me">### The outliers added above are what we want to detect ####<br/>############# Use Mahalanobis distance method to detect them ####</span><span id="ece7" class="ma jt hi lw b fi mu mc l md me"># Define the Elliptic Envelope<br/>el = covariance.EllipticEnvelope(store_precision=True, assume_centered=False, support_fraction=None, <br/>                                    contamination=0.0075, random_state=0)<br/># Fit the data - this is where FastMCD is used by sklearn<br/>el.fit(d)</span><span id="e118" class="ma jt hi lw b fi mu mc l md me"># Create column that shows anomaly status<br/>d['Anomaly or Not'] = el.predict(d)</span><span id="b446" class="ma jt hi lw b fi mu mc l md me"># Create scatterplot and color the anomalies differently<br/>plt.figure(figsize = (9, 4))<br/>ax = plt.scatter(d['Var 1'], d['Var 2'], c = d['Anomaly or Not'], cmap = 'coolwarm')<br/>plt.xlabel('Var 1')<br/>plt.ylabel('Var 2')<br/>plt.colorbar(label = '-1: Anomaly; +1: Not Anomaly')<br/>plt.grid()<br/></span></pre><p id="93ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">污染输出= 0.075:</p><figure class="kv kw kx ky fd la er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mv"><img src="../Images/fe9952aec15c8996f09b89be6718c235.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyxGrv7zACRlUTmK3-WKjQ.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">如我们所见，该算法将左上角的两个示例标记为异常。试验污染值以找到正确的值很重要。</figcaption></figure><p id="2dbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，这种方法是有效的——它检测多元异常。它可以用于具有数百个维度的数据。设置污染非常重要。为了看到这一点，让我们检查算法的结果，因为我们设置了不同的污染值。</p><div class="kv kw kx ky fd ab cb"><figure class="kz la mw lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/d8f5c0e708f9209b1c70fbd91fe942f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*tAzkuG1ELWRfxmWqzdVJFQ.png"/></div></figure><figure class="kz la mw lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/51c3a27f90517ee4e6360f887eb3b18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*u-dQ0YstgB4XVy2ejUDrcg.png"/></div></figure></div><div class="ab cb"><figure class="kz la mw lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/e6e33f8717778f2a5c7ed8f17855308a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*eGFjhIz0agsNM2F3ul41Eg.png"/></div></figure><figure class="kz la mw lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/c225765668ba06a1179ee5ead3ff4da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*hIvTR46RLurCkZCgkvdWvQ.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx mx di my lt translated">对于较小的污染值，该算法是保守的，检测到的异常很少。随着污染的增加，它将更多的“外部”点标记为异常。</figcaption></figure></div><p id="75a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所见，设置正确的污染是非常重要的。<em class="jr">污染应设置为我们对异常数据点比例的最佳估计值。</em></p><h2 id="4ae7" class="ma jt hi bd ju mf mg mh jy mi mj mk kc iq ml mm kg iu mn mo kk iy mp mq ko mr bi translated">如果我们没有对污染的估计，该怎么办？</h2><p id="80c4" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">然后，我们从稳健平均值直接计算每个点的Mahalanobis距离，并基于数据中Mahalanobis距离的分布为其设置截止值。我们执行以下操作:</p><ol class=""><li id="99dc" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">将<strong class="ih hj"> sklearn .协方差. EllipticEnvelope() </strong>拟合到数据。</li><li id="a97a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">使用<code class="du mz na nb lw b"><a class="ae ms" href="https://scikit-learn.org/stable/modules/generated/sklearn.covariance.EllipticEnvelope.html#sklearn.covariance.EllipticEnvelope.mahalanobis" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">mahalanobis</strong></a>()</code>方法计算每个数据点与稳健平均值的马氏距离。</li><li id="8732" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">可视化数据中的马氏距离分布。确定一个阈值，超过该阈值的点将被称为异常值-通过可视化距离<strong class="ih hj">或</strong>的分布，对距离使用单变量异常检测算法来找出哪些距离是异常的。</li></ol><p id="4bb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另外，请注意，污染值在这种方法中并不重要，因此我们设置为任意值。</p><pre class="kv kw kx ky fd lv lw lx ly aw lz bi"><span id="1a0a" class="ma jt hi lw b fi mb mc l md me"># Create Data - with Anomaly - as before.<br/>d1 = np.random.multivariate_normal(mean = np.array([-.5, 0]),<br/>                               cov = np.array([[1, 0], [0, 1]]), size = 100)</span><span id="546a" class="ma jt hi lw b fi mu mc l md me">d2 = np.random.multivariate_normal(mean = np.array([15, 10]),<br/>                               cov = np.array([[1, 0.3], [.3, 1]]), size = 100)</span><span id="909b" class="ma jt hi lw b fi mu mc l md me">outliers = np.array([[0, 10],[0, 9.5]])<br/>d = pd.DataFrame(np.concatenate([d1, d2, outliers], axis = 0), columns = ['Var 1', 'Var 2'])</span><span id="36b9" class="ma jt hi lw b fi mu mc l md me">###### Fit Elliptic Envelope ##############</span><span id="6f49" class="ma jt hi lw b fi mu mc l md me">contamination = .4 # We can set any value here as we will now use our own threshold<br/>el = covariance.EllipticEnvelope(store_precision=True, assume_centered=False, support_fraction=None, <br/>                                    contamination=contamination, random_state=0)<br/># Fit the data<br/>el.fit(d)<br/>############# New Part ################</span><span id="4e9d" class="ma jt hi lw b fi mu mc l md me"># Create column that measures Mahalanobis distance<br/>d['Mahalanobis Distance'] = el.mahalanobis(d)</span><span id="6f0f" class="ma jt hi lw b fi mu mc l md me"># Create scatterplot and color the anomalies differently<br/>plt.figure(figsize = (12, 6))<br/>ax = plt.scatter(d['Var 1'], d['Var 2'], c = d['Mahalanobis Distance'], cmap = 'coolwarm')<br/>#plt.title('Contamination = Does not matter for this method', weight = 'bold')<br/>#ax = sns.scatterplot(d['Var 1'], d['Var 2'], c = d['Anomaly or Not'])<br/>plt.xlabel('Var 1')<br/>plt.ylabel('Var 2')<br/>plt.colorbar(label = 'Mahalanobis Distance')<br/>plt.grid()<br/></span></pre><div class="kv kw kx ky fd ab cb"><figure class="kz la nc lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/b5249f2de318bbc8b24ac7a8161ab5ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*qw1lZq-_Jg29JfD3shD25A.png"/></div></figure><figure class="kz la nd lc ld le lf paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/a1c0d2e61fe060a972ef1437203f2849.png" data-original-src="https://miro.medium.com/v2/resize:fit:1134/format:webp/1*m8QSXo-NhDcvZaqaViq1lQ.png"/></div><figcaption class="ln lo et er es lp lq bd b be z dx ne di nf lt translated">如我们所见，两个异常的马氏距离大于其余数据的马氏距离。</figcaption></figure></div><p id="6efe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们确定一个马哈拉诺比斯距离的阈值。一种方法是对计算的马氏距离应用单变量异常检测算法，这是有意义的，因为我们通过计算马氏距离将2D数据转换为1D数据。现在，这个距离代表我们在1D的数据，我们可以对它使用单变量异常检测方法。让我们对数据中的马哈拉诺比斯距离作一个箱线图，并用图基的方法找出极限距离。</p><figure class="kv kw kx ky fd la er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es ng"><img src="../Images/6a161420e770fc8cd00d7c0f77d8a907.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjyzJonH7G0jQZRZpRcLsg.png"/></div></div><figcaption class="ln lo et er es lp lq bd b be z dx translated">我们可以在100附近看到2个明显的异常值——事实上，这是我们迄今为止发现的2个异常点。</figcaption></figure><p id="f806" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在清楚地看到100附近的2个点是强异常。20附近还有一个点被贴上了异常的标签——需要进一步分析。</p><p id="4b1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们刚才所做的是一项标准技术— <strong class="ih hj">我们通过计算每个点与稳健平均值的马氏距离，将多变量异常值检测问题转化为单变量异常值检测问题。然后，我们在这个距离上应用单变量方法。</strong></p><p id="7a2e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，我们可以简单地制作一个直方图，直观地确定一个好的阈值。</p><p id="b8fc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注意:</strong>马哈拉诺比斯距离方法甚至适用于数百个特征。为了便于可视化，我在讨论中使用了两个变量。</p><h1 id="9de9" class="js jt hi bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">摘要</h1><p id="ccb5" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">我们讨论了异常检测中的三大类问题以及用于解决这些问题的三大类技术。我们讨论了多元方法的重要性，当我们拥有高维数据时，多元方法通常可以提供EDA无法提供的见解。我们讨论了针对单变量和多变量情况执行异常检测的稳健方法。对于多变量技术，我们讨论了Mahalanobis距离方法的稳健变化，并讨论了<strong class="ih hj">将多变量异常检测问题转化为单变量问题的一般方法。在接下来的文章中，我们将讨论自动编码器、隔离森林、OC-SVM等方法。</strong></p><p id="96e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何反馈，请随时告诉我。</p></div></div>    
</body>
</html>