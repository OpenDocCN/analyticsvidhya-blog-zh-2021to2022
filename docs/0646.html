<html>
<head>
<title>Parallel Hyperparameter tuning in Julia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Julia中的并行超参数调谐</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parallel-hyperparameter-tuning-in-julia-2eb17e756043?source=collection_archive---------17-----------------------#2021-01-25">https://medium.com/analytics-vidhya/parallel-hyperparameter-tuning-in-julia-2eb17e756043?source=collection_archive---------17-----------------------#2021-01-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8f56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我之前的<a class="ae jc" href="https://iwasnothing.medium.com/use-oscillator-of-rsi-in-machine-learning-prediction-of-stock-return-8de6b9543315" rel="noopener">帖子</a>中，我使用的超参数是通过包<a class="ae jc" href="https://github.com/baggepinnen/Hyperopt.jl" rel="noopener ugc nofollow" target="_blank">超视</a>找到的。用法非常简单，它只是利用不同的采样器在我指定的参数范围内循环。</p><h1 id="a77b" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">软件包安装</h1><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="2bd7" class="kk je hh kg b fi kl km l kn ko">Pkg.add("Hyperopt")</span></pre><h2 id="d961" class="kk je hh bd jf kp kq kr jj ks kt ku jn ip kv kw jr it kx ky jv ix kz la jz lb bi translated">用法:</h2><p id="a8d2" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated"><strong class="ig hi">参数</strong> : <em class="lh"> seqlen，Nh，delta，lr，mm，day0 </em></p><p id="eaea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">目标函数</strong> : <em class="lh"> myObjective </em>，将调用我的模型训练，并返回目标成本。客观成本可以是我们旨在最小化的培训损失。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="4746" class="kk je hh kg b fi kl km l kn ko">using Hyperopt</span><span id="d2cd" class="kk je hh kg b fi li km l kn ko">ho = @hyperopt for i=20,<br/>sampler = RandomSampler(), <br/>seqlen = StepRange(3, 5, 20),<br/>Nh = StepRange(5,3, 20),<br/>delta = StepRange(10,5, 25),<br/>lr =  exp10.(LinRange(-4,-3,10)),<br/>mm =  LinRange(0.75,0.95,5),<br/>day0 = StepRange(5,3, 10)</span><span id="a52e" class="kk je hh kg b fi li km l kn ko">@show myObjective(etf,seqlen,Nh,lr,mm,day0,day0+delta,:reg,i)</span><span id="498d" class="kk je hh kg b fi li km l kn ko">end</span><span id="c0ac" class="kk je hh kg b fi li km l kn ko">best_params, min_f = ho.minimizer, ho.minimum</span></pre><h1 id="d0c6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">并行执行</h1><p id="4b6e" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">超参数调整通常需要很长时间。在Julia中，我们可以让它跨多个工作进程并行运行。下面是创建4个工人进程的代码。运行下面的代码后，使用函数"<em class="lh"> nworkers() </em>"显示有4个工作进程。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="4b65" class="kk je hh kg b fi kl km l kn ko">using Distributed<br/>addprocs(4)</span></pre><p id="a0f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了让每个worker进程知道我们代码的所有引用，我首先把所有的模型训练代码放在模块"<em class="lh"> OsRSIConv.jl </em>"中。下面的代码将生成模块及其目录和文件“Project.toml”。然后折射模块定义中的代码，放入它创建的文件夹:“<a class="ae jc" href="https://github.com/iwasnothing/JuliaConvGRU/blob/main/OsRSIConv/src/OsRSIConv.jl" rel="noopener ugc nofollow" target="_blank"><em class="lh">OsRSIConv/src/OsRSIConv . JL</em></a>”。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="c784" class="kk je hh kg b fi kl km l kn ko">Pkg.generate("OsRSIConv")</span></pre><p id="d59b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后使用宏“<em class="lh"> @everywhere </em>”要求每个工作进程安装所需的包，并加载模块“<em class="lh"> OsRSIConv.jl </em>”。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="cdc3" class="kk je hh kg b fi kl km l kn ko"><a class="ae jc" href="http://twitter.com/everywhere" rel="noopener ugc nofollow" target="_blank">@everywhere</a> include("installPkg.jl")<br/><a class="ae jc" href="http://twitter.com/everywhere" rel="noopener ugc nofollow" target="_blank">@everywhere</a> push!(LOAD_PATH, "OsRSIConv/");<br/><a class="ae jc" href="http://twitter.com/everywhere" rel="noopener ugc nofollow" target="_blank">@everywhere</a> using OsRSIConv</span></pre><p id="0f04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后只需将宏“@hyperopt”改为“@phyperopt”，它将自动在所有可用的工作进程上运行循环。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="6cbb" class="kk je hh kg b fi kl km l kn ko">ho = @phyperopt for i=20,<br/>sampler = RandomSampler(), <br/>seqlen = StepRange(3, 5, 20),<br/>Nh = StepRange(5,3, 20),<br/>delta = StepRange(10,5, 25),<br/>lr =  exp10.(LinRange(-4,-3,10)),<br/>mm =  LinRange(0.75,0.95,5),<br/>day0 = StepRange(5,3, 10)</span><span id="d03d" class="kk je hh kg b fi li km l kn ko">@show myObjective(etf,seqlen,Nh,lr,mm,day0,day0+delta,:reg,i)</span><span id="9369" class="kk je hh kg b fi li km l kn ko">end</span><span id="6ee9" class="kk je hh kg b fi li km l kn ko">best_params, min_f = ho.minimizer, ho.minimum</span></pre><p id="7bcc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用4个工作进程，我获得了2.3倍的速度提升。</p><blockquote class="lj lk ll"><p id="7037" class="ie if lh ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">非平行远视:630.5秒</p><p id="506d" class="ie if lh ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">并行phyperot:264.4秒</p></blockquote><h1 id="60e5" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">附赠曲目</h1><p id="b5b8" class="pw-post-body-paragraph ie if hh ig b ih lc ij ik il ld in io ip le ir is it lf iv iw ix lg iz ja jb ha bi translated">使用机器学习模型的好处之一是，我可以用不同股票的数据应用同一个模型进行训练。我可以在股票符号数组的循环中运行训练。</p><p id="737b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了加快训练速度，我可以使用Julia并行计算功能非常轻松地并行运行它。</p><p id="8497" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，我们需要添加和加载每个工作进程所需的所有包。然后只需使用函数“<em class="lh"> pmap </em>”对数组中的每个符号应用训练函数“<em class="lh"> trainPredict </em>”。</p><pre class="kb kc kd ke fd kf kg kh ki aw kj bi"><span id="ea3f" class="kk je hh kg b fi kl km l kn ko">include("installPkg.jl")<br/>tstart = time()<br/>list = ["FB","AAPL","AMZN","GOOG","NFLX","SQ","MTCH","AYX","ROKU","TTD"]</span><span id="dfc2" class="kk je hh kg b fi li km l kn ko">result = pmap(OsRSIConv.trainPredict,list)<br/>print(result)<br/>println(vcat(result))<br/>tend=time()<br/>et=tend-tstart<br/><a class="ae jc" href="http://twitter.com/show" rel="noopener ugc nofollow" target="_blank">@show</a> et</span></pre><p id="f938" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结果</strong></p><blockquote class="lj lk ll"><p id="d867" class="ie if lh ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">顺序循环基线:398秒</p><p id="f7cc" class="ie if lh ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">地图(平行循环):187秒</p></blockquote><p id="e344" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lh">来源:</em><a class="ae jc" href="https://github.com/iwasnothing/JuliaConvGRU/blob/main/parallel.ipynb" rel="noopener ugc nofollow" target="_blank"><em class="lh">parallel . ipynb</em></a></p></div></div>    
</body>
</html>