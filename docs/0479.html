<html>
<head>
<title>Explicit understanding of python package building (structuring) -part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对python包构建(结构化)的明确理解——第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/explicit-understanding-of-python-package-building-structuring-4ac7054c0749?source=collection_archive---------1-----------------------#2021-01-18">https://medium.com/analytics-vidhya/explicit-understanding-of-python-package-building-structuring-4ac7054c0749?source=collection_archive---------1-----------------------#2021-01-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/b716e0d74a9583aadc98f54883dc4330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGjvKkRa8mrYCqr10QSDCQ.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">威利·芬伯格在<a class="ae iu" href="https://unsplash.com/s/photos/architecture?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="6283" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是构建python包系列文章的第二部分。在前一篇文章中，我们讨论了如何对你的代码库和文档的概念进行版本控制。在本文中，我们将讨论如何将该代码转换成一个实际的包，该包的工作方式类似于您使用的常规python库。</p><p id="e8a9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有很多方法可以把你的代码转换成一个包。构建包和创建包结构是完全不同的事情。因为你必须使用打包工具将你的代码转换成一个包，但是正确的做法是代码库的形状与构建工具相兼容。</p><p id="7314" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，为什么会有几种封装架构？没有通用的吗？。事实上，不是。原因是架构依赖于您正在构建的工件的范围和包的使用。因此，有一些通用的布局模式:</p><blockquote class="jt ju jv"><p id="fbe3" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> <em class="hi">命令行应用布局</em> </strong></p></blockquote><p id="096e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种类型的应用程序可以下载和安装，然后将代码作为外部模块导入，或者直接在终端中运行。</p><ul class=""><li id="145c" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><em class="jw"> python模块布局</em></li><li id="d59c" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><em class="jw"> python包布局</em></li><li id="126c" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><em class="jw"> python库布局</em></li></ul><p id="69d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">附注:以上布局/架构的名称并不标准，但都是常用的术语。特别是，<code class="du ko kp kq kr b">setuptools</code>库支持轻松创建以上3种结构。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="5f39" class="la lb hi kr b fi lc ld l le lf">package_folder/<br/>│<br/>├── .gitignore<br/>├── src/<br/>├── logs/<br/>├── docs/<br/>├── bin/<br/>├── data/<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>├── test/<br/>└── setup.py</span></pre><p id="b209" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是任何python包的最小布局。在你建立模型之后，有另外的文件夹。如；<code class="du ko kp kq kr b">dist/</code>、<code class="du ko kp kq kr b">build/</code>。</p><p id="51ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">。gitignore </em> —正如我们在上一篇文章中讨论的，我们的版本控制系统是git，我们使用GitHub作为存储库控制器。因此，有些文件我们不想上传到远程存储库。喜欢；日志、bin、数据、分布、构建。这里我们用。gitignore文件来丢失这些文件的git跟踪。大多数语言都有这个文件的<a class="ae iu" href="https://www.toptal.com/developers/gitignore" rel="noopener ugc nofollow" target="_blank">模板</a>，你可以根据自己的喜好在那里添加或删除行。还有编辑这些文件的规则和语法。</p><p id="dc03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">src/</em>-这是包含python包代码的文件夹。此文件夹的结构因您选择的应用程序布局而异。</p><p id="1fc0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw"> logs/ </em> —日志文件保存在该文件夹中。</p><p id="86f1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw"> LICENSE </em> —该文件显示发行商为用户提供的软件包和设施以及限制的许可。使用知名许可比使用自创许可更好。喜欢；<a class="ae iu" href="https://www.gnu.org/licenses/gpl-3.0.en.html" rel="noopener ugc nofollow" target="_blank"> GNU </a>，<a class="ae iu" href="https://www.apache.org/licenses/LICENSE-2.0" rel="noopener ugc nofollow" target="_blank"> Apache许可</a>，<a class="ae iu" href="https://opensource.org/licenses/MIT" rel="noopener ugc nofollow" target="_blank"> MIT许可</a>，<a class="ae iu" href="https://creativecommons.org/choose/" rel="noopener ugc nofollow" target="_blank">知识共享许可</a>。</p><p id="1712" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">readme . MD</em>——通常，这是一个<a class="ae iu" href="https://www.markdownguide.org/getting-started/" rel="noopener ugc nofollow" target="_blank"> markdown </a>文件【因为它易于编辑并得到广泛支持。]加上...的扩展名。md或<a class="ae iu" href="https://www.latex-project.org/" rel="noopener ugc nofollow" target="_blank"> LaTeX </a>文件【python创建的纯文本文件】，扩展名为. TeX，这是我们在上一篇文章中讨论过的docs文件。</p><p id="cb7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw"> requirements.txt </em> —这里，是你的包依赖项。如果您熟悉python虚拟环境[pip，conda]，您会记得从CLI生成该文件的一个命令。<code class="du ko kp kq kr b">pip freeze &gt; requirements.txt</code>。然而，在这种情况下使用它并不是好的做法。因为该命令向需求文件添加了次要依赖项。通常，下面的方法是检查<code class="du ko kp kq kr b">src/</code> dir文件并手动添加这些文件中的所有导入库。与库一样，unittest、tox也不能包含在该文件中。因为这些库只供开发人员使用。]</p><p id="55e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">test/</em>——如果你已经为你的包编写了单元测试，那么这些文件就放在这个文件夹下。</p><p id="55b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw"> setup.py </em> —这是文件夹目录中最关键的文件。因为这个文件说，所有关于包的所有细节都给了包构建者。创建这个文件有几种可接受的开发实践。此外，文件的某些部分会根据您的应用程序布局而变化。</p><p id="ba42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果这个包是一个复杂的包，那么您也将创建以下目录。</p><p id="fa65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">docs/——正如我们在上一篇文章中讨论的，这个文件夹是用于库的外部综合文档。通常，该文件夹包含。md，。HTML，。css文件。这是Github </em> <a class="ae iu" href="https://pages.github.com/" rel="noopener ugc nofollow" target="_blank"> <em class="jw">页面上你的页面主机</em></a><em class="jw"/><a class="ae iu" href="https://www.mkdocs.org/" rel="noopener ugc nofollow" target="_blank"><em class="jw">MkDocs、</em> </a> <em class="jw">或</em><a class="ae iu" href="https://readthedocs.org/" rel="noopener ugc nofollow" target="_blank"><em class="jw">readthedocs</em></a><em class="jw">站点</em></p><p id="2e6c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">bin/——这里是您在包实现中使用的所有可执行文件。如果你的包是纯python的，这里没什么可放的。但是如果你使用了一些C或C++代码，那么它们的可执行文件必须保存在这里。</p><p id="ede6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">data/——如果你已经使用了一些文本文件来保存变量或参数或数据，那么这些文件就放在这个文件夹下</em></p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><blockquote class="jt ju jv"><p id="650c" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> python模块布局</strong></p></blockquote><p id="49bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在python导入中，在外部文件中编写的代码会导致将导入的文件命名为当前名称空间中的“模块”。<strong class="ix hj">这个词命名空间</strong>有点特殊。<strong class="ix hj">名称空间</strong>在python这样的语言中起着重要作用，因为它们使用词法作用域作为作用域规则，函数是一级对象。作为总结，当你键入<code class="du ko kp kq kr b">from file_name import function</code>时，函数克隆到当前工作变量空间，而不是在原始变量空间上处理。</p><p id="a24c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">或多或少，这里我们关心的是将python包创建为一个模块。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="aed4" class="la lb hi kr b fi lc ld l le lf">pgk_name/<br/>│<br/>├── src/<br/>│   ├── module_1.py<br/>│   └── module_2.py<br/>│<br/>├── tests/<br/>│   ├── module_1_test.py<br/>│   └── module_2_test.py<br/>│<br/>├── .gitignore<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>└── setup.py</span></pre><p id="be62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，主要有<code class="du ko kp kq kr b">src/</code>和<code class="du ko kp kq kr b">setup.py</code>的变化。</p><p id="c052" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ko kp kq kr b">src/</code>目录下的文件是包实现的代码。在由<code class="du ko kp kq kr b">if __name__ == "__main__" :</code>定义的if条件块下，将所有本地操作添加到像<code class="du ko kp kq kr b">module_1.py</code>这样的文件中是一个很好的做法。事实上，这个块下的所有代码只在文件本身执行时才运行。所以，这防止了在词法克隆功能时运行一些代码。</p><p id="e9b8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，包的行为方式也取决于setup.py文件的配置。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="fad2" class="la lb hi kr b fi lc ld l le lf">package_dir={'': 'src'},</span><span id="c3e0" class="la lb hi kr b fi ln ld l le lf">py_modules = ["module_1", "module_2"],</span></pre><p id="324e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您使用<code class="du ko kp kq kr b">setuptools</code>作为打包模块时，这是最简单的方法。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><blockquote class="jt ju jv"><p id="79c3" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> python包布局</strong></p></blockquote><p id="a09f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">实际上，包在结构和行为上与python模块略有不同。你可以在文件的顶部说<code class="du ko kp kq kr b">import numpy</code>，在那之后的任何地方，你可以通过使用像<code class="du ko kp kq kr b">numpy.array()</code>这样的点操作来访问任何功能。模块中不存在功能克隆。</p><p id="59f8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你熟悉OOP概念，这和OOP中的打包完全一样，唯一的区别是这个包是可移植的。</p><p id="7d3c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您使用的是像pycharm、eclipse — pydev这样的IDE，您只需点击几下鼠标就可以为包创建一个文件夹结构。然而，这很简单。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="3582" class="la lb hi kr b fi lc ld l le lf">project_name/<br/>│<br/>├── pkg_name/<br/>│   ├── __init__.py<br/>│   ├── file_1.py<br/>│   └── internal_pck/<br/>│       ├── __init__.py<br/>│       ├── int_file_1.py<br/>│       └── int_file_2.py<br/>│<br/>├── tests/<br/>│   └── pkg_name_test<br/>│       ├── file_1_tests.py<br/>│       └── internalpkg_name<br/>│          ├── int_file_1_tests.py<br/>│          └── int_file_2_tests.py<br/>│<br/>├── .gitignore<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>└── setup.py</span></pre><p id="3515" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要的区别是没有<code class="du ko kp kq kr b">src/</code>文件夹，有一个文件夹有你的包的名字，并且总是以<code class="du ko kp kq kr b">__init__.py</code>文件开始。这是为什么呢？实际上，在这里你是在创造一个具有可以与外部世界互动的界面的机器。此外，您可以通过在<code class="du ko kp kq kr b">pkg_name/</code>目录而不是<code class="du ko kp kq kr b">__init__.py</code>文件中写入文件来定义机器做什么，它们如何做这些。那个文件是定义这个包的接口，说什么功能可以在使用这个包的时候被一个外部文件访问。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="e900" class="la lb hi kr b fi lc ld l le lf">from .file_1 import function_1<br/>from .internal_pkg import function_2<br/>import logging</span><span id="1e6a" class="la lb hi kr b fi ln ld l le lf">logger = logging.getLogger(__name__)<br/>logger.setLevel(logging.INFO)</span><span id="d4be" class="la lb hi kr b fi ln ld l le lf">__all__ = [<br/>    'function_1',<br/>    'function_2'<br/>]</span></pre><p id="6fd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个例子有点复杂，因为包里面有一个包。创建封装内部包的<code class="du ko kp kq kr b">pkg</code>接口是至关重要的，否则这个例子将在我们的下一个主题中讨论。</p><p id="6f0b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不仅<code class="du ko kp kq kr b">src/</code>文件夹中的更改，而且<code class="du ko kp kq kr b">setup.py</code>也必须相应更改。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="a856" class="la lb hi kr b fi lc ld l le lf">packages=['pkg_name','pkg_name/<!-- -->internal_pck<!-- -->'],</span></pre><p id="29ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在构建<em class="jw">轮子或egg文件时，setuptool会识别包中的所有文件，并将它们导入到最终构建中。</em>如果没有内部包，只需定义包名就足够了。如果有内部包，并且主包使用那些内部包提供的一些功能，那么定义那些包目录是必不可少的。</p></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><blockquote class="jt ju jv"><p id="8b67" class="iv iw jw ix b iy iz ja jb jc jd je jf jx jh ji jj jy jl jm jn jz jp jq jr js hb bi translated"><strong class="ix hj"> python库布局</strong></p></blockquote><p id="e37a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是python打包的扩展版本。因为这里的python库包含了不止一个python包，这些包[大部分]都是相互独立工作的，它们有自己的接口与外部接口一起工作。这种python库的一个很好的例子是<code class="du ko kp kq kr b">scikit-learn</code>，因为<code class="du ko kp kq kr b">scikit-learn</code>库包含像<code class="du ko kp kq kr b">Regression, Classification, Preprcess, Ensemble, etc.</code>这样的包</p><p id="4d26" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">文件夹结构的定义主要有两种不同的方式，但<code class="du ko kp kq kr b">setup.py</code>文件的配置与上述相同。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="d002" class="la lb hi kr b fi lc ld l le lf">project_name/<br/>│<br/>├── lib_name/<br/>│   ├── __init__.py<br/>│   ├── file_1.py<br/>│   ├── pkg_1/<br/>│   │   ├── __init__.py<br/>│   │   ├── file_1.py<br/>│   │   └── file_2.py<br/>│   │<br/>│   └── pkg_2/<br/>│       ├── __init__.py<br/>│       ├── file_3.py<br/>│       └── file_4.py<br/>│<br/>├── tests/<br/>│<br/>├── .gitignore<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>└── setup.py</span></pre><p id="dd90" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与上面的例子不同的是，这里你从主库接口引用内部包接口[<code class="du ko kp kq kr b">__init__.py</code>]。因此，在运行时，用户可以通过使用点操作来访问内部函数。然而，定义<code class="du ko kp kq kr b">test/</code>比上面的结构更复杂。</p><pre class="ks kt ku kv fd kw kr kx ky aw kz bi"><span id="803e" class="la lb hi kr b fi lc ld l le lf">project_name/<br/>│<br/>├── pkg_1/<br/>│   ├── __init__.py<br/>│   ├── module_1.py<br/>│   └── module_2.py<br/>├── pkg_2/<br/>│   ├── __init__.py<br/>│   ├── module_1.py<br/>│   └── module_2.py<br/>│<br/>├── tests/<br/>│<br/>├── .gitignore<br/>├── LICENSE<br/>├── README.md<br/>├── requirements.txt<br/>└── setup.py</span></pre><p id="f092" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一种在一个名字下提供多个包的方式。所以，这里用户感觉有不同的包，但是开发者包测试比上面的方法更容易。然而，构建python库的最正式的方法是先定义。</p><p id="0233" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">链接:</p><p id="49c2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://packaging.python.org/tutorials/packaging-projects/" rel="noopener ugc nofollow" target="_blank">包装用PyPA导轨</a></p><p id="dd5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://docs.python.org/3/reference/import.html#regular-packages" rel="noopener ugc nofollow" target="_blank">命名空间包&amp;常规包</a>的区别</p><p id="50ab" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://www.python.org/dev/peps/pep-0420/" rel="noopener ugc nofollow" target="_blank"> PEP 420 —名称空间打包指南</a></p><figure class="ks kt ku kv fd ij"><div class="bz dy l di"><div class="lo lp l"/></div></figure><div class="lq lr ez fb ls lt"><a href="https://realpython.com/lessons/preparing-your-package-publication/" rel="noopener  ugc nofollow" target="_blank"><div class="lu ab dw"><div class="lv ab lw cl cj lx"><h2 class="bd hj fi z dy ly ea eb lz ed ef hh bi translated">准备在PyPI - Real Python上发布您的包</h2><div class="ma l"><h3 class="bd b fi z dy ly ea eb lz ed ef dx translated">现在包的代码部分已经准备好上传了，但是在你可以分享你的…</h3></div><div class="mb l"><p class="bd b fp z dy ly ea eb lz ed ef dx translated">realpython.com</p></div></div><div class="mc l"><div class="md l me mf mg mc mh io lt"/></div></div></a></div></div><div class="ab cl lg lh gp li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hb hc hd he hf"><p id="efd6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们只是把我在上一篇文章中提到的一个话题转换到了我们要讨论的内容之下。因此，摆在我们面前的是一系列议题:</p><ul class=""><li id="d8f3" class="ka kb hi ix b iy iz jc jd jg kc jk kd jo ke js kf kg kh ki bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/explicit-understanding-of-python-package-building-coding-93fa72c7cb95">文件和版本控制</a> ✅</li><li id="e6f4" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated"><a class="ae iu" rel="noopener" href="/analytics-vidhya/explicit-understanding-of-python-package-building-structuring-4ac7054c0749">包装架构</a> ✅</li><li id="749b" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">python装饰者</li><li id="7aad" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">python生成器</li><li id="acb3" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">python上下文管理器</li><li id="0ced" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">面向对象的设计模式用法</li><li id="4808" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">包测试——单元测试——没有模仿/模仿</li><li id="e0c2" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">异常处理和调试</li><li id="1dfb" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">CI/CD管道建筑</li><li id="542a" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">自动化CI/CD管道</li><li id="5fe4" class="ka kb hi ix b iy kj jc kk jg kl jk km jo kn js kf kg kh ki bi translated">未来兼容性</li></ul><p id="8022" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不久我们将看到pythonic的另一篇文章！！。</p><p id="5838" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jw">谢谢。</em></p></div></div>    
</body>
</html>