<html>
<head>
<title>Longest Common Subsequence</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最长公共子序列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/longest-common-subsequence-2f4f830be14f?source=collection_archive---------20-----------------------#2021-03-03">https://medium.com/analytics-vidhya/longest-common-subsequence-2f4f830be14f?source=collection_archive---------20-----------------------#2021-03-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/425b2d415d3d1631e288e0ba81c54434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lu0tn6PEQliWQaNO"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">由<a class="ae it" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Markus Spiske </a>在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><blockquote class="iu iv iw"><p id="8c9c" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">写一个函数，找出两个序列之间的<strong class="ja hi">最长公共子序列</strong>的长度。</p><p id="2a9e" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated">例如，给定字符串“serendipitous”和“deposition ”,最长的公共子序列是“reipito ”,其长度是7。</p></blockquote></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="7313" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated"><strong class="ja hi"> <em class="iz">递归方法</em> </strong> →</p><ol class=""><li id="4e8e" class="kg kh hh ja b jb jc jf jg kd ki ke kj kf kk jv kl km kn ko bi translated">从0开始创建两个计数器<code class="du kp kq kr ks b">idx1</code>和<code class="du kp kq kr ks b">idx2</code>。我们的递归函数将计算<code class="du kp kq kr ks b">seq1[idx1:]</code>和<code class="du kp kq kr ks b">seq2[idx2:]</code>的LCS</li><li id="d40b" class="kg kh hh ja b jb kt jf ku kd kv ke kw kf kx jv kl km kn ko bi translated">如果<code class="du kp kq kr ks b">seq1[idx1]</code>和<code class="du kp kq kr ks b">seq2[idx2]</code>相等，那么这个人物属于<code class="du kp kq kr ks b">seq1[idx1:]</code>和<code class="du kp kq kr ks b">seq2[idx2:]</code>的LCS(为什么？).更进一步的长度这就是LCS比<code class="du kp kq kr ks b">seq1[idx1+1:]</code>和<code class="du kp kq kr ks b">seq2[idx2+1:]</code>的LCS多一个</li></ol><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es ky"><img src="../Images/bfa1d8748b1cbadf368b834d73306795.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/0*TD9tcw4UYTNDAebv.png"/></div></figure><p id="0a27" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">3.如果不是，则<code class="du kp kq kr ks b">seq1[idx1:]</code>和<code class="du kp kq kr ks b">seq2[idx2:]</code>的LCS是<code class="du kp kq kr ks b">seq1[idx1+1:], seq2[idx2:]</code>的LCS和<code class="du kp kq kr ks b">seq1[idx1:]</code>、<code class="du kp kq kr ks b">seq2[idx2+1:]</code>的LCS中较长的一个</p><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/95e8b88e26608064bddb608388ba5516.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/0*rZu8C2IVH7v1_XDb.png"/></div></figure><p id="6785" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">4.如果<code class="du kp kq kr ks b">seq1[idx1:]</code>或<code class="du kp kq kr ks b">seq2[idx2:]</code>为空，则它们的LCS为空。</p><p id="d02d" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">下面是递归调用树的样子:</p><figure class="kz la lb lc fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/d2533e600fa9f904b0e51c278f879f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fYrE4p8sdAnOztri.png"/></div></div></figure><pre class="kz la lb lc fd lf ks lg lh aw li bi"><span id="d22e" class="lj lk hh ks b fi ll lm l ln lo">def lcs_recursive(seq1, seq2, idx1=0, idx2=0):<br/>    if idx1 == len(seq1) or idx2 == len(seq2):<br/>        return 0<br/>    elif seq1[idx1] == seq2[idx2]:<br/>       return 1 + lcs_recursive(seq1, seq2, idx1+1, idx2+1)<br/>    else:<br/>       option1 = lcs_recursive(seq1, seq2, idx1+1, idx2)<br/>       option2 = lcs_recursive(seq1, seq2, idx1, idx2+1)<br/>       return max(option1, option2)</span></pre><p id="c7d0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated"><strong class="ja hi"> <em class="iz">算法复杂低效→ </em> </strong></p><p id="852e" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">最坏的情况发生在每次我们必须尝试2个子问题时，即当序列没有公共元素时。</p><p id="0120" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">时间复杂性是O(2^(m+n)).</p><p id="b4b5" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">它通过使用一种叫做<em class="iz">记忆</em>(即记忆)的技术来克服。它用于存储中间重复结果，以备将来参考。</p><pre class="kz la lb lc fd lf ks lg lh aw li bi"><span id="e482" class="lj lk hh ks b fi ll lm l ln lo">def lcs_memo(seq1, seq2):<br/>    memo = {}<br/>    def recurse(idx1=0, idx2=0):<br/>        key = (idx1, idx2)<br/>        if key in memo:<br/>            return memo[key]<br/>        elif idx1 == len(seq1) or idx2 == len(seq2):<br/>            memo[key] = 0<br/>        elif seq1[idx1] == seq2[idx2]:<br/>            memo[key] = return 1 + recurse(idx1+1, idx2+1)<br/>        else:<br/>            memo[key] = max(recurse(idx1+1, idx2), recurse(idx1, idx2+1))<br/>        return memo[key]<br/>    return recurse(0, 0)</span></pre></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><p id="6946" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">但是，递归的使用增加了空间复杂度，因为对于每个调用，需要分配空间，并且该过程继续。因此，该问题的解决方案是<em class="iz">迭代方法，</em>可通过以下方式实现:</p><p id="cf1b" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated"><strong class="ja hi"> <em class="iz">动态编程→ </em> </strong></p><ol class=""><li id="4ecb" class="kg kh hh ja b jb jc jf jg kd ki ke kj kf kk jv kl km kn ko bi translated">创建一个用0初始化的大小为<code class="du kp kq kr ks b">(n1+1) * (n2+1)</code>的表，其中<code class="du kp kq kr ks b">n1</code>和<code class="du kp kq kr ks b">n2</code>是序列的长度。<code class="du kp kq kr ks b">table[i][j]</code>代表<code class="du kp kq kr ks b">seq1[:i]</code>和<code class="du kp kq kr ks b">seq2[:j]</code>的最长公共子序列。下面是表格的样子(来源:Kevin Mavani，Medium)。</li></ol><figure class="kz la lb lc fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/774b002041277da5045091a325cb819b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*UEUV0sL2MqiiqiF8.png"/></div></figure><p id="8c3d" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">2.如果<code class="du kp kq kr ks b">seq1[i]</code>和<code class="du kp kq kr ks b">seq2[j]</code>相等，则<code class="du kp kq kr ks b">table[i+1][j+1] = 1 + table[i][j]</code></p><p id="01a3" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">3.如果<code class="du kp kq kr ks b">seq1[i]</code>和<code class="du kp kq kr ks b">seq2[j]</code>相等，则<code class="du kp kq kr ks b">table[i+1][j+1] = max(table[i][j+1], table[i+1][j])</code></p><pre class="kz la lb lc fd lf ks lg lh aw li bi"><span id="4d74" class="lj lk hh ks b fi ll lm l ln lo">def lcs_dp(seq1, seq2):<br/>    n1, n2 = len(seq1), len(seq2)<br/>    table = [[0 for x in range(n2)] for x in range(n1)]<br/>    for idx1 in range(n1):<br/>        for idx2 in range(n2):<br/>            if seq1[idx1] == seq2[idx2]:<br/>                table[i+1][j+1] = 1 + table[i][j]<br/>            else:<br/>                table[i+1][j+1] = max(table[i][j+1], table[i+1][j])<br/>    return table[-1][-1]</span></pre><p id="c84d" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji kd jk jl jm ke jo jp jq kf js jt ju jv ha bi translated">对于这种方法…时间复杂度是O(N1 * N2)。</p></div></div>    
</body>
</html>