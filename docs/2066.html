<html>
<head>
<title>Introduction to Julia MLJ</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">朱莉娅·MLJ简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-julia-mlj-96a806815cb2?source=collection_archive---------17-----------------------#2021-04-03">https://medium.com/analytics-vidhya/introduction-to-julia-mlj-96a806815cb2?source=collection_archive---------17-----------------------#2021-04-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b018" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将使用<a class="ae jd" href="https://datahack.analyticsvidhya.com/contest/practice-problem-loan-prediction-iii/?utm_source=auto-email#MySubmissions" rel="noopener ugc nofollow" target="_blank">贷款批准预测</a>数据来说明如何使用Julia机器学习包MLJ进行简单的数据分析生命周期。</p><h1 id="b846" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">浏览数据</h1><p id="d7c1" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">将CSV文件读取到数据帧，指定第一行为标题。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2917" class="kq jf hi km b fi kr ks l kt ku">df = DataFrame(CSV.File(file, header=1))</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kv"><img src="../Images/299557450a339dd334b5f1a2f68182ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RwI03fKFmpyy1KqHC4OCbw.png"/></div></div></figure><p id="c626" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">显示数据摘要，包括最小值/最大值、缺失值数量和数据类型。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4d82" class="kq jf hi km b fi kr ks l kt ku">describe(df)</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es ld"><img src="../Images/e0919be49a4776481029f335dc8bb723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUTwKuLb1sXbmWK6mHX6Tg.png"/></div></div></figure><h1 id="d4fa" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">清理数据</h1><p id="6949" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">由于存在一些缺失值，处理缺失值的两种常用方法是:(1)过滤，和(2)估算。茱莉亚包<a class="ae jd" href="https://invenia.github.io/Impute.jl/latest/" rel="noopener ugc nofollow" target="_blank">估算</a>可以有所帮助。</p><p id="38c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">筛选出缺少值的行。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="4ceb" class="kq jf hi km b fi kr ks l kt ku">Impute.filter(df; dims=:rows)</span></pre><p id="4e95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用统计平均值或模式估算缺失值。默认规则详情可在此<a class="ae jd" href="https://invenia.github.io/Impute.jl/latest/api/imputation/#Impute.defaultstats" rel="noopener ugc nofollow" target="_blank">链接</a>中找到。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="91e4" class="kq jf hi km b fi kr ks l kt ku">Impute.substitute(df)</span></pre><p id="8a3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">缺失值也可以通过先向前滚动再向后滚动来估算。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="9bee" class="kq jf hi km b fi kr ks l kt ku">Impute.locf(df)|&gt; Impute.nocb()</span></pre><h1 id="572d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">可视化数据</h1><p id="7681" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">下面是以透视表格式显示按属性分组的值计数的函数。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="acfe" class="kq jf hi km b fi kr ks l kt ku">function pivotView(df1,x,y)<br/>    return unstack(combine(groupby(df1, [x, y]), nrow =&gt; :count),x,y,:count,allowmissing=true)<br/>end</span></pre><p id="0c5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们检查一下受抚养人的数量在贷款状态中是如何分布的。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="e0ae" class="kq jf hi km b fi kr ks l kt ku">pivotView(df,:Loan_Status, :Dependents)</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div class="er es le"><img src="../Images/b54474f1bd3484a786d1f0410a2e7fdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1220/format:webp/1*bcA2HfdhNfV6vf1p-cLb_Q.png"/></div></figure><p id="9a0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们还可以显示申请人收入、共同申请人收入和贷款金额的直方图分布。它们的形状看起来像对数正态分布。如果我们绘制对数值的直方图，它就变成正常的钟形，如右边所示。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="32e0" class="kq jf hi km b fi kr ks l kt ku">p1 = histogram(df[:,:ApplicantIncome],label=["ApplicantIncome"],legend=:topright,legendfont=font(4))<br/>p1log = histogram(log.(df[:,:ApplicantIncome]),label=["Log(ApplicantIncome)"],legend=:topleft,legendfont=font(4))</span><span id="4275" class="kq jf hi km b fi lf ks l kt ku">p2 = histogram(df[:,:CoapplicantIncome],label=["CoapplicantIncome"],legend=:topright,legendfont=font(4))<br/>p2log = histogram(log.(df[:,:CoapplicantIncome]),label=["Log(CoapplicantIncome)"],legend=:topleft,legendfont=font(4))</span><span id="b124" class="kq jf hi km b fi lf ks l kt ku">p3 = histogram(df[:,:LoanAmount],label=["LoanAmount"],legend=:topright,legendfont=font(4))<br/>p3log = histogram(log.(df[:,:LoanAmount]),label=["Log(LoanAmount)"],legend=:topleft,legendfont=font(4))</span><span id="1143" class="kq jf hi km b fi lf ks l kt ku">plot(p1,p1log, p2,p2log, p3 ,p3log,  layout = (3,2))</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lg"><img src="../Images/e30372d0d3828b40270b667effcb539e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA7RaAd2zjbsC4KaAyWr2A.png"/></div></div></figure><h1 id="77e4" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">特征工程</h1><p id="0cbc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">基于现有特征创建新特征将是有用的。函数“transform”通过对每一行应用指定的函数(“ByRow(fn)”)来创建一个新列。感叹号意味着它将就地更新数据帧。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="f9be" class="kq jf hi km b fi kr ks l kt ku">transform!(df, :Dependents =&gt; ByRow(x -&gt; x == "0" ? "N" : "Y") =&gt; :hasDependents)</span><span id="f136" class="kq jf hi km b fi lf ks l kt ku">transform!(df, :Property_Area =&gt; ByRow(x -&gt; x == "Urban" ? "Y" : "N") =&gt; :isUrban)<br/>    <br/>transform!(df, :Loan_Amount_Term =&gt; ByRow(x -&gt; x &lt; 360 ? "N" : "Y") =&gt; :LongLoan)<br/><br/>transform!(df, [:Loan_Amount_Term,:LoanAmount] =&gt; ByRow(/) =&gt; :payment)</span></pre><p id="0e52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中最重要的特征是净收益比率。下面的函数将计算净收入比率，方法是将申请人收入和共同申请人收入相加，除以估计的家庭成员人数，然后与每个贷款期限的平均贷款额进行比较，以计算它们的比率。比率越高，偿还能力越强。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="865b" class="kq jf hi km b fi kr ks l kt ku">function netIncome(married,dependents,term,income1,income2,amt)<br/>    if married == "Yes"<br/>        n = 2<br/>    else<br/>        n = 1<br/>    end<br/>    if dependents == "3+"<br/>        n = n + 3<br/>    else<br/>        n = n + parse(Int8, dependents)<br/>    end<br/>    ((income1 + income2)/n) / (amt/term)<br/>end</span><span id="2dc1" class="kq jf hi km b fi lf ks l kt ku">transform!(df, [:Married,:Dependents ,:Loan_Amount_Term,:ApplicantIncome,:CoapplicantIncome,:LoanAmount] <br/>        =&gt; ByRow(netIncome) =&gt; :NetIncome)</span></pre><h1 id="9685" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">MLJ的数据类型</h1><p id="52b0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">MLJ使用科学类型(scitype)作为模型输入的数据类型。我们需要将数据帧(dtype)转换成scitype。一般情况下，Float会转换为“连续”。分类值将被转换为OrderedFactor或MultiClass。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="c38a" class="kq jf hi km b fi kr ks l kt ku">function unpackData(df,features)</span><span id="ee1a" class="kq jf hi km b fi lf ks l kt ku">y, X = unpack(df[:,features], ==(:Loan_Status), c-&gt;true;<br/>    :NumFamily  =&gt; Count,<br/>    :Married =&gt; OrderedFactor,<br/>    :hasDependents =&gt; OrderedFactor,<br/>    :Education     =&gt; OrderedFactor,<br/>    :Self_Employed =&gt; OrderedFactor,<br/>    :Property_Area =&gt; Multiclass,<br/>    :LogApplicantIncome =&gt; Continuous,<br/>    :LogCoapplicantIncome =&gt; Continuous,<br/>    :payment =&gt; Continuous,<br/>    :NetIncome =&gt; Continuous,<br/>    :Credit_History =&gt; OrderedFactor,<br/>    :LongLoan =&gt; OrderedFactor,<br/>    :Loan_Status =&gt; OrderedFactor<br/>    )<br/>    return (y,X)<br/>end<br/>y, X = unpackData(df,features)<br/>schema(X)</span></pre><figure class="kh ki kj kk fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es lh"><img src="../Images/9c20c04d9fc29a521512333a0da7bb2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDBQ3B_6UHStcaYcVKQYvg.png"/></div></div></figure><h1 id="f6b2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">分割数据集</h1><p id="b2dc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">将数据集拆分，保留20%作为验证的测试数据。我们只需要拆分和打乱数据集的索引。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="77e3" class="kq jf hi km b fi kr ks l kt ku">train, test = partition(eachindex(y), 0.8, shuffle=true)</span></pre><h1 id="bfb5" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">装载模型</h1><p id="09ad" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">MLJ使用“@load”来加载ML模型的代码。这里有一个XGBoost分类器的例子。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0719" class="kq jf hi km b fi kr ks l kt ku">Pkg.add("MLJXGBoostInterface")<br/>Pkg.add("MLJIteration")<br/>using MLJXGBoostInterface<br/>using MLJIteration<br/>cfr = <a class="ae jd" href="http://twitter.com/load" rel="noopener ugc nofollow" target="_blank">@load</a> XGBoostClassifier pkg=XGBoost</span></pre><h1 id="2f2d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">数据预处理</h1><p id="c599" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">数字特征需要在0，1的范围内进行归一化。分类特征需要被转换成一个热编码器。通常人们会用模型训练建立一个数据预处理的管道。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="5d20" class="kq jf hi km b fi kr ks l kt ku">pipe = <a class="ae jd" href="http://twitter.com/pipeline" rel="noopener ugc nofollow" target="_blank">@pipeline</a>(Standardizer,<br/>                 OneHotEncoder,<br/>                 cfr())</span></pre><h1 id="67e9" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">超参数</h1><p id="be01" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">每个ML模型都有自己的调整参数，选择正确的值很重要。这个过程称为超参数调整。在MLJ，我们可以将TunedModel job定义为通过一系列超参数运行多个模型。下面的代码将在n=2000个模型上循环，范围包括学习速率(eta)和树的max_depth。具有较深树的模型可以拟合更复杂的数据，但是太高会导致过度拟合。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="0d61" class="kq jf hi km b fi kr ks l kt ku">r = [<br/>    range(pipe, :(xg_boost_classifier.eta), lower=0.001, upper=0.03, scale=:log),<br/>    range(pipe, :(xg_boost_classifier.max_depth), lower=2, upper=10)<br/>    ]<br/>pipe.xg_boost_classifier.num_round = 200<br/>pipe.xg_boost_classifier.subsample = 0.8<br/>pipe.xg_boost_classifier.colsample_bytree = 0.8<br/>self_tuning_xgb = TunedModel(model=pipe,<br/>                              resampling=CV(nfolds=3),<br/>                              tuning=RandomSearch(),<br/>                              range=r,<br/>                              measure=[LogLoss()],n=2000);<br/>m = machine(self_tuning_xgb, X, y)<br/>fit!(m, rows=train)<br/>fitted_params(m).best_model</span></pre><p id="a9d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">接下来，我们需要使用对象“machine”将数据绑定到模型管道。然后我们可以运行拟合过程拟合！(m，rows=train)与训练集进行比较。</p><h1 id="8e21" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">培训和评估</h1><p id="2d22" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">除了单次拟合，它还支持交叉验证。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2b55" class="kq jf hi km b fi kr ks l kt ku">evaluate!(m,resampling=CV(nfolds=3),measure=[LogLoss()], verbosity=1)</span></pre><h1 id="2100" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">毫升服务</h1><p id="c894" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">最后一步是对未知数据的预测。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="7977" class="kq jf hi km b fi kr ks l kt ku">yhat = predict(m, X[test,:]);</span></pre><p id="df7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它将在每个目标标签上产生一个概率列表。基于该概率，如果该概率超过预定义的阈值，例如0.5，我们可以给出预测。</p><pre class="kh ki kj kk fd kl km kn ko aw kp bi"><span id="2d96" class="kq jf hi km b fi kr ks l kt ku">function getOutcome(yhat)<br/>    yhat1 = []<br/>    for d in yhat<br/>        if pdf(d,"N") &gt; 0.5<br/>            yhat1 = vcat(yhat1,"N")<br/>        else<br/>            yhat1 = vcat(yhat1,"Y")<br/>        end<br/>    end<br/>    return yhat1<br/>end</span></pre></div></div>    
</body>
</html>