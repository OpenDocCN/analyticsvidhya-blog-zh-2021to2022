<html>
<head>
<title>Deep Learning: Loading and Operationalizing Our Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度学习:加载和操作我们的模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deep-learning-loading-and-operationalizing-our-model-13c4da002225?source=collection_archive---------13-----------------------#2021-04-04">https://medium.com/analytics-vidhya/deep-learning-loading-and-operationalizing-our-model-13c4da002225?source=collection_archive---------13-----------------------#2021-04-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/157020ab5cb10ad2007faa068d14cb48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HvhgF5zduk8HWJmz8YHJKg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated"><em class="it">图片:Shutterstock </em></figcaption></figure><p id="59de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们不能使用它们，建立神经网络/模型有什么必要？在本文中，我们将看看如何操作一个神经网络。</p><blockquote class="js jt ju"><p id="ea76" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr ha bi translated">这是我上一篇关于使用cifar-10创建图像分类器的文章的延续。你可以在这里找到<a class="ae jz" rel="noopener" href="/analytics-vidhya/deep-learning-creating-an-image-classifier-using-pytorch-with-cifar-10-f603659722b2">。</a></p></blockquote><p id="404b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在前一篇文章中，我们训练并保存了我们的模型。在本文中，我们将使用python flask加载模型并进行操作。</p></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><p id="9983" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们需要完成三个主要步骤:</p><ul class=""><li id="0b62" class="kh ki hh iw b ix iy jb jc jf kj jj kk jn kl jr km kn ko kp bi translated">加载我们的模型</li><li id="02c8" class="kh ki hh iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">编写预测函数</li><li id="850a" class="kh ki hh iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated">包装到烧瓶应用程序</li></ul><h1 id="6669" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">加载我们的模型</h1><p id="b496" class="pw-post-body-paragraph iu iv hh iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">在上一篇文章中，我们用名称<em class="jv"> checkpoint.pth </em>保存了我们的模型。为了加载它，我们使用了<a class="ae jz" href="https://pytorch.org/docs/stable/generated/torch.load.html" rel="noopener ugc nofollow" target="_blank"> torch.load </a>函数。然后我们重建我们的模型。</p><p id="b0ab" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，为了重建工作，我们需要我们的Net类，所以我们将把它带过来。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="c9e4" class="mh kw hh md b fi mi mj l mk ml"># let's do our importa here</span><span id="17f2" class="mh kw hh md b fi mm mj l mk ml">import torch<br/>from PIL import Image<br/>import torchvision<br/>import torchvision.transforms as transforms<br/>import numpy as np<br/>import torch.nn as nn<br/>import torch.nn.functional as F</span></pre></div><div class="ab cl ka kb go kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ha hb hc hd he"><pre class="mc md me mf aw mg bi"><span id="484f" class="mh kw hh md b fi mn mo mp mq mr mj l mk ml"># the cifar-10 class labels<br/>classes = ('plane', 'car', 'bird', 'cat', 'deer', 'dog', 'frog', 'horse', 'ship', 'truck')</span><span id="8836" class="mh kw hh md b fi mm mj l mk ml"># our nn<br/>class Net(nn.Module):<br/>    def __init__(self):<br/>        super(Net, self).__init__()<br/>        self.conv1 = nn.Conv2d(3, 32, 3)<br/>        self.conv2 = nn.Conv2d(32, 64, 3)<br/>        self.conv3 = nn.Conv2d(64, 128, 3)<br/>        self.pool = nn.MaxPool2d(2, 2)<br/>        self.fc1 = nn.Linear(128 * 2 * 2, 128)<br/>        self.fc2 = nn.Linear(128, 64)<br/>        self.fc3 = nn.Linear(64, 32)<br/>        self.fc4 = nn.Linear(32, 10)<br/>        self.dropout1 = nn.Dropout(p=0.2, inplace=False)</span><span id="52c7" class="mh kw hh md b fi mm mj l mk ml">    def forward(self, x):<br/>        x = self.pool(F.relu(self.conv1(x)))<br/>        x = self.dropout1(x)<br/>        x = self.pool(F.relu(self.conv2(x)))<br/>        x = self.dropout1(x)<br/>        x = self.pool(F.relu(self.conv3(x)))<br/>        x = self.dropout1(x)<br/>        x = x.view(-1, 128 * 2 * 2)<br/>        x = F.relu(self.fc1(x))<br/>        x = F.relu(self.fc2(x))<br/>        x = F.relu(self.fc3(x))<br/>        x = self.fc4(x) #output layer</span><span id="62f2" class="mh kw hh md b fi mm mj l mk ml">    return x</span></pre><p id="58bb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们检查一下我们的机器是否有GPU，如果没有，我们使用CPU</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="1a13" class="mh kw hh md b fi mi mj l mk ml">device = 'cuda' if torch.cuda.is_available() else 'cpu'</span></pre><p id="e55c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在让我们来看看加载模型的函数</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="4b8d" class="mh kw hh md b fi mi mj l mk ml"># function to load and reconstruct the model<br/>def load_checkpoint(filepath):</span><span id="e902" class="mh kw hh md b fi mm mj l mk ml">    # we do map_location=device so that in case the model was trained with GPU and then we're trying to load it on a machine that has but CPU, it should still work<br/>    checkpoint = torch.load(filepath, map_location=device)<br/>    model = checkpoint['model']<br/>    model.load_state_dict(checkpoint['state_dict'])</span><span id="2295" class="mh kw hh md b fi mm mj l mk ml">    for parameter in model.parameters():<br/>        parameter.requires_grad = False<br/>    <br/>    # put our model to evaluation mode<br/>    model.eval()</span><span id="a79e" class="mh kw hh md b fi mm mj l mk ml">    return model</span></pre><h1 id="443f" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">预测函数</h1><p id="0635" class="pw-post-body-paragraph iu iv hh iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">现在我们有了要加载和重建模型的代码片段，让我们编写一个函数来进行预测。该函数将图像路径作为参数，并返回预测的标签。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="8700" class="mh kw hh md b fi mi mj l mk ml">def do_predcition(filepath):<br/>    pil_image = Image.open(filepath)<br/></span><span id="ead9" class="mh kw hh md b fi mm mj l mk ml">    # transform the image to a tensor and resize to fit our trained model size  <br/>    img_loader = transforms.Compose([<br/>    transforms.Resize((32,32)),<br/>    transforms.ToTensor()])</span><span id="fd73" class="mh kw hh md b fi mm mj l mk ml">    ts_image = img_loader(pil_image).float()<br/>    ts_image.unsqueeze_(0)</span><span id="d541" class="mh kw hh md b fi mm mj l mk ml">    outputs = model(ts_image.to(device))</span><span id="5667" class="mh kw hh md b fi mm mj l mk ml">    _, predicted = torch.max(outputs.data, 1)<br/>    </span><span id="4d49" class="mh kw hh md b fi mm mj l mk ml">    # the prediction is a list, so we have to get the first element    <br/>    return classes[predicted[0]]</span></pre><p id="654c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这一点上，我们有了一切与神经网络有关的东西。我们剩下的是将函数包装到flask应用程序中。</p><h1 id="0bba" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">烧瓶应用程序</h1><p id="80bc" class="pw-post-body-paragraph iu iv hh iw b ix lt iz ja jb lu jd je jf lv jh ji jj lw jl jm jn lx jp jq jr ha bi translated">让我们获取flask应用程序所需的导入。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="c97b" class="mh kw hh md b fi mi mj l mk ml"># imports specific to the flask app<br/>from flask import Flask, render_template, request<br/>from werkzeug.utils import secure_filename<br/>import os</span></pre><p id="494d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基本上，我们有一个简单的文件夹结构:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="7eff" class="mh kw hh md b fi mi mj l mk ml">root<br/>--templates<br/>----index.html<br/>--app.py</span></pre><p id="2baf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="jv">index.html</em>是一个允许用户选择图像的简单表单。如果你想用postman测试模型端点，这部分甚至可以省去。<em class="jv">index.html</em>页面相当简单:</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="f70a" class="mh kw hh md b fi mi mj l mk ml">&lt;--index.html--&gt;<br/>&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;form action = "/uploader" method = "POST" enctype = "multipart/form-data"&gt;<br/>            &lt;input type = "file" name = "file" /&gt;<br/>            &lt;input type = "submit"/&gt;<br/>        &lt;/form&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="98ab" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们来看一下<em class="jv"> app.py </em>代码。我们基本上有两条路线，然后引入预测代码。</p><pre class="ly lz ma mb fd mc md me mf aw mg bi"><span id="56c8" class="mh kw hh md b fi mi mj l mk ml"># bring all imports here</span><span id="b15a" class="mh kw hh md b fi mm mj l mk ml">app = Flask(__name__)</span><span id="00b7" class="mh kw hh md b fi mm mj l mk ml"># bring Net class and the other functions and codes here</span><span id="38d0" class="mh kw hh md b fi mm mj l mk ml">model = load_checkpoint('checkpoint.pth')<br/>model.to(device)</span><span id="fd0f" class="mh kw hh md b fi mm mj l mk ml">@app.route('/')<br/>def upload_file_page():<br/>    return render_template('index.html')</span><span id="83ad" class="mh kw hh md b fi mm mj l mk ml">@app.route('/uploader', methods = ['GET', 'POST'])<br/>def upload_file():<br/>    image_path = ''<br/>    if request.method == 'POST':<br/>        f = request.files['file']<br/>        f.save(secure_filename(f.filename))<br/>        image_path = "./" + secure_filename(f.filename)</span><span id="5a06" class="mh kw hh md b fi mm mj l mk ml">        # call our prediction function<br/>        category = do_predcition(image_path)</span><span id="e3eb" class="mh kw hh md b fi mm mj l mk ml">        # delete the uploaded file<br/>        os.remove(image_path)</span><span id="04b4" class="mh kw hh md b fi mm mj l mk ml">        return category<br/>    # you can hangle the get request here anyhow you'll like</span><span id="2f31" class="mh kw hh md b fi mm mj l mk ml">if __name__ == '__main__':</span><span id="a1f5" class="mh kw hh md b fi mm mj l mk ml"># uncomement this line if you want to run inproduction<br/>#   app.run(host='0.0.0.0', port=80)</span><span id="46ba" class="mh kw hh md b fi mm mj l mk ml">    app.run(debug = True)</span></pre><p id="c335" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，您可以使用python app.py运行应用程序</p><p id="45c8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你在本地运行，那么你可以在<a class="ae jz" href="http://0.0.0.0:80/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:5000/ </a>找到这个应用</p><p id="c931" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你在你的云服务器上运行，你可以通过你的服务器公共ip访问(就像我的例子)，当然是在上面的app.py代码上设置了正确的配置之后。</p><figure class="ly lz ma mb fd ii"><div class="bz dy l di"><div class="ms mt l"/></div></figure><p id="832a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">仅此而已。</p><p id="6faf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的宝贵时间！希望你喜欢它！</p><h1 id="89f4" class="kv kw hh bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">参考</h1><ul class=""><li id="4814" class="kh ki hh iw b ix lt jb lu jf mu jj mv jn mw jr km kn ko kp bi translated"><a class="ae jz" href="https://pytorch.org/docs/stable/generated/torch.load.html" rel="noopener ugc nofollow" target="_blank">火炬装载</a></li><li id="2f79" class="kh ki hh iw b ix kq jb kr jf ks jj kt jn ku jr km kn ko kp bi translated"><a class="ae jz" href="https://flask.palletsprojects.com/en/1.1.x/quickstart/" rel="noopener ugc nofollow" target="_blank">烧瓶文件</a></li></ul></div></div>    
</body>
</html>