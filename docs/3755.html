<html>
<head>
<title>Python memory management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python内存管理</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-memory-management-8854f4952ba0?source=collection_archive---------0-----------------------#2021-07-23">https://medium.com/analytics-vidhya/python-memory-management-8854f4952ba0?source=collection_archive---------0-----------------------#2021-07-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie"><p id="9091" class="if ig hh bd ih ii ij ik il im in io dx translated">编写高效的代码意味着编写节省内存的代码。</p></blockquote><p id="988a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl io ha bi translated">本文描述了python 3.6中的内存管理和垃圾收集。</p><p id="9eec" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">对于任何软件开发人员来说，理解内存分配是如何发生的以及如何管理内存是非常重要的。</p><p id="fedb" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">在这个过程中，我们将经历:</p><ul class=""><li id="c7fa" class="jr js hh ir b is jm iw jn ja jt je ju ji jv io jw jx jy jz bi translated">什么是内存管理？</li><li id="bcdd" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">为什么需要内存管理？</li><li id="4172" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">Python中内存是如何分配的？</li><li id="e34a" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">Python中的垃圾收集</li></ul></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="10b3" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">什么是内存管理？</strong></h1><p id="de1d" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated">简单地说，内存管理就是为程序提供存储数据所需的内存并释放内存中未使用的数据的过程称为内存管理。</p><p id="eb1b" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">提供内存被称为<strong class="ir hi">内存分配</strong>。释放内存被称为<strong class="ir hi">内存释放。</strong></p><p id="eda5" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">在Python中，<strong class="ir hi">内存管理器</strong>负责分配和释放内存。</p></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="386f" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">为什么需要内存管理？</strong></h1><p id="bbbb" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated">通常，编程语言使用对象来操作程序所需的数据。这些对象是在内存中创建的，以便更快地访问。因此，一旦一个对象被创建，它就在内存中被分配了一些空间，一旦你的程序完成了它的执行，这些对象就必须被清理或者从内存中删除，因为它们不再被使用，可以被其他进程/程序再次使用来执行。</p><p id="d65f" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">如果不清理这些未使用的对象，那么您的内存可能已满，没有足够的空间供其他程序使用，您的应用程序可能会崩溃。所以，内存管理在任何编程语言中都是非常重要的。</p><p id="79e9" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">在早期的编程语言(如C)中，分配内存和在执行后释放内存是开发人员的责任，这导致了以下问题:</p><blockquote class="lp lq lr"><p id="ff54" class="ip iq ls ir b is jm iu iv iw jn iy iz lt jo jc jd lu jp jg jh lv jq jk jl io ha bi translated"><strong class="ir hi">忘记释放内存— </strong>如果开发者忘记释放未使用的内存，那么内存可能会变满，导致你的程序使用过多的内存。</p><p id="5553" class="ip iq ls ir b is jm iu iv iw jn iy iz lt jo jc jd lu jp jg jh lv jq jk jl io ha bi translated"><strong class="ir hi">释放已经在使用的内存— </strong>如果开发人员错误地释放了已经在使用的内存，当您的程序试图访问相同的内存时，会导致意外的行为。</p></blockquote><p id="8825" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">所以，这些问题导致新的编程语言实现了自动的<strong class="ir hi">内存管理</strong>和<strong class="ir hi">垃圾收集</strong>，这由Python中的<strong class="ir hi"> Python内存管理器</strong>负责。</p><blockquote class="ie"><p id="e2ac" class="if ig hh bd ih ii lw lx ly lz ma io dx translated">在python中，内存分配和取消分配是自动的。</p></blockquote></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="4eb3" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">Python中内存是如何分配的？</strong></h1><p id="3a43" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated">所以，正如在<strong class="ir hi">中所说，python内存管理器</strong>负责<strong class="ir hi">分配和释放内存。</strong></p><p id="90ef" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">内存有两部分栈内存和堆内存(这与堆数据结构无关)</p><p id="012a" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated"><strong class="ir hi">堆栈内存</strong>—所有的方法/方法调用、引用都存储在堆栈内存中。</p><p id="d761" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated"><strong class="ir hi">堆内存</strong> —所有对象都存储在堆中。</p><blockquote class="ie"><p id="a9ab" class="if ig hh bd ih ii lw lx ly lz ma io dx translated"><strong class="ak">python中的每一样东西都是对象。因此，了解python中的对象非常重要。</strong></p></blockquote><p id="92bd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl io ha bi translated"><strong class="ir hi"> Python是一种动态类型语言</strong>，这意味着不同于其他编程语言(Java和C#)，类型是基于它所引用的值来分配的。</p><p id="6df9" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">例如，在Java/C#等其他编程语言中，如果不指定变量的类型，就无法创建变量。</p><p id="c787" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated"><code class="du mb mc md me b">In C# we create a variable as , public int &lt;variable_name&gt;</code></p><figure class="mf mg mh mi fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx translated">动态类型语言</figcaption></figure><p id="5447" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">在上面的例子中，我创建了一个名为“x”的变量，它最初被赋值为None。(python中的None相当于其他编程语言中的null)。当“x”被赋值为“无”时，“x”的类型为“无”。</p><p id="fc7e" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">当“x”被重新分配为10时，“x”的类型为“int”。</p><p id="9973" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">当“x”再次被重新分配给“10”时，“x”的类型是“str”。</p><p id="ba1f" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">与其他编程语言不同，在python中，每当一个变量被赋值时，python内存管理器将检查内存中是否已经有一个具有该值的对象。如果对象已经存在于内存中，那么这个变量指向那个对象，而不是创建一个具有相同值的新对象。</p><p id="9bcc" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">如果具有该值的对象在内存(堆)中不可用，python内存管理器将创建一个具有指定值的新对象，该变量将指向堆(内存)中新创建的对象。</p><p id="bb7e" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">此外，当一个变量被重新赋值为新变量时，python不会覆盖内存中的值，而是再次遵循上述相同的过程，并检查堆中是否已经存在具有新值的对象。如果对象已经存在，那么这个变量将指向那个对象，否则python内存管理器将在堆上用新值创建一个新对象，这个变量将指向那个值。</p><p id="8e7c" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">举个例子，</p><pre class="mf mg mh mi fd mq me mr ms aw mt bi"><span id="226d" class="mu kn hh me b fi mv mw l mx my"><strong class="me hi">x == 100</strong> // this will create a new object in heap<br/><strong class="me hi">y == 100</strong> // this will not create a new object as an object with           value 100 is already available on heap</span><span id="eaf4" class="mu kn hh me b fi mz mw l mx my"><strong class="me hi">print(id(x) == id(y))</strong> // this returns true because x and y are pointing to same object on heap</span><span id="8d6c" class="mu kn hh me b fi mz mw l mx my"><strong class="me hi">x = 101  </strong>// now when new value is assigned  "101" is not available on heap , so new object is created and x points to this new object . In this case value at that location is not overwritten unlike other programming languages.<br/></span></pre><blockquote class="lp lq lr"><p id="1e82" class="ip iq ls ir b is jm iu iv iw jn iy iz lt jo jc jd lu jp jg jh lv jq jk jl io ha bi translated">这与其他编程语言的情况不同，在其他编程语言中，当变量被更新时，该存储器位置/地址处的值被新的更新值覆盖</p></blockquote><p id="6a4a" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">为了清楚地理解上面讨论的要点，请点击下面的链接，该链接展示了上面讨论的关于python对象内存分配的要点。</p><figure class="mf mg mh mi fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx translated">对象创建</figcaption></figure><blockquote class="ie"><p id="aa80" class="if ig hh bd ih ii ij ik il im in io dx translated">每当在python中创建新对象时，python内存管理器都会确保堆中有足够的内存来为该对象分配空间。</p><p id="641c" class="if ig hh bd ih ii lw lx ly lz ma io dx translated">在python中，所有的对象都是从<strong class="ak"> PyObject一个struct </strong>中派生出来的，这个struct有两个属性:引用计数和指向对象的指针</p></blockquote><p id="8476" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl io ha bi translated">有关<strong class="ir hi">对象</strong>的更多信息，请参考以下文档。</p><div class="na nb ez fb nc nd"><a href="https://docs.python.org/3.6/c-api/structures.html" rel="noopener  ugc nofollow" target="_blank"><div class="ne ab dw"><div class="nf ab ng cl cj nh"><h2 class="bd hi fi z dy ni ea eb nj ed ef hg bi translated">公共对象结构- Python 3.9.6文档</h2><div class="nk l"><h3 class="bd b fi z dy ni ea eb nj ed ef dx translated">Python的对象类型定义中使用了大量的结构。本节…</h3></div><div class="nl l"><p class="bd b fp z dy ni ea eb nj ed ef dx translated">docs.python.org</p></div></div></div></a></div></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="36d5" class="km kn hh bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">Python中的垃圾收集</h1><p id="e9d2" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated">现在，是时候清理不使用的对象了。释放内存或删除未使用的对象以便其他对象可以使用的过程称为<strong class="ir hi">垃圾收集</strong>。</p><p id="85c3" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">因此，垃圾收集器的工作是跟踪可以释放的对象。</p><p id="e550" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">Python使用以下两种算法进行垃圾收集:</p><ul class=""><li id="560c" class="jr js hh ir b is jm iw jn ja jt je ju ji jv io jw jx jy jz bi translated">引用计数</li><li id="f057" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">分代垃圾收集</li></ul><h2 id="5867" class="mu kn hh bd ko nm nn no ks np nq nr kw ja ns nt la je nu nv le ji nw nx li ny bi translated"><strong class="ak">参考计数</strong></h2><p id="484a" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated"><strong class="ir hi">引用计数</strong>是一种简单的技术，每当对象的引用计数达到“0”时，它就有资格进行垃圾收集，并且为该对象分配的内存被自动释放。</p><p id="cecb" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">每当创建一个对象时，该对象的引用计数就增加“1”，类似地，当移除对该对象的引用时，其引用计数就减少“1”。最后，当该对象的引用计数变为“0”时，分配给该对象的内存被释放。</p><p id="e17f" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">python“sys”模块提供了一个名为“getrefcount(object)”的方法，该方法给出了给定对象的引用计数。</p><p id="f8d9" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">浏览下面的代码示例，它演示了在什么情况下对象的引用计数会增加和减少。</p><figure class="mf mg mh mi fd mj"><div class="bz dy l di"><div class="mk ml l"/></div><figcaption class="mm mn et er es mo mp bd b be z dx translated">对象引用计数</figcaption></figure><p id="6efa" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">默认情况下，python使用引用计数技术进行垃圾收集，这是不能禁用的(开发者对此没有控制权)。</p><p id="cde7" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">但这种技术的问题是它有一些开销，因为每个对象都必须跟踪内存取消分配的引用计数，而且每当对象引用计数变为“0”时，就会发生内存取消分配。</p><p id="9628" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">引用计数将无法检测到循环引用，并且这些对象将没有资格进行垃圾收集。</p><p id="5e66" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">由于上述问题，python还使用了另一种叫做<strong class="ir hi">分代垃圾收集的技术。</strong></p><h2 id="4f62" class="mu kn hh bd ko nm nn no ks np nq nr kw ja ns nt la je nu nv le ji nw nx li ny bi translated"><strong class="ak">分代垃圾收集</strong></h2><p id="ea71" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl io ha bi translated">这在python中也是一个自动过程，但与不能禁用的引用计数不同，分代垃圾收集是可选的，也可以手动触发。</p><p id="688c" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated"><strong class="ir hi">python中的gc </strong>模块负责分代垃圾收集。</p><p id="dd45" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">在这种技术中，所有python对象被分为3类:</p><ul class=""><li id="a2e6" class="jr js hh ir b is jm iw jn ja jt je ju ji jv io jw jx jy jz bi translated">第0代</li><li id="e528" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">第一代</li><li id="d9cc" class="jr js hh ir b is ka iw kb ja kc je kd ji ke io jw jx jy jz bi translated">第二代</li></ul><p id="0ac9" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">每一代都有一个预定义的<strong class="ir hi">阈值</strong>，阈值只是垃圾收集器何时调用垃圾收集的指示器。</p><p id="59a0" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">您可以通过导入gc模块来检查默认阈值，如下所示:</p><figure class="mf mg mh mi fd mj er es paragraph-image"><div class="er es nz"><img src="../Images/6f4d4b9617c24bbb71ce726d5fdd332c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*3oq_AiEYP11ToAfu-thqHA.png"/></div></figure><p id="3733" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">您还可以检查每代中的对象数量，如下所示:</p><figure class="mf mg mh mi fd mj er es paragraph-image"><div class="er es oc"><img src="../Images/3a6758cd866d190f6ca07fef02fdd537.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*Q2FkKgeV3_Cg9CVNVsqhuQ.png"/></div></figure><p id="06d8" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">您也可以手动调用垃圾收集，如下所示:</p><figure class="mf mg mh mi fd mj er es paragraph-image"><div class="er es od"><img src="../Images/9dbe0dcc56054ba7b2dbd846a206bf90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*Q__473Y34ZjkQvxYhFliBA.png"/></div></figure><p id="1bd5" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">您也可以按如下方式设置阈值:</p><figure class="mf mg mh mi fd mj er es paragraph-image"><div class="er es oe"><img src="../Images/8b25da43818273e8d461cb5008636690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1322/format:webp/1*yjq-TltcQiPudQllr99aVw.png"/></div></figure><blockquote class="ie"><p id="cea8" class="if ig hh bd ih ii ij ik il im in io dx translated">当创建一个新对象时，该对象被分类为“第0代”。</p></blockquote><p id="935a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl io ha bi translated">当一个代达到其阈值时，垃圾收集被自动触发，并且垃圾收集后该代中剩余的任何对象都被提升到较老的代。</p><p id="71fe" class="pw-post-body-paragraph ip iq hh ir b is jm iu iv iw jn iy iz ja jo jc jd je jp jg jh ji jq jk jl io ha bi translated">如果有2代达到阈值，垃圾收集总是选择老一代，然后是年轻一代。</p></div></div>    
</body>
</html>