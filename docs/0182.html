<html>
<head>
<title>Queue &amp; Deque Overview and Its Implementation in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">队列和出队概述及其在Python中的实现</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/queue-deque-overview-and-its-implementation-in-python-c36c56b532b8?source=collection_archive---------11-----------------------#2021-01-07">https://medium.com/analytics-vidhya/queue-deque-overview-and-its-implementation-in-python-c36c56b532b8?source=collection_archive---------11-----------------------#2021-01-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="c3e5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">队列概述</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es iw"><img src="../Images/a90b1b8def5d0ceb71088825e61c80d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*bfDeil46PnBH6iRacZ-SPA.jpeg"/></div><figcaption class="je jf et er es jg jh bd b be z dx translated">队列数据结构示例<a class="ae ji" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.tutorialspoint.com%2Fdata_structures_algorithms%2Fdsa_queue.htm&amp;psig=AOvVaw0dZHE-BlcExn6lT1tXSIHV&amp;ust=1610087145981000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCIi5yZaYie4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="a355" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">队列是编程中一种有用的数据结构。它类似于电影院大厅外的购票队列，第一个进入队列的人是第一个拿到票的人。</p><p id="8320" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">队列是项目的有序集合，其中新项目的添加发生在一端，称为“<strong class="jl hi">后方“【T3”)，现有项目的移除发生在另一端，通常称为“<strong class="jl hi">前方”。</strong></strong></p><p id="d5c6" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">当一个元素进入队列时，它从后面开始向前面移动，一直等到下一个元素被删除。队列中最近添加的项必须在集合末尾等待。</p><p id="9a55" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在集合中时间最长的项目在最前面。这种排序原则有时被称为<strong class="jl hi"> FIFO，先进先出</strong>。它也被称为“先到先得”。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es kf"><img src="../Images/674c9256a5280ada2700bb9d6074d5e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vs7uVwGUf6BpP77m2X-YCA.png"/></div></div></figure><p id="f26c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">入队术语描述了我们何时将一个新项目添加到队列中。出列术语描述从前面移除项目。</p><h1 id="dae3" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">队列的实现</h1><p id="ec8b" class="pw-post-body-paragraph jj jk hh jl b jm lc ii jo jp ld il jr js le ju jv jw lf jy jz ka lg kc kd ke ha bi translated">我们现在将通过实现我们自己的队列类来建立我们对队列的理解！</p><h1 id="2ee1" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">队列方法和属性</h1><p id="7b39" class="pw-post-body-paragraph jj jk hh jl b jm lc ii jo jp ld il jr js le ju jv jw lf jy jz ka lg kc kd ke ha bi translated">在我们开始实现自己的队列之前，让我们回顾一下它将具有的属性和方法:</p><ul class=""><li id="ece6" class="lh li hh jl b jm jn jp jq js lj jw lk ka ll ke lm ln lo lp bi translated">Queue()创建一个新的空队列。它不需要参数，返回一个空队列。</li><li id="753a" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">enqueue(item)将新项目添加到队列的末尾。它需要该项目，但不返回任何内容。</li><li id="7b3a" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">dequeue()从队列中删除前面的项目。它不需要参数并返回项目。队列被修改。</li><li id="d2f8" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">isEmpty()测试队列是否为空。它不需要参数，返回一个布尔值。</li><li id="2124" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">size()返回队列中的项目数。它不需要参数，返回一个整数。</li></ul><h1 id="81d8" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">队列实现</h1><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="a901" class="ma kl hh lw b fi mb mc l md me">class Queue:<br/>    def __init__(self):<br/>        self.items = []</span><span id="890f" class="ma kl hh lw b fi mf mc l md me">    def isEmpty(self):<br/>        return self.items == []</span><span id="19b4" class="ma kl hh lw b fi mf mc l md me">    def enqueue(self, item):<br/>        self.items.insert(0,item)</span><span id="c6ca" class="ma kl hh lw b fi mf mc l md me">    def dequeue(self):<br/>        return self.items.pop()</span><span id="0c1d" class="ma kl hh lw b fi mf mc l md me">    def size(self):<br/>        return len(self.items)</span><span id="8d33" class="ma kl hh lw b fi mf mc l md me">q = Queue()</span><span id="61d2" class="ma kl hh lw b fi mf mc l md me">q.size()</span><span id="61f1" class="ma kl hh lw b fi mf mc l md me">0</span><span id="ee99" class="ma kl hh lw b fi mf mc l md me">q.isEmpty()</span><span id="2d9d" class="ma kl hh lw b fi mf mc l md me">True</span><span id="0999" class="ma kl hh lw b fi mf mc l md me">q.enqueue(1)</span><span id="d271" class="ma kl hh lw b fi mf mc l md me">q.dequeue()</span><span id="03a3" class="ma kl hh lw b fi mf mc l md me">1</span></pre><h2 id="64a7" class="ma kl hh bd km mg mh mi kq mj mk ml ku js mm mn kw jw mo mp ky ka mq mr la ms bi translated">德克概述</h2><p id="b2c2" class="pw-post-body-paragraph jj jk hh jl b jm lc ii jo jp ld il jr js le ju jv jw lf jy jz ka lg kc kd ke ha bi translated">一个双端队列，也称为双端队列，它是一个类似于队列的有序项目集合。它有两个末端，一个前端和一个后端，这些项目仍然位于集合中。</p><p id="3779" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">使deque与众不同的是添加和删除项目的无限制性。新的物品可以添加在前面或者稀有。同样，可以从任意一端移除现有项目。在某种意义上，这种混合线性结构在一个数据结构中提供了堆栈和队列的所有功能。</p><p id="9a2c" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">重要的是要注意，即使deque可以假定堆栈和队列的许多特征，它也不需要那些数据结构所强制的LIFO和FIFO排序。我们需要始终如一地使用添加和删除操作。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="kg kh di ki bf kj"><div class="er es mt"><img src="../Images/07b8d160c1228d319ec0812853f1b185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPuMCPVbwKnoyNhEIOJOpA.png"/></div></div></figure><h1 id="0ec2" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">Deque的实现</h1><p id="54cd" class="pw-post-body-paragraph jj jk hh jl b jm lc ii jo jp ld il jr js le ju jv jw lf jy jz ka lg kc kd ke ha bi translated">现在我们将实现我们自己的Deque类！</p><h2 id="1548" class="ma kl hh bd km mg mh mi kq mj mk ml ku js mm mn kw jw mo mp ky ka mq mr la ms bi translated">方法和属性</h2><ul class=""><li id="b61b" class="lh li hh jl b jm lc jp ld js mu jw mv ka mw ke lm ln lo lp bi translated">dequee()创建一个新的空dequee。它不需要参数，返回一个空的队列。</li><li id="34c5" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">addFront(item)向队列的前面添加一个新项目。它需要该项目，但不返回任何内容。</li><li id="8807" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">addRear(item)将新项目添加到队列的后面。它需要该项目，但不返回任何内容。</li><li id="1514" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">removeFront()从队列中移除前面的项目。它不需要参数并返回项目。该队列被修改。</li><li id="bf7e" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">removeRear()从队列中移除后面的项目。它不需要参数并返回项目。该队列被修改。</li><li id="90c9" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">isEmpty()测试队列是否为空。它不需要参数，返回一个布尔值。</li><li id="4d55" class="lh li hh jl b jm lq jp lr js ls jw lt ka lu ke lm ln lo lp bi translated">size()返回队列中的项数。它不需要参数，返回一个整数。</li></ul><h1 id="67c0" class="kk kl hh bd km kn ko kp kq kr ks kt ku in kv io kw iq kx ir ky it kz iu la lb bi translated">Deque实现</h1><pre class="ix iy iz ja fd lv lw lx ly aw lz bi"><span id="03d7" class="ma kl hh lw b fi mb mc l md me">class Deque:<br/>    def __init__(self):<br/>        self.items = []</span><span id="35a9" class="ma kl hh lw b fi mf mc l md me">    def isEmpty(self):<br/>        return self.items == []</span><span id="ab21" class="ma kl hh lw b fi mf mc l md me">    def addFront(self, item):<br/>        self.items.append(item)</span><span id="507e" class="ma kl hh lw b fi mf mc l md me">    def addRear(self, item):<br/>        self.items.insert(0,item)</span><span id="ce7b" class="ma kl hh lw b fi mf mc l md me">    def removeFront(self):<br/>        return self.items.pop()</span><span id="8b1e" class="ma kl hh lw b fi mf mc l md me">    def removeRear(self):<br/>        return self.items.pop(0)</span><span id="fa65" class="ma kl hh lw b fi mf mc l md me">    def size(self):<br/>        return len(self.items)</span></pre><p id="729d" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">在下一篇博客中，我们将看到链表及其在python中的实现。</p></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="965b" class="pw-post-body-paragraph jj jk hh jl b jm jn ii jo jp jq il jr js jt ju jv jw jx jy jz ka kb kc kd ke ha bi translated">如果你有任何反馈或批评，请随时与我分享。如果本演练对您有所帮助，请喜欢👏文章。干杯！🍻</p></div></div>    
</body>
</html>