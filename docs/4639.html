<html>
<head>
<title>Music Recommender System — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">音乐推荐系统——第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/music-recommender-system-part-2-ff4c3f54cba3?source=collection_archive---------0-----------------------#2021-12-08">https://medium.com/analytics-vidhya/music-recommender-system-part-2-ff4c3f54cba3?source=collection_archive---------0-----------------------#2021-12-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c104" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">获取音乐数据集并执行探索性数据分析</p><h1 id="46ba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">概述</h1><p id="0912" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在<a class="ae kg" href="https://nsanka.medium.com/music-recommender-system-part-1-86936d673c31?sk=4278ddfebc850599db2fca4a5f2a2104" rel="noopener">上一篇文章</a>中，我们用所有必要的Python库创建了开发环境。</p><p id="a4bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，让我们来看看我们使用的数据集，该数据集是作为<a class="ae kg" href="https://www.aicrowd.com/challenges/spotify-million-playlist-dataset-challenge" rel="noopener ugc nofollow" target="_blank"> Spotify百万播放列表数据集(MPD)挑战</a>的一部分提供的。为了准备在机器学习模型中使用的数据集，我们需要执行一些数据清理和数据操作任务。我们还将研究数据集以了解功能，并结合通过Spotify API获得的其他数据字段。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div class="er es kh"><img src="../Images/dac1cc0aa1c9122db919a95826c051c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*Kx2IRDYfywhdsSHTYlCYAg.png"/></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">Spotify MPD</figcaption></figure><h1 id="f1ef" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">访问Spotify API</h1><p id="cfe3" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在获取和研究播放列表数据集之前，首先我们需要获取Spotify API的客户端凭据。如果您没有Spotify帐户，您需要创建一个免费/付费帐户。获得账户后，前往<a class="ae kg" href="https://developer.spotify.com/" rel="noopener ugc nofollow" target="_blank">面向开发者的Spotify】，点击你的</a><a class="ae kg" href="https://developer.spotify.com/dashboard/applications" rel="noopener ugc nofollow" target="_blank">仪表盘</a>并接受他们的条款。接下来点击“创建一个应用程序”,并给出应用程序的名称和描述。创建应用程序后，概览页面将会打开，您应该会在左侧看到“客户端ID”和“客户端密码”，我们将使用它们来获取其他数据字段。“spot ipy”Python库将用于连接Spotify API，它有两种<a class="ae kg" href="https://spotipy.readthedocs.io/en/2.12.0/" rel="noopener ugc nofollow" target="_blank">授权方法</a>。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es kt"><img src="../Images/a7e302b6c2c103dbda3f529ee0590161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7kNIh6BZGLGlq2wl0fteiQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">Spotify应用程序的客户端ID和密码</figcaption></figure><h1 id="c1e9" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">获取数据集</h1><p id="bd7e" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们将使用Spotify提供的数据集来研究音乐推荐。该数据集包括美国Spotify用户在2010年1月至2017年11月期间创建的公共播放列表。它有100万个Spotify播放列表，超过200万首独特的歌曲，近30万名艺术家，可在这里<a class="ae kg" href="https://www.aicrowd.com/challenges/spotify-million-playlist-dataset-challenge/dataset_files" rel="noopener ugc nofollow" target="_blank">获得</a>。首先，我们需要注册成为会员，以便访问数据集文件。创建帐户并登录后，复制“Spotify _ million _ playlist _ dataset . zip”的链接，然后在第1部分创建的工作区中，在终端中输入以下命令进行下载，替换“dataset_url”。zip文件超过5GB，所以下载需要一些时间。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="136e" class="ld je hi kz b fi le lf l lg lh"># Download zip file<br/>wget "dataset_url" -O spotify_million_playlist_dataset.zip<br/># To see all files list in zip file<br/>unzip -l spotify_million_playlist_dataset.zip<br/># Extract README.md file from zip file<br/>unzip -p spotify_million_playlist_dataset.zip README.md &gt; README.md</span></pre><p id="859a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">由于GitPod实例只有大约30GB的可用磁盘空间，我们将只提取所需的文件夹/文件。从数据集中提取的自述文件，如上面的命令所示，将为您提供有关数据如何存储在文件中以及各个元数据字段的更多详细信息。zip文件在“src”文件夹中也包含一些python文件，其中“stats.py”用于计算数据集的统计数。我们可以从下面的zip文件中提取“src”文件夹，并查看stats.py文件。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="7467" class="ld je hi kz b fi le lf l lg lh"># Extract src folder from zip file<br/>unzip spotify_million_playlist_dataset.zip "src/*" -d .</span></pre><h1 id="d1ba" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">快速接近</h1><p id="c598" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">数据集zip文件在数据文件夹中有1000个json文件，每个json文件有1000个播放列表。每个播放列表都有许多曲目。我们可以遵循stats.py文件中给出的类似方法，遍历每个文件，然后遍历每个播放列表来获取信息。我们想快速进入建模部分，所以我们决定使用部分数据。我们提取了20个json文件，从每个文件中读取信息，并添加到如下所示的列表中。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="5560" class="ld je hi kz b fi le lf l lg lh">import os<br/>import json</span><span id="f8c4" class="ld je hi kz b fi li lf l lg lh">def loop_slices(path, num_slices=20):<br/>  cnt = 0<br/>  mpd_playlists = []<br/>  filenames = os.listdir(path)<br/>  for fname in sorted(filenames):<br/>    print(fname)<br/>    if fname.startswith("mpd.slice.") and fname.endswith(".json"):<br/>      cnt += 1<br/>      fullpath = os.sep.join((path, fname))<br/>      f = open(fullpath)<br/>      js = f.read()<br/>      f.close()<br/>      current_slice = json.loads(js)</span><span id="fbcb" class="ld je hi kz b fi li lf l lg lh">      # Create a list of all playlists<br/>      for playlist in current_slice['playlists']:<br/>        mpd_playlists.append(playlist)</span><span id="912e" class="ld je hi kz b fi li lf l lg lh">      if cnt == num_slices:<br/>        break</span><span id="a98b" class="ld je hi kz b fi li lf l lg lh">  return mpd_playlists</span><span id="d9c7" class="ld je hi kz b fi li lf l lg lh"># Path where the json files are extracted<br/>path = 'data/'<br/>playlists = loop_slices(path, num_slices=20)</span></pre><p id="f96d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是提取播放列表中每个音轨的音频特征。我们使用spotipy库从Spotify中提取所需的音频功能。最后，出于建模目的，我们取了每个播放列表中所有曲目的音频特征的平均值。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="5289" class="ld je hi kz b fi le lf l lg lh">import spotipy<br/>from spotipy.oauth2 import SpotifyClientCredentials</span><span id="cf37" class="ld je hi kz b fi li lf l lg lh"># Spotify credentials<br/>os.environ["SPOTIPY_CLIENT_ID"] = "Replace with Client ID"<br/>os.environ["SPOTIPY_CLIENT_SECRET"] = "Replace with Client Secret"<br/>os.environ['SPOTIPY_REDIRECT_URI'] = "http://localhost:8080"</span><span id="9fb1" class="ld je hi kz b fi li lf l lg lh">sp = spotipy.Spotify(client_credentials_manager =      <br/>                     SpotifyClientCredentials())</span><span id="37da" class="ld je hi kz b fi li lf l lg lh">cols_to_keep = ['danceability', 'energy', 'key', 'loudness', 'mode', 'speechiness', 'acousticness', 'instrumentalness', 'liveness', 'valence', 'tempo', 'duration_ms', 'time_signature']</span><span id="98a3" class="ld je hi kz b fi li lf l lg lh">dfs = []<br/>for playlist in tqdm(playlists):<br/>  audio_feats = []<br/>  for track in playlist['tracks']:<br/>    track_uri = track['track_uri'].split(":")[2]<br/>    feature = sp.audio_features('track_uri')<br/>    if feature:<br/>      audio_feats.append(feature[0])</span><span id="6e12" class="ld je hi kz b fi li lf l lg lh">  avg_feats = pd.DataFrame(audio_feats)[cols_to_keep].mean()<br/>  avg_feats['name'] = playlist['name']<br/>  avg_feats['pid'] = playlist['pid']<br/>  dfs.append(avg_feats.T)</span></pre><p id="6960" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在提取了20，000个播放列表的所有平均音频特征后，我们开始建立和训练机器学习模型。</p><h1 id="2b9f" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">处理一百万个播放列表</h1><p id="3b9d" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我们使用20，000个播放列表和其他文章中描述的聚类模型获得了不错的推荐。但是，当我们用不同的用户播放列表进行测试时，它对一些用户来说是失败的。因此，我们希望使用完整的数据集来重新训练模型。为此，我们需要获得所有播放列表的平均音频特征。上面提到的快速方法不起作用，或者花了太多时间来读取和提取特征。所以，我们更新了数据处理代码。在更新代码时，我们发现我们不需要提取每个曲目的特征，因为一些曲目在播放列表中重复。下图显示了前几个json文件的新的、现有的和总的磁道变化。尽管每个json文件都有超过60K的磁道，但只有30K-35K的唯一磁道，并且在最初的几个json文件之后，只有不到5K的新磁道。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="er es lj"><img src="../Images/28eee1ab869bcfdaf700c62d4fab0316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-ROUZP_srFKsrwZpPMrLA.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">更改每个json文件的轨道</figcaption></figure><p id="3395" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">几乎没有对数据处理代码进行流程改进。第一个是，我们没有提取所有的json文件，而是使用Python的“zipfile”库直接从zip文件中读取。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="326b" class="ld je hi kz b fi le lf l lg lh">import os<br/>import json<br/>from zipfile import ZipFile<br/>import fnmatch</span><span id="f034" class="ld je hi kz b fi li lf l lg lh">def extract_mpd_dataset(zip_file, num_files=0, num_playlists=0):<br/>  with ZipFile(zip_file) as zipfiles:<br/>    file_list = zipfiles.namelist()<br/>    #get only the csv files<br/>    json_files = fnmatch.filter(file_list, "*.json")<br/>    json_files = [f for i,f in sorted([(int(filename.split('.')[2].split('-')[0]), filename) for filename in json_files])]</span><span id="39e2" class="ld je hi kz b fi li lf l lg lh">    cnt = 0<br/>    for filename in json_files:<br/>      cnt += 1<br/>      print('\nFile: ' + filename)<br/>      with zipfiles.open(filename) as json_file:<br/>        json_data = json.loads(json_file.read())<br/>        process_json_data(json_data, num_playlists)</span><span id="8458" class="ld je hi kz b fi li lf l lg lh">      if (cnt == num_files) and (num_files &gt; 0):<br/>        break</span><span id="84e3" class="ld je hi kz b fi li lf l lg lh">zip_file = 'data/spotify_million_playlist_dataset.zip'<br/>extract_mpd_dataset(zip_file, 0, 0)</span></pre><p id="2a58" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二个改进是读取整个文件，而不是一次读取每个播放列表。我们使用Pandas的“json_normalize”函数将json文件转换成数据帧。这有助于我们非常轻松地处理播放列表和曲目。示例代码如下，你可以在GitHub中看到<a class="ae kg" href="https://github.com/nsanka/RecSys" rel="noopener ugc nofollow" target="_blank">完整代码</a>。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="b21a" class="ld je hi kz b fi le lf l lg lh">import pandas as pd<br/>def process_json_data(json_data, num_playlists):<br/>  # Get all playlists in the file<br/>  playlists_df = pd.json_normalize(json_data['playlists'])</span><span id="8c36" class="ld je hi kz b fi li lf l lg lh">  # Get all the tracks in the file<br/>  tracks_df = pd.json_normalize(json_data['playlists'], record_path=['tracks'], meta=['pid', 'num_followers'])</span></pre><p id="0aaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用Pandas内置的SQLite功能来读取数据帧并保存到表中。创建了四个表，分别是播放列表、曲目、功能和评级。播放列表、表格和特征具有独特的项目，并且收视率表格具有播放列表和曲目之间的链接。为了创建唯一曲目表，我们不仅从该文件中删除了重复曲目，还删除了数据库中存在的曲目。下面是保存数据库中的表的示例代码。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="52df" class="ld je hi kz b fi le lf l lg lh">import sqlite3<br/>db_file = 'data/spotify_million_playlists.db'<br/>conn = sqlite3.connect(db_file)<br/># Create playlists table<br/>playlists_df.to_sql(name='playlists', con=conn, if_exists='append', index=False)</span><span id="d71c" class="ld je hi kz b fi li lf l lg lh"># Added unique track_id for each non-duplicate tracks<br/># Create ratings table in database<br/>ratings_df = tracks_df[['pid', 'track_id', 'pos', 'num_followers']]</span><span id="8354" class="ld je hi kz b fi li lf l lg lh"># Remove all duplicate tracks, Create tracks table<br/>tracks_df.drop(['pos', 'duration_ms', 'pid', 'num_followers'], axis=1, inplace=True)<br/>tracks_df = tracks_df.drop_duplicates(subset='track_uri', keep="first")<br/>tracks_df.to_sql(name='tracks', con=conn, if_exists='append', index=False)</span></pre><p id="7fe8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们执行的最后一个修改是一次获得多个音轨的音频特征。spotipy库一次可以获得100个音轨的音频特征。因此，我们更新了代码，从tracks表中获取所有的“track_uri ”,并一次处理100首曲目。下面是示例代码。</p><pre class="ki kj kk kl fd ky kz la lb aw lc bi"><span id="e7cd" class="ld je hi kz b fi le lf l lg lh">cur = conn.cursor()<br/>cur.execute('''select track_id, track_uri from tracks where (track_id &gt; ?) and (track_id &lt;= ?)''', (0, 100))<br/>rows = cur.fetchall()<br/>uris = [row[1] for row in rows]</span><span id="558a" class="ld je hi kz b fi li lf l lg lh">feats_list = sp.audio_features(uris)<br/># Remove None items, for some tracks there are no features<br/>feats_list = [item for item in feats_list if item]</span><span id="656c" class="ld je hi kz b fi li lf l lg lh">feats_df = pd.DataFrame(feats_list)<br/>columns = ['danceability','energy','key','loudness','mode','speechiness','acousticness','instrumentalness','liveness','valence','tempo','duration_ms','time_signature']<br/>feats_df = feats_df[columns]<br/>track_id_list = range(1, 101)<br/>feats_df.insert(loc=0, column='track_id', value=track_id_list)</span><span id="0b59" class="ld je hi kz b fi li lf l lg lh">feats_df.to_sql(name='features', con=conn, if_exists='append', index=False)</span></pre><p id="c9ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从Spotify读取一百万个播放列表并获得每首独特歌曲的音频特征的完整过程需要超过2个小时的系统时间。因此，我们添加了代码，将日志保存在一个文本文件中，以便于跟踪，您可以在我的GitHub中看到完整的<a class="ae kg" href="https://github.com/nsanka/RecSys/blob/main/data/read_spotify_mpd_complete_log.txt" rel="noopener ugc nofollow" target="_blank">日志文件</a>。</p><h1 id="341c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">下一步</h1><p id="3228" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">在<a class="ae kg" rel="noopener" href="/@david.de.hernandez/modeling-data-for-a-spotify-recommender-system-3056997a0fc5?sk=7ce613a3d5cbd4a69e73804983d49f91">的下一篇文章</a>中，我们将看到使用我们在此收集的数据来构建和训练机器学习模型。</p><h1 id="a096" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考资料:</h1><ul class=""><li id="3eeb" class="lk ll hi ih b ii kb im kc iq lm iu ln iy lo jc lp lq lr ls bi translated"><a class="ae kg" href="https://dl.acm.org/doi/abs/10.1145/3240323.3240342" rel="noopener ugc nofollow" target="_blank"> <em class="lt">陈、拉梅、沙德尔、扎马尼。Recsys挑战赛2018:自动音乐播放列表延续。《第12届ACM推荐系统会议论文集》(RecSys '18)，2018 </em> </a></li><li id="d41e" class="lk ll hi ih b ii lu im lv iq lw iu lx iy ly jc lp lq lr ls bi translated"><a class="ae kg" href="https://towardsdatascience.com/all-pandas-json-normalize-you-should-know-for-flattening-json-13eae1dfb7dd" rel="noopener" target="_blank">用熊猫拉平JSON】</a></li><li id="b0a4" class="lk ll hi ih b ii lu im lv iq lw iu lx iy ly jc lp lq lr ls bi translated"><a class="ae kg" href="https://towardsdatascience.com/python-pandas-and-sqlite-a0e2c052456f" rel="noopener" target="_blank"> Python熊猫和SQLite </a></li></ul></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><p id="8075" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢看我的文章，并想支持我，请考虑注册成为一个媒体成员。每月5美元，你可以无限制地阅读媒体上的故事。请注册使用我的链接来支持我:<a class="ae kg" href="https://nsanka.medium.com/membership." rel="noopener">https://nsanka.medium.com/membership.</a></p></div></div>    
</body>
</html>