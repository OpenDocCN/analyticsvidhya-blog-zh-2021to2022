<html>
<head>
<title>Dockerizing Django with Numpy and Gunicorn</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Numpy和Gunicorn将Django归档</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/dockerizing-django-with-numpy-and-gunicorn-1b969cdb5f78?source=collection_archive---------11-----------------------#2021-01-20">https://medium.com/analytics-vidhya/dockerizing-django-with-numpy-and-gunicorn-1b969cdb5f78?source=collection_archive---------11-----------------------#2021-01-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8ae68bf08b286540c87729636fd75bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vOPxF4adc7HzbbhJmf676Q.jpeg"/></div></div></figure><p id="9eab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">大家好。</p><p id="64f3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">事实上，网上有很多关于django的教程。但是在我工作的项目中，我们使用像Numpy和Pillow这样的库，alpine linux不能编译这个，因为缺少依赖关系。</p><p id="2c90" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的堆栈:</p><ul class=""><li id="c347" class="jn jo hh ir b is it iw ix ja jp je jq ji jr jm js jt ju jv bi translated">姜戈</li><li id="c335" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Numpy</li><li id="faa5" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">枕头</li><li id="c877" class="jn jo hh ir b is jw iw jx ja jy je jz ji ka jm js jt ju jv bi translated">Postgres</li></ul><p id="a0f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先让我们创建基本的<code class="du kb kc kd ke b">Dockerfile</code></p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="fd17" class="kn ko hh ke b fi kp kq l kr ks">FROM python:3.6.4-alpine</span><span id="0a06" class="kn ko hh ke b fi kt kq l kr ks">ADD . /app</span><span id="311c" class="kn ko hh ke b fi kt kq l kr ks">WORKDIR /app</span><span id="46f2" class="kn ko hh ke b fi kt kq l kr ks">RUN pip install -r requirements.txt</span><span id="2580" class="kn ko hh ke b fi kt kq l kr ks">EXPOSE 8000</span><span id="9af8" class="kn ko hh ke b fi kt kq l kr ks">CMD ["manage.py", "runserver"]</span></pre><p id="00db" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你不使用像<code class="du kb kc kd ke b">Numpy</code>这样的c编译库，它基本上可以工作。</p><p id="b893" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">问题是，我们需要在alpine中添加编译器，我有一个很大的层，因为我认为在一个层上运行这个进程更好。</p><p id="0391" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">完全依赖安装层:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="2531" class="kn ko hh ke b fi kp kq l kr ks">RUN apk add --no-cache jpeg tiff-dev openjpeg-dev postgresql-dev &amp;&amp; \<br/>    apk add --no-cache \<br/>    --virtual=.build-deps \<br/>    g++ zlib-dev freetype-dev lcms2-dev \<br/>    gcc libc-dev linux-headers tk-dev tcl-dev harfbuzz-dev \<br/>    fribidi-dev build-base py-pip rsyslog cython file binutils \<br/>    musl-dev python3-dev cython &amp;&amp; \<br/>    ln -s locale.h /usr/include/xlocale.h &amp;&amp; \<br/>    pip install --upgrade pip &amp;&amp; \<br/>    pip install -r requirements.txt --no-cache-dir &amp;&amp; \<br/>    rm -r /root/.cache &amp;&amp; \<br/>    find /usr/lib/python3.*/ -name 'tests' -exec rm -r '{}' + &amp;&amp; \<br/>    find /usr/lib/python3.*/site-packages/ -name '*.so' -print -exec sh -c 'file "{}" | grep -q "not stripped" &amp;&amp; strip -s "{}"' \; &amp;&amp; \<br/>    rm /usr/include/xlocale.h &amp;&amp; \<br/>    apk --purge del .build-deps</span></pre><h1 id="0acc" class="ku ko hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Alpine编译器</h1><p id="88ce" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">我安装了一些像<code class="du kb kc kd ke b">g++</code>和<code class="du kb kc kd ke b">linux-headers</code>虚拟的包，并在pip安装后清理了它们，因为我只需要这些包来发布一些依赖关系的脚本，而大小是容器的问题。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="bc6d" class="kn ko hh ke b fi kp kq l kr ks">-t, --virtual NAME    Instead of adding all the packages to 'world', create a new <br/>                        virtual package with the listed dependencies and add that <br/>                        to 'world'; the actions of the command are easily reverted <br/>                        by deleting the virtual package</span></pre><p id="cd9a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这意味着当您安装软件包时，这些软件包不会添加到全局软件包中。并且这种改变可以容易地恢复。所以如果我需要gcc来编译一个程序，但是一旦程序被编译了，我就不再需要gcc了。</p><p id="b5e9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我可以在一个虚拟包中安装gcc和其他所需的包，并且所有的依赖项和所有东西都可以从这个虚拟包名称中删除。下面是一个用法示例</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="c4f8" class="kn ko hh ke b fi kp kq l kr ks">apk add --virtual mypacks gcc vim<br/>apk del mypacks</span></pre><p id="1904" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下一个命令将删除用第一个命令安装的所有18个软件包。</p><h1 id="4674" class="ku ko hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Postgres</h1><p id="f8c9" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">我在我的本地机器上运行Postgresql，而不是docker。我需要把它连接起来。你可以使用<code class="du kb kc kd ke b">host.docker.internal</code>这个映射直接路由你的机器<code class="du kb kc kd ke b">localhost</code></p><p id="7677" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我添加了这个env变量</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="a804" class="kn ko hh ke b fi kp kq l kr ks">ENV DB_HOST=host.docker.internal</span></pre><p id="2bf1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">并在“settings.py”上使用了它</p><p id="fbbd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi">— -</p><h1 id="5184" class="ku ko hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">格尼科恩</h1><p id="6d0b" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">我决定用Gunicorn来运行用<code class="du kb kc kd ke b">n</code>工人处理的程序。因此，我将<code class="du kb kc kd ke b">gunicorn</code>添加到requirements.txt中，并添加了两行用于运行流程</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="00b3" class="kn ko hh ke b fi kp kq l kr ks">ENV WORKER_COUNT=2</span><span id="7604" class="kn ko hh ke b fi kt kq l kr ks">CMD ["sh", "-c", "gunicorn --bind :8000 --workers ${WORKER_COUNT} project.wsgi:application"]</span></pre><p id="27d1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用<code class="du kb kc kd ke b">WORKER_COUNT</code>环境变量作为默认值。每当我需要的时候，我都会覆盖这个值。</p><h1 id="25ef" class="ku ko hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">运转</h1><p id="a7a5" class="pw-post-body-paragraph ip iq hh ir b is lr iu iv iw ls iy iz ja lt jc jd je lu jg jh ji lv jk jl jm ha bi translated">我决定用<code class="du kb kc kd ke b">n</code> workers创建makefile来运行这个容器。所以我用这个命令创建了Makefile。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="2484" class="kn ko hh ke b fi kp kq l kr ks">docker-run:<br/> docker run -e worker_count=${worker} -p 127.0.0.1:8000:8000 project${version}</span></pre><h1 id="3e9d" class="ku ko hh bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">完整的文档</h1><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="a009" class="kn ko hh ke b fi kp kq l kr ks">FROM python:3.6.4-alpine</span><span id="2b09" class="kn ko hh ke b fi kt kq l kr ks">ADD . /app<br/>WORKDIR /app</span><span id="6bc5" class="kn ko hh ke b fi kt kq l kr ks"># Need to Update at Settings.py<br/>ENV DB_HOST=host.docker.internal</span><span id="e905" class="kn ko hh ke b fi kt kq l kr ks"># Default Worker Count is 2<br/>ENV WORKER_COUNT=2</span><span id="7805" class="kn ko hh ke b fi kt kq l kr ks"># Install dependencies layer.<br/>RUN apk add --no-cache postgresql \<br/>                        jpeg tiff-dev openjpeg-dev \<br/>                        libpq postgresql-libs postgresql-dev &amp;&amp; \<br/>    apk add --no-cache \<br/>    --virtual=.build-deps \<br/>    g++ jpeg-dev zlib-dev freetype-dev lcms2-dev \<br/>    gcc libc-dev linux-headers tk-dev tcl-dev harfbuzz-dev \<br/>    fribidi-dev zlib-dev build-base py-pip rsyslog cython file binutils \<br/>    musl-dev python3-dev cython &amp;&amp; \<br/>    ln -s locale.h /usr/include/xlocale.h &amp;&amp; \<br/>    pip install --upgrade pip &amp;&amp; \<br/>    pip install -r requirements.txt --no-cache-dir &amp;&amp; \ <br/>    rm -r /root/.cache &amp;&amp; \<br/>    find /usr/lib/python3.*/ -name 'tests' -exec rm -r '{}' + &amp;&amp; \<br/>    find /usr/lib/python3.*/site-packages/ -name '*.so' -print -exec sh -c 'file "{}" | grep -q "not stripped" &amp;&amp; strip -s "{}"' \; &amp;&amp; \<br/>    rm /usr/include/xlocale.h &amp;&amp; \<br/>    apk --purge del .build-deps</span><span id="0f92" class="kn ko hh ke b fi kt kq l kr ks">EXPOSE 8000</span><span id="1486" class="kn ko hh ke b fi kt kq l kr ks">CMD ["sh", "-c", "gunicorn --bind :8000 --workers ${WORKER_COUNT} project.wsgi:application"]</span></pre><p id="0195" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这篇文章对你有用。</p><p id="8306" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">谢了。</p></div></div>    
</body>
</html>