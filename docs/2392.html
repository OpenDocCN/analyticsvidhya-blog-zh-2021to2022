<html>
<head>
<title>How to properly handle concurrency and parallelism with Golang</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Golang正确处理并发和并行</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-properly-handle-concurrency-and-parallelism-with-golang-89dd054b739f?source=collection_archive---------4-----------------------#2021-04-21">https://medium.com/analytics-vidhya/how-to-properly-handle-concurrency-and-parallelism-with-golang-89dd054b739f?source=collection_archive---------4-----------------------#2021-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="07cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用线程编程总是很棒的，你可以更快地得到结果，同时处理更多的事情，并尽可能让服务器保持忙碌，不幸的是，这产生了几个问题，当你不习惯使用线程时，这些问题并不那么明显。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/9af79156add474e963d9dc68b872e2d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*IOv7Bz00Ln-iDAH5KkO9kg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">古老而珍贵</figcaption></figure><p id="2664" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇短文中，我将向你介绍我认为最常见的问题，以及我通常是如何解决这些问题的。</p><p id="704e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在整个教程中，我们将使用相同的基本练习，运行从0到15的数字，并将它们打印在屏幕上，在每一步之后，我们将逐渐增加新的功能，但计数到某个极限的主要机制将持续存在，该代码可能不是您见过的最好的Go代码或最惯用的代码，但它的编写方式使我们试图解决的问题变得非常明显。</p><p id="194c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将从例1开始。开始:</p><pre class="jd je jf jg fd jo jp jq jr aw js bi"><span id="b931" class="jt ju hh jp b fi jv jw l jx jy">package main<br/><br/>import (<br/>   "log"<br/>   "time"<br/>)<br/><br/>func main() {<br/>   start := time.Now()<br/>   var counter = 0<br/>   for i := 1; i &lt;= 16; i++ {<br/>      log.Println("Start", counter)<br/>      counter++<br/>   }<br/>   elapsed := time.Since(start)<br/>   log.Println(elapsed)<br/>}</span></pre><p id="6f7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这只是按顺序排列的数字:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es jz"><img src="../Images/48d9de3c75947c295bd9655298bbbe4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5fPtvosHxMuLnfcDAI_yg.png"/></div></div></figure><p id="f6d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这表示你写的任何程序都是按顺序工作的，它执行任务0，一旦完成就执行任务1，依此类推。</p><p id="65e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将介绍我们的第一个线程机制，这是一个“go例程”，它将在不同的线程中运行任何代码(这不是真正的线程，但现在让我们假设它们是同一件事)，我们通过在函数前使用go关键字来启动go例程，它可以是匿名函数或命名函数，在这里我只做一个匿名函数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ke"><img src="../Images/22cc7952a912b0941722ccfca065de28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*89dwzBWR6PvKNSaNbW9mEQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">ex_2 .去吧</figcaption></figure><p id="200c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经将计数/打印语句发送到一个新线程，其行为与第一次运行时略有不同:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kf"><img src="../Images/47df69b789d52550db2c8e60601a656f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*EAUm7BsYJnmS7SFrg2n1Hw.png"/></div></figure><p id="3be4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它确实跑得更快了…但是它没有打印出任何数字！</p><p id="c414" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们启动一个新线程时，主线程继续运行，忽略了新线程上发生的事情，然后到达主线程的末尾(第18行)并停止执行，因为没有任何信息告诉它另一个线程正在运行，它就关闭了。</p><p id="f0ea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们现在将做一个小小的调整，天真地等待所有线程完成:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kg"><img src="../Images/e1b2d7d2dfc6638543e78c53d67aa2dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*PmfsDO6QFhSYfrVTmyt_iA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">ex_3 .去吧</figcaption></figure><p id="deaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次我们在主线程中添加了睡眠，我们希望所有的goroutines都在这2秒内完成:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kh"><img src="../Images/1a87ee86c5afa00ffd1b26540a366400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*QSlXM01Zwok2fg7FiWERnQ.png"/></div></figure><p id="4ae7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好了，我们现在变得更好了，我们有16行，但它们都显示0，如果我们查看日志时间，它们都运行在第二:47，没有显示在:48，然后它在:49完成执行，所以我们等待线程完成的天真等待产生了两个新问题:</p><ul class=""><li id="88ba" class="ki kj hh ig b ih ii il im ip kk it kl ix km jb kn ko kp kq bi translated">计数器值没有正确更新</li><li id="2921" class="ki kj hh ig b ih kr il ks ip kt it ku ix kv jb kn ko kp kq bi translated">我们空闲了一段时间</li></ul><p id="045e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我多次运行相同的代码，会出现一个有趣的现象:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kf"><img src="../Images/6d459a6fe8b8d4b90726131c838010c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*dHXHvFgMERfCTmzZ08t4rw.png"/></div></figure><p id="9bf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中一个任务是报告11(您可能会得到另一个不同的数字)，这是因为我们有一个数据竞争条件，所有线程几乎同时启动，并且它们都共享计数器变量，因此它们都以0值开始，递增1，然后打印出来，对于其中一些线程，当它们启动时值是0，但当它们递增时，它是不同的，这就是这里导致11的原因。</p><p id="d1bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我们将做一件非常基本但不太精确的事情(我们将在以后用更好的方法解决这个问题):</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kw"><img src="../Images/ea1e9cf49d8d925eea0b194e0277a195.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*5LoALOkxZbnBRC_4_roOZA.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">ex_4.go</figcaption></figure><p id="0327" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们将在迭代中进行计数，而不是在线程中，我们让线程打印值，因为做增量比旋转新线程更快，我们还将复制counter的值，并将其作为参数发送给goroutine，该副本将被读取为“thisCounter”:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kx"><img src="../Images/b6116908a4b054b2304e36e5c0b1a1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*pnwj-qVRwNc1HsSNCD7Nsw.png"/></div></figure><p id="6d81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，数据竞争的情况似乎已经得到了解决，至少在这个简单的例子中，counter++比创建新线程更快，我们现在认为这是一个胜利，以后会适当地解决它，但是让我们转到线程化时产生的另一个问题:等待任务完成。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ky"><img src="../Images/9929d5d839a30df0e3e15c1fa9aa3cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*sFKUzHjJz5uMGTF-w07Oxg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">去吧</figcaption></figure><p id="644c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次我们将为我们的程序引入另一个组件:WaitGroup，这是一种同步所有线程的机制。</p><p id="63f8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们在第12行声明了我们的waitgroup，然后在每次迭代中，我们会在第15行告知我们正在向我们的waitgroup添加一个新线程，delta参数会告诉waitgroup最后要等待多少个任务，在这里，我会在每次循环迭代中将wait group的大小增加1，但我们也可以在循环之外这样做，比如说16， 在循环内部这样做将使我们的代码在处理下一级waitgroups时更具可移植性，所以我们现在将delta=1，在goroutine内部，您会注意到一个“wg”。 Done()"调用，这样做的目的是将waitgroup最后需要同步的任务量减一，所以wg。添加会增加it和wg。完成减少它，然后在第22行，我们有一个工作组。Wait，它只是等待waitgroup内部的一个内部计数器达到0，直到它达到0，它将永远阻止执行，如果你从来没有调用足够的wg。Done()，那么我们将永远闲置，或者直到外部因素中断执行。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es kz"><img src="../Images/d98c89ab2ec0f32c85fedf282b22c7c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*AoyAkojPVM46V_mF31fh4Q.png"/></div></figure><p id="6e03" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次，程序在所有任务完成后立即结束:)</p><p id="9722" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们还有另一个不明显的问题，因为这是一个小例子，但是，如果我们有数千个任务要运行，并且它们都做了一些繁重的处理，我们将同时启动一千个goroutines，这取决于可用的资源，我们可能会使系统崩溃，因为所有的东西都在同时工作，为此，我们有一个小机制来控制有多少工作同时排队:SizedWaitGroup。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es la"><img src="../Images/32e5bb6416be993abb243ec516ec551c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*lr0e2VktD1gbYTGGpCn0Bg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">去吧</figcaption></figure><p id="0db2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将使用remeh的sizedwaitgroups包，您会注意到语法与常规waitgroup非常相似:</p><p id="202d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次，在创建sizedwaitgroup时，我们需要指定一个限制，即在生成新线程之前并行运行的最大任务量，这将给我们带来并行化的好处，而没有破坏服务器的风险。向我们的sizedwaitgroups计数器添加()一个任务，在这个实现中，我们不需要指定我们要添加多少任务，它被强制以1为增量，这是因为如果sizedwaitgroup已满(在我们的示例中为6)，函数将阻塞主线程，因此循环的前6次迭代将正常进行，然后在第7次迭代时，因为sizedwaitgroup已满(并且还没有任务报告. Done())， 它将等待，直到组中有一个可用的槽，一旦有，线程将启动，循环将继续，直到它完成所有的工作，或者由于我们的等待池已满而再次被阻塞。 Done()函数的行为方式与waitgroup中的以及。Wait()函数。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lb"><img src="../Images/23b1db1ace2691f89470743850cbb161.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsPKFu8KiXKDBu6tmmMfBA.png"/></div></div></figure><p id="bbbf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次，我们看到任务是以6个块为单位工作的，因为我们在完成一个线程之前的延迟是2秒，这就是释放一个槽所需要的时间。</p></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="5a5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">既然我们已经有了几种运行任务的机制，那么让我们把注意力集中在我们已经推迟了一段时间的问题上:数据竞争条件。</p><p id="7085" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将从编写程序的一个小变体开始，但是这个变体使问题变得非常明显:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lj"><img src="../Images/cbd7908dcc8287f6f03045b5ebf7fe00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*fXxRgkNxcnBW3qrgHxEZTg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">ex_7 .走</figcaption></figure><p id="c653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一个有我们已经谈论了一段时间的大部分组件，但问题在于我们正在写入计数器变量的事实，到我们必须写入它的时候，可能已经发生了更多的变化(通过时间嘲笑。Sleep)，因此该值不是恒定的/可预测的:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lk"><img src="../Images/5ee767e663be387d57346791219bcf99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*3Xn3ggnbqkGEYtWpS4hSzQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">代码可能看起来很傻，但这一点已经被证明了</figcaption></figure><p id="d540" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们将使用名为“通道”的工具，这是线程间共享数据的首选方式。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ll"><img src="../Images/3441cb019bf25ecb9a285647924f847b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVW15pfQQPKvxecnL1qaKw.png"/></div></div></figure><p id="985a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从第9行开始，创建一个名为“counterChan”的通道，它将包含“int”类型的数据(您也可以指定缓冲区大小，但这将在另一篇文章中讨论)。</p><p id="704b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，在第11行和第18行启动两个相同的线程，每个线程最多运行8次，通过通道发送值1并休眠100 ms，然后主线程将运行16次迭代(每个线程8+8次)，并将从计数器中取出一个值，并将其与计数器变量相加。</p><p id="6391" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该通道的行为有点像一个项目队列(简化描述)，您可以使用以下格式写入任何内容:</p><p id="bec5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">频道</strong> &lt; -数值</p><p id="58b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将以线程安全的方式写入该“队列”，然后当您试图从中读取时:</p><p id="b572" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可变频道</p><p id="0ccb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果通道是空的，这将阻止执行，一旦一个值被放在它上面，然后它被发送到变量，执行被解锁(至少直到它到达另一个通道读取)。</p><p id="860a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本例中，我们写了一个硬编码的值1，然后有一个循环，它将监听16次来自通道的值，并将该值添加到计数器变量中。</p><p id="8ece" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果通道已经有一个我们还没有读取的值，执行将被阻塞，直到它为空，所以我们应该总是非常小心地尽可能快地读取/写入通道，并将任何其他代码推迟到另一个线程。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lm"><img src="../Images/994fb57ece0d564e667eb0ca93f8d48c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E-sMVMhui0t2SSpBMZD1XQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">由于计数器是在单个线程中聚合的，所以数字是排序的</figcaption></figure></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="22c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们现在将使用不同的解决方案来处理相同的问题:互斥体</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ln"><img src="../Images/ef9e41a39449af5c9b1c8b1c461e9bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bbNt-QO3dyPDw5fEovnWPA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">ex_9 .走</figcaption></figure><p id="cbae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一次，我们有一个字符串片段和两个将向其写入的线程，我们有相同的数据竞争条件，这在您多次运行该程序后会更加明显:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lo"><img src="../Images/5fcf427c8b2286822bc68796b63ed125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*A4P6HLF2jYQcPA57m3evyA.png"/></div></figure><p id="f4a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一次和最后一次运行中，它按照我们的预期工作，一个项目被添加到切片中，然后另一个项目被添加到切片中，数据被正确打印，每个线程都有一个项目，在第二次运行中，每个线程都将切片读取为空，线程一添加了一个值并打印出该值，然后线程二做了同样的事情，在第三次运行中，来自第一个线程的数据被添加但没有被打印。 然后第二个线程加了一个值，第一个线程打印它，然后第二个线程打印它(如果让你困惑的话，想象一下计算机会有多困惑！ ).</p><p id="87b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我们将使用众所周知的mutex(互斥)原语，这是一个可以在将被多个线程共享的东西上设置的锁，一次只有一个线程可以处理它。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lp"><img src="../Images/ea2e110a96c0f1205085a41280796957.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JQ8xDyhO8NYxiy8Vc3j-qA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">走吧</figcaption></figure><p id="5a2e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第9行将定义我们的互斥体，然后在第16/25行，使用一个. Lock()来启动一个对资源的独占访问块，一旦值被添加到任务片，锁就立即被移除，以便不同的线程也可以使用该片。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lq"><img src="../Images/9e9f3467093e72e0d024eccff83f564e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dE6gwTd3xxBZFNwSiBlkqg.png"/></div></div></figure><p id="55ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，无论我们运行多少次，数据都会是我们期望的样子。</p><p id="8f79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一个例子将非常相似，只是这一次我们将做更多的并发线程:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lr"><img src="../Images/2ebd208d8a733280f4429264ebad2aac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8pRGxu0gM5XXnVLeOyhGsg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">走吧</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ls"><img src="../Images/69302c24bbf90f929594ea62fa9001d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NbpKGdc40jzwq3bbVy5vzg.png"/></div></div></figure><p id="33d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">即使每次运行后数据排序不同，所有数据点都是唯一的，这是我们所期望的。</p><p id="3f95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的最后一个例子是一个设计模式，我用它来尽可能地保持资源可用(并且只在需要的时候)。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lt"><img src="../Images/17ba7b12e3ca25ec2417ea63ef62c1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ruPb543SwduhfPgY_-rZEA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">未完待续…</figcaption></figure><p id="77fb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们执行典型的循环，然后在随机休眠后对每个数字调用函数“Add ”,最后的for将保持程序持续运行，在我的用例中，程序总是有工作要做/正在监听rabbitMQ队列。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es lu"><img src="../Images/d560b92dc9d1ea2e01517a8d8bdadfa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41Jy8ZfcadG-jnum06AFZQ.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">…续</figcaption></figure><p id="b481" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Add func获取发送的项目，通过互斥锁阻止对任务片的访问，并将其附加到片上，如果片的长度为10个项目，则这些项目将被发送到不同的进程“转储”,该进程可以对它们进行任何操作，这10个项目将从片上删除，这样它们就不会被重新处理。如果由于任何原因，切片少于10个项目，那么我们启动一个定时器，它将等待5秒钟，如果定时器到期并且切片中有数据，那么将使用任何可用的数据来调用Dump func，这样我们就可以继续向前推送数据，要么是因为我们的“任务缓冲区”已满，要么是因为已经过了足够长的时间而没有对它执行任何操作，我们应该清除它以保持另一部分忙碌。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ka kb di kc bf kd"><div class="er es ln"><img src="../Images/dd30cb0bc341c457a3b5da0953b39851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vH9nXWPJBNXqyAO9h4jAw.png"/></div></div></figure><p id="f927" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">前3行将因缓冲区已满而被触发，最后一行是因为定时器到期，如果您注意时间，则从第一次添加开始运行5秒，触发的定时器是来自T24数据点的定时器，它发生在该项被转储之前，一旦定时器到期，其他行将跳过转储，因为这两个剩余值已经离开缓冲区。</p></div></div>    
</body>
</html>