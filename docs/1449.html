<html>
<head>
<title>Learn Blockchain by Building One using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用Python构建区块链来学习区块链</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/learn-blockchain-by-building-one-using-python-780d41ccb112?source=collection_archive---------13-----------------------#2021-03-02">https://medium.com/analytics-vidhya/learn-blockchain-by-building-one-using-python-780d41ccb112?source=collection_archive---------13-----------------------#2021-03-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/a7983b099ccc6e770a27f8e1dc7f5177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*Ctxj3RVWUash_hjYIWnS3g.png"/></div><figcaption class="il im et er es in io bd b be z dx translated"><a class="ae ip" href="https://www.information-age.com/bitcoin-cryptocurrencies-perfect-hedge-covid-19-crisis-123490086/" rel="noopener ugc nofollow" target="_blank">比特币</a></figcaption></figure><p id="2c29" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在开始构建区块链之前，您需要了解区块链的一些基础知识。</p><p id="5db1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">顾名思义，区块链就是“区块链”。每个块包含一个“<strong class="is hi">块号</strong>”、“<strong class="is hi">现时值</strong>”、“<strong class="is hi">信息(数据)”、特定事务</strong>发生的位置、“T8】先前散列和“<strong class="is hi">散列</strong>”。</p><p id="2e04" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">区块链中的所有区块都通过“哈希”变量相互链接。“哈希”包含链中前一个块的信息，这是保持整个链链接和连接的原因。这个散列只不过是一些密钥，这些密钥是由密码算法(例如:SHA256、SHA512、SHA6等)产生的一些混洗字符。)</p><p id="ef88" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">以SH256算法为例:包含64个字符(1，2…9，0 &amp;A，B，C，…。e，F)和256位(4X64)每个字符。</p><h1 id="5abb" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">我们开始吧</strong></h1><p id="bbe7" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">逐步解释</p><p id="3b7b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><a class="ae ip" href="https://github.com/Prachi-Gopalani13/Blockchain-Demo" rel="noopener ugc nofollow" target="_blank"> <strong class="is hi">(如果你愿意，这是代码)</strong> </a></p><h2 id="e973" class="kr jp hh bd jq ks kt ku ju kv kw kx jy jb ky kz kc jf la lb kg jj lc ld kk le bi translated"><strong class="ak">安装库</strong></h2><p id="7e81" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated">确保你已经安装了Python (Spider)的最新版本。为了处理请求，我使用了<a class="ae ip" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>。此外，您需要安装两个Python库，分别名为Flask和Requests，库需要:</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="8709" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">第一部分:构建区块链</strong></h1><p id="8d39" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated"><strong class="is hi">初始化块的变量:</strong></p><p id="8714" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">创建一个名为blockchain.py的Python文件，这里首先要创建一个<em class="ll"> Blockchain </em>类，并初始化以下变量:</p><p id="4977" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">用self创建一个constructor _init_(self)是Blockchain类的实例</p><p id="5bce" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll">链:</em> </strong>一个<strong class="is hi"> <em class="ll"> </em> </strong>空列表，在其中添加块。</p><p id="e328" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll"> create_block </em> </strong>:在这个方法中，我们用0初始化了之前的hash，从这里开始制作块。</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="d02b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll">创建区块链</em> </strong></p><p id="b68a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在我们有一个空的链，让我们添加块到它！我们将添加一个<em class="ll">块</em>变量，用这些属性描述一个JSON对象:</p><p id="b6f8" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll">索引</em> </strong>:取我们区块链的长度，并加1。我们将使用它来引用一个单独的块，例如，genesis块的index = 1</p><p id="ab1b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll">时间戳</em> </strong>:使用我们的time()导入，时间戳的意思是时间，这个时间就是他们当时在电脑上的时间。</p><p id="ad0b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll">证明</em> </strong>:这来自我们的矿工，他认为自己找到了一个有效的“现时”，或者说“证明”。我们稍后会详细讨论这个问题。</p><p id="9775" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi"> <em class="ll"> previous_hash </em> </strong>:最近<em class="ll">批准的</em>块的散列版本。</p><p id="81ff" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在，我们将把所有关于block的信息添加到block列表(self.chain)中，并返回新的block。</p><p id="5f48" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">加工前一个程序块</strong></p><p id="de06" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">到目前为止，一切顺利！让我们首先定义一个get_previous_block()方法，这样我们就可以调用我们的链并接收最近添加的块(我们将在我们的新索引中使用它)。</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5390" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">工作证明</strong></p><p id="6a2e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在我们简单的区块链被创造出来了，是时候保护我们的创世积木了。我们不希望任何人通过提供新的哈希信息来改变我们的区块链。为此，我们需要实现一个工作证明算法。工作证明算法只是确保没有人能够改变散列。该算法将对区块链上生成的哈希添加一些约束，使得任何人都无法进行任何更改。</p><p id="756b" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">为此，我们向块字段添加一个nonce。这将确保我们的哈希保持约束。</p><p id="5e97" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">“工作证明”使用SHA-256算法，但是设置了一个条件，而不是接受一个输入并给出一个输出，例如<strong class="is hi">输出散列需要将前四个字符作为零。</strong></p><p id="d8f1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这里使用了一个名为Hasib的函数，在它的<strong class="is hi"> </strong>中。encode()和。hexdigest()用于获得正确格式的十六进制输出。中间的数学部分是一些生成散列的简单数学。</p><p id="88f6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">因此，基本上,“证明”将增加1，直到我们设置的条件(前四个零)得到满足。<strong class="is hi"> </strong>一旦满足条件，将证明变量添加到块中，然后将块添加到块链中。</p><p id="6c92" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下面是“工作证明”功能的代码</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="6a45" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">检查模块</strong>的有效性</p><p id="7c44" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下面的代码片段用于验证代码块的完整性。我们一次获取一个数据块，并使用之前的哈希值检查它是否为真，否则有人在某个时候弄乱了区块链数据，因此我们回滚。或者在任何散列不能匹配前四位数为零的条件的情况下。我们返回false。</p><p id="1eea" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">完成了区块链的制作，现在是开采区块和在Flask API中实现的时候了，因为我已经在这里使用了Postman来观察开采的区块。</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h1 id="572e" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">第2部分:在Postman中执行代码</h1><p id="7609" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated"><strong class="is hi">创建烧瓶API </strong></p><p id="89e1" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">在python中调用内置函数Flask并存储在app中，同时调用前面步骤中构建的主函数Blockchain()并赋给区块链变量。现在，下一步将是使用app.route方法开采区块。</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="7f6f" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">开采一个区块</strong></p><p id="caad" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">@app.route ('/'，methods=[])这是一个flask beauty，可以在其中命名URL和方法。将执行下面的功能。@app.route()在flask中被称为decorators。我们实例化了一个烧瓶对象和一个名为区块链的区块链对象。步骤1创建区块，或者用专业术语来说，开采新区块。其中包含以下响应:</p><p id="c484" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">消息:</strong>矿块消息</p><p id="5e25" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">索引:</strong>块号</p><p id="2506" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">时间戳:</strong>区块开采的时间</p><p id="6248" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">证明:</strong>哪个是加密的哈希密钥</p><p id="f60a" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">上一个哈希:</strong>最后一个加密的哈希密钥</p><p id="df86" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">所有这些都将被定向到JSON Flask API(因为这里我们将使用postman进行演示)。</p><p id="4824" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">现在的问题是我们如何看到这个链条？</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="13a6" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">获得全区块链</strong></p><p id="b967" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">这就是get_chain装饰器的用途。它返回整个区块链。你可能已经看到了jsonify函数，它将python字典转换成可以跨API发送的json对象。这里，在已经定义的响应链和长度中=200意味着直到可以开采200个块。</p><p id="12a5" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">下一个函数is_valid()用于在Flask API中显示消息</p><figure class="lf lg lh li fd ii"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="5441" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">运行代码</strong></p><p id="36da" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">运行代码后，打开postman并登录，你会看到一个看起来像地址栏的屏幕。到那里选择方法GET(这实际上是默认的)并输入<a class="ae ip" href="http://0.0.0.0:5000/get_chain" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/GET _ chain</a>，你应该看到你的区块链的genesis块。让我们挖掘更多的节点<a class="ae ip" href="http://0.0.0.0:5000/mine_block" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0 . 0:5000/mine _ block</a>你将能够看到更多的节点。再做几个节点，一旦完成，你可以查看<a class="ae ip" href="http://0.0.0.0:5000/get_chain" rel="noopener ugc nofollow" target="_blank">http://0 . 0 . 0:5000/get _ chain</a>，看看你的区块链是如何成长的！</p><p id="50e7" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">你可以在块中添加更多的字段，也许更多的数据段等等。我希望你能使用Postman来测试我们的API。</p><h1 id="eda2" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">第3部分:输出快照</strong></h1><p id="e446" class="pw-post-body-paragraph iq ir hh is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn ha bi translated"><strong class="is hi">通过get_chain函数挖掘的3个块</strong></p><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/6fcec8ed3faef5ebe92a431ca0ed623d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*ITiIMw7QkWn58c78nuGLVw.png"/></div><figcaption class="il im et er es in io bd b be z dx translated"><strong class="bd jq">开采了3个区块</strong></figcaption></figure><figure class="lf lg lh li fd ii er es paragraph-image"><div class="er es ln"><img src="../Images/3a6efc75f292e81116cd64db706e5b0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*eb0u5EP5XhUlDXSEqf-Icw.png"/></div><figcaption class="il im et er es in io bd b be z dx translated"><strong class="bd jq">显示消息(证明od块有效性)</strong></figcaption></figure><p id="32eb" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated"><strong class="is hi">结论:</strong> <br/>在本文中我们学习了区块链的基础和一些工作方式，我们还成功地创建了一个区块链应用程序。编写区块链代码和挖掘区块链。从这里你可以做很多事情，尽你所能改进应用程序。</p><p id="9587" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">此处提供代码<a class="ae ip" href="https://github.com/Prachi-Gopalani13/Blockchain-Demo" rel="noopener ugc nofollow" target="_blank"> Github链接</a>！</p><p id="5b24" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">学习愉快！</p><p id="d34e" class="pw-post-body-paragraph iq ir hh is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn ha bi translated">关注更多更新！</p></div></div>    
</body>
</html>