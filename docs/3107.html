<html>
<head>
<title>Logistic Regression Understanding and Implementation From Scratch (Part 1)| Python | Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从零开始理解和实现逻辑回归(第1部分)| Python |机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-understanding-and-implementation-from-scratch-part-1-python-machine-a8cf9e459f10?source=collection_archive---------6-----------------------#2021-06-07">https://medium.com/analytics-vidhya/logistic-regression-understanding-and-implementation-from-scratch-part-1-python-machine-a8cf9e459f10?source=collection_archive---------6-----------------------#2021-06-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c66a82f73762642ee9d78d82a0ef23a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Vc8yv2rvxWpIWob_BehzA.png"/></div></div></figure><p id="c2a1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是一个由两部分组成的系列。第1部分(这一部分)将是关于逻辑回归算法的理论理解。  <a class="ae jo" href="https://writersbyte.com/programming/understanding-and-implementing-logistic-regression-algorithm-part-1-python-machine-learning/" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi"> <em class="jn">第二部分</em> </strong> </a> <strong class="ir hi"> <em class="jn">将覆盖编码部分，这里我们将在PYTHON中实现LOGISTIC回归* </em> </strong></p><p id="1abb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我在以前的博客中讨论过很多机器学习文章，但大多数都是<em class="jn">回归算法</em>，即预测连续数字。这一次我们稍微改变一下思路，转而预测离散类。</p><p id="697c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这次我们将讨论<strong class="ir hi"> <em class="jn">逻辑回归</em> </strong>算法的工作原理。</p><p id="e3cb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">回归算法预测连续数据，例如来自一组给定特征的特定商品的价格，而逻辑回归给出基于类别的预测，例如<strong class="ir hi"> <em class="jn">某个人是否肥胖或是否患有糖尿病</em> </strong>。</p><p id="44c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这种算法可以被训练来从给定的数据中预测多个类别。然而，为了简单起见，我们将在本教程中讨论二进制数据分类。</p><h1 id="92eb" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">算法:</h1><p id="55a6" class="pw-post-body-paragraph ip iq hh ir b is kn iu iv iw ko iy iz ja kp jc jd je kq jg jh ji kr jk jl jm ha bi translated">逻辑回归与线性回归非常接近。如果你不熟悉线性回归，可以在这里了解一下<a class="ae jo" href="https://writersbyte.com/implementing-multi-variable-linear-regression-algorithm-in-python/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4242" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">线性回归就是<em class="jn">拟合直线。</em> <strong class="ir hi">逻辑回归</strong>，然而，事情有点弯曲(双关语😉，过一会儿你就明白了😅).</p><p id="1180" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">初始计算与线性回归的计算相同，我们有一组由<strong class="ir hi"> X </strong>表示的输入特征和一些与之相关的随机初始化权重，这里是<strong class="ir hi"> θ </strong>。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/2ccc818e5b8c2690ac7a48eda8f78aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:210/format:webp/1*p4JjMS9aeHeewhJAwjkV-Q.png"/></div></figure><p id="a633" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">上述两个量的点积形成一条直线的方程。我们仍然可以用这条直线来拟合我们的二进制类，下面是它的样子。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es kx"><img src="../Images/5db0d84a50ba1e3813fda5731457f092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*UchwJ1TKX0XQU7lD2w4IUA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">来自训练数据的二进制输出标签</figcaption></figure><p id="3271" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们只有两个类，用<strong class="ir hi"> 0 &amp; 1 </strong> ( <strong class="ir hi">记住！！</strong> <em class="jn">计算机不理解文本，所以所有的字符串输入都必须以数字格式编码</em>)，这就是我们的输出。如果我们在这里做线性回归，拟合一条直线，我们可能会得到合理的结果。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/566bd2f1fe71a34c74cddc099bb393a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*a_9Vrr6bVnw3aCnaT7khbw.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">对这样的数据拟合直线</figcaption></figure><p id="cfa7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这看起来足够好了，线左边的任何数据点都是0(红色)，右边的任何数据点都是1(绿色)，当然有边际误差。但是等等！！如果我们的数据分布不均匀，如果我们有异常值怎么办？让我们看看这会有什么影响。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/961ad4689aca26f339fee9fa5e1f57da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*zWSy4ys-6HfEdp5HiZN11w.png"/></div></figure><p id="0e3d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在我们有一个问题。由于类1中的数据位置较远，线更加向右倾斜，因此类1中的许多点现在被错误分类。</p><p id="b712" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好消息是，这是有解决办法的。为了正确分类这些数据，我们要做的就是…</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es le"><img src="../Images/274e330a48bfc2163431dca8c15b8e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRQHfBkSDvVHrP9WswcVuw.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx">😁</figcaption></figure><p id="4810" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们必须添加某种变换，将这条直线变成一条更…..柔韧的。一个。这就是我们引入sigmoid函数的地方。数学上，sigmoid函数由以下等式表示:</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/1cfc505c7e4a78537599eaf6f5067cf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*u94URFBqCJ_Ssk5QPPxxdg.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">sigmoid函数的数学表达式</figcaption></figure><p id="af5a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该函数具有以下形状:</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lg"><img src="../Images/249f239345445b3269c689f1fe638273.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VuE-KFEgdmEpK54fZEpRFQ.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">s形曲线</figcaption></figure><p id="4fb2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个函数被限制在0和1之间，直观地说，它更倾向于适合我们的二进制数据。线性回归和逻辑回归之间的唯一区别是增加了sigmoid转换这一额外步骤。所以现在我们的数据会经历以下几个步骤；</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/7dc832a4c9a22939cba629df9a80f969.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*D7BWujLue92ux3EK1FL3BA.png"/></div></figure><p id="6b31" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最终的输出变量<strong class="ir hi"> z </strong>是我们的模型将预测的。</p><p id="7480" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像每一个机器学习模型一样，我们将使用随机权重初始化我们的模型，因此为了使曲线合适，我们将执行与线性回归相同的步骤；</p><ol class=""><li id="d7fd" class="li lj hh ir b is it iw ix ja lk je ll ji lm jm ln lo lp lq bi translated"><strong class="ir hi">计算产量。</strong></li><li id="2db7" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">使用各自的损失函数计算损失(衡量我们的预测输出与实际输出的差距)。</strong></li><li id="6d5a" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">使用更新等式更新权重，以最小化损失。</strong></li><li id="8813" class="li lj hh ir b is lr iw ls ja lt je lu ji lv jm ln lo lp lq bi translated"><strong class="ir hi">重复步骤1-3，直到完成设定的迭代次数。</strong></li></ol><p id="79c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看看这个损失函数和更新方程。</p><p id="1bb1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于线性回归，我们使用了良好的均方误差函数，但它不适合这里，因为我们的sigmoid函数在系统中引入了非线性，并且均方误差不会达到全局最小值。</p><p id="c533" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我将跳过实际损失函数的本质细节，直接跳到等式。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lw"><img src="../Images/3665f658170652d63f45b7e56108929f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*THQllprv_JhwGdcoZOrlNg.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">逻辑回归的损失函数</figcaption></figure><p id="d901" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了找到这个损失函数的最小值，我们取这个函数对给定重量的导数。令人惊讶的是，导数结果与线性回归函数的导数完全相同。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/c52d06598ed2bb41bb7341e0eeb12828.png" data-original-src="https://miro.medium.com/v2/resize:fit:664/format:webp/1*XA7v-HlcWJyYY46r051BNA.png"/></div><figcaption class="ky kz et er es la lb bd b be z dx translated">最小化损失</figcaption></figure><p id="7ef7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于我们模型中使用的所有权重，更新方程保持不变。</p><p id="d75b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在此之后，我们所要做的就是重复上述步骤，直到我们有一个合理的拟合。</p><figure class="kt ku kv kw fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/e445ec5e998c9b6cf42ee57ea65bbaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9DPR4oUQSkiJZCU_Uba_3w.png"/></div></div><figcaption class="ky kz et er es la lb bd b be z dx translated">针对二元类的sigmoid曲线</figcaption></figure><p id="dd0f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个看起来好多了。对于这样的拟合，我们可以简单地设置规则，比如对于大于0.5的<strong class="ir hi">值，我们给它一个值1，对于小于0.5的，给它0。</strong></p><p id="3734" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是它，这就是完整的逻辑回归算法解释。</p><p id="8906" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本教程的第2部分是关于逻辑回归的python实现。</p><p id="89a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jo" href="https://writersbyte.com/programming/understanding-and-implementing-logistic-regression-algorithm-part-1-python-machine-learning/" rel="noopener ugc nofollow" target="_blank">在这里阅读第二部分</a>。</p><h2 id="d080" class="lz jq hh bd jr ma mb mc jv md me mf jz ja mg mh kd je mi mj kh ji mk ml kl mm bi translated">更像这样:</h2><div class="mn mo ez fb mp mq"><a href="https://writersbyte.com/datascience/implementing-k-means-clustering-with-k-means-initialization-in-python/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hi fi z dy mv ea eb mw ed ef hg bi translated">实现K意味着用K Means++初始化| Python进行聚类。- WritersByte</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">K-Means聚类是一种无监督的机器学习算法。无人监管意味着它不需要标签或…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">writersbyte.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne in mq"/></div></div></a></div><div class="mn mo ez fb mp mq"><a href="https://writersbyte.com/datascience/ai-for-beginners/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hi fi z dy mv ea eb mw ed ef hg bi translated">人工智能初学者:人工智能基础- WritersByte</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">你正在浏览你的脸书页面。你看到一则广告“我们的人工智能解决方案将改变你的…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">writersbyte.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne in mq"/></div></div></a></div><div class="mn mo ez fb mp mq"><a href="https://writersbyte.com/programming/4-key-python-data-structures-e-very-beginner-must-know/" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab dw"><div class="ms ab mt cl cj mu"><h2 class="bd hi fi z dy mv ea eb mw ed ef hg bi translated">每个初学者都必须知道的4个关键Python数据结构。- WritersByte</h2><div class="mx l"><h3 class="bd b fi z dy mv ea eb mw ed ef dx translated">最近几年，Python已经成为最受编程新手欢迎的语言，因为它易于使用，而且…</h3></div><div class="my l"><p class="bd b fp z dy mv ea eb mw ed ef dx translated">writersbyte.com</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne in mq"/></div></div></a></div></div></div>    
</body>
</html>