<html>
<head>
<title>Type qualifiers : const , volatile , in C++ a tutorial</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型限定符:const，volatile，在C++教程中</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/type-qualifiers-const-volatile-in-c-a-tutorial-d2d61a0d83a1?source=collection_archive---------28-----------------------#2021-01-11">https://medium.com/analytics-vidhya/type-qualifiers-const-volatile-in-c-a-tutorial-d2d61a0d83a1?source=collection_archive---------28-----------------------#2021-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="86cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">c++ <strong class="ig hi"> <em class="jc">中对象的声明具有以下形式</em> </strong>:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8dac" class="jm jn hh ji b fi jo jp l jq jr">[Storage class] [Qualifier] Type Name ;</span><span id="53af" class="jm jn hh ji b fi js jp l jq jr">/*brackets means optional  .*/</span></pre><p id="4c30" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于存储类，您可以查看本<a class="ae jt" href="https://twiserandom.com/cpp/storage-classes-in-c-a-tutorial/" rel="noopener ugc nofollow" target="_blank">教程</a>，至于限定符，它们用于限定一个定义，作为常量定义:<code class="du ju jv jw ji b">const</code>，或者可变定义:<code class="du ju jv jw ji b">volatile</code>，或者两者都是<code class="du ju jv jw ji b">const volatile</code>定义。</p><p id="7755" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ju jv jw ji b">const</code>和<code class="du ju jv jw ji b">volatile</code> <strong class="ig hi"> <em class="jc">可以与</em> </strong>变量、函数参数和返回值、类类型数据成员和函数成员一起使用。</p><h1 id="b03f" class="jx jn hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">常数</h1><p id="58b6" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated"><code class="du ju jv jw ji b">const</code>表示不可改变，<strong class="ig hi"> <em class="jc">提供定义后，</em> </strong>定义不变。常量变量必须初始化。</p><p id="693b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi"> <em class="jc">带有变量</em> </strong>的例子。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e876" class="jm jn hh ji b fi jo jp l jq jr">int var_i;<br/>/*var_i is not a constant <br/>  variable , its definition <br/>  can be changed .*/<br/>var_i = 1;</span><span id="ddc6" class="jm jn hh ji b fi js jp l jq jr">int var1_i;<br/>/*var1_i  is not a constant <br/>  variable , its definition can <br/>  be changed .*/<br/>var1_i = 1;</span><span id="9eb5" class="jm jn hh ji b fi js jp l jq jr">const int var_ci = -1 ;<br/>/*var_ci  is a constant <br/>  variable , its definition <br/>  cannot change . <br/>  var_ci can also be declared <br/>  int const var_ci = -1 ; */</span><span id="a9e5" class="jm jn hh ji b fi js jp l jq jr">int const *ptr_ci = &amp;var_i;<br/>/*ptr_ci is a pointer to <br/>  a constant integer , <br/>  it is illegal to use<br/>  *ptr_ci = 4 ; <br/>  to change the value of <br/>  the pointed to integer .*/</span><span id="5403" class="jm jn hh ji b fi js jp l jq jr">int *const cptr_i = &amp;var_i;<br/>/*cptr_i is a constant pointer<br/>  to an integer . The value <br/>  of cptr_i cannot be changed .<br/>  It is illegal to do :<br/>  cptr_i = &amp;var1_i; .*/</span><span id="a29e" class="jm jn hh ji b fi js jp l jq jr">const int *const cptr_ci = &amp;var_i;<br/>/*cptr_ci is a constant pointer <br/>  to a constant integer . The<br/>  value of the pointer and the <br/>  pointed value cannot be changed .<br/>  It is illegal to do :<br/>  cptr_ci = &amp;var1_i;<br/>  *cptr_ci = 34; .*/</span></pre><p id="0dc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi"> <em class="jc">带函数参数的例子。</em> </strong></p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c102" class="jm jn hh ji b fi jo jp l jq jr">const int * foo(const int *ptr_ci ){<br/>    /*ptr_ci is a pointer to a<br/>      constant integer , the value<br/>      of the constant integer must<br/>      not be changed .<br/>      The function foo , perform<br/>      an operation , that does not<br/>      affect original data .*/</span><span id="1bf3" class="jm jn hh ji b fi js jp l jq jr">    static int arr_i[ ] = {0 , 1 , 2 , 3 };<br/>      /*Declare a static array arr_i.*/</span><span id="310a" class="jm jn hh ji b fi js jp l jq jr">    return &amp;arr_i[1];<br/>      /*Return the address of the<br/>      second element of the array .*/ }</span></pre><p id="822c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个<strong class="ig hi"> <em class="jc">的例子，有类</em> </strong>的数据成员，和类成员函数。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="1130" class="jm jn hh ji b fi jo jp l jq jr">class Foo{<br/>public:<br/>  const int var_i;<br/>  float var_f;<br/>  mutable double var_d;<br/>  /*A mutable class data member ,<br/>    can be changed , even<br/>    if its class instance is<br/>    declared constant .*/<br/>  Foo( );<br/>  void cFct( )const; };</span><span id="16ab" class="jm jn hh ji b fi js jp l jq jr">Foo::Foo():var_i(0 ) , var_f(-1.f ) , var_d(0.4 ){}</span><span id="455f" class="jm jn hh ji b fi js jp l jq jr">void Foo::cFct( )const{<br/>  /*A constant function can access<br/>    all data members , but must not<br/>    change the value of any , beside<br/>    a data member which is declared<br/>    mutable .*/<br/>  var_d = var_d + var_f + var_i; }</span><span id="ef7b" class="jm jn hh ji b fi js jp l jq jr">int main(void ){<br/>  Foo foo;<br/>  /*Create an object named foo ,<br/>    It is illegal to do<br/>    foo.var_i = -1 ; <br/>    because var_i is declared<br/>    constant .*/</span><span id="cd0b" class="jm jn hh ji b fi js jp l jq jr">  foo.var_d = foo.var_i + foo.var_f + foo.var_d ;<br/>  /*Assign a value to var_d .*/</span><span id="71d0" class="jm jn hh ji b fi js jp l jq jr">  foo.cFct();<br/>  /*Call the constant function cFct .*/</span><span id="1ac5" class="jm jn hh ji b fi js jp l jq jr">  const Foo foo_c;<br/>  /*Create an object named foo_c.<br/>    foo_c is declared constant ,<br/>    it is allowed only to change<br/>    the value of a mutable data<br/>    member.<br/>    It is illegal to do :<br/>      foo_c.var_f = 4.f ; .*/</span><span id="51ba" class="jm jn hh ji b fi js jp l jq jr">  foo_c.var_d = foo.var_i + foo.var_f + foo.var_d ;<br/>  /*Assign a value to var_d , which is<br/>   a mutable data member .*/<br/>  foo_c.cFct();<br/>  /*A constant object is only <br/>    allowed to call constant <br/>    functions .*/ }</span></pre><h1 id="e668" class="jx jn hh bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">不稳定的</h1><p id="bebb" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">一个<code class="du ju jv jw ji b">volatile</code>限定符，用来通知编译器，那一个<strong class="ig hi"> <em class="jc">变量的定义，可以</em> </strong> <em class="jc"> </em>异步地改变到程序中。所以在某种程度上，这与程序本身所做的改变无关，因此变量的改变可以由外部进程来完成。</p><p id="2270" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当使用volatile限定符时，编译器<strong class="ig hi"> <em class="jc">不做某些优化</em> </strong>，这依赖于变量定义的变化与程序本身同步的事实。当一个变量被访问时，即使程序本身没有改变它的值，变量值也要被重新读取。</p><p id="84c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jc">非静态的成员函数</em> </strong>可以声明为volatile，如果一个类的实例是volatile，那么它只能访问volatile成员函数。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2914" class="jm jn hh ji b fi jo jp l jq jr">class Foo{<br/>public:<br/>  volatile int var_vi;<br/>  float var_f;<br/>  Foo();<br/>  void fct_v( )volatile;<br/>  void fct();<br/>};</span><span id="7c0c" class="jm jn hh ji b fi js jp l jq jr">Foo::Foo( ):var_vi(1 ) , var_f(-3.f ){}</span><span id="7635" class="jm jn hh ji b fi js jp l jq jr">void Foo::fct_v( )volatile{<br/>  var_vi = var_vi + var_f; }</span><span id="b656" class="jm jn hh ji b fi js jp l jq jr">void Foo::fct( ){<br/>  var_vi = var_vi + var_f; }</span><span id="9322" class="jm jn hh ji b fi js jp l jq jr">int main(void ){<br/>  Foo foo;<br/>  /*Create an instance of foo .*/<br/>  foo.var_vi = -1;<br/>  /*Set a value to the volatile<br/>    data member .*/<br/>  foo.fct_v();<br/>  /*Call the volatile function .*/<br/>  foo.fct();<br/>  /*Call the non volatile function .*/</span><span id="59cc" class="jm jn hh ji b fi js jp l jq jr">  volatile Foo foo_v;<br/>  /*Create a volatile instance of<br/>    Foo .<br/>    Each data member of foo_v<br/>    is volatile . foo_v can<br/>    only access functions declared<br/>    as volatile .*/<br/>  foo_v.var_f = 3.1f;<br/>  /*Set a value to var_f which <br/>    is not declared volatile .*/<br/>  foo_v.fct_v();<br/>  /*Call the volatile function <br/>    fct_v .*/ }</span></pre><p id="1d51" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du ju jv jw ji b">const</code> <strong class="ig hi"> <em class="jc">可以和</em> </strong> <code class="du ju jv jw ji b">volatile</code>一起使用，表示一个变量相对于程序本身的不变性，但是这个变量从程序外部被改变的能力。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="2ac9" class="jm jn hh ji b fi jo jp l jq jr">const volatile int var_ci = 0 ;</span></pre></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="21f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">最初发表于2021年1月11日</em><a class="ae jt" href="https://twiserandom.com/cpp/type-qualifiers-const-volatile-in-cpp-a-tutorial/" rel="noopener ugc nofollow" target="_blank"><em class="jc">https://twiserandom.com</em></a><em class="jc">。</em></p></div></div>    
</body>
</html>