<html>
<head>
<title>Introduction to TensorFlow with Keras API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Keras API tensor flow简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/introduction-to-tensorflow-with-keras-api-36cbeeb562d5?source=collection_archive---------4-----------------------#2021-05-23">https://medium.com/analytics-vidhya/introduction-to-tensorflow-with-keras-api-36cbeeb562d5?source=collection_archive---------4-----------------------#2021-05-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="3727" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在TensorFlow中创建各种神经网络的简单介绍。</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/5f929db6ce92b02c3942bcf15c72f335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2NrF3RYT3Y1I9Zp2_Fqvlw.jpeg"/></div></div></figure><h1 id="b8d3" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">Keras是什么？</h1><p id="42e7" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">Keras是一种高级深度学习API(应用程序编程接口)，允许我们轻松地构建、训练、评估和执行各种神经网络。它所做的是抽象出各种深度学习库的实现，如TensorFlow、微软认知工具包(CNTK)和Theano。</p><h1 id="43bc" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">什么是张量流？</h1><p id="d43b" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">这是一个深度学习库，同时它还提供了大量用于数值计算和大规模机器学习的工具。它还提供了用于模型可视化TensorBoard、用于生产TensorFlow项目的TensorFlow Extended (TFX)等等。</p><h1 id="54f0" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">我们开始吧</h1><p id="2467" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">为了使用Keras在TensorFlow中构建神经网络，TensorFlow提供了自己的Keras实现。要使用它，让我们导入它。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="863c" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">Keras提供了3种不同的API来创建基于模型复杂程度的神经网络。这些是:</p><ul class=""><li id="0373" class="ld le hh kc b kd ky kg kz kj lf kn lg kr lh kv li lj lk ll bi translated"><strong class="kc hi">顺序API </strong></li><li id="465e" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="kc hi">功能API </strong></li><li id="d55a" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated"><strong class="kc hi">子类化API </strong></li></ul><p id="249e" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">我们会一个一个地检查。</p><h1 id="7145" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">使用Keras Sequential API构建简单模型</h1><p id="edf6" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">对于非常简单的用例，或者有时甚至对于基线模型，这个API通常是首选的。它是一层层的线性堆叠。</p><p id="6930" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">在这里，我们为具有两个隐藏图层的MNIST数据集创建了一个分类MLP。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="11c7" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">这里有一点见解:</p><ul class=""><li id="9340" class="ld le hh kc b kd ky kg kz kj lf kn lg kr lh kv li lj lk ll bi translated">首先是一个<code class="du lr ls lt lu b">Flatten</code>层，其目的是将每个输入转换成一个1D数组。直观上，它执行<code class="du lr ls lt lu b">X.reshape(-1,1)</code>，其中<code class="du lr ls lt lu b">X</code>是输入。我们还提供了28×28的<code class="du lr ls lt lu b">input_shape</code>，因为MNIST数据集由28×28像素的数字图像组成。</li><li id="9d39" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">然后我们堆叠了两个<code class="du lr ls lt lu b">Dense</code>层，都有<code class="du lr ls lt lu b">"relu"</code>激活。</li><li id="d581" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">最后，我们添加了一个激活了<code class="du lr ls lt lu b">"softmax"</code>的<code class="du lr ls lt lu b">Dense</code>输出层，因为这个模型是用于分类任务的。</li></ul><p id="436e" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">但是有一种更简单的方式来写这个:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="a6f1" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">现在我们可以调用模型的<code class="du lr ls lt lu b">summary()</code>方法来显示模型的所有层和参数。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lv"><img src="../Images/62bc5ad8082a2fd09e594d3b11eea252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/0*FbAs6wvWoGjcQkTq.png"/></div></figure><ul class=""><li id="b411" class="ld le hh kc b kd ky kg kz kj lf kn lg kr lh kv li lj lk ll bi translated">如前所述，展平层展平我们的28x28输入，以在第一层中给出784个神经元的输入形状。</li><li id="3161" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">根据我们的代码，下一层有300个神经元。每个神经元与前一层(即<code class="du lr ls lt lu b">Dense</code>层)中的每个神经元都有联系，导致300x784 = 235200个权重加上300个偏差(该层中的每个神经元)= 235500个可训练参数。</li><li id="c8d9" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">并且对于该NN中的所有不同层，情况相同。</li></ul><h1 id="779d" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">编译模型</h1><p id="57e0" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">模型的<code class="du lr ls lt lu b">compile()</code>方法指定了损失函数和要使用的优化器。我们还可以指定我们希望在培训和评估期间计算的额外指标。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="29ad" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">我们使用了<code class="du lr ls lt lu b">"sparse_categorical_crossentropy"</code>,因为对于每个实例，只有一个目标类索引(0-9 ),并且这些类是互斥的。</p><p id="fd20" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">如果我们每个实例有一个目标概率，(就像第三类的<code class="du lr ls lt lu b">[0., 0., 0., 1., 0., 0., 0., 0., 0., 0.]</code>)我们会使用<code class="du lr ls lt lu b">"categorical_crossentropy"</code>。</p><p id="db69" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">对于二元分类任务，我们将使用<code class="du lr ls lt lu b">"binary_crossentropy"</code>。</p><h1 id="ff07" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">训练模型</h1><p id="9524" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">对于训练，我们调用<code class="du lr ls lt lu b">fit()</code>方法，传递输入特征、标签和历元数。我们还可以传递验证数据，以便在模型接受训练时测量验证的准确性。</p><p id="7279" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">这个方法返回一个<code class="du lr ls lt lu b">history</code>对象，然后我们可以使用Tensorboard或一个简单的脚本来可视化它。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/11b7f511312a5952d77f8344a3dc95a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bVwa_XerM4IqGh9hu49iuA.jpeg"/></div></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lx"><img src="../Images/2bd2675dea2417dfccd37864089ff1d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*ziYRu52msj1L0_Pm8NDKkA.png"/></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">绘制训练模型的学习曲线</figcaption></figure><h1 id="5be1" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">使用函数式API构建复杂模型</h1><p id="a374" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">此API主要用于构建非顺序神经网络，即，我们将拥有多个输入、多个输出，甚至将激活或输入直接传递给网络中的其他层。</p><p id="ecd8" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">一个这样的例子是<em class="mc">宽&amp;深</em>的神经网络。该网络将全部或部分输入直接连接到输出层。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/00d609f252265c78fc27c7b171bf2ab3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Z4d0uoHEpEftPespm1vIA.jpeg"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">广度和深度神经网络</figcaption></figure><p id="2ddd" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">这有助于学习深度模式(使用深度路径)和简单规则(通过短路径)。</p><p id="2c53" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">在Keras中，我们可以像这样使用函数式API来构建加州住房预测问题:</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><ul class=""><li id="540e" class="ld le hh kc b kd ky kg kz kj lf kn lg kr lh kv li lj lk ll bi translated">注意我们是如何创建一个指定输入形状的<code class="du lr ls lt lu b">Input</code>对象的，然后这个对象在创建后就被传递给<code class="du lr ls lt lu b">Dense</code>层作为输入。</li><li id="97cc" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">这创建了一个隐藏的层对象<code class="du lr ls lt lu b">hidden1</code>，它被进一步传递到<code class="du lr ls lt lu b">hidden2</code>。</li><li id="2b10" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">然后我们需要连接密集层的输入和输出。因此我们使用了<code class="du lr ls lt lu b">Concatenate</code>层并传递了<code class="du lr ls lt lu b">input_</code>和<code class="du lr ls lt lu b">hidden2</code>对象。</li><li id="455b" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">最后，我们告诉Keras什么是输入和输出。从而创建了我们的模型对象。</li></ul><p id="4e84" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">但是，如果您想要多个输入或多个输出呢？使用函数式API，你也可以做到这一点。检查这个:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/3d9769fcaf517ea865d67dcad8593983.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z5LWYS_mNAxUeGSv1k_TXA.jpeg"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">具有两个输入的宽深度神经网络</figcaption></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="7eae" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">这让我们通过宽路径发送特征的子集，通过深路径发送不同的特征子集。</p><p id="0d07" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated"><strong class="kc hi">需要注意的一点是，</strong>现在我们需要调用<code class="du lr ls lt lu b">fit()</code>方法<strong class="kc hi">来提供一组输入，而不是单个输入</strong>。如果我们的网络中有多个输出和验证数据，这同样适用于标签。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="3ce9" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">当我们有很多输入时，为了避免输入的错误排序，提供一个输入字典，并以key作为输入的名称可能会有所帮助。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="3a3c" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">同样的方法，我们可以实现这个模型的多个输出:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es md"><img src="../Images/d8b0bc492a6a3ab1722128fb72081fde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4mqARaM0pc0ZWqAYpwBQQ.jpeg"/></div></div><figcaption class="ly lz et er es ma mb bd b be z dx translated">具有两个输入和两个输出的宽深度神经网络</figcaption></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="5a63" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">每个输出都需要自己的损失函数。这就是为什么当我们编译模型时，会传递一个损失列表。提供一个<code class="du lr ls lt lu b">loss_weights</code>列表给一个输出一个更大的权重也是有帮助的。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="83b8" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">如前所述，对于训练，我们需要为每个输出提供标签。这完全取决于模型的构建任务。</p><p id="b918" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">在模型评估期间，Keras返回总损失以及所有其他产出损失。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="1fbd" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">模型的<code class="du lr ls lt lu b">predict()</code>方法也返回不同输出层的输出。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><h1 id="5fed" class="ji jj hh bd jk jl jm jn jo jp jq jr js in jt io ju iq jv ir jw it jx iu jy jz bi translated">使用子类化API构建动态模型</h1><p id="d37e" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">在某些情况下，模型可能涉及循环、变化的形状、条件分支和其他动态结构。Keras子类化API正是为了这个目的，为此我们需要:</p><ul class=""><li id="1886" class="ld le hh kc b kd ky kg kz kj lf kn lg kr lh kv li lj lk ll bi translated">子类<code class="du lr ls lt lu b">keras.Model</code>类。</li><li id="a259" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">在构造函数中创建层。</li><li id="7869" class="ld le hh kc b kd lm kg ln kj lo kn lp kr lq kv li lj lk ll bi translated">用<code class="du lr ls lt lu b">call()</code>方法计算这些层。</li></ul><p id="26a0" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">让我们使用子类化API构建同样的<em class="mc">宽和深</em>模型</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="396e" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">虽然这有Keras不能检查它的缺点。所以我们不能保存或克隆模型，<code class="du lr ls lt lu b">summary()</code>方法也只返回一个层列表。此外，Keras不能提前检查类型和形状。</p><p id="b76e" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">而且很容易出错，所以除非你真的需要这种灵活性，否则尽量避免。</p><p id="d66b" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated"><strong class="kc hi"> <em class="mc">不断学习。</em>T15】</strong></p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h1 id="d3da" class="ji jj hh bd jk jl ml jn jo jp mm jr js in mn io ju iq mo ir jw it mp iu jy jz bi translated">我是谁？</h1><p id="ade3" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">我是阿努拉格·达泽。对机器学习充满热情的终身学习者。</p><p id="f87a" class="pw-post-body-paragraph ka kb hh kc b kd ky ii kf kg kz il ki kj la kl km kn lb kp kq kr lc kt ku kv ha bi translated">来自anuragdhadse.com的广播<a class="ae mq" href="http://anuragdhadse.com/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>