<html>
<head>
<title>Beginner’s guide to Abstract Base Class in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python抽象基类入门指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/beginners-guide-to-abstract-base-class-in-python-d256e535016f?source=collection_archive---------11-----------------------#2021-03-24">https://medium.com/analytics-vidhya/beginners-guide-to-abstract-base-class-in-python-d256e535016f?source=collection_archive---------11-----------------------#2021-03-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/20c4ea39287ed0e1e1e29e0a00066f24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yEuDdYaF8jq8Ncjc.png"/></div></div></figure><h1 id="c2e4" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="39cd" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在本文中，您将了解Python中抽象基类的好处，以及如何在Python的内置<code class="du kl km kn ko b">abc</code>模块中使用它们</p><h1 id="5d0b" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">什么是抽象基类？</h1><p id="8b69" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">简而言之，抽象基类为其他类提供了蓝图。抽象基类不包含实现。相反，它们提供一个接口并确保派生类被正确实现。</p><h1 id="37a2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">为什么我们需要抽象基类？</h1><p id="9832" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">想象你正在创建一个游戏，在这个游戏中你有不同的动物。为了定义动物，你可以有一个叫做<code class="du kl km kn ko b">Animal</code>的基类。狗/猫/鸭都是从基类<code class="du kl km kn ko b">Animal</code>派生出来的类。</p><h1 id="945e" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">动物基础类</h1><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="1974" class="kx iq hh ko b fi ky kz l la lb">class Animal:<br/>    def get_age():<br/>        ## return age of the animal<br/>    <br/>    def is_dead():<br/>        ## return the colour of the animal</span></pre><ul class=""><li id="7ad6" class="lc ld hh jp b jq le ju lf jy lg kc lh kg li kk lj lk ll lm bi translated">每种动物都有这两种方法。因此，每当我们从<code class="du kl km kn ko b">Animal</code>类继承一个动物(狗/猫等)类时，我们希望每个动物都实现这些方法。我们不能让动物不支持这些方法。[第一条规则]</li><li id="7137" class="lc ld hh jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">每当我们看到一种动物，我们就叫它狗/猫/鸭/老虎。这些都是各种<strong class="jp hi">动物</strong>。也就是说，你永远不会看着紫色毛茸茸的东西说“那是一种动物，没有更具体的方式来定义它”。关键是，你永远看不到一种动物四处走动，它不是更具体的其他东西(鸭子、猪等)。)[第二条规则]</li></ul><h1 id="a32a" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">规则</h1><p id="ffad" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">通过使用这两条规则，我们可以使我们的代码更易维护，对程序员更友好</p><h1 id="55df" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">规则1</h1><p id="fc63" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">从特定基类继承的子类必须实现抽象基类中定义的所有方法和属性。</p><h1 id="4688" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">规则2</h1><p id="4201" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">抽象基类不能被实例化。它们由其他子类继承。</p><h1 id="8cec" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">用Python实现</h1><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="45c1" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">让我们试着用Python实现这些动物类，使用我们讨论过的规则。</p><p id="0f3f" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">在上面的程序中，我们创建了一个从<code class="du kl km kn ko b">Animal</code>类继承所有方法的<code class="du kl km kn ko b">Dog</code>类。让我们看看规则1是否被遵守。概括一下:</p><p id="5321" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><strong class="jp hi">规则1:从特定基类继承的子类必须实现抽象基类中定义的所有方法和属性。</strong></p><p id="e550" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">让我们创建一个<code class="du kl km kn ko b">Dog</code>类的对象</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="eff4" class="kx iq hh ko b fi ky kz l la lb">bulldog = Dog()<br/><br/>bulldog.get_age() # 5 years<br/><br/>bulldog.is_dead() # NotImplementedError</span></pre><p id="6d76" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">子类<code class="du kl km kn ko b">Dog</code>没有实现基类<code class="du kl km kn ko b">Animal</code>的<code class="du kl km kn ko b">is_dead</code>方法，当我们试图从bulldog对象调用这个方法时，我们得到一个异常。所以这和预期的一样。<strong class="jp hi">但是如果我们不调用这个方法，甚至没有违反这个规则的警告，我们可以成功地运行程序</strong>。理想情况下，基类的所有方法都应该由子类实现。</p><p id="4575" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><strong class="jp hi">以上程序不遵循规则1。</strong></p><p id="072a" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><strong class="jp hi">规则2:抽象基类不能实例化。它们由其他子类继承。让我们检查是否遵循了规则2。</strong></p><p id="efb2" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">让我们试着实例化基类。</p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="3573" class="kx iq hh ko b fi ky kz l la lb">animal = Animal()<br/>animal.get_age() # NotImplementedError</span></pre><p id="c0e6" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">如果我们试图调用基类的方法，就会得到错误。但是，我们可以实例化基类。<strong class="jp hi">所以，上面的程序不遵循规则2 </strong></p><h1 id="dc44" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated"><code class="du kl km kn ko b">abc</code>救援模块</h1><p id="0420" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">有了Python的<code class="du kl km kn ko b">abc</code>模块，我们可以做得更好，并确保两个规则都得到遵守。让我们更新上面的程序</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="ls lt l"/></div></figure><p id="0a97" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">在上面的程序中，我们从模块<code class="du kl km kn ko b">abc</code>中导入了助手类<code class="du kl km kn ko b">ABC</code>，通过它我们实现了基类。此外，我们对基类中的所有方法都使用了装饰器<code class="du kl km kn ko b">@abstractmethod</code>。</p><p id="9e08" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">让我们试着实例化我们的子类:<code class="du kl km kn ko b">Dog</code></p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="a000" class="kx iq hh ko b fi ky kz l la lb">bulldog = Dog()</span><span id="8394" class="kx iq hh ko b fi lx kz l la lb">TypeError: Can't instantiate abstract class Dog with abstract methods is_dead</span></pre><p id="376d" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">这一次我们得到一个<code class="du kl km kn ko b">TypeError</code>,指定抽象方法没有被实现。</p><p id="2945" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><strong class="jp hi">这成功地遵循了规则1。</strong></p><p id="1399" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">让我们试着实例化我们的基类:<code class="du kl km kn ko b">Animal</code></p><pre class="kp kq kr ks fd kt ko ku kv aw kw bi"><span id="af3d" class="kx iq hh ko b fi ky kz l la lb">animal = Animal()</span><span id="fb3a" class="kx iq hh ko b fi lx kz l la lb">TypeError: Can't instantiate abstract class Animal with abstract methods get_age, is_dead</span></pre><p id="ee74" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated">这一次我们得到了一个<code class="du kl km kn ko b">TypeError</code>,指定抽象类不能被实例化。</p><p id="4586" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><strong class="jp hi">这成功地遵循了规则2。</strong></p><h1 id="619d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="a344" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在您的代码中使用ABC将使您的类层次结构更健壮，更易于维护。本文中的一些要点是:</p><ul class=""><li id="9e41" class="lc ld hh jp b jq le ju lf jy lg kc lh kg li kk lj lk ll lm bi translated">抽象e类(ABCs)确保派生类在实例化时实现基类的特定方法。</li><li id="04e7" class="lc ld hh jp b jq ln ju lo jy lp kc lq kg lr kk lj lk ll lm bi translated">使用ABC有助于编写易于阅读和维护的无错误的类层次结构。</li></ul></div><div class="ab cl ly lz go ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ha hb hc hd he"><p id="c7cf" class="pw-post-body-paragraph jn jo hh jp b jq le js jt ju lf jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ha bi translated"><em class="mf">原载于2021年3月24日https://dollardhingra.com</em><em class="mf">的</em> <a class="ae mg" href="https://dollardhingra.com/blog/python-abstract-base-class/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">。</em></a></p></div></div>    
</body>
</html>