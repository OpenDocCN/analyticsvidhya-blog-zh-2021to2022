<html>
<head>
<title>Ensemble Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">集成方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ensemble-methods-a25b6ebaaa12?source=collection_archive---------0-----------------------#2021-11-02">https://medium.com/analytics-vidhya/ensemble-methods-a25b6ebaaa12?source=collection_archive---------0-----------------------#2021-11-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/fa0c9db4ec10ce6e0f47d984d62b90ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQ00qmunwKuyp3areQ9gBA.png"/></div></div></figure><p id="7edc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">集成方法是一种机器学习技术，它将多个基本模型组合成一个最佳预测模型。集成技术是用于获得更好结果的多模型方法。在大多数情况下，集合技术比单一模型产生更准确的结果。在许多机器学习竞赛中，获胜的解决方案使用了集成方法。网飞大众竞赛的获胜者采用集成方法创建了一个强大的协同过滤系统。</p><p id="9910" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们主要利用决策树来概述集合方法的定义和实用性。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es jn"><img src="../Images/edd36ef709a3b21d07c1271529d01206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*DFvptGnHZgvFd-rttwM8GQ.png"/></div></figure><p id="2d75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">决策树基于一系列问题和条件来确定预测值。例如，这个简单的决策树决定了一个人是否应该出去玩。该树考虑了几个天气因素，并给每个因素做出决定或提出另一个问题。在这个例子里，每次阴天的时候，我们都会在外面玩。但是，如果下雨了，一定要问有没有风？如果刮风，我们就不玩了。但是如果没有风，把鞋带系紧，因为我们要出去玩。</p><p id="b40e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">决策树也可以用同样的格式解决定量问题。在左边的树中，我们想知道是否投资商业房地产。是写字楼吗？一个仓库？一栋公寓楼？经济条件好？经济条件差？一项投资会有多少回报？这些问题都是用这个决策树来回答和解决的。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es js"><img src="../Images/4c71f448ea070599f0f1d635c248e250.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B-XXPhQlAvDM2AfMPoaXZw.png"/></div></div></figure><p id="624f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当制作决策树时，有几个因素我们必须考虑:我们根据什么特征做决策？将每个问题分类为是或否答案的阈值是什么？在第一个决策树中，如果我们想问自己是否有朋友一起玩呢？如果我们有朋友，我们每次都会玩。如果不是，我们可能会继续问自己关于天气的问题。通过添加一个额外的问题，我们希望更好地定义是和否类。</p><p id="6114" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这就是集合方法派上用场的地方！集成方法允许我们考虑决策树的样本，计算在每次分裂时要使用的特征或要问的问题，并基于样本决策树的聚合结果做出最终预测，而不是仅仅依赖于一个决策树并希望我们在每次分裂时做出正确的决策。</p><p id="2bc7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">简单的合奏技巧:</strong></p><p id="621b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">主要有三种集成技术。</p><p id="44fa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)最大投票</p><p id="3fe8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)平均</p><p id="e431" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)加权平均</p><p id="d41a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 1) </strong> <strong class="ir hi"> Max投票:- </strong></p><p id="7200" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最大投票法一般用于分类问题。</p><p id="5f4d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种技术中，使用多个模型来预测每个数据点。</p><p id="26b9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个模型的预测被认为是一次“投票”。我们从大多数模型中得到的预测被用作最终预测。</p><p id="3984" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，当你让你的5位同事给你的电影打分时(满分5分)；我们假设其中三人给它打了4分，而两人给了5分。由于大多数人给了4分，所以最终的评分将为4分。你可以认为这是所有预测的模式。</p><p id="15e3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最大值投票的结果将是这样的:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/75f4fc358819d2a351df3ae214ebef9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wb9SP3y4ub6K00C0MXdiwQ.png"/></div></div></figure><p id="c30e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2) </strong> <strong class="ir hi">平均:- </strong></p><p id="d204" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在平均中，对平均中的每个数据点进行多次预测。</p><p id="f8b3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种方法中，我们取所有模型预测的平均值，并用它来进行最终预测。</p><p id="5c21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">平均可用于回归问题中的预测或计算分类问题的概率。</p><p id="db12" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，在下面的情况中，平均方法将取所有值的平均值。</p><p id="4daa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">即(5+4+5+4+4)/5 = 4.4</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/e6566696e3c1cbb72a84ea0732bc558f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RNfog7q0xgOT3EIIZK2Vvw.png"/></div></div></figure><p id="a6c6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3) </strong> <strong class="ir hi">加权平均:- </strong></p><p id="4e52" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是平均法的延伸。</p><p id="532f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有模型被赋予不同的权重，定义每个模型对于预测的重要性。</p><p id="4eb6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">例如，如果你的两个同事是批评家，而其他人没有这方面的经验，那么这两个朋友的回答比其他人更重要。</p><p id="1dd9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">结果计算为[(5 * 0.23)+(4 * 0.23)+(5 * 0.18)+(4 * 0.18)+(4 * 0.18)]= 4.41。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/5a0b9277bec2417520bcf89c3193a00f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sCH9IDDsbSwZzW3fDqTTzw.png"/></div></div></figure><p id="b027" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">高级合奏技术:</strong></p><p id="6fbc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 1) </strong> <strong class="ir hi">堆叠:- </strong></p><p id="8ed3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">堆叠是一种集成学习技术，它使用来自多个模型(例如决策树、KNN或SVM)的预测来构建新模型。该模型用于对测试集进行预测。</p><p id="4936" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是简单堆叠系综的分步解释:</p><ol class=""><li id="0e04" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated">列车组分为10个部分。</li></ol><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kd"><img src="../Images/a08170cac03b7253374e74dbf38d54cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*EWF9J6Z85pErEDZPbwzrNA.png"/></div></div></figure><p id="fd1d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)基础模型(假设决策树)适合9个部分，并对第10部分进行预测。对列车组的每个部分都要这样做。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es ke"><img src="../Images/9a2f27ef13adf2bb5fff637d1880ed94.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*EAXHkOgbPlQGXqG1v5WQ5Q.png"/></div></figure><p id="5475" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)然后，基础模型(在这种情况下，决策树)适合整个训练数据集。</p><p id="95fc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)使用该模型，对测试集进行预测。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kf"><img src="../Images/413e235dc9b610188abf55bf814e0ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:468/format:webp/1*s07CH-sCE-EdKh8QALb4Vg.png"/></div></figure><p id="5b51" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5)对另一个基本模型(比如KNN)重复步骤2到4，得到训练集和测试集的另一组预测。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kg"><img src="../Images/b39532e2ac83409fbeac80839342ad0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*KwC3y1Z-BqiIdn10lRkz2w.png"/></div></figure><p id="a8c1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">6)来自训练集的预测被用作建立新模型的特征。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kh"><img src="../Images/8cf853ab27829043ca14eca006649620.png" data-original-src="https://miro.medium.com/v2/resize:fit:284/format:webp/1*xTyjJCcknCZZ1BAEGJ4mcg.png"/></div></figure><p id="9ec1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">7)该模型用于对测试预测集进行最终预测。</p><p id="8a84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 2) </strong> <strong class="ir hi">混合:- </strong></p><p id="f6a6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">混合遵循与堆叠相同的方法，但仅使用训练集中的维持(验证)集来进行预测。</p><p id="28f8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">换句话说，与堆栈不同，预测仅针对维持集进行。</p><p id="8243" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">维持集和预测用于构建在测试集上运行的模型。以下是混合过程的详细说明:</p><ol class=""><li id="2882" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated">训练集被分成训练集和验证集。</li></ol><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es ki"><img src="../Images/0e3ba78111c6ad9ac033373af3868ed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:604/format:webp/1*xGiW-eJOgmJE4BKo0ElPqg.png"/></div></figure><p id="c548" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)在训练集上拟合模型。</p><p id="4fb1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)在验证集和测试集上进行预测。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kj"><img src="../Images/535ecfd6a33a81b23ba8680cd7faf410.png" data-original-src="https://miro.medium.com/v2/resize:fit:672/format:webp/1*Np7BM2cRDW9v0ufu7jnLbw.png"/></div></figure><p id="0b20" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)验证集及其预测被用作建立新模型的特征。</p><p id="9f87" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5)该模型用于对测试和元特征进行最终预测。</p><p id="8089" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 3) </strong> <strong class="ir hi">装袋:- </strong></p><p id="160c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Bagging是一种合并各种模型(例如，所有决策树)的输出以产生更通用的输出的技术。我有一个问题:在同一组数据上开发所有模型并整合它们会有用吗？给定相同的输入，这些模型很可能会产生相同的结果。</p><p id="9ac6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Bootstrapping是一种采样技术，在这种技术中，我们通过替换从原始数据集创建观察值子集。子集的大小与原始集的大小相同。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kk"><img src="../Images/f5c2dd2946e58a75fcc024a432ee9f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*Wj8ur94WXrIuldJ9DRTwcQ.png"/></div></figure><p id="2243" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">bagging(或Bootstrap Aggregating)技术使用这些子集(包)来获得分布的公平概念(完整集)。为打包创建的子集的大小可能小于原始集。</p><p id="b86d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)从原始数据集创建多个子集，选择具有替换的观察值。</p><p id="b1bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)在这些子集的每一个上创建基础模型(弱模型)。</p><p id="497f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)模型并行运行，相互独立。</p><p id="5cc4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)通过组合来自所有模型的预测来确定最终预测。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kl"><img src="../Images/f297039cbba0a77d56aeb2ffcc8e7a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*dESjHHL0FtF9VkxTxjK_zQ.png"/></div></figure><p id="6595" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> 4) </strong> <strong class="ir hi">助推:- </strong></p><p id="3856" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们继续之前，我想问你一个问题:如果第一个模型错误地预测了一个数据点，合并第一个模型和下一个模型(可能是所有模型)的预测会产生更好的结果吗？升压就是用来处理这类问题的。</p><p id="187f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">升压是一个连续的过程，其中每个后续模型都试图纠正前一个模型的错误。后续模型依赖于前一个模型。让我们在下面的步骤中了解升压的工作方式。</p><p id="0d46" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)从原始数据集创建子集。</p><p id="649b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)最初，所有数据点被赋予相等的权重。</p><p id="ab79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)在该子集上创建基础模型。</p><p id="f729" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)该模型用于对整个数据集进行预测</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es km"><img src="../Images/bab15fd13feffa3d951aef6ccd7fc52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*y1HwCgzn6TWFHhn49dBt5w.png"/></div></figure><p id="dd22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5)使用实际值和预测值计算误差。</p><p id="f519" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">6)不正确预测的观察值被给予较高的权重。</p><p id="3129" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(这里，三个错误分类的蓝色加分将被赋予更高的权重)</p><p id="32a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">7)创建另一个模型，并对数据集进行预测。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kn"><img src="../Images/0f18c6c221f17ad2f79638f26f5e9dde.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*8bRaqqQ1GsI907CGafhQLw.png"/></div></figure><p id="6837" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(这个模型试图纠正前一个模型的错误)</p><p id="acba" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">8)类似地，创建多个模型，每个模型校正前一个模型的误差。</p><p id="57cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">9)最终模型(强学习者)是所有模型(弱学习者)的加权平均值。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es ko"><img src="../Images/f192a6d3e42eb91c658d1d1e00c75934.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/format:webp/1*Q-xxivRn1WXLGF6ulAO7Pg.png"/></div></figure><p id="405c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，增强算法将多个弱学习器结合起来形成一个强学习器。单个模型在整个数据集上表现不佳，但在数据集的某些部分表现良好。因此，每个模型实际上都提高了整体的性能。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kp"><img src="../Images/680018e9ece198ed1148a299db8644d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:444/format:webp/1*vCiwX1KH60YmztQoPApsYw.png"/></div></figure><p id="d639" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">解释至少两种不同的类型，以及何时应用它们。</p><p id="7dc8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">解决方案:</strong></p><p id="986a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">基于Bagging和Boosting的算法:Bagging和Boosting是两种最常见的集成学习策略。对于每一种策略，下面是一些最常用的算法。在不久的将来，我将为这些算法中的每一个制作单独的条目。</p><p id="a351" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">装袋算法:</strong></p><p id="3713" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随机森林</p><p id="bcdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Bagging元估计量</p><p id="7013" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">升压算法:</strong></p><p id="91d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">adaboost算法</p><p id="c85c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">梯度推进机</p><p id="4ca1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">XGBoost</p><p id="262a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">轻型GBM</p><p id="21e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">CatBoost</p><p id="f314" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">随机森林:</strong></p><p id="9dad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一种使用bagging技术的集成机器学习算法是随机森林。</p><p id="cfbb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它是bagging估计算法的扩展。</p><p id="c6bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">随机森林使用决策树作为它的基本估计器。</p><p id="63c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与bagging元估计器不同，随机森林随机选择一组特征来确定决策树每个节点的最佳分割。</p><p id="9fdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总而言之，随机森林随机选择数据点和特征，并构建多棵树(森林)。</p><p id="6f8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> AdaBoost: </strong></p><p id="e5c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AdaBoost或自适应增强是最基本的增强算法之一。</p><p id="67a9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">建模通常用决策树来完成。</p><p id="73e2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">构建了多个序列模型，每个模型都纠正了前一个模型的缺陷。</p><p id="1a52" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AdaBoost将权重添加到预测不佳的观察值中，以下模型尝试准确预测这些值。</p><p id="cba3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">AdaBoost的运行示例:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kq"><img src="../Images/0b0a21e2bf87321cbc01cefae4ebd4e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1232/format:webp/1*Yt-r4HGRJ4ykhjb88GKX_Q.png"/></div></figure><p id="8e18" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> XGBoost: </strong></p><p id="6c6a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">极端梯度增强(XGBoost)是梯度增强方法的更高级版本。</p><p id="37fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">XGBoost已被证明是一种强大的机器学习算法，已被广泛用于竞赛和黑客马拉松。</p><p id="8c8e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">XGBoost比其他梯度增强方法快大约10倍，并且具有良好的预测潜力。</p><p id="f10e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它还包括各种正则化，减少过度拟合，提高整体性能。因此，它也被称为“正则化提升技术”。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/5ae8ba8335e5cb17b96085b626bbe2f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZJr6Kybbu0BH-VLotEpO5w.png"/></div></div></figure><p id="cd49" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">轻型GBM: </strong></p><p id="8f4e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们进入Light GBM是如何工作的之前，让我们先来看看为什么在有这么多其他的(就像我们上面看到的那些)的时候，我们首先需要它。</p><p id="966e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当数据集非常大时，轻量级GBM优于所有其他技术。</p><p id="844b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">与其他算法相比，轻量级GBM在大型数据集上运行所需的时间更少。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jt"><img src="../Images/4e94773d3e9b5e20fbc02c1b2a849ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2dRfqaOSIyky-TZbtALQA.png"/></div></div></figure><p id="50c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">LightGBM是一个梯度推进框架，它采用基于树的算法并使用基于叶的方法，而其他技术使用基于层的方法。</p><p id="b0e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面的图表可以帮助你更好地理解不同之处。</p><p id="0ea5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">装袋和增压有一些相似之处:</strong></p><p id="7d57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1.这两种策略都是用于从单个学习者生成N个学习者的集成方法。</p><p id="e67d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.两者都使用随机抽样来生成许多训练数据集。</p><p id="9a1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3.通过平均N个学习者，两者都得到最终选择(或者取他们中的大多数，即多数投票)。</p><p id="029e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">两者都可以有效地降低方差和增加稳定性。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ks"><img src="../Images/9f43411ab552db078d5da94ced99f84c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CzGLz7FGnLKFBnbtI35P_Q.png"/></div></div></figure><p id="1e75" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">何时使用装袋增压:</strong></p><p id="6a96" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Bagging是一种通过从数据集产生用于训练的附加数据来减少预测方差的技术，该数据集通过将重复与组合相结合来创建多组原始数据。</p><p id="084f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">提升是一种迭代策略，用于根据之前的分类调整观察的权重。</p><p id="f2af" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果观察值被错误地分类，Boosting试图增加观察值的权重。</p><p id="522f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">总体而言，助推创造了良好的预测模型。</p><p id="f9bf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">结论:</strong>集合建模可以极大地提高你的模型的性能，甚至可以成为第一名和第二名的区别！</p></div></div>    
</body>
</html>