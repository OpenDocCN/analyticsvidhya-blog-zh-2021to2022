<html>
<head>
<title>Creating a multiplayer speed typing game using Flask, SocketIO and Celery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建一个多人快速打字游戏使用烧瓶，SocketIO和芹菜</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-multiplayer-speed-typing-game-using-flask-socketio-and-celery-a3269a8f3e99?source=collection_archive---------6-----------------------#2021-03-02">https://medium.com/analytics-vidhya/creating-a-multiplayer-speed-typing-game-using-flask-socketio-and-celery-a3269a8f3e99?source=collection_archive---------6-----------------------#2021-03-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7d0f78d8def7220d531c6d8a71a0916e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MNVLpt1QKejE86drTiIGYA.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">类型战斗比赛</figcaption></figure><p id="0839" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">最近我一直在玩多种快速打字游戏，但我对它们的通用性感到沮丧，在游戏开始时，你等待其他玩家加入并显示文本，当游戏开始时，你尽可能快地打字，当你完成时，你可以看到自己与其他人相比的情况。虽然尝试获得第一名很有趣，但没有真正的理由在线玩，没有策略，也没有玩家互动，最快的人总是会赢。</p><p id="9e86" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">六个月前，<a class="ae jr" href="https://typefight.me/" rel="noopener ugc nofollow" target="_blank"> typefight </a>的想法出现在我的脑海中，从那以后我一直致力于它，一路上犯了很多错误，最终形成了我现在的设置。在这篇文章中，我想展示一下typefight是如何构建的。我希望它能帮助任何想用python创作在线游戏的人。</p><h2 id="f7bd" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">关于typefight</h2><p id="f8f0" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated"><a class="ae jr" href="https://typefight.me/" rel="noopener ugc nofollow" target="_blank"> typefight </a>是一款竞技速度打字游戏，与大多数打字游戏不同，玩家可以相互互动，并可以选择不同的打字顺序，从而通过不同的策略获得独特的游戏体验。<br/> typefight的灵感来自俄罗斯方块99，以及高速打字游戏，如<br/><a class="ae jr" href="https://zty.pe/" rel="noopener ugc nofollow" target="_blank"/>和<a class="ae jr" href="https://play.typeracer.com/" rel="noopener ugc nofollow" target="_blank"> typeracer </a>。</p><h2 id="2f4e" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">怎么玩</h2><figure class="kt ku kv kw fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/452f30710846b08abacb13843da1516a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*KegmLMWk8fBvQIBy1hdE4g.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">播放器视图的一部分</figcaption></figure><p id="30ab" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">每个玩家视图分为3个部分，攻击词，防御格子和<br/>精确栏。为了赢得游戏，对方玩家的网格必须接触到精度栏，其大小根据玩家在过去100次击键中犯了多少错误来设置。防御网格将随着时间的推移而增长，新词要么来自游戏推进机制，要么来自对手的攻击。<br/>玩家可以随时选择输入哪个单词(在防御格子中，该单词上面不能有其他单词)，一旦输入第一个字符，玩家就不能切换到另一个单词。</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><h2 id="300a" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">游戏循环</h2><p id="f82b" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">每个游戏的核心应该是游戏循环，它处理输入，推进游戏，然后呈现变化。使用游戏循环可以更容易地推进游戏和渲染玩家数据。这是我构建的游戏循环:</p><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="le lf l"/></div></figure><p id="19ab" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">由于每场比赛都应该有不同的游戏循环，所以需要使用某种并发性，因为在python中不能并行运行多个线程，所以我选择使用带有R <a class="ae jr" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank"> edis </a>的<a class="ae jr" href="https://docs.celeryproject.org/en/stable/getting-started/introduction.html" rel="noopener ugc nofollow" target="_blank"> Celery </a>作为消息代理，这使得能够在不同的进程中创建游戏循环并与服务器通信。</p><h2 id="b408" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">玩家与SocketIO通信</h2><p id="d706" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">Flask-SocketIO用于服务器和玩家之间的通信。当玩家想要开始一个游戏时，前端代码将他们连接到SocketIO服务器，并保存他们的会话id，该id将用于发送输入。一旦与另一个玩家匹配，两个玩家都被放在一个有特定匹配id的插槽中，这使得向两个玩家呈现数据变得更加容易。</p><p id="b66b" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">现在我们有了通信过程的全貌，玩家开始<br/>输入字母“a ”,浏览器使用SocketIO发送它，它到达服务器<br/>,服务器在redis中发布数据，然后游戏循环获得数据并推进游戏。当服务器想要向播放器呈现改变时，它发布redis消息，服务器拾取该消息并使用SocketIO将其发送给负责呈现该消息的播放器浏览器。</p><h2 id="dd42" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">前端</h2><p id="3358" class="pw-post-body-paragraph it iu hh iv b iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm kr jo jp jq ha bi translated">网站本身非常简单，它使用MVP设计模式，用Typescript编写<br/>，Gulp用来编译和捆绑代码到一个JavaScript <br/>文件中。游戏渲染是使用PixiJS创建引擎完成的，它允许我轻松地创建视图和动画。</p><p id="8722" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我在编写前端时遇到的一个主要问题是服务器引发的ping，这是63毫秒，就游戏循环而言，这意味着当用户向服务器发送输入时，循环将在获取之前运行两次，此外，糟糕的或远距离的连接将使游戏无法播放。这个问题通过向前端添加一些服务器逻辑来预测接下来应该发生什么来解决，例如，保存可以键入的单词，以便客户端代码可以知道用户输入是否是错误的。</p></div><div class="ab cl kx ky go kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ha hb hc hd he"><h2 id="b0e2" class="js jt hh bd ju jv jw jx jy jz ka kb kc je kd ke kf ji kg kh ki jm kj kk kl km bi translated">一个有用，一个没用</h2><figure class="kt ku kv kw fd ii"><div class="bz dy l di"><div class="lg lf l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">使用Tkinter的typefight的早期版本</figcaption></figure><p id="cb28" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">我犯的最大最耗时的错误是没有从一开始就使用游戏循环，这导致我两次对游戏代码设计进行了重大修改。一旦我实现了游戏循环，代码变得更加精简，实现机器人、玩家之间的交互和渲染玩家数据变得更加容易。</p><p id="2032" class="pw-post-body-paragraph it iu hh iv b iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ha bi translated">对我帮助很大的一件事是，从开发的早期阶段就开始关注产品，记录所有可能出错的地方，或者某个库推荐什么时候出错。除了在大部分游戏逻辑完成时设置生产服务器，这有助于更早地发现问题。</p></div></div>    
</body>
</html>