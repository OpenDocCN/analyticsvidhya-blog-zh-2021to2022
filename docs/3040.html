<html>
<head>
<title>Mask and Distancing Detector using transfer learning: Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用迁移学习的屏蔽和距离检测器:第2部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mask-and-distancing-detector-part-2-66401065bae5?source=collection_archive---------17-----------------------#2021-05-30">https://medium.com/analytics-vidhya/mask-and-distancing-detector-part-2-66401065bae5?source=collection_archive---------17-----------------------#2021-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ed0cee9b52a3d25973c93cdd7273c3fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zLOv-ztU3nLWoULb.jpg"/></div></div></figure><p id="f6de" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在上一篇文章中我们完成了我们的人脸和距离检测器，如果你还没有看过这篇文章，你可以从这里<a class="ae jn" href="https://anmolcrazy2.medium.com/mask-detection-and-social-distancing-detector-part-1-b6ed4a3a4274" rel="noopener"><strong class="ir hi"/></a><strong class="ir hi">。</strong>我会在本文结尾写完整的代码</p><p id="27ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在完成我们的掩膜检测器之前，我们需要了解一些重要的主题，以及我们将在掩膜检测器中使用哪些主题。</p><p id="2c81" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">我们在图像检测时面临的一些问题是</strong></p><ol class=""><li id="8e5a" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">缺少可用于模型训练的数据</li><li id="97fd" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">从零开始训练模型或不训练模型，以便我们用标记的数据进行分类。</li></ol><blockquote class="kc kd ke"><p id="f035" class="ip iq kf ir b is it iu iv iw ix iy iz kg jb jc jd kh jf jg jh ki jj jk jl jm ha bi translated">对于问题1，我们有数据扩充，对于第二个问题，我们使用迁移学习。</p></blockquote><h1 id="434b" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">数据扩充</h1><p id="ff65" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">我们认识到图像分类需要大量的数据，获取蒙面人的照片是一项繁琐的任务，所以首先我们必须重新生成大量的数据。在蒙版数据上实现它之前，让我在一些随机的照片上尝试一下，并尝试大量地重新生成照片。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="6950" class="lv kk hh lr b fi lw lx l ly lz">from keras.layers import Flatten, Dense<br/>from keras.preprocessing.image import ImageDataGenerator, load_img, img_to_array</span></pre><p id="4f57" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用Keras API进行数据重建或扩充，并使用我的一张简单图片。ImageDataGenerator函数用于从一张照片生成多张照片。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="39cb" class="lv kk hh lr b fi lw lx l ly lz">datagen=ImageDataGenerator(rotation_range=40, <br/>                           width_shift_range=0.2,<br/>                           height_shift_range=0.2,<br/>                           zca_whitening=False, zca_epsilon=1e-06,<br/>                           shear_range=0.4,<br/>                           zoom_range=0.6,<br/>                           horizontal_flip=True,<br/>                           fill_mode="nearest")</span></pre><p id="378d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们需要指定需要重新生成的照片的位置。我们将运行一个for循环，该循环将在生成20张照片后中断。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="45fa" class="lv kk hh lr b fi lw lx l ly lz">img=load_img('image/IMG_20190710_085629.jpg')<br/>x=img_to_array(img)<br/>x=x.reshape((1,)+ x.shape)</span><span id="6a48" class="lv kk hh lr b fi ma lx l ly lz">i=0<br/>for batch in datagen.flow(x, batch_size=1, save_to_dir='vac_hes/Gaza/generate/augment', save_prefix='anmol',save_format="jpg"):<br/>    i+=1<br/>    if i&gt;20:<br/>        break</span></pre><p id="9a91" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我想重新生成的照片是我的个人照片。我用这个来说明。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/f2d4260e570aa23293ca3e1aed2f8cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*c4LzfRwIeS2ByZOwF7m6sQ.png"/></div></figure><p id="1403" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里是扩增目录中重新生成的照片。您可以生成任意数量的照片。我已经从这张照片中生成了20张照片。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/e78eed6212696149535e0f2ce0b6b1e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va9uDtM_w6B6j0qcLWWGbg.png"/></div></div></figure><p id="c84c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在数据问题解决了，我们可以继续前进了。然而，下一个问题是从零开始，训练我们的模型，或者在类似的数据上挑选一个已经训练好的模型，在其上添加我们的分类模型，并将其用于我们的分类。对于图像分类，我们已经有超过百万张图像的标注数据，名为<strong class="ir hi"> ImageNet </strong>，型号为<strong class="ir hi"> VGG19 </strong>。</p><h1 id="3187" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">迁移学习</h1><p id="6b0d" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">这个使用已经训练好的模型来解决另一个类似问题的过程叫做迁移学习。例如，被训练用于对不同对象(如狗、猫、马、鞋等)的图像进行分类的模型可以用于检测人脸面具。</p><p id="b6a3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">迁移学习的过程可以比作人脑。一个已经知道如何骑自行车和自行车的人会发现驾驶汽车比一个一生中从未驾驶过汽车的人更容易。</p><p id="f9f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">工作流程如下</strong></p><ol class=""><li id="a8c7" class="jo jp hh ir b is it iw ix ja jq je jr ji js jm jt ju jv jw bi translated">从先前训练的模型中提取图层。</li><li id="a75c" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">冻结它们，以避免在未来的训练中破坏它们所包含的任何信息。</li><li id="0b90" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">在冻结层上添加一些新的可训练层。他们将学习将旧要素转化为新数据集的预测。</li><li id="91f7" class="jo jp hh ir b is jx iw jy ja jz je ka ji kb jm jt ju jv jw bi translated">在数据集上训练新图层。</li></ol><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="000c" class="lv kk hh lr b fi lw lx l ly lz">vgg19 = VGG19(weights='imagenet',include_top=False,input_shape=(128,128,3))<br/><br/>for layer <strong class="lr hi">in</strong> vgg19.layers:<br/>    layer.trainable = False<br/>    <br/>model = Sequential()<br/>model.add(vgg19)<br/>model.add(Flatten())<br/>model.add(Dense(2,activation='sigmoid'))<br/>model.summary()</span></pre><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="er es md"><img src="../Images/f2decdebf6f54dd2e5bdf5ce672d411e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*Jd8CXlg7I19dpRx-cx6-fA.png"/></div></figure><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="4936" class="lv kk hh lr b fi lw lx l ly lz">include_top=false:</span></pre><p id="59e4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您使用了预训练的VGG19模型，但没有使用最后一个输出层，而是使用了您自己的输出层。我们将指定输入大小。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="5c50" class="lv kk hh lr b fi lw lx l ly lz">layer.trainable = False</span></pre><p id="8bb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们冻结了所有层的重量。因此，现在不会为预训练模型的所有层更新权重。</p><pre class="lm ln lo lp fd lq lr ls lt aw lu bi"><span id="deba" class="lv kk hh lr b fi lw lx l ly lz">model.add(Dense(2,activation='sigmoid'))</span></pre><p id="4dcb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将在预训练模型的基础上添加我们自己的分类器。才能有我们具体分类的结果。在这里，我们指定我们想要对您的数据进行分类的类的数量。我们只想要2个类，面具或没有面具。我们将使用sigmoid函数作为我们的激活函数。</p></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h1 id="9ac0" class="kj kk hh bd kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc mp le lf lg bi translated">完整的面罩检测器代码</h1><p id="28af" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">你可以从这里 下载训练、测试、验证数据<a class="ae jn" href="https://www.kaggle.com/ashishjangra27/face-mask-12k-images-dataset" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">，从这里</strong> </a>下载屏蔽图像数据<a class="ae jn" href="https://www.kaggle.com/andrewmvd/face-mask-detection" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">。为哈尔卡斯克下载数据<a class="ae jn" href="https://www.kaggle.com/gpreda/haar-cascades-for-face-detection" rel="noopener ugc nofollow" target="_blank"> <strong class="ir hi">从这里</strong> </a></strong></a></p><figure class="lm ln lo lp fd ii"><div class="bz dy l di"><div class="mq mr l"/></div></figure><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/0ec5646dfd18e2f95f1bcd0ba4404846.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QFM3r_3_wkYdxqqPx4RlKA.png"/></div></div></figure><p id="a912" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">绿色矩形是由于距离。而红色矩形表示没有最小距离。更多的照片使用相同的代码分类。</p><figure class="lm ln lo lp fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/43ffdb64ec98b448edce1c2b8a14994a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-KccHZKbTb35Qd_sMndYQ.png"/></div></div></figure><figure class="lm ln lo lp fd ii er es paragraph-image"><div class="er es mu"><img src="../Images/172948c7c99ce7504214b02eb5d77185.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*NY_Gb5D6ZU8bH13rOyoRkQ.png"/></div></figure></div><div class="ab cl me mf go mg" role="separator"><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj mk"/><span class="mh bw bk mi mj"/></div><div class="ha hb hc hd he"><h1 id="8023" class="kj kk hh bd kl km ml ko kp kq mm ks kt ku mn kw kx ky mo la lb lc mp le lf lg bi translated">结论</h1><p id="fcc3" class="pw-post-body-paragraph ip iq hh ir b is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ll jk jl jm ha bi translated">我们已经把我们的图像分为屏蔽和非屏蔽。为此，我们使用人脸检测、图像增强、迁移学习和欧几里德距离来寻找人与人之间的距离。我们可以在我们的街道上使用这个模型来识别没有戴口罩或保持最小距离的人，并相应地对他们进行罚款。警察不必手动识别人们并敦促他们戴上面具。</p></div></div>    
</body>
</html>