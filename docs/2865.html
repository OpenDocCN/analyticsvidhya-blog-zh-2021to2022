<html>
<head>
<title>Deploy Your ML Model to an Interactive Folium Map for Spatial Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将您的ML模型部署到用于空间数据的交互式叶子地图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/deploy-your-ml-model-to-an-interactive-folium-map-for-spatial-data-5de5269b64cd?source=collection_archive---------8-----------------------#2021-05-21">https://medium.com/analytics-vidhya/deploy-your-ml-model-to-an-interactive-folium-map-for-spatial-data-5de5269b64cd?source=collection_archive---------8-----------------------#2021-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c30d64dfec55d5c9eb66310e1e5a8d80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIDoTqEX9-Ux9sXahtnfJg.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated"><a class="ae it" href="https://www.facebook.com/manish.mamtani?__cft__[0]=AZXLUXLqc1mjIdcimWp2-qVc34Hg53-ohsDkj55_dZdLbbrUpZt1-qwMIOVHhcrkGHOCWQn3kPX_hrAm3X9IL_u4dr-3fMan1qJiIAr7RD3m31RtWrHgi1RBICymeY7bhuoWJuaBGu037HCzkYwtwVEb&amp;__tn__=-UC*F" rel="noopener ugc nofollow" target="_blank">马尼什·马姆塔尼</a>，新汉普郡秋天的颜色——航拍</figcaption></figure><p id="e305" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">COVID 19会如何传播？房地产价格会是多少？发生车祸或犯罪的概率有多大？所有这些问题都与地理因素密切相关。</p><p id="fb3f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在本文中，我将展示如何使用一个<code class="du js jt ju jv b">folium</code>地图来呈现模型预测。当我们想在本地展示我们的模型预测时，这个工具就变得很方便。</p><p id="3096" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下图展示了以色列大米的过去和预测价格，这与当地的竞争和客户的经济特征密切相关。</p><figure class="jw jx jy jz fd ii"><div class="bz dy l di"><div class="ka kb l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">以色列大米月价格</figcaption></figure><p id="f6f1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这种类型的展示允许读者探索局部水平上的模型预测，并且在分析涉及地理方面的情况下它非常适合。</p><h2 id="0d68" class="kc kd hh bd ke kf kg kh ki kj kk kl km jf kn ko kp jj kq kr ks jn kt ku kv kw bi translated">语境</h2><p id="40dd" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">在这篇文章中，我展示了我们在<a class="ae it" href="https://www.iep.org.il/english/en-home" rel="noopener ugc nofollow" target="_blank">以色列经济规划研究所</a>做的一个项目。该项目的目标是构建一个工具，允许客户比较和检查他们所在地区的零售价格。</p><p id="7255" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们有牛奶和大米等几种日常食品的数据。该数据跨越24个月，涵盖了以色列大型零售公司的所有商店。</p><p id="992d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于每种产品，我们都训练了几个模型，包括Catboost、XGBoost和LSTM，以预测不同地理位置的未来零售价格。</p><p id="f7eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">令人惊讶的是，虽然RNN和决策树在时间序列和横截面分析中很常见，但关于这些算法在面板数据中的使用的文献却很少，几乎不存在。我们的数据跨越时间，涵盖不同的地理位置(商店)。在训练模型时忽略数据的这些特征可能会导致我们高估我们的模型预测能力。</p><p id="2f31" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在即将发表的一篇文章中，我将详细说明我们如何实际训练该模型，结合滚动预测交叉验证<a class="ae it" href="https://www.youtube.com/watch?v=g9iO2AwTXyI&amp;t=607s" rel="noopener ugc nofollow" target="_blank">【11】</a>和传统的训练、交叉验证和测试集分割。在本文中，我将重点介绍如何利用<code class="du js jt ju jv b">folium</code>包来呈现地理相关数据的模型预测。</p><p id="9fcf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于数据生成过程也与地理特征相关，下面的一些步骤也与特征工程相关。文章内容如下。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lc"><img src="../Images/c9cdf00d232deec1261b8d71bbb9db63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*JBSUqN7Gthx2Bn5oA-2ftA.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">地图上的商店，不同的颜色代表不同的零售公司，每个点就是一个商店。</figcaption></figure><ol class=""><li id="87cd" class="ld le hh iw b ix iy jb jc jf lf jj lg jn lh jr li lj lk ll bi translated"><strong class="iw hi">用</strong>提取坐标<code class="du js jt ju jv b"><strong class="iw hi">Google Maps API</strong></code>。该地区的顾客数量、他们的平均收入、竞争(表示为给定地区的商店数量)所有这些因素都会影响当地的零售价格。深入研究影响价格的地理和经济因素并不是本文的目的。坐标将允许我们为模型创建特征，为地图创建点。</li><li id="55a7" class="ld le hh iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hi">用</strong> <code class="du js jt ju jv b"><strong class="iw hi">Google Distance Matrix API</strong></code> <strong class="iw hi">和自由选项提取店铺之间的道路距离和持续时间。</strong>在某些情况下，我们可能希望使用物体之间的距离来为模型创建特征。在我们的案例中，我们使用了地理位置相近的商店的信息。</li><li id="903b" class="ld le hh iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hi">使用</strong> <code class="du js jt ju jv b"><strong class="iw hi">altair</strong></code> <strong class="iw hi">创建特定商店的历史图表</strong>。我注意到，当您想要将图表作为弹出元素添加到一个follow地图中时，matplotlib不太有用。Altair提供了一个简单的解决方案。</li><li id="8929" class="ld le hh iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hi">如何创建叶子地图。</strong>准备数据并反复运行商店，以在地图上创建新的标记。</li><li id="953d" class="ld le hh iw b ix lm jb ln jf lo jj lp jn lq jr li lj lk ll bi translated"><strong class="iw hi">奖励</strong>:嵌入你的地图。树叶地图可以保存为HTML格式。要想上传到网站(比如Medium)上，得先嵌入。</li></ol><p id="0ffe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以让我们开始吧！</p><h1 id="9a75" class="lr kd hh bd ke ls lt lu ki lv lw lx km ly lz ma kp mb mc md ks me mf mg kv mh bi translated">1.从地址到坐标</h1><p id="7014" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">起初，我们的数据可能看起来像这样</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/76593c61a8cbec1f29a56e156461578b.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/1*ghBwigS_1-Zqo_7m473_Tw.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">面板数据集(另存为df)</figcaption></figure><p id="5f29" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们想给每个<code class="du js jt ju jv b">Address</code>分配两个坐标。谷歌对这个API的每1000次请求收取5美元，每个月我们免费获得200美元的使用费。与距离矩阵不同(见下一部分)，在这一部分中，我们只查找每个地址一次，所以我们只需要保留<code class="du js jt ju jv b">Retailer</code>和<code class="du js jt ju jv b">Address</code>。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="eedb" class="kc kd hh jv b fi mn mo l mp mq">addresses_df = df.filter(items = [‘Retailer’, ‘Address’]).\<br/> drop_duplicates().\<br/> reset_index(drop = True)</span></pre><p id="f340" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们会得到这样一个缩短的数据:</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es mr"><img src="../Images/20b15c64b9c47f9cd14647ef57354057.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/1*vC97h20zu9KVeVRk1AYTNA.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">地址数据(保存为地址)</figcaption></figure><p id="72aa" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">鉴于我们的数据看起来像这样，我们可以进行下一步。网上有很多优秀的导游；我用的是<a class="ae it" href="https://towardsdatascience.com/pythons-geocoding-convert-a-list-of-addresses-into-a-map-f522ef513fd6" rel="noopener" target="_blank">那款</a>。但是，首先，我们必须创建一个Google API密钥；你可以在这里做那件事。</p><p id="2439" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有了密钥后，我们可以使用<code class="du js jt ju jv b">request</code>包向Google请求坐标。在下面的代码中，我们准备我们的客户端。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="cbc4" class="kc kd hh jv b fi mn mo l mp mq"># working in a Colab framework, we first need to install googlemaps<br/>!pip install -U googlemaps</span><span id="ec41" class="kc kd hh jv b fi ms mo l mp mq">import requests</span><span id="4396" class="kc kd hh jv b fi ms mo l mp mq">import googlemaps</span><span id="5519" class="kc kd hh jv b fi ms mo l mp mq">from datetime import datetime</span><span id="9d55" class="kc kd hh jv b fi ms mo l mp mq">gmaps = googlemaps.Client(key='---YOUR KEY HERE---')</span></pre><p id="e6c2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们像那样跑过不同的地址</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="de19" class="kc kd hh jv b fi mn mo l mp mq">geocode = {}<br/>geocode['index'] = []<br/>geocode['address'] = []<br/>geocode['geocode_results'] = []</span><span id="7862" class="kc kd hh jv b fi ms mo l mp mq">for j in range(len(addresses)):<br/>  geocode_result = gmaps.geocode(addresses[j])<br/>  geocode['index'].append(j)<br/>  geocode['address'].append(addresses[j])<br/>  geocode['geocode_results'].append(geocode_result)</span><span id="5f66" class="kc kd hh jv b fi ms mo l mp mq">geocode_df = pd.DataFrame(geocode)</span></pre><p id="8dc6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的数据应该是这样的</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/14868f11ba2de7137860644ac88af08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*oKjUK4Ft8s82sE_qFMEABw.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">地理编码_df</figcaption></figure><p id="7c3e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">对于每个商店，谷歌的地理编码结果是一个看起来像字典的字符串。<code class="du js jt ju jv b">ast</code>包允许我们将字典中的字符串转换成字典，所以我们运行我们的存储，提取纬度和经度，我们就完成了。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="ca4e" class="kc kd hh jv b fi mn mo l mp mq">import ast<br/>geocode_df['Latitude']  = None<br/>geocode_df['Longitude'] = None</span><span id="d016" class="kc kd hh jv b fi ms mo l mp mq">for j in range(geocode_df.shape[0]):<br/>  try:<br/>    # convert string to dictionary<br/>    geocode_results_dict = \<br/>       ast.literal_eval(geocode_df['geocode_results'][j])[0]<br/>    # extract values<br/>    geocode_df['Latitude'][j] = \<br/>       geocode_results_dict['geometry']['location']['lat']<br/>    geocode_df['Longitude'][j] = \<br/>       geocode_results_dict['geometry']['location']['lng']</span><span id="c354" class="kc kd hh jv b fi ms mo l mp mq">  except:<br/>    geocode_df['Latitude'][j] = None<br/>    geocode_df['Longitude'][j] = None</span><span id="3ba4" class="kc kd hh jv b fi ms mo l mp mq">geocode_df</span></pre><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/cebf191318a8b7c159c3a11f8a80231a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*WpW5A67pcBVK_Vxswgpajg.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">带坐标的geocode_df</figcaption></figure><p id="9fdd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们有了每个商店的坐标。我们现在可以计算从一个商店到另一个商店的距离，或者为每个商店分配其位置属性。</p><h1 id="c544" class="lr kd hh bd ke ls lt lu ki lv lw lx km ly lz ma kp mb mc md ks me mf mg kv mh bi translated">2.从坐标到距离</h1><p id="2733" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">这一部分并不完全与叶子地图相关，但它可能与建模步骤相关，所以我在这里添加它。</p><p id="552d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">给定我们的坐标，我们希望创建一个距离矩阵，该矩阵的(I，j)元素表示商店I和商店j之间的距离。由于我们有单行道，或单向拥堵，该矩阵可能不是对称的。对角线假定为0，因为从商店I到其自身的距离可以忽略不计。</p><p id="15b3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以使用<code class="du js jt ju jv b">gmaps.distance_matrix</code>计算位置之间的距离。它接受元素、起点和目的地，并返回旅行花费的平均时间(以汽车为单位)和距离(以公里为单位)。</p><p id="b463" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">之前的计算相对便宜—我们只需要查找每个商店一次。在这里，另一方面，对于每个商店，我们画出与所有其他商店的距离。这增加了搜索的数量，并且可能是昂贵的。</p><p id="f2e9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我的项目中，我不需要所有的距离——因为埃拉特的商店不与特拉维夫的商店竞争，所以我在预测对方的价格时不需要考虑第一个因素。在那个阶段，一些规则可能会有帮助，所以我们不需要计算<strong class="iw hi">所有的</strong>距离。</p><p id="8582" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在阅读代码之前，我提供了一种计算两点之间空中距离的免费方法。这个计算的结果可以让你在第二步设置一个更精确的搜索(比如，只有当两点的空中距离小于7公里时，才使用Google API计算两点之间的距离——这是我的条件)。</p><p id="9580" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我在这里使用了<a class="ae it" href="https://stackoverflow.com/questions/19412462/getting-distance-between-two-points-based-on-latitude-longitude" rel="noopener ugc nofollow" target="_blank">的函数</a>。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="e37d" class="kc kd hh jv b fi mn mo l mp mq">import math<br/><br/><br/>def distance(origin, destination):<br/>    """<br/>    Calculate the Haversine distance.<br/><br/>    Parameters<br/>    ----------<br/>    origin : tuple of float<br/>        (lat, long)<br/>    destination : tuple of float<br/>        (lat, long)<br/><br/>    Returns<br/>    -------<br/>    distance_in_km : float<br/><br/>    Examples<br/>    --------<br/>    &gt;&gt;&gt; origin = (48.1372, 11.5756)  # Munich<br/>    &gt;&gt;&gt; destination = (52.5186, 13.4083)  # Berlin<br/>    &gt;&gt;&gt; round(distance(origin, destination), 1)<br/>    504.2<br/>    """<br/>    lat1, lon1 = origin<br/>    lat2, lon2 = destination<br/>    radius = 6371  # km<br/><br/>    dlat = math.radians(lat2 - lat1)<br/>    dlon = math.radians(lon2 - lon1)<br/>    a = \<br/>      (math.sin(dlat / 2) * math.sin(dlat / 2) + \<br/>       math.cos(math.radians(lat1)) * math.cos(math.radians(lat2))*\<br/>       math.sin(dlon / 2) * math.sin(dlon / 2))<br/>    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))<br/>    d = radius * c<br/><br/>    return d</span></pre><p id="b3c9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在计算了<code class="du js jt ju jv b">geocode_df</code>所有商店之间的成对空中距离并只保留距离小于7公里的组合后，我继续使用距离矩阵API。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="970f" class="kc kd hh jv b fi mn mo l mp mq">for i in range(geocode_df.shape[0]):<br/>  # Create an empty dict<br/>  distance_matrix_i = {'origin_address':[], <br/>                       'destination_address':[], <br/>                       'origin_google':[],<br/>                       'destination_google': [],<br/>                       'distance_text': [],<br/>                       'distance_value': [],<br/>                       'duration_text': [],<br/>                       'duration_value': []}</span><span id="4a4c" class="kc kd hh jv b fi ms mo l mp mq">  # Calculate Distance Sequentially<br/>  for j in range(len(addresses)):<br/>    ij_ans = gmaps.distance_matrix(<br/>             origins=[geocode_df['address'][i]], <br/>             destinations = addresses[j], mode='driving')</span><span id="10bb" class="kc kd hh jv b fi ms mo l mp mq">    distance_matrix_i['origin_address'].\<br/>       append(geocode_df['address'][i])<br/>    distance_matrix_i['destination_address'].append(addresses[j])<br/>    distance_matrix_i['origin_google'].\<br/>       append(ij_ans['origin_addresses'][0])<br/>    distance_matrix_i['destination_google'].\<br/>       append(ij_ans['destination_addresses'][0])</span><span id="3337" class="kc kd hh jv b fi ms mo l mp mq">    # If destination was found<br/>    if (ij_ans['rows'][0]['elements'][0]['status'] == 'OK'):<br/>      distance_matrix_i['distance_text'].\<br/>       append(ij_ans['rows'][0]['elements'][0]['distance']['text'])<br/>      distance_matrix_i['distance_value'].\<br/>       append(ij_ans['rows'][0]['elements'][0]['distance']['value'])<br/>      distance_matrix_i['duration_text'].\<br/>       append(ij_ans['rows'][0]['elements'][0]['duration']['text'])<br/>      distance_matrix_i['duration_value'].\<br/>       append(ij_ans['rows'][0]['elements'][0]['duration']['value'])</span><span id="a1a9" class="kc kd hh jv b fi ms mo l mp mq">    else:<br/>      distance_matrix_i['distance_text'].append(None)<br/>      distance_matrix_i['distance_value'].append(None)<br/>      distance_matrix_i['duration_text'].append(None)<br/>      distance_matrix_i['duration_value'].append(None)</span><span id="ca14" class="kc kd hh jv b fi ms mo l mp mq">  distance_matrix_i_df = pd.DataFrame.from_dict(distance_matrix_i)</span><span id="674e" class="kc kd hh jv b fi ms mo l mp mq">  distance_matrix_i_df.to_csv(f' --- Your Location ---', index = False)</span></pre><p id="5e00" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的结果应该是这样的</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/1e04e7f435d089570dfb6d67d9d1b737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GH_3sbRvbgNHtWqiA1Inaw.gif"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">谷歌距离矩阵结果，0是起点，1是终点</figcaption></figure><h1 id="6e53" class="lr kd hh bd ke ls lt lu ki lv lw lx km ly lz ma kp mb mc md ks me mf mg kv mh bi translated">3.创建一个牛郎星图表</h1><p id="cbe0" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">这个包并没有不友好到需要在单独的部分解释。尽管如此，对于我们的项目，我必须构建一个商店级别的图表，每次结合四个数据框架，所以我决定花几行来解释我所做的事情，以防您面临类似的情况。</p><p id="a5ad" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后，我们要在地图上分配每个商店/市场，图表如下。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/d4bd0e108f7f540fcf6499e7937e9e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ooI29X5PbxVJATPbnZxbPQ.gif"/></div></div></figure><p id="2751" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">蓝线代表给定商店以前的大米价格。橙色表示使用CatBoost模型预测的商店价格。红色表示以色列所有商店的大米月平均价格，浅蓝色线表示拥有当前商店的同一零售商的大米月平均价格。</p><p id="6de1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了创建如上的图表，我们需要制作如下的数据框。</p><figure class="jw jx jy jz fd ii er es paragraph-image"><div class="er es mx"><img src="../Images/e1092e5da4da017101681dbc91911090.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/1*QSOxiqRPq7JLodLWmi8dnw.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">牵牛星_df</figcaption></figure><p id="3524" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，我们使用以下代码创建图表</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="76c4" class="kc kd hh jv b fi mn mo l mp mq">import altair as alt</span><span id="0373" class="kc kd hh jv b fi ms mo l mp mq">source = pd.DataFrame({<br/>    'Month': temp_df.Month,<br/>    'Price': temp_df.AVGPriceAfterOffer,<br/>    'Label': temp_df.Label<br/>})</span><span id="da48" class="kc kd hh jv b fi ms mo l mp mq">sw_bar = \<br/>  alt.Chart(source).mark_line().encode(<br/>    x=alt.Y('Month',scale=alt.Scale(domain=(Months))),<br/>    y=alt.Y('Price', scale=alt.Scale(domain=(5, 15))),<br/>  color='Label',<br/>  strokeDash='Label').properties(title= 'chart_title_here')</span><span id="26a3" class="kc kd hh jv b fi ms mo l mp mq">sw_bar.configure_title(<br/>  fontSize=20,<br/>  font='Courier',<br/>  anchor='start',<br/>  color='gray'<br/>)</span></pre><h1 id="9cab" class="lr kd hh bd ke ls lt lu ki lv lw lx km ly lz ma kp mb mc md ks me mf mg kv mh bi translated">4.从商店级图表到交互式地图</h1><p id="cba2" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">到目前为止，我们准备了每个商店的坐标，并创建了一个商店级别的图表来显示其以前的价格和预测的价格，并将它们与整个以色列的平均价格进行比较。现在，我们将使用下面的代码在地图中部署这些元素(我假设您的项目与我们的不同，所以我不喜欢深入细节，而是停留在高级代码上。所以，下面我没有复制我的代码，而是用代码块角色来表示，这样你就可以把它放入你的案例中。</p><pre class="jw jx jy jz fd mj jv mk ml aw mm bi"><span id="f049" class="kc kd hh jv b fi mn mo l mp mq">import folium<br/>from folium.plugins import MarkerCluster<br/>import ast<br/>import altair as alt<br/>import pandas as pd<br/>import vega</span><span id="afe2" class="kc kd hh jv b fi ms mo l mp mq">text = ''</span><span id="bdd9" class="kc kd hh jv b fi ms mo l mp mq"># Define coordinates of where we want to center our map<br/>israel_coords = [31.4117257, 35.0818155]</span><span id="2a28" class="kc kd hh jv b fi ms mo l mp mq"># Create the map<br/>my_map2 = folium.Map(location = israel_coords, zoom_start = 9)<br/></span><span id="73f6" class="kc kd hh jv b fi ms mo l mp mq"># Create a color pallet for different retail companies</span><span id="7e83" class="kc kd hh jv b fi ms mo l mp mq">colors = {<br/>  'יינות ביתן': 'black',<br/>  'פרש מרקט': 'pink',<br/>  'חצי חינם': 'yellow',<br/>  'מחסני השוק': 'darkblue',<br/>  ...}</span><span id="e701" class="kc kd hh jv b fi ms mo l mp mq"># Create a DataFrame as altair_df, with country-level prices (that is loop invariant)<br/>altair_df = ...</span><span id="5370" class="kc kd hh jv b fi ms mo l mp mq">for j in range(0,stores_df.shape[0]):</span><span id="2a36" class="kc kd hh jv b fi ms mo l mp mq">  # Create a DataFrame as altair_df, with store and retailer level<br/>  # prices, and append it to the existed altair_df <br/>  altair_df = ...</span><span id="ca1f" class="kc kd hh jv b fi ms mo l mp mq">  title_ = '--- Set a store dependent title here ---'</span><span id="4ac7" class="kc kd hh jv b fi ms mo l mp mq">  # create graph<br/>  source = pd.DataFrame({<br/>    'Month': temp_df.Month,<br/>    'Price': temp_df.AVGPriceAfterOffer,<br/>    'Label': temp_df.Label<br/>  })<br/>  <br/>  sw_bar = \<br/>    alt.Chart(source).mark_line().encode(<br/>      x=alt.Y('Month',scale=alt.Scale(domain=(Months))),<br/>      y=alt.Y('Price', scale=alt.Scale(domain=(5, 15))),<br/>    color='Label',<br/>    strokeDash='Label').properties(title= 'chart_title_here')</span><span id="bf24" class="kc kd hh jv b fi ms mo l mp mq">  sw_bar.configure_title(<br/>    fontSize=20,<br/>    font='Courier',<br/>    anchor='start',<br/>    color='gray'<br/>  )</span><span id="0c24" class="kc kd hh jv b fi ms mo l mp mq">  # add the chart as a folium feature<br/>  vega = folium.features.\<br/>    VegaLite(sw_bar, width='100%', height='100%')</span><span id="b169" class="kc kd hh jv b fi ms mo l mp mq">  # create popup<br/>  sw_popup = folium.Popup(text,parse_html=True)</span><span id="c02d" class="kc kd hh jv b fi ms mo l mp mq">  # add chart to popup<br/>  vega.add_to(sw_popup)<br/> <br/>  # add to map (using our coordinates for store j)<br/>  place = [df['Latitude'][j], df['Longitude'][j]]</span><span id="33e1" class="kc kd hh jv b fi ms mo l mp mq">  # create marker on the map, with optional popup text or <br/>  # Vincent visualization<br/>  sw_marker = folium.features.\<br/>    Marker(place, <br/>           icon=folium.\<br/>           Icon(color=colors[XMerged['Retailer'][j]]))</span><span id="5fcf" class="kc kd hh jv b fi ms mo l mp mq">  sw_marker.add_to(my_map2)</span><span id="d910" class="kc kd hh jv b fi ms mo l mp mq">my_map2</span></pre><p id="8280" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就是这样！我们现在应该可以看到本文开头的交互式地图。</p><h1 id="f561" class="lr kd hh bd ke ls lt lu ki lv lw lx km ly lz ma kp mb mc md ks me mf mg kv mh bi translated">5.奖励:嵌入您的地图</h1><p id="5614" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">好了，现在我们已经完成了上面的所有步骤，现在我们有了<code class="du js jt ju jv b">my_map2</code>，一个HTML文件，我们可以与我们组织中的同事共享，或者原样发送给客户端；但是如果我们想把它上传到我们的网站并保持它的交互性呢？一个中等职位，就像这个？然后我们必须先嵌入我们的地图。</p><p id="37de" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">试图将HTML文件原样上传到网站可能是不可能的。它由成千上万行HTML代码组成(在我的例子中)，并且它需要首先被嵌入。</p><p id="0f57" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">试图通过Gist上传你的叶子地图可能会导致这个<a class="ae it" href="https://github.com/python-visualization/branca/issues/81" rel="noopener ugc nofollow" target="_blank">错误</a>。相信我；我花了几个小时试图正确上传我的HTML地图。我发现这样做的最短和最可靠的方法是使用<a class="ae it" href="https://datapane.com/" rel="noopener ugc nofollow" target="_blank">数据面板</a>服务。我在社区许可下上传了上面的地图，是免费的。</p><p id="a31d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我跟随<a class="ae it" href="https://medium.com/r?url=https%3A%2F%2Ftowardsdatascience.com%2Fhow-to-embed-interactive-charts-on-your-medium-articles-and-website-6987f7b28472" rel="noopener">这个</a>伟大的教程走向数据科学。首先，我在DataPane中创建了一个令牌，然后，在Colab笔记本中，我再次创建了my_map2，并像在教程中一样发布了它。结果出现在本文的顶部。</p></div></div>    
</body>
</html>