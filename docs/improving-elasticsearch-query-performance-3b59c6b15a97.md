# 提高弹性搜索查询性能

> 原文：<https://medium.com/analytics-vidhya/improving-elasticsearch-query-performance-3b59c6b15a97?source=collection_archive---------2----------------------->

![](img/c99525b6bd453a2214437d9423c63577.png)

**简介**

Elasticsearch 是一个基于 Apache Lucene 的分布式查询处理系统，用于构建搜索和分析系统。这是一个基于 java 的实现，它读取一个 JSON 请求，并用 JSON 响应有效载荷进行响应。它为调用查询接口提供了 API，并在行业中广泛用于对大量数据进行更快的分析搜索。ELK stack 提供了广泛的功能，并展示了一个完整的生态系统，用于存储、处理、查询和转换大量的事务日志，并提供了对数据集的出色监控和可视化功能。Elasticsearch 集群中的数据管理部分不同于其他数据持久化和搜索替代方案。Elasticsearch 在结构化文档上创建索引，而不是将数据保存为表格

让我们在一个非常高的层次上理解 elasticsearch 数据管理的构造块，以供以后参考。

***文档*** :最基本的实体，可以比作数据库中的一行，这就是你要搜索的内容，可以是任何编码的结构化数据格式。

***倒排索引*** :基于搜索查询的具有相似属性的文档组。它可以被理解为类似于一个数据库，其中保存着与一个模式连接在一起的记录，这些记录具有共同的特征，并且在逻辑上是相关的。这是一种 hashmap 类型的表示，有助于从单词中找到文档。作用于 **TFIDF** ，简称**词频-逆文档频率**

> *tfidf(t，D，D) = tf(t，D)。idf(t，D)*

***碎片*** :碎片是跨越 elasticsearch 集群中各个节点的索引的分割。它们是托管在一个节点上的独立索引。

> 根据我最近在扩展具有近实时处理需求的搜索系统方面的一些经验，这里有一些技巧可以帮助加速 elasticsearch 集群中的搜索和索引吞吐量。

**配置堆**

使用 elasticsearch，需要将 MAX_HEAP 和 MIN_HEAP 配置为相同的值，以避免在运行时调整大小，这是一个致命的操作。

> `*ES_HEAP_SIZE*`可以使用环境变量来进行设置，而不是显式配置-Xms 和-Xmx 值。

**堆不是万能的，给 Lucene 足够的资源**

如果我们不这样做，本质上意味着我们配置了一个太大的堆，这有其自身的缺点，不用说在弹性搜索中，这可能是一场性能灾难。Lucene 的性能依赖于这种与操作系统的交互。但是如果你把所有可用的内存都给了 Elasticsearch 的堆，就不会有任何剩余给 Lucene 了。这可能会严重影响性能。

另一方面，Lucene 被设计成利用底层操作系统来缓存内存数据结构。Lucene 片段存储在不可变的单独文件中，所以这些文件永远不会改变。这使得它们对缓存非常友好，底层操作系统会很高兴地将热段驻留在内存中以实现更快的访问。这些段包括倒排索引(用于全文搜索)和 doc 值(用于聚合)。

> 一般建议将可用内存的 1/2 给 Elasticsearch heap，而将剩余的 1/2 留作空闲。相信我，它不会闲置的；Lucene 会更好地利用它。

**如果不能完全消除交换，就减少交换**

交换主内存会降低系统性能。确保您有足够的资源来降低交换的需求，这违背了提高内存操作速度的目的。交换时间通常会比实际的内存获取时间多几倍。编辑/etc/fstab 以永久禁用它。另一种方法是降低`swappiness`。该值控制操作系统尝试交换内存的力度。这阻止了正常情况下的交换，但仍然允许操作系统在内存意外情况下交换。

> 或者，您可以让 JVM 锁定它的内存空间，不允许操作系统交换内存。这可以通过在 elasticsearch 属性文件中设置***bootstrap . mlockall:true***来实现。

**反规范化文档**

尽可能限制连接，嵌套查询会显著降低搜索查询性能。设计数据模型时，要使数据在很大程度上可以反规范化，从而消除一些不需要的连接。

**在步进时将多个字段复制到单个字段**

这是为了避免创建具有多个查询字段的搜索查询，这会严重降低搜索性能。或者，在创建索引时，使用 copy_to 指令将多个字段的值复制到单个字段中。

**大量使用数据的预索引**

为了避免在搜索期间进行昂贵的范围聚合，最好将范围预先索引到索引中。

**急切指定热点区域进行缓存**

在文件系统重新启动时，默认情况下，系统缓存将根据查询的热门搜索创建热区域的缓存，但建议尽快让系统知道要缓存什么，以实现更快的搜索响应时间并预热系统。这一过程称为缓存预加载，此时操作系统会被指示急切地将数据加载到文件系统缓存中。

**正确选择副本数量**

副本有助于增强所有系统的弹性和可用性，但是将副本数量增加到一定数量后就没有什么用了，而且可能会降低系统性能。

> 我怎么计算呢？嗯，如果您有一个包含`*N*`个节点的集群，总共有`*P*`个主碎片，并且如果您希望最多一次处理`*F*`个节点故障，那么正确的副本数量是`*max(F, ceil(N / P) - 1)*`

**缓存**

作为一个支持搜索的系统，弹性搜索中的读取应该明显更快，因此频繁读取的结果应该总是在文件系统的热点区域，为了实现这一点，需要有大量的物理内存可用于缓存数据。通常建议分配一半的可用集群内存用于缓存。

**更新是成本密集型的**

作为默认行为，elasticsearch 将每秒刷新所有索引的索引，其中查询负载至少为每 30 秒 1 个查询。对于负载较高的系统，建议将刷新率提高到更高的间隔值，以避免刷新过程的开销更频繁，并提高索引吞吐量。

**初始加载时不加载副本**

在生成新的弹性搜索集群和索引数据时，最好不要在启用复制的情况下加载数据，一旦加载数据，就会增加副本数量，并且一旦发生刷新过程，副本就会扩大。这实质上意味着，您应该始终对正在读取的数据进行持久备份，因为数据负载是以 0 复制系数发生的，任何停机都意味着数据丢失。

**为步进设置正确的缓冲区大小**

拥有足够大的缓冲区对于快速执行繁重的索引过程非常重要。确保***indexes . memory . index _ buffer _ size****为每个碎片设置了正确的值，通常每个碎片可以达到 512 mb，进一步增加通常没有帮助*。**

> *假设您有 40GB 的 JVM 内存，它将为索引缓冲区提供 4GB(10%),这对于大量索引的 8 个碎片来说足够了。*

***如果不需要，禁用再平衡***

*切换**cluster . routing . rebalance . enable**设置以启用/禁用重新平衡。Elasticsearch 有时会重新平衡碎片，这会降低搜索查询的性能。*

***分片上浆***

*分片允许与分布式架构并行执行，因此，它允许水平扩展。有两种类型的碎片，主碎片负责读写操作，如索引、重建索引、删除等，副本碎片负责高可用性和读取吞吐量。*

*优化分片值得考虑的点是分片的大小、分片中每个片段的大小、一个节点中有多少个活动片段。*

*副本碎片对于扩展搜索吞吐量很重要，如果硬件适合这种情况，可以小心地增加副本碎片的数量。*

> *通常，每个节点的碎片越少，性能越好，因为文件系统缓存在节点间的分布会更有效。*

***解耦索引和搜索***

*在单个集群中，索引和搜索都会相互竞争资源。通过设置双集群并配置[跨集群复制](https://www.elastic.co/guide/en/elasticsearch/reference/master/xpack-ccr.html)将数据从一个集群复制到另一个集群，并将所有搜索定向到具有跟随者索引的集群，搜索活动将不再争夺托管领导者索引的集群上的索引资源。*

***结论***

*Elasticsearch 提供了广泛的配置支持，可以对属性进行调整，以实现有助于实现业务目标的最佳设置。应充分考虑系统的存储、转换、分析和处理需求，以确定最佳方案。基于 Lucene 的系统的一些最好的特性伴随着非常高的资源权衡，因此过度的工程设计可能是危险的。*