<html>
<head>
<title>Bubble sort: In-depth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">冒泡排序:深入</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/bubble-sort-in-depth-64f209c7c4b3?source=collection_archive---------14-----------------------#2021-02-10">https://medium.com/analytics-vidhya/bubble-sort-in-depth-64f209c7c4b3?source=collection_archive---------14-----------------------#2021-02-10</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/dd07058960f7d3c85be3974fe8cd8cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mSPvcpriGY4jxljq.jpg"/></div></div></figure><p id="9ae5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是<a class="ae jn" href="https://kgdavidson.co.uk/algoverview" rel="noopener ugc nofollow" target="_blank">系列</a>的第一部分，它将介绍所有类型的程序算法。这些文章将深入讨论各种常见的算法，同时保持所有内容简单易懂。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="10f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">冒泡排序是任何人都应该学习的第一个也是最容易的排序算法之一。</strong>它的最坏情况时间复杂度为O(n ^ 2)，这发生在数据集被反向排序的情况下，当数组已经被排序时，它的最好情况复杂度为O(n)。这使得它是一个相对较慢的算法，但是对于现代计算机上的较小数据集，它是完全足够的。</p><h1 id="c39b" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">例子+解释</h1><p id="b93f" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated"><strong class="ir hi">冒泡排序的工作原理是一次比较成对的元素，如果它们顺序不对就交换它们。</strong>它从头到尾对每一对数组都这样做，直到数组排序完毕。</p><p id="5895" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">传递1 </strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="0eb6" class="lh jw hh ld b fi li lj l lk ll">99↷40 98 43 101</span><span id="cd45" class="lh jw hh ld b fi lm lj l lk ll">40 99↷98 43 101</span><span id="5404" class="lh jw hh ld b fi lm lj l lk ll">40 98 99↷43 101</span><span id="89bf" class="lh jw hh ld b fi lm lj l lk ll">40 98 43 99 101</span></pre><p id="bf6b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">比较阵列中的每一对，并在必要时交换。</p><p id="b557" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">第二遍</strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="aec4" class="lh jw hh ld b fi li lj l lk ll"><strong class="ld hi">40</strong> <strong class="ld hi">98 </strong>43 99 101</span><span id="4757" class="lh jw hh ld b fi lm lj l lk ll">40 <strong class="ld hi">98</strong>↷<strong class="ld hi">43</strong> 99 101</span><span id="655d" class="lh jw hh ld b fi lm lj l lk ll">40 43 <strong class="ld hi">98</strong> <strong class="ld hi">99</strong> 101</span><span id="c179" class="lh jw hh ld b fi lm lj l lk ll">40 43 98 <strong class="ld hi">99</strong> <strong class="ld hi">101</strong></span></pre><p id="efb5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">此时，我们可以看到数据集已经排序。然而，该算法需要一次没有任何交换的完整传递才能知道数据已排序。</p><p id="0474" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">传递3 </strong></p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="37d4" class="lh jw hh ld b fi li lj l lk ll"><strong class="ld hi">40</strong> <strong class="ld hi">43</strong> 98 99 101</span><span id="faee" class="lh jw hh ld b fi lm lj l lk ll">40 <strong class="ld hi">43</strong> <strong class="ld hi">98</strong> 99 101</span><span id="9369" class="lh jw hh ld b fi lm lj l lk ll">40 43 <strong class="ld hi">98</strong> <strong class="ld hi">99</strong> 101</span><span id="6eeb" class="lh jw hh ld b fi lm lj l lk ll">40 43 98 <strong class="ld hi">99</strong> <strong class="ld hi">101</strong></span></pre><p id="6ddd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在此过程中没有交换，因此算法知道停止。</p><h1 id="924b" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">冒泡排序伪代码</h1><figure class="ky kz la lb fd ii"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="1631" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="lp">原载于2021年2月10日https://kgdavidson.co.uk</em><a class="ae jn" href="https://kgdavidson.co.uk/algoverview--bubble-sort-in-depth/" rel="noopener ugc nofollow" target="_blank"><em class="lp"/></a><em class="lp">。</em></p></div></div>    
</body>
</html>