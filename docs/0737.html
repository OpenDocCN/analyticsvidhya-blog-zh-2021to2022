<html>
<head>
<title>Creating a custom Dataset and Dataloader in Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Pytorch中创建自定义数据集和数据加载器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-a-custom-dataset-and-dataloader-in-pytorch-76f210a1df5d?source=collection_archive---------0-----------------------#2021-01-29">https://medium.com/analytics-vidhya/creating-a-custom-dataset-and-dataloader-in-pytorch-76f210a1df5d?source=collection_archive---------0-----------------------#2021-01-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="8cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练深度学习模型需要我们将数据转换成模型可以处理的格式。例如，模型可能需要宽度为512、高度为512的图像，但是我们收集的数据包含宽度为1280、高度为720的图像。因此，我们需要某种方法来将我们现有的可用数据转换成模型所需的精确格式。</p><p id="c7c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简单地说，dataloader是一个函数，它遍历所有可用的数据，并以批处理的形式返回这些数据。例如，如果我们有一个包含100幅图像的数据集，我们决定将数据的大小定为4。我们的数据加载器将处理数据，并返回25批，每批4张图像。</p><p id="dae4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建数据加载器可以通过多种方式完成，并且不需要任何方式的torch。然而，使用torch使任务变得容易得多。记住这一点，让我们从理解Torch数据集和Dataloder类包含什么开始。</p><p id="27cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">火炬数据集:</strong></p><ol class=""><li id="64ac" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Torch数据集类基本上是一个表示数据集的抽象类。它允许我们将数据集视为一个类的对象，而不是一组数据和标签。</li><li id="3f5c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">数据集</strong>类的主要任务是每次被调用时返回一对【输入，标签】。我们可以在类中定义函数来预处理数据，并以我们需要的格式返回数据。</li><li id="eede" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">该类必须包含两个主要函数:<br/> <strong class="ih hj"> __len__() </strong>:这是一个返回数据集长度的函数。<br/> <strong class="ih hj"> __getitem__() </strong>:这是一个返回一个训练示例的函数。</li><li id="e077" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">torch数据集类可以从<strong class="ih hj">torch . utils . data . dataset</strong>导入</li></ol><p id="c29d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">火炬数据加载器:</strong></p><ol class=""><li id="0e72" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">Torch Dataloader不仅允许我们批量迭代数据集，还允许我们访问用于<strong class="ih hj">多重处理</strong>(允许我们并行加载多批数据，而不是一次加载一批数据)<strong class="ih hj">混排</strong>等的内置函数。</li><li id="8cf0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">torch Dataloader将torch数据集作为输入，并从Dataset类调用__getitem__()函数来创建一批数据。</li><li id="6aa5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">torch dataloader类可以从<strong class="ih hj">torch . utils . data . data loader</strong>导入</li></ol><p id="b0db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">代号:</strong></p><ul class=""><li id="501c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我不会深入讨论训练模型的整个过程，但是我会一步一步地解释创建数据集类和数据加载器的过程。</li><li id="aa70" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">对代码的要求将是:<br/><strong class="ih hj">numpy</strong>:pip 3 install numpy<br/><strong class="ih hj">opencv</strong>:pip 3 insall opencv-python<br/><strong class="ih hj">torch</strong>:pip 3 install torch<br/><strong class="ih hj">glob</strong>:pip 3 install glob</li><li id="a031" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我为分类模型的任务创建了一个样本数据集，对猫和狗进行分类。文件夹结构如下。我们有包含代码<strong class="ih hj"> Main.py </strong>的<strong class="ih hj">项目</strong>文件夹，以及名为<strong class="ih hj"> Dog_Cat_Dataset </strong>的文件夹。这个名为<strong class="ih hj"> Dog_Cat_Dataset </strong>的文件夹是数据集文件夹，其中包含两个子文件夹，分别名为<strong class="ih hj"> dogs </strong>和<strong class="ih hj"> cats </strong>。“狗”和“猫”文件夹各有5张图片。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2a48" class="kb kc hi jx b fi kd ke l kf kg">- <strong class="jx hj">Project</strong><br/>    - <strong class="jx hj">Main.py</strong><br/>    - <strong class="jx hj">Dog_Cat_Dataset</strong><br/>        - <strong class="jx hj">dogs</strong><br/>           - 1.jpg<br/>           - 2.jpg<br/>           - 3.jpg<br/>           - 4.jpg<br/>           - 5.jpg<br/>        - <strong class="jx hj">cats</strong><br/>           - 1.jpg<br/>           - 2.jpg<br/>           - 3.jpg<br/>           - 4.jpg<br/>           - 5.jpg</span></pre><ul class=""><li id="487b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">让我们从一些导入开始代码<strong class="ih hj"> Main.py </strong>。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="ab43" class="kb kc hi jx b fi kd ke l kf kg"><em class="kh">import</em> glob<br/><em class="kh">import</em> cv2<br/><em class="kh">import</em> numpy as np<br/><em class="kh">import</em> torch<br/><em class="kh">from</em> torch.utils.data <em class="kh">import</em> Dataset, DataLoader</span></pre><ul class=""><li id="db90" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated"><strong class="ih hj"> glob: </strong>允许我们轻松地检索子文件夹中数据的路径<br/> <strong class="ih hj"> cv2: </strong>用作图像处理库来读取和预处理图像<br/> <strong class="ih hj"> numpy: </strong>用于矩阵运算<br/> <strong class="ih hj"> torch: </strong>用于创建Dataset和Dataloader类，并将数据转换为张量。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="aef5" class="kb kc hi jx b fi kd ke l kf kg">class CustomDataset(Dataset):<br/>    def __init__(self):<br/>        self.imgs_path = "Dog_Cat_Dataset/"<br/>        file_list = glob.glob(self.imgs_path + "*")<br/>        print(file_list)<br/>        self.data = []<br/>        <em class="kh">for</em> class_path in file_list:<br/>            class_name = class_path.split("/")[-1]<br/>            <em class="kh">for</em> img_path in glob.glob(class_path + "/*.jpeg"):<br/>                self.data.append([img_path, class_name])<br/>        print(self.data)<br/>        self.class_map = {"dogs" : 0, "cats": 1}<br/>        self.img_dim = (416, 416)</span><span id="dccd" class="kb kc hi jx b fi ki ke l kf kg">    def __len__(self):<br/>        <em class="kh">return</em> len(self.data)</span><span id="2567" class="kb kc hi jx b fi ki ke l kf kg">    def __getitem__(self, idx):<br/>        img_path, class_name = self.data[idx]<br/>        img = cv2.imread(img_path)<br/>        img = cv2.resize(img, self.img_dim)<br/>        class_id = self.class_map[class_name]<br/>        img_tensor = torch.from_numpy(img)<br/>        img_tensor = img_tensor.permute(2, 0, 1)<br/>        class_id = torch.tensor([class_id])<br/>        <em class="kh">return</em> img_tensor, class_id</span></pre><ul class=""><li id="b8ee" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">让我们详细讨论一下这个类。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="16eb" class="kb kc hi jx b fi kd ke l kf kg">class CustomDataset(Dataset):</span></pre><ul class=""><li id="a234" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们创建一个名为<strong class="ih hj"> CustomDataset </strong>的类，并传递参数<strong class="ih hj"> Dataset </strong>，以允许它继承Torch Dataset类的功能。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0333" class="kb kc hi jx b fi kd ke l kf kg">def __init__(self):<br/>    self.imgs_path = "Dog_Cat_Dataset/"<br/>    file_list = glob.glob(self.imgs_path + "*")<br/>    print(file_list)</span></pre><ul class=""><li id="5934" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们定义init函数来初始化变量。变量<strong class="ih hj"> self.imgs_path </strong>包含我们的Dog_Cat_Dataset文件夹的基本路径</li><li id="9df6" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">然后，我们使用glob检索我们指定的基本文件夹中所有文件夹的列表。在我们的示例中，<strong class="ih hj"> Dog_Cat_Dataset </strong>文件夹包含两个子文件夹，分别名为<strong class="ih hj"> dogs </strong>和<strong class="ih hj"> cats </strong>。添加到<strong class="ih hj"> self.imgs_path </strong>中的“*”项表示我们想要搜索指定路径中的所有文件夹或文件。(注意，使用“*”操作将返回文件夹中的每个文件，而不仅仅是文件夹名。所以要确保这个位置除了猫狗文件夹之外没有其他东西。)</li><li id="8ef3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">print语句将返回以下输出:<br/><strong class="ih hj">[' Dog _ Cat _ Dataset/dogs '，' Dog_Cat_Dataset/cats'] </strong></li><li id="41fb" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">这个file_list变量包含数据集中所有类的列表(狗和猫)。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="22d7" class="kb kc hi jx b fi kd ke l kf kg">self.data = []<br/><em class="kh">for</em> class_path in file_list:<br/>    class_name = class_path.split("/")[-1]<br/>    <em class="kh">for</em> img_path in glob.glob(class_path + "/*.jpeg"):<br/>        self.data.append([img_path, class_name])<br/>print(self.data)</span></pre><ul class=""><li id="1d9a" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们现在开始创建数据列表，它将包含数据集中所有图像的路径。</li><li id="29ad" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我们遍历文件列表中的所有类(狗和猫)，对于每个类，我们首先从提取实际的类名开始。正如您可以从打印的文件列表中看到的，每个类都是根据其基本路径来表示的；即狗_猫_数据集/狗。因为我们更愿意把类称为狗和猫，而不是关于它的路径，我们通过用“/”分割这个<strong class="ih hj"> class_path </strong>来创建一个<strong class="ih hj"> class_name </strong>变量。(用“/”分割将返回一个列表["Dog_Cat_Dataset "，" dogs"]。采用[-1]索引将使用列表中的最后一个条目。在这种情况下，应该是“狗”。</li><li id="a52c" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">现在我们正在遍历数据集的每个类(狗和猫)，我们希望检索它们文件夹中的每个图像(例如1.jpeg、2.jpeg等)。为此，我们再次使用glob返回文件夹中扩展名为"的所有文件。jpeg”。我们传递给glob的完整字符串是Dog_Cat_Dataset/dogs/*。jpeg。“*。jpeg“表示我们需要扩展名为的每个文件”。jpeg”。</li><li id="5f7d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我们将每个图像的文件路径及其对应的类名附加到列表self.data中。这为我们提供了一种检索输入图像及其相应标签的方法。打印该列表将返回以下输出。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="8597" class="kb kc hi jx b fi kd ke l kf kg"> [['Dog_Cat_Dataset/dogs/4.jpeg', 'dogs'],    <br/>  ['Dog_Cat_Dataset/dogs/3.jpeg', 'dogs'], <br/>  ['Dog_Cat_Dataset/dogs/5.jpeg', 'dogs'],<br/>  ['Dog_Cat_Dataset/dogs/1.jpeg', 'dogs'],<br/>  ['Dog_Cat_Dataset/dogs/2.jpeg', 'dogs'],<br/>  ['Dog_Cat_Dataset/cats/4.jpeg', 'cats'],<br/>  ['Dog_Cat_Dataset/cats/3.jpeg', 'cats'],<br/>  ['Dog_Cat_Dataset/cats/5.jpeg', 'cats'],<br/>  ['Dog_Cat_Dataset/cats/1.jpeg', 'cats'],<br/>  ['Dog_Cat_Dataset/cats/2.jpeg', 'cats']]</span></pre><ul class=""><li id="3735" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们另外定义了一个类别映射和一个图像维度。<strong class="ih hj"> self.class_map </strong>字典，允许我们将类的字符串转换成数字；即“狗”对应于类别0，而“猫”对应于类别1，并且图像尺寸是我们将调整所有图像的尺寸，使得它们都具有相同的尺寸。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="522a" class="kb kc hi jx b fi kd ke l kf kg">self.class_map = {"dogs" : 0, "cats": 1}<br/>self.img_dim = (416, 416)</span></pre><ul class=""><li id="c203" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">现在我们已经创建了一个包含所有数据的列表，我们开始为<strong class="ih hj"> __len__() </strong>编写函数，这对于Torch Dataset对象是必需的。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="0351" class="kb kc hi jx b fi kd ke l kf kg">def __len__(self):<br/>    <em class="kh">return</em> len(self.data)</span></pre><ul class=""><li id="90d2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们的数据集的大小就是我们拥有的单个图像的数量，这可以通过<strong class="ih hj"> self.data </strong>列表的长度来获得。(Torch在内部使用该函数来了解其数据加载器中数据集的大小，以使用该数据集大小内的索引来调用<strong class="ih hj"> __getitem__() </strong>函数)</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="2814" class="kb kc hi jx b fi kd ke l kf kg">def __getitem__(self, idx):<br/>    img_path, class_name = self.data[idx]</span></pre><ul class=""><li id="a4e2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们首先定义<strong class="ih hj"> __getitem__ </strong>函数，将自身的对象作为输入(<strong class="ih hj"> self </strong>)，以及一个<strong class="ih hj"> idx </strong>。<strong class="ih hj"> idx </strong>是这个函数将被调用的术语，对应于哪个图像需要从我们的<strong class="ih hj"> self.data </strong>列表中返回。</li><li id="79f5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我们从<strong class="ih hj"> self.data </strong>列表中检索对应于idx的图像路径和类名。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="3e25" class="kb kc hi jx b fi kd ke l kf kg">img = cv2.imread(img_path)<br/>img = cv2.resize(img, self.img_dim)<br/>class_id = self.class_map[class_name]</span></pre><ul class=""><li id="30ac" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们使用opencv作为图像处理库来加载图像并将其调整到所需的尺寸。</li><li id="ea28" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我们使用<strong class="ih hj"> imread </strong>函数读取图像，该函数从给定的图像路径加载图像，然后将其调整到我们在<strong class="ih hj"> self.img_dim </strong>变量中指定的尺寸。</li><li id="623f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">用于分类的深度学习模型通常利用与类相关联的编号id，而不是名称(“dogs”-&gt; 0)。<strong class="ih hj"> self.class_map </strong>字典只是提供了从名字到号码的映射。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="fefc" class="kb kc hi jx b fi kd ke l kf kg">img_tensor = torch.from_numpy(img)<br/>img_tensor = img_tensor.permute(2, 0, 1)<br/>class_id = torch.tensor([class_id])</span></pre><ul class=""><li id="a39b" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">一旦我们加载了图像，并获得了相应的类id，我们就将变量转换为张量。使用torch训练模型需要我们将变量转换为torch张量格式，其中包含计算梯度的内部方法等。</li><li id="6b59" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">我们创建变量<strong class="ih hj"> img_tensor </strong>，它是我们加载的<strong class="ih hj"> img </strong>的张量形式。Opencv使用库numpy将图像表示为矩阵，<strong class="ih hj"> torch.from_numpy </strong>函数允许我们将numpy数组转换为torch张量。</li><li id="7cb7" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">火炬卷积要求图像为通道优先格式；例如，3通道图像(红色、绿色和蓝色通道)在numpy中通常表示为:(宽度、高度、通道)，但是torch要求我们将其转换为:(通道、宽度、高度)。</li><li id="5f73" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">对于这种转换，我们使用torch的置换功能，它允许我们改变torch张量的维度排序。我们传递给它的参数，对应于我们想要的新的维度排序。例如，在我们的例子中，我们有(宽度、高度、通道)。<br/> (Width - &gt; 0)，(Height- &gt; 1)，(Channels- &gt; 2) <br/>我们想要重新排序这些维度，以首先制作通道，因此，我们使用<strong class="ih hj"> img_tensor.permute(2，0，1) </strong>，这将首先制作第二维度。</li><li id="b609" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">然后，我们将<strong class="ih hj"> class_id </strong>的整数值转换为torch张量，并通过将其称为<strong class="ih hj">【class _ id】</strong>来增加其维数。这是为了确保数据可以在torch需要的维度上进行批量处理。(Torch要求标签为[batch_size，label_dimension]形状。只使用<strong class="ih hj"> class_id </strong>，而不使用<strong class="ih hj">【class _ id】</strong>会导致我们得到最终大小为【batch_size】，因为每个<strong class="ih hj"> class_id </strong>只是一个单一值。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="13a2" class="kb kc hi jx b fi kd ke l kf kg"><em class="kh">return</em> img_tensor, class_id</span></pre><ul class=""><li id="f849" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们返回了<strong class="ih hj"> img_tensor </strong>和<strong class="ih hj"> class_id </strong>，这样无论何时使用<strong class="ih hj"> idx </strong>调用<strong class="ih hj"> __getitem__ </strong>函数，都会返回一个带有相应标签的图像。</li><li id="ab15" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">注意:另外，torch可能需要将返回的张量转换为float类型。这可以通过以下修改来实现:</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="c3af" class="kb kc hi jx b fi kd ke l kf kg"><em class="kh">return</em> img_tensor.float(), class_id.float()</span></pre><ul class=""><li id="d738" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">现在我们已经创建了数据集，我们可以在torch dataloader中使用这个类在训练时遍历这些数据。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="a9e9" class="kb kc hi jx b fi kd ke l kf kg"><em class="kh">if</em> __name__ == "__main__":<br/>    dataset = CustomDataset()<br/>    data_loader = DataLoader(dataset, batch_size=4, shuffle=True)</span></pre><ul class=""><li id="481c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">为了测试数据集和我们的数据加载器，在我们脚本的主函数中，我们创建了我们创建的<strong class="ih hj"> CustomDataset </strong>的一个实例，并将其命名为<strong class="ih hj">数据集。</strong></li><li id="cae3" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">Torch DataLoader将这个<strong class="ih hj">数据集</strong>以及batch_size、shuffle等其他参数作为输入，这些参数是额外的术语，用于指定我们希望每批数据中有多少图像，以及我们是否希望随机生成我们之前使用的<strong class="ih hj"> idx </strong>。</li></ul><pre class="js jt ju jv fd jw jx jy jz aw ka bi"><span id="f261" class="kb kc hi jx b fi kd ke l kf kg"><em class="kh">for</em> imgs, labels in data_loader:<br/>    print("Batch of images has shape: ",imgs.shape)<br/>    print("Batch of labels has shape: ", labels.shape)</span></pre><ul class=""><li id="8a23" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc jr jj jk jl bi translated">我们可以通过遍历数据加载器来测试它的工作情况，并打印输入图像的形状和标签。</li><li id="ef8a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc jr jj jk jl bi translated">torch数据加载器确实需要很多额外的参数，比如:</li></ul><ol class=""><li id="8927" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> no_workers </strong>:对应于我们要并行加载数据的工作线程数量。使用更多的工作人员可以加快数据加载过程。</li><li id="f742" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> pin_memory </strong>:在GPU设备上训练时，我们会希望加快将加载的数据从CPU传递到GPU的过程。因此，将其设置为true会加快数据传输速度。</li><li id="b0f5" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj"> drop_last </strong>:如果有样本&lt; batch_size，跳过最后一批数据。例如，在我们的例子中，我们的数据集中有10个图像，我们指定批量大小为4。这意味着最后一批只有2个图像。设置drop_last=True，将跳过这最后一批，因为它有&lt; 4个图像。</li></ol><p id="acad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注:</strong></p><ol class=""><li id="bf3d" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">torch的dataset类可以像python中的任何其他类一样使用，并且可以有任意数量的子函数，只要它有两个必需的函数(<strong class="ih hj"> __len__ </strong>和<strong class="ih hj"> __getitem__ </strong>)。</li><li id="39fe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果可用，返回的数据也可以传递给GPU。比如:<strong class="ih hj"> img_tensor.to("cuda ")。</strong></li><li id="0c37" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">torch数据加载器有一个可用于<br/> <a class="ae kj" href="https://pytorch.org/docs/stable/data.html#iterable-style-datasets" rel="noopener ugc nofollow" target="_blank">链接</a>的附加参数列表</li><li id="d109" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我已经在github上传了这篇文章的完整代码:<a class="ae kj" href="https://github.com/vineeth2309/Custom-Dataset-and-Dataloader-in-Torch" rel="noopener ugc nofollow" target="_blank">代码</a></li></ol></div></div>    
</body>
</html>