<html>
<head>
<title>Python speed up</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python加速</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-speed-up-89f249bc484a?source=collection_archive---------11-----------------------#2021-08-14">https://medium.com/analytics-vidhya/python-speed-up-89f249bc484a?source=collection_archive---------11-----------------------#2021-08-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fcc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个故事中，我只是分享我做的小小研究。</p><p id="c363" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">关键要点:</strong></p><ul class=""><li id="a338" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi"> Dask </strong> 1.0.0版本于2018年11月底发布，2015年左右开始开发。我想以后再进一步探索。</li><li id="1de6" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated"><strong class="ig hi"> Spark </strong>也在我的探索名单上很长时间了。</li><li id="f1ef" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">Numba 可以用来优化一些关键的功能。</li></ul><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es jq"><img src="../Images/c94de6810d36fe8d42035bc64b4e75ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ve5M_EfvgiJDRb-FVgJS8w.png"/></div></div></figure><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es kc"><img src="../Images/0cb78fefbb2ff8111a399cd6b7271d52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7nSShzxhCRZYByYag1nXAg.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated"><a class="ae kh" href="https://www.youtube.com/watch?v=hT8wjSGL7S8" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=hT8wjSGL7S8</a></figcaption></figure><h1 id="e93f" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">…向量化…</h1><p id="03d0" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">就用Numpy和熊猫吧。但是请参见下面的Numba以了解替代方案。</p><h1 id="2e7c" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">并行化</h1><ul class=""><li id="287a" class="jc jd hh ig b ih lg il lh ip ll it lm ix ln jb jh ji jj jk bi translated">对于一些简单的场景，标准的<em class="lo">多进程</em>库可能就足够了。例如参见<a class="ae kh" rel="noopener" href="/geekculture/join-files-cc5e38e3c658">https://medium.com/geekculture/join-files-cc5e38e3c658</a>。</li><li id="1773" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">看起来Pandaral-lel<a class="ae kh" href="https://reposhub.com/python/miscellaneous/nalepae-pandarallel.html" rel="noopener ugc nofollow" target="_blank">https://repos hub . com/python/miscellaneous/na lepae-pandarallel . html</a>非常有限，应该使用trail &amp; error来有效地利用它。另请参见<a class="ae kh" href="https://towardsdatascience.com/pandaral-lel-a-simple-and-efficient-tool-to-parallelize-your-pandas-operations-on-all-your-cpus-bb5ff2a409ae" rel="noopener" target="_blank">https://towards data science . com/pandaral-lel-a-simple-efficient-tool-to-parallelism-your-pandas-operations-on-all-your-your-CPU-bb 5 ff 2 a 409 AE</a></li></ul><p id="2de3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了Dask 和<strong class="ig hi"> Ray </strong>之外，还有一些更好的选择，我们先来看看。引用:</p><blockquote class="lp lq lr"><p id="31f8" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"><em class="hh">*</em></strong><a class="ae kh" href="https://www.datarevenue.com/ml-tools/dask" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">Dask</em></strong></a><strong class="ig hi"><em class="hh">:</em></strong><em class="hh">一个低级调度器和一个高级局部熊猫替换，面向计算集群上的运行代码。</em></p><p id="770a" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> * Ray: </em> </strong> <em class="hh">跨处理器或集群并行化Python代码的底层框架。</em></p><p id="87fb" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"><em class="hh"/></strong><a class="ae kh" href="https://www.datarevenue.com/ml-tools/modin" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">摩丁</em></strong></a><strong class="ig hi"><em class="hh">:</em></strong><em class="hh">熊猫的空降替代品，由</em><strong class="ig hi"><em class="hh">【Dask】</em></strong><em class="hh">或</em> <strong class="ig hi"> <em class="hh">雷</em> </strong> <em class="hh">驱动。</em></p><p id="0c8b" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"><em class="hh">*</em></strong><a class="ae kh" href="https://www.datarevenue.com/ml-tools/vaex" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">Vaex</em></strong></a><strong class="ig hi"><em class="hh">:</em></strong><em class="hh">使用惰性评估和内存映射的部分熊猫替换，允许开发人员在标准机器上处理大型数据集。</em></p><p id="a36b" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"><em class="hh">*</em></strong><a class="ae kh" href="https://www.datarevenue.com/ml-tools/rapids" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">激流</em></strong></a><strong class="ig hi"><em class="hh">:</em></strong><em class="hh">运行在GPU上的数据科学库集合，包括</em><a class="ae kh" href="https://github.com/rapidsai/cudf" rel="noopener ugc nofollow" target="_blank"><em class="hh">cuDF</em></a><em class="hh">，熊猫的部分替代。<br/> …。</em></p></blockquote><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="er es lv"><img src="../Images/976b1d36f7e4bd2f19f9ff9f0551a8d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ugi6FikkhYX8w-T99058HQ.png"/></div></div><figcaption class="kd ke et er es kf kg bd b be z dx translated">Dask和Ray比较成熟，但是摩丁和Vaex比较容易上手。如果你有GPU的话，Rapids是有用的。</figcaption></figure><blockquote class="lp lq lr"><p id="4399" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> *到期:</em> </strong> <em class="hh">自第一次提交以来的时间和提交次数。</em></p><p id="565a" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> *人气:</em></strong><em class="hh">GitHub明星数。</em></p><p id="2f78" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> *易于采用:</em> </strong> <em class="hh">用户期望的知识量、假定的硬件资源和安装的简易性。</em></p><p id="0cdf" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> *扩展能力:</em> </strong> <em class="hh">每个工具的广泛数据集大小限制，取决于它是主要依赖于单个机器上的RAM、硬盘空间，还是可以扩展到机器集群。</em></p><p id="97f5" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> *用例:</em> </strong> <em class="hh">无论这些库是旨在加速Python软件的一般功能(</em> <strong class="ig hi"> <em class="hh">一般功能(</em> </strong> <em class="hh">)、是专注于数据科学和机器学习(</em> <strong class="ig hi"> <em class="hh">数据科学</em> </strong> <em class="hh">)、还是仅限于简单地替换熊猫的“数据框架”功能(</em> </p></blockquote><p id="9f4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://www.datarevenue.com/en-blog/pandas-vs-dask-vs-vaex-vs-modin-vs-rapids-vs-ray" rel="noopener ugc nofollow" target="_blank">https://www . data revenue . com/en-blog/pandas-vs-dask-vs-vaex-vs-modin-vs-rapids-vs-ray</a></p><p id="08e8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，也可以换成<strong class="ig hi"> Spark </strong> /PySpark。这种方法的主要缺点是您需要学习全新的方法来组织您的代码。以下是更多相关信息。</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="16f7" class="ki kj hh bd kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf bi translated">光线</h1><p id="af2d" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">引用自其网站:</p><blockquote class="lp lq lr"><p id="15bc" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">Ray为构建分布式应用程序提供了一个简单、通用的API。T94】</p><p id="b488" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">雷通过</em>完成这个任务</p><p id="ff6c" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 1。为构建和运行分布式应用程序提供简单的原语。</em></p><p id="a3b3" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 2。支持最终用户并行处理单个机器代码，几乎不需要修改代码。</em></p><p id="c73c" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 3。包括应用程序、库和工具的大型生态系统，以支持复杂的应用程序。</em></p><p id="30a9" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh">雷核</em> </strong> <em class="hh">为应用构建提供了简单的原语。</em></p></blockquote><p id="9019" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://docs.ray.io/en/master/" rel="noopener ugc nofollow" target="_blank">https://docs.ray.io/en/master/</a></p><p id="10d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们详细说明一下。引用:</p><blockquote class="lp lq lr"><p id="1aaa" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">传统编程依赖于两个核心概念:</em> <strong class="ig hi"> <em class="hh">函数</em> </strong> <em class="hh">和</em> <strong class="ig hi"> <em class="hh">类。</em> </strong> <em class="hh">利用这些构建模块，编程语言允许我们构建无数的应用程序。</em></p><p id="6e1f" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">然而，当我们将应用程序迁移到分布式环境时，概念通常会发生变化。</em></p><p id="c000" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">在光谱的一端，我们有类似</em><a class="ae kh" href="https://www.open-mpi.org/" rel="noopener ugc nofollow" target="_blank"><em class="hh">OpenMPI</em></a><em class="hh">，</em><a class="ae kh" href="https://docs.python.org/2/library/multiprocessing.html" rel="noopener ugc nofollow" target="_blank"><em class="hh">Python</em><strong class="ig hi"><em class="hh">多处理</em> </strong> </a> <em class="hh">和</em><a class="ae kh" href="http://zeromq.org/" rel="noopener ugc nofollow" target="_blank"><em class="hh">ZeroMQ</em></a><em class="hh">的工具，它们为发送和接收消息提供底层原语。这些工具非常强大，但它们提供了不同的抽象，因此单线程应用程序必须从头开始重写才能使用它们。</em></p><p id="ba34" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">另一方面，我们有特定领域的工具，如用于模型训练的</em><a class="ae kh" href="https://www.tensorflow.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">【tensor flow】</em></strong></a><strong class="ig hi"><em class="hh"/></strong><em class="hh"/><a class="ae kh" href="https://spark.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">Spark</em></strong></a><strong class="ig hi"><em class="hh"/></strong><em class="hh">用于数据处理和SQL，以及</em><a class="ae kh" href="https://flink.apache.org/" rel="noopener ugc nofollow" target="_blank"><strong class="ig hi"><em class="hh">Flink</em></strong>这些工具提供了更高层次的抽象，如神经网络、数据集和流。然而，因为它们不同于串行编程所用的抽象，应用程序必须从头开始重新编写才能利用它们……</a></p><p id="ee9d" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">雷占据了一个独特的中间地带。而不是引入新的概念。Ray采用现有的函数和类的概念，并将它们作为任务和参与者转换到分布式环境中。这种API选择允许串行应用并行化，而无需重大修改。</em></p><p id="1e49" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> …Ray允许你用</em> <code class="du mi mj mk ml b"><em class="hh">@ray.remote</em></code> <em class="hh">装饰器来声明一个Python类。每当实例化该类时，Ray都会创建一个新的“actor ”,它是一个在集群中某个地方运行的进程，并保存着该对象的副本。对该角色的方法调用变成了在角色进程上运行的任务，并且可以访问和改变角色的状态。以这种方式，参与者允许在多个任务之间共享可变状态，而远程函数不能。</em></p><p id="ae55" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">个体参与者串行执行方法(每个个体方法都是原子的)，因此不存在竞争条件。并行可以通过创建多个参与者来实现。</em></p><p id="d851" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">……演员都是极其厉害的。它们允许您获取一个Python类，并将其实例化为一个微服务，可以从其他参与者和任务甚至其他应用程序查询该微服务。</em></p><p id="348c" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">任务和参与者是Ray提供的核心抽象。这两个概念非常通用，可以用来实现复杂的应用程序，包括Ray的内置库，用于<a class="ae kh" href="https://ray.readthedocs.io/en/latest/rllib.html" rel="noopener ugc nofollow" target="_blank"><em class="hh"/></a><em class="hh">、</em> <a class="ae kh" href="https://ray.readthedocs.io/en/latest/tune.html" rel="noopener ugc nofollow" target="_blank"> <em class="hh">超参数调优</em> </a> <em class="hh">、</em> <a class="ae kh" href="https://github.com/modin-project/modin" rel="noopener ugc nofollow" target="_blank"> <em class="hh">加速熊猫</em> </a> <em class="hh">等等。</em></p></blockquote><p id="67d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://towardsdatascience.com/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d70369b8" rel="noopener" target="_blank">https://towards data science . com/modern-parallel-and-distributed-python-a-quick-tutorial-on-ray-99f8d 70369 b 8</a></p><p id="971e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">据我所知，雷把演员模型带到了Python语言中。它确实是一个强大的工具，但是它需要重新设计你的代码。</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="2c61" class="ki kj hh bd kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf bi translated">达斯克</h1><p id="f1cb" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">引用自官方文件:</p><blockquote class="lp lq lr"><p id="757b" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">分析师经常使用Pandas、Scikit-Learn、Numpy和Python生态系统的其他工具来分析他们个人电脑上的数据。他们喜欢这些工具，因为它们高效、直观且广受信任。然而，当他们选择将他们的分析应用于更大的数据集时，他们发现这些工具并不是为超越单台机器而设计的。Dask提供了以最少的重写更自然地扩展Pandas、Scikit-Learn和Numpy工作流的方法。它与这些工具集成得很好，因此它复制了它们的大部分API，并在内部使用它们的数据结构。此外，Dask与这些库共同开发，以确保它们一致发展，最大限度地减少从本地笔记本电脑过渡到多核工作站，然后再过渡到分布式集群时的摩擦。熟悉Pandas/Scikit-Learn/Numpy的分析师将很快熟悉他们的Dask同类产品，并将他们的许多直觉带到一个可扩展的环境中……<br/>……<br/>Dask可以使分析师能够在他们的笔记本电脑上操作100GB以上的数据集，或者在工作站上操作1TB以上的数据集，而完全不需要使用集群。这可能是更可取的，原因如下:</p><p id="65eb" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 1。他们可以使用本地软件环境，而不是受限于集群上的可用资源或必须管理Docker映像。</em></p><p id="baba" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 2。他们可以在途中、咖啡店或远离公司网络的家中更轻松地工作。</em></p><p id="c094" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 3。在单台机器上调试错误和分析性能更加简单和愉快。</em></p><p id="ad6f" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 4。他们的迭代周期可以更快。</em></p><p id="c68a" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 5。他们的计算可能更有效，因为所有的数据都是本地的，不需要通过网络或在不同的进程之间流动。<br/>……<br/>Dask允许您将集群换成单机调度程序，这种调度程序非常轻量级，不需要设置，并且可以完全在与用户会话相同的进程中运行……</em></p></blockquote><h1 id="9836" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><em class="mm"> Dask与Python代码原生集成</em></h1><blockquote class="lp lq lr"><p id="c1d1" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> Python包括计算库，如</em> <strong class="ig hi"> <em class="hh"> Numpy、Pandas和Scikit-Learn </em> </strong> <em class="hh">，以及许多其他用于数据访问、绘图、统计、图像和信号处理等的库。这些库无缝地协同工作，产生一个内聚的包生态系统，它们共同发展，以满足当今大多数领域中的分析师的需求。</em></p><p id="3cd0" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">这个生态系统由每个人都遵守的通用标准和协议联系在一起，这使得这些包以令人惊讶和愉快的方式相互受益。</em></p><p id="18ef" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="hh"> Dask从这个生态系统内进化而来</em> </strong> <em class="hh">。它遵守这些标准和协议，并积极参与社区工作来推动新的标准和协议。这使得生态系统的其余部分能够以最少的协调从并行和分布式计算中受益。Dask并不寻求破坏或取代现有的生态系统，而是从内部补充和受益。</em></p><p id="e0a3" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">结果，Dask开发被来自Pandas、Numpy、Scikit-Learn、Scikit-Image、Jupyter和其他人的开发者社区所推动。这种来自更广泛的社区增长的参与有助于用户信任该项目，并有助于确保Python生态系统将以平稳和可持续的方式继续发展。</p></blockquote><p id="f6eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://docs.dask.org/en/latest/why.html" rel="noopener ugc nofollow" target="_blank">https://docs.dask.org/en/latest/why.html</a></p><p id="88d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，它值得进一步研究。</p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="bb5b" class="ki kj hh bd kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf bi translated">农巴</h1><p id="cede" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">引用:</p><blockquote class="lp lq lr"><p id="e678" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> Numba为代码生成提供了几个实用程序，但是它的核心特性是</em> <code class="du mi mj mk ml b"><a class="ae kh" href="https://numba.readthedocs.io/en/stable/reference/jit-compilation.html#numba.jit" rel="noopener ugc nofollow" target="_blank"><em class="hh">numba.jit()</em></a></code> <em class="hh">装饰器。使用这个装饰器，您可以通过Numba的JIT编译器为优化标记一个函数。不同的调用模式触发不同的编译选项和行为。</em></p></blockquote><p id="dcf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://numba.readthedocs.io/en/stable/user/jit.html" rel="noopener ugc nofollow" target="_blank">https://numba.readthedocs.io/en/stable/user/jit.html</a></p><p id="f6e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们引用另一个资源:</p><blockquote class="lp lq lr"><p id="10a1" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> JIT或Just In Time compilation是一种编译器特性，允许在运行时而不是在执行时解释和编译语言。这意味着JIT编译器在编译代码之前执行逻辑，而不是准备所有的代码来工作，决定代码要做什么，然后再去做。</em></p><p id="0ca2" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">这种编译器的好处当然是速度。花费在初始编译上的时间更少意味着代码可以更快地被解释。打个比方，假设你有一份晚餐要做的东西的清单。你可以采取一种多任务的方法，在同一时间做多件事情，而不是单独做所有的事情。</em></p><p id="d549" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">数字概述</em></p><p id="96a3" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">Numba JIT编译器…使用标准的LLVM编译器库。虽然它在这方面确实有一些缺点，因为LLVM的重点不一定是JIT，但它确实意味着编译器非常快和精确。 <strong class="ig hi"> <em class="hh"> Numba编译的Pythonic算法可以达到c等低级语言中常见的速度</em> </strong></p><p id="8a67" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">这听起来可能很复杂，的确如此——但这并不意味着Numba很难使用。事实上，Numba非常容易使用！为了试用它，你当然需要用Python的包管理器PIP来添加它。</em></p></blockquote><pre class="jr js jt ju fd mn ml mo mp aw mq bi"><span id="41f7" class="mr kj hh ml b fi ms mt l mu mv">sudo pip3 install numba</span></pre><blockquote class="lp lq lr"><p id="3715" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">安装Numba后，可以通过jit函数访问:</em></p></blockquote><figure class="jr js jt ju fd jv"><div class="bz dy l di"><div class="mw mx l"/></div></figure><blockquote class="lp lq lr"><p id="3f65" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">对于大多数代码，Numba在优化Python代码方面做了令人难以置信的工作……然而，在其当前版本中，Numba仍有很长的路要走，并出现了[某些代码的问题。有些问题无法通过简单的Python调用来解决，尽管Numba在创建可以轻松导入的Python优化编译器方面做得很好，但仍有改进的空间。</p></blockquote><p id="3f60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://towardsdatascience.com/numba-jit-compilation-but-for-python-373fc2f848d6" rel="noopener" target="_blank">https://towardsdatascience . com/numba-JIT-compilation-but-for-python-373 fc 2 f 848d 6</a></p><p id="f32b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想特别指出@jit decorator的另一个参数:</p><h1 id="eb28" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><code class="du mi mj mk ml b"><em class="mm">nogil</em></code></h1><blockquote class="lp lq lr"><p id="545f" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">每当Numba将Python代码优化为只对原生类型和变量(而不是Python对象)起作用的原生代码时，就不再需要持有Python的</em> <a class="ae kh" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank"> <em class="hh">全局解释器锁</em> </a> <em class="hh"> (GIL)。如果您通过了</em> <code class="du mi mj mk ml b"><em class="hh">nogil=True</em></code> <em class="hh">，Numba将在进入此编译函数时释放GIL。</em></p></blockquote><pre class="jr js jt ju fd mn ml mo mp aw mq bi"><span id="faaf" class="mr kj hh ml b fi ms mt l mu mv">@jit(nogil=True)<br/>def f(x, y):<br/>    return x + y</span></pre><blockquote class="lp lq lr"><p id="9cef" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh">使用GIL发布版运行的代码可以与执行Python或Numba代码的其他线程并发运行(无论是同一个编译函数，还是另一个函数)，从而让您充分利用多核系统。如果该函数在</em> <a class="ae kh" href="https://numba.readthedocs.io/en/stable/glossary.html#term-object-mode" rel="noopener ugc nofollow" target="_blank"> <em class="hh">对象模式</em> </a> <em class="hh">下编译，这是不可能的。</em></p><p id="166c" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated">当使用 <code class="du mi mj mk ml b"><em class="hh">nogil=True</em></code> <em class="hh">时，你必须警惕多线程编程的常见陷阱(一致性、同步、竞争条件等)。).</em></p></blockquote><p id="7e2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://numba.readthedocs.io/en/stable/user/jit.html" rel="noopener ugc nofollow" target="_blank">https://numba.readthedocs.io/en/stable/user/jit.html</a></p><h1 id="c540" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">Numba的局限性</h1><blockquote class="lp lq lr"><p id="12ab" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 1。Numba编译单个函数，而不是整个程序。</em></p><p id="0940" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 2。Numba支持Python的一个子集。有些字典/列表/集合支持但</em> <strong class="ig hi"> <em class="hh">不混合类型</em> </strong> <em class="hh">的键和值在列表中也不混合类型。</em></p><p id="2212" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 3。Numba支持NumPy的子集。并非所有的函数和方法都可用。</em></p><p id="2b24" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 4。Numba不支持Scikitlearn、PyData和其他一些Python包。</em></p><p id="3784" class="ie if lo ig b ih ii ij ik il im in io ls iq ir is lt iu iv iw lu iy iz ja jb ha bi translated"><em class="hh"> 5。使用Numpy数组比使用Python列表效果更好。但是这并不是很大的限制，因为我们的大部分数据科学计算都是用NumPy数组完成的。</em></p></blockquote><p id="26b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae kh" href="https://www.analyticsvidhya.com/blog/2021/04/numba-for-data-science-make-your-py-code-run-1000x-faster/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2021/04/numba-for-data-science-make-your-py-code-run-1000 x-faster/</a></p></div><div class="ab cl lw lx go ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="ha hb hc hd he"><h1 id="db33" class="ki kj hh bd kk kl md kn ko kp me kr ks kt mf kv kw kx mg kz la lb mh ld le lf bi translated">“轻量级”框架和避免繁重的初始化过程</h1><p id="ef96" class="pw-post-body-paragraph ie if hh ig b ih lg ij ik il lh in io ip li ir is it lj iv iw ix lk iz ja jb ha bi translated">这真的取决于你正在做的任务。也许你可以让你的应用程序一直运行，比如web服务，这样初始化时间就不那么重要了。也许整个管道运行需要几个小时，所以在启动时多“浪费”几秒钟是可以的。如果你正在做一些接近“实时”的事情，那么你确实应该减少你的初始化时间。有许多技术可以做到这一点，但是，使用随机值的模型只是其中之一。</p><p id="7386" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一种方法可能是:使用“轻”模型，您可以将初始化的模型保存到某个快速存储中，并在启动时从其中加载。</p></div></div>    
</body>
</html>