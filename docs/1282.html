<html>
<head>
<title>Steal songs from your friends on Spotify using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python从Spotify上的朋友那里窃取歌曲</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/steal-songs-from-your-friends-on-spotify-using-python-3c3b654b4375?source=collection_archive---------16-----------------------#2021-02-22">https://medium.com/analytics-vidhya/steal-songs-from-your-friends-on-spotify-using-python-3c3b654b4375?source=collection_archive---------16-----------------------#2021-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/096437d9d22231458b2994e09408cfe8.png" data-original-src="https://miro.medium.com/v2/resize:fit:448/format:webp/1*llhdCJSqpVEECCKlDNORRQ.png"/></div></figure><p id="ebc7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你有没有想过如何创建一个朋友在Spotify上听的播放列表？Spotify API和Spotitpy python库使这变得简单易行。</p><p id="4990" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，您需要熟悉使用python中的Spotipy库。如果你以前使用过这个工具，请继续阅读，否则，我创建了这篇文章，涵盖如何开始的基础知识:<a class="ae jj" href="https://maxpiersanti.medium.com/automating-spotify-with-python-everything-you-need-to-know-about-the-spotipy-library-f84d60e8a3ec" rel="noopener">https://maxpiersanti . medium . com/automating-Spotify-with-python-everything-you-need-to-know-the-spot ipy-library-f 84d 60 E8 a3 EC</a></p><p id="77f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这个项目的设置相当简单。首先，我们将创建一个助手类，以便使一些设置过程更加简化。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="d19d" class="jt ju hh jp b fi jv jw l jx jy">import spotipy<br/>import spotipy.util as util <br/>from spotipy.oauth2 import SpotifyClientCredentials<br/>from spotipy.oauth2 import SpotifyOAuth</span><span id="f500" class="jt ju hh jp b fi jz jw l jx jy">class Setup(object):<br/>    cid = ''<br/>    secret = ''<br/>    primaryUsername = ''<br/>    scope = "playlist-modify-public"</span><span id="752d" class="jt ju hh jp b fi jz jw l jx jy">def __init__(self, cid, secret, primaryUsername):<br/>        Setup.cid = cid<br/>        Setup.secret = secret<br/>        Setup.primaryUsername = primaryUsername</span><span id="468e" class="jt ju hh jp b fi jz jw l jx jy">def createAndReturnAuthenticatedSpotifyInstance(self):<br/>        token =       util.prompt_for_user_token(Setup.primaryUsername,Setup.scope,client_id=Setup.cid,client_secret=Setup.secret,redirect_uri='<a class="ae jj" href="http://localhost/'" rel="noopener ugc nofollow" target="_blank">http://localhost/'</a>) <br/>        spotify = spotipy.Spotify(auth=token)<br/>        return spotify</span><span id="2f57" class="jt ju hh jp b fi jz jw l jx jy">def initializeData(self, friendUsernames, spotify):<br/>        totalTracks = []<br/>        friendTrackData = []<br/>        for i in range(len(friendUsernames)):    <br/>            username = friendUsernames[i]<br/>            playlists = spotify.user_playlists(username)<br/>            userTracks = []<br/>            while playlists:<br/>                for i, playlist in enumerate(playlists['items']):           <br/>                    playlistTracks =   </span><span id="61c5" class="jt ju hh jp b fi jz jw l jx jy">                    spotify.playlist_tracks(playlist['uri'])<br/>                    trackItems = playlistTracks['items']    <br/>                    for k in range(len(trackItems)):<br/>                        trackItem = trackItems[k]<br/>                        track = trackItem['track']<br/>                        userTracks.append(track['uri'])<br/>                        totalTracks.append(track['uri'])<br/>                if playlists['next']:<br/>                    playlists = spotify.next(playlists)<br/>                else:<br/>                    playlists = None<br/>            dictOfData = {"user":username, "userTracks":userTracks}<br/>            friendTrackData.append(dictOfData)<br/>        return totalTracks, friendTrackData</span></pre><p id="f2ca" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">因此，在这个类中，我们初始化了Spotipy实例，获得了从本地主机promt读取和写入播放列表的用户权限，并创建了一个helper方法，该方法将收集我们自己的个人播放列表和公共播放列表中的所有曲目，我们稍后将填充这些曲目。</p><p id="e451" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在创建一个新的python文件，作为我们应用程序的主要驱动程序。</p><pre class="jk jl jm jn fd jo jp jq jr aw js bi"><span id="1cf1" class="jt ju hh jp b fi jv jw l jx jy">import spotipy<br/>import spotipy.util as util<br/>from spotipy.oauth2 import SpotifyClientCredentials<br/>from spotipy.oauth2 import SpotifyOAuth<br/>import SetupModule<br/>import math<br/>from collections import Counter</span><span id="ccaf" class="jt ju hh jp b fi jz jw l jx jy">cid = 'your cid'<br/>secret = 'your secret'<br/>username = 'username of user'<br/>friendUsernames = [#add in friend usernames in this format      </span><span id="4306" class="jt ju hh jp b fi jz jw l jx jy">                   'username' + , #]<br/>playlistLength = 100<br/>maxMatchFactor = len(friendUsernames)<br/>numFriends = len(friendUsernames)<br/>compilerId = 'spotify:playlist:identifier for playlist to fill'<br/>setupTool = SetupModule.Setup(cid,secret, username)<br/>spotify = setupTool.createAndReturnAuthenticatedSpotifyInstance()</span><span id="776c" class="jt ju hh jp b fi jz jw l jx jy"># find the most tracks that each individual liked the most<br/>def findIndividualFavorites():<br/>    allFavorites = []<br/>    personalShare = math.ceil((0.5 * playlistLength)/numFriends)<br/>    for i in range(len(friendTrackData)):<br/>        curUser = friendTrackData[i]<br/>        tracks = curUser['userTracks']<br/>        occurence_count = Counter(tracks) <br/>        mostPopular = occurence_count.most_common(personalShare)<br/>        temp = dict(mostPopular)<br/>        allFavorites += temp.keys()        <br/>    return allFavorites</span><span id="6089" class="jt ju hh jp b fi jz jw l jx jy"># add track operation can only support a list of max size 100 so if we have more track than that <br/># break total tracks into a bunch of size 99 chunks and add those iteratively<br/>def addTracksToPlaylist(tracksToAdd):  <br/>    if len(tracksToAdd) &gt; 99:<br/>        generator = chunks(tracksToAdd,99)<br/>        for value in generator:  <br/>            spotify.user_playlist_add_tracks(username, compilerId,   </span><span id="d274" class="jt ju hh jp b fi jz jw l jx jy">            value, position=None)<br/>    else:<br/>        spotify.user_playlist_add_tracks(username, compilerId, </span><span id="8269" class="jt ju hh jp b fi jz jw l jx jy">         tracksToAdd, position=None)</span><span id="c0ac" class="jt ju hh jp b fi jz jw l jx jy"># find songs that everyone likes </span><span id="92fb" class="jt ju hh jp b fi jz jw l jx jy">def findPopularAmongAll(matchFactors):<br/>    popularAmongAll = []<br/>    while( len(popularAmongAll) != math.ceil((0.5*playlistLength))):<br/>        for p in range( maxMatchFactor-1,0,-1):<br/>            if  len(matchFactors[p]) != 0 :<br/>                popularAmongAll.append(matchFactors[p].pop())<br/>                break<br/>    return popularAmongAll</span><span id="e852" class="jt ju hh jp b fi jz jw l jx jy">def sortByMatchFactor(totalTracksClean):<br/>    matchFactorCollection = {k: [] for k in range(maxMatchFactor)}<br/>     <br/>    for x in range(len(totalTracksClean)):<br/>        curTrack = totalTracksClean[x]<br/>        trackMatchFactor = getMatchFactor(curTrack)<br/>        for i in range(maxMatchFactor,0,-1):<br/>            if trackMatchFactor &gt; i:<br/>                matchFactorCollection[i].append(curTrack)<br/>                break<br/>    return matchFactorCollection</span><span id="ee24" class="jt ju hh jp b fi jz jw l jx jy"># match factor is the number of friend's who had this track in their # playlist</span><span id="afcd" class="jt ju hh jp b fi jz jw l jx jy">def getMatchFactor(the_track):<br/>    matchFactor = 0<br/>    for i in range(len(friendTrackData)):<br/>        curUser = friendTrackData[i]<br/>        tracks = curUser['userTracks']<br/>        if tracks.count(the_track) &gt; 0:<br/>            matchFactor += 1<br/>    return matchFactor</span><span id="3ec6" class="jt ju hh jp b fi jz jw l jx jy">def chunks(lst, n):<br/>    for i in range(0, len(lst), n):<br/>        yield lst[i:i + n]</span><span id="f822" class="jt ju hh jp b fi jz jw l jx jy">playlists = spotify.user_playlists(username)<br/>totalTracks, friendTrackData =  setupTool.initializeData(friendUsernames, spotify)<br/>totalTracksClean = list(dict.fromkeys(totalTracks))<br/>matchFactors = sortByMatchFactor(totalTracksClean)<br/>popularAmongAll = findPopularAmongAll(matchFactors)<br/>individualFavs = findIndividualFavorites()<br/>tracksOfPlaylist = popularAmongAll + individualFavs<br/>addTracksToPlaylist(tracksOfPlaylist)</span></pre><p id="2bba" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">首先，我们初始化开始与Spotify API通信所需的字段。填写顶部的字段后，我们使用setupTool从您选择的朋友的公共播放列表中获取所有曲目数据。</p><p id="ff6a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">目前，我正在创建一个100首曲目的播放列表，其中50首曲目来自具有广泛吸引力的歌曲，50首来自个人喜爱的歌曲，但这种算法可以根据需要轻松更改。</p><p id="489d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果您有任何问题，请留下您的评论，我可以帮助您诊断任何问题。</p></div></div>    
</body>
</html>