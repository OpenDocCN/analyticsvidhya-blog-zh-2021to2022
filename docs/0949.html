<html>
<head>
<title>Predicting Viral Stocks on Reddit with Machine Learning (Part II)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习预测Reddit上的病毒性股票(下)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-viral-stocks-on-reddit-with-machine-learning-part-ii-9386f4ca9c26?source=collection_archive---------19-----------------------#2021-02-07">https://medium.com/analytics-vidhya/predicting-viral-stocks-on-reddit-with-machine-learning-part-ii-9386f4ca9c26?source=collection_archive---------19-----------------------#2021-02-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7d5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jc">图形化编程&amp;用Luigi设计原子工作流</em></p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="cf31" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">简介</strong></h1><p id="30d4" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">这是<a class="ae kn" rel="noopener" href="/swlh/predicting-viral-stocks-on-reddit-with-machine-learning-cb442ae0bfdc">的第二部分，我的第一篇文章</a>是构建一个线性分类算法来预测可能在Reddit上疯传的股票。到目前为止，这个玩具算法挑选的股票在3天内上涨了10%-18%(免责声明:不是投资建议)，我将在未来一周继续更新它的表现。在第二部分中，我将重点关注使用Luigi将现有代码重构为健壮的原子工作流。(注意:第二部分更侧重于实际的Python技术，而我的第一篇文章更多的是关于数据科学。)</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="5add" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">概述</strong></h1><p id="9455" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">我在这篇文章中试图做的是:1)为原子工作流的重要性提供概念背景，2)提供如何用真实代码实现这一点的例子。本文中讨论的概念和技术并不局限于我们的小玩具分类问题，相反，我将它作为一个门户来分享我对这些技术的看法和经验。</p><h1 id="afde" class="jk jl hh bd jm jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh bi translated"><strong class="ak">达格</strong></h1><p id="7a94" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">在我们开始实施之前，让我们花点时间思考一下为什么我们想要这样做的一些更高层次的原因:</p><p id="829a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们构建的每个数据科学程序或应用程序都可以简化为一个简单的工作流:我们获取一些数据，对其应用一些函数，然后获取该函数的输出，并将其提供给其他函数，以获得一些最终输出。在图形表示中，它可能看起来像这样:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/dd9e1da5ab0de968c0294f3bb578641f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*boz-FCN2y_GtGuxD5tm3MA.png"/></div></div></figure><p id="f1a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意工作流是如何有清晰的箭头指示整个流程的功能(或任务)顺序的。在上面的例子中，图也不包含任何循环(或递归/循环引用)。我们称这样的工作流图为有向无环图(或DAG)。</p><p id="b7d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么我们想要图形化编程？因为通过将代码结构化为图的组件，它允许我们对整个程序有更高层次的概述，还允许我们将程序分成更小的独立部分，这提供了开发、测试以及部署的灵活性和简易性。我们可以一步一步地开发和测试每一个步骤，并使用管道或工作流包将它们缝合在一起，而不是一次构建所有东西，并从上到下运行所有东西。为什么要无环？效率。尝试用递归计算fib(100000 ),我打赌你会看到关于递归限制的警告，代码会拒绝继续运行。</p><h1 id="7c09" class="jk jl hh bd jm jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh bi translated">原子数</h1><p id="4c8d" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">工作流的一个非常微妙但重要但容易被忽略的问题是原子性。原子性意味着在下游任务开始工作之前，上游任务的输出必须100%完成。这可能不明显，但写入文件需要时间，有时在上游任务完成写入之前，输出文件可能已经存在于系统中，这意味着从上游任务寻找输出文件以开始其自身工作的下游任务将得到损坏的文件作为其输入，从而破坏整个工作流的完整性。这在文件很大的情况下尤其成问题(对于我们的玩具示例来说，这可能不是一个真正的问题，但是原子性应该始终被认为是最佳实践)。实现原子写入的一个简单方法是首先将输出写入一个临时文件，然后仅当写入完成时将临时文件重命名为输出文件。逻辑很简单，但差异可能很大。对于上下文管理器，原子写逻辑看起来像这样:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="5b3f" class="lk jl hh lg b fi ll lm l ln lo">@contextmanager<br/>def atomic_write():<br/>    with open(tmpfile, 'w') as f:<br/>         try:<br/>             yield f    # writing is performed to f<br/>         finally:<br/>             os.rename(tmpfile, outputfile)    # move temp to output</span></pre><p id="664a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">路易吉</p><p id="e456" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Luigi由Spotify开发，利用了图形化编程和原子性的概念。它是一个广泛使用的管道管理工具，在其目标类下具有健壮的内置原子写/读功能。在坚果壳中，Luigi工作流中的任务有输入需求和输出目标，分别表示来自上游的输入和到下游的输出。运行时，Luigi从最后一步开始，检查每个任务的输出文件是否存在，如果输出不存在，则只运行该任务。这是为了确保管道不会重复相同的工作。这种逻辑的缺点是它不会重新运行任何任务，除非您更改输出文件名(不可能覆盖)。Luigi工作流的DAG示例如下所示:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lp"><img src="../Images/06f223d02cf7f3ae73bec32a0a569020.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08ibQK4u8UTfHaxZEHI_8w.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">来源:https://luigi.readthedocs.io/en/stable/index.html<a class="ae kn" href="https://luigi.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="970d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Luigi中以原子方式编写文件的最简单和最基本的方法是利用在其基本目标类中实现的temporary_path上下文管理器，它在进入上下文时为文件编写创建一个临时路径，并在成功完成编写后将临时文件移动到输出路径。当然，这种基本实现有许多限制(例如，它不保留文件后缀，不支持目标目录)，但是目标类可以很容易地扩展以满足更高级的需求。对于这个例子，我们将使用基本实现。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lu"><img src="../Images/ca80fa0fc480b6181a120c26b6a54d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NdHl_qTLklop-qxFjtcTcw.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">来源:<a class="ae kn" href="https://github.com/spotify/luigi/blob/master/luigi/target.py" rel="noopener ugc nofollow" target="_blank">https://github . com/Spotify/Luigi/blob/master/Luigi/target . py</a></figcaption></figure><p id="d662" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于Luigi的更多细节，请参考他们的文档。写得很好。</p></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="7253" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">实现</strong></h1><p id="9797" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">现在我们对DAG和原子性有了一些背景了解，我们可以开始将代码重构到Luigi管道中。回想一下，我们的预测系统主要由以下步骤组成:</p><ol class=""><li id="6ac1" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb ma mb mc md bi translated">下载历史热门和热门Reddit提交数据</li><li id="70c3" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">预处理下载的数据以创建标签和组合文本列</li><li id="3eaf" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">感知器和Pegasos训练和超参数调整</li><li id="cd33" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">下载最新的Reddit提交数据</li><li id="e9fe" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">预处理下载的数据以合并文本列</li><li id="c147" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb ma mb mc md bi translated">使用优化模型中的最佳参数进行预测，并从正面预测中提取股票代码</li></ol><p id="8999" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们的DAG可能看起来像这样:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mj"><img src="../Images/dc15eec09031b1a61acb9b179b691c55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V8TkFjx0h07bt6M6ayCB4A.png"/></div></div></figure><p id="b9b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Luigi scheduler看来，它是这样的:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mk"><img src="../Images/aecd9d5a15720620377a7425d17a9fbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XORs5rg841xxRyJ80EeBHA.png"/></div></div></figure><p id="c614" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，Luigi以相反的顺序检查已完成的任务，从最后一个阶段开始，一旦它看到Predict没有完成，它就会寻找它的依赖项，在本例中是PreProcessPredictData和Train_Classifier，如果没有完成，它会继续沿着链向上，逐个寻找它们的依赖项。最终结果是，Luigi将确保所有要求的任务只完成一次。</p><p id="1137" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结构</strong></p><p id="8ff0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将这个管道分为三个主要任务:tasks.data、tasks.train和tasks.predict。在data中，我将处理下载和预处理任务，在train中，我将处理算法训练，在predict中，我将基于训练中的优化参数运行预测。还要注意，在linear_classifier和viral_stock_predictor目录下，我都有__init__和__main__两个目录，这是因为我将它们视为独立的模块。由于我们上次在main中有相当多的代码行来训练我们的算法，所以将整个算法部分重构为一个模块要容易得多，在我们的任务中，我们可以简单地告诉Luigi用命令行操作来执行那个模块。这使得用户更容易实际运行程序。因此，在我们重组之后，整个项目目录看起来像这样:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ml"><img src="../Images/bbca85ea0986eeca3bd29b2f7ffa51f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*FQijpIjaLkN98cyJmMb8KA.png"/></div></figure><p id="afd3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的主模块是viral_stock_predictor，在该模块中，在任务下，我们使用命令行参数运行linear_classifier模块。linear_classifier下的cli.py看起来像这样，这样就可以实现:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="3f1d" class="lk jl hh lg b fi ll lm l ln lo">def main():<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument('-ip', '--inputpath')<br/>    parser.add_argument('-pp', '--predictpath')<br/>    parser.add_argument('-mp', '--modelpath')<br/>    parser.add_argument('-op', '--outputpath')<br/>    parser.add_argument('-t', '--train', action='store_true', default=False)<br/>    args = parser.parse_args()<br/>    if args.train:<br/>        train(args.inputpath, args.modelpath)<br/>    else:<br/>        predict(args.predictpath, args.modelpath, args.outputpath)</span></pre><p id="94ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在__mian__中，我们简单地做:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="449e" class="lk jl hh lg b fi ll lm l ln lo">from .cli import main</span><span id="43c8" class="lk jl hh lg b fi mm lm l ln lo">if __name__ == '__main__':<br/>    main()</span></pre><p id="572f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以如果我们逃跑</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="2213" class="lk jl hh lg b fi ll lm l ln lo">python -m linear_classifier -t, --inputpath, 'data/traindata.csv', --modelpath, 'data/model.pkl'</span></pre><p id="f05c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将:</p><ul class=""><li id="90b7" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb mn mb mc md bi translated">从traindata.csv中取出预处理后的数据；</li><li id="5ed8" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">提取词袋特征向量；</li><li id="00bc" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">基于感知器和Pegasos算法优化theta和theta _ 0；</li><li id="d45a" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">调整超参数以找到最佳的theta和theta _ 0；和</li><li id="f7ca" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">将其另存为model.pkl以备将来使用。</li></ul><p id="568a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，如果我们跑</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="fe11" class="lk jl hh lg b fi ll lm l ln lo">python -m linear_classifier --predictpath, 'data/newsubs.csv', --modelpath, 'data/model.pkl', --outpath, 'data/predictions.txt'</span></pre><p id="8b45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将:</p><ul class=""><li id="9063" class="lv lw hh ig b ih ii il im ip lx it ly ix lz jb mn mb mc md bi translated">获取预处理的新提交和先前保存的模型参数；</li><li id="111e" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">对所有提交的材料进行分类；</li><li id="99d5" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">找到所有带有正面标签的投稿；和</li><li id="c74e" class="lv lw hh ig b ih me il mf ip mg it mh ix mi jb mn mb mc md bi translated">从它们中提取一个tickers列表到一个. txt文件中。</li></ul><p id="ad29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个模块经过适当的重构后，我们终于可以继续编写Luigi管道了。</p><p id="1d70" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">写一个Luigi任务</strong></p><p id="fe69" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Luigi管道基本上是按照一定的DAG以有序的方式缝合在一起的多个任务。构建管道需要(a)设计我们的DAG ,( b)在DAG中编写所有任务。我们已经完成了(a ),现在让我们继续实际编写任务。</p><p id="4bc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Luigi任务是类对象，我们可以基于许多预定义的任务类对其进行扩展。在这个例子中，我们将使用两个任务类:task和ExternalProgramTask。</p><p id="b316" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">路易吉。任务是最基本的任务类，它有几个元素:参数、需求、输出和运行。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es mo"><img src="../Images/2e9014ca02bb440497ea1cb6739cec27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dEUVgm1WL_H1qRDzaaHVcA.png"/></div></div><figcaption class="lq lr et er es ls lt bd b be z dx translated">来源:https://luigi.readthedocs.io/en/stable/tasks.html</figcaption></figure><p id="782a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们简单地在MyTask类的实例上调用build时:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="0513" class="lk jl hh lg b fi ll lm l ln lo">luigi.build([MyTask()])</span></pre><p id="3c4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">将调用run()方法，并将结果写入output()，output()是一个类似文件的对象，其属性path是我们所需的输出文件路径。</p><p id="fa63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的示例中，我们将像这样编写DownloadData任务:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="2178" class="lk jl hh lg b fi ll lm l ln lo">class DownloadData(Task):<br/>    __version__ = "0.0.1"<br/>    LOCAL_ROOT = os.path.abspath('data/raw')<br/>    ranked_by = Parameter()<br/>    limit = Parameter()<br/>    time_filter = Parameter('month')<br/><br/>    def output(self):<br/>        return luigi.LocalTarget(os.path.join(self.LOCAL_ROOT, str(self.limit)+'_'+self.ranked_by+'-'+self.time_filter)+'.csv'))<br/><br/>    def run(self):<br/>        # atomically write to output file with self.temp_output_path<br/>        with self.output().temporary_path() as self.temp_output_path:<br/>            download_data(ranked_by=self.ranked_by, fp=self.temp_output_path, limit=self.limit, time_filter=self.time_filter)</span></pre><p id="4fe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，它没有任何要求，因为这是我们的第一个任务，它不依赖于任何其他任务。还要注意，我在输出文件路径中包含了参数值，这是为了解决我上面提到的问题，即，如果输出路径只是“downloadeddata.csv”，只要downloadeddata.csv文件存在，任务就不会再次运行，即使我们将参数从hot更改为top，或者增加或减少限制。这显然很糟糕。在输出路径中手动包含参数值是解决这个问题的一种方法。解决这一问题的更高级的技术称为加盐图，它不仅考虑任务本身的参数，还考虑每个父任务的参数，以及参数以外的因素(即运行函数的实现)，方法是在输出路径中包含__version__ class属性，并使用某种加盐算法对其进行哈希运算。它降低了人类的可读性，但却是一种更好的方法。加盐输出可能看起来像这样:</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mp"><img src="../Images/1a8fe7148cccf46855d450b3e20b0565.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*OvmUzGva2RBmgzJeTEqJwA.png"/></div></figure><p id="d381" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个例子，我们将坚持在输出名称中添加参数的基本方法。</p><p id="19e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预处理数据将需要下载数据作为其输入，因此它看起来像这样:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="a35e" class="lk jl hh lg b fi ll lm l ln lo">class PreProcessTrainData(Task):<br/>    __version__ = "0.0.1"<br/>    LOCAL_ROOT = os.path.abspath('data/training')<br/>    threshold = Parameter()<br/>    limit = Parameter(1000)<br/>    time_filter = Parameter('month')<br/><br/>    def requires(self):<br/>        # input include hot submissions as well as top submissions Data from DownloaData<br/>        return {'hot_subs': self.clone(DownloadData, ranked_by = 'hot'),<br/>                'top_subs': self.clone(DownloadData, ranked_by= 'top')}<br/><br/>    def output(self):<br/>        return luigi.LocalTarget(os.path.join(self.LOCAL_ROOT, self.limit+'_'+self.threshold+'_'+'self.time_filter'+'_'+'processed.csv'))<br/><br/>    def run(self):<br/>        hot_subs = pre_processing(infp=self.input()['hot_subs'].path, threshold=self.threshold)<br/>        top_subs = pre_processing(infp=self.input()['top_subs'].path, threshold=self.threshold)<br/>        # atomically write to output file with self.temp_output_path<br/>        with self.output().temporary_path() as self.temp_output_path:<br/>            combine_subs(hot_subs, top_subs, self.temp_output_path)</span></pre><p id="656b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Luigi的智能特性之一是self.clone()方法，它会自动将该任务的相同参数值传递给任何共享参数所需的上游任务，从而消除了指定所有参数的需要。换句话说，只需调用:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="a732" class="lk jl hh lg b fi ll lm l ln lo">self.clone(DownloadData)</span></pre><p id="e6f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Luigi会自动将limit=1000和time_filter='month '传递到DownloadData()中。这是一个非常好的特性，它使得参数管理变得更加容易。</p><p id="4758" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">外部程序任务</strong></p><p id="d4f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于训练和预测任务，我想介绍另一个名为ExternalProgramTask的任务类。我们仍然可以通过指定linear_classifier模块中需要在run方法下执行的每个函数来处理基本的任务类，但是这很混乱，并且违背了将它们重构到自己的模块中的目的。ExternalProgramTask好得多，也干净得多，因为它创建了一个子流程，传入了所有参数，并作为一个模块运行我们的训练/预测算法(但在相同的python环境中)。必须重写program_args()方法，以指定要传递给子流程的参数。在我们的案例中:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="2511" class="lk jl hh lg b fi ll lm l ln lo">class TrainClassifier(ExternalProgramTask):<br/>    __version__ = "0.0.1"<br/>    LOCAL_ROOT = os.path.abspath("model")<br/>    threshold = Parameter(25000)<br/>    limit = Parameter()<br/>    time_filter = Parameter("month")<br/><br/>    def requires(self):<br/>        return self.clone(data.PreProcessTrainData)<br/><br/>    def output(self):<br/>        return luigi.LocalTarget(<br/>            os.path.join(self.LOCAL_ROOT, self.limit+self.threshold+self.time_filter+"model_results.p")<br/>        )<br/><br/>    def program_args(self):<br/>        # use self.temp_output_path for atomic write<br/>        return (<br/>            [<br/>                "python",<br/>                "-m",<br/>                "linear_classifier",<br/>                "-t",<br/>                "--inputpath",<br/>                self.input().path,<br/>                "--modelpath",<br/>                self.temp_output_path,<br/>            ]<br/><br/>    def run(self):<br/>        with self.output().temporary_path() as self.temp_output_path:<br/>            super().run()</span></pre><p id="7575" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一个重要的注意事项是，我们必须将临时路径作为参数传递给子进程，以便子进程写入临时文件，Luigi可以在完全完成后将临时文件移动到所需的输出路径。这也是为了确保原子性。关于如何实现super.run()函数的更多细节，请参考Luigi关于ExternalProgramTask的文档。</p><p id="2fb9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以更进一步，通过使用ExternalPythonProgramTask和指定子环境的virtualenv的路径，在自己的Python环境中构建一个完整的microscience环境，该环境具有自己的依赖项。但是对于我们的特定用例来说，这是不必要的，因为我们对linear_classifier模块没有额外的依赖。</p><p id="8f16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">预测任务可以类似地完成，只需对program_args稍作修改。</p><h1 id="ebc3" class="jk jl hh bd jm jn ko jp jq jr kp jt ju jv kq jx jy jz kr kb kc kd ks kf kg kh bi translated">CLI </h1><p id="b2bb" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">最后，我们已经设计了我们的工作流，重新构建了我们的项目目录，将整个linear_classifier部分重构为一个模块，并编写了我们的所有任务，现在我们可以将以下内容添加到viral_stock_predictor模块下的cli.py中:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="434d" class="lk jl hh lg b fi ll lm l ln lo">def main():<br/>    parser = argparse.ArgumentParser()<br/>    parser.add_argument("-l", "--limit", default=1000)<br/>    parser.add_argument("-thresh", "--threshold", default=25000)<br/>    parser.add_argument("-tfilter", "--time_filter", default="month")<br/>    args = parser.parse_args()<br/>    build(<br/>        [<br/>            predict.Predict(<br/>                threshold=int(args.threshold),<br/>                limit=int(args.limit),<br/>                time_filter=args.time_filter,<br/>            )<br/>        ],<br/>        local_scheduler=True,<br/>   )</span></pre><p id="c1df" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用一行简单的代码运行整个工作流程:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="3c66" class="lk jl hh lg b fi ll lm l ln lo">python -m viral_stock_predictor</span></pre><p id="91f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将触发上述所有步骤，并完成每个未完成的任务，最终输出是一个. txt文件，其中记录了所有有前途的tickers和最相关的单词。假设我们已经训练了我们的分类器，并且只希望使用它来进行预测，那么任务流程将如下所示:</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="ab6e" class="lk jl hh lg b fi ll lm l ln lo">DEBUG: Checking if Predict(threshold=25000, limit=1000, time_filter=month, notbinarize=False) is complete</span><span id="dbcb" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Checking if PreProcessPredictData(ranked_by=new, limit=1000) is complete</span><span id="0291" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Checking if TrainClassifier(threshold=25000, limit=1000, time_filter=month, notbinarize=False) is complete</span><span id="91bd" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   Predict_1000_False_25000_39ebda1003   has status   PENDING</span><span id="8412" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   TrainClassifier_1000_False_25000_39ebda1003   has status   DONE</span><span id="ae7e" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Checking if DownloadData(ranked_by=new, limit=1000, time_filter=month) is complete</span><span id="5cc0" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   PreProcessPredictData_1000_new_b4a0ee8de2   has status   PENDING</span><span id="ed9f" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   DownloadData_1000_new_month_1293b4de6b   has status   PENDING</span><span id="ebe2" class="lk jl hh lg b fi mm lm l ln lo">INFO: Done scheduling tasks</span><span id="c3e6" class="lk jl hh lg b fi mm lm l ln lo">INFO: Running Worker with 1 processes</span><span id="5397" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Asking scheduler for work...</span><span id="ecd3" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Pending tasks: 3</span><span id="ed23" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) running   DownloadData(ranked_by=new, limit=1000, time_filter=month)</span><span id="2d7e" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) done      DownloadData(ranked_by=new, limit=1000, time_filter=month)</span><span id="df47" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: 1 running tasks, waiting for next task to finish</span><span id="d9b0" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   DownloadData_1000_new_month_1293b4de6b   has status   DONE</span><span id="0ddb" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Asking scheduler for work...</span><span id="392c" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Pending tasks: 2</span><span id="e15b" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) running   PreProcessPredictData(ranked_by=new, limit=1000)</span><span id="16ef" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) done      PreProcessPredictData(ranked_by=new, limit=1000)</span><span id="520d" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: 1 running tasks, waiting for next task to finish</span><span id="6135" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   PreProcessPredictData_1000_new_b4a0ee8de2   has status   DONE</span><span id="a9ce" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Asking scheduler for work...</span><span id="4060" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Pending tasks: 1</span><span id="a1b4" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) running   Predict(threshold=25000, limit=1000, time_filter=month, notbinarize=False)</span><span id="09b8" class="lk jl hh lg b fi mm lm l ln lo">INFO: Running command: python -m linear_classifier --predictpath /Users/abc/PycharmProjects/reddit_prediction/data/predicting/processed_02072021_10_test.csv --modelpath /Users/abc/PycharmProjects/reddit_prediction/model/model_results_1000_25000.p --outputpath /Users/abc/PycharmProjects/reddit_prediction/prediction/prediction_results_1000_25000_02072021_10.txt-luigi-tmp-0776734234</span><span id="2634" class="lk jl hh lg b fi mm lm l ln lo">INFO: [pid 4300] Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) done      Predict(threshold=25000, limit=1000, time_filter=month, notbinarize=False)</span><span id="fe75" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: 1 running tasks, waiting for next task to finish</span><span id="6b31" class="lk jl hh lg b fi mm lm l ln lo">INFO: Informed scheduler that task   Predict_1000_False_25000_39ebda1003   has status   DONE</span><span id="70ce" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Asking scheduler for work...</span><span id="36b9" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: Done</span><span id="b283" class="lk jl hh lg b fi mm lm l ln lo">DEBUG: There are no more tasks to run at this time</span><span id="0519" class="lk jl hh lg b fi mm lm l ln lo">INFO: Worker Worker(salt=684773548, workers=1, host=abc.local, username=abc, pid=4300) was stopped. Shutting down Keep-Alive thread</span><span id="ac29" class="lk jl hh lg b fi mm lm l ln lo">INFO:</span><span id="6fd6" class="lk jl hh lg b fi mm lm l ln lo">===== Luigi Execution Summary =====</span><span id="951a" class="lk jl hh lg b fi mm lm l ln lo">Scheduled 4 tasks of which:</span><span id="33d6" class="lk jl hh lg b fi mm lm l ln lo">* 1 complete ones were encountered:</span><span id="032f" class="lk jl hh lg b fi mm lm l ln lo">- 1 TrainClassifier(...)</span><span id="aad3" class="lk jl hh lg b fi mm lm l ln lo">* 3 ran successfully:</span><span id="40bf" class="lk jl hh lg b fi mm lm l ln lo">- 1 DownloadData(ranked_by=new, limit=1000, time_filter=month)</span><span id="6c86" class="lk jl hh lg b fi mm lm l ln lo">- 1 PreProcessPredictData(ranked_by=new, limit=1000)</span><span id="dfc1" class="lk jl hh lg b fi mm lm l ln lo">- 1 Predict(...)</span><span id="7180" class="lk jl hh lg b fi mm lm l ln lo">This progress looks :) because there were no failed tasks or missing dependencies</span></pre></div><div class="ab cl jd je go jf" role="separator"><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji jj"/><span class="jg bw bk jh ji"/></div><div class="ha hb hc hd he"><h1 id="d905" class="jk jl hh bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated"><strong class="ak">结论</strong></h1><p id="6091" class="pw-post-body-paragraph ie if hh ig b ih ki ij ik il kj in io ip kk ir is it kl iv iw ix km iz ja jb ha bi translated">这次我们做了很多事情，现在这个程序使用起来简单可靠，即使对于不熟悉python的用户来说也是如此。Luigi不是唯一的管道管理工具，但是原子性和图形化编程的概念才是真正的要点。</p></div></div>    
</body>
</html>