<html>
<head>
<title>How to avoid BroadcastNestedJoin in Spark</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何避免Spark中的广播式加入</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-avoid-broadcastnestedjoin-in-spark-372d20b8e82d?source=collection_archive---------5-----------------------#2021-03-31">https://medium.com/analytics-vidhya/how-to-avoid-broadcastnestedjoin-in-spark-372d20b8e82d?source=collection_archive---------5-----------------------#2021-03-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2ba7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">连接是Spark作业中至关重要的操作之一。Spark支持以下类型的连接</p><ol class=""><li id="d091" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">内部连接</li><li id="4d28" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">左侧外部</li><li id="b807" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">右侧外部</li><li id="5fbb" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">全外</li><li id="040b" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">左反</li><li id="e93f" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">左半部</li></ol><blockquote class="jq jr js"><p id="700f" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">在本文中，我们将探讨广播嵌套连接性能问题以及如何避免它。</p></blockquote><p id="0f00" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每一个都有其使用案例。基于Spark成本的优化器根据各种参数选择最佳连接策略，例如:</p><ul class=""><li id="68af" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jx ji jj jk bi translated">连接类型</li><li id="1fae" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">连接条件(equi，between等。)</li><li id="f8fc" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">数据的大小</li><li id="3226" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">暗示</li><li id="334c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">Spark配置，如spark . SQL . autobroadcastjointhreshold</li><li id="bbb5" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">还有更多…</li></ul><p id="34e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于上述参数，Spark选择下面列出的一种连接策略:</p><ul class=""><li id="5c86" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jx ji jj jk bi translated">广播散列连接</li><li id="ae20" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">无序散列连接</li><li id="a927" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">无序排序-合并连接</li><li id="b36c" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jx ji jj jk bi translated">广播嵌套循环连接</li></ul><blockquote class="jq jr js"><p id="e879" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">更多信息，请参考下面的链接。</p></blockquote><div class="jy jz ez fb ka kb"><a href="https://github.com/apache/spark/blob/master/sql/core/src/main/scala/org/apache/spark/sql/execution/SparkStrategies.scala" rel="noopener  ugc nofollow" target="_blank"><div class="kc ab dw"><div class="kd ab ke cl cj kf"><h2 class="bd hi fi z dy kg ea eb kh ed ef hg bi translated">阿帕奇/火花</h2><div class="ki l"><h3 class="bd b fi z dy kg ea eb kh ed ef dx translated">Apache Spark——用于大规模数据处理的统一分析引擎</h3></div><div class="kj l"><p class="bd b fp z dy kg ea eb kh ed ef dx translated">github.com</p></div></div><div class="kk l"><div class="kl l km kn ko kk kp kq kb"/></div></div></a></div><p id="b7c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于大多数场景，spark选择了正确的连接策略，但是也有一些场景，选择的策略并不是最好的。我们将在本文中讨论其中的一个问题以及修复它的方法。</p><p id="88d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">出于演示目的，我将使用下面的数据集。</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="kx ky di kz bf la"><div class="er es kr"><img src="../Images/9e59c0332a47ec031864050b7516a594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebFn4JoEoqKIVPZ_6hGiew.png"/></div></div><figcaption class="lc ld et er es le lf bd b be z dx translated">员工和奖金表</figcaption></figure><p id="7827" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用途</strong>:计算员工奖金。</p><p id="080e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">如何:</strong>根据<strong class="ig hi">min _ salary≤salary≤max _ salary</strong>加入员工和奖金表</p><p id="28a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">预期结果</strong>:在最佳时间计算奖金。</p><p id="1e78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了获得更好的性能，因为奖金表很小，所以它应该适合广播散列连接。</p><p id="7d29" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们将数据加载到数据帧中，然后使用between函数将它们连接起来。下面是它的代码片段。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div><figcaption class="lc ld et er es le lf bd b be z dx translated">加载员工和奖金表数据</figcaption></figure><p id="eecd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是Spark准备的物理计划，其中使用了“BroadcastNestedLoopJoin”连接策略。这很慢。我们将通过下面的例子来理解这一点</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="389f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> Ex </strong>:在实时场景中，假设一个分区有100K行，广播表有20K条记录。</p><blockquote class="jq jr js"><p id="c673" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">球部分估计:Spark中优化分区的大小是100 MB(近似值)。对于12列和100K条记录，文件大小为104 MB)</p></blockquote><p id="a57e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以通过上面的计算，对于每个分区，BroadcastNextedLoopJoin将迭代2000000000次。这可能会导致性能问题。这里我们已经考虑到所有分区是均匀分布的(可能在这一步之前，我们必须执行其他的join或group by或window操作)。并不总是如此。</p><p id="bc6f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们使用类似如下的连接条件，将使用相同的连接策略:</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="9cdf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们像下面这样在连接中添加一个相等的条件，Spark将使用广播散列连接。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="0ec9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们如何得到这个新列，我们可以在连接条件中使用它，它不影响连接结果。</p><p id="a5aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们尝试在两个数据框架中添加默认列，并在连接条件中使用它。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="73ab" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从物理计划可以看出，Spark在查询计划中忽略了这个新列，这可能是由于一些内部优化。</p><p id="c650" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们尝试在现有列的帮助下构建一个常量列。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="3021" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们已经使用了salary列并将其乘以0，并在join中使用了结果列。现在Spark在用BroadcastHashJoin。</p><p id="72e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们在数据中没有一个数字列。我们可以创建一个带有一条记录的虚拟数据帧，并与两个数据帧交叉连接。</p><figure class="ks kt ku kv fd kw"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="662c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码中，Spark在连接中考虑了temp_clm。它将BroadcastNestedLoopJoin转换为BroadcastHashJoin。由于交叉连接是对一条记录执行的，其影响可以忽略不计。</p><p id="2a73" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以根据自己的方便程度使用任何方法，并强制spark使用BroadcastHash join，这比BroadcastNestedLoopJoin要快。</p><p id="b314" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请分享你对此的想法，快乐学习。</p><blockquote class="jq jr js"><p id="d7eb" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">“一旦你停止学习，你就开始死亡”<br/> —阿尔伯特·爱因斯坦</p></blockquote></div></div>    
</body>
</html>