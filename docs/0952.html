<html>
<head>
<title>A simple intro to keras for tensorflow 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">tensorflow 2的keras简单介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-simple-intro-to-keras-for-tensorflow-2-330fd35a0c9e?source=collection_archive---------22-----------------------#2021-02-07">https://medium.com/analytics-vidhya/a-simple-intro-to-keras-for-tensorflow-2-330fd35a0c9e?source=collection_archive---------22-----------------------#2021-02-07</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d98ca0e453be2716c4da187418c6961b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lFqYLNv0L_05Flk2mJ7ZSw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">tensorflow 2船上有keras！<strong class="bd it"> tf.keras </strong></figcaption></figure><p id="a1f7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">T2的Keras项目T3的目标是为人类创造一个简单的编程界面。tensorflow现在在其自己的库中包含了一个keras版本，这一事实可以作为这一成功的证据。</p><p id="0fd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个关于Keras工作流的简要介绍性指南，特别是针对模型设计的三种API风格。见此<a class="ae js" href="https://towardsdatascience.com/3-ways-to-create-a-machine-learning-model-with-keras-and-tensorflow-2-0-de09323af4d3" rel="noopener" target="_blank">其他职位</a>一步一步的教程。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="af12" class="ka kb hh bd it kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">Keras工作流程</h1><p id="bd59" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">在Keras中，训练ML模型应该感觉类似于使用sklearn分类器。API提供了设计、编译、拟合和评估简单和复杂机器学习架构的方法。Keras的美源于它的简单。培训流程的典型结构是:</p><ol class=""><li id="56e2" class="lc ld hh iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated">设计模型架构</li><li id="87fa" class="lc ld hh iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">使用优化器、损失和度量选择来编译模型</li><li id="3e06" class="lc ld hh iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated">为给定数量的时期训练模型</li></ol><p id="2345" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一些真实的代码来看看这个结构的运行情况(来自<a class="ae js" href="https://www.tensorflow.org/overview" rel="noopener ugc nofollow" target="_blank"> tensorflow网站</a>):</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="76eb" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的例子中，使用了一个非常简单的模型架构。根据所需的复杂程度，有三种设计模型的方式(所谓的API风格):</p><h2 id="6032" class="lw kb hh bd it lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated"><a class="ae js" href="https://www.tensorflow.org/guide/keras/sequential_model" rel="noopener ugc nofollow" target="_blank">顺序API </a></h2><p id="ef7b" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">在这种方法中，我们首先实例化一个<em class="mk">TF . keras . models . sequential</em>类，然后我们简单地添加我们想要的所有层来创建所需的架构。下面的例子是一个简单的卷积架构。</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="92dd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">定义输入大小后，所有后续大小都将从应用的操作中推断出来。在本例中，最大池层将图像大小减半，而卷积层由于没有填充，将x和y轴上的大小减少了每侧内核大小的一半。</p><p id="eb24" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了验证模型结构，可以使用<em class="mk"> model.summary() </em>命令。它提供了以下摘要:</p><pre class="lq lr ls lt fd ml mm mn mo aw mp bi"><span id="aed4" class="lw kb hh mm b fi mq mr l ms mt">Model: "Keras Test CNN"<br/>_________________________________________________________________<br/>Layer (type)                 Output Shape              Param #   <br/>=================================================================<br/>conv2d (Conv2D)              (None, 26, 26, 32)        320       <br/>_________________________________________________________________<br/>max_pooling2d (MaxPooling2D) (None, 13, 13, 32)        0         <br/>_________________________________________________________________<br/>conv2d_1 (Conv2D)            (None, 11, 11, 64)        18496     <br/>_________________________________________________________________<br/>max_pooling2d_1 (MaxPooling2 (None, 5, 5, 64)          0         <br/>_________________________________________________________________<br/>conv2d_2 (Conv2D)            (None, 3, 3, 64)          36928     <br/>_________________________________________________________________<br/>flatten (Flatten)            (None, 576)               0         <br/>_________________________________________________________________<br/>dense (Dense)                (None, 64)                36928     <br/>_________________________________________________________________<br/>dense_1 (Dense)              (None, 10)                650       <br/>=================================================================<br/>Total params: 93,322<br/>Trainable params: 93,322<br/>Non-trainable params: 0<br/>_________________________________________________________________</span></pre><p id="87dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看<em class="mk">“输出形状”</em>列，我们可以确认我们的计算，因为每个<em class="mk"> conv2d </em>层将x和y维度减少2 (kernelsize！= 3)并且每个<em class="mk"> max_pooling2d </em>层将它们平分。你是否注意到输出图形的第一个尺寸总是<em class="mk">无</em>？这是因为它将在编译时由batchsize设置。</p><p id="9095" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">最后一列<em class="mk">“Param #”</em>表示该层添加到模型的可训练参数的数量。这可能是评估模型复杂性的一个非常重要的指标。</p><p id="95ed" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">尽管顺序风格使用起来非常方便，但它不允许构建更复杂的体系结构，例如剩余网络。为了允许更多的控制，可以使用函数式API。</p><h2 id="27c8" class="lw kb hh bd it lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated"><a class="ae js" href="https://www.tensorflow.org/guide/keras/functional" rel="noopener ugc nofollow" target="_blank">功能API </a></h2><p id="b258" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">层可以被看作函数或可调用函数，它们接受一个张量并产生一个张量。按照这种逻辑，机器学习模型也可以通过将它们的返回值相互馈送来从链接层创建。通过这样做，我们创建了一个有向图，tensordata沿着这个有向图流动。</p><p id="547b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这允许模型设计者构建剩余连接、共享层，甚至多个输入或输出。在下面的例子中，定义了一个简单的剩余网络。</p><figure class="lq lr ls lt fd ii"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="0403" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如第9行所示，模块2的输出是输入x和两个卷积层的结果之和。这不可能用顺序方法来实现。</p><p id="4daf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意你如何定义一个<em class="mk">角。输入</em>项，非常类似于<em class="mk"> tf.placeholder. </em>最后，模型实例由输入层和输出层构成，输出层位于定义图的叶节点。</p><h2 id="60ce" class="lw kb hh bd it lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated"><a class="ae js" href="https://www.tensorflow.org/guide/keras/custom_layers_and_models" rel="noopener ugc nofollow" target="_blank">子类化</a></h2><p id="ded1" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">复杂性的高潮是子类化。这种OOP模式允许你实现你自己的层，并修改你的模型的每一个行为。这可以通过编写一个扩展<em class="mk"> keras.layers.Layer </em>并实现所有必要方法的类来实现。</p><blockquote class="mu mv mw"><p id="7d2f" class="iu iv mk iw b ix iy iz ja jb jc jd je mx jg jh ji my jk jl jm mz jo jp jq jr ha bi translated">您可以将子类化与顺序或函数API风格结合起来！</p></blockquote><p id="7d66" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在实现一个定制层之后，您可以简单地将它链接到您的功能/顺序风格模型中，并使用默认的方法来实现！</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="ae73" class="lw kb hh bd it lx ly lz kf ma mb mc kj jf md me kn jj mf mg kr jn mh mi kv mj bi translated">结论</h2><p id="73e3" class="pw-post-body-paragraph iu iv hh iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr ha bi translated">总而言之，Keras工作流使得在tensorflow中设计、训练和评估模型变得很容易。通过使用函数式API和子类化，可以实现更复杂的架构。</p><p id="5ec9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢阅读！如果你喜欢这个，请鼓掌几下:)</p></div></div>    
</body>
</html>