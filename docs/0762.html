<html>
<head>
<title>Exploiting the Floyd-Steinberg Algorithm for Dithering Images in R</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">利用Floyd-Steinberg算法在R</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploiting-the-floyd-steinberg-algorithm-for-image-dithering-in-r-c19c8008fc99?source=collection_archive---------5-----------------------#2021-01-30">https://medium.com/analytics-vidhya/exploiting-the-floyd-steinberg-algorithm-for-image-dithering-in-r-c19c8008fc99?source=collection_archive---------5-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/64173cb60b930690c46511de92336957.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*0DiyXcJ7P86msiI-tEz1wA.png"/></div><figcaption class="im in et er es io ip bd b be z dx translated">图片来自<a class="ae iq" href="https://www.rawpixel.com/image/537402/free-illustration-image-van-gogh-vincent-van-gogh-painting" rel="noopener ugc nofollow" target="_blank">rawpixel.com</a></figcaption></figure><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="fbf6" class="ja jb hi iw b fi jc jd l je jf">(statistics == programming)</span><span id="4512" class="ja jb hi iw b fi jg jd l je jf">&gt; TRUE</span></pre><p id="75c1" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">回到2019年，当我在莱顿大学开始攻读统计科学硕士学位时，我根本不知道上述表达式可能会评估为<code class="du kf kg kh iw b">TRUE</code>。有教育科学背景的我，在SPSS的语法窗口编辑一些代码的时候，总觉得自己是一个真正的程序员。嗯……没有。在我的第一个学期，我注册了“R统计计算”这门课程，在这门课程中，我学习了统计编程的基础知识。这些课程被证明是我参加过的最有用的课程之一，在这些课程中，我真正对R作为一种(统计)编程语言产生了一些喜爱。现在，仅仅一年半之后，我在Medium上写了我的第一篇文章——并非完全偶然——关于用于抖动图像的Floyd-Steinberg算法:这是对我的第一个真正的编程任务的致敬！</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><h2 id="4668" class="ja jb hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated"><strong class="ak">图像抖动:一个简短的解释</strong></h2><p id="2b06" class="pw-post-body-paragraph jh ji hi jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">好了，图像抖动。很可能你从未听说过它。虽然这不是Medium上第一篇文章最吸引人的主题，但它的名字和工作算法都很酷。它还有一些相当不错的基本统计概念，我将在这篇博文的第二部分中讨论。所以，让我们潜入图像抖动的丰富多彩的世界！</p><blockquote class="ln lo lp"><p id="f06b" class="jh ji lq jj b jk jl jm jn jo jp jq jr lr jt ju jv ls jx jy jz lt kb kc kd ke hb bi translated">抖动用于在有限的调色板中创建图像的“颜色深度”的幻觉——这种技术也被称为颜色量化<em class="hi"> ~维基百科</em></p></blockquote><p id="c7d7" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">换句话说:我们可以使用抖动来使图片看起来仍然很棒，尽管使用了较少的颜色。这在某种意义上是通过愚弄我们的大脑来实现的。为了揭开这个令人眼花缭乱的把戏，有一些关于图片和标准RGB调色板的基本知识是很有见地的。有趣的事实:抖动的图像通常通过小圆点或点来识别。就像梵高那顶惊人的草帽！</p><h2 id="118e" class="ja jb hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated">RGB调色板</h2><p id="88d6" class="pw-post-body-paragraph jh ji hi jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">图像由像素组成，每个像素可以由具有三个不同值的向量来表示:一个值用于亮度R的亮度，一个值用于亮度G的亮度，一个值用于亮度T4的亮度。假设我们有一张480×480 = 230，400像素的图片，并想象左上角的像素由向量<strong class="jj hj"> x </strong> ₁,₁ = {0，0，0}表示。现在，这个像素将是黑色的，因为所有的颜色都设置为最低强度。另一个像素，例如右上角的像素，可以用<strong class="jj hj"> x </strong> ₁,₄₈₀ = {1，0，0}来表示，结果像素就像鲁道夫的鼻子一样红。<br/>使用全色板给了我们256 = 16，777，216种不同的颜色:这听起来太夸张了，太多了，人眼都分辨不出来。此外，它使我们的形象不必要的大！下面是这样一张图片(1.2MB)</p><figure class="ir is it iu fd ij er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/79165a3419d3f13c7af6eff105d7b3ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ae2xtJZ3ONe1MN5nkLZ1pw.png"/></div></div></figure><p id="0178" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">多可爱啊！小一点的调色板也可以很好的显示这个小男孩，但是如果我们只用三位色系呢？三位意味着2 = 8种颜色，或者换句话说:像素向量中的每个R值、G值或B值要么关闭(255)，要么打开(0)。结果是:</p><figure class="ir is it iu fd ij er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/59ce4b1798d8a4dfa6e52fc398d5b87a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8wnRBQzQ-4YdSFBeyHs7A.png"/></div></div></figure><p id="6d57" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">嗯，看起来我们丢失了大量的信息。幸运的是，现在我们至少知道存在类似抖动的东西，这应该有助于我们让Quokka Quinten看起来很好，即使调色板非常小！多亏了罗伯特·弗洛伊德和路易斯·斯坦伯格，我们有了一个神奇的算法来完成这项工作。</p><h2 id="054e" class="ja jb hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated"><strong class="ak">弗洛伊德-斯坦伯格算法</strong></h2><p id="2bf7" class="pw-post-body-paragraph jh ji hi jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">弗洛伊德和斯坦伯格早在1976年就提出了他们的想法，事实上他们发现了一种欺骗人类大脑的方法，利用了一种叫做<em class="lq">错误扩散的原理。</em>关于详细的解释，我参考了<a class="ae iq" href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering" rel="noopener ugc nofollow" target="_blank">维基百科页面</a>或<a class="ae iq" href="https://www.youtube.com/watch?v=0L2n8Tg2FwI" rel="noopener ugc nofollow" target="_blank">编码列车的这个很棒的解释视频</a>。</p><p id="c72e" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">简而言之，该算法的工作原理如下:</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/89f1e0f52a7915c6544409107b6c31d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1234/format:webp/1*EKbTBG7BkxXoSkE-19Nhqg.png"/></div></figure><p id="d1c0" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">从伪代码中可以看出，误差被指定为用全色调色板表示的像素值与使用较小调色板时的像素值之间的差异。随后，这种误差被分布——或<em class="lq">扩散— </em>到相邻像素上。这真的很有帮助，因为我们人类将这种扩散视为较小调色板中可用颜色的一尘不染的混合:我们观察到的颜色比实际上更多！</p><h2 id="f3ab" class="ja jb hi bd kp kq kr ks kt ku kv kw kx js ky kz la jw lb lc ld ka le lf lg lh bi translated"><strong class="ak">在R中抖动图像</strong></h2><p id="95d5" class="pw-post-body-paragraph jh ji hi jj b jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka lm kc kd ke hb bi translated">现在我们至少对图像抖动的工作原理有了一个基本的了解，是时候利用弗洛伊德-斯坦伯格算法，让Quokka Quinten看起来更精致了！我们首先加载所需的包并读取映像。请注意，该图像为670×946像素，因此它被表示为一个由三个矩阵(红色、绿色和蓝色各一个)组成的阵列，这三个矩阵“相互堆叠”。因为我们只需要前三个通道，所以我们只需要选择这些通道。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="f7d6" class="ja jb hi iw b fi jc jd l je jf">library("tidyverse")<br/>library("png")</span><span id="83a5" class="ja jb hi iw b fi jg jd l je jf">quokka &lt;- png::readPNG(source = "0_img/quokka.png")<br/>quokka &lt;- quokka[, , 1:3]</span></pre><p id="83d7" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">下一步是编写一个函数来创建一个更小的调色板。我喜欢能够创建不同大小的调色板，例如八种颜色(3位)、512种颜色(9位)甚至32，768种颜色(15位)。因此，该函数取决于<em class="lq"> K </em>，它或者是我们想要在调色板中拥有的颜色数量，或者是比特大小。我已经内置了一些简单的检查，但如果你忽略它们，这不是犯罪。</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="e583" class="ja jb hi iw b fi jc jd l je jf">CreatePalette &lt;- function(K){</span><span id="5c4a" class="ja jb hi iw b fi jg jd l je jf"> if (K %in% c(8, 64, 512, 4096, 32768) == FALSE &amp;&amp;<br/>     K %in% c(3, 6, 9, 12, 15) == FALSE) {<br/>    stop("Input K must be a one of these numbers: <br/>        (8, 64, 512, 4096, 32768) or (3, 6, 9, 12, 15)")<br/> }<br/>  <br/> if (K %in% c(3, 6, 9, 12, 15) == FALSE &amp; log2(K) %% 3 != 0) {<br/>   stop("Your input must satisfy the following condition: <br/>         log2(K) %% 3 == 0")<br/> }</span><span id="e63a" class="ja jb hi iw b fi jg jd l je jf"> if (K %in% c(8, 64, 512, 4096, 32768)) {<br/>   K = K^(1/3)<br/> }<br/><br/> if (K %in% c(3, 6, 9, 12, 15)) {<br/>    K = 2^(K/3)<br/> }</span><span id="8a70" class="ja jb hi iw b fi jg jd l je jf"> color_combs &lt;- expand.grid(seq(0, 255, 255/(K - 1)), <br/>                            seq(0, 255, 255/(K - 1)), <br/>                            seq(0, 255, 255/(K - 1)))<br/>  <br/> colnames(color_combs) &lt;- c("Red", "Green", "Blue")<br/>  <br/> all_colors &lt;- apply(color_combs, 1, function(x){<br/>   red &lt;- x[1]<br/>   green &lt;- x[2]<br/>   blue &lt;- x[3] <br/>   col &lt;- rgb(red, green, blue, maxValue = 255)<br/>   })</span><span id="acaa" class="ja jb hi iw b fi jg jd l je jf"> out &lt;- list(cols = all_colors,<br/>             dat = color_combs)<br/>  <br/> return(out)<br/>}</span></pre><p id="a4f4" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">前两个<code class="du kf kg kh iw b">if</code>语句用于检查我们是否提供了有效的输入。接下来的两个<code class="du kf kg kh iw b">if</code>语句确保<em class="lq"> K </em>被转换成像素向量的单个条目可以取的值<em class="lq">的数量。假设我们想要创建一个3位调色板。这意味着我们有八种不同的RGB组合:</em></p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/c6c17b893fd41166874d328bfffe51a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:488/format:webp/1*4DfQK2HW4E0ntP4YrICcwQ.png"/></div></figure><p id="ac44" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">注意，我们使用R的内置<code class="du kf kg kh iw b">rgb</code>函数，它将像素亮度转换成十六进制代码的实际颜色。不要惊慌，这只是另一种表现颜色的方式——就像RGB配色方案一样！</p><p id="a5dd" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">在我们实际应用Floyd-Steinberg算法之前，最后一步是编写一个函数，为每个像素找到较小调色板中“最接近”的颜色，其中接近度定义为:</p><figure class="ir is it iu fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/1d539f750bb30b94bbfaa9cd5401be08.png" data-original-src="https://miro.medium.com/v2/resize:fit:296/1*WUk4Ndk3TfSxN-OuAVU56w.gif"/></div></figure><p id="85e9" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">其中<strong class="jj hj"> c </strong> ₖ = {Redₖ，Greenₖ，Blueₖ}对于<em class="lq"> k </em> ∈ {1，…，<em class="lq"> K </em> }是缩减调色板中的特定颜色，<strong class="jj hj"> x </strong> ᵢⱼ是我们考虑的像素的强度向量。用不太专业的术语来说:最接近的颜色是平方欧几里德距离最小的颜色！使用功能<code class="du kf kg kh iw b">FindClosestPaletteColor</code>，我们可以在较小的调色板中用最接近的颜色替换每个像素:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="93d6" class="ja jb hi iw b fi jc jd l je jf">FindClosestPaletteColor &lt;- function(picture, n_bit, maxValue = 255){</span><span id="7373" class="ja jb hi iw b fi jg jd l je jf"> if (maxValue != 1 &amp; maxValue != 255) {<br/>    stop("maxValue should be either 1 or 255")<br/> }<br/>  <br/> if (maxValue == 1) {<br/>    picture &lt;- picture * 255<br/> }<br/>  <br/> col_palette &lt;- CreatePalette(n_bit)$dat<br/>  <br/> closestpixel &lt;- array(dim = dim(picture))<br/>  <br/> for (i in 1:nrow(picture)) {<br/>   for (j in 1:ncol(picture)) {<br/>       pixel &lt;- picture[i, j, ]<br/>       ind &lt;- which.min(rowSums(t(pixel - t(col_palette))^2))<br/>      <br/>       closestpixel[i, j, ] &lt;- as.numeric(col_palette[ind, ])<br/>   }<br/> }<br/>  <br/> return(closestpixel)<br/>}</span></pre><p id="9f7c" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">到目前为止，我们已经准备好了能够顺利地将弗洛伊德和斯坦伯格的想法处理成工作算法的所有要素。祝你好运！</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="7ced" class="ja jb hi iw b fi jc jd l je jf">DitherImage &lt;- function(picture, n_bit) {<br/>  <br/> pixels &lt;- picture<br/> quant_error &lt;- array(dim = dim(picture))<br/> col_palette &lt;- CreatePalette(n_bit)$dat/255<br/>  <br/> for(i in 1:(nrow(pixels) - 1)){<br/>   for(j in 1:(ncol(pixels) - 1)){<br/>       oldpixel &lt;- pixels[i, j, ] <br/>       newpixel &lt;- Closest(oldpixel, col_palette)<br/>       pixels[i, j, ] &lt;- newpixel<br/>       quant_error[i, j, ] &lt;- oldpixel - newpixel<br/>        <br/>       pixels[i    , j + 1, ] &lt;- pixels[i, j + 1, ] +<br/>                              quant_error[i, j, ] * 7 / 16<br/>       pixels[i + 1, j + 1, ] &lt;- pixels[i + 1, j + 1, ] + <br/>                              quant_error[i, j, ] * 1 / 16<br/>       pixels[i + 1, j    , ] &lt;- pixels[i + 1, j    , ] + <br/>                              quant_error[i, j, ] * 5 / 16<br/>       pixels[i + 1, j - 1, ] &lt;- pixels[i + 1, j - 1, ] + <br/>                              quant_error[i, j, ] * 3 / 16<br/>   }<br/> }</span><span id="77b2" class="ja jb hi iw b fi jg jd l je jf"> col_oldpixels &lt;- pixels[, ncol(pixels), ]<br/> col_newpixels &lt;- matrix(nrow = nrow(col_oldpixels), <br/>                         ncol = ncol(col_oldpixels))<br/> <br/> for (i in 1:nrow(col_oldpixels)) {<br/>    col_newpixels[i, ] &lt;- Closest(col_oldpixels[i, ], col_palette)<br/> }<br/>  <br/> pixels[, ncol(pixels), ] &lt;- col_newpixels<br/> quant_error[, ncol(pixels), ] &lt;- col_oldpixels - col_newpixels</span><span id="b780" class="ja jb hi iw b fi jg jd l je jf"> row_oldpixels &lt;- pixels[nrow(pixels), , ]<br/> row_newpixels &lt;- matrix(nrow = nrow(row_oldpixels), <br/>                         ncol = ncol(row_oldpixels))<br/>  <br/> for (i in 1:nrow(row_oldpixels)) {<br/>    row_newpixels[i, ] &lt;- Closest(row_oldpixels[i, ], col_palette)<br/>  }<br/>  <br/> pixels[nrow(pixels), , ] &lt;- row_newpixels<br/> quant_error[nrow(pixels), , ] &lt;- row_oldpixels - row_newpixels<br/>  <br/> out &lt;- list(New_Colors = pixels,<br/>             Errors = 255 * quant_error,<br/>             Loss = sum((255 * quant_error)^2))<br/>  <br/> return(out)<br/>}</span></pre><p id="8628" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">有几个小细节值得补充说明:</p><ol class=""><li id="cb75" class="mc md hi jj b jk jl jo jp js me jw mf ka mg ke mh mi mj mk bi translated">双<code class="du kf kg kh iw b">for</code>循环是大部分抖动发生的地方。由于该算法只能正确处理除第一列和最后一列以及最后一行之外的所有内容，因此我们需要一些额外的代码来抖动图像边缘。这是处理所有后续代码的地方。</li><li id="d051" class="mc md hi jj b jk ml jo mm js mn jw mo ka mp ke mh mi mj mk bi translated">为了找到较小调色板中新像素的亮度，我使用了函数<code class="du kf kg kh iw b">Closest</code>。这其实是<code class="du kf kg kh iw b">FindClosestPaletteColor</code>更快的实现。代码如下:</li></ol><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="bdf0" class="ja jb hi iw b fi jc jd l je jf">Closest &lt;- function(pixel, col_palette = col_palette) {<br/> ind &lt;- which.min(rowSums(t(pixel - t(col_palette))^2))<br/>  <br/> newpixel &lt;- as.numeric(col_palette[ind, ])<br/>  <br/> return(newpixel)<br/>}</span></pre><p id="9749" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">这是一个总结！那是一些杰出的<em class="lq">高级菜肴</em>，在那里我们成功地实现了Floyd-Steinberg算法来抖动Quokka Quinten。保存结果的一个相当方便的方法是运行下面几行代码:</p><pre class="ir is it iu fd iv iw ix iy aw iz bi"><span id="1f87" class="ja jb hi iw b fi jc jd l je jf">dithered_03 &lt;- DitherImage(quokka, n_bit = 3)<br/>writePNG(dithered_03$New_Colors, "0_img/quokka_dithered_03.png")</span></pre><p id="306f" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">看看他！Quiten现在看起来好多了，尽管我们只用了8(！)颜色。在第二部分中，我们将更深入地探究算法背后的统计过程，并且我们将尝试提出一种合理的方法来确定颜色的最佳数量。希望你喜欢！</p><figure class="ir is it iu fd ij er es paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="er es lu"><img src="../Images/749fd6cee668c30d5b5aa890061e054e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QAuadqV7QjH0AoKzuBcXsA.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">抖动3位qu kka Quinten(0.28 MB)</figcaption></figure></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="144b" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">[1] R.W. Floyd和L. Steinberg“空间灰度的自适应算法”，《信息显示学会会议录》，第17卷第2期，1976年，第75-77页。</p><p id="d26d" class="pw-post-body-paragraph jh ji hi jj b jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke hb bi translated">完整源代码:【https://github.com/justinkraaijenbrink/imagedithering T4】</p></div></div>    
</body>
</html>