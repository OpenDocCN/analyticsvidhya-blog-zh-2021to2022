<html>
<head>
<title>Digit Emoji Predictor: Build UI for Deep Learning model in Notebook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数字表情符号预测器:为笔记本中的深度学习模型构建UI</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/digit-emoji-predictor-build-ui-for-deep-learning-model-in-notebook-cc8e08669174?source=collection_archive---------14-----------------------#2021-04-30">https://medium.com/analytics-vidhya/digit-emoji-predictor-build-ui-for-deep-learning-model-in-notebook-cc8e08669174?source=collection_archive---------14-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="ef0d" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">通过在JavaScript和Python之间传递数据，在Jupyter notebook中建立一个数字表情预测器。通常，JavaScripts用于笔记本中的数据可视化，但它也可以用于深度学习模型的前端/UI原型化。</h2></div><h1 id="6bbd" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">为什么要在笔记本中构建UI？</h1><figure class="jp jq jr js fd jt er es paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="er es jo"><img src="../Images/4ad00abb5ac56b5af1b1c76c581b979d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PhkVJnV3YUSNhSNSs-7PMg.png"/></div></div></figure><p id="6056" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">简短回答:</p><blockquote class="kw"><p id="1a15" class="kx ky hh bd kz la lb lc ld le lf kv dx translated">在真正的软件开发开始之前，与来自业务、数据科学、前端开发人员、DevOps等不同团队的同事分享深度学习模型笔记本，征求他们的意见。</p></blockquote><p id="25e1" class="pw-post-body-paragraph ka kb hh kc b kd lg ii kf kg lh il ki kj li kl km kn lj kp kq kr lk kt ku kv ha bi translated">Jupyter notebook是用于快速原型制作的，每个人都知道这一点，但是很多人忽略的是，我们也可以快速制作UI原型。许多数据科学家<strong class="kc hi">很快就开始</strong>利用他们拥有的任何少量数据构建大型深度学习模型，甚至没有考虑他们正在开发什么以及为谁开发🤷‍♂️.相信我，您满意的第一个模型(基于准确性等指标)不会部署到生产中，因为各种原因，如推理时间慢、没有设备支持、占用内存等等。<br/> <br/>即使是经验丰富的项目/产品经理有时也不会知道他们真正想要的是什么，所以首先尝试从所有相关人员那里获得工作流程或管道协议，即使有了这些，一些事情也会从缝隙中溜走。“我是数据科学家，我的工作只是建立ML模型，这不是正确的思维模式，至少在我看来是这样。”DevOps有一点商业、Web开发方面的知识，可以帮助你节省大量的调试时间，或者解释为什么你建立的模型/工作流是最适合商业的。在这里最好是万事通。顺便说一句，这并不意味着你应该接管你同事的责任。试着去了解你圈子之外发生的事情。在这篇文章中，让我分享一个例子，说明为深度学习模型的输入&amp;输出创建一个简单的UI如何帮助您看到工作流程中的裂缝并提高生产率。</p><h1 id="8fb4" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">应用</h1><p id="dbd1" class="pw-post-body-paragraph ka kb hh kc b kd ll ii kf kg lm il ki kj ln kl km kn lo kp kq kr lp kt ku kv ha bi translated">如果你不熟悉<a class="ae lq" href="https://www.kaggle.com/c/digit-recognizer" rel="noopener ugc nofollow" target="_blank"> MNIST </a>数据集，那么只要知道你可以建立一个<strong class="kc hi">数字表情预测器</strong>，因为数据集包含手绘数字的灰度图像，从0到9。所以我们的UI会让用户画一个数字&amp;来显示相应的表情符号。</p><p id="2ab6" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">首先，我们将决定我们要建造什么？与其从头开始创建，不如让我们尝试在不使用Django的情况下，在笔记本中重新创建<a class="ae lq" href="https://towardsdatascience.com/deploying-your-first-deep-learning-model-mnist-in-production-environment-510bfdc4808d" rel="noopener" target="_blank">数字识别器</a>。我们选择的用例很棒，因为我们不能简单地使用<code class="du lr ls lt lu b">pywidgets</code>，这迫使我们深入挖掘HTML &amp; JavaScript的世界。从长远来看，这条路线有更多的好处，因为无限的能力，免费的资源，更重要的是更接近实际的前端。当然，如果你想要的只是一个滑块，那就用<code class="du lr ls lt lu b">pywidgets</code>滚动。我们将首先设置后端，然后返回到UI。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es lv"><img src="../Images/c0d70d70a0b26504d7b6228c66886298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*yMwHBl_Z_-EVa1PB.gif"/></div></figure><h1 id="9837" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">数字表情识别器</h1><p id="b291" class="pw-post-body-paragraph ka kb hh kc b kd ll ii kf kg lm il ki kj ln kl km kn lo kp kq kr lp kt ku kv ha bi translated">我已经使用<code class="du lr ls lt lu b">pytorch</code>训练了CNN深度学习模型，我们将从<a class="ae lq" href="https://github.com/6aravind/tidbits/blob/main/assets/models/mnist_model.pth" rel="noopener ugc nofollow" target="_blank">这里</a>下载模型&amp;权重。这是一个简单的模型，有3个<em class="lw"> Conv模块</em>和2个<em class="lw">全连接层</em>。这个模型使用的变换有<code class="du lr ls lt lu b">Resize</code> &amp; <code class="du lr ls lt lu b">ToTensor</code>。在图像上调用<code class="du lr ls lt lu b">predict</code>功能，我们将得到预测的数字。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="39ae" class="mb ix hh lu b fi mc md l me mf">import torch<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>from torchvision import transforms<br/><br/># Digit Recognizer model definition<br/>class CNN(nn.Module):<br/>    def __init__(self):<br/>        super(CNN, self).__init__()<br/>        self.conv1 = nn.Conv2d(1, 32, kernel_size=5)<br/>        self.conv2 = nn.Conv2d(32, 32, kernel_size=5)<br/>        self.conv3 = nn.Conv2d(32,64, kernel_size=5)<br/>        self.fc1 = nn.Linear(3*3*64, 256)<br/>        self.fc2 = nn.Linear(256, 10)<br/><br/>    def forward(self, x):<br/>        x = F.relu(self.conv1(x))<br/>        x = F.dropout(x, p=0.5, training=self.training)<br/>        x = F.relu(F.max_pool2d(self.conv2(x), 2))<br/>        x = F.dropout(x, p=0.5, training=self.training)<br/>        x = F.relu(F.max_pool2d(self.conv3(x),2))<br/>        x = F.dropout(x, p=0.5, training=self.training)<br/>        x = x.view(-1,3*3*64 )<br/>        x = F.relu(self.fc1(x))<br/>        x = F.dropout(x, training=self.training)<br/>        x = self.fc2(x)<br/>        return x<br/><br/><br/><br/># Predict the digit given the tensor<br/>def predict(image, modelName = 'mnist_model.pth'):<br/><br/>    # Resize before converting the image to Tensor<br/>    Trfms = transforms.Compose([transforms.Resize(28), transforms.ToTensor()])<br/><br/>    # Apply transformations and increase dim for mini-batch dimension<br/>    imageTensor = Trfms(image).unsqueeze(0)<br/><br/>    # Download model from URL and load it<br/>    model = torch.load(modelName)<br/><br/>    # Activate Eval mode<br/>    model.eval()<br/><br/>    # Pass the image tensor by the model &amp; return max index of output<br/>    with torch.no_grad():<br/>        out = model(imageTensor)<br/>        return int(torch.max(out, 1)[1])</span></pre><p id="a272" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">我们需要一个助手函数来将<strong class="kc hi"> BASE64图像</strong>(用户将要在其中绘制数字的画布区域)转换为<strong class="kc hi"> PIL图像</strong>。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="659c" class="mb ix hh lu b fi mc md l me mf">import re, base64<br/>from PIL import Image<br/>from io import BytesIO<br/><br/># Decode the image drawn by the user<br/>def decodeImage(codec):<br/><br/>    # remove the front part of codec<br/>    base64_data = re.sub('^data:image/.+;base64,', '', codec)<br/><br/>    # base64 decode<br/>    byte_data = base64.b64decode(base64_data)<br/><br/>    # Convert to bytes<br/>    image_data = BytesIO(byte_data)<br/><br/>    # Convert to image &amp; convert to grayscale<br/>    img = Image.open(image_data).convert('L')<br/>    return img</span></pre><p id="7388" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">现在让我们将这两个函数即<code class="du lr ls lt lu b">decodeImage</code>和<code class="du lr ls lt lu b">predict</code>合并为一个单独的函数。这种方式更容易，因为函数的输出(emoji html代码)可以通过JavaScript直接传递给html标签。如果你感到困惑，坚持一会儿，在下一节中事情会变得容易得多。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="e016" class="mb ix hh lu b fi mc md l me mf"># Decode the image and predict the value<br/>def decode_predict(imgStr):<br/><br/>    # Decode the image<br/>    image = decodeImage(imgStr)<br/><br/>    # Declare html codes for 0-9 emoji<br/>    emojis = [ <br/>            "&amp;#48;&amp;#65039;&amp;#8419;",<br/>             "&amp;#49;&amp;#65039;&amp;#8419;",<br/>             "&amp;#50;&amp;#65039;&amp;#8419;",<br/>             "&amp;#51;&amp;#65039;&amp;#8419;",<br/>             "&amp;#52;&amp;#65039;&amp;#8419;",<br/>             "&amp;#53;&amp;#65039;&amp;#8419;",<br/>             "&amp;#54;&amp;#65039;&amp;#8419;",<br/>             "&amp;#55;&amp;#65039;&amp;#8419;",<br/>             "&amp;#56;&amp;#65039;&amp;#8419;",<br/>             "&amp;#57;&amp;#65039;&amp;#8419;"<br/>    ]<br/><br/>    # Call the predict function<br/>    digit = predict(image)<br/><br/>    # get corresponding emoji<br/>    return emojis[digit]</span></pre><h1 id="b1d7" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">用户界面</h1><p id="61cc" class="pw-post-body-paragraph ka kb hh kc b kd ll ii kf kg lm il ki kj ln kl km kn lo kp kq kr lp kt ku kv ha bi translated">HTML和CSS部分非常简单，JavaScript允许用户在画布内部绘图，并通过按钮<code class="du lr ls lt lu b">Predict</code> &amp; <code class="du lr ls lt lu b">Clear</code>调用函数。<code class="du lr ls lt lu b">Clear</code>按钮清理画布并将结果设置为🤔表情符号。我们将在下一节中设置<code class="du lr ls lt lu b">Predict</code>按钮JS函数。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="5888" class="mb ix hh lu b fi mc md l me mf">from IPython.display import HTML<br/><br/>html = """<br/>&lt;div class="outer"&gt;<br/>        &lt;! -- HEADER SECTION --&gt;<br/>    &lt;div&gt; <br/>        &lt;h3 style="margin-left: 30px;"&gt; Digit Emoji Predictor &amp;#128640; &lt;/h3&gt; <br/>        &lt;br&gt;<br/>        &lt;h7 style="margin-left: 40px;"&gt; Draw a digit from &amp;#48;&amp;#65039;&amp;#8419; - &amp;#57;&amp;#65039;&amp;#8419;&lt;/h7&gt;<br/>    &lt;/div&gt;<br/><br/>    &lt;div&gt;<br/>           &lt;! -- CANVAS TO DRAW THE DIGIT --&gt;<br/>        &lt;canvas id="canvas" width="250" height="250" style="border:2px solid; float: left; border-radius: 5px; cursor: crosshair;"&gt;<br/>        &lt;/canvas&gt;<br/><br/>            &lt;! -- SHOW PREDICTED DIGIT EMOJI--&gt;<br/>        &lt;div class="wrapper1"&gt; &lt;p id="result"&gt;&amp;#129300;&lt;/p&gt;&lt;/div&gt;<br/><br/>            &lt;! -- BUTTONS TO CALL DL MODEL &amp; CLEAR THE CANVAS --&gt;<br/>        &lt;div class="wrapper2"&gt;<br/>            &lt;button type="button" id="predictButton" style="color: #4CAF50;margin:10px;"&gt;  Predict &lt;/button&gt;  <br/>            &lt;button type="button" id="clearButton" style="color: #f44336;margin:10px;"&gt;  Clear &lt;/button&gt;  <br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;<br/>"""<br/><br/><br/>css = """<br/>&lt;style&gt;<br/>    .wrapper1 {<br/>      text-align: center;<br/>      display: inline-block;<br/>      position: absolute;<br/>      top: 82%;<br/>      left: 25%;<br/>      justify-content: center;<br/>      font-size: 30px;<br/>    }<br/>    .wrapper2 {<br/>      text-align: center;<br/>      display: inline-block;<br/>      position: absolute;<br/>      top: 90%;<br/>      left: 19%;<br/>      justify-content: center;<br/>    }<br/><br/>    .outer {<br/>        height: 400px; <br/>        width: 400px;<br/>        justify-content: center;<br/>    }<br/><br/>&lt;/style&gt;<br/>"""<br/><br/><br/>javascript = """<br/><br/>&lt;script type="text/javascript"&gt;<br/>(function() {<br/>    /* SETUP CANVAS &amp; ALLOW USER TO DRAW */<br/>    var canvas = document.querySelector("#canvas");<br/>    canvas.width = 250;<br/>    canvas.height = 250;<br/>    var context = canvas.getContext("2d");<br/>    var canvastop = canvas.offsetTop<br/>    var lastx;<br/>    var lasty;<br/>    context.strokeStyle = "#000000";<br/>    context.lineCap = 'round';<br/>    context.lineJoin = 'round';<br/>    context.lineWidth = 5;<br/><br/>    function dot(x, y) {<br/>        context.beginPath();<br/>        context.fillStyle = "#000000";<br/>        context.arc(x, y, 1, 0, Math.PI * 2, true);<br/>        context.fill();<br/>        context.stroke();<br/>        context.closePath();<br/>    }<br/><br/>    function line(fromx, fromy, tox, toy) {<br/>        context.beginPath();<br/>        context.moveTo(fromx, fromy);<br/>        context.lineTo(tox, toy);<br/>        context.stroke();<br/>        context.closePath();<br/>    }<br/>    canvas.ontouchstart = function(event) {<br/>        event.preventDefault();<br/>        lastx = event.touches[0].clientX;<br/>        lasty = event.touches[0].clientY - canvastop;<br/>        dot(lastx, lasty);<br/>    }<br/>    canvas.ontouchmove = function(event) {<br/>        event.preventDefault();<br/>        var newx = event.touches[0].clientX;<br/>        var newy = event.touches[0].clientY - canvastop;<br/>        line(lastx, lasty, newx, newy);<br/>        lastx = newx;<br/>        lasty = newy;<br/>    }<br/>    var Mouse = {<br/>        x: 0,<br/>        y: 0<br/>    };<br/>    var lastMouse = {<br/>        x: 0,<br/>        y: 0<br/>    };<br/>    context.fillStyle = "white";<br/>    context.fillRect(0, 0, canvas.width, canvas.height);<br/>    context.color = "black";<br/>    context.lineWidth = 10;<br/>    context.lineJoin = context.lineCap = 'round';<br/>    debug();<br/>    canvas.addEventListener("mousemove", function(e) {<br/>        lastMouse.x = Mouse.x;<br/>        lastMouse.y = Mouse.y;<br/>        Mouse.x = e.pageX - canvas.getBoundingClientRect().left;<br/>        Mouse.y = e.pageY - canvas.getBoundingClientRect().top;<br/>    }, false);<br/>    canvas.addEventListener("mousedown", function(e) {<br/>        canvas.addEventListener("mousemove", onPaint, false);<br/>    }, false);<br/>    canvas.addEventListener("mouseup", function() {<br/>        canvas.removeEventListener("mousemove", onPaint, false);<br/>    }, false);<br/>    var onPaint = function() {<br/>        context.lineWidth = context.lineWidth;<br/>        context.lineJoin = "round";<br/>        context.lineCap = "round";<br/>        context.strokeStyle = context.color;<br/>        context.beginPath();<br/>        context.moveTo(lastMouse.x, lastMouse.y);<br/>        context.lineTo(Mouse.x, Mouse.y);<br/>        context.closePath();<br/>        context.stroke();<br/>    };<br/><br/>    function debug() {<br/>        /* CLEAR BUTTON */<br/>        var clearButton = $("#clearButton");<br/>        clearButton.on("click", function() {<br/>            context.clearRect(0, 0, 250, 250);<br/>            context.fillStyle = "white";<br/>            context.fillRect(0, 0, canvas.width, canvas.height);<br/><br/>            /* Remove Result */<br/>            document.getElementById("result").innerHTML = "&amp;#129300;";<br/>        });<br/>        $("#colors").change(function() {<br/>            var color = $("#colors").val();<br/>            context.color = color;<br/>        });<br/>        $("#lineWidth").change(function() {<br/>            context.lineWidth = $(this).val();<br/>        });<br/>    }<br/>}());<br/><br/>&lt;/script&gt;<br/><br/>"""<br/><br/><br/>HTML(html + css + javascript)</span></pre><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mg"><img src="../Images/dadfdf35e3264434a69962cafce76f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:902/format:webp/1*bgVq7XSSIWan1ibCBS215g.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">数字表情符号预测器的用户界面</figcaption></figure><p id="4906" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">太好了！我们可以在画布内部进行绘制，单击<code class="du lr ls lt lu b">Clear</code>按钮，画布将被清理。当用户点击<code class="du lr ls lt lu b">Predict</code>按钮时，棘手的部分开始了，因为我们必须做以下事情:</p><ul class=""><li id="d6cc" class="ml mm hh kc b kd ke kg kh kj mn kn mo kr mp kv mq mr ms mt bi translated"><a class="ae lq" href="https://jakevdp.github.io/blog/2013/06/01/ipython-notebook-javascript-python-communication/" rel="noopener ugc nofollow" target="_blank"> JS转Python👉</a>在画布中抓取绘图，并将其传递给python</li></ul><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="ecac" class="mb ix hh lu b fi mc md l me mf">/* PASS CANVAS BASE64 IMAGE TO PYTHON VARIABLE imgStr*/<br/>    var imgData = canvasObj.toDataURL();<br/>    var imgVar = 'imgStr';<br/>    var passImgCode = imgVar + " = '" + imgData + "'";<br/>    var kernel = IPython.notebook.kernel;<br/>    kernel.execute(passImgCode);</span></pre><ul class=""><li id="906b" class="ml mm hh kc b kd ke kg kh kj mn kn mo kr mp kv mq mr ms mt bi translated"><a class="ae lq" href="https://towardsdatascience.com/javascript-charts-on-jupyter-notebooks-dd25f794cf6a" rel="noopener" target="_blank"> Python对JS👉</a>将预测表情符号设置为HTML元素的值(<code class="du lr ls lt lu b">#result</code>)</li></ul><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="3766" class="mb ix hh lu b fi mc md l me mf">/* CALL PYTHON FUNCTION "decode_predict" WITH "imgStr" AS ARGUMENT */<br/>    function handle_output(response) {<br/>        /* UPDATE THE HTML BASED ON THE OUTPUT */<br/>        var result = response.content.data["text/plain"].slice(1, -1);<br/>        document.getElementById("result").innerHTML = result;<br/>    }<br/>    var callbacks = {<br/>        'iopub': {<br/>            'output': handle_output,<br/>        }<br/>    };<br/>    var getPredictionCode = "decode_predict(imgStr)";<br/>    kernel.execute(getPredictionCode, callbacks, { silent: false });</span></pre><p id="1053" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">把所有的联系在一起。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="0a48" class="mb ix hh lu b fi mc md l me mf">predictJS = """</span><span id="4f09" class="mb ix hh lu b fi mu md l me mf">&lt;script type="text/javascript"&gt;<br/><br/>/* PREDICTION BUTTON */<br/>$("#predictButton").click(function() {<br/>    var canvasObj = document.getElementById("canvas");<br/>    var context = canvas.getContext("2d");<br/><br/>    /* PASS CANVAS BASE64 IMAGE TO PYTHON VARIABLE imgStr*/<br/>    var imgData = canvasObj.toDataURL();<br/>    var imgVar = 'imgStr';<br/>    var passImgCode = imgVar + " = '" + imgData + "'";<br/>    var kernel = IPython.notebook.kernel;<br/>    kernel.execute(passImgCode);<br/><br/>    /* CALL PYTHON FUNCTION "decode_predict" WITH "imgStr" AS ARGUMENT */<br/>    function handle_output(response) {<br/>        /* UPDATE THE HTML BASED ON THE OUTPUT */<br/>        var result = response.content.data["text/plain"].slice(1, -1);<br/>        document.getElementById("result").innerHTML = result;<br/>    }<br/>    var callbacks = {<br/>        'iopub': {<br/>            'output': handle_output,<br/>        }<br/>    };<br/>    var getPredictionCode = "decode_predict(imgStr)";<br/>    kernel.execute(getPredictionCode, callbacks, { silent: false });<br/>});<br/>&lt;/script&gt;<br/><br/>"""<br/>HTML(predictJS)</span></pre><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mv"><img src="../Images/73b0d3d5b8eae5e6bbcceb1e214504a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/1*EaY062wnD67D-2GdWPhlIA.gif"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">错误的预测</figcaption></figure><p id="a5cb" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">我们有好消息也有坏消息，好消息是Python和JavaScript之间的数据连接工作正常，但是预测值都是错误的(映射到相同的值— 8)。让我们比较一下传递给python的画布图像和MNIST数据集图像。</p><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mw"><img src="../Images/5d51b5d45fdb293c174634e8b8cd06e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1074/format:webp/1*95bvFdgObTZMaJ9zGagwMw.png"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">比较画布和MNIST的图像</figcaption></figure><p id="51fd" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">现在很清楚，我们需要对图像进行<code class="du lr ls lt lu b">invert</code>处理，因为模型是在具有黑色背景和白色笔画的数据集上训练的。</p><pre class="jp jq jr js fd lx lu ly lz aw ma bi"><span id="6332" class="mb ix hh lu b fi mc md l me mf">import PIL.ImageOps<br/><br/># Decode the image and predict the value<br/>def decode_predict(imgStr):<br/><br/>    # Decode the image<br/>    image = decodeImage(imgStr)<br/><br/>    # Invert the image as model expects black background &amp; white strokes<br/>    image = PIL.ImageOps.invert(image)<br/><br/>    # Declare html codes for 0-9 emoji<br/>    emojis = [ <br/>            "&amp;#48;&amp;#65039;&amp;#8419;",<br/>             "&amp;#49;&amp;#65039;&amp;#8419;",<br/>             "&amp;#50;&amp;#65039;&amp;#8419;",<br/>             "&amp;#51;&amp;#65039;&amp;#8419;",<br/>             "&amp;#52;&amp;#65039;&amp;#8419;",<br/>             "&amp;#53;&amp;#65039;&amp;#8419;",<br/>             "&amp;#54;&amp;#65039;&amp;#8419;",<br/>             "&amp;#55;&amp;#65039;&amp;#8419;",<br/>             "&amp;#56;&amp;#65039;&amp;#8419;",<br/>             "&amp;#57;&amp;#65039;&amp;#8419;"<br/>    ]<br/><br/>    # Call the predict function<br/>    digit = predict(image)<br/><br/>    # get corresponding emoji<br/>    return emojis[digit]</span></pre><figure class="jp jq jr js fd jt er es paragraph-image"><div class="er es mv"><img src="../Images/8d8f946033a89dc4d9161188d3a186ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:908/0*V-ReLcZVaGcpBGz4.gif"/></div><figcaption class="mh mi et er es mj mk bd b be z dx translated">正确的数字表情预测</figcaption></figure><p id="e837" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">厉害！它工作了。</p><h1 id="0836" class="iw ix hh bd iy iz ja jb jc jd je jf jg in jh io ji iq jj ir jk it jl iu jm jn bi translated">结论</h1><p id="32ec" class="pw-post-body-paragraph ka kb hh kc b kd ll ii kf kg lm il ki kj ln kl km kn lo kp kq kr lp kt ku kv ha bi translated">现在，您可以快速将此笔记本分享给每个人，并征求他们的意见。不要忘记提到警告，这是一个早期的原型。没费多大力气，我们就复制了一个网络应用的功能。最大的好处是，我们从未离开舒适的笔记本电脑，并有可能弥合培训和测试数据之间的差距。</p><p id="67f9" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated">希望我能让你相信，基本的web开发技能对于数据科学家来说非常有用。笔记本可以从<a class="ae lq" href="https://github.com/6aravind/tidbits/blob/main/notebook/Digit%20Emoji%20Predictor_Build%20UI%20for%20Deep%20Learning%20model%20in%20Jupyter%20Notebook.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>进入。欢迎通过评论或<a class="ae lq" href="https://twitter.com/@6aravind" rel="noopener ugc nofollow" target="_blank"> Twitter </a>联系我们。</p></div><div class="ab cl mx my go mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ha hb hc hd he"><p id="29cc" class="pw-post-body-paragraph ka kb hh kc b kd ke ii kf kg kh il ki kj kk kl km kn ko kp kq kr ks kt ku kv ha bi translated"><em class="lw">原载于2021年4月30日</em><a class="ae lq" href="https://dev.to/6aravind/digit-emoji-predictor-build-ui-for-deep-learning-model-in-notebook-2gf0" rel="noopener ugc nofollow" target="_blank"><em class="lw">https://dev . to</em></a><em class="lw">。</em></p></div></div>    
</body>
</html>