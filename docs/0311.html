<html>
<head>
<title>k-nearest neighbours</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">k近邻</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/k-nearest-neighbours-db303d1351f?source=collection_archive---------30-----------------------#2021-01-11">https://medium.com/analytics-vidhya/k-nearest-neighbours-db303d1351f?source=collection_archive---------30-----------------------#2021-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="46f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">机器学习算法</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/a32c60ac9253732a8908d0138501258d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/0*dwx-FBmSTotZmTuS.jpeg"/></div></figure><p id="48e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KNN是一种简单直观的机器学习算法。它可用于分类和回归。这是一种监督学习，我们得到x和y。</p><p id="c68d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KNN是非参数的，这意味着它不做任何假设，因此准确性取决于数据的质量。这是易于使用，以及有一个快速的计算时间。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jk"><img src="../Images/d9248c8d06f9bd00e0d01ed2e92a6930.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ypwHNFS6jjz548di.jpg"/></div></div></figure><p id="2ccd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，它也有一定的缺点，如在边界上分类数据点的能力很差。我们必须找到k(我们将要预测的最近邻的数量)的最佳值。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jp"><img src="../Images/f26a225429cfb60bd1bdae65dc15b393.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/format:webp/0*THMbbhCWE8Uap1TC.png"/></div></figure><p id="0892" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有黑点作为测试点，我们必须预测它属于哪一类！！因此，我们计算每个点的欧几里德距离，然后找到k个最小距离(最近的邻居)。之后，我们将检查每个职业的多数票。最接近的类别将是测试点的类别。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jl jm di jn bf jo"><div class="er es jk"><img src="../Images/3aa4a95d82c18c5fab9c2b1ce2b52387.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ArzM4czrRsEImoDR.png"/></div></div></figure><blockquote class="jq jr js"><p id="8033" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">这是最蛮力的算法，你用的任何其他算法都应该比这个好(精度更高，复杂度更低)。这个预测不涉及任何训练。所有的工作都发生在查询时。</p></blockquote><p id="889b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jx translated">KNN的ets代码</p><pre class="jd je jf jg fd kg kh ki kj aw kk bi"><span id="14c0" class="kl km hh kh b fi kn ko l kp kq">def dis(x1,x2):<br/>    return np.sqrt(sum((x1-x2)**2))</span><span id="9bad" class="kl km hh kh b fi kr ko l kp kq">def knn(X,Y,query,k=5):<br/>    val = []<br/>    m = X.shape[0]<br/>    <br/>    for i in range(m):<br/>        d = dis(query , X[i])<br/>        val.append((d,Y[i]))<br/>    val=sorted(val)<br/>    val=val[:k]<br/>    val=np.array(val)<br/>    print(val)<br/>    <br/>    new_val = np.unique(val[:,1],return_counts=True)<br/>    print(new_val)<br/>    <br/>    max_freq_index = new_val[1].argmax()<br/>    pred = new_val[0][max_freq_index]<br/>    <br/>    return pred</span></pre><p id="d427" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">逐步解释我们在这段代码中做了什么！！</p><ol class=""><li id="c6f2" class="ks kt hh ig b ih ii il im ip ku it kv ix kw jb kx ky kz la bi translated">加载数据</li><li id="dadd" class="ks kt hh ig b ih lb il lc ip ld it le ix lf jb kx ky kz la bi translated">将K初始化为您选择的邻居数量</li></ol><p id="ebfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.对于数据中的每个例子</p><p id="5fc5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.1根据数据计算查询示例和当前示例之间的距离。</p><p id="9449" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.2将示例的距离和索引添加到有序集合中</p><p id="730d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">4.按距离从小到大(按升序)对距离和索引的有序集合进行排序</p><p id="cc02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">5.从排序的集合中挑选前K个条目</p><p id="e24e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">6.获取所选K个条目的标签</p><p id="0827" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">7.如果是回归，返回K个标签的平均值</p><p id="66dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">8.如果分类，返回K标签的模式。</p><p id="706d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jx translated">现在我们可以选择k的值？</p><p id="0790" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通常找到的最佳<strong class="ig hi"> K值</strong>是N的平方根，其中N是样本总数。</p><blockquote class="jq jr js"><p id="be9e" class="ie if jt ig b ih ii ij ik il im in io ju iq ir is jv iu iv iw jw iy iz ja jb ha bi translated">要获得knn，您可以将它应用于MNIST数据集！！</p></blockquote></div></div>    
</body>
</html>