<html>
<head>
<title>Data pre-processing: A step-by-step guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据预处理:分步指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-pre-processing-a-step-by-step-guide-eeb1c26301bd?source=collection_archive---------21-----------------------#2021-01-02">https://medium.com/analytics-vidhya/data-pre-processing-a-step-by-step-guide-eeb1c26301bd?source=collection_archive---------21-----------------------#2021-01-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0aea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开始数据建模之前，进行充分的分析和特征工程是非常重要的。人们经常面临数据处理的问题，尤其是当数据是高维的时候。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/eadeece1cb1a7ed7bb5cf8cce7278727.png" data-original-src="https://miro.medium.com/v2/resize:fit:990/format:webp/1*FSvd-0PpXOCivDduo41sJA.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">来源:<a class="ae jo" href="https://www.pinterest.ca/pin/585608757769156534/?lp=true" rel="noopener ugc nofollow" target="_blank"> Pinterest </a></figcaption></figure><p id="35d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，让我们来看看数据预处理的不同步骤。</p><h2 id="afda" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">1.用什么编码平台？</h2><p id="c611" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">虽然<a class="ae jo" href="https://jupyter.org/" rel="noopener ugc nofollow" target="_blank"> Jupyter Notebook </a>是一个很好的起点，但Google <a class="ae jo" href="https://colab.research.google.com/notebooks/intro.ipynb" rel="noopener ugc nofollow" target="_blank"> Colab </a>永远是协作工作的最佳选择。在这篇文章中，我将使用Google Colab来展示数据预处理步骤。</p><h1 id="aaed" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">2.如何为进一步的分析准备原始数据？</h1><p id="d0f0" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">数据收集是机器学习问题的第一步。其次是理解和加载笔记本中的数据。数据可以有多种格式<a class="ae jo" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html" rel="noopener ugc nofollow" target="_blank"/>,大多数问题中最常见的格式是csv(逗号分隔值)。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="c001" class="jp jq hh lh b fi ll lm l ln lo">## Import required libraries<br/>import numpy as np<br/>import pandas as pd</span><span id="90b5" class="jp jq hh lh b fi lp lm l ln lo">## Upload dataset<br/>from google.colab import files<br/>uploaded = files.upload()</span></pre><h2 id="4764" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">2.1选择要上传的文件</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="6455" class="jp jq hh lh b fi ll lm l ln lo">## Read a .csv file to pandas dataframe<br/>df = pd.read_csv(uploaded['data.csv'])</span><span id="2642" class="jp jq hh lh b fi lp lm l ln lo">## Read a .json file to pandas dataframe<br/>df = pd.read_json(uploaded['data.json'])</span><span id="c8c3" class="jp jq hh lh b fi lp lm l ln lo">## Read an excel file to pandas dataframe<br/>df = pd.read_excel(uploaded['data.xlsx'])</span></pre><h1 id="4660" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">3.描述数据有哪些不同的方式？</h1><h2 id="8c79" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.1数据的维度</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="9bbf" class="jp jq hh lh b fi ll lm l ln lo">df.shape <br/># df is the dataframe object name whose dimension we want to obtain<br/># it returns a tuple with (no.of rows,no. of columns) </span></pre><h2 id="7cdc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.2检查并删除数据集中的任何重复项</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="609d" class="jp jq hh lh b fi ll lm l ln lo">df.duplicated().sum() #returns the duplicated rows in our data<br/>df.drop_duplicates(inplace=True)</span></pre><p id="e3a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lq lr ls lh b">inplace=True</code>确保dataframe对象被修改，但不创建其副本。如果您需要返回数据帧的副本，请使用<code class="du lq lr ls lh b">inplace=False</code>来代替。</p><h2 id="65c9" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.3每个数字列的描述</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="97c4" class="jp jq hh lh b fi ll lm l ln lo">df.describe()  #returns only the numerical columns stats<br/></span><span id="13a4" class="jp jq hh lh b fi lp lm l ln lo">#to get all columns' stats use<br/>df.describe(include='all') </span></pre><p id="9e63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du lq lr ls lh b">describe()</code>通过最小值和最大值以及平均值、中值、标准偏差&amp;等几个值，帮助获得数据集的基本信息。</p><h2 id="30f7" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.4获取数据集的第一行或最后几行</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="c849" class="jp jq hh lh b fi ll lm l ln lo">df.head(5) # returns first '5' rows of the dataframe<br/>df.tail(5) # returns last '5' rows of the dataframe</span></pre><h2 id="749b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.5检查列的数据类型和每列中的条目数:</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="491a" class="jp jq hh lh b fi ll lm l ln lo">df.info()</span></pre><h2 id="0a10" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.6列名</h2><p id="9c1f" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">如果数据集包含大量的要素(列)，它有助于获取整个要素列表。使用<code class="du lq lr ls lh b">df.columns</code>以描述性格式返回数据帧中所有列的名称。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="518d" class="jp jq hh lh b fi ll lm l ln lo">df.columns #deliveries.csv</span><span id="8f3f" class="jp jq hh lh b fi lp lm l ln lo">Output:<br/>Index(['id', 'season', 'city', 'date', 'team1', 'team2', 'toss_winner','toss_decision', 'result', 'dl_applied', 'winner', 'win_by_runs','win_by_wickets', 'player_of_match', 'venue', 'umpire1', 'umpire2', 'umpire3'],<br/>      dtype='object')<br/></span></pre><h2 id="cfd6" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.7检查数据集中的常量列:</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="cbe3" class="jp jq hh lh b fi ll lm l ln lo">const_col=[c <strong class="lh hi">for</strong> c <strong class="lh hi">in</strong> df.columns <strong class="lh hi">if</strong> df[str(c)].nunique()==1]</span></pre><p id="e5b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">常量列是只包含一个唯一值的列。删除它们是有意义的，因为它们不会给我们的最终模型增加任何价值</p><h2 id="beae" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.8删除数字列中的特殊字符</h2><p id="fa2c" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">现在，在几个实例中，包含数字数据的列可以具有“对象”数据类型。由于缺少数据点，一些特殊字符如<code class="du lq lr ls lh b"><strong class="ig hi">?</strong></code>或<code class="du lq lr ls lh b">space</code>可能出现在连续变量中。在这种情况下，我们将检查唯一条目，以删除它们并更改数据类型:</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="9212" class="jp jq hh lh b fi ll lm l ln lo">for col in ['names of each column containing object datatype with numeric data points']:<br/>  uni_val_col = df[col].unique()<br/>  print ('The unique values in ' , col , 'are ', uni_val_col)## Convert string datatype to float wherever required and change special characters to NaN<br/>for col in ['names of each column containing object datatype with numeric data points']:<br/>  df[col] = pd.to_numeric(df[col], errors='coerce')</span></pre><p id="09a6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这会将数字列中的特殊字符转换为“NaN”值，然后转换为<em class="lt">数字</em>类型。</p><h2 id="4b1b" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.9从分类列中删除特殊字符</h2><p id="83a6" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">我们应该在分类列中检查类似的特殊字符(如3.8节所述)，并用适当的值替换它们。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="08d8" class="jp jq hh lh b fi ll lm l ln lo">df.replace(to_replace=["?", ";"], value=np.nan)</span></pre><h2 id="21fa" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">3.10创建独立的连续和分类数据框架</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="0349" class="jp jq hh lh b fi ll lm l ln lo">## Create a dataframe with continuous columns <br/>df_cont = df.select_dtypes(include = ['int64','float64'])</span><span id="57a4" class="jp jq hh lh b fi lp lm l ln lo">## Create a dataframe with categorical columns<br/>df_cat = df.select_dtypes(include = ['object'])</span></pre><h1 id="d4d6" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">4.缺失值处理</h1><p id="df65" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">大多数情况下，数据集会丢失值，真实世界的数据从来都不是完美的，并且包含很高百分比的丢失数据。缺失值可能是因为在大型数据集的情况下，收集每个数据值非常困难。</p><p id="ce81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">没有最好的方法来估算缺失数据，这取决于问题的类型。可能有许多方法来进行估算，但是这里我们将集中讨论几种方法。</p><h2 id="8abe" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">4.1查找缺失值百分比</h2><p id="a844" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">在这里，我们可以看到如何获得我们在第3节中创建的连续数据帧中缺失值的百分比。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="0ca5" class="jp jq hh lh b fi ll lm l ln lo"># Percentage of missing values in each dataframe along with visualization<br/>total_missing = df.isna().sum()</span><span id="a7c2" class="jp jq hh lh b fi lp lm l ln lo">#percentage</span><span id="e4b9" class="jp jq hh lh b fi lp lm l ln lo">percent_mising=df.isna().mean()*100</span><span id="7a83" class="jp jq hh lh b fi lp lm l ln lo">missing_data = pd.concat([total_missing, percent_mising], axis=1, keys=['Total', 'Percent'])</span><span id="30a8" class="jp jq hh lh b fi lp lm l ln lo">f, ax = plt.subplots(figsize=(15, 6))<br/>plt.xticks(rotation='90')<br/>sns.barplot(x=missing_data.index, y=missing_data['Percent'])<br/>plt.xlabel('df_cont', fontsize=15)<br/>plt.ylabel('Percent of missing values', fontsize=15)<br/>plt.title('Percent missing data by feature', fontsize=15)</span><span id="316b" class="jp jq hh lh b fi lp lm l ln lo">missing_data</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lu"><img src="../Images/69ffbaf11adfa3dbce22adf8f0cbb876.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/1*uTQ2rArjFl2uL_j5g7zpfg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">输出:</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/39c9b950f1a6c0988ea68a84c1e46551.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MlvJEpRK__9jAaUIhq3log.png"/></div></div></figure><h2 id="4526" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">4.2缺失值的插补</h2><h2 id="b96a" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">数字数据框架</h2><p id="aa72" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">任何列的缺失值都可以通过均值、中值或众数进行估算。如果列中的数据点没有太大的偏差，对于连续数据点，中值比平均值更适合用于替换空值。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="3322" class="jp jq hh lh b fi ll lm l ln lo">df_cont.'columnname'.fillna(df_cont['columnname'].median(), inplace=True)</span></pre><p id="5755" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">估算值的最简单方法是使用<strong class="ig hi">简单估算器</strong>估算来处理缺失值。还有其他的<a class="ae jo" href="https://scikit-learn.org/stable/modules/impute.html" rel="noopener ugc nofollow" target="_blank">方法</a>也是为了获得更好的结果。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="a0b3" class="jp jq hh lh b fi ll lm l ln lo">from sklearn.impute import SimpleImputer<br/>imputer = SimpleImputer(missing_values=np.nan, strategy='mean') <br/>df_data = imputer.fit_transform(df_cont)</span><span id="075d" class="jp jq hh lh b fi lp lm l ln lo">## Creating a new dataframe of the imputed data<br/>df_num = pd.DataFrame(df_data, columns = df_cont.columns )<br/></span></pre><h2 id="4d8c" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">4.2.2分类数据框架</h2><p id="ad64" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">在分类数据点的情况下，我们可以用模式来代替它</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="ded8" class="jp jq hh lh b fi ll lm l ln lo">## Replacing NaN with mode for a column<br/>df_cat.'catName'.replace({'NaN':df_cat.'catName'.mode()} , inplace =True)</span></pre><h1 id="8be6" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">5.数据分布</h1><h2 id="5932" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">5.1数字数据帧的图形表示</h2><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="0cdf" class="jp jq hh lh b fi ll lm l ln lo">## Plotting bar plots for categorical data columns<br/>for col in df_cat.columns:<br/>    plt.figure()<br/>    sns.countplot(x=col, data=df_cat)<br/>    plt.xticks(rotation=90,fontsize=15)<br/></span></pre><h1 id="9707" class="kp jq hh bd jr kq kr ks jv kt ku kv jz kw kx ky kc kz la lb kf lc ld le ki lf bi translated">6.异常值的处理</h1><h2 id="9840" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">6.1异常值百分比和其他描述性统计措施</h2><p id="3d48" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">异常值是可能影响也可能不影响模型的任何特征的极值。要获得每个数值或分类属性中异常值的百分比，我们可以使用-</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="3a89" class="jp jq hh lh b fi ll lm l ln lo"># Use the appropriate dataframe in place of "dataframe_name" in the code below, i.e. in this case <strong class="lh hi">df_num</strong> and <strong class="lh hi">df_cat</strong>df_outliers = pd.DataFrame(index=dataframe_name.columns, columns=['outliers', 'outliers%']) for col in dataframe_name.columns:if any(x in str(dataframe_name[col].dtype) for x in ['int', 'float']):df_outliers.loc[col, 'count'] = len(dataframe_name)<br/>df_outliers.loc[col, 'q1'] = dataframe_name[col].quantile(0.25)<br/>df_outliers.loc[col, 'q3'] = dataframe_name[col].quantile(0.75)<br/>df_outliers.loc[col, 'iqr'] = df_outliers.loc[col, 'q3'] - df_outliers.loc[col, 'q1']<br/>df_outliers.loc[col, 'lower'] = df_outliers.loc[col, 'q1'] - (3 * df_outliers.loc[col, 'iqr'])<br/>df_outliers.loc[col, 'upper'] = df_outliers.loc[col, 'q3'] + (3 * df_outliers.loc[col, 'iqr'])<br/>df_outliers.loc[col, 'min'] = df[col].min()<br/>df_outliers.loc[col, 'max'] = df[col].max()<br/>df_outliers.loc[col, 'outliers'] = ((dataframe_name[col] &lt; df_outliers.loc[col, 'lower']) | (df[col] &gt; df_outliers.loc[col,'upper'])).sum()<br/>df_outliers.loc[col, 'outliers%'] = np.round(df_outliers.loc[col,<br/>'outliers'] / len(dataframe_name) *100)df_outliers</span></pre><p id="4d28" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们也可以对每个特征使用箱线图来获得相同的图形表示。</p><h2 id="b3bc" class="jp jq hh bd jr js jt ju jv jw jx jy jz ip ka kb kc it kd ke kf ix kg kh ki kj bi translated">6.2异常值的处理</h2><p id="3b94" class="pw-post-body-paragraph ie if hh ig b ih kk ij ik il kl in io ip km ir is it kn iv iw ix ko iz ja jb ha bi translated">有不同的方法来处理异常值，z-score是一种简单的方法。</p><pre class="jd je jf jg fd lg lh li lj aw lk bi"><span id="7139" class="jp jq hh lh b fi ll lm l ln lo">from scipy import statsz_scores = stats.zscore(dataframe_name)<br/>abs_z_scores = np.abs(z_scores)<br/>entries = (abs_z_scores &lt; 3).all(axis=1)<br/>dataframe_name = dataframe_name[entries]</span></pre></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="7833" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这就完成了我们最初的数据预处理！我们现在可以从可视化和特征工程开始，使我们的数据集模型就绪。</p></div></div>    
</body>
</html>