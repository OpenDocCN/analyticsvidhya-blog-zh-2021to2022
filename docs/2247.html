<html>
<head>
<title>Predicting Music App Churns with 89% F1 Score: Sparkify Project</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测音乐应用程序搅动89%的F1评分:Sparkify项目</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-music-app-churns-with-machine-learning-sparkify-project-dfc2ac2c695c?source=collection_archive---------9-----------------------#2021-04-14">https://medium.com/analytics-vidhya/predicting-music-app-churns-with-machine-learning-sparkify-project-dfc2ac2c695c?source=collection_archive---------9-----------------------#2021-04-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class="ev ex ie if ig ab cb"><figure class="ih ii ij ik il im in paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><img src="../Images/c7029f828714eb7d55317418ddec3057.png" data-original-src="https://miro.medium.com/v2/resize:fit:992/format:webp/1*SqIrlf-3iNkPX2BOe3DEbg.jpeg"/></div></figure><figure class="ih ii iu ik il im in paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><img src="../Images/107a6da826d816a3aed7524a90ce2b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1010/format:webp/1*9zvzMwe4XjKGj7V2ZRS5gg.jpeg"/></div><figcaption class="iv iw et er es ix iy bd b be z dx iz di ja jb translated">左图:<a class="ae jc" href="https://airmore.com/best-music-apps-for-iphone.html" rel="noopener ugc nofollow" target="_blank">https://airmore.com/best-music-apps-for-iphone.html</a>右图:<a class="ae jc" href="https://www.customerbliss.com/popular-2016-posts/" rel="noopener ugc nofollow" target="_blank">https://www.customerbliss.com/popular-2016-posts/</a></figcaption></figure></div><p id="af68" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><em class="kb">在这个项目中，我将解释我的Udacity数据科学家跟踪毕业项目:音乐应用Sparkify的客户流失建模。你可以在我的githı账户上找到这个项目的代码:</em><a class="ae jc" href="https://github.com/semihnykv/MusicAppChurnPrediction" rel="noopener ugc nofollow" target="_blank">https://github.com/semihnykv/MusicAppChurnPrediction</a></p><p id="3565" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">Sparkify是Udacity为一些项目创建的一个虚构的手机和电脑数字音乐服务应用程序。Spotify或其他音乐流媒体应用程序也是如此。它的数据类型与我们习惯的网站事件类型数据相同。当用户播放一首歌曲或打开应用程序时，所有这些操作都会记录到数据库中，并附带事件类型。有了这些数据，可以做很多实验。</p><p id="fc8e" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在这个项目中，我试图用给定的数据创建一个流失模型。在特征工程部分创建新特征为模型增加了有价值的改进。我将在下面的章节中解释我的工作:</p><p id="67a4" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">大纲:</strong></p><p id="921e" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> 1。简介-项目范围</strong></p><p id="f1ff" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> 2。探索性数据分析</strong></p><p id="1980" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> 3。特征工程</strong></p><p id="ffdf" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> 4。建模</strong></p><p id="31e9" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> 5。调查结果&amp;结论</strong></p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h1 id="47f5" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">1.导言-项目范围</h1><p id="fb49" class="pw-post-body-paragraph jd je hh jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka ha bi translated">在这个项目中，我们有小型、中型和完整的数据集。我在IBM Cloud Pak解决方案上使用了中等大小的数据集(237)。我用Pyspark进行分析和建模。用Spark搭配Hadoop是因为大数据。使用PySpark，您可以在Python编程语言中使用rdd，并在Hadoop系统上轻松使用Spark。</p><p id="9ed4" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们将尝试通过使用机器学习来预测音乐应用Sparkify的流失用户。</p><p id="d1c4" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">首先，我们将发现数据并进行一些特征工程。然后我们会实现一些分类算法来预测流失用户。</p><p id="263e" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">由于流失用户是数据的一小部分(几乎22%)，我们将使用1级流失的F1度量来比较算法。F1指标是真实类别的精确度和召回率的调和平均值。</p><p id="9da2" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在决定算法后，我们将进行一些超参数搜索以获得更好的预测分数。</p><p id="5c55" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">最终，我们将拥有一个可靠的机器学习模型，根据我们掌握的行为和使用数据预测哪些用户更有可能流失。</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h1 id="43e3" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">2.探索性数据分析</h1><p id="594a" class="pw-post-body-paragraph jd je hh jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka ha bi translated">下面的数据集架构显示了数据集结构和可用的列。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/b8867db52235c1a148ea8600cc6b33c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*JCT0srFKDxd-SuzPP4QRzg.png"/></div></figure><p id="c817" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们将通过使用<code class="du lr ls lt lu b">Cancellation Confirmation</code>事件来定义我们的客户流失，从而创建一个客户流失标签。拥有此类事件数据行的用户将被标记为流失用户。</p><p id="c7ec" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">该数据集是基于事件的数据集，类似于Google Analytics网站数据。当用户登录或播放一首歌曲时，它会为该行/事件创建一个事件和其他功能。我们为用户提供会话，以及这些会话中的事件，如添加朋友、下一首歌或滚动广告。这些事件类型在页面功能中给出。</p><p id="9f87" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">我们来分析一下性别特征:</strong></p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="1d66" class="lz kk hh lu b fi ma mb l mc md">df_gender = df.groupby(["gender","userId"]).agg({"churn":"mean"})<br/>df_gender_churn_rate = df_gender.groupby("gender").agg({"avg(churn)":"mean"})<br/>fig = plt.figure(figsize=(8, 4))<br/>sns.barplot(x="gender", y="avg(avg(churn))", data=df_gender_churn_rate.toPandas())</span></pre><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es me"><img src="../Images/023a448cc74fc925f960243317dbd6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*F7Gnjl2c9o_HtCtF7f_5uQ.png"/></div></figure><p id="daa1" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在第一种方法中，我们获得用户的流失值，因为它在用户的所有行中都是相同的。然后我们通过性别分组再次取平均值，我们得到性别的流失率。性别似乎没有提供足够的信息来预测客户流失。</p><p id="1a44" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">我们来分析一下关卡特性:</strong></p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="b3b2" class="lz kk hh lu b fi ma mb l mc md">df_level_user = df.groupby(["userId","churn"]).agg({"level":"last"})<br/>df_level_churn_rate = df_level_user.groupby("last(level)").agg({"churn":"mean"})<br/>df_level_churn_rate.show(5)</span></pre><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/7f629d2d63eaaad2ed016aec20a97107.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*vFCvc3LvzLlo4Q9J4paFlA.png"/></div></figure><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es mg"><img src="../Images/88477052ef2b098c446a5be9f263b425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*JIYNBRjJMcpxtGRlTxxsuA.png"/></div></figure><p id="4dfb" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">首先，我们根据用户id和流失状态进行分组，并获得最新级别的用户，以便更好地进行评估。好像我们免费用户有0.26 %的流失率。付费用户的流失率为0.21，低于免费用户。这可能是预测客户流失的一个指标。</p><p id="aae9" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">我们来分析一下歌曲计数特征:</strong></p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="aacb" class="lz kk hh lu b fi ma mb l mc md">df_count_song = df.filter(df.page == "NextSong").groupby(["userId","churn"]).agg(count("song"),countDistinct("song").alias("distinct_song"))<br/>df_song_mean = df_count_song.groupby("churn").agg({"count(song)":"mean","distinct_song":"mean"})<br/>df_song_mean.show(5)</span></pre><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es mh"><img src="../Images/89298cd2402ab8d64079ab04c6d94c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:722/format:webp/1*q9Kwz0F5bEqWQKg4sB8WEw.png"/></div></figure><p id="b5d5" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们可以看到，churn-1用户播放的歌曲比非churn用户少。从歌曲数量和不同的歌曲数量来看，他们播放的歌曲较少。</p><p id="e41b" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">我们来分析一下页面/事件类型特征:</strong></p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es mi"><img src="../Images/11693804bca145e17160f487cea0efb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyJ9a6ivbFxGMSmo8n3FjA.png"/></div></div></figure><p id="7b2e" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们分组并得到每种事件类型的页面数。它给了我们事件的计数，例如:对于第一个用户，他/她添加了4个朋友，得到了1个错误，他/她注销了5次，看到了20个滚动广告，只给了一次否定。它们可能是预测客户流失的指标。</p><p id="dfc3" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">如果我们按流失状态对这些数据进行分组并分析结果，我们会看到:</p><ul class=""><li id="5735" class="mj mk hh jf b jg jh jk jl jo ml js mm jw mn ka mo mp mq mr bi translated">流失的人倾向于少加好友。</li><li id="fe5d" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人倾向于在播放列表中添加较少的歌曲。</li><li id="2579" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人不太可能点击降级页面。</li><li id="7015" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人不太可能出错</li><li id="b3fa" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人不太可能需要帮助</li><li id="1876" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人可能会得到更多的滚动广告</li><li id="48ba" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">流失的人给予大拇指向上或向下的数字较低，似乎他们不喜欢与应用程序的互动。</li></ul><p id="e69f" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们将对每个用户进行标准化，因为每个用户的数量是不同的。它可能会误导算法。</p><p id="e476" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">加好友，提交降级升级都是实数。所以我们把这些排除在百分比公式之外。我们创建了一个总计数列，并将页面计数除以这个数字，以便对每个用户进行标准化。我们得到:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es mx"><img src="../Images/a7a26bf97f5c6fea511465c43a781e1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qcxbu2tAhZlovu261TNWA.png"/></div></div></figure></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h1 id="50f1" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">3.特征工程</h1><p id="609f" class="pw-post-body-paragraph jd je hh jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka ha bi translated">我们将创建新的功能除了现成的功能后，EDA。</p><p id="0c16" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> a .平均会话持续时间</strong></p><p id="6faf" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们将为用户获取每个会话的开始和结束时间。然后，我们可以通过计算这些日期的差异来添加“会话持续时间”列。</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="da99" class="lz kk hh lu b fi ma mb l mc md">df_session_length = df_session_length.withColumn('session_duration',(col("max_time").cast("long") - col("min_time")\                                                                     .cast("long"))/60)</span></pre><p id="3a46" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">按用户分组基于此会话的数据，我们得到:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es my"><img src="../Images/a75b4426761122f569a890e210c6dde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/format:webp/1*wFtkK6AmE6euWTAyM3CQXg.png"/></div></figure><p id="7d39" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> b .每次会话的平均歌曲数</strong></p><p id="bcba" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们按用户id和会话id对数据进行分组，计算该会话中播放的歌曲。则会话的平均歌曲计数作为新特征而产生。流失用户在他们的会话中播放较少的歌曲可能是一个事实:)</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="686a" class="lz kk hh lu b fi ma mb l mc md">df_avgsong_allsession = df.groupby(["userId","sessionId"]).agg(count("song"))<br/><br/>df_avgsong_per_session = df_avgsong_allsession.groupby("userId").agg({"count(song)":"mean"})<br/>df_avgsong_per_session.show(3)</span></pre><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es mz"><img src="../Images/5b3d6c7f0c43afe10acfa713fa1400ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*JANr9M5cTvPjc37bLvHX7g.png"/></div></figure><p id="6dc3" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> c .平均会话间隔持续天数</strong></p><p id="e4bf" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">一些用户可能很少使用app，一些用户每天都会定期使用。为了理解这一点，我们将创建一个特征。我们将使用最小和最大日期以及会话计数来计算此功能。我们得到时间间隔，然后将这些时间间隔除以时间指标和会话计数，最后得到以天为单位的平均间隔持续时间。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es na"><img src="../Images/44a13d813e73215447e6ebb1cb81e394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t_RAXb2P2z5VqFCgTrGXEg.png"/></div></div></figure><p id="38ea" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">然后我们得到:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/4f8abc8ef94c70f8680691a18857617c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*jpk-mCtDvlUU_t9I--9e5Q.png"/></div></figure><p id="4a73" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> d .自登记日期起的任期特征</strong></p><p id="b8be" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们在所有行上都有注册日期，这是用户的开始日期。如果我们得到最大会议日期，减去注册日期，我们达到任期功能的天。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nc"><img src="../Images/d0f71a7cd53a4c03ef851dfb2ea0c44e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cXjBQqQMd-tSow4XRzLrxQ.png"/></div></div></figure><p id="99b8" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">艺人范围KPI </strong></p><p id="db63" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">一些用户倾向于听相同的歌手，这可能是一个很好的迹象，表明他们会使用应用程序更长时间，因为他们有些沉迷于听一些选定的音乐，我们可以说他们有特定的喜好。</p><p id="78a3" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">为了计算该特征，我们将不同艺术家计数除以总艺术家计数。如果用户听同一个艺术家，这个数字将接近0，否则接近1。</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="007b" class="lz kk hh lu b fi ma mb l mc md">df_page_pivot = df_page_pivot.withColumn("artist_range",  <br/>                                    df_page_pivot["distinct_artist"] / df_page_pivot["count(artist)"] )</span></pre><p id="00a7" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> f .时段趋势(过去7天对比上周)</strong></p><p id="8920" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们现在将创建一个需要更复杂计算的特征，我们将使用pyspark中的窗口函数来查找我们的特征。</p><p id="9654" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">首先，我们按用户id和会话id对数据进行分组，并以日期时间和时间戳格式找到会话的最大日期。然后，对于每一行，我们返回7天和14天，并计算会话数(行数)。我们通过按用户标识划分数据并使用窗口函数来实现。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nd"><img src="../Images/0d4c86d05e50aaf29a72d6a69547960f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0cHOl_u57bRGQjt_efD0tw.png"/></div></div></figure><p id="61db" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在找到这个用户的基于会话的数据后，我们必须只取最新的会话，因为我们将使用它来比较7天与前一周。要做到这一点，我们需要给会话一个等级数，只取第一个。我们通过使用pyspark.sql函数库中的行号函数来实现这一点。</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="9054" class="lz kk hh lu b fi ma mb l mc md">df_session_limited3 = df_session_limited2.withColumn("rn", F.row_number().over(Window.partitionBy("userId").orderBy(F.col("datetimeNew").desc())))</span></pre><p id="65b3" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">现在我们在表中有了名为“rn”列的秩数:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es ne"><img src="../Images/3f5eebdb11e1a42a31f9cea1d3e74e4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PlZKNkyWLofLhalcdGXiUQ.png"/></div></div></figure><p id="d8d4" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">现在，我们只为所有用户选择排名第一的行，并检查用户的数据:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nf"><img src="../Images/7f2f1bbafd894ef29417bded7d526ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u2KqoweC7B5vzrYWHQiMdQ.png"/></div></div></figure><p id="99aa" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">让我们创建一个趋势公式=(上周会话计数)/(过去14天会话计数+ 0.01)</p><p id="9f68" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">如果过去14天没有会话，我们会添加0.01。分母为零对我们来说可能是个问题。</p><p id="9cbe" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">如果新的KPI低于0.5，我们可以说上周的会话数与上周相比有所减少。让我们应用这些并检查userd33。</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="c23b" class="lz kk hh lu b fi ma mb l mc md">df_session_limited3 = df_session_limited3.withColumn("last_week_trend",df_session_limited3["sessions_in_7_days"] / (df_session_limited3["sessions_in_14_days"] + 0.01 ))<br/>df_session_limited3.filter(df_session_limited3.userId == "33").show()</span></pre><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es ng"><img src="../Images/784f93b1e5254d22662f3eecdb0522a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sjz-YLykYv4z322B8sPxkA.png"/></div></div></figure><p id="8f2d" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">然后，我们为所有用户提供了新功能:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nh"><img src="../Images/63dcaa9eec00bcb9600fe7eab37b910d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*bBssr39fY-LKb0Qaz240Fw.png"/></div></div></figure><p id="8938" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> g .删除高基数特性</strong></p><p id="c7e7" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在我们的数据集中，我们有一些分类特征，如位置和用户代理。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es ni"><img src="../Images/56cc27e0140f796472148113e7ed1c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kR7EXWxLBb_Tsn1-8EfEKA.png"/></div></div></figure><p id="12b7" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">对于位置功能，您可以从左边的条形图中看到，有如此多的选项。如果我们对我们的数据使用这个特征(我们的数据包括448个人)，将会有算法的误用，特别是基于树的算法。所以我不会用这个特性来得到一个健康的模型。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es nj"><img src="../Images/abfd08ac98072fa86faeba8f70a063fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*L79rqCQrR0VS1Gwws4UAjg.png"/></div></figure><p id="f59d" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">对于用户代理特性，我们可以很容易地说同样的事情。在我们的数据集中有71个不同的用户代理和448个用户。从这种糟糕的数据中学习，因为每个用户代理标签的数量非常少，这对我们的模型没有好处。</p><p id="39cc" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> h .将所有特征连接在一起</strong></p><p id="adb8" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们通过使用userı将主数据与新特性结合起来。</p><pre class="ln lo lp lq fd lv lu lw lx aw ly bi"><span id="a610" class="lz kk hh lu b fi ma mb l mc md">df_page_pivot = df_page_pivot.join(df_session_avg,["userId"])<br/>df_page_pivot = df_page_pivot.join(df_avgsong_per_session,["userId"])<br/>df_page_pivot = df_page_pivot.join(df_session_interval,["userId"])<br/>df_page_pivot = df_page_pivot.join(df_user_tenure,["userId"])<br/>df_page_pivot = df_page_pivot.join(df_session_trend,["userId"])</span></pre><p id="cbb0" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">让我们在整个数据中再次检查流失率:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es nk"><img src="../Images/898cb87279e05d17186309a82a7a9e24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1254/format:webp/1*dYbCL_fOSKXbwDwA9QImOQ.png"/></div></figure><p id="b7fb" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">22%的用户已经退出了该应用程序。</p><p id="ede8" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">一、多重共线性测试</strong></p><p id="78e0" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">首先，我们将创建一个热图来进行可视化分析:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es nl"><img src="../Images/5f0e59c58423fc6970bfddd00531d381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1326/format:webp/1*vCOUtoKhCNezKUni39CLsg.png"/></div></figure><p id="6f33" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">一些特征似乎是相关的。</p><ul class=""><li id="e1fd" class="mj mk hh jf b jg jh jk jl jo ml js mm jw mn ka mo mp mq mr bi translated">计数歌曲和计数艺术家几乎计数相同的播放行和高度相关，我会放弃计数艺术家。</li><li id="a6e6" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">艺术家范围和计数(不同艺术家)相关，我将删除计数(不同艺术家)，因为我们有艺术家范围KPI。</li><li id="a75d" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">由于艺术家范围衡量音乐使用的多样性，我们可以删除计数(独特的歌曲)功能。因为计数歌曲和计数(不同歌曲)也是高度相关的。</li><li id="32d9" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">每个会话的平均歌曲数和平均会话持续时间高度相关，我将删除平均歌曲数。</li><li id="fe4f" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">数宋和sum(length)高度相关，我就滴sum(length)了。</li><li id="7c55" class="mj mk hh jf b jg ms jk mt jo mu js mv jw mw ka mo mp mq mr bi translated">加好友和数歌相关，我会掉加好友。</li></ul><p id="6c23" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">drop = "count(artist)"、" distinct artist "、" avg(count(song))"、" sum(length)"、" distinct song "、" Add Friend "</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h1 id="57f3" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">4.系统模型化</h1><p id="9332" class="pw-post-body-paragraph jd je hh jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka ha bi translated">我们只有22%的流失用户，所以我们应该为我们的模型测量F1分数。</p><p id="5b5f" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">如果按精度衡量，可以预测所有样本为0类，达到78%的精度:)</p><p id="ec66" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">F1将是衡量客户流失的一个好方法。</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nm"><img src="../Images/d1dece595f3fa8645dcf5ad2d6022193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Oa-RYuk3nASoP6TtB0rhNg.gif"/></div></div><figcaption class="iv iw et er es ix iy bd b be z dx translated">贷方:【https://pmirla.github.io/2018/11/15/precison_recall.html T4】</figcaption></figure><p id="ff71" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们将使用这些分类算法:</p><p id="ad37" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> <em class="kb">逻辑回归</em> </strong></p><p id="81be" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">实际上，逻辑回归基本上是一种回归算法。主要的区别是，这一次在将权重与特征值相乘后，我们使用这个总和，并将其传递给一个sigmoid函数，得到一个介于0和1之间的值。这给了我们一个概率和一个很好的分类器。它的目标也是最大化“最大似然性”，而不是最小化回归的“均方误差”。</p><p id="ae8d" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> <em class="kb">决策树分类器</em> </strong></p><p id="2044" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">决策树是一种几乎基于规则的非参数算法，它使用n个特征在n轴输入空间上几何地划分零件。它从数据中学习如何以最佳信息增益分割特征空间。它随着特征添加规则而增长，最终形成一个几乎树状的基于规则的模型。它也可以用于回归。</p><p id="a2bf" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> <em class="kb">随机森林分类器</em> </strong></p><p id="bdd1" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">决策树算法中的随机森林驱动。这一次算法不使用单棵树，使用这么多棵树。这些小树不是从所有数据中学习，而是从随机样本中学习。然后这些关于分类的小树决策进入投票系统并决定模型决策。可以说，与决策树和逻辑回归相比，它是一种更加黑箱化的算法。它也可以用作回归。</p><p id="e700" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi"> <em class="kb">梯度提升树分类器</em> </strong></p><p id="5728" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">梯度推进算法是一种集成算法，它使用许多预测器，如随机森林。除此之外，该算法还具有boosting特性。这是通过每个模型关注其前任的错误来实现的。每个预测器都试图通过减少误差来改进其前身。这个逻辑使得这个算法很特别。</p><p id="76c7" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在使用算法之前，首先我们借助pyspark.ml库的StringIndexer函数将分类变量性别和级别转换为数字。</p><p id="4410" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">然后我们检查空值，发现没有空值:</p><figure class="ln lo lp lq fd ii er es paragraph-image"><div role="button" tabindex="0" class="io ip di iq bf ir"><div class="er es nn"><img src="../Images/530696ff9d7a1a282fffaa44ba5e6315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wg1IVvmAST4UXdFNu56Y-A.png"/></div></div></figure><p id="e13e" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">然后，我们使用经典的训练-测试分割:)方法，测试规模为0.2。</p><p id="544a" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在train-test split之后，我们为pyspark创建了一个由交叉验证器组成的函数。它包括一个由向量汇编器、最小最大缩放器和分类器组成的流水线。我们为交叉验证器选择3号折叠。</p><p id="95c3" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">为了评估，我们创建了另一个函数来测量训练和测试数据的准确性和F1，这样我们就可以正确地测量我们的模型。</p><p id="7d9f" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">使用默认设置实现算法后:</p><h2 id="3527" class="lz kk hh bd kl no np nq kp nr ns nt kt jo nu nv kx js nw nx lb jw ny nz lf oa bi translated"><strong class="ak">最终对比:</strong></h2><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es ob"><img src="../Images/46f1ecffa76a25cf17321c644a447da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*ZCp4Zc4N81x18kJq4LcKMw.png"/></div></figure><p id="5154" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">正如我们从最终表格中看到的，通过评估测试数据指标F1和准确性，逻辑回归是最成功的算法。</p><p id="7b78" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我们可以有把握地宣称，逻辑回归为我们的数据集创建了一个很好的模型。决策树和特别是GradientBoost似乎过度拟合数据，因为它们的训练指标非常高，而测试指标与逻辑回归不兼容。</p><p id="b0ff" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我通过GridSearchCV使用一些参数搜索尝试了逻辑回归，但是没有得到任何更好的结果。所以我们可以在数据集中使用默认的LR模型。</p><p id="ca44" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">特征重要性:</strong></p><figure class="ln lo lp lq fd ii er es paragraph-image"><div class="er es oc"><img src="../Images/4cb08f3ab1409c2aa3ed7555145d2cad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1162/format:webp/1*49RQx9s8G0Caq_hSbq0Wew.png"/></div></figure></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><h1 id="8c79" class="kj kk hh bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">5.调查结果和结论</h1><p id="d3fc" class="pw-post-body-paragraph jd je hh jf b jg lh ji jj jk li jm jn jo lj jq jr js lk ju jv jw ll jy jz ka ha bi translated">在这个项目中，我们为一个虚构的音乐应用程序创建了一个中小型的事件类型数据集。我们想建立一个退出使用应用程序的客户流失模型。如果我们能在这些客户离开之前预测他们，我们就能接触到他们，并推广一些活动或折扣，这样就不会失去客户。这将使公司更有利可图。</p><p id="bfa1" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">分析数据集和其中的特征显示了一些关于流失的指标。除了这些现成的表格格式的功能，我们还添加了一些测量用户行为、消费和属性的功能。添加这些额外的功能使我们的模型更加坚实和强大。</p><p id="df1b" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在最后一部分，我们尝试了pyspark.ml库中的一些现成模型，并选择了具有默认设置的逻辑回归算法。我们可以说，我们在数据集中的特征会或多或少地影响我们客户的流失概率。这些特征的权重是模型的参数，唯一的区别是这些总权重与特征值相乘得到一个sigmoid函数，并转化为搅动的概率值。</p><p id="f575" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">在这个项目中，我们使用IBM Watson Studio及其spark &amp; hadoop特性来更轻松地分析数据。我们使用pyspark python模块在spark和hadoop系统中工作。</p><p id="a0ea" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">非常感谢Udacity和本项目的数据提供商。</p><p id="9dc1" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">我希望你喜欢它，并能给我的作品一个好的掌声:)</p><p id="5f66" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated">谢谢大家！</p><p id="6299" class="pw-post-body-paragraph jd je hh jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka ha bi translated"><strong class="jf hi">资源:</strong></p><div class="od oe ez fb of og"><a href="https://databricks.com/blog/2015/07/15/introducing-window-functions-in-spark-sql.html" rel="noopener  ugc nofollow" target="_blank"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hi fi z dy ol ea eb om ed ef hg bi translated">Spark SQL中的窗口函数介绍</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">在这篇博文中，我们介绍了Apache Spark中添加的新窗口函数特性。窗口功能允许…</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">databricks.com</p></div></div><div class="op l"><div class="oq l or os ot op ou is og"/></div></div></a></div><div class="od oe ez fb of og"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/solving-complex-big-data-problems-using-combinations-of-window-functions-deep-dive-in-pyspark-b1830eb00b7d"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hi fi z dy ol ea eb om ed ef hg bi translated">使用窗口函数的组合解决复杂的大数据问题。</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">Spark2.4，Python3。</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">medium.com</p></div></div><div class="op l"><div class="ov l or os ot op ou is og"/></div></div></a></div><div class="od oe ez fb of og"><a href="https://towardsdatascience.com/the-most-complete-guide-to-pyspark-dataframes-2702c343b2e8" rel="noopener follow" target="_blank"><div class="oh ab dw"><div class="oi ab oj cl cj ok"><h2 class="bd hi fi z dy ol ea eb om ed ef hg bi translated">pySpark数据帧最完整的指南</h2><div class="on l"><h3 class="bd b fi z dy ol ea eb om ed ef dx translated">包含您可能需要的所有数据框架功能的书签备忘单</h3></div><div class="oo l"><p class="bd b fp z dy ol ea eb om ed ef dx translated">towardsdatascience.com</p></div></div><div class="op l"><div class="ow l or os ot op ou is og"/></div></div></a></div></div></div>    
</body>
</html>