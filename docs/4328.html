<html>
<head>
<title>What is Content-Based Filtering? An Applied Example in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是基于内容的过滤？Python中的一个应用实例</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-is-content-based-filtering-an-applied-example-in-python-42acb4cbaa30?source=collection_archive---------0-----------------------#2021-09-23">https://medium.com/analytics-vidhya/what-is-content-based-filtering-an-applied-example-in-python-42acb4cbaa30?source=collection_archive---------0-----------------------#2021-09-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2290" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于内容过滤的电影推荐系统开发</p><p id="c508" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你好。在这个故事中，我们将试图涵盖什么是基于内容的过滤，我们将通过使用这个数据集来编写一个简单的电影推荐程序。该数据集包含电影和用户评级数据。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c5618d1b4e79f24ed191ac7fa2bc109c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gwh4ElgPDfTIF0AfGxrdxQ.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">由<a class="ae jc" href="https://unsplash.com/@franki?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">弗兰基·查马基</a>在<a class="ae jc" href="https://unsplash.com/s/photos/artificial-intelligence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="260a" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="bf3c" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">有几种类型的推荐系统技术。基于内容的过滤就是其中之一。我们可以简单地解释为；这种技术通过使用项目的描述来创建推荐。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kw"><img src="../Images/3c6a1a09a783f3f034d89df575a049f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jmhbvj4DDbNLCz9J7QhjYA.png"/></div></div></figure><h1 id="70fd" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是基于内容的过滤？</h1><p id="d9dc" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">如上所述，我们将使用项目的描述或我们将用于创建推荐系统的功能。然而，正如我们所知，计算机不能像我们理解的那样理解我们的文本。例如，当我正在搜索一部周日晚上的电影时，如果我在电影的描述中看到“战争”这个词，我可以理解为这部电影是关于战争的。但是当电脑看到这个词时，它将不能识别这部电影是关于战争的。这不是他们的本性。因此，我们需要将文本表示为数学形式，以便计算机能够理解。</p><p id="7e0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们需要矢量化每个文本，然后我们可以使用几种类型的技术。我们可以计算每个向量的相似度或距离。以下是用数学方法表示文本的常用技术:</p><ul class=""><li id="ce4d" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">计数向量</li><li id="aa62" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">TF-IDF</li></ul><p id="453b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以使用以下公式计算它们的距离:</p><ul class=""><li id="3aa4" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">欧几里德距离</li><li id="9213" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">余弦相似性</li></ul><p id="29ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们看到下面的数据结构就是我们想要的基于内容的过滤。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ll"><img src="../Images/4d7c9d0dd8721f5bd695e72527d5f36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rq79dd2U4Aly0R2VtoBU7g.png"/></div></div></figure><p id="5ab2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">行代表项目(电影、产品等。)和列代表单词。我们在专栏中看到了所有电影描述中的独特词汇。交叉单元格表示电影包含N个相同的单词。</p><p id="4a85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们计算行(每个电影的单词向量)距离，并推荐距离较小的电影。</p><p id="ea65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个故事中，我们将使用TF-IDF矢量化技术。</p><h2 id="78d0" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">什么是TF-IDF？</h2><p id="82bd" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这是一种矢量化技术。下面可以看到TF-IDF矢量化的步骤。</p><ul class=""><li id="efd8" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">TF(t):术语频率。t项在整个文档中的出现频率/文档中的总项数</li><li id="4c78" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">IDF(t):逆文档频率。1 + log_e((文档总数+ 1) /(包含t项的文档总数+ 1))。</li><li id="78fc" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">TF-IDF : TF(t) * IDF(t)</li><li id="154e" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">每个TF-IDF值的L2归一化</li></ul><h1 id="cf61" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">Python中的一个应用实例</h1><p id="ca96" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">为了使用基于内容的过滤，我们将使用<code class="du ma mb mc md b">sklearn</code>包。您可以使用以下命令安装它:</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="b300" class="lm ju hh md b fi mi mj l mk ml">pip install sklearn</span></pre><h2 id="463d" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">导入库</h2><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="3588" class="lm ju hh md b fi mi mj l mk ml">from sklearn.metrics.pairwise import cosine_similarity<br/>from sklearn.feature_extraction.text import TfidfVectorizer<br/>import pandas as pd</span></pre><h2 id="e1f3" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">正在加载数据集</h2><p id="cc3e" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我已经把数据集下载到了我的工作区，我在故事开始时提到过。因此我将直接使用<code class="du ma mb mc md b">read_csv</code>方法。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="2518" class="lm ju hh md b fi mi mj l mk ml">df = pd.read_csv("the_movies_dataset/movies_metadata.csv",<br/>                 low_memory=False)</span><span id="18de" class="lm ju hh md b fi mm mj l mk ml">df.head(1)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mn"><img src="../Images/61a116de06ec416b9f8bdf7fd1d1e8bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oYTZA3Nbbv3rOVhPPitW5Q.png"/></div></div></figure><h2 id="1cf8" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">正在准备数据集</h2><p id="e5e8" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">这个数据集有这么多列。然而，我们不会全部使用它们。我将从中选择3个需要的列。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="7ad7" class="lm ju hh md b fi mi mj l mk ml">df = df[['id','title','overview']]</span><span id="ffa4" class="lm ju hh md b fi mm mj l mk ml">df.head(1)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/b120e7992c1941399a161c5fe7b826eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*SrFHM3wrvFBkr-TTadrfKg.png"/></div></figure><ul class=""><li id="2222" class="kx ky hh ig b ih ii il im ip kz it la ix lb jb lc ld le lf bi translated">id列保存电影的id</li><li id="f4e6" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">标题列包含电影的标题</li><li id="1e5a" class="kx ky hh ig b ih lg il lh ip li it lj ix lk jb lc ld le lf bi translated">“概述”栏包含影片的概述。我们将使用这个专栏进行矢量化。我们将创建的推荐系统将使用这些词进行推荐。</li></ul><h2 id="1e63" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">创建TF-IDF矩阵</h2><p id="e322" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我将使用<code class="du ma mb mc md b">sklearn</code>中的<code class="du ma mb mc md b">TfidfVectorizer</code>功能。我将把“english”传递给它的stop_words参数。如果概览为空，我将用<code class="du ma mb mc md b">'’</code>填充概览。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="91f7" class="lm ju hh md b fi mi mj l mk ml">tfidf = TfidfVectorizer(stop_words='english')</span><span id="ad93" class="lm ju hh md b fi mm mj l mk ml">df['overview'] = df['overview'].fillna('')</span></pre><p id="0226" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我需要通过使用概述来创建TF-IDF矩阵。在这个矩阵中，行代表电影，列代表来自概观的独特单词。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="bc4f" class="lm ju hh md b fi mi mj l mk ml">tfidf_matrix = tfidf.fit_transform(df['overview'])</span><span id="ec66" class="lm ju hh md b fi mm mj l mk ml">tfidf_matrix.shape</span><span id="868e" class="lm ju hh md b fi mm mj l mk ml">&gt;&gt;&gt; (45466, 75827)</span></pre><p id="3bd1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们有45466部电影和75827个独特的词。如果我检查唯一的电影标题计数，我希望看到与TF-IDF矩阵的行数相同的计数。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/17735c735659f22f1d941bee71076fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*kMN4STXvGUWjE24PnSz61w.png"/></div></figure><h2 id="4a47" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">计算余弦相似度</h2><p id="9197" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我将使用<code class="du ma mb mc md b">cosine_similarity</code>函数进行计算。我将把TF-IDF矩阵传递给这个函数，然后这个函数将计算每个向量(电影)的余弦相似度。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="84f3" class="lm ju hh md b fi mi mj l mk ml">cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)</span></pre><p id="cad4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这一点上，我可以看到电影之间的相似之处。我们在下面的中看到了第二部电影的相似之处。正如你可能注意到的，我们在这个数组的第二个索引处看到了1。因为这意味着第二部电影和第二部电影的相似性，显然他们是一样的。因此，相似性在第二个索引上是1。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="d0a4" class="lm ju hh md b fi mi mj l mk ml">cosine_sim[1]</span><span id="47cc" class="lm ju hh md b fi mm mj l mk ml">&gt;&gt;&gt; array([0.01504121, 1., 0.04681953, ..., 0. , 0.02198641, 0.00929411])</span></pre><h2 id="d607" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">利用相似性进行推荐</h2><p id="8424" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">首先，我将过滤掉标题为空的电影，并将它们从数据集中删除。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="bba2" class="lm ju hh md b fi mi mj l mk ml">df = df[~df['title'].isna()]</span></pre><p id="91fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我需要得到电影的索引。因为在我们的余弦相似度计算矩阵中，计算矩阵是基于索引的。比如我想看《玩具总动员》和其他电影的相似度，我就用它的索引:<code class="du ma mb mc md b">cosine_sim[0]</code>来得到它的相似度。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="72ce" class="lm ju hh md b fi mi mj l mk ml">indices = pd.Series(df.index, index=df['title'])</span><span id="bd83" class="lm ju hh md b fi mm mj l mk ml">indices = indices[~indices.index.duplicated(keep='last')]</span><span id="398b" class="lm ju hh md b fi mm mj l mk ml">indices</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/ae7f11bd3946645ee1911f0770483323.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*LFrxEz1LjTo3HsLDFL576Q.png"/></div></figure><p id="4695" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我也可以使用这个数据帧来获取电影的id，如下所示。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="2acd" class="lm ju hh md b fi mi mj l mk ml">target_movie_index = indices['Toy Story']</span><span id="f700" class="lm ju hh md b fi mm mj l mk ml">target_movie_index</span><span id="32f2" class="lm ju hh md b fi mm mj l mk ml">&gt;&gt;&gt; 0</span></pre><p id="8479" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我只需要将这个索引传递给余弦相似度矩阵，以获得这部电影与其他电影的相似度0 id(玩具总动员)。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="6875" class="lm ju hh md b fi mi mj l mk ml">cosine_sim[target_movie_index]</span><span id="1464" class="lm ju hh md b fi mm mj l mk ml">&gt;&gt;&gt; array([1., 0.01504121, 0., ..., 0., 0.00595453, 0.])</span></pre><p id="0d09" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将利用这些相似之处创建一个数据框架。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="de34" class="lm ju hh md b fi mi mj l mk ml">similarity_scores = pd.DataFrame(cosine_sim[target_movie_index], columns=["score"])</span><span id="9bb6" class="lm ju hh md b fi mm mj l mk ml">similarity_scores</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mo"><img src="../Images/d19810c9c48fae8411ca128ad036f5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*_wwEfbPojQTBPCdoc1MGsQ.png"/></div></figure><p id="ca0d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们得到45466行，因为我们的余弦相似度计算矩阵具有相同的行数。</p><p id="8ee5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我可以通过使用这些分数获得与<code class="du ma mb mc md b">target_movie_id</code>相似的电影。我将使用保存相似性和索引的score列对数据帧进行排序，然后我将取前11行。第一行是id为<code class="du ma mb mc md b">target_movie_id</code>的电影。越早的行指示越高的相似性，这意味着前11行中的电影是最相似的。我拿到了他们的指数。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="2da0" class="lm ju hh md b fi mi mj l mk ml">movie_indices = similarity_scores.sort_values("score", ascending=False)[0:11].index</span></pre><p id="6e2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过使用上面的这些指数，我可以得到与我的目标电影最相似的前11部电影。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="8e3b" class="lm ju hh md b fi mi mj l mk ml">df['title'].iloc[movie_indices]</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/b4b096947f0a2d4faf2731174242f0f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V5mI9A5LK2dX_W9Q6vHSmA.png"/></div></div></figure><p id="c998" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">恭喜你。我们已经推荐了与我们的目标电影相似的电影。</p><h2 id="edbc" class="lm ju hh bd jv ln lo lp jz lq lr ls kd ip lt lu kh it lv lw kl ix lx ly kp lz bi translated">创建函数</h2><p id="9a6e" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">我将创建一个函数，通过使用我想要的name参数来过滤电影名称。我将使用下面的函数获取包含此名称参数的所有电影名称和索引；</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="bb50" class="lm ju hh md b fi mi mj l mk ml">def get_films_by_name(movie_name, movie_indices):<br/>    return movie_indices[movie_indices.index.str.contains(movie_name, na=False)]</span><span id="0772" class="lm ju hh md b fi mm mj l mk ml">get_films_by_name('Lord', indices)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/66122a5f5f692fae40e39af4edd9b93f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6bKvLvKnH78rdaA8QBlpQ.png"/></div></div></figure><p id="ac9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我将创建一个函数来获取推荐的电影。</p><pre class="je jf jg jh fd me md mf mg aw mh bi"><span id="507f" class="lm ju hh md b fi mi mj l mk ml">def get_recommended_movies(target_movie_index, movie_similarities,movies_df):<br/>    similarity_scores = pd.DataFrame(movie_similarities[target_movie_index], columns=["score"]) <br/>    movie_indices = similarity_scores.sort_values("score", ascending=False)[0:11].index <br/>    return df['title'].iloc[movie_indices]</span><span id="9547" class="lm ju hh md b fi mm mj l mk ml">get_recommended_movies(2007,cosine_sim,df) <br/># 2007 index for "The Lord of the Rings"</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mq"><img src="../Images/ce7292273ab320e0c6742e3f35834ab8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*VWLsb0XGzieBu10MlWxiKQ.png"/></div></figure><p id="793a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看上面的《指环王》推荐电影。</p><h1 id="2e19" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后</h1><p id="8137" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">希望你喜欢这个。另外，我会在Kaggle上分享代码。你可以从<a class="ae jc" href="https://www.kaggle.com/enesbaysan/content-based-filtering" rel="noopener ugc nofollow" target="_blank">这里</a>买到。</p><p id="d865" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">万事如意。</p></div></div>    
</body>
</html>