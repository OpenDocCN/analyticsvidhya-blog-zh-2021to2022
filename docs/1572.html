<html>
<head>
<title>Signals In Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">姜戈的信号</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/signals-in-django-af99dabeb875?source=collection_archive---------1-----------------------#2021-03-08">https://medium.com/analytics-vidhya/signals-in-django-af99dabeb875?source=collection_archive---------1-----------------------#2021-03-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/5eb6b6f6e1f9214d2352d886ef16049f.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*0sq5VhMcEzZ12CpiShVrIw.png"/></div></figure><p id="77ca" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在本文中，我们将讨论Django中有哪些信号，以及如何在我们的Django项目中使用这些信号。那我们开始吧。</p><p id="c7d0" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在许多情况下，当在模型实例中有一些修改或者创建一个特定的模型实例时，我们可能需要执行一些动作。Django提供了一种优雅的方式来处理这种情况。信号是让我们把事件和行动联系起来的工具。</p><p id="8777" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先让我们回顾一下信号的基本概念，</p><p id="18fe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj"> <em class="jk">信号:</em> </strong></p><p id="0b9b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">信号是与特定事件相对应的对象。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="143b" class="ju jv hi jq b fi jw jx l jy jz">from django.dispatch import Signal  </span><span id="85c6" class="ju jv hi jq b fi ka jx l jy jz">make_order = Signal(providing_args=["toppings", "size", "type"])</span></pre><p id="079c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">信号可以在特定事件发生时发送信息。这是通过在信号实例上调用<code class="du kb kc kd jq b">send()</code>方法来实现的(传入一个<code class="du kb kc kd jq b">sender</code>参数，以及上面指定的参数):</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="27e2" class="ju jv hi jq b fi jw jx l jy jz">class Burger:     <br/>    def create_order(self, toppings, size, type):<br/>       make_order.send(sender=self.__class__, toppings=toppings, size=size, type=type)</span></pre><p id="68b7" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated"><strong class="io hj">接收者:</strong></p><p id="53bb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">接收器是连接到每个信号的python函数。当信号发送消息时，每个连接的接收器都被调用。接收器的功能特征应该与信号的<code class="du kb kc kd jq b">send()</code>方法相匹配。您使用<code class="du kb kc kd jq b">@receiver</code>装饰器将接收器连接到信号。</p><pre class="jl jm jn jo fd jp jq jr js aw jt bi"><span id="f3d9" class="ju jv hi jq b fi jw jx l jy jz">from django.dispatch import receiver <br/>from burger import signals  </span><span id="de77" class="ju jv hi jq b fi ka jx l jy jz">@receiver(signals.pizza_done) <br/>def notify-when_order_created(sender, toppings, size, **kwargs):<br/>     # Create an order</span></pre><p id="428d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">以上是信号调度员的基本知识。接收器连接到信号并接收由信号发送消息，并进一步执行</p><p id="1f27" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我将向您展示信号最常见的用例，即在创建用户实例时创建一个概要文件实例。</p><p id="7722" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">最常用的信号是:-</p><blockquote class="ke kf kg"><p id="1de3" class="im in jk io b ip iq ir is it iu iv iw kh iy iz ja ki jc jd je kj jg jh ji jj hb bi translated"><strong class="io hj"><em class="hi">pre _ save/post _ save</em></strong><em class="hi">:—模型的</em> <code class="du kb kc kd jq b"><a class="ae kk" href="https://docs.djangoproject.com/en/3.1/ref/models/instances/#django.db.models.Model.save" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="hi">save()</em></strong></a></code> <em class="hi">方法被调用之前或之后发送。</em></p><p id="6912" class="im in jk io b ip iq ir is it iu iv iw kh iy iz ja ki jc jd je kj jg jh ji jj hb bi translated"><strong class="io hj"><em class="hi">pre _ delete/post _ delete</em></strong><em class="hi">:—在调用模型的</em> <code class="du kb kc kd jq b"><a class="ae kk" href="https://docs.djangoproject.com/en/3.1/ref/models/instances/#django.db.models.Model.delete" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="hi">delete()</em></strong></a></code> <em class="hi">方法或queryset的</em> <code class="du kb kc kd jq b"><a class="ae kk" href="https://docs.djangoproject.com/en/3.1/ref/models/querysets/#django.db.models.query.QuerySet.delete" rel="noopener ugc nofollow" target="_blank"><strong class="io hj"><em class="hi">delete()</em></strong></a></code> <em class="hi">方法之前或之后发送。</em></p></blockquote></div><div class="ab cl kl km gp kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="hb hc hd he hf"><figure class="jl jm jn jo fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="b2d1" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">解释:</p><p id="38fb" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先我们导入了post_save和receiver，然后我们创建了一个接收函数create_user_profile，它将接收post_save信号。我们使用receiver decorator在创建用户实例时调用create_user_profile函数。</p><p id="7a75" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">因此，我们接受create_user_profile函数上的sender、instance、created(这将是一个布尔值，表示用户实例是否已创建)参数，</p><p id="b619" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">并且根据创建的真值，我们为用户创建配置文件对象。</p><p id="89e8" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">上述是实现信号的一种方式，你也可以在不同的文件中使用接收器功能的代码(注意:你必须在应用程序的app.py ready方法中正确导入该文件，否则它将无法工作。</p><p id="54dc" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">信号非常方便，你可以看到信号是同步的，这意味着正常的程序执行流程在继续发送信号的代码之前依次运行每个接收器。你可以在Django文档中阅读更多关于信号的信息。</p><p id="9f0d" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">信号调度机制并不是Django所特有的，它实际上是一种众所周知的设计模式:<strong class="io hj"> </strong> <a class="ae kk" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank"> <strong class="io hj">观察者模式</strong> </a>。唯一的区别是在术语上:在观察者模式中，信号被称为“主体”，接收器被称为“观察者”。</p><p id="c2d6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如果你在实现信号时遇到任何困难，请在评论中告诉我。</p><p id="3e89" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">编码快乐！！！</p></div></div>    
</body>
</html>