<html>
<head>
<title>Implementation of Artificial Neural Network in Python- Step by Step Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">人工神经网络在Python中的实现——分步指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/implementation-of-artificial-neural-network-in-python-step-by-step-guide-556d066f9f5b?source=collection_archive---------0-----------------------#2021-03-30">https://medium.com/analytics-vidhya/implementation-of-artificial-neural-network-in-python-step-by-step-guide-556d066f9f5b?source=collection_archive---------0-----------------------#2021-03-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5349d456cb27d8d39286bd4b77d41c65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1UWs6qblvHrqR40k.jpg"/></div></div></figure><p id="7081" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这篇文章中，我将分享用Python 实现人工神经网络(ANN)的<strong class="is hj">。因此，请花几分钟时间了解一下<strong class="is hj">人工神经网络以及如何用Python实现ANN。</strong></strong></p><p id="2431" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，事不宜迟，让我们开始吧-</p><h1 id="6f85" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">用Python实现人工神经网络</h1><p id="a1e9" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在开始用Python实现人工神经网络之前，我想告诉你关于<a class="ae kr" href="https://www.mltut.com/best-deep-learning-courses-on-coursera/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">人工神经网络</strong> </a>及其工作原理。</p><h1 id="37a4" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">什么是人工神经网络？</h1><p id="b485" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">人工神经网络与人脑非常相似。</p><p id="703b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人脑由神经元组成。这些神经元是相连的。在人脑中，神经元看起来像这样…</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7c1810c63a0f7ce5a5acc7f645cf8da9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*x_YMDMTAh6SPjKiv.png"/></div></div></figure><p id="7e4a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在这张图片中看到的，有<strong class="is hj">神经元、树突和轴突。</strong></p><p id="f7fe" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">你怎么看？</strong></p><p id="bb75" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你触摸热的表面时，你如何突然移开你的手？。这是发生在你体内的过程。</p><p id="8973" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你触摸热的表面时。然后你的皮肤会自动向神经元发送信号。然后神经元做出决定<strong class="is hj">“拿开你的手”</strong>。</p><p id="145e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是关于人类大脑的全部内容。同理，<strong class="is hj">人工神经网络工作。</strong></p><p id="0029" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">人工神经网络有三层</p><ol class=""><li id="acbc" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">输入层。</li><li id="9679" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">隐藏层。</li><li id="81d9" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">输出层。</li></ol><p id="366f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看这张图片</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lk"><img src="../Images/69059714dd7e4d416b79271654f9d55e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Uz90_IT0umsvJybc.png"/></div></div></figure><p id="8811" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在这张图片中，你看到的所有圆圈都是神经元。人工神经网络<strong class="is hj">完全连接</strong>与这些神经元。</p><p id="8146" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据被传送到<strong class="is hj">输入层</strong>。然后输入层把这个数据传递给下一层，这是一个<strong class="is hj">隐藏层</strong>。隐藏层执行某些操作。并将结果传递给<strong class="is hj">输出层</strong>。</p><p id="496d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，这是一个人工神经网络的基本粗略工作流程。在这三层中，执行各种计算。</p><p id="e8b9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们详细了解每一层。所以第一层是<strong class="is hj">输入层</strong>。</p><h2 id="0483" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">输入层</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/33a350df4a4ca4c9ea05622c6bfaf949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*NQUMjWcyc4D9ycvO"/></div></figure><p id="c093" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">我想现在你脑子里可能有一个疑问，输入层传递的是什么信号？。</strong></p><p id="b0d7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以就人脑而言，这些输入信号就是你的感官。这些感官是你能看到、听到、闻到或触摸到的任何东西。例如，如果你触摸一些热的表面，然后突然一个信号被发送到你的大脑。这个信号是人脑的输入信号。</p><p id="8917" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是，</p><p id="ac00" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">就人工神经网络而言，输入层包含<strong class="is hj">个独立变量</strong>。所以自变量<strong class="is hj">变量1，自变量2，自变量n. </strong></p><p id="abfa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要记住的重要一点是，这些<strong class="is hj">自变量是针对一个观察值</strong>的。更简单地说，假设有不同的自变量，比如一个人的年龄、薪水和工作角色。所以对一个人或一行，取所有这些自变量。</p><p id="1376" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要知道的另一个要点是，你需要对这些自变量进行一些<strong class="is hj">标准化或规范化</strong>。这取决于具体情况。做标准化或规范化的主要目的是使所有的值都在同一个范围内。我将在实现部分讨论这一点。</p><p id="f442" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们进入下一层，那就是-</p><h2 id="59e4" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">输出层-</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/c6e2438827bc5f193272146658ced2cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*hSe0ZV_cWEkhwbj5"/></div></figure><p id="6504" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">那么，接下来的问题就是产出值可以是多少？</strong></p><p id="60a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">答案是输出值可以是-</p><ol class=""><li id="5970" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">连续的(比如价格)。</li><li id="c923" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">二进制(是/否形式)。</li><li id="138e" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">分类变量。</li></ol><p id="e869" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果输出值是分类的，那么重要的是，在这种情况下，你的输出值不是1。它可能不止一个输出值。正如我在图中所示。</strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/a15fe893f0e053369ee875f08d1420f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*f32rvivFhxlutS7-"/></div></figure><p id="7198" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来，我将讨论突触。</p><h2 id="5391" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">突触-</h2><p id="69e1" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">突触只不过是两层之间的连接线。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/69264ade2b3d3e5a57f6a1f9888eec48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*FdvYUw6aEcdc60Rn"/></div></figure><p id="b396" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在突触中，权重被分配给每个突触。这些权重对于人工神经网络的工作至关重要。权重是神经网络学习的方式。通过调整权重，神经网络决定什么信号是重要的，什么信号是不重要的。</p><h2 id="a7b1" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">隐藏层或神经元-</h2><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/73d798f16f1aabad0c83adf512bff298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/0*SaRj9osWgHigAaVs"/></div></figure><p id="6dc0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">下一个问题是神经元内部发生了什么？</strong></p><p id="a005" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">所以在神经元内部，发生了两个主要的重要步骤——</strong></p><ol class=""><li id="7b71" class="kw kx hi is b it iu ix iy jb ky jf kz jj la jn lb lc ld le bi translated">加权和。</li><li id="c797" class="kw kx hi is b it lf ix lg jb lh jf li jj lj jn lb lc ld le bi translated">激活功能。</li></ol><p id="a2c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一步是加权求和，这意味着分配给突触的所有权重都加上输入值。差不多吧-</p><p id="26df" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">【x1 . w1+x2 . w2+x3 . w3+………………..Xn。Wn] </strong></p><p id="202c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">计算加权和后，将<strong class="is hj">激活函数</strong>应用于该加权和。然后神经元决定是否将这个信号发送到下一层。</p><p id="7f37" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望现在你已经理解了人工神经网络的基本工作程序。现在我们来看一下人工神经网络在Python 中的实现<strong class="is hj">。</strong></p><h1 id="3d64" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">人工神经网络在Python中的实现</h1><p id="34d6" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了实现，我将使用<strong class="is hj">流失建模数据集</strong>。可以从<a class="ae kr" href="https://www.kaggle.com/mltuts/churn-modelling-data" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj"> Kaggle </strong> </a>下载数据集。人工神经网络既可以用于分类<strong class="is hj">也可以用于回归</strong>。而这里我们要用<strong class="is hj"> ANN进行分类。</strong></p><p id="47f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该数据集具有以下特征-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8811855b27bd5e433d097f2f3aac86b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*otgKKj01TSURnBjQ.jpg"/></div></div></figure><p id="ce80" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">该数据集包含<strong class="is hj">客户Id、姓氏、信用评分、地理位置、性别、年龄、任期、余额、产品数量(从银行使用，如信用卡或贷款等)、有无信用卡(1表示有，0表示无)、活跃会员(表示客户是否使用银行)、估计工资。</strong></p><p id="32c1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以这些都是客户流失建模数据集的独立变量。最后一个特征是<strong class="is hj">因变量</strong>，即<strong class="is hj">客户在未来是否退出银行</strong> ( 1表示客户将退出银行，0表示客户将留在银行。)</p><p id="e543" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">银行使用这些独立变量，分析了客户6个月的行为，无论他们离开银行还是留下来，并制作了这个数据集。</p><p id="893b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，银行必须根据这个数据集为新客户创建一个预测模型。这个预测模型必须为任何新客户预测他或她将留在银行还是离开银行。因此，银行可以为预测模型预测将离开银行的客户提供一些特别的服务。</p><p id="f1bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我希望你现在理解了问题陈述。所以用Python实现人工神经网络的第一步是<strong class="is hj">数据预处理</strong>。</p><h2 id="b5f8" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.数据预处理</h2><p id="8417" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">在数据预处理中，第一步是-</p><h2 id="b693" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.1导入库-</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="4ff2" class="ll jp hi mb b fi mf mg l mh mi">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd</span></pre><p id="f406" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">NumPy是一个开源Python库，用于执行各种<strong class="is hj">数学和科学任务。</strong> NumPy被<strong class="is hj">用于</strong>处理数组。它还具有在<strong class="is hj">线性代数、傅立叶变换和矩阵领域工作的功能。</strong></p><p id="8c44" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Matplotlib </strong>是一个绘图库，用于创建<strong class="is hj">图形，在图形中绘制区域，在绘制区域中绘制一些线，用标签装饰图形等。</strong></p><p id="6d6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> Pandas </strong>是用于<strong class="is hj">数据角力和分析的工具。</strong></p><p id="43a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在第一步中，我们导入了所有需要的库。现在下一步是-</p><h2 id="01b9" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.2加载数据集</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="c888" class="ll jp hi mb b fi mf mg l mh mi">dataset = pd.read_csv('Churn_Modelling_dataset.csv')</span></pre><p id="f08c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，当你在运行这行代码后加载数据集时，你会得到类似这样的数据</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/f04ec8e5f848f1800df95b99a150e292.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QpMi92vbgvBb0Css.jpg"/></div></div></figure><p id="2f0c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如您在数据集中看到的，有13个自变量和1个因变量。但是前三个独立变量<strong class="is hj">行号、客户Id和姓氏</strong>对我们的预测没有用。所以下一步我们会剔除这三个自变量。我们还会拆分X中的自变量和y中的因变量。</p><h2 id="8ad0" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.3将数据集分为X和Y</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="53b1" class="ll jp hi mb b fi mf mg l mh mi">X = pd.DataFrame(dataset.iloc[:, 3:13].values)<br/>y = dataset.iloc[:, 13].values</span></pre><p id="6fcf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么<strong class="is hj"> dataset.iloc[:，3:13]。数值</strong>？因为credit_score的索引值为3。我们希望从信用评分到估计工资的功能。</p><p id="ce31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当你运行这几行时，你会得到两个独立的表X和y，就像这样-</p><p id="357c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">自变量(X)- </strong></p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/8a9ff1ef28b1409b15447e9cc3eda3bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7jwPBdymaMVsiSAt.jpg"/></div></div></figure><p id="bda7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在此图中，您可以看到数据集是从<strong class="is hj"> Credit_Score开始到Estimated_Salary。</strong></p><p id="db77" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">因变量(Y)</strong>–</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/8177e5a8ecde228d9403c6f9f332b74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:276/format:webp/0*KxBJx6L0uek8nHUN.jpg"/></div></figure><p id="af64" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们已经将数据集分成了X和y两部分。下一步是-</p><h2 id="78b0" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.4对分类数据进行编码-</h2><p id="22c1" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为什么需要编码…？</p><p id="0d92" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们可以看到，有两个分类变量——<strong class="is hj">地理和性别。</strong>所以我们必须将这些分类变量编码成一些标签，如性别的0和1。和一些地理变量热编码。</p><p id="23b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先让我们对性别变量执行<strong class="is hj">标签编码- </strong></p><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="9350" class="ll jp hi mb b fi mf mg l mh mi">from sklearn.preprocessing import LabelEncoder, OneHotEncoder<br/>labelencoder_X_2 = LabelEncoder()<br/>X.loc[:, 2] = labelencoder_X_2.fit_transform(X.iloc[:, 2])</span></pre><p id="c8eb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为什么我用2…？</p><p id="867d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为性别变量的索引值为2。</p><p id="623c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在对性别变量进行标签编码后，男性和女性被转换成0和1，就像这样</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/26a78007b4f66ac976d8e8f7fe66d6ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-fz1I7LFA2awKoVO.png"/></div></div></figure><p id="d249" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">o代表女性，1代表男性。现在我们又多了一个分类变量，那就是地理。现在，我们将执行一个热编码，将法国、西班牙和德国转换为0和1形式。</p><p id="b4ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">一个热编码- </strong></p><p id="579d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，我们需要像在性别变量中一样应用标签编码。然后我们将应用一键编码。所以，让我们来看看-</p><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="6fb9" class="ll jp hi mb b fi mf mg l mh mi">labelencoder_X_1 = LabelEncoder()<br/>X.loc[:, 1] = labelencoder_X_1.fit_transform(X.iloc[:, 1])</span></pre><p id="5eed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在应用了标签编码之后，现在是时候应用一个热门编码了</p><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="e58a" class="ll jp hi mb b fi mf mg l mh mi">onehotencoder = OneHotEncoder(categorical_features = [1])<br/>labelencoder_X_1 = LabelEncoder()<br/>X.loc[:, 1] = labelencoder_X_1.fit_transform(X.iloc[:, 1])<br/>X = onehotencoder.fit_transform(X).toarray()<br/>X = X[:, 1:]</span></pre><p id="0f24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，当你运行这段代码时，你会得到类似这样的输出-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/53211e18a914c62034331775689d4388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jjKn0TdMkAhLNHEH.jpg"/></div></div></figure><p id="7356" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">看到数据集后很迷茫…？</p><p id="d425" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我解释一下，</p><p id="5a63" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里<strong class="is hj">【0 0】的意思是——法国。</strong></p><p id="bbda" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">【0 1】意为西班牙，</strong></p><p id="177f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">【1 0】意为德国</strong></p><p id="bba0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，<strong class="is hj">的前两列</strong>代表<strong class="is hj">地理变量</strong>。我希望你现在明白了。</p><p id="7645" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">下一步是将数据集分成训练集和测试集。</p><h2 id="bc00" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.5将X和Y数据集分成训练集和测试集</h2><p id="f85f" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">为了建立机器学习模型，我们需要在训练集上训练我们的模型。为了检查我们模型的性能，我们使用了一个测试集。这就是为什么我们必须将X和Y数据集分成<strong class="is hj">训练集和</strong>测试集。</p><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="d8dc" class="ll jp hi mb b fi mf mg l mh mi">from sklearn.model_selection import train_test_split<br/>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)</span></pre><p id="e373" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当分成训练集和测试集时，你必须记住，80%-90%的数据应该在训练测试中。这也是我写<strong class="is hj"> test_size = 0.2 </strong>的原因。</p><p id="2d21" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经将数据集分成了<strong class="is hj"> X_train、X_test、y-train和y_test。</strong></p><p id="7d30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以下一步是<strong class="is hj">特征缩放。</strong></p><h2 id="7568" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">1.6执行特征缩放</h2><p id="e75b" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">正如您在数据集中看到的，所有值都不在同一范围内，尤其是<strong class="is hj"> Balance和Estimated_salary。这需要大量的计算时间。因此，为了克服这个问题，我们执行<strong class="is hj">特征缩放。</strong></strong></p><p id="7ebc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要确保的一件事是，无论你已经在0个表格中有值，都要在深度学习中执行特征缩放。</p><p id="51ef" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">特征缩放有助于我们<strong class="is hj">在特定范围内标准化数据。</strong></p><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="e65e" class="ll jp hi mb b fi mf mg l mh mi">from sklearn.preprocessing import StandardScaler<br/>sc = StandardScaler()<br/>X_train = sc.fit_transform(X_train)<br/>X_test = sc.transform(X_test)</span></pre><p id="73ed" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">执行要素缩放后，所有值都被归一化，如下所示</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9b7041489905f7a48a0cc874b80b3221.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kDZgiTwhlsZl3ZRe.jpg"/></div></div></figure><p id="27fd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们完成了数据预处理步骤。现在是时候进入第二部分了，那就是建立人工神经网络。</p><h2 id="bd64" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.建立人工神经网络</h2><p id="f853" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">第一步是-</p><h2 id="0593" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.1导入Keras库和包</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="f43c" class="ll jp hi mb b fi mf mg l mh mi">import keras<br/>from keras.models import Sequential<br/>from keras.layers import Dense</span></pre><h2 id="f6ab" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.2初始化人工神经网络</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="8f3a" class="ll jp hi mb b fi mf mg l mh mi">classifier = Sequential()</span></pre><p id="028c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">顺序类允许我们构建人工神经网络，但作为一个层序列。正如我在理论部分告诉你的，人工神经网络是由完全连接的层构成的。初始化人工神经网络后，是时候-</p><h2 id="8f8b" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.3添加输入层和第一个隐藏层</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="193b" class="ll jp hi mb b fi mf mg l mh mi">classifier.add(Dense(output_dim = 6, init = 'uniform', activation = 'relu', input_dim = 11))</span></pre><p id="743f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Dense是Tensorflow中的一个著名类。密集用于在ANN中添加完全连接的层。</p><p id="d25a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">“add”</strong>是<strong class="is hj">顺序类中的方法。</strong> output_dim表示隐藏层中隐藏神经元的个数。但是这没有经验法则。所以我用了6。您可以使用任何其他号码进行检查。</p><p id="5db8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于全连接神经网络，隐含层中的<a class="ae kr" href="https://www.mltut.com/activation-function-and-its-types-which-one-is-better/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">激活函数</strong> </a>应为<strong class="is hj">整流器激活函数</strong>。所以我用<strong class="is hj">‘relu’</strong>。</p><p id="5422" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们的输入层有11个神经元。为什么…？</p><p id="5cb4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为我们有11个自变量(包括2列地理)。</p><p id="3125" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这就是为什么<strong class="is hj"> input_dim = 11。现在我们已经建立了第一个输入层和一个隐藏层。下一步，我们将通过复制这段代码来构建下一个隐藏层</strong></p><h2 id="f4f4" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.4添加第二个隐藏层</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="8406" class="ll jp hi mb b fi mf mg l mh mi">classifier.add(Dense(output_dim = 6, init = 'uniform', activation = 'relu'))</span></pre><p id="cac4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">同样，我们在第二个隐藏层中使用了6个隐藏神经元。现在我们已经添加了一个输入层和两个隐藏层。是时候添加我们的输出层了。</p><h2 id="9c07" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">2.5添加输出层</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="0e52" class="ll jp hi mb b fi mf mg l mh mi">classifier.add(Dense(output_dim = 1, init = 'uniform', activation = 'sigmoid'))</span></pre><p id="f81b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在输出层，我们需要1个神经元。为什么…？</p><p id="8815" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为正如你在数据集中看到的，我们有一个二进制形式的因变量。这意味着我们必须以0或1的形式来预测。这就是为什么输出层只需要一个神经元的原因。</p><p id="593b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我写<strong class="is hj"> output_dim = 1。</strong></p><p id="c96a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">接下来的事情是<strong class="is hj">激活功能</strong>。在输出层，应该有一个Sigmoid激活函数。为什么…？</p><p id="7b08" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因为Sigmoid激活函数不仅可以预测，还可以提供客户是否离开银行的概率。</p><p id="c5a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于激活函数的更多细节，我推荐你阅读这个解释- <a class="ae kr" href="https://www.mltut.com/activation-function-and-its-types-which-one-is-better/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">激活函数及其类型-哪个更好？</strong> </a></p><p id="5037" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们终于完成了第一个人工神经网络的创建。下一步，我们将训练我们的人工神经网络。</p><h2 id="92ff" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">3.训练人工神经网络</h2><p id="c794" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">训练部分需要两个步骤-编译人工神经网络，并使人工神经网络适合训练集。所以让我们从第一步开始-</p><h2 id="d2b1" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">3.1编译人工神经网络</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="9a93" class="ll jp hi mb b fi mf mg l mh mi">classifier.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])</span></pre><p id="ac5c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">编译</strong>是Tensorflow的一种方法。<strong class="is hj">“Adam”</strong>是可以执行<a class="ae kr" href="https://www.mltut.com/stochastic-gradient-descent-a-super-easy-complete-guide/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">随机梯度下降</strong> </a>的优化器。优化器在训练期间更新权重并减少损失。为了理解梯度下降背后的理论，可以查看一下这个解释——<a class="ae kr" href="https://www.mltut.com/stochastic-gradient-descent-a-super-easy-complete-guide/" rel="noopener ugc nofollow" target="_blank"><strong class="is hj">随机梯度下降——一个超级容易的完全指南！</strong> </a>。</p><p id="75ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你需要确定的一件事是，当你做类似的二元预测时，总是使用损失函数作为<strong class="is hj">二元交叉熵</strong>。</p><p id="42cd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了评估我们的人工神经网络模型，我将使用准确性指标。这就是为什么<strong class="is hj"> metrics = ['accuracy'] </strong>。现在我们已经编译了我们的ANN模型。下一步是-</p><h2 id="3c60" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">3.2使ANN适合训练集</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="2954" class="ll jp hi mb b fi mf mg l mh mi">classifier.fit(X_train, y_train, batch_size = 10, nb_epoch = 100)</span></pre><p id="e45d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">与其把我们的预测和真实结果一个一个对比，不如批量执行。所以我才写<strong class="is hj"> batch_size = 10 </strong>。</p><p id="d5db" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">神经网络必须在一定数量的历元上进行训练，以随着时间的推移提高精确度。于是我决定了<strong class="is hj"> nb_epoch = 100 </strong>。所以当你运行这段代码时，你可以看到每个时期的精度。</p><p id="a881" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在第一个纪元，精确度是-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/796e901e73492a8bbe141ddd7c7688eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/0*yy87I0z_tM7roQrl.jpg"/></div></figure><p id="500e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是79%，但是在运行所有100个历元之后，精度增加，我们得到最终精度-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/1c7b57d29f94f16d2c288977d1120777.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/0*5hvyfTlZ26grWtLE.jpg"/></div></figure><p id="b265" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那是83%。挺好的。现在，我们已经完成了培训部分。最后但并非最不重要的部分是预测测试集结果-</p><h2 id="c65c" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">4.预测测试集结果-</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="c0c2" class="ll jp hi mb b fi mf mg l mh mi">y_pred = classifier.predict(X_test)<br/>y_pred = (y_pred &gt; 0.5)</span></pre><p id="0534" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> y_pred &gt; 0.5 </strong>表示如果y-pred在0到0.5之间，那么这个新的y_pred将变成<strong class="is hj"> 0(假)</strong>。如果y_pred大于0.5，那么新的y_pred将变成<strong class="is hj"> 1(真)。</strong></p><p id="628b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以在运行这段代码后，你会得到y_pred，类似这样的结果-</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/58b7b6cb39eb39a17564521d451322e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/0*mSU5vQi_05DN1p31.jpg"/></div></figure><p id="43e4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但是你能通过看这些预测值解释一下，有多少值预测对了，有多少值预测错了吗？</p><p id="1bba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于小型数据集，您可以。但是当我们有一个大的数据集时，这是不可能的。这就是为什么我们使用一个<a class="ae kr" href="https://www.mltut.com/what-is-the-confusion-matrix-in-machine-learning/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hj">混淆矩阵</strong> </a>，来清除我们的混淆。</p><p id="bb31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所以，下一步是-</p><h2 id="d1a3" class="ll jp hi bd jq lm ln lo ju lp lq lr jy jb ls lt kc jf lu lv kg jj lw lx kk ly bi translated">5.制作混淆矩阵</h2><pre class="ks kt ku kv fd ma mb mc md aw me bi"><span id="6d30" class="ll jp hi mb b fi mf mg l mh mi">from sklearn.metrics import confusion_matrix, accuracy_score<br/>cm = confusion_matrix(y_test, y_pred)<br/>print(cm)<br/>accuracy_score(y_test,y_pred)</span></pre><p id="76af" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们得到了84.2%的准确率。</p><figure class="ks kt ku kv fd ij er es paragraph-image"><div class="er es mm"><img src="../Images/5c7ca5c2fdd6c4dcf07a493f611d9d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:272/format:webp/0*xm54V48-ALw2E6oR.jpg"/></div></figure><p id="278d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">那还不错。现在，我建议您尝试一些值，并让我知道您获得了多少精度？</p><p id="676f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们开始吧。恭喜你！</p><p id="9f30" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">你已经成功地建立了你的第一个人工神经网络。现在是总结的时候了。</p><h1 id="527c" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">结论</h1><p id="bd38" class="pw-post-body-paragraph iq ir hi is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hb bi translated">我试图用简单易懂的方式从零开始讲解人工神经网络以及人工神经网络在Python中的实现。希望你能理解。</p><p id="328a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我建议你自己试试。如果你有任何疑问，欢迎在评论区问我。我愿意帮助你。</p><p id="3f87" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">快乐学习！</p></div></div>    
</body>
</html>