<html>
<head>
<title>Clustering on Mixed Data Types in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中混合数据类型的聚类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/clustering-on-mixed-data-types-in-python-7c22b3898086?source=collection_archive---------0-----------------------#2021-01-25">https://medium.com/analytics-vidhya/clustering-on-mixed-data-types-in-python-7c22b3898086?source=collection_archive---------0-----------------------#2021-01-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7a52dc60bea53d31a2a4b48d98b18f6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sldu4ZiL5fl4YGNWlqvjCg.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="c50c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在我第一次数据科学实习期间，我被分配了一个看似简单的任务，在数据集中寻找聚类。鉴于我对K-Means、DBSCAN和GMM等聚类算法的基本了解，我认为我可以轻松完成这项任务。然而，当我更仔细地研究数据集时，我意识到这些数据混合了<strong class="iw hj">分类</strong>和<strong class="iw hj">连续</strong>数据，而且我所知道的许多常见聚类方法并不容易工作。</p><blockquote class="js jt ju"><p id="b1c0" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">分类数据</em> </strong> <em class="hi">由多个离散的类别组成，这些类别之间通常没有任何明确的顺序或关系。这些数据可能看起来像是</em>“Android”<em class="hi">或</em>“iOS”。</p><p id="5a8b" class="iu iv jv iw b ix iy iz ja jb jc jd je jw jg jh ji jx jk jl jm jy jo jp jq jr hb bi translated"><strong class="iw hj"> <em class="hi">连续数据</em> </strong> <em class="hi">由可以取任意值的实数组成。该数据可能看起来像</em> "3.14159" <em class="hi">或</em> "43" <em class="hi">。</em></p></blockquote><p id="f953" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">许多数据集混合了分类数据和连续数据。然而，如何对混合数据类型的数据集进行聚类并不简单。那么，我们如何对既有分类特征又有连续特征的数据进行聚类呢？让我们看看使用Python处理这个问题的两种简单方法。</p><h1 id="90c3" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">资料组</h1><p id="1a3e" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">在本文中，我将对我创建的一个小型数据集进行聚类，该数据集混合了分类特征和连续特征。我的假数据代表可能用于了解电子商务网站/应用程序客户的客户数据。我们的假数据集将有4个特征:</p><ul class=""><li id="c0b3" class="lc ld hi iw b ix iy jb jc jf le jj lf jn lg jr lh li lj lk bi translated"><strong class="iw hj"> OS </strong> —我们假冒客户的操作系统(<em class="jv">分类</em>)</li><li id="6092" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><strong class="iw hj"> ISP </strong> —我们假冒客户的互联网服务提供商(<em class="jv">分类</em>)</li><li id="0040" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><strong class="iw hj">年龄</strong> —客户年龄(<em class="jv">连续</em>)</li><li id="9f55" class="lc ld hi iw b ix ll jb lm jf ln jj lo jn lp jr lh li lj lk bi translated"><strong class="iw hj">花费时间</strong> —我们的假冒用户在我们的网站上花费的时间(<em class="jv">连续</em>)</li></ul><p id="a23d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是用来生成我们的假数据的代码。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="16c6" class="lz ka hi lv b fi ma mb l mc md"><em class="jv">#create dataset</em><br/><strong class="lv hj">import</strong> <strong class="lv hj">numpy</strong> <strong class="lv hj">as</strong> <strong class="lv hj">np</strong> <br/><strong class="lv hj">import</strong> <strong class="lv hj">pandas</strong> <strong class="lv hj">as</strong> <strong class="lv hj">pd</strong><br/><br/>operating_systems = ["Android","iOS"]<br/>isp_names = ["Cox","HughesNet","Xfinity","AT&amp;T"]<br/><br/>data = []<br/><strong class="lv hj">for</strong> i <strong class="lv hj">in</strong> range(100):<br/>    row = []<br/>    row.append(np.random.choice(operating_systems)) #OS<br/>    row.append(np.random.choice(isp_names)) #ISP<br/>    row.append(np.random.poisson(lam=25)) #Age <br/>    row.append(np.random.uniform(low=0.5, high=1000)) #Time Spent<br/>    data.append(row)<br/><br/>customers = pd.DataFrame(data, columns = ['OS', 'ISP','Age','Time Spent'])</span></pre><p id="ccbb" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这是我们的假数据集的样子。现在让我们动手做一些集群工作吧！</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es me"><img src="../Images/842b782881b24c065a078fa5e1934cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rSrMgKdiH4knbDqZyR7ltw.png"/></div></div></figure><h1 id="962e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法1: K原型</h1><p id="268f" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">我们将尝试的第一种聚类方法叫做K原型。该算法本质上是K均值算法和K模式算法的结合。</p><p id="1ff7" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了刷新我们的记忆，<strong class="iw hj"> K-means </strong>使用欧几里德距离对数据进行聚类。同时，<strong class="iw hj"> K-modes </strong>基于数据点之间匹配类别的数量对分类数据进行聚类。这两者的混合:K-prototype算法，正是我们需要的来聚集我们的假客户！</p><p id="3b4c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">首先，让我们标准化数据中的连续特征，以确保一个特征不会被解释为比另一个更重要。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="3592" class="lz ka hi lv b fi ma mb l mc md">from sklearn import preprocessing</span><span id="5094" class="lz ka hi lv b fi mf mb l mc md">customers_norm = customers.copy()<br/>scaler = preprocessing.MinMaxScaler()<br/>customers_norm[['Age','Time Spent']] = scaler.fit_transform(customers_norm[['Age','Time Spent']])</span></pre><p id="dd43" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，让我们使用K-prototypes算法对我们的数据进行聚类。我的算法实现很简单，用3个集群和Cao初始化。在训练模型时，我们指定数据中的哪些列是分类的(列0和1)。关于实现和微调这个算法的更多信息可以在这里找到:<a class="ae mg" href="https://github.com/nicodv/kmodes" rel="noopener ugc nofollow" target="_blank">https://github.com/nicodv/kmodes</a>。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="c708" class="lz ka hi lv b fi ma mb l mc md">from kmodes.kprototypes import KPrototypes</span><span id="2b57" class="lz ka hi lv b fi mf mb l mc md">kproto = KPrototypes(n_clusters=3, init='Cao')</span><span id="240a" class="lz ka hi lv b fi mf mb l mc md">clusters = kproto.fit_predict(customers_norm, categorical=[0, 1])</span><span id="686f" class="lz ka hi lv b fi mf mb l mc md">#join data with labels <br/>labels = pd.DataFrame(clusters)<br/>labeledCustomers = pd.concat((customers,labels),axis=1)<br/>labeledCustomers = labeledCustomers.rename({0:'labels'},axis=1)</span></pre><p id="e9fc" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">最后，让我们制作一些群集图来看看我们的群集表现如何。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/97e0b63fcafcfdc7e1e89b155cdbeaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hnXMXoyUtUiX8z38FifSdw.png"/></div></div></figure><p id="2a71" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">成功了！看起来我们有三个相当不同的集群。我们的第一个集群似乎代表了在网站上花费大量时间的用户。我们的第二个集群主要是Android用户，他们花费的时间中等/低。最后，我们的第三个集群主要是iOS用户，他们也有中度/低度的时间消耗。</p><h1 id="e47d" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">方法2:具有一个热编码的K-Means</h1><p id="c887" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">使用K-原型算法的替代方法是使用K-means算法和一个热编码分类变量。<strong class="iw hj">一个热编码</strong>包括为数据集中的每个分类值创建一个新列。然后根据该分类值是否在数据中来分配1或0。让我们使用pandas的“get_dummies”函数对数据集中的分类值进行热编码。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="19a8" class="lz ka hi lv b fi ma mb l mc md">customers_norm = pd.get_dummies(customers_norm, columns=["OS","ISP"])</span></pre><p id="9f7a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在，我们的数据看起来像这样。酷！是时候进行更多的聚类了。</p><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/acdefa2e052e95419e45a77310b4e0d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXFGTCpY8LKUKKoemU4D9A.png"/></div></div></figure><p id="c93a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">让我们使用K-means的一个基本实现对这些数据进行聚类，并制作更多的群集图来看看这种方法是如何工作的。</p><pre class="lq lr ls lt fd lu lv lw lx aw ly bi"><span id="2d1b" class="lz ka hi lv b fi ma mb l mc md">from sklearn.cluster import KMeans</span><span id="8335" class="lz ka hi lv b fi mf mb l mc md">kmeans = KMeans(3)<br/>clusters = kmeans.fit_predict(customers_norm)<br/>labels = pd.DataFrame(clusters)<br/>labeledCustomers = pd.concat((customers,labels),axis=1)<br/>labeledCustomers = labeledCustomers.rename({0:'labels'},axis=1)</span></pre><figure class="lq lr ls lt fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/644acb2ca14d19ccb6cbe559f19b5e78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*70B2GIVjl8xZBjkLSPibLA.png"/></div></div></figure><p id="62be" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">好吧！有趣的是，我们可以看到这些集群与之前展示的K-prototypes集群有多么不同。乍一看，似乎我们数据中的分类特征对我们的聚类贡献更大，而我们的连续特征根本没有贡献多少。第一个集群包含不使用AT&amp;T的iOS用户。我们的第二个集群包含使用AT&amp;T的iOS用户。最后，我们的第三个集群包含所有Android用户。同时，年龄和花费的时间在所有集群中有很大的分布。</p><h1 id="036e" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="d6f5" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">在这篇文章中，我们研究了Python中混合分类/连续数据聚类的两种不同方法。首先，我们实现了<strong class="iw hj"> K-prototypes </strong>算法，这是一种专门设计的算法，使用K-means/K-modes的组合对混合数据进行聚类。作为替代，我们尝试使用带有一个热编码的K-means算法。</p><p id="058b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">使用我们的假数据集，这两种方法确定的聚类有显著差异。k原型似乎均衡地考虑了分类和连续特征。与此同时，K-means似乎更重视分类特征，这可能是不可取的。</p><p id="d224" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这些方法如何处理您的混合数据集？大家讨论一下！</p><p id="46ef" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">Github repo与所有代码/视觉效果在这里:<a class="ae mg" href="https://github.com/ryankemmer/ClusteringMixedData" rel="noopener ugc nofollow" target="_blank">https://github.com/ryankemmer/ClusteringMixedData</a></p><h1 id="1231" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><p id="387a" class="pw-post-body-paragraph iu iv hi iw b ix kx iz ja jb ky jd je jf kz jh ji jj la jl jm jn lb jp jq jr hb bi translated">[1] de Vos，Nelis J. kmodes分类聚类库。2015–2021年，【https://github.com/nicodv/kmodes T2】</p><p id="77a2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">[2]黄，z .:混合数值与分类值的大数据集聚类，第一届亚太知识发现与数据挖掘会议论文集，新加坡，第21–34页，1997 .</p></div></div>    
</body>
</html>