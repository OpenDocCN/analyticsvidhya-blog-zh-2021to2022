<html>
<head>
<title>Create Choropleth Maps by Using Plotly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Plotly创建Choropleth地图</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-choropleth-maps-by-using-plotly-31771803da7?source=collection_archive---------4-----------------------#2021-07-26">https://medium.com/analytics-vidhya/create-choropleth-maps-by-using-plotly-31771803da7?source=collection_archive---------4-----------------------#2021-07-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="067c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大家好。在这个故事中，我们将试图涵盖，我们如何使用Plotly创建choropleth地图。</p><p id="50f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们想创建choropleth，我们需要有与我们的目标区域相关的GeoJSON文件。我准备了我们将在这个故事中用到的笔记本。你可以从<a class="ae jd" href="https://github.com/mebaysan/VeriBilimi/blob/master/Python/3-)KesifciVeriAnaliziVeVeriGorsellestirme/Plotly-Dash-Examples/Plotly-Choropleth/Choropleth.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>进入。</p><h1 id="a878" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">关于我们的Jupyter笔记本</h1><p id="1562" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我们将使用<a class="ae jd" href="https://www.citypopulation.de/en/turkey/admin/" rel="noopener ugc nofollow" target="_blank">这个数据集</a>来创建我们的笔记本。该数据集包含某些年份土耳其总人口的估计值。你可以从<a class="ae jd" href="https://docs.google.com/spreadsheets/d/1iwe7WoUGxl9EkzJwvpw4Fzo_AUh8jjPuHCtJLkZgcLE/edit#gid=0" rel="noopener ugc nofollow" target="_blank">这里</a>访问数据集。我们将使用<a class="ae jd" href="https://gist.github.com/mebaysan/9be56dd1ca5659c0ff7ea5e2b5cf6479" rel="noopener ugc nofollow" target="_blank">这个GeoJSON文件</a>作为我们的目标区域。我们将创建的choropleth将展示估计的人口。</p><h1 id="23f2" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">我们开始吧</h1><h2 id="ca8c" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">准备和导入依赖项</h2><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="442c" class="kh jf hi la b fi le lf l lg lh">import pandas as pd<br/>import numpy as np<br/>import plotly.express as px<br/>import plotly.graph_objects as go<br/>from plotly.subplots import make_subplots<br/>import requests<br/>import json</span></pre><p id="8190" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与Plotly包不同，我们需要导入<strong class="ih hj">请求</strong>和<strong class="ih hj"> json </strong>包。我们将使用请求从GitHub gists获取GeoJSON数据，并使用JSON访问数据。</p><h2 id="4ec6" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">导入数据集</h2><p id="34ad" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">从CSV文件导入包含估计人口的数据集。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="a659" class="kh jf hi la b fi le lf l lg lh">df = pd.read_csv('Turkey Districts - Population Estimate - Sayfa1.csv')</span></pre><p id="f7b2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了从GitHub gist访问数据，我们将使用请求，并将GET请求发送到包含GeoJSON文件的URL。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="aad8" class="kh jf hi la b fi le lf l lg lh">response = requests.get('<a class="ae jd" href="https://gist.githubusercontent.com/mebaysan/9be56dd1ca5659c0ff7ea5e2b5cf6479/raw/6d7a77d8a2892bd59f401eb87bd82d7f48642a58/turkey-geojson.json'" rel="noopener ugc nofollow" target="_blank">https://gist.githubusercontent.com/mebaysan/9be56dd1ca5659c0ff7ea5e2b5cf6479/raw/6d7a77d8a2892bd59f401eb87bd82d7f48642a58/turkey-geojson.json'</a>)</span></pre><p id="9477" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所知，我们的响应存储在响应对象中。现在，我们需要从响应对象中提取json数据，并将其作为GeoJSON进行访问。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="5611" class="kh jf hi la b fi le lf l lg lh">geojson = response.json()</span></pre><p id="e234" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你打印geojson变量，我们在其中存储数据，你可以看到json数据。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/b9c7426aa0aac5982a0ec681cb3067c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Snv3O8bvaPUCpJJ0rW6cwQ.png"/></div></div></figure><h2 id="d245" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">检查数据集并准备可视化</h2><p id="0f82" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">打印数据类型，看看它们是什么样子的。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/e7d4d2ae0ca5b50e207a5ea9e98fb1de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9cQBw5yeqsFMsItlnjZoPQ.png"/></div></div></figure><p id="8634" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你看，估计列是对象类型。但是它们存储的是数字数据。我们需要改变他们的数据类型。首先，我将更改它们的列名，以便于访问。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c698" class="kh jf hi la b fi le lf l lg lh">df.rename(columns={'Population\nEstimate\n2009': 'Tahmin-2009',<br/>                   'Population\nEstimate\n2013': 'Tahmin-2013',<br/>                   'Population\nEstimate\n2019': 'Tahmin-2019'<br/>                   }, inplace=True)</span></pre><p id="ad2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将使用<strong class="ih hj"> df.head(2) </strong>查看前两行</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/9aa97220e449c442718ebbbc8fad38e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lDOnmE2xgKiM7XZ1HZ5rfA.png"/></div></div></figure><p id="d2dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在看起来好多了。但是仍然有一个问题。他们在Excel文件中用“，”分隔浮点值，但我们使用“.”分隔在Python中。我们需要解决那件事。我将通过使用lambda函数对列使用apply函数。我将用'，'分割所有的值，然后将我为每一行分隔的所有部分连接成一个字符串。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c66c" class="kh jf hi la b fi le lf l lg lh">df['Tahmin-2009'] = df['Tahmin-2009'].apply(lambda x: ''.join(x.split(',')))<br/>df['Tahmin-2013'] = df['Tahmin-2013'].apply(lambda x: ''.join(x.split(',')))<br/>df['Tahmin-2019'] = df['Tahmin-2019'].apply(lambda x: ''.join(x.split(',')))</span></pre><p id="4916" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您尝试将列转换为数字数据，您将会看到错误。因为他们写的是'…'而不是空值。我用numpy.nan替换'…'值。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="1310" class="kh jf hi la b fi le lf l lg lh">df.replace('...', np.nan, inplace=True)</span></pre><p id="40d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我可以将估计的列转换为数字数据。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="03db" class="kh jf hi la b fi le lf l lg lh">df['Tahmin-2009'] = pd.to_numeric(df['Tahmin-2009'])<br/>df['Tahmin-2013'] = pd.to_numeric(df['Tahmin-2013'])<br/>df['Tahmin-2019'] = pd.to_numeric(df['Tahmin-2019'])</span></pre><p id="b9c7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我要检查数据类型。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/eb4d967eeef8f7ef612e0fc13912c032.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajL4KB13h2oJNrSL9sWuuQ.png"/></div></div></figure><p id="df09" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">看啊。这似乎是我们想要的。该数据集包含土耳其的城市和地区。但我只想选择城市。因此，我将使用状态列来过滤数据集。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="c11a" class="kh jf hi la b fi le lf l lg lh">df = df[(df['Status'] == 'Metropolitan Province') | (df['Status'] == 'Province')]</span></pre><h2 id="d0b5" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">关于我们GeoJSON数据的一些信息</h2><p id="26dc" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在本节中，我们将使用我们在故事开始时创建的geojson变量。</p><ul class=""><li id="df8d" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">geojson['features'] =我们可以访问存储城市坐标的数组</li><li id="4a8c" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">geojson['features'][0] =我们可以访问存储城市坐标的数组的第一项</li><li id="e004" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">geojson['features'][0]['id'] =我们可以访问第一个城市的geojson id</li><li id="29bb" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">geojson[' features '][0][' properties ']=我们可以访问第一个城市的geo JSON属性</li><li id="5666" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">geojson[' features '][0][' properties '][' name ']=我们可以在geo JSON属性中访问第一个城市的名称属性</li></ul><p id="3463" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认情况下，Plotly Choropleth会查看GeoJSON的<strong class="ih hj">特征(geojson['feature']) </strong>对象的id。如果我们愿意，我们可以改变这一点，我们可以说“您必须查看geo JSON[' feature '][' properties ']”。</p><p id="94b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们想象一下。我们不知道。我们将创建一个变量作为geoDict，用于从geojson绑定城市名称和城市id。该字典将包含城市名作为键，城市id作为值。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="f8f0" class="kh jf hi la b fi le lf l lg lh">geoDict = {}<br/>for i in geojson['features']:<br/>    geoDict[i['properties']['name']] = i['id']</span></pre><h2 id="c9a2" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">将数据集与GeoJSON IDs绑定</h2><p id="eeb0" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">我需要改变一些价值观的价值，因为我们想要的。有拼写问题。因为这些值是我们在geojson中使用replace函数更改的。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="9a6f" class="kh jf hi la b fi le lf l lg lh">df.loc[df['Name'] == 'Afyonkarahisar'] = df.loc[df['Name'] == 'Afyonkarahisar'].replace('Afyonkarahisar', 'Afyon')</span><span id="0072" class="kh jf hi la b fi me lf l lg lh">df.loc[df['Name'] == 'Elâzığ'] = df.loc[df['Name'] == 'Elâzığ'].replace('Elâzığ', 'Elazığ')</span><span id="ad57" class="kh jf hi la b fi me lf l lg lh">df.loc[df['Name'] == 'Hakkâri'] = df.loc[df['Name'] == 'Hakkâri'].replace('Hakkâri', 'Hakkari')</span></pre><p id="ab5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我创建了一个列，并将其默认值设置为“Yok”。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="7742" class="kh jf hi la b fi le lf l lg lh">df.loc[:, 'GeoID'] = 'Yok'</span></pre><p id="78ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我使用dataframe的“名称”列和geoDict的键将geojson ids与dataframe绑定在一起。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="80c1" class="kh jf hi la b fi le lf l lg lh">df['GeoID'] = df['Name'].apply(lambda x: geoDict[x])</span></pre><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es li"><img src="../Images/a9e56261027e821473a36098dcbfdbf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3E-GRhm8lNcnVTvTypzkSw.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">我们可以在数据框中看到大地水准面</figcaption></figure><p id="e67f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">哼。我们对数据进行了预处理，以准备我们想要的格式。现在我们可以创造合唱团。我们开始吧。</p><h1 id="9319" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Plotly Express的Choropleths</h1><h2 id="a531" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">Choropleth地图框</h2><p id="2dc5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">用<a class="ae jd" href="https://www.mapbox.com/" rel="noopener ugc nofollow" target="_blank">地图框</a>绘制创建的Choropleth地图框。通过使用从MapBox创建的MapBox令牌，您可以使用自己定制的地图。</p><ul class=""><li id="f403" class="lq lr hi ih b ii ij im in iq ls iu lt iy lu jc lv lw lx ly bi translated">df =哪个数据帧变量</li><li id="03fd" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">geojson =哪个geojson变量</li><li id="79a9" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">locations = plot ly中用于绑定geojson和dataframe的列</li><li id="1f8f" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">颜色=哪一列将设置颜色</li><li id="8496" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">range_color =为设置颜色设置最小值和最大值</li><li id="37bb" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">中心=地图开始时将使用哪个坐标</li><li id="e8af" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">标签=更改您在绘图中使用的标签</li><li id="6e92" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">mapbox_style = mapbox地图样式</li><li id="5329" class="lq lr hi ih b ii lz im ma iq mb iu mc iy md jc lv lw lx ly bi translated">custom_data =您可以发送自定义数据，以便在悬停等情况下使用。行动</li></ul><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="e8ec" class="kh jf hi la b fi le lf l lg lh">fig = px.choropleth_mapbox(<br/>df,  <br/>geojson=geojson,<br/>locations='GeoID',<br/>color='Tahmin-2019',                           color_continuous_scale="dense", <br/>range_color=(df['Tahmin-2019'].min(),df['Tahmin-2019'].max()),<br/>center={'lat': 38.7200, 'lon': 34.0000},<br/>labels={'Tahmin-2019': '2019 Nüfus Tahmini'},<br/>mapbox_style="carto-positron",<br/>zoom=4.8,<br/>opacity=0.5,<br/>custom_data=[df['Name'],<br/>df['Tahmin-2019'], df['Status']]<br/>)</span><span id="dc97" class="kh jf hi la b fi me lf l lg lh"># Some make-up for plot<br/>fig.update_layout(<br/>title='Türkiye Nüfus Tahminleri 2019',<br/>title_x=0.5<br/>)</span><span id="98b0" class="kh jf hi la b fi me lf l lg lh"># I created my own hover template for on hover event<br/>hovertemp = '&lt;i style="color:red;"&gt;Şehir Adı:&lt;/i&gt; %{customdata[0]}&lt;br&gt;'<br/>hovertemp += '&lt;i&gt;Şehir Statüsü:&lt;/i&gt; %{customdata[2]}&lt;br&gt;'<br/>hovertemp += '&lt;i&gt;Tahmini Nüfus:&lt;/i&gt; %{customdata[1]:,f}&lt;br&gt;'</span><span id="5f88" class="kh jf hi la b fi me lf l lg lh"># I set my own hover template<br/>fig.update_traces(hovertemplate=hovertemp) </span><span id="7a2d" class="kh jf hi la b fi me lf l lg lh">fig.show()</span></pre><p id="9b7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您执行代码，您可以看到输出。</p><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/2ee90fba9ed22bce88dd72ec06588bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QlqU1iKzwW-JTxWuAezufQ.png"/></div></div></figure><h2 id="c86d" class="kh jf hi bd jg ki kj kk jk kl km kn jo iq ko kp js iu kq kr jw iy ks kt ka ku bi translated">Choropleth</h2><p id="090b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">与之前使用choropleth _ mapbox函数创建的地图不同，我们使用了featureidkey参数。它将使用geojson的<strong class="ih hj">属性</strong>属性绑定geojson和dataframe。</p><p id="ca74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">颜色_连续_刻度</strong>改变调色板。</p><p id="5bce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> update_geos </strong>功能可以设置地图设置。<strong class="ih hj"> fitbounds </strong>可以绘制地图边框<strong class="ih hj">可见</strong>参数可以设置可见性。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="8a87" class="kh jf hi la b fi le lf l lg lh">fig = px.choropleth(<br/>df,<br/>geojson=geojson,<br/>locations='Name',<br/>featureidkey='properties.name',<br/>color='Tahmin-2019',<br/>color_continuous_scale="Viridis",<br/>range_color=(df['Tahmin-2019'].min(),<br/>df['Tahmin-2019'].max()),<br/>center={'lat': 38.7200, 'lon': 34.0000},<br/>labels={'Tahmin-2019': '2019 Nüfus Tahmini'},<br/>custom_data=[df['Name'],<br/>df['Tahmin-2019'], <br/>df['Status']]<br/>)</span><span id="4f27" class="kh jf hi la b fi me lf l lg lh">fig.update_geos(<br/>fitbounds="locations",<br/>visible=False<br/>)</span><span id="7af2" class="kh jf hi la b fi me lf l lg lh"><br/><br/>hovertemp = '&lt;i&gt;Şehir Adı:&lt;/i&gt; %{customdata[0]}&lt;br&gt;'<br/>hovertemp += '&lt;i&gt;Şehir Statüsü:&lt;/i&gt; %{customdata[2]}&lt;br&gt;'<br/>hovertemp += '&lt;i&gt;Tahmini Nüfus:&lt;/i&gt; %{customdata[1]:,f}&lt;br&gt;'</span><span id="f407" class="kh jf hi la b fi me lf l lg lh"><br/>fig.update_traces(hovertemplate=hovertemp)</span><span id="bcb4" class="kh jf hi la b fi me lf l lg lh">fig.show()</span></pre><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/1d46b028fbf67777cc2fbd3e219b9cde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DGzhUrBPd0YTUDV8zqjJZQ.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">我们用choropleth制作的地图</figcaption></figure><h1 id="e7be" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">使用Plotly图形对象的Choropleths</h1><p id="b836" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">在这一节中我不想作不必要的解释。因为手法差不多。如果你不知道如何创造支线剧情，你可以阅读我的故事。</p><pre class="kv kw kx ky fd kz la lb lc aw ld bi"><span id="19de" class="kh jf hi la b fi le lf l lg lh">fig = make_subplots(<br/>rows=1, cols=2,<br/>specs=[<br/>[{"type": "choropleth"},{"type": "choropleth"}],<br/>]<br/>)</span><span id="b93c" class="kh jf hi la b fi me lf l lg lh">fig.add_trace(trace=go.Choropleth(<br/>    featureidkey='properties.name',<br/>    geojson=geojson,<br/>    locations=df['Name'],<br/>    z=df['Tahmin-2009'],<br/>    colorscale='YlGn',<br/>    colorbar_title="Tahmin",<br/>    zmin=df['Tahmin-2009'].min(),<br/>    zmax=df['Tahmin-2009'].max(),<br/>    name='2009 Nüfus Tahmini',<br/>    hoverinfo='location+z',<br/>    showlegend=False,<br/>    showscale=False,<br/>), row=1, col=1)</span><span id="8a29" class="kh jf hi la b fi me lf l lg lh">fig.add_trace(trace=go.Choropleth(<br/>    featureidkey='properties.name',<br/>    geojson=geojson,<br/>    locations=df['Name'],<br/>    z=df['Tahmin-2019'],<br/>    colorscale='YlGn',<br/>    colorbar_title="Tahmin",<br/>    zmin=df['Tahmin-2019'].min(),<br/>    zmax=df['Tahmin-2019'].max(),<br/>    name='2019 Nüfus Tahmini',<br/>    hoverinfo='location+z',<br/>), row=1, col=2)</span><span id="3a7a" class="kh jf hi la b fi me lf l lg lh">fig.update_geos(fitbounds="locations",<br/>                visible=False,<br/>                )</span><span id="3858" class="kh jf hi la b fi me lf l lg lh">hovertemp = '&lt;i&gt;Şehir Adı:&lt;/i&gt; %{location} &lt;br&gt;'<br/>hovertemp += '&lt;i&gt;Nüfus Tahmini:&lt;/i&gt; %{z:,}'</span><span id="f785" class="kh jf hi la b fi me lf l lg lh">fig.update_traces(hovertemplate=hovertemp)</span><span id="7a7f" class="kh jf hi la b fi me lf l lg lh">fig.update_layout(<br/>    title='2009 ve 2019 Arasında Karşılaştırmalı Nüfus Tahminleri', title_x=0.5)</span><span id="6403" class="kh jf hi la b fi me lf l lg lh">fig.show()</span></pre><figure class="kv kw kx ky fd lj er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es mj"><img src="../Images/c050f3cfb5fe7222b9b596ca29f34827.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qFIbCN3RKZ6N-D4t2F7iBw.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">我们可以看到不同年份的不同地图</figcaption></figure><p id="0cc4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我希望这个故事能帮助你理解“我们如何用Plotly创建choropleth地图”。</p><p id="1bab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">亲切的问候。</p></div></div>    
</body>
</html>