<html>
<head>
<title>2- Econometric &amp; Statistical Models in Time Series</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2-时间序列中的计量经济学和统计模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/2-econometric-statistical-models-in-time-series-7b69ae3ab1d8?source=collection_archive---------2-----------------------#2021-05-03">https://medium.com/analytics-vidhya/2-econometric-statistical-models-in-time-series-7b69ae3ab1d8?source=collection_archive---------2-----------------------#2021-05-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/13390f4019a483c14a9ea5ef2058f1ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PpNXEyHvQBydzdOd"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">科技日报在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的<a class="ae it" href="https://unsplash.com/@techdailyca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><blockquote class="iu iv iw"><p id="5b73" class="ix iy iz ja b jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv ha bi translated"><strong class="ja hi">更新</strong>:这篇文章是我探索时间序列的系列文章的一部分。查看完整系列:<a class="ae it" rel="noopener" href="/analytics-vidhya/1-introduction-to-time-series-5ae663c468f4">第1部分</a>，第2部分，<a class="ae it" href="https://ertuncogulcan.medium.com/3-time-series-forecasting-using-lstm-e14b93f4ec7c" rel="noopener">第3部分</a>。</p></blockquote></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h2 id="753a" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">介绍</h2><p id="cd7d" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">我有佛罗里达自1743年以来的月平均气温，我在上一篇文章中讨论过。在这篇文章中，首先我将解释一些基本的模型和它们的定义，并向你展示在这个数据集上使用ARIMA、萨里玛等模型进行时间序列的基本操作。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h1 id="47cd" class="lg ke hh bd kf lh li lj kj lk ll lm kn ln lo lp kr lq lr ls kv lt lu lv kz lw bi translated">别跟我解释，出示代码</h1><p id="6ad3" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">你可以在这里访问GitHub repo。</p></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h2 id="e644" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">AR(p):自回归</h2><p id="68cc" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">通过线性组合先前时间步长的观测值进行估计。<br/>适用于没有趋势性或季节性的单变量时间序列。<br/> p:延时。如果p = 1，意味着模型是用前面的时间步建立的。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es lx"><img src="../Images/dab23bbc18f4a26686ad162b3a2824ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/0*qmzp8qhx5JFWA83O"/></div></figure><h2 id="f770" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">马(问):移动平均</h2><p id="f922" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">估计是用在先前时间步骤中获得的误差的线性组合来完成的。<br/>适用于没有趋势性或季节性的单变量时间序列。<br/> q:是延时数。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/82215fa3be79eabe2761595e092be7aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/0*gcMi4Vjf1uVgTMXo"/></div></figure><h2 id="aa83" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">ARMA(p，q) = AR(p) +MA(q)自回归移动平均</h2><p id="37ee" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">结合AR和MA方法。<br/>使用历史值和过去误差的线性组合进行估计。<br/>适用于没有趋势性或季节性的单变量时间序列。<br/> p和q是延时数。p为AR模型q为MA模型。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es md"><img src="../Images/7508408363932982818a9cee9aea8094.png" data-original-src="https://miro.medium.com/v2/resize:fit:614/0*jbirf5dGUMl_41_s"/></div></figure><h2 id="479b" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">ARIMA(p，d，q):(自回归综合移动平均线)</h2><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/48cbace127f02c8a1c92cac9b54aa1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mD45YFvVD4yyQres.png"/></div></div></figure><p id="51f2" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">ARIMA模型用于查看时间序列数据并对未来进行预测。常用的用法是Arima (p，d，q)。p用于自回归(ar (p))部分，d表示数据序列有多少次不同。(之前的数据减去每个数据得到的新序列)最后，q用于移动平均(ma (q))部分。在这种情况下，Arima (1，0，0)和ar (1)是相同的。<br/> arima (0，0，1)和ma (1)相同。</p><p id="32c7" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi">如果要一步步总结:</strong></p><ul class=""><li id="ac0f" class="mf mg hh ja b jb jc jf jg ko mh ks mi kw mj jv mk ml mm mn bi translated">通过观察值和不同于先前时间步长的误差的线性组合进行估计。</li><li id="1392" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">它适用于单变量趋势数据，但不适用于季节性数据。</li><li id="a088" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">p:实际值延迟数(自回归程度)<br/> -如果p = 2，则在yt-1和yt-2模型中。</li><li id="2441" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">d:不同操作的数量(差异程度，I)</li><li id="a5fd" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">q:误差延迟数(移动平均度)</li><li id="4e0a" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">被关注是什么意思？<br/>——比如就是把今天和前一天的值相减。</li><li id="1144" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">发现过程有什么作用，为什么我们会被注意到？<br/> -稳定级数。</li><li id="f849" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">稳定系列是什么意思？<br/> -消除序列的统计属性随时间变化的情况。</li><li id="c2b8" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">可以理解，在这里取差的过程创造了在现在流行的系列中进行预测的机会。</li></ul><h2 id="382b" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">SARIMA (p，D，q) (P，D，Q)m:(季节性自回归综合移动平均)</h2><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/e48af5d3502039ac7fb0de352eb4c1e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MovsGGs_fCJ1alCy.png"/></div></div></figure><p id="f7d8" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">这是一种特别用于时间序列分析的方法，用于解释和预测数据。除了Arima模型之外，在季节性数据中使用的参数可能比净化模型多3个。这些参数是自相关、差异等。季节性数据。是价值观。</p><p id="89e6" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi">如果要一步步总结:</strong></p><ul class=""><li id="890b" class="mf mg hh ja b jb jc jf jg ko mh ks mi kw mj jv mk ml mm mn bi translated">ARIMA +是季节性</li><li id="61ed" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">它可用于包含趋势和季节性的单变量序列。</li><li id="d414" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">p，d，q是来自ARIMA的参数。趋势元素*。ARIMA能够模拟这一趋势。</li><li id="48ba" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">P:实际值延迟数(自回归程度)<br/> -如果P = 2，则在yt-1和yt-2模型中。</li><li id="e933" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">d:不同交易的数量(差异程度)</li><li id="d1ca" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">q:误差延迟数(移动平均度)</li><li id="2c34" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">如果q = 2，则在et-1和et-2模型中。</li><li id="9dba" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">p，D，Q季节滞后数。季节元素。</li><li id="00f1" class="mf mg hh ja b jb mo jf mp ko mq ks mr kw ms jv mk ml mm mn bi translated">m单个季节周期的时间步长数。它表达了季节性的结构。</li></ul></div><div class="ab cl jw jx go jy" role="separator"><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb kc"/><span class="jz bw bk ka kb"/></div><div class="ha hb hc hd he"><h2 id="9afe" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">0.数据准备</h2><p id="e523" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">首先，我们将我们的数据划分为Arima模型的训练/测试。与前一篇文章一样，在将1995年之前发现的数据确定为训练集时。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="44c3" class="kd ke hh mv b fi mz na l nb nc">train = florida[:"1994-12-01"]<br/>len(train)<br/>test = florida["1995-01-01":]<br/>len(test)</span></pre><h2 id="ee62" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.Arima模型</h2><p id="d99b" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">作为第一步，我们建立一个基本的Arima模型，并查看我们的测试误差，而不应用任何调整操作。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="b1a3" class="kd ke hh mv b fi mz na l nb nc">arima_model = ARIMA(train, order = (1,0,1)).fit(disp=0)<br/>arima_model.summary()<br/><br/>y_pred= arima_model.forecast(225)[0]<br/>mean_absolute_error(test, y_pred)<br/># 4.39981</span></pre><p id="aec6" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">在视觉化方面，我想象1985年后的场景，以获得舒适清晰的视觉效果。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="180a" class="kd ke hh mv b fi mz na l nb nc">train["1985":].plot(legend=True, label = 'TRAIN')<br/>test.plot(legend=True, label = 'TEST', figsize = (6,4))<br/>pd.Series(y_pred, index=test.index).plot(legend=True, label = 'Prediction')<br/>plt.title("Train, Test and Predicted Test")<br/>plt.show()</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nd"><img src="../Images/60887acc77b370db1deb12a2739160fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*RH6brM2_nPCFPGPE"/></div></figure><p id="2103" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">如你所见，我们的猜测似乎不太好。所以我们来做一个调音过程。</p><p id="bfb8" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">有两种常用的技术来优化这些统计模型。首先，根据ACF和PACF图确定模型等级。第二，基于AIC统计量确定模型等级。</p><h2 id="02b5" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.1根据ACF和PACF图确定模型等级</h2><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="8b50" class="kd ke hh mv b fi mz na l nb nc">def acf_pacf(y, lags=30):</span><span id="88ca" class="kd ke hh mv b fi ne na l nb nc">plt.figure(figsize=(12, 7))</span><span id="f473" class="kd ke hh mv b fi ne na l nb nc">layout = (2, 2)</span><span id="3892" class="kd ke hh mv b fi ne na l nb nc">ts_ax = plt.subplot2grid(layout, (0, 0), colspan=2)</span><span id="55cd" class="kd ke hh mv b fi ne na l nb nc">acf_ax = plt.subplot2grid(layout, (1, 0))</span><span id="1daa" class="kd ke hh mv b fi ne na l nb nc">pacf_ax = plt.subplot2grid(layout, (1, 1))</span><span id="5325" class="kd ke hh mv b fi ne na l nb nc">y.plot(ax=ts_ax)</span><span id="7988" class="kd ke hh mv b fi ne na l nb nc"># Durağanlık testi (HO: Series is not Stationary. H1: Series is Stationary.)</span><span id="4dd2" class="kd ke hh mv b fi ne na l nb nc">p_value = sm.tsa.stattools.adfuller(y)[1]</span><span id="0087" class="kd ke hh mv b fi ne na l nb nc">ts_ax.set_title(‘Time Series Analysis Plots\n Dickey-Fuller: p={0:.5f}’.format(p_value))</span><span id="205a" class="kd ke hh mv b fi ne na l nb nc">smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</span><span id="ffec" class="kd ke hh mv b fi ne na l nb nc">smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</span><span id="981f" class="kd ke hh mv b fi ne na l nb nc">plt.tight_layout()</span><span id="0002" class="kd ke hh mv b fi ne na l nb nc">plt.show()</span><span id="3063" class="kd ke hh mv b fi ne na l nb nc">acf_pacf(florida)</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/fd08be3b82eafd7afb9a307c36675a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MfeYdp69l3ZO2Es2"/></div></div></figure><p id="0a24" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">这里我们试图给图表中的p和q值一个更好的值。</p><p id="c1c3" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">在这里，它是为了查看ACF图和时间序列中先前时段的值之间的相关性。在这里，我们看到滞后值为30的事务。</p><p id="d111" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">所以我们在看yt-1，yt-2，…延伸到yt-30。</p><p id="e06a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">在图中浅蓝色区域剩余的点上，自相关并不显著，我们有许多有意义的自相关，但很少有无意义的自相关。</p><p id="5b24" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">如果要简单总结一下:</p><p id="45e0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">-这意味着如果<strong class="ja hi"> ACF宽度</strong><strong class="ja hi">根据延迟减少</strong>，并且<strong class="ja hi"> PACF p </strong>是延迟<strong class="ja hi"> AR (p) </strong>后的<strong class="ja hi">截止</strong>图案。</p><p id="6969" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">-如果<strong class="ja hi"> ACF宽度q </strong>延迟后为<strong class="ja hi">切断</strong>，且<strong class="ja hi"> PACF宽度</strong><strong class="ja hi">根据延迟减少</strong>，则表示是<strong class="ja hi"> MA (q) </strong>图案。</p><p id="b582" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">-如果<strong class="ja hi"> ACF </strong>和<strong class="ja hi"> PACF的宽度根据滞后减少</strong>，则表示是<strong class="ja hi"> ARMA </strong>型号。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="5529" class="kd ke hh mv b fi mz na l nb nc">df_diff = florida.diff()</span><span id="f7b7" class="kd ke hh mv b fi ne na l nb nc">df_diff.dropna(inplace=True)</span><span id="a6b0" class="kd ke hh mv b fi ne na l nb nc">acf_pacf(df_diff)</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nf"><img src="../Images/7956fdda4d4b4209d56f67a5a5d30626.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-xgug8IF7fN2H9k2"/></div></div></figure><p id="23e5" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">我们很容易在自相关中看到季节性。从这种视觉技术中，我们看不到有助于确定分数的分数。</p><p id="5f03" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2根据AIC &amp; BIC统计</strong>确定模型等级</p><p id="86a0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">现在，我们正试图通过在我们确定的范围内尝试所有组合来找到最佳参数，以找到能给我们带来最佳结果的值。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="9991" class="kd ke hh mv b fi mz na l nb nc"># Generation of combinations of p and q<br/><br/>p = d = q = range(0, 4)<br/>pdq = list(itertools.product(p, d, q))<br/><br/>def arima_optimizer_aic(train, orders):<br/>    best_aic, best_params = float("inf"), None<br/><br/>    for order in orders:<br/>        try:<br/>            arma_model_result = ARIMA(train, order).fit(disp=0)<br/>            aic = arma_model_result.aic<br/>            if aic &lt; best_aic:<br/>                best_aic, best_params = aic, order<br/>            print('ARIMA%s AIC=%.2f' % (order, aic))<br/>        except:<br/>            continue<br/>    print('Best ARIMA%s AIC=%.2f' % (best_params, best_aic))<br/>    return best_params<br/><br/>best_params_aic = arima_optimizer_aic(train, pdq)</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es ng"><img src="../Images/882a23c399963deb170f7a8dfd739a80.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/0*gXPFeK9ZG_H1Hd9r"/></div></figure><p id="f7a0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">通过将我们发现的最佳值添加到我们的ARIMA模型中，我们创建了我们的调整模型。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="35b7" class="kd ke hh mv b fi mz na l nb nc">arima_model = ARIMA(train, best_params_aic).fit(disp=0)<br/>y_pred = arima_model.forecast(225)[0]<br/>mean_absolute_error(test, y_pred)<br/># 1.4470</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nd"><img src="../Images/87994a9dfd68f11ddcb649f36d0762db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*7kjxNml1sDH73Fjg"/></div></figure><p id="9669" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">当我们可视化我们调优的模型时，我们可以说，与之前的模型相比，我们有一个非常成功的模型结果。</p><h2 id="9839" class="kd ke hh bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.萨里玛模型</h2><p id="b071" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">首先，我们已经执行了这一步，因为我们需要在数据集中创建一个验证。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="eb45" class="kd ke hh mv b fi mz na l nb nc">from statsmodels.tsa.statespace.sarimax import SARIMAX<br/><br/>train = florida[:"1994-12-01"]<br/>len(train)<br/>test = florida["1995-01-01":]<br/>len(test)<br/>val = train["1991-01-01":]<br/>len(val)</span></pre><p id="1078" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.1基本型号</strong></p><p id="995a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">我们将使用名为SARIMAX的函数来实现这一点。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="eebf" class="kd ke hh mv b fi mz na l nb nc">model = SARIMAX(train, order=(1,0,1), seasonal_order=(0,0,0,12))<br/>sarima_model = model.fit(disp=0)</span></pre><p id="5e34" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.2验证错误</strong></p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="7732" class="kd ke hh mv b fi mz na l nb nc">pred = sarima_model.get_prediction(start = pd.to_datetime('1991-01-01'),dynamic=False)<br/>pred_ci = pred.conf_int()<br/><br/>y_pred = pred.predicted_mean<br/>mean_absolute_error(val, y_pred)<br/># 1.9192</span></pre><p id="a443" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.3验证预测可视化</strong></p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nh"><img src="../Images/6280662f31b68effcde3840e6ff1c1d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*CZctTTen76Cw8AWx"/></div></figure><p id="3426" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">与基本模型相比，我们的验证错误看起来相当不错。</p><p id="b46f" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.4测试错误</strong></p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="4e4e" class="kd ke hh mv b fi mz na l nb nc">y_pred_test = sarima_model.get_forecast(steps=225)<br/>pred_ci = y_pred_test.conf_int()<br/>y_pred = y_pred_test.predicted_mean<br/>mean_absolute_error(test, y_pred)<br/># 17.0051</span></pre><p id="76fe" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">我们看到我们的真实误差现在相对较高。如果我们认为这是实际分数，那么我们在上一步中看到的低验证错误可能表示过度拟合。</p><p id="2c86" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.5预测可视化</strong></p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nh"><img src="../Images/ba6226f5f7bcef2288822cbbbd703617.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Wl2hQ0TcodHH1Mtn"/></div></figure><p id="6367" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">我们可以看到图表有多糟糕。</p><p id="b0f0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.6模式调谐</strong></p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="6c5d" class="kd ke hh mv b fi mz na l nb nc">p = d = q = range(0, 2)<br/>pdq = list(itertools.product(p, d, q))<br/>seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]<br/><br/>def sarima_optimizer_aic(train, pdq, seasonal_pdq):<br/>    best_aic, best_order, best_seasonal_order = float("inf"), float("inf"), None<br/>    for param in pdq:<br/>        for param_seasonal in seasonal_pdq:<br/>            try:<br/>                sarimax_model = SARIMAX(train, order=param, seasonal_order=param_seasonal)<br/>                results = sarimax_model.fit(disp=0)<br/>                aic = results.aic<br/>                if aic &lt; best_aic:<br/>                    best_aic, best_order, best_seasonal_order = aic, param, param_seasonal<br/>                print('SARIMA{}x{}12 - AIC:{}'.format(param, param_seasonal, aic))<br/>            except:<br/>                continue<br/>    print('SARIMA{}x{}12 - AIC:{}'.format(best_order, best_seasonal_order, best_aic))<br/>    return best_order, best_seasonal_order<br/><br/>best_order, best_seasonal_order = sarima_optimizer_aic(train, pdq, seasonal_pdq)</span></pre><p id="cb6a" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">在这里，由于变量过多，我们试图保持较小的范围(2)。您可以增加范围。后来，我们写了12，因为我们知道季节周期。</p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es ni"><img src="../Images/a7354c1313c17b1d4a8b9219b23dec2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/0*ks5I3NR6EM6tgJdO"/></div></figure><p id="7feb" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.7最终模型及其测试误差</strong></p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="9abb" class="kd ke hh mv b fi mz na l nb nc">model = SARIMAX(train, order=best_order, seasonal_order=best_seasonal_order)<br/>sarima_final_model = model.fit(disp=0)<br/>###############################<br/>### Final Model Test Error ###<br/>###############################<br/><br/>y_pred_test = sarima_final_model.get_forecast(steps=225)<br/>pred_ci = y_pred_test.conf_int()<br/>y_pred = y_pred_test.predicted_mean<br/>mean_absolute_error(test, y_pred)<br/># 1.013578872841977</span></pre><p id="525c" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.8最终模型的可视化</strong></p><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nh"><img src="../Images/94bb4499446b1e8faa752dd7eb82787b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*I0lQXQ39bM83kJ-s"/></div></figure><p id="20f2" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated"><strong class="ja hi"> 2.9基于MAE的SARIMA优化器</strong></p><p id="8c84" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">我们根据AIC优化了模型，但我们也可以根据梅这样做。为此，我想在这里多开一节来展示一下。</p><pre class="ly lz ma mb fd mu mv mw mx aw my bi"><span id="83f9" class="kd ke hh mv b fi mz na l nb nc">def fit_model_sarima(train, val, pdq, seasonal_pdq):<br/>    sarima_model = SARIMAX(train, order=pdq, seasonal_order=seasonal_pdq).fit(disp=0)<br/>    y_pred_val = sarima_model.get_forecast(steps=48)<br/>    y_pred = y_pred_val.predicted_mean<br/>    return mean_absolute_error(val, y_pred)<br/><br/>fit_model_sarima(train, val, (0, 1, 0), (0, 0, 0, 12))<br/><br/>p = d = q = range(0, 2)<br/>pdq = list(itertools.product(p, d, q))<br/>seasonal_pdq = [(x[0], x[1], x[2], 12) for x in list(itertools.product(p, d, q))]<br/><br/><br/>def sarima_optimizer_mae(train, val, pdq, seasonal_pdq):<br/>    best_mae, best_order, best_seasonal_order = float("inf"), float("inf"), None<br/>    for param in pdq:<br/>        for param_seasonal in seasonal_pdq:<br/>            try:<br/>                mae = fit_model_sarima(train, val, param, param_seasonal)<br/>                if mae &lt; best_mae:<br/>                    best_mae, best_order, best_seasonal_order = mae, param, param_seasonal<br/>                print('SARIMA{}x{}12 - MAE:{}'.format(param, param_seasonal, mae))<br/>            except:<br/>                continue<br/>    print('SARIMA{}x{}12 - MAE:{}'.format(best_order, best_seasonal_order, best_mae))<br/>    return best_order, best_seasonal_order<br/><br/><br/>best_order, best_seasonal_order = sarima_optimizer_mae(train, val, pdq, seasonal_pdq)<br/><br/>model = SARIMAX(train, order=best_order, seasonal_order=best_seasonal_order)<br/>sarima_final_model = model.fit(disp=0)<br/><br/>y_pred_test = sarima_final_model.get_forecast(steps=225)<br/>pred_ci = y_pred_test.conf_int()<br/>y_pred = y_pred_test.predicted_mean<br/>mean_absolute_error(test, y_pred)<br/># 0.92</span></pre><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nj"><img src="../Images/e753db6ef36bba72e4d8905c5657e6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/0*JAOycWm0HVPlrKh9"/></div></figure><figure class="ly lz ma mb fd ii er es paragraph-image"><div class="er es nh"><img src="../Images/62e5dd64c6dda2656d55f0d0a6913a89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*Nb0w7HeShUG3ABTQ"/></div></figure><h1 id="cdc1" class="lg ke hh bd kf lh nk lj kj lk nl lm kn ln nm lp kr lq nn ls kv lt no lv kz lw bi translated">参考</h1><p id="2ce7" class="pw-post-body-paragraph ix iy hh ja b jb lb jd je jf lc jh ji ko ld jl jm ks le jp jq kw lf jt ju jv ha bi translated">[1]<a class="ae it" href="https://www.veribilimiokulu.com/bootcamp-programlari/veri-bilimci-yetistirme-programi/" rel="noopener ugc nofollow" target="_blank">https://www.veribilimiokulu.com</a></p><p id="b630" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">[2]<a class="ae it" href="https://www.analyticsvidhya.com/blog/2020/10/how-to-create-an-arima-model-for-time-series-forecasting-in-python/" rel="noopener ugc nofollow" target="_blank">https://www . analyticsvidhya . com/blog/2020/10/how-to-create-an-ARIMA-model-for-time-series-forecasting-in-python/</a></p><p id="10f0" class="pw-post-body-paragraph ix iy hh ja b jb jc jd je jf jg jh ji ko jk jl jm ks jo jp jq kw js jt ju jv ha bi translated">[3]https://www.statisticssolutions.com/time-series-analysis/<a class="ae it" href="https://www.statisticssolutions.com/time-series-analysis/" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>