<html>
<head>
<title>[Part 2] RESTful API’s using Flask: HTTP verbs, statelessness &amp; the REST paradigm.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">[第2部分]使用Flask的RESTful API:HTTP动词、无状态REST范式。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-2-restful-apis-using-flask-http-verbs-statelessness-the-rest-paradigm-853de8d7164e?source=collection_archive---------8-----------------------#2021-04-01">https://medium.com/analytics-vidhya/part-2-restful-apis-using-flask-http-verbs-statelessness-the-rest-paradigm-853de8d7164e?source=collection_archive---------8-----------------------#2021-04-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5ff9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们后退一步，重新回顾一下互联网是如何工作的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/624a565c8b230929f17540e51ade792d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*brOBO9sOPM5YJZjw"/></div></div></figure><p id="e39a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当你在浏览器中输入“www.facebook.com ”,它就会通过互联网到达服务器。服务器是运行在专用计算机上的程序，它可以响应浏览器的请求并向用户提供内容。这些请求和响应是使用超文本传输协议(HTTP)传输的，这实际上只是计算机通过互联网交换数据的一种标准化方式。</p><p id="705f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">HTTP定义了方法(也称为HTTP动词),浏览器和程序使用这些方法来发出请求，这些请求由服务器接收和执行。这些包括GET、POST、PUT、DELETE和其他。GET是最常用的动词。当您将浏览器指向一个URL时，它会向注册接收该URL请求的服务器发送一个GET请求。GET请求告诉服务器传递该URL的数据(包含文本图片和其他内容的网页)。当您去facebook.com时，您的浏览器向脸书服务器发送一个GET请求，该请求到达与基本URL相关联的端点。当请求被发送到该端点时，服务器被告知传递登录页面，这就是您所看到的。</p><p id="6b86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，API利用这些相同的HTTP动词接收来自用户的请求，并在响应中传递数据或修改它的数据存储。在上一篇文章中，我们在资源类中添加了一个get方法，让服务器知道如何处理用户向服务器上的端点发送的GET请求。我们同样可以使用我们的API向服务器添加数据或删除数据。我们只需要写出我们的端点，与这些端点相关联的资源，资源可以处理什么样的请求，以及它们最终将如何处理它们。</p><p id="4ecd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使一个API成为REST api的是它对某些原则和惯例的遵守，这些原则和惯例是REST范式的核心。REST认为API是一组可以交互的资源，可以检索或修改数据。我们在应用程序中看到了这一点，我们创建了一个资源对象，将它与端点相关联，并将资源添加到flask_restful中。部署应用程序时，对端点的调用将由服务器接收，服务器将把它提交给flask_restful，后者将获取指定端点的资源，并运行其中的任何代码来生成正确的响应。</p><p id="1a7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个关键的方面是REST API应该是无状态的(REST代表<strong class="ig hi">RE</strong>presentational<strong class="ig hi">S</strong>tate<strong class="ig hi">T</strong>transfer)。状态是CS的一个完整的研究领域，很难进入。本质上，REST上下文中的无状态意味着服务器对请求的响应不应该依赖于任何先前的请求。这归结起来就是将数据存储从处理和交付中分离出来，并让我们的API充当数据库的网关。</p><p id="90cb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们停止了前一篇文章，在本地服务器上运行一个有效的API。然而，这个API的记录是运行脚本中定义的一个简单的python列表，存储在短期内存(RAM)中。以这种方式在脚本中声明的变量只在脚本运行时存在，如果程序终止，变量就会丢失。此外，RAM内存是有限的，并不意味着要保存大量不经常使用的信息。</p><p id="a09e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但最重要的是，它违反了“无国籍”的条件。假设我的API中有一个端点返回一个位置中所有记录的列表，另一个端点允许我添加到这个列表中。如果我像在我的示例脚本中那样将所有这些都存储在内存中，那么所有记录的列表将取决于先前发送给它的POST请求。</p><p id="0e20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们必须将API使用的数据存储在磁盘的某个地方。存储数据以供检索的首选方法是在数据库中。每当用户向我们的API提交请求时，它要么从我们的数据库中检索数据，要么向我们的数据库中添加数据。SQL是标准的选择，尽管像Mongo-DB这样基于JSON的非SQL平台已经变得越来越流行。在本教程中，我们将建立一个SQLite数据库，并让我们的API使用它将请求的数据发送回用户。</p><p id="8de3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的数据存储和可能想要使用我们的数据和服务的最终用户之间添加API层有很多好处。首先，有这样一个数据库中介会更安全。它提供了一个干净、统一的界面，任何程序都可以轻松地与之交互。它是模块化的，因为我们可以在API中而不是在客户端应用程序中包含许多功能，所以我们可以在一个地方进行更改，而消费应用程序可以继续照常运行，因为它们可以从预期的API中获得输出。</p><p id="57b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以让我们建立一个SQLite数据库来使用我们的API。在您的根文件夹中，创建一个新的python文件(如果您愿意，可以将其命名为“db_setup.py”)。这是该文件的外观:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jo"><img src="../Images/8cd96cc1513f64d531847d3f8fa25519.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jn1XVvJy6fkO4AriNTAGaA.png"/></div></div></figure><p id="f74e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们走一遍。我们导入sqlite3，它内置于python中，所以我们不需要安装任何东西。使用SQLite的第一步包括设置我们的连接对象；这就是我们的Pyython脚本连接到数据库的方式。我们在这里指定数据库文件的路径和名称，如果我们输入一个不存在的文件名，sqlite3实际上会在那个位置创建一个同名的数据库文件。</p><p id="93b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们从连接对象中捕获光标。这个对象用于向我们的数据库提交查询，它存储从提交的查询返回的结果。现在，我们可以简单地继续编写SQL表达式，并将它们传递给游标对象的execute方法。</p><p id="4c12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的例子中，我们编写了一个查询，在数据库中创建了一个表，并向其中添加了列。animals后面的tuple包含我们希望在表中使用的列的名称，以及要存储在那里的数据的类型。然后我们简单地将它传递给execute方法，这将创建一个表。最后，确保在连接对象上调用commit方法，以实际保存对数据库的更改，并关闭连接。</p><p id="8220" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是我们向数据库添加记录的方法:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jp"><img src="../Images/11bbff088bd7825ef9864a6baa09c4e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*4hSbLtRHNKcbAyyRM5rCVg.png"/></div></figure><p id="6fef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在连接到数据库并实例化了一个游标之后，我们首先定义了一个tuple，其中包含了我们想要的记录值。记得我们做了三个专栏，第一个有integeres，第二个有text。为了将该记录插入到数据库中，我们创建了如上所示的查询。然后，我们将查询和带有实际记录的元组传递给execute，它知道替换“？”用元组的值按顺序排列。</p><p id="acdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">好的，我们知道如何将数据输入我们的数据库。很容易看出我们如何使用API从数据库中检索数据。我们只需将检索代码添加到与端点相关联的资源中，就这样！</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jq"><img src="../Images/ae38f61af06e118380465bcc1886ecc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*KrZAbRuUW0b-GaZSFDKa5g.png"/></div></div></figure><p id="8cc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，我们再次实例化了一个连接、一个游标，并像以前一样将一个查询传递给游标。只是这一次，我们编写了一个select查询，将用户传入的变量传入我们的端点，然后从该查询中检索结果。</p><p id="fc55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想指出一件事。仔细看看这条线:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jr"><img src="../Images/0ce0d0f53a92c2d63250aa6bd95f99a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*mJjYKhLQzqJEJiCZq5JK_g.png"/></div></figure><p id="a0cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意当我们将name变量传递给游标时。传入只有一个值的元组似乎有些奇怪。不幸的是，这只是SQlite的一个怪癖:它要求变量以元组的形式传入，即使只有一个。之后，我们通过对结果调用fetchone，将执行查询的结果捕获到“row”中。Fetchone将只返回一条记录，如果我们只想得到一条记录，那么它是很有用的。这会得到一个列表。如果在数据库中找到一条与用户输入相匹配的记录，我们通过切分列表以JSON格式返回该记录。如果没有找到，我们返回一个错误消息。</p><p id="c11f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一点也不难，对吧？向前去建造吧！</p></div></div>    
</body>
</html>