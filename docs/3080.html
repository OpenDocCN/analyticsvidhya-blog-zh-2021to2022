<html>
<head>
<title>Generative Adversarial Network(GAN)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生成对抗网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/generative-adversarial-network-gan-92c614ba9e64?source=collection_archive---------2-----------------------#2021-06-04">https://medium.com/analytics-vidhya/generative-adversarial-network-gan-92c614ba9e64?source=collection_archive---------2-----------------------#2021-06-04</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="498f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">通过创建一个生成类似于MNIST数据库中的手写数字图像的模型来理解。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/a0d811981854785642163261f315db59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LvZFGZgiG6xO_Wyvh62gZA.jpeg"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">【甘】</figcaption></figure><h2 id="88dd" class="jv jw hi bd ju jx jy jz ka kb kc kd ke iq kf kg kh iu ki kj kk iy kl km kn ko bi translated"><strong class="ak"> <em class="kp">创成式建模简介:</em> </strong></h2><p id="c320" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated"><strong class="ih hj">——<a class="ae kv" href="https://machinelearningmastery.com/what-are-generative-adversarial-networks-gans/" rel="noopener ugc nofollow" target="_blank"><em class="jd">来源</em> </a> <em class="jd">。</em></strong></p><p id="34ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">要了解生成模型的威力，只需访问thispersondoesnotexist.com的</em><a class="ae kv" href="https://thispersondoesnotexist.com/" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">。每次你重新加载页面，一个人的脸的新图像会在运行中生成。结果相当令人着迷。</em></p><p id="d4c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">深度神经网络主要用于监督学习:分类或回归。然而，生成对抗网络或GANs将神经网络用于一个非常不同的目的:生成建模</em></p><p id="c1c8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">虽然有许多方法用于生成建模，但生成对抗网络采用以下方法:</strong></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kw"><img src="../Images/f28f3635c03777150ba266150f68a97e.png" data-original-src="https://miro.medium.com/v2/resize:fit:890/format:webp/1*Y9Y5iO-u9zfisjvzUJo3ZA.png"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated"><strong class="bd ju">氮化镓工艺</strong></figcaption></figure><p id="e40e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两个神经网络:一个生成器和一个鉴别器。给定随机向量/矩阵，生成器生成“假”样本，鉴别器尝试检测给定样本是“真”(从训练数据中选取)还是“假”(由生成器生成)。训练是一前一后进行的:我们训练鉴别器几个时期，然后训练生成器几个时期，然后重复。这样，生成器和鉴别器都能更好地完成各自的工作。</p><p id="78fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，众所周知，GANs很难训练，并且对超参数、激活函数和正则化极其敏感。我们将训练一个GAN来生成类似于MNIST数据库中的手写数字图像。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es kx"><img src="../Images/10ed43d87415414878af086d60a8861f.png" data-original-src="https://miro.medium.com/v2/resize:fit:678/format:webp/1*cIuTUbeQH0pOtGv2AQHoDg.jpeg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">手写数字的图像</figcaption></figure><p id="f8b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我们将要做的事情</p><ul class=""><li id="d324" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><em class="jd">定义问题陈述</em></li><li id="3d5e" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">加载数据(通过变换和归一化)</em></li><li id="6039" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">非标准化，用于样品的目视检查</em></li><li id="41b4" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">定义鉴频器网络</em></li><li id="16d4" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">研究激活功能:泄漏ReLU </em></li><li id="4cae" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">定义发电机网络</em></li><li id="6cf2" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">解释输出激活功能:TanH </em></li><li id="331a" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">看一些样本输出</em></li><li id="ff25" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">为鉴别器和发生器的训练定义损失、优化器和辅助函数</em></li><li id="5a2c" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">训练模型</em></li></ul><ol class=""><li id="512f" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc lm le lf lg bi translated"><strong class="ih hj"> <em class="jd">定义问题陈述:</em> </strong> <em class="jd">训练GAN生成类似于来自数据库的手写数字的图像。</em></li><li id="38f7" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc lm le lf lg bi translated"><strong class="ih hj"> <em class="jd">加载数据(带转换和归一化):</em> </strong> <em class="jd">我们首先使用</em> <code class="du ln lo lp lq b"><em class="jd">torchvision.datasets</em></code> <em class="jd">中的</em> <code class="du ln lo lp lq b"><em class="jd">MNIST</em></code> <em class="jd">助手类下载并导入数据作为PyTorch数据集。</em></li></ol><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">代码解释上面写的行</figcaption></figure><p id="475e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 3。反规格化，用于样本的目视检查:</em> </strong> <em class="jd">因为我们已经规格化了图像数据集，所以我们需要定义一个助手来反规格化图像以查看它们。该功能对于查看生成的图像也很有用。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="af4b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 4。定义鉴别器网络:</em> </strong> <em class="jd">鉴别器将一幅图像作为输入，并试图将其分类为</em> <code class="du ln lo lp lq b"><em class="jd">“real” </em></code> <em class="jd">或</em> <code class="du ln lo lp lq b"><em class="jd">“generated”</em></code> <em class="jd">。在这个意义上，它就像任何其他神经网络一样。虽然我们可以使用CNN作为鉴别器，但为了简单起见，我们使用了一个具有3个线性层的简单前馈网络。我们将把每个28x28的图像视为大小为784的向量。就像任何其他二进制分类模型一样，鉴别器的输出是0和1之间的单个数字，它可以被解释为输入图像是假的(即生成的)的概率。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">定义鉴别器</figcaption></figure><p id="5941" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 5。研究激活函数:Leaky ReLU: </em> </strong>我们对鉴别器使用的是Leaky ReLU激活。与常规ReLU功能不同，泄漏ReLU允许负值的小梯度信号通过。因此，它使来自鉴别器的梯度更强地流入发生器。在反向推进过程中，它不是传递0的梯度(坡度),而是传递一个小的负梯度。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lt"><img src="../Images/2247fc6aa0d30daabd4c8a188aee3bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*siH_yCvYJ9rqWSUYeDBiRA.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">鉴别器的激活功能</figcaption></figure><p id="55a7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">6<em class="jd">。定义生成器网络:</em> </strong> <em class="jd">生成器的输入通常是一个向量或矩阵，用作生成图像的种子。同样，为了保持简单，我们将使用一个具有3层的前馈神经网络，输出将是一个大小为784的向量，它可以转换为28x28 px的图像。ReLU激活用于发生器，但输出层除外，它使用Tanh函数。我们走</em> <code class="du ln lo lp lq b"><strong class="ih hj"><em class="jd"> latent_size=64</em></strong></code></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="88d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 7。解释输出激活函数:TanH: </em> </strong> <em class="jd">在生成器中，w </em> e正在使用生成器输出层的TanH激活函数。因为我们已经观察到，使用有界激活允许模型更快地学习以饱和和覆盖训练分布的颜色空间。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lu"><img src="../Images/33370463979ab8adf4c8525716335527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/1*BqzHBWHSzrkADj4dGGS2ww.gif"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">Tanh函数</figcaption></figure><p id="da18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">注意，由于TanH激活的输出位于</em> <code class="du ln lo lp lq b"><em class="jd">[-1,1]</em></code> <em class="jd">的范围内，我们对训练数据集中的图像应用了相同的变换。</em></p><p id="8922" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 8。看一些示例输出:</em> </strong> <em class="jd">让我们使用生成器生成一个输出向量，并通过对输出</em> <strong class="ih hj"> <em class="jd">进行变换和反规格化来将其视为图像。</em>T29】</strong></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="faff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">正如所料，发电机的输出基本上是随机噪声。现在我们需要定义一个助手函数来训练我们的模型。</em></p><p id="105b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd"> 9。</em>定义损耗、优化器、辅助函数进行训练:</strong> <em class="jd">现在我们需要定义损耗和优化器函数来训练我们的鉴别器和生成器。由于鉴别器是二进制分类模型，我们可以使用二进制交叉熵损失函数来量化它能够区分真实图像和生成图像的程度。</em></p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lv"><img src="../Images/2f8c6b8e86fb15de6dd551f98102a139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*ygOJngLIlJxSfrVqI7LV5w.jpeg"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="79e6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在生成器和鉴别器的优化器中，我们也将学习率设置为0.0002来训练我们的模型。</p><blockquote class="lw lx ly"><p id="1ef7" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj">答<em class="hi">。</em>鉴别器训练:</strong>以下是训练鉴别器的步骤。</p></blockquote><ul class=""><li id="3f97" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><em class="jd">如果图像是从真实的MNIST数据集中选取的，我们希望鉴别器输出1，如果是生成的，输出0。</em></li><li id="b788" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">我们首先传递一批真实图像，并计算损失，将目标标签设置为1。</em></li><li id="fbd0" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">然后，我们使用生成器生成一批假图像，将它们传递到鉴别器，并计算损失，将目标标签设置为0。</em></li><li id="2bf9" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">最后，我们将两个损失相加，并使用总损失来执行梯度下降，以调整鉴别器的权重。</em></li></ul><p id="c985" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">需要注意的是，我们</em> <strong class="ih hj"> <em class="jd">在训练鉴别器时不改变生成器模型</em> </strong> <em class="jd">的权重(</em> <code class="du ln lo lp lq b"><em class="jd">d_optimizer</em></code> <em class="jd">只影响</em> <code class="du ln lo lp lq b"><em class="jd">D.parameters()</em></code> <em class="jd">)。这是我们如何为鉴别器定义训练函数的代码。我们还定义了</em> <code class="du ln lo lp lq b"><strong class="ih hj"><em class="jd">reset_grad</em></strong></code> <em class="jd">函数，在训练每个历元之前将梯度重置为零。</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><blockquote class="lw lx ly"><p id="d75d" class="if ig jd ih b ii ij ik il im in io ip lz ir is it ma iv iw ix mb iz ja jb jc hb bi translated"><strong class="ih hj"> b .生成器训练:</strong> <em class="hi"> </em>由于生成器的输出是图像，我们如何训练生成器并不明显。这就是我们使用一个相当优雅的技巧的地方，即使用鉴别器作为损失函数的一部分。它是这样工作的:</p></blockquote><ul class=""><li id="d70b" class="ky kz hi ih b ii ij im in iq la iu lb iy lc jc ld le lf lg bi translated"><em class="jd">我们用生成器生成一批图像，把它们传入鉴别器。</em></li><li id="2b55" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">我们通过将目标标签设置为1(即真实)来计算损失。我们这样做是因为生成器的目的是“愚弄”鉴别器。</em></li><li id="0eb6" class="ky kz hi ih b ii lh im li iq lj iu lk iy ll jc ld le lf lg bi translated"><em class="jd">我们使用损失来执行梯度下降，即改变生成器的权重，因此它在生成真实图像方面变得更好。</em></li></ul><p id="ffd0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是它的代码。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="8c90" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10。<em class="jd">训练模型:</em>  <em class="jd">现在我们完成了训练模型的所有工作，现在我们已经准备好训练模型了。在每个时期，我们首先训练鉴别器，然后是生成器。如果您没有使用GPU，培训可能需要一段时间。</em></p><p id="7ac0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面是它的代码。</p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="lr ls l"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">训练我们模型的代码</figcaption></figure><p id="c1a5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">如果你的硬件系统中没有安装GPU，你可以使用谷歌colab</em><a class="ae kv" href="https://research.google.com/colaboratory/" rel="noopener ugc nofollow" target="_blank"><em class="jd"/></a><em class="jd">这是一个免费的谷歌数据科学和机器学习服务，你可以在谷歌colab上的jupyter笔记本中将运行时改为GPU。</em></p><p id="64eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">现在我们已经训练了我们的模型，我们可以将中间生成的图像保存到任何文件，我们可以看到我们的图像如何变得像来自随机噪声的MNIST数据集的图像。</em></p><p id="5412" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">这里有一个视频链接，介绍图像是如何变化的</em></p><figure class="jf jg jh ji fd jj"><div class="bz dy l di"><div class="mc ls l"/></div></figure><h1 id="8499" class="md jw hi bd ju me mf mg ka mh mi mj ke mk ml mm kh mn mo mp kk mq mr ms kn mt bi translated">总结:</h1><p id="3c40" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated">下面是我们为训练生成性对抗网络所做的总结。</p><p id="6e5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经训练了一个模型，该模型获取一组真实图像，并生成一些与真实图像相似的假图像。对于这项工作，我们首先从MNIST数据集中加载数据，查看数据集中的图像，定义一个鉴别器来区分真实图像和生成的图像，定义一个生成器来生成图像，然后训练鉴别器和生成器，最后使用一些超参数(如历元数和学习率)来训练我们的完整模型，就这样。</p><h1 id="1952" class="md jw hi bd ju me mf mg ka mh mi mj ke mk ml mm kh mn mo mp kk mq mr ms kn mt bi translated">未来工作:</h1><p id="faf6" class="pw-post-body-paragraph if ig hi ih b ii kq ik il im kr io ip iq ks is it iu kt iw ix iy ku ja jb jc hb bi translated"><em class="jd">作为一项练习，你应该尝试独立应用每项技术，看看每项技术对性能和最终输出的影响有多大。当你尝试不同的实验时，你会开始培养选择正确架构的直觉，你会越来越好。</em></p><p id="8b41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">为了得到你的帮助，我在参考资料中分享了帮助笔记本。</em></p><h1 id="5e3e" class="md jw hi bd ju me mf mg ka mh mi mj ke mk ml mm kh mn mo mp kk mq mr ms kn mt bi translated"><strong class="ak">参考文献:</strong></h1><ol class=""><li id="094e" class="ky kz hi ih b ii kq im kr iq mu iu mv iy mw jc lm le lf lg bi translated"><a class="ae kv" href="https://jovian.ai/bhupendrasingh62435/06-mnist-gan" rel="noopener ugc nofollow" target="_blank">我的木星笔记本本项目的生成对抗网络</a></li></ol><p id="0f6b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<em class="jd"> </em> <a class="ae kv" href="https://jovian.ai/learn/deep-learning-with-pytorch-zero-to-gans" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Jovian.ai教程</em> </a></p><p id="2640" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<a class="ae kv" href="https://youtu.be/79IvwU3G5_Q?list=PLyMom0n-MBroupZiLfVSZqK5asX8KfoHL" rel="noopener ugc nofollow" target="_blank"> <em class="jd">具体视频讲解如何创建生成性对抗网络</em> </a></p><div class="mx my ez fb mz na"><a href="https://jovian.ai/bhupendrasingh62435/06-mnist-gan" rel="noopener  ugc nofollow" target="_blank"><div class="nb ab dw"><div class="nc ab nd cl cj ne"><h2 class="bd hj fi z dy nf ea eb ng ed ef hh bi translated">bhupendrasingh 62435/06-mnist-gan-Jovian</h2><div class="nh l"><h3 class="bd b fi z dy nf ea eb ng ed ef dx translated">在06-mnist-gan笔记本上与bhupendrasingh62435协作。</h3></div><div class="ni l"><p class="bd b fp z dy nf ea eb ng ed ef dx translated">jovian.ai</p></div></div><div class="nj l"><div class="nk l nl nm nn nj no jo na"/></div></div></a></div><p id="1aa8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你喜欢这个，并且发现了一些有趣的东西，你可以为我鼓掌，你也可以和你的朋友分享这些东西</p><h1 id="3432" class="md jw hi bd ju me mf mg ka mh mi mj ke mk ml mm kh mn mo mp kk mq mr ms kn mt bi translated">感谢您的阅读，祝您好运。</h1></div></div>    
</body>
</html>