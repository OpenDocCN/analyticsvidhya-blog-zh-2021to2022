<html>
<head>
<title>Apache Kafka Architecture - Getting Started with Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Kafka架构-Apache Kafka入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-kafka-architecture-getting-started-with-apache-kafka-771d69ac6cef?source=collection_archive---------1-----------------------#2021-03-21">https://medium.com/analytics-vidhya/apache-kafka-architecture-getting-started-with-apache-kafka-771d69ac6cef?source=collection_archive---------1-----------------------#2021-03-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="2516" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇博文中，我将尝试解释什么是Apache Kafka，它是如何工作的，何时使用，向Kafka写入数据，以及从Kafka读取数据。令人愉快的读物。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/fce5dc1f99e71c13e9b7e60887b32ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*YZ8LhE9vCaheBkviPzQEaw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="http://www.techmonks.org/kafka-terminology/" rel="noopener ugc nofollow" target="_blank">http://www.techmonks.org/kafka-terminology/</a></figcaption></figure><p id="8c98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们先来看看过去的建筑。在90年代，客户机-服务器体系结构很流行。这里有一个整体结构。在<strong class="ig hi"> <em class="jp">的单片</em> </strong>结构中；所有结构都包含在一个应用程序中。随着时间的推移，上网人数增加了。版本更新已经成为一种持续的需求。由于这个原因，喜欢这种结构的人越来越少。</p><p id="82ca" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后<strong class="ig hi"> <em class="jp">微服务</em> </strong>脱颖而出。但是，由于微服务中有太多的应用程序，应用程序如何相互通信的问题一直是个大问题。</p><p id="08c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随着时间的推移，新的组件开始出现。每个新发布的组件都会导致应用程序网络中出现许多新的连接。</p><p id="1b40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在接下来的时间里，两种不同的架构开始被使用。</p><p id="1814" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jq jr js jt b">Request/Response Architecture</code>；在这个架构中，一个部分调用另一个部分，并等待它的响应。这个网络非常庞大和复杂。随着数据量的增长，使用这种架构变得有点困难。</p><p id="68ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个是<code class="du jq jr js jt b">Event-Driven Architecture</code>；<strong class="ig hi"> <em class="jp">消息总线</em> </strong>使得这种架构的实现成为可能。现在，与<code class="du jq jr js jt b">Event</code>的交流已经在军种之间开始了。没有服务直接联系对方。</p><p id="52e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个部分都异步地做事情，彼此之间没有联系。还有很多其他应用使用<code class="du jq jr js jt b">Message Bus</code>。阿帕奇卡夫卡就是其中之一，可以说是最受欢迎的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ju"><img src="../Images/0e07be125e05d2d8a78db88b1555bad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q-43CEWGeKNoOpO3UoqkbQ.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="https://realtimeapi.io/hub/event-driven-apis/" rel="noopener ugc nofollow" target="_blank">https://realtimeapi.io/hub/event-driven-apis/</a></figcaption></figure><h2 id="63a8" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">那么阿帕奇卡夫卡是如何传递这种信息的呢？</h2><p id="f93e" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">在卡夫卡那里，信息被发送到叫做<code class="du jq jr js jt b">Topic</code>的地方。每个主题都有一个名称。另外，其他人也可以阅读这些主题。</p><h2 id="4239" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">什么是阿帕奇卡夫卡？</h2><p id="8a8a" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">Apache Kafka，就其最一般的定义而言，是一个分布式消息传递系统。卡夫卡的一些特征是:</p><ul class=""><li id="fe2a" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">流处理平台</li><li id="00fc" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">开源软件</li><li id="6c65" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">分布式的计算机系统</li><li id="6e9c" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">完全可扩展</li><li id="aa1d" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">高性能-低延迟</li></ul><p id="a0fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">阿帕奇卡夫卡；被许多大公司使用，如网飞、苹果、优步、Spotify和LinkedIn。现在，实时流处理对公司来说变得非常重要。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ln"><img src="../Images/fc6cdff12ae4e49bdbe0c4eb8cdd7a63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*oLdyxvynNlZEwSxybZdGQg.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="https://www.slideshare.net/brianritchie1/building-eventdriven-systems-with-apache-kafka" rel="noopener ugc nofollow" target="_blank">https://www . slide share . net/brianritchie 1/building-event driven-systems-with-Apache-Kafka</a></figcaption></figure><h2 id="f500" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">我们能用阿帕奇卡夫卡做什么？</h2><ul class=""><li id="142d" class="kz la hh ig b ih ku il kv ip lo it lp ix lq jb le lf lg lh bi translated">欺诈和异常检测</li><li id="77f4" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">推荐引擎</li><li id="a82b" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">监控/指标</li><li id="5ee8" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">活动跟踪</li><li id="abf6" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">集成系统</li><li id="7c8d" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">实时流处理</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es lr"><img src="../Images/68a7a97b9d7630f044ed98cfe858c713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mpZDWKBleYyBIYVau5difA.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="https://axual.com/apache-kafka-use-cases-in-real-life/" rel="noopener ugc nofollow" target="_blank">https://axual.com/apache-kafka-use-cases-in-real-life/</a></figcaption></figure><h2 id="3142" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">阿帕奇·卡夫卡的建筑</h2><p id="9e5c" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">卡夫卡建筑有4个演员。这些是；</p><ul class=""><li id="924c" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">经纪人</li><li id="a29f" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">动物园管理员</li><li id="c5cc" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">生产者</li><li id="bfc7" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">消费者</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es ls"><img src="../Images/a0485821d322862e1e497cd622f82304.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0QqLTumYuNrpmNoZr1QoEA.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="https://www.cloudkarafka.com/blog/2016-11-30-part1-kafka-for-beginners-what-is-apache-kafka.html" rel="noopener ugc nofollow" target="_blank">https://www . cloudkarafka . com/blog/2016-11-30-part 1-Kafka-for-初学者-什么是-apache-kafka.html </a></figcaption></figure><p id="a68d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个Kafka集群由一个或多个<code class="du jq jr js jt b">Brokers</code>组成。每个代理相互依赖地工作。每个经纪人都有自己唯一的识别号。在代理中发送给Kafkaya的消息被存储和处理。计算机内存不用于数据存储。数据存储在硬盘上。</p><p id="fdf1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jq jr js jt b">Zookeeper</code>是开源软件。卡夫卡用Zookeeper来管理所有经纪人。发送的数据从不存储在这里。动物园管理员的职责是:</p><ul class=""><li id="18e3" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">协调经纪人。</li><li id="6eba" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">选择主分区。</li><li id="72d9" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">确保经纪人相互了解。</li><li id="02b0" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">发现新的或删除的经纪人或新增加的，改变的主题。</li></ul><p id="ce56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du jq jr js jt b">Producer</code>；向Kafka写入数据。<code class="du jq jr js jt b">Consumer</code>从Kafka读取数据。</p><p id="17e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在现实生活中，经纪人和动物园管理员的数量应该由奇数组成，并且应该至少为3。这样做的原因是为了确保复制过程可以正确执行，并防止出现诸如<code class="du jq jr js jt b">Split-Brain</code>之类的问题。</p><p id="eaae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">复制是将数据复制所需的次数。换句话说，数据的副本被创建和再现。复制次数应该是多少？我们可以用一个简单的公式证明这一点。</p><pre class="jd je jf jg fd lt jt lu lv aw lw bi"><span id="abe7" class="jz ka hh jt b fi lx ly l lz ma">Number of <strong class="jt hi">Brokers </strong>&gt; =<strong class="jt hi"> </strong>Number of <strong class="jt hi">Replications</strong></span></pre><h2 id="b5fc" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">如何向阿帕奇卡夫卡写数据？</h2><p id="867f" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">Apache Kafka使用Topic存储数据。每个主题都有自己的名字。主题存储在代理上。</p><p id="7db5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主题中有分区。所以Topic是一个由分区组成的结构。数据实际上被写入主题中的任何分区。我们可以决定确定每个主题的分区数量。</p><p id="f66c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分区实际上使用了日志原理。也就是后面不断添加数据。我们不能添加分区的开头或中间。数据按照发送到分区的顺序写入。这是从旧到新的顺序。写入的数据不能再次更改。分区中的数据不会永远存储在这里。Kafka有两种存储配置。这些是:</p><ul class=""><li id="5087" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated">基于时间的保留(例如7天)</li><li id="4f97" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">基于数据大小的存储(例如100 GB)</li></ul><p id="1011" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为分区中的每条消息定义一个偏移量。使用该偏移量读取数据。实际上，偏移量是用来确定数据的位置的。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="er es mb"><img src="../Images/aeb285d28d83aab00be7297b827001da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XoGldc1rfKOQJsCeIYULBg.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">资源:<a class="ae jo" href="https://dzone.com/articles/apache-kafka-topic-architecture-amp-partitions" rel="noopener ugc nofollow" target="_blank">https://dzone . com/articles/Apache-Kafka-topic-architecture-amp-partitions</a></figcaption></figure><h2 id="9584" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">我们为什么要创建分区？</h2><ul class=""><li id="9377" class="kz la hh ig b ih ku il kv ip lo it lp ix lq jb le lf lg lh bi translated">到<code class="du jq jr js jt b">Aggregation</code>根据生产者数据中规定的特征</li><li id="1c54" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">保持数据有序(<code class="du jq jr js jt b">Sorting — Event-Sourcing</code></li><li id="f12e" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">通过增加<code class="du jq jr js jt b">Parallelism</code>读取数据更快</li><li id="7cc9" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated">更有效地存储数据(<code class="du jq jr js jt b">Efficiency</code></li></ul><h2 id="af9e" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">如何将数据写入分区？</h2><p id="cd49" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">我们可以给我们发送给卡夫卡的信息一个密钥。Kafka将相同的键值写入同一个分区。假设我们不给钥匙。在这种情况下，卡夫卡采用了循环法。换句话说，它通过将传入的消息分成多个分区来编写它们。比如我们给类别Key-Value，Kafka就把同一个类别的数据写入同一个分区。</p><p id="ca40" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jp">关于分区要知道的一些事情:</em> </strong></p><p id="fa95" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，如果只有一个分区，那么读写数据的性能将会非常低。平行将不复存在。</p><p id="55fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一次只有一个具有相同ID的用户可以读取一个分区。</p><p id="20af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用分区，我们可以按我们想要的方式路由大消息。</p><p id="5115" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jp">领袖分区选举</em> </strong></p><p id="bc1f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每个分区的一个复制副本被指定为主导分区。数据总是被写入这些主分区。然后，这些主分区通过将数据发送到其他副本来提供同步。如果主分区崩溃，Kafka会将其中一个副本指定为主分区。</p><p id="fd78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jp">制作者确认</em> </strong></p><p id="c035" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ack = 0→最快但风险最大的方法。数据被发送到Kafka，它继续不等待回答。</p><p id="e1dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ack = 1→中快，认为是安全的。数据被发送到Kafka，它等待直到数据被写入主分区，然后继续。</p><p id="3f19" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ack = 2→最慢、最安全的方法。数据被发送到Kafka，数据被写入主分区在主分区写入其他副本之后，系统继续。</p><h2 id="2c67" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">如何从阿帕奇卡夫卡中读取数据？</h2><p id="c86f" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">卡夫卡在读取数据时首先确定的是从哪个位置读取数据。这个位置叫做偏移量。如果读者已经阅读或停止，那么他在Zookeeper中最后停留的地方是清楚的。卡夫卡继续阅读。</p><h2 id="d706" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">卡夫卡的信息阅读策略</h2><p id="acaa" class="pw-post-body-paragraph ie if hh ig b ih ku ij ik il kv in io ip kw ir is it kx iv iw ix ky iz ja jb ha bi translated">可以用3种不同的策略读取数据。</p><ul class=""><li id="0032" class="kz la hh ig b ih ii il im ip lb it lc ix ld jb le lf lg lh bi translated"><strong class="ig hi">最多一次:</strong>消息丢失的风险很高。分别应用读取、提交、处理和保存到数据库步骤。</li><li id="1c34" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated"><strong class="ig hi">至少一次:</strong>这是最首选的策略。我们确保处理消息时没有错误。分别应用读取、处理、保存到数据库和提交步骤。</li><li id="d35c" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb le lf lg lh bi translated"><strong class="ig hi">恰好一次:</strong>传入的消息被保存在一个事务中。即使过程中有任何中断，消息也不会消失。但是这种方法对性能有巨大的影响。应该只在必要的时候使用。分别应用读取、事务和提交步骤。</li></ul><p id="4b99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢阅读这篇博文。要了解更多信息，您可以从下面的资源中进行研究。您对内容的建议和反馈对我来说非常重要。你可以通过评论来表明你的想法。祝大家快乐！</p><h2 id="9afc" class="jz ka hh bd kb kc kd ke kf kg kh ki kj ip kk kl km it kn ko kp ix kq kr ks kt bi translated">资源</h2><ol class=""><li id="5843" class="kz la hh ig b ih ku il kv ip lo it lp ix lq jb mc lf lg lh bi translated"><a class="ae jo" href="https://www.youtube.com/c/BarisDereTR" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/c/BarisDereTR</a></li><li id="b8c0" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb mc lf lg lh bi translated"><a class="ae jo" href="https://www.youtube.com/watch?v=ccmb4uZOSp4&amp;list=PLZYKO7600KN9ttvG0mFYzP82AbIdeJYwq" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=ccmb4uZOSp4&amp;list = plzyko 7600 kn 9 ttvg 0 mfyzp 82 abidejywq</a></li><li id="7e0c" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb mc lf lg lh bi translated"><a class="ae jo" href="https://www.instaclustr.com/apache-kafka-architecture/" rel="noopener ugc nofollow" target="_blank">https://www.instaclustr.com/apache-kafka-architecture/</a></li><li id="33bd" class="kz la hh ig b ih li il lj ip lk it ll ix lm jb mc lf lg lh bi translated"><a class="ae jo" href="https://kafka.apache.org/documentation/" rel="noopener ugc nofollow" target="_blank">https://kafka.apache.org/documentation/</a></li></ol></div></div>    
</body>
</html>