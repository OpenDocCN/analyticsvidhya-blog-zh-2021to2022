<html>
<head>
<title>Consistent Hashing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一致散列法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/consistent-hashing-f94a6c6d511?source=collection_archive---------11-----------------------#2021-03-06">https://medium.com/analytics-vidhya/consistent-hashing-f94a6c6d511?source=collection_archive---------11-----------------------#2021-03-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/b70cc8860e6ef9c32eb2b20f3ee19976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Sw1BErDSdeJZ4prh"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">由<a class="ae it" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马库斯·斯皮斯克</a>在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="0b76" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">哈希基础……⭐️</strong></h2><p id="c41c" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">哈希是设计和开发分布式系统时使用的最基本、最强大的技术之一。散列意味着将一个任意的<em class="kn">键</em>(一个对象)<em class="kn">(通常是</em>)转换成一个整数，称为<em class="kn"> hashcode </em>。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="3108" class="iu iv hh kt b fi kx ky l kz la">int hashCode = hashMe(key)</span></pre><p id="cb27" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">散列需要一个<em class="kn">强</em>散列函数，它接受一个键并返回一个整数。所谓<em class="kn">强</em>，我的意思是这个函数必须能够在输出范围内均匀分布各种键，这样<em class="kn">碰撞</em>就很少了。一个<em class="kn">冲突</em>意味着不止一个键被分配了相同的整数。令人欣慰的是，这个问题已经解决了，有许多众所周知的很好的散列算法，例如MD5，SHA，brunh等。</p><p id="cbd6" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">哈希技术广泛应用于简单程序、web应用程序和大规模分布式系统中，用于快速查找关键字。</p><h2 id="cc0d" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">缓存…📝</strong></h2><p id="a49b" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">从磁盘或通过网络读取需要时间，并且会增加应用程序的延迟。为了消除这种延迟，通常将结果存储在内存中(在哈希表中),以便更快地查找。它确实可以加速许多操作，降低成本，还可以减少下游系统的负载。尽管在进行缓存时会遇到不同的挑战。例如，我们必须解决如下一些挑战-</p><ul class=""><li id="6281" class="lg lh hh ju b jv lb jz lc jf li jj lj jn lk km ll lm ln lo bi translated">如何让缓存保持最新？</li><li id="1f8b" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km ll lm ln lo bi translated">提供陈旧数据可以吗？</li><li id="db46" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km ll lm ln lo bi translated">当托管缓存的机器死亡时会发生什么？</li><li id="9efc" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km ll lm ln lo bi translated">如果数据变大，而您无法将数据完全加载到内存中，该怎么办？</li></ul><p id="c677" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">嗯，所有这些挑战总是会存在的，我们作为工程师必须找到一个平衡点，并知道我们所做的权衡的风险。</p><p id="0fbb" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">当分布在机器上时，缓存可以水平扩展。</p><h2 id="50dd" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">分布式缓存…😱</strong></h2><p id="0ed7" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">因此，您加载到内存中的数据集变得非常庞大，无法在一台机器上加载，因此您必须将数据分散到多台机器上。但是你如何传播它呢？</p><p id="f24f" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">例如，您想要在内存中存储用户信息，并且您有一百万个用户。因此，您启动了多台机器，并为每台机器分配了一组用户。想象一下你会有一张像这样的地图-</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b667" class="iu iv hh kt b fi kx ky l kz la">#where 0,1,2 represents machineId and u{int} represents UserId(key)<br/>0 -&gt; [u1, u2, u3, u4]<br/>1 -&gt; [u5, u6, u7, u8]<br/>2 -&gt; [u9, u10]}</span></pre><p id="24ca" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">如何将机器分配给用户？一个基本的技术可以是只做模运算，然后找到machineId。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8ca3" class="iu iv hh kt b fi kx ky l kz la">machineId = key % (number of machines)</span></pre><p id="e500" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">因此，如果用户Id是56，并且您有3台机器，您将把用户放在带有<code class="du lu lv lw kt b">id = (56%3) = 2</code>的机器上。如果用户Id是90，那么您将使用带有<code class="du lu lv lw kt b">id = (90%3) = 0</code>的机器，以此类推…</p><p id="b623" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">这个简单的散列技术是可行的，但是…</p><ul class=""><li id="c7fb" class="lg lh hh ju b jv lb jz lc jf li jj lj jn lk km ll lm ln lo bi translated">如您所见，我们的哈希函数取决于机器的数量，当我们想要添加更多机器或删除一些机器时，它会为每个用户更改哈希。所以现在，您需要在您的机器集群中洗牌。因此，每当一台机器死机或者你想升级的时候，你就必须不停地按键。这可能非常昂贵，而且随着集群规模的增长，这种情况会更加频繁。</li><li id="976d" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km ll lm ln lo bi translated">另一个问题是，密钥不是均匀分布的，这意味着您可能最终拥有一台机器比其他机器拥有更多的密钥。因此，这台机器将服务于大多数请求<strong class="ju hi"> <em class="kn">(热缓存)</em> </strong>。例如，如果大多数用户标识可以被“机器数量”整除，那么它们将会出现在带有<code class="du lu lv lw kt b">id=0</code>的机器上，而其他机器将会闲置。</li></ul><p id="6535" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">因此，这种技术不是水平可伸缩的。</p><h2 id="6571" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated"><strong class="ak">一致散列法…👊</strong></h2><p id="7f02" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">这种技术<em class="kn">减少了</em>向外扩展或向内扩展时的键重组，这在以前的方法中是一个大问题。现代分布式数据库和缓存解决方案使用一致的散列法，例如DynamoDb、Redis等。</p><p id="be76" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated"><strong class="ju hi">它是如何工作的？🤔</strong></p><p id="09ca" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">想象一个环形编队，在这个环上你分散你的机器。您的散列函数生成一个范围<code class="du lu lv lw kt b">0...H</code>内的整数。每个整数映射到环上的一个点。对于每个缓存<em class="kn">(机器)</em>你将在环上分配一个点。比如说。<code class="du lu lv lw kt b">cache1 -&gt; 5</code> <code class="du lu lv lw kt b">cache2 -&gt; 100</code>等等…</p><ol class=""><li id="4fa0" class="lg lh hh ju b jv lb jz lc jf li jj lj jn lk km lx lm ln lo bi translated">对于给定的键，找到散列整数<code class="du lu lv lw kt b">int hashIndex = hashFunc(key)</code></li><li id="5642" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km lx lm ln lo bi translated">这个<code class="du lu lv lw kt b">hashIndex</code>映射到环上的一个点。</li><li id="4483" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km lx lm ln lo bi translated">从这一点，顺时针方向移动，找到下一台可用的机器。</li><li id="6ce7" class="lg lh hh ju b jv lp jz lq jf lr jj ls jn lt km lx lm ln lo bi translated">这台机器将容纳<code class="du lu lv lw kt b">key</code></li></ol><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ly"><img src="../Images/fd2be88ca2acda502a8f2349e5ea3402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ziqdspLiW0yDmJ-5zxnU4g.png"/></div></div></figure><p id="51dc" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated"><strong class="ju hi">添加一台机器……➕</strong></p><p id="88c6" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">当您添加一台机器时，您只需从新机器之前存在的机器上移动一些密钥，其余的密钥保留在以前的设置中。</p><p id="c255" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated"><strong class="ju hi">移除机器… ➖ </strong></p><p id="1627" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">当一台机器死亡时，存在于该机器上的所有密钥将转移到环上的下一台机器。其余的键不会被重组。</p><p id="f93c" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">因此，在最大时间内，如果添加或移除机器，仅移动<code class="du lu lv lw kt b">k/n</code>键，其中<code class="du lu lv lw kt b">k = number of keys</code>和<code class="du lu lv lw kt b">n=number of machines</code></p><p id="25e4" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">到目前为止，我们解决了向外扩展或向内扩展时重组键的问题。但是非均匀密钥分布的另一个问题仍然会发生，因为密钥只是随机分布的。</p><p id="f79a" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">这个<em class="kn">热</em>缓存的问题，可以用副本来解决。因此，我们将缓存映射到环上的多个点，而不是映射到环上的单个点。所以现在每个缓存映射到环上的多个点。<code class="du lu lv lw kt b">cache1 -&gt; 5, 153, 200</code> <code class="du lu lv lw kt b">cache2 -&gt; 100, 240</code>以此类推。这也意味着，每个缓存将保存属于环的不同部分的<code class="du lu lv lw kt b">keys</code>。</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/3c7bc75ce2dd6e25772ebaeaec5348d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qopc2qWHdiBxkV7ymif57A.png"/></div></div></figure><p id="cac8" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">副本的数量越多，分布就越均匀。</p><p id="e1fc" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">🍻干杯，</p><p id="e053" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">Kaivalya Apte💻</p><p id="a4c6" class="pw-post-body-paragraph js jt hh ju b jv lb jx jy jz lc kb kc jf ld ke kf jj le kh ki jn lf kk kl km ha bi translated">软件工程师@Twilio</p></div></div>    
</body>
</html>