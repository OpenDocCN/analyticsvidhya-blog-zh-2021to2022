<html>
<head>
<title>Thinking in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在反应中思考</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/thinking-in-react-c9661081ef91?source=collection_archive---------4-----------------------#2021-08-18">https://medium.com/analytics-vidhya/thinking-in-react-c9661081ef91?source=collection_archive---------4-----------------------#2021-08-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7b8ea738091862d95cbc49a9210e8a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dzGEBDpbFgU3KgnvrsFdiw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">让我们建造</figcaption></figure></div><div class="ab cl it iu go iv" role="separator"><span class="iw bw bk ix iy iz"/><span class="iw bw bk ix iy iz"/><span class="iw bw bk ix iy"/></div><div class="ha hb hc hd he"><p id="5f11" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">这篇博客的目标读者是React的初学者。</p><h2 id="25f9" class="jy jz hh bd ka kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks bi translated">第0节:简介</h2><p id="2eaa" class="pw-post-body-paragraph ja jb hh jc b jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt kx jv jw jx ha bi translated"><strong class="jc hi">这篇博文</strong>的目的是构建一个非常简单的react应用<em class="ky"> </em>，但是我们将按照react文档<a class="ae kz" href="https://reactjs.org/docs/thinking-in-react.html#:~:text=%20Thinking%20in%20React%20%201%20Step%201%3A,of%20app%20state%20is.%20Next%2C%20we...%20More%20" rel="noopener ugc nofollow" target="_blank"> <strong class="jc hi">中描述的系统化方法</strong>来完成<strong class="jc hi"/></a><strong class="jc hi">。</strong></p><p id="1e56" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">读完这篇博文后，如果我的读者能够理解这里解释的一些思维过程，并直观地将其融入到他们学习React的日常工作流程中，我会很高兴，这将是这篇博文的关键所在。</p><p id="37ac" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">读者不必担心这篇博文中缺少代码。这篇博文的主要目的是向读者阐述在React中开发网站时所涉及的一些思维过程。当然，这个项目的代码是作为GitHub Repo的链接提供的。</p><h2 id="f5ea" class="jy jz hh bd ka kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks bi translated">第一部分:主要内容</h2><p id="547d" class="pw-post-body-paragraph ja jb hh jc b jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt kx jv jw jx ha bi translated">首先，让我们看看我们正在努力构建什么。👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/4b7ff0761981510d4c3f6612f8350da7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*WX0_9G3c-b6Ipaod_4KRMA.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">我们将使用React文档中规定的系统方法构建web-app</figcaption></figure><p id="7fd3" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">正如我们在应用程序中看到的那样，有一堆问题，每个问题都有一个相关的按钮，当用户点击按钮时，应用程序会显示答案。</p><p id="12a4" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">要使用React构建这个网站/web应用程序，文档建议我们从一个模拟开始，就像设计师提供给我们的演示网站一样，将其分成几个部分，并构建一个组件层次结构。把“把它分成小块”想成是指我们给应用程序的每一个可辨别的部分贴上标签。</p><p id="aa26" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">现在，让我们标记应用程序的每个部分，然后决定应用程序的组件层次结构。</strong></p><p id="5a63" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我已经标记了应用程序的每个可识别的部分如下。就看一眼吧👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lf"><img src="../Images/b31d5faf97e1903ccd64d93b49814028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQlDoyxXVUro7J0w2mmSfw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">标有不同部分的应用程序。</figcaption></figure><p id="addf" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在，让我们决定我们需要为这个应用程序构建的组件及其层次结构。</p><p id="76ec" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">让我们从第4、5、6和7部分组成一个名为QAcard的组件。</p><p id="50a9" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我们可以在QAcard中使用条件渲染、道具和状态改变来渲染5和7。对于第6部分，我们将构建一个名为ExpandBtn的组件。</p><p id="5446" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在QAcard的层次结构如下所示👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/a9b1d046ae87b9d91684ea1cd8e5c493.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*wYAjhdynh1vJUgjpWhZGjw.png"/></div></figure><p id="45bb" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">让我们使用组件QAcard组成另一个名为BoxOfQA的组件。这个BoxOfQA组件表示标记为8的部分。BoxOfQA的组件层次结构如下所示👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/381950323a3416097e86141ecd8a10ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*wMqedTSperHauWhwEw-CZw.png"/></div></figure><p id="9aa6" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">让我们创建一个名为Content的组件，它表示标记为2的部分，这个组件将包含第3部分和BoxOfQA组件。我们也不要将1作为组件来实现。</p><p id="439e" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在，我们的整个组件层次结构将看起来像这样👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es li"><img src="../Images/44bf6e10f20b96053f92eae572b31902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*mzBQb7UGXnwuq2RN2eHXiw.png"/></div></figure><p id="4bf6" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在我们知道了我们的组件和它们的层次结构，让我们通过<strong class="jc hi">构建我们的应用程序</strong>的静态版本来做一些编码。<strong class="jc hi"> </strong>在编码之前，我们最好仔细考虑一下这些组件的功能<strong class="jc hi">。</strong>如果我们<strong class="jc hi">问自己类似</strong>的问题会更好</p><ol class=""><li id="9e4d" class="lj lk hh jc b jd je jh ji jl ll jp lm jt ln jx lo lp lq lr bi translated">每个组件的职责是什么？</li><li id="53c6" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">两个不同的组件之间是否有一些共同的责任？</li><li id="b0ca" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">一个组件是多余的吗？</li><li id="c193" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">我们可以设想一个不同的组件层次结构吗？</li></ol><p id="ae6a" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">无论如何，不管上述问题的答案是什么，我都将继续组装一个静态版本的应用程序。</p><p id="864d" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">根据</strong> <a class="ae kz" href="https://reactjs.org/docs/thinking-in-react.html#step-2-build-a-static-version-in-react" rel="noopener ugc nofollow" target="_blank"> <strong class="jc hi"> React官方文档</strong> </a> <strong class="jc hi">“到这一步结束时，你将拥有一个可重用组件库来呈现你的数据模型”</strong></p><p id="8209" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我用过create-react-app并且src目录的结构和app静态版本的代码可以在这里<a class="ae kz" href="https://github.com/varadan13/Thinking-in-React" rel="noopener ugc nofollow" target="_blank">阅读。</a></p><p id="743e" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated"><strong class="jc hi">我实现的静态版本的应用程序</strong>看起来像👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lx"><img src="../Images/80e7c27ca9984be8a62f0cd9ffc1d19b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YqTA47LTCnZQ3Gkh74skvQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">应用程序的静态版本</figcaption></figure><p id="7c7e" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">在这个阶段，按钮不起作用，UI没有响应。现在让我们让它有反应。</p><p id="f3a3" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">是时候识别我们传递给组件和从组件传递来的所有数据了。</p><p id="30ad" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在，让我们识别应用程序中的所有数据。</p><p id="627e" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">作为项目设置的一部分，我们有一个名为data.js的文件，顾名思义，它包含我们在应用程序中显示的问题和答案的json数据。我们将这个文件导入到我们的应用程序的BoxOfQA组件中，并在QAcard组件中使用它。因此，基本上在我们的简单应用程序中，这是从一个组件流向另一个组件的唯一数据。下图强调了两个组件之间的数据流。然而，这些数据并不代表一种状态，因为它们不必随着一些用户交互而改变。</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es ly"><img src="../Images/3cd79abd0cc96b44cbcc9a8c98101ab2.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*IDZrtChBJit_pjUySRTTug.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">流程图显示了从组件BoxOfQA到QAcard的数据流</figcaption></figure><p id="627d" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">因为我们现在已经识别了应用程序中的数据。让我们弄清楚我们需要对这个应用程序进行反应的所有状态。</p><p id="0c74" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">我们确实需要一个状态，当用户点击按钮时，这个状态就会更新。我想就这样吧。有了这一个状态，我们就能实现我们的目标。</p><p id="ca61" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">使用此状态，我们可以:</p><ol class=""><li id="aec3" class="lj lk hh jc b jd je jh ji jl ll jp lm jt ln jx lo lp lq lr bi translated">更改按钮上显示的内容</li><li id="2463" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">显示和不显示问题的答案。</li></ol><p id="b03a" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">现在是时候弄清楚我们必须把我们的状态放在哪里了，为此我们必须参考我们的组件层次结构图。我们有两个选择:</p><ol class=""><li id="2ccc" class="lj lk hh jc b jd je jh ji jl ll jp lm jt ln jx lo lp lq lr bi translated">这种状态可以由按钮私下管理，这并没有错，因为这种状态是由于我们单击按钮而发生的，因此我们可以使它成为这种状态的唯一所有者，但这可能会导致一个问题，即我们可能会发现很难有条件地显示问题的答案</li><li id="a1ed" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">我们可以提升状态，并把它放在一个组件中，我们可以做这两个，即，更新按钮和有条件地呈现答案</li></ol><p id="e0b3" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">如果我们仔细看看我们的层次结构图，有一个合适的地方来保存我们的状态，那就是QAcard组件。</p><p id="200f" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">概括地说，我们已经计算出应用程序中的主要数据，我们决定只创建一个州，我们决定将它放在QAcard中。现在让我们来实现它。</p><p id="1fca" class="pw-post-body-paragraph ja jb hh jc b jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx ha bi translated">实现状态后，应用程序的行为如下👇</p><figure class="lb lc ld le fd ii er es paragraph-image"><div class="er es la"><img src="../Images/0615e8ab6722fa9c9b13bdd8f20b12fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*KuCf1TH4jPwttgL7xSoGpw.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">应用程序的最终版本。</figcaption></figure><h2 id="24cf" class="jy jz hh bd ka kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks bi translated">第二部分:结论</h2><p id="c2ef" class="pw-post-body-paragraph ja jb hh jc b jd kt jf jg jh ku jj jk jl kv jn jo jp kw jr js jt kx jv jw jx ha bi translated">因为这个应用程序非常简单。很容易找出组件并决定它们的功能。很容易找出组件之间的数据流、状态等。但是在一个普通的react项目中，这些活动会消耗大量的时间。理想情况下，你必须在一个更大的项目中尝试这种方法，并检查它是否可行，是否让你富有成效。我认为这确实让你更有效率。</p><h2 id="2013" class="jy jz hh bd ka kb kc kd ke kf kg kh ki jl kj kk kl jp km kn ko jt kp kq kr ks bi translated">第3节:参考</h2><ol class=""><li id="1b53" class="lj lk hh jc b jd kt jh ku jl lz jp ma jt mb jx lo lp lq lr bi translated">我的<a class="ae kz" href="https://github.com/varadan13/Thinking-in-React" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>包含上述应用程序的代码。</li><li id="90dc" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated"><a class="ae kz" href="https://reactjs.org/docs/thinking-in-react.html#:~:text=%20Thinking%20in%20React%20%201%20Step%201:,of%20app%20state%20is.%20Next,%20we...%20More%20" rel="noopener ugc nofollow" target="_blank">思考中反应过来</a></li><li id="6ede" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">这个<a class="ae kz" href="https://github.com/john-smilga/react-projects/tree/master/04-accordion/final" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>被用作这篇博文中使用的项目代码的参考。</li><li id="848a" class="lj lk hh jc b jd ls jh lt jl lu jp lv jt lw jx lo lp lq lr bi translated">上面GitHub repo的作者在这里托管了app<a class="ae kz" href="https://react-projects-4-accordion.netlify.app/" rel="noopener ugc nofollow" target="_blank"><strong class="jc hi"/></a><strong class="jc hi"/>看起来和这篇博文中实现的app一模一样。</li></ol></div></div>    
</body>
</html>