<html>
<head>
<title>Matching Genetic Sequences Through the BLAST and Karp-Rabin Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过BLAST和Karp-Rabin算法匹配遗传序列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/matching-genetic-sequences-through-the-blast-and-karp-rabin-algorithm-ffebc810a9d0?source=collection_archive---------14-----------------------#2021-02-22">https://medium.com/analytics-vidhya/matching-genetic-sequences-through-the-blast-and-karp-rabin-algorithm-ffebc810a9d0?source=collection_archive---------14-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/63bb5667160cef93ee09e41183fc40b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*riYL2jIpEpM8UsbZ.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">鸣谢:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.newscientist.com%2Fterm%2Fdna%2F&amp;psig=AOvVaw0S9mfrvxY30CvdMwS-05kX&amp;ust=1613958825683000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCKjIjKfv-e4CFQAAAAAdAAAAABAJ" rel="noopener ugc nofollow" target="_blank">新科学家</a></figcaption></figure><p id="6882" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:我将在这篇文章中大量引用大O符号；它本质上是讨论代码时间复杂度的形式化符号。如果你不确定什么是大O符号，我强烈建议在这里查看</em> <a class="ae iu" href="https://www.freecodecamp.org/news/big-o-notation-why-it-matters-and-why-it-doesnt-1674cfa8a23c/" rel="noopener ugc nofollow" target="_blank"> <em class="jt">链接</em> </a> <em class="jt">。</em></p><p id="9d1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">670亿英里。这是人体内所有未折叠的DNA片段的长度。太不可思议了，如此简单的东西，<strong class="ix hj">仅仅四个含氮碱基</strong>，就能创造出如此复杂而精密的有机体。</p><p id="39de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这670亿英里中，人类基因组中大约有30亿个这样的DNA碱基对，组成了最终控制我们的思想、行为和情绪等的遗传密码。</p><p id="cf43" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在理解了人体的复杂性，也就理解了为什么科学家和数学家在努力理解这种遗传密码；有太多的信息需要筛选。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/4352f6143a8e411cf1235625a057b001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LRwfy5t6f_TI0ykN.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在一个典型的海滩上，碱基对比细沙还多！信用:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.npr.org%2Fsections%2Fkrulwich%2F2012%2F09%2F17%2F161096233%2Fwhich-is-greater-the-number-of-sand-grains-on-earth-or-stars-in-the-sky&amp;psig=AOvVaw104Tgdoj1J3vZ0q_Yi2UxL&amp;ust=1614034870452000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCPiIqc6K_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank"> NPR </a></figcaption></figure><p id="e602" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些人面临的一个特殊问题是将特定的核苷酸串映射到整个人类基因组，这仅仅是因为潜在的时间复杂性。使用传统方法，计算机可能需要数年时间来筛选基因组，以找到一个特定的部分，因为它以二次时间或O(n)运行。新的解决方案旨在通过在线性时间或O(n)中筛选基因组来解决这个问题。</p><p id="5f03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">目前，有两种不同的解决方案大大降低了筛选基因组的时间复杂度:使用Karp-Rabin算法和散列的<strong class="ix hj">线性时间精确字符串匹配</strong>(将字符串精确匹配到基因组的一部分)和使用BLAST算法的<strong class="ix hj">线性时间不精确字符串匹配</strong>(允许一些核苷酸差异)。</p><p id="392f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，我们将回顾这些不同的算法，并具体讨论这些算法如何降低传统数据库搜索的时间复杂度。</p><h1 id="c6f4" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线性时间精确字符串匹配</h1><p id="03b1" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">这一部分将致力于解决<strong class="ix hj">在数十亿个核苷酸组中将精确的核苷酸序列与人类基因组匹配的问题。</strong>这不同于不精确的字符串匹配，在不精确的字符串匹配中，我们可以允许一些不精确的改变，因为我们的目标是从进化的角度来解决它(稍后将详细介绍这个特定的主题)。</p><h2 id="2c35" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">基本解</h2><p id="dbb1" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">我们的目标是在长度为<em class="jt"> n </em>的文本<em class="jt"> T </em>中找到长度为<em class="jt"> m </em>的模式<em class="jt"> P </em>。最简单的解决方案就是<strong class="ix hj">将模式滑动到文本中，并找到我们正在寻找的序列</strong>。如下图所示，我们只需在文本<em class="jt"> T </em>中缓慢滚动模式通过每个可能的长度<em class="jt"> m </em>的连续组合，直到我们找到想要的组合。</p><p id="f591" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从第一个数字开始，我们将找到一个长度为<em class="jt"> m </em>的模式，并继续这个过程，直到我们到达第(<em class="jt"> n-m </em> +1)个数字。然而，这种方法提供了一种非线性的解决方案，这种解决方案会成倍地恶化。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lq"><img src="../Images/fbd84aec35b90a8f95878ca4cd55ac18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*au7Dds9W3f7-I2QRj9XCxg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">Karp-Rabin基本解的算法解释示例。马诺里斯·凯利斯</figcaption></figure><h2 id="fc06" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">模运算</h2><p id="812f" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">随着模式长度<em class="jt"> n </em>随时间增加，y的计算可能导致不期望的时间复杂度。这可以通过<strong class="ix hj">数学技巧在线性时间而非二次时间内计算<em class="jt"> y </em>来解决。</strong></p><p id="b421" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你仔细观察，你会发现下一个数字只不过是前一个数字移动了1加上另一个数字</p><p id="7e41" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以使用三个运算使用先前的<em class="jt">y</em>T34】计算当前的<em class="jt"> y </em>(在这个实例中将使用23590到35902的例子):</p><ul class=""><li id="6070" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">使用模数运算符删除最左边的数字(例如，23590 mod 10000 = 3590 →可以表示为<em class="jt"> y </em> mod 10^ <em class="jt"> m </em>)</li><li id="83a1" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">将所有数字向左移动(例如3590将变成35900 →可以表示为<em class="jt"> y </em> x 10)</li><li id="ef44" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">将新数字加到右边(例如35900 + 2 = 35902 →可以表示为<em class="jt"> y </em> + <em class="jt"> n </em>，其中<em class="jt"> n </em>是序列中的下一个数字)。</li></ul><h2 id="4d2d" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">哈希算法——卡普-拉宾算法</h2><p id="a6f6" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">当注意到我们要比较的序列通常比五个长得多时，第二个问题就出现了。当比较长度以百万计的字符串时，这种形式的比较将被证明是低效的。</p><p id="6194" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了确保最有效的比较，我们可以使用<strong class="ix hj">散列</strong>，这是一种将长度为<em class="jt"> m </em>的字符串转换为更理想长度的方法(例如，将长度为一百万的字符串转换为长度小于十的字符串)。为了使用Karp-Rabin算法执行这种散列，我们对<em class="jt"> p </em>取模进行所有的计算，其中<em class="jt"> p </em>是一个选定的常数，该常数足够小，使得能够在恒定时间内进行比较。</p><p id="2ba8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">注意:为了使散列有效，需要将文本转换成数字格式。这可以很容易地用核苷酸来完成，通过分配腺嘌呤0，胞嘧啶1，鸟嘌呤2和胸腺嘧啶3。</em></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/31f0851f07e1baebe6d549bde0e77902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCntWRL8U5okbdnoPIc-9w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">哈希的例子。对于这些问题，我们将使用模运算符。鸣谢:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHash_function&amp;psig=AOvVaw3xpOPtAPrETr2-C20JC7j8&amp;ust=1614035316173000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCPiX_qqM_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="ceb6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，假设我们使我们的<em class="jt"> p </em> =13，我们想要散列数字14152。由于14152 mod 13等于8(由于模数运算符只计算两个数相除的余数)，因此我们有效地将长度为5的字符串转换为长度为1的字符串。</p><p id="a921" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种形式的散列是非常强大的，因为我们将要比较的序列通常会有<strong class="ix hj">数千甚至数百万个核苷酸长</strong>。通过使用散列法，我们能够将这些序列减少到仅仅一到两位数的长度，而不是100。</p><p id="e824" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">模数<em class="jt"> p </em>有效地<strong class="ix hj">将任何序列限制在范围【0…p】，</strong>内，而不管特定的比对是什么。与以前的方法相比，这些比较可以在更线性的时间内进行。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mf"><img src="../Images/1f9578757c5886136101d955b8cf0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D7SJN9d2P49dJSpTlCc2CQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">寻找有效匹配的模运算符示例。26模11是4。信用:<a class="ae iu" href="https://www.javatpoint.com/daa-rabin-karp-algorithm" rel="noopener ugc nofollow" target="_blank">Java point</a></figcaption></figure><p id="d242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上图所示，如果模式的哈希等于算法正在检查的特定字符串的哈希，则它们被认为彼此相等。这大大减少了比较时间，因为我们仍然在进行比较，只是数字的长度要小得多。</p><p id="ff7e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有两个主要特征有助于散列不同的序列以使它们的长度更小:</p><ul class=""><li id="f630" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated"><strong class="ix hj">再现性:</strong>如果两个数字相同，那么它们的映射散列将另外保持相同。</li><li id="2d37" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><strong class="ix hj">均匀输出分布:</strong>不管特定的输入分布如何，输出分布必须保持均匀，这意味着散列中的每个数字被选中的概率相等。</li></ul><p id="702a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数学运算的不变性允许再现性方面被覆盖；此外，模操作符有效地循环通过数的集合的方式，确保了相等的概率分布，满足了均匀的输出分布。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/26f7e122c676008a262f83a353653cb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ouXYipqE4e9F5XQN72TmLA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">虚假命中的示例(不等于查询字符串)。信用:<a class="ae iu" href="https://www.javatpoint.com/daa-rabin-karp-algorithm" rel="noopener ugc nofollow" target="_blank">Java point</a></figcaption></figure><p id="858d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">乱真命中</strong>，与模式形成匹配的命中，即使它们是不同的，在散列函数时必然会发生。例如，14 mod 13和27 mod 13产生相同的1的散列，即使它们是不同的值；这会导致未来的许多问题。</p><p id="45f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上图中，您可以认出这是我们的26位模式，而我们检查的15位字符串产生了相同的散列值4，尽管它们是不同的值。这造成了许多不必要的假阳性，会破坏我们算法的有效性。</p><p id="c25a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了避免这个问题，只需<strong class="ix hj">用未散列查询</strong>检查原始未散列数。尽管我们正在以较慢的时间复杂度进行比较，但我们是在比以前更小的一组数字上进行的。</p><p id="46c9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这种改变的Karp-Rabin算法提供了预期的线性运行时间，因为考虑到值<em class="jt"> p </em>被仔细选择，假命中的概率在整个序列中保持很小。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/cf3acf76c5b958ed73d96f95a7a4053a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OAaLGjl-Vv4j9GuhcjA5LA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">时间复杂度最小化的最终Karp-Rabin算法。</figcaption></figure><h2 id="5604" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">受过训练的字符串匹配</h2><p id="82d8" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">与这个最终确定的Karp-Rabin算法一起，<strong class="ix hj">训练的字符串匹配</strong>可以用于将时间复杂度降低到O( <em class="jt"> n </em>)时间。</p><p id="fb17" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如前所述，最初的解决方案只是简单地将长度为<em class="jt"> m </em>的字符串与数据集内的字符串进行逐个字符的比较，以找出数据中存在哪些模式，然后以低效的方式不断循环这些字符串。这产生了一种算法，其运行的时间复杂度为<strong class="ix hj"> <em class="jt"> O(m * n) </em>时间</strong>，其中<em class="jt"> n </em>是模式的长度。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/c5be439dce4c38c942659a951b3e94c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*L0MVdOfQ2t-I8O9Iigy5wQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">数据库搜索中的朴素字符串匹配算法。</figcaption></figure><p id="f1d4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果已经发现不匹配，可以通过简单地停止比较来对该算法进行轻微的改变；然而，在最坏的情况下，如果我们比较的字符串匹配整个序列，这仍然导致缓慢的O( <em class="jt"> m * n) </em>时间复杂度。</p><p id="7c42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用与上述模运算类似的思想，我们可以<strong class="ix hj">从上一次字符串比较中获取冗余，并在当前字符串比较中使用它</strong>。利用这一点，我们可以对目标序列进行比以前大得多的移动。这导致了所需比较次数的减少，从而导致线性运行时间为O( <em class="jt"> n </em>)。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/00741e1517b44d7f309cb20f6d793e46.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*BL9tMH1HP_EtbUZ0jvLnEA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">受过训练的字符串匹配算法。</figcaption></figure><p id="a7b2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上图所示，使用目标数据库中的字符串对模式进行正确分类时，可以跳过三个空格，因为我们知道接下来的三个字符串是不匹配的。我们可以把第二、第三和第四个字母分别归类为‘b’、‘c’、‘d’，证明这些字母都不能等于‘a’，导致不匹配。</p><p id="b4f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">受过训练的字符串匹配可以与Karp-Rabin算法</strong>一起使用，以产生有效的数据库查询搜索，并导致快速计算，从而导致线性时间复杂度。</p><h1 id="5c09" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">线性时间不精确字符串匹配</h1><p id="f7be" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">在不精确的字符串匹配中，我们将主要关注寻找仅相差几个核苷酸的相似基因序列的问题。这对于在基因组中寻找<strong class="ix hj">进化序列</strong>特别有用。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/0350a3bfc7f6973c2c90948ea133d345.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BL58Bwfe0rEBBp30"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">进化过程的三种突变。学分:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww2.le.ac.uk%2Fprojects%2Fvgec%2Fschoolsandcolleges%2Ftopics%2Fgenetics-mutation-and-cancer&amp;psig=AOvVaw11MsgLB-Amb83an_mjnXiq&amp;ust=1614038188749000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCPie9v2W_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">莱斯特大学</a></figcaption></figure><p id="f688" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当经历进化过程时，无论是通过<strong class="ix hj">插入</strong>(添加一个核苷酸)<strong class="ix hj">删除</strong>(删除一个核苷酸)，还是<strong class="ix hj">替换</strong>(将一个核苷酸字母改为其他三个中的一个)，人类基因组中的一些核苷酸都会发生变化，这是有道理的。</p><p id="3785" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BLAST算法解释了这些过程，因为它在整个人类基因组中找到了相对不精确的字符串。</p><h2 id="2a69" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">一些考虑</h2><p id="5768" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">BLAST算法利用了其将检查的大多数目标序列将与目标序列<strong class="ix hj">不相关的特殊性质。</strong></p><p id="2ee6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，如果您正在寻找长度为1，000的序列，并且您拒绝某些不到95%相同的匹配，那么您可以简单地跳过不包含连续50个核苷酸的序列，因为您知道这些将是整个字符串的错配。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es ml"><img src="../Images/66e1aa81307df8fe08a2d0fa9e7808dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/0*IJQz82QtdtwVcngv.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">鸽子洞原理的可视化表示。信用:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmedium.com%2Fcantors-paradise%2Fthe-pigeonhole-principle-e4c637940619&amp;psig=AOvVaw2_fBSS5j2qh8xEQugWIVz0&amp;ust=1614038311538000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCJCPhr-X_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">中等</a></figcaption></figure><p id="ba12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个极其重要的属性，因为它允许我们跳过某些与目标模式完全无关的序列。这与众所周知的<strong class="ix hj">鸽子洞原理</strong>类似，该原理指出，如果有<em class="jt"> n-1 </em>只鸽子适合进入<em class="jt"> n </em>个洞，则至少有一个洞没有鸽子。鸽子洞原理是数学中一个令人惊叹的应用，所以如果你有兴趣阅读更多，请查看这个<a class="ae iu" href="https://www.geeksforgeeks.org/discrete-mathematics-the-pigeonhole-principle/" rel="noopener ugc nofollow" target="_blank">链接</a>。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/3e613b07369f0ebff7c1de5f854e9614.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cFZO0yrn-CadJpAoWopcpg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">描述不同物种在进化过程中哪些区域是保守的。鸣谢:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FConserved_sequence&amp;psig=AOvVaw2k7SsgIY84dsRtKya29GEr&amp;ust=1614038401673000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCJi-raGh_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">维基百科</a></figcaption></figure><p id="98a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">BLAST算法考虑到主要在功能DNA的区域中会有相似性(或<strong class="ix hj">保守区域</strong>)的延伸，因此它不需要检查整个字符串进行比较，而只需要检查功能DNA的簇。保守区域是在进化过程中保持不变(没有突变)的区域。</p><p id="851a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与此同时，BLAST算法对数据进行预处理(使用哈希和本文稍后讨论的其他技术),以便在O( <em class="jt"> n </em>)时间内轻松找到长度为<em class="jt"> n </em>的模式。</p><h2 id="789f" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">BLAST算法过程</h2><p id="32b1" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">BLAST算法将长度为<em class="jt"> n </em>的查询/模式分割成长度为W的重叠单词，称为<strong class="ix hj"> W-mers </strong>。例如，如果查询词(例如ATCGCGATA)的长度为<em class="jt"> n=9 </em>并且W=3，那么我们将有三个三聚体用于查询(ATC、GCG和ATA)。</p><p id="dd91" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将查询拆分成这些词之后，算法会为每个词找到一个相似词的邻域。因此，举例来说，如果有一个ACG的三聚体，那么这些单词中的一些将包括ATG、ACA和TCG，因为它们与原始的W-mer几乎没有什么不同。我们不断修改这些序列，直到它们低于预定义的阈值<em class="jt"> T. </em></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/4b34a4d1e58e5c07ed6b0f9e3c4855ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ALuzQLRP_-CGOx8H.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">将原始序列放入哈希表的示例。学分:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=http%3A%2F%2Fwww.cs.rice.edu%2F~ogilvie%2Fcomp571%2F2018%2F09%2F04%2Fblast-fasta.html&amp;psig=AOvVaw1CjuAyAKx-5VXr2tnH_CoY&amp;ust=1614041207893000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCKCBipmi_O4CFQAAAAAdAAAAABAj" rel="noopener ugc nofollow" target="_blank">莱斯大学</a></figcaption></figure><p id="811a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些子串随后被存储在一个<strong class="ix hj">散列</strong> <strong class="ix hj">表</strong>或一个<strong class="ix hj"> W-mer数据库</strong>中，其中存储了所有的邻近单词和原始单词。这允许邻居与原始模式大致相似。这些不同的字符串中的每一个都有不同的散列(使用上面显示的散列方法)，通常称为<strong class="ix hj">种子</strong>。这些散列使用与Karp-Rabin算法相似的过程。</p><p id="4641" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了找到比对，我们只需使用我们的集合扩展种子，直到我们的<strong class="ix hj">比对分数</strong>(一个衡量结果种子与数据库字符串相似程度的分数)低于某个阈值x。我们将进一步讨论它最初是如何精确计算比对分数的。注意，X和T是不同的，因为X表示整个原始模式和新发现的种子集合之间的相似性，而T只是检查原始W-mer和相邻W-mer之间的相似性。</p><p id="2ebb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">w、T和X是<strong class="ix hj">超参数</strong>，这意味着它们可以被相应地调整以更好地适应模型。例如，增加W可以导致更少的虚假命中，但是由于比以前更大的哈希表和更少的实际命中，它也可以导致更大的空间复杂度。<strong class="ix hj">在增加或减少它们之前，确保认识到其中每一个的权衡。</strong></p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/2da646c5d13811ef762d5f7758e856c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TgEC6anKeD7D8lONXcV2fw.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">BLAST算法的工作流程。</figcaption></figure><h2 id="cb23" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">BLAST算法的扩展</h2><p id="28ef" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">虽然BLAST算法是计算生物学领域中最著名和引用最多的算法之一，但是可以进行一些修改来增加模型的复杂性并减少虚假命中的数量。</p><p id="c078" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">想要减少查询规模的科学家经常使用过滤。如果查询具有<strong class="ix hj">低复杂性区域</strong>，或相同核苷酸的区域(例如GC、A等的重复序列)。)，并且数据库具有长段的相同核苷酸组，那么将会有许多不必要的命中，这会搞乱算法。因此，通过简单地过滤掉这些低复杂度区域，我们可以减少这些命中，并且只生成有意义的命中。</p><p id="74e6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">另一方面，为了产生更多的<strong class="ix hj">命中</strong>(不是虚假命中)，我们可以使用<strong class="ix hj">两次命中爆炸</strong>，其中我们<strong class="ix hj">散列两个小W-mer，而不是简单地散列一个长W-mer。</strong>通过将W-mer一分为二，我们可以找到更小的相似区域，并获得更高的灵敏度。此外，由于W随后减小，因此寄生命中减少。</p><p id="3000" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，<strong class="ix hj">梳</strong>在找出原始数据库字符串中有用的核苷酸部分时特别有用。梳子的工作原理是<strong class="ix hj">去除我们不关心的核苷酸，只关注我们关心的核苷酸</strong>。例如，我们可以考虑忽略三联体中的第三个核苷酸(因为它们通常对氨基酸的表达没有影响)。我们可以将它表示为110110…的按位序列，其中1表示核苷酸，而0隐藏它。</p><p id="11ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些梳也可以随机决定，其中每个第<em class="jt"> n- </em>个核苷酸将具有由概率矩阵确定的被隐藏的概率。这种方法通常被称为<strong class="ix hj">随机投影</strong>，它大大增加了在数据库中找到匹配的概率。</p><h1 id="7b37" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">序列比对概率</h1><p id="a286" class="pw-post-body-paragraph iv iw hi ix b iy kx ja jb jc ky je jf jg kz ji jj jk la jm jn jo lb jq jr js hb bi translated">BLAST算法使用<strong class="ix hj">评分矩阵</strong>来确定种子集合是否与目标图案或数据库中呈现的图案大致相似。这允许我们基于事实矩阵来评估比对中的某些错配。</p><p id="3853" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">评分矩阵以两个假设为中心，这两个假设试图将两个序列显示为<strong class="ix hj">同源</strong>，这意味着它们因其相似的核苷酸而拥有共同的祖先:</p><ul class=""><li id="7c01" class="lr ls hi ix b iy iz jc jd jg lt jk lu jo lv js lw lx ly lz bi translated">排列是偶然的，序列是不相关的。</li><li id="c750" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">这种结盟是由于一个共同的祖先，他们是有血缘关系的。</li></ul><p id="7461" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了构建特定的评分矩阵，我们将查看这两种假设的概率之间的比率。使用两种主要的评分矩阵:核苷酸评分矩阵和氨基酸评分矩阵。虽然氨基酸评分矩阵通常更多地用于BLAST算法，但是理解核苷酸评分矩阵将给予我们计算分数背后必要的一般直觉。</p><h2 id="7164" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">了解核苷酸评分矩阵</h2><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/7ca9883f4cdeba7f70351652f30a6eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1198/format:webp/1*e6Vv9e2_XoHomk-mSmLqhg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">核苷酸评分矩阵示例。</figcaption></figure><p id="60f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所示，该核苷酸评分矩阵主要基于不同核苷酸之间的相互作用和错配发生的可能性来定义。例如,+1表示在整个进化过程中保持不变的核苷酸，这意味着它们不会改变。</p><p id="d114" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还表明，As和ts之间的转换比As和Gs之间的转换具有更大的权重；Ts、Cs和Gs也有类似的情况。为什么会这样呢？这主要是由于某种核苷酸碱基突变成另一种碱基的进化可能性。</p><p id="91c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">A突变成G是有道理的，因为它们属于同一个嘌呤家族，而不是属于T2嘧啶家族的T或C。在家族间变异比在家族间杂交更容易。因此，它的负数比其他的要小。</p><p id="b003" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，负数越大，表示人体内发生当前突变的<strong class="ix hj">可能性越小。</strong>由于从A到G的突变比从A到T的突变更常见，所以它的负数会比后者低。</p><h2 id="dd75" class="lc ka hi bd kb ld le lf kf lg lh li kj jg lj lk kn jk ll lm kr jo ln lo kv lp bi translated">氨基酸评分矩阵</h2><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/00cbcaa81576015243b86fc644d0a3fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/0*h0l8LUvGWrY8L-S4.jpg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">将三核苷酸对转换成氨基酸的通用表格。信用:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.nature.com%2Fscitable%2Ftopicpage%2Fnucleic-acids-to-amino-acids-dna-specifies-935&amp;psig=AOvVaw2TQu7Axj4G8SBLYxGCJzIv&amp;ust=1614041446519000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCJDgj4-j_O4CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">性质</a></figcaption></figure><p id="0f1c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">氨基酸相互作用/突变概率比核苷酸相互作用更难量化；因此，我们需要实现一种不同的方法，而不是使用简单的直觉，如核苷酸替换表。请记住，我们将主要使用<strong class="ix hj">氨基酸评分矩阵进行BLAST算法，</strong>因此，我们拥有一个准确的索引非常重要。</p><p id="cc48" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">通过使用数学运算和使用上面定义的两个假设理解概率方面，我们可以通过使用已知概率计算分数来确定这个替换矩阵。</p><p id="26fa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您对这背后的数学推理感兴趣，我强烈建议您查看这个<a class="ae iu" href="https://bio.libretexts.org/Bookshelves/Computational_Biology/Book%3A_Computational_Biology_-_Genomes_Networks_and_Evolution_(Kellis_et_al.)/03%3A_Rapid_Sequence_Alignment_and_Database_Search/3.07%3A_Probabilistic_Foundations_of_Sequence_Alignment" rel="noopener ugc nofollow" target="_blank">链接</a>，但是出于本文的目的，我将把这些计算留在这里。不同氨基酸对<em class="jt"> a </em>和<em class="jt"> b </em>的最终置换矩阵得分可由下式给出:</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/83c3aad3eb951c0799a5a76e9b168d6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*178kasEvi0uPlXDDES1CSA.png"/></div></figure><p id="f4f7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分子讨论了<strong class="ix hj">某些进化过程将a变成b </strong>的可能性，而分母讨论了氨基酸<em class="jt"> a </em>和氨基酸<em class="jt"> b </em>在基因组内部的<strong class="ix hj">可能性。</strong></p><p id="99e3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用上面给出的置换得分公式，我们可以制作氨基酸的置换矩阵，允许更精确的氨基酸得分矩阵，类似于所示的核苷酸。</p><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ms"><img src="../Images/fa1b873f1c18872370a20b715a851e29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LdXz7cklzbzSBKqX42mFoQ.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">一个氨基酸替代矩阵的例子(BLOSUM62矩阵)。</figcaption></figure><h1 id="d1f9" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">应用程序</h1><figure class="jv jw jx jy fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mt"><img src="../Images/d9be9df8eb36f372d236f66919fb9a45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7YJ59opTL10TEJwF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">计算机在理解DNA方面的应用是巨大的！信用:<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.aiche.org%2Fchenected%2F2014%2F10%2Fimportant-breakthrough-dna-computing&amp;psig=AOvVaw0yleqF9Xtpd5txzLcKDIok&amp;ust=1614026871417000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCKD9quvs--4CFQAAAAAdAAAAABAJ" rel="noopener ugc nofollow" target="_blank">爱车</a></figcaption></figure><p id="28ae" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">比对基因序列在医疗保健领域有相当大的应用。这不仅可以用来理解人类和其他物种的进化过程，还可以用来<strong class="ix hj">将特定的已知DNA片段与人类基因组内部发现的片段进行匹配。</strong></p><p id="0be1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">了解这种比对可以为更多地了解人类基因组铺平道路，并允许更个性化的策略以及对某些突变的潜在治疗。</p><p id="e8f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">序列比对及其计算生物学的支配性领域是一个快速发展的领域，我很高兴看到BLAST算法和Karp-Rabin算法如何被定制以进一步降低时间复杂性。请在下面的评论中告诉我你的想法！</p><h1 id="0865" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="25da" class="lr ls hi ix b iy kx jc ky jg mu jk mv jo mw js lw lx ly lz bi translated">序列比对可以通过分别使用Karp-Rabin算法和BLAST算法的精确或不精确的字符串匹配来进行。</li><li id="69a3" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">Karp-Rabin算法旨在使用熟练的模和算术运算以及散列函数来降低将精确的核苷酸序列与人类基因组匹配的时间复杂度。</li><li id="1c47" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">BLAST算法将查询拆分为称为W-mer的重叠单词，根据该W-mer构建相似的单词，并使用相似的哈希函数来降低匹配更不精确的序列和模式的时间复杂度，以理解进化过程。</li><li id="daf3" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">BLAST算法有多种扩展，如过滤、两次BLAST和组合，这些扩展修复了BLAST算法实现中的小生境问题。</li><li id="60c8" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated">BLAST算法使用评分矩阵来匹配两个氨基酸/核苷酸的比对，以反映两个序列是否同源(它们是否有共同的祖先)。</li></ul><h1 id="7418" class="jz ka hi bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">额外资源</h1><ul class=""><li id="4d47" class="lr ls hi ix b iy kx jc ky jg mu jk mv jo mw js lw lx ly lz bi translated"><a class="ae iu" href="https://ocw.mit.edu/ans7870/6/6.047/f15/MIT6_047F15_Compiled.pdf" rel="noopener ugc nofollow" target="_blank">计算生物学:基因组、网络、进化麻省理工学院课程6.047/6.878教材</a>(为了更好地全面理解计算生物学这个新兴领域)</li><li id="3ebb" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><a class="ae iu" href="https://www.geeksforgeeks.org/discrete-mathematics-the-pigeonhole-principle/" rel="noopener ugc nofollow" target="_blank">鸽笼原理</a>(理解BLAST算法优化背后的直觉)</li><li id="193a" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><a class="ae iu" href="https://bio.libretexts.org/Bookshelves/Computational_Biology/Book%3A_Computational_Biology_-_Genomes_Networks_and_Evolution_(Kellis_et_al.)/03%3A_Rapid_Sequence_Alignment_and_Database_Search/3.07%3A_Probabilistic_Foundations_of_Sequence_Alignment" rel="noopener ugc nofollow" target="_blank">序列比对的概率基础</a>(了解BLAST算法背后的置换矩阵)</li><li id="c3aa" class="lr ls hi ix b iy ma jc mb jg mc jk md jo me js lw lx ly lz bi translated"><a class="ae iu" href="https://ieeexplore.ieee.org/abstract/document/859065/" rel="noopener ugc nofollow" target="_blank">BLAST的高效平方根算法</a>(BLAST算法背后的原创研究论文)</li></ul></div><div class="ab cl mx my gp mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="hb hc hd he hf"><p id="dc62" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">嗨！我今年16岁，目前对机器学习和生物技术领域感兴趣。如果你有兴趣看到更多我的内容和我发布的内容，可以考虑订阅我的</em> <a class="ae iu" href="https://forms.gle/gdCammxd628UTQ9j9" rel="noopener ugc nofollow" target="_blank"> <em class="jt">简讯</em> </a> <em class="jt">！查看我的一月简讯</em> <a class="ae iu" href="https://preview.mailerlite.com/t9c2v5" rel="noopener ugc nofollow" target="_blank"> <em class="jt">这里</em> </a> <em class="jt">！还有，看看我的</em><a class="ae iu" href="https://www.linkedin.com/in/karthikmittal/" rel="noopener ugc nofollow" target="_blank"><em class="jt">LinkedIn</em></a><em class="jt">和</em><a class="ae iu" href="https://github.com/karthikm15" rel="noopener ugc nofollow" target="_blank"><em class="jt">Github</em></a><em class="jt">页面。如果你对个人心态感兴趣，或者只是一般的东西，使用我的</em> <a class="ae iu" href="https://calendly.com/karthikmittal306" rel="noopener ugc nofollow" target="_blank"> <em class="jt">日历</em> </a> <em class="jt">注册聊天。</em></p></div></div>    
</body>
</html>