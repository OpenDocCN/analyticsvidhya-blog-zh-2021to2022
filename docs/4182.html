<html>
<head>
<title>Text Processing Tools I Wish I Knew Earlier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">文本处理工具我希望我早点知道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/text-processing-tools-i-wish-i-knew-earlier-a6960e16a9c9?source=collection_archive---------6-----------------------#2021-09-06">https://medium.com/analytics-vidhya/text-processing-tools-i-wish-i-knew-earlier-a6960e16a9c9?source=collection_archive---------6-----------------------#2021-09-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/adca74af89e8eb74303d9d0ea0623251.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QjbKA1PITCHtll_gbEDMaA.jpeg"/></div></div></figure><h1 id="8cd2" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">介绍</h1><p id="aa16" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">在我从事数据科学的过程中，从学校工作到实习再到全职工作，自然语言处理(NLP)一直是我感兴趣的领域。阅读像《变形金刚》这样最新最伟大的NLP技术，一直都是耐人寻味，引人入胜的。然而，有一件事仍然是NLP的基石，那就是文本处理。</p><p id="40fe" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">实际上，我已经写了一篇中型文章，概述了一些常见的过程，如词汇化和词干化，以及停用词和标点符号的删除。如果你想了解更多，这里有一个我正在谈论的文章的链接。尽管有无数的其他文章已经讨论过了。这就引出了我写这篇文章的原因。我想分享两个文本处理函数，我觉得它们在我的数据科学之旅中很有用，而且我没有找到太多关于它们的文献。</p><p id="7d69" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">它们是<strong class="jp hi">标签处理</strong>和<strong class="jp hi">乱码检测</strong>。</p></div><div class="ab cl kr ks go kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ha hb hc hd he"><h1 id="a1dd" class="ip iq hh bd ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji lc jk jl jm bi translated">标签处理</h1><p id="8204" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">当我在一家专注于影响者的MarTech初创公司工作时，我必须处理大量来自社交媒体的数据。这意味着与新闻文章或研究论文相比，文本数据将会更加混乱，结构化程度更低。鉴于大多数社交媒体文本都是个性化的，它们也与亚马逊评论等文本略有不同。有了社交媒体数据，会有更多的表情符号、提及、俚语和标签。</p><p id="5c74" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">标签无疑是文本中最有问题的部分之一。移除表情符号和提及，或者替换俚语会很容易。但是，即使移除了hashtag符号，它仍然会留下字符组合，中间没有空格。因为大多数文本处理通过分隔空格来标记句子中的单词</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2a53" class="lm iq hh li b fi ln lo l lp lq">"This is a sentence" -&gt; ["This", "is", "a" "sentence"]</span></pre><p id="774b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">简单地删除hashtag符号会导致字符组合本身被认为是一个标记:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="7f24" class="lm iq hh li b fi ln lo l lp lq">"foodislife" -&gt; ["foodislife"]<br/><br/># instead of<br/><br/>"foodislife" -&gt; ["food", "is", "life"]</span></pre><p id="1b03" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">因此，hashtag处理函数能够将这个组合拆分成单个的单词。</p><p id="f7ee" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">以下是完整的代码:</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><h1 id="ea36" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">它是如何工作的</h1><p id="d55f" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">基于语料库，我们生成单词计数的字典。所以我们从字面上统计每个词在语料库中的出现次数。由此，我们通过字母的组合逐个字符地迭代，并且在每次迭代中，我们使用字典计算它是一个单词的概率。</p><p id="1b08" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">基于字母组合的窗口成为单词的可能性以及窗口的起始索引成为单词的良好起点的概率来计算概率。</p><p id="4bfc" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">通过这种方法，在字母组合中的每一个可能的拆分处，我们将得到该拆分形成一个单词的概率。然后，该算法将跟踪概率最高的索引，并在这些点上拆分字母组合以形成一个句子</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="e497" class="lm iq hh li b fi ln lo l lp lq">'ilovefood'</span><span id="f82e" class="lm iq hh li b fi lt lo l lp lq"># iteration 1:<br/>'i'<br/>## at 'i', since it's such a common word, it would have a high probability<br/>## hence, we consider it a word</span><span id="54a4" class="lm iq hh li b fi lt lo l lp lq"># iteration 2:<br/>'l'<br/>## 'l' is not common by itself and hence would have a low probability of it being a word</span><span id="6b20" class="lm iq hh li b fi lt lo l lp lq"># iteration 3:<br/>'lo'<br/>## 'lo' is also not common.</span><span id="5de2" class="lm iq hh li b fi lt lo l lp lq"># and so on.. until we split at <br/>'i', 'love', 'food'</span></pre><p id="f90e" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">注意，<code class="du lu lv lw li b">word_dict.json</code>文件来自上面的<code class="du lu lv lw li b">generate_word_dictionary</code>函数。我只是将字典导出到一个. json文件中。为了方便起见，这里有一个将字典导出到. json文件的函数:</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="80de" class="lm iq hh li b fi ln lo l lp lq">import json</span><span id="c49b" class="lm iq hh li b fi lt lo l lp lq">def export_dict_to_json(dictionary: dict, file_name: str):<br/>		with open(file_name, 'w') as file:<br/>				json.dump(dictionary, file)</span></pre><h1 id="c6bc" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">胡言乱语检测</h1><p id="1c04" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这并不像hashtag函数那样有用，但是我真的觉得这很有趣，而且在需要的时候非常有用。我发现这个函数在执行数据探索之前特别有用。这是因为数据集中的一些句子可能有非常长的乱码。这最终扭曲了句子和数据集的度量，并使真正理解数据集变得困难。</p><p id="f160" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">在我解释算法如何工作之前，让我展示完整的代码:</p><figure class="ld le lf lg fd ii"><div class="bz dy l di"><div class="lr ls l"/></div></figure><p id="8245" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">乱码检测功能的工作方式类似于hashtag处理功能。从某种意义上说，他们都利用了概率。然而，乱码检测函数得到的不是单词的概率，而是一个字母跟随另一个字母的概率。比如‘a’在‘b’之后的概率。或者字母“z”在“k”后面的概率。</p><h1 id="30f7" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">它是如何工作的</h1><p id="fa83" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">从语料库中，<code class="du lu lv lw li b">generate_gibberish_model</code>将读取每个句子，并计算两个字母之间的出现次数。</p><pre class="ld le lf lg fd lh li lj lk aw ll bi"><span id="2920" class="lm iq hh li b fi ln lo l lp lq">'this is not gibberish'</span><span id="adc2" class="lm iq hh li b fi lt lo l lp lq">'t' -&gt; 'h'<br/>'h' -&gt; 'i'<br/>'i' -&gt; 's'<br/>'s' -&gt; ' '<br/>' ' -&gt; 'i'<br/>...<br/>'b' -&gt; 'e'<br/>'e' -&gt; 'r'<br/>'r' -&gt; 'i'<br/>'i' -&gt; 's'<br/>'s' -&gt; 'h'</span></pre><p id="ce11" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这将生成两个字母之间的出现次数。这个函数的字典输出将在函数中使用，以计算一个字符串是否是乱码。其中较高的概率表示字符串是可能的，而较低的概率表示字符的组合没有意义并且是乱码。</p><p id="548b" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">方法是遍历一个字符串，检索两个字母中每一个出现的概率，然后将所有的概率相加得到一个概率值。如代码所示，使用对数概率而不是直接概率，以避免长文本中可能出现的数字下溢问题。</p><p id="997d" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">这个方法将返回一个概率值，不管这个令牌是不是乱码。因此，需要声明一个阈值来确定在什么概率值下我们可以确信该令牌是乱码。在上面的代码中，我使用了<code class="du lu lv lw li b">0.0188</code>。任何值都可以使用，但是让我解释一下我是如何得到这个值的。</p><p id="ebd0" class="pw-post-body-paragraph jn jo hh jp b jq kl js jt ju km jw jx jy kn ka kb kc ko ke kf kg kp ki kj kk ha bi translated">我有一些好的文本和乱码文本的例子。然后，我对所有好的和乱码的文本使用了乱码检测功能，发现了一个介于被视为非乱码的最小阈值和被视为乱码的最大阈值之间的值。而对我来说，这个值就是<code class="du lu lv lw li b">0.0188</code>。</p><h1 id="d70d" class="ip iq hh bd ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm bi translated">结论</h1><p id="7458" class="pw-post-body-paragraph jn jo hh jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ha bi translated">这些函数的逻辑非常简单，但是在处理文本时会产生很好的性能。我希望这些功能能够像帮助我一样帮助别人，并帮助我成为一名更好的数据科学家。如果你们中的任何人遇到了任何有趣的文本处理方法/功能/页面，请在下面的评论中留下它们！感谢阅读！</p></div></div>    
</body>
</html>