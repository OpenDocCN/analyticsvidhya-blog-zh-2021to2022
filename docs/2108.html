<html>
<head>
<title>Making sense of typing.overload</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解打字的意义。超载</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/making-sense-of-typing-overload-437e6deecade?source=collection_archive---------5-----------------------#2021-04-05">https://medium.com/analytics-vidhya/making-sense-of-typing-overload-437e6deecade?source=collection_archive---------5-----------------------#2021-04-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4acc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让你的回报类型更精确！</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/0fe6569196c5e537324e80655e90f087.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GHJdRJjhnUXJR0VF"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">布雷特·乔丹</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="38ab" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如果不使用<code class="du ks kt ku kv b">typing.overload</code>会发生什么</h1><p id="fd8e" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">假设我们有一个函数，它有一个布尔参数<code class="du ks kt ku kv b">inplace</code>，并且它的返回类型依赖于<code class="du ks kt ku kv b">inplace</code>的值。如果是<code class="du ks kt ku kv b">True</code>，则返回<code class="du ks kt ku kv b">None</code>，否则返回一个整数:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="67ca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过检查函数，我们可以看到我们期望第17行的返回类型是<code class="du ks kt ku kv b">None</code>，而第18行和第19行的返回类型是<code class="du ks kt ku kv b">Cat</code>。然而，<code class="du ks kt ku kv b">mypy</code>在函数内部没有达到峰值，因此认为它们都是<code class="du ks kt ku kv b">Optional[Cat]</code>。实际上，运行上面的剪贴，我们得到:</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="5d84" class="lh jv hi kv b fi li lj l lk ll">main.py:17: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:18: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:19: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:20: note: Revealed type is 'Union[main.Cat, None]'</span></pre><p id="b8db" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使第17行和第18行的返回类型更加精确，我们需要<code class="du ks kt ku kv b">overload</code>。</p><h1 id="1dcf" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如果使用重载会发生什么</h1><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="810a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它返回</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="d272" class="lh jv hi kv b fi li lj l lk ll">main.py:31: note: Revealed type is 'None'<br/>main.py:32: note: Revealed type is 'main.Cat'<br/>main.py:33: note: Revealed type is 'main.Cat'<br/>main.py:34: note: Revealed type is 'Union[main.Cat, None]'</span></pre><p id="bc91" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意我们是如何需要重载的:</p><ul class=""><li id="9600" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">文字[假]，默认</li><li id="dda2" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">字面[真实]</li><li id="0429" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">带默认值的布尔值</li></ul><p id="4bf7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还要注意，我们需要从实现中移除返回类型。</p><p id="7a5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这还不算太糟。当在我们重载的关键字参数之前有额外的关键字参数<em class="ma">时，事情就变得复杂了。</em></p><h1 id="bb21" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">使用带有默认值的额外参数重载函数</h1><p id="0e00" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">比方说，我们有:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="62cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">运行mypy，我们得到</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="992f" class="lh jv hi kv b fi li lj l lk ll">main.py:29: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:30: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:31: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:32: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:33: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:34: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:35: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:36: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:37: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:38: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:39: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:40: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:41: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:42: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:43: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:44: note: Revealed type is 'Union[main.Cat, None]'</span></pre><p id="babc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了使返回类型更加精确，我们可能会像以前一样尝试同样的技巧并重载:</p><ul class=""><li id="5f45" class="lm ln hi ih b ii ij im in iq lo iu lp iy lq jc lr ls lt lu bi translated">文字[假]，默认</li><li id="b2d3" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">字面[真实]</li><li id="41a3" class="lm ln hi ih b ii lv im lw iq lx iu ly iy lz jc lr ls lt lu bi translated">带默认值的布尔值</li></ul><p id="dd0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这是行不通的(试着运行上面的代码片段看看！).相反，我们需要重载我们想要重载的参数之前的默认参数的每个组合。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="lb lc l"/></div></figure><p id="080e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这将会回来</p><pre class="je jf jg jh fd ld kv le lf aw lg bi"><span id="f7ac" class="lh jv hi kv b fi li lj l lk ll">main.py:94: note: Revealed type is 'None'<br/>main.py:95: note: Revealed type is 'main.Cat'<br/>main.py:96: note: Revealed type is 'main.Cat'<br/>main.py:97: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:98: note: Revealed type is 'None'<br/>main.py:99: note: Revealed type is 'main.Cat'<br/>main.py:100: note: Revealed type is 'main.Cat'<br/>main.py:101: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:102: note: Revealed type is 'None'<br/>main.py:103: note: Revealed type is 'main.Cat'<br/>main.py:104: note: Revealed type is 'main.Cat'<br/>main.py:105: note: Revealed type is 'Union[main.Cat, None]'<br/>main.py:106: note: Revealed type is 'None'<br/>main.py:107: note: Revealed type is 'main.Cat'<br/>main.py:108: note: Revealed type is 'main.Cat'<br/>main.py:109: note: Revealed type is 'Union[main.Cat, None]'</span></pre><h1 id="6ae0" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="e3b1" class="pw-post-body-paragraph if ig hi ih b ii kw ik il im kx io ip iq ky is it iu kz iw ix iy la ja jb jc hb bi translated">我们已经看到了<code class="du ks kt ku kv b">typing.overload</code>如何帮助我们使函数的返回类型更加精确。现在请出去重载一些函数！</p></div></div>    
</body>
</html>