<html>
<head>
<title>Yet Another Intro to Concurrency in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中并发性的又一介绍</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/yet-another-intro-to-concurrency-in-python-5aad2796a766?source=collection_archive---------19-----------------------#2021-01-25">https://medium.com/analytics-vidhya/yet-another-intro-to-concurrency-in-python-5aad2796a766?source=collection_archive---------19-----------------------#2021-01-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="e176" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python中主要并发主题的简单介绍</p><p id="6252" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用<a class="ae jc" href="https://github.com/python/cpython" rel="noopener ugc nofollow" target="_blank"> CPython解释器</a>在Python中找到理解和实现并发性的资源当然并不困难。然而，找到<em class="jd">好的</em>资源可能是困难的。因此，我想为这个主题写更多的“登陆页面”，简要地触及Python中并发性的主要子主题，同时只为那些想要深入了解的人提供权威资源(主要是官方Python文档和来自维护者的摘录)。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/10996ac5b43aa761eda02fd8a310ac81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*k7UXOz3ksm7ykyCE.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">具有讽刺意味的是，通过<em class="jq">创造另一种资源</em>来解决太多资源的问题，我并没有完全忘记..但是这次会不一样！😅</figcaption></figure><h1 id="d6ed" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">主要模块</h1><p id="83fb" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">熟悉Python中并发性的最好方法之一是接触主要的内置并发模块，对于这一点，没有比Python文档更好的权威资源了！文档维护得很好，有源代码和代码片段示例的链接。文档中有一页专门讨论了<a class="ae jc" href="https://docs.python.org/3/library/concurrency.html" rel="noopener ugc nofollow" target="_blank">并发</a>主题，但是有点冗长。对于简单的介绍，我建议首先熟悉如何…</p><p id="a488" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个进程(使用<a class="ae jc" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">多重处理。流程</a></p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="ffad" class="kz js hh kv b fi la lb l lc ld"><strong class="kv hi">from</strong> <strong class="kv hi">multiprocessing</strong> <strong class="kv hi">import</strong> Process<br/><br/><strong class="kv hi">def</strong> f(name):<br/>    print('hello', name)<br/><br/><strong class="kv hi">if</strong> __name__ == '__main__':<br/>    p = Process(target=f, args=('bob',))<br/>    p.start()<br/>    p.join()</span></pre><p id="002f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个螺纹(使用<a class="ae jc" href="https://docs.python.org/3/library/threading.html#threading.Thread" rel="noopener ugc nofollow" target="_blank">螺纹。螺纹</a></p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="dec7" class="kz js hh kv b fi la lb l lc ld"><strong class="kv hi">from</strong> <strong class="kv hi">threading</strong> <strong class="kv hi">import</strong> Thread<br/><br/><strong class="kv hi">def</strong> f(name):<br/>    print('hello', name)<br/><br/><strong class="kv hi">if</strong> __name__ == '__main__':<br/>    t = Thread(target=f, args=('bob',))<br/>    t.start()<br/>    t.join()</span></pre><p id="04c7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于额外的积分(对于Python 3.7以上的用户)，您还可以熟悉如何创建一个协程(使用<a class="ae jc" href="https://docs.python.org/3/library/asyncio-task.html#coroutine" rel="noopener ugc nofollow" target="_blank"> asyncio </a>)</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="830d" class="kz js hh kv b fi la lb l lc ld"><strong class="kv hi">import</strong> <strong class="kv hi">asyncio</strong><br/><strong class="kv hi">import</strong> <strong class="kv hi">time</strong><br/><br/><strong class="kv hi">async</strong> <strong class="kv hi">def</strong> say_after(delay, what):<br/>    <strong class="kv hi">await</strong> asyncio.sleep(delay)<br/>    print(what)<br/><br/><strong class="kv hi">async</strong> <strong class="kv hi">def</strong> main():<br/>    print(f"started at <em class="jd">{</em>time.strftime('<em class="jd">%X</em>')<em class="jd">}</em>")<br/><br/>    <strong class="kv hi">await</strong> say_after(1, 'hello')<br/>    <strong class="kv hi">await</strong> say_after(2, 'world')<br/><br/>    print(f"finished at <em class="jd">{</em>time.strftime('<em class="jd">%X</em>')<em class="jd">}</em>")<br/><br/>asyncio.run(main())</span></pre><p id="842c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python库中包含的其他并发抽象，如<a class="ae jc" href="https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor" rel="noopener ugc nofollow" target="_blank">执行器</a>和<a class="ae jc" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.pool.Pool" rel="noopener ugc nofollow" target="_blank">池</a>都是在上述类的基础上构建的。</p><h1 id="483d" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">全局解释器锁(GIL)</h1><p id="8e55" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">每当用Python处理并发性时，房间里就有一头大象；那就是<a class="ae jc" href="https://medium.com/r?url=https%3A%2F%2Fdocs.python.org%2F3%2Fglossary.html%23term-global-interpreter-lock" rel="noopener">全局解释器锁</a>，又名GIL。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es le"><img src="../Images/9998dc3900e48cf582051dc04fcaea6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TwhqAIar98RPkF7Y.jpg"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">GIL实际上更像是一只海姆达尔犬，而不是一头大象…</figcaption></figure><h2 id="fe1d" class="kz js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">什么</h2><p id="41ca" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">GIL是CPython解释器的一个特性，它确保<em class="jd">只有一个线程在解释器中运行</em>(即使是在多核机器上)。在幕后，GIL只是一个互斥体，由线程传递以决定谁去执行。这种线程锁定模型如下所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="er es lw"><img src="../Images/e81e689280eb82eb58fd54a848468145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-byBEYjCl3q0yLZ-.png"/></div></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">这里你可以看到一个多线程的Python程序，其中只有获得了GIL的线程才能执行</figcaption></figure><p id="89af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">释放GIL并允许下一个线程运行的三个值得注意的场景是当正在执行的线程…</p><ol class=""><li id="3bcb" class="lx ly hh ig b ih ii il im ip lz it ma ix mb jb mc md me mf bi translated">在I/O(读、写、接收、发送等)上被阻止。)</li><li id="c66d" class="lx ly hh ig b ih mg il mh ip mi it mj ix mk jb mc md me mf bi translated">位于显式释放它的本机C扩展中(例如，<a class="ae jc" href="https://github.com/numpy/numpy/search?utf8=%E2%9C%93&amp;q=NPY_BEGIN_THREADS" rel="noopener ugc nofollow" target="_blank"> NumPy </a>)</li><li id="b157" class="lx ly hh ig b ih mg il mh ip mi it mj ix mk jb mc md me mf bi translated">执行100个“滴答”(“滴答”<em class="jd">大致是</em>翻译成指令)</li></ol><h2 id="3d04" class="kz js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">为什么</h2><p id="3a35" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这种机制的主要原因是<em class="jd">很简单</em>。它简化了CPython解释器的许多底层细节(内存管理、对C扩展的调用等)。).此外，它使Python开发人员变得简单，因为他们不再受制于涉及线程竞争条件的一大类问题。</p><h2 id="ffcd" class="kz js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">我为什么在乎？</h2><p id="9108" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">当评估你的Python程序在给定场景中应该使用什么并发原语时，了解GIL是极其重要的，无论是线程、进程、协同程序还是普通的串行执行。例如，使用多线程处理CPU受限的任务可能会<em class="jd">降低</em> <em class="jd">程序的速度</em>，而不管内核是否可用，这对于任何在这种执行模型之外编程的人来说都是违反直觉的。这将在下一节中演示。</p><p id="4e76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd">更多关于GIL的信息，请查看丹·比兹利的博客:</em><a class="ae jc" href="http://www.dabeaz.com/GIL/" rel="noopener ugc nofollow" target="_blank"><em class="jd">http://www.dabeaz.com/GIL/</em></a></p><h1 id="1311" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">何时使用线程，何时使用进程，何时不使用线程(串行执行)</h1><p id="c155" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">这里没有灵丹妙药。何时使用线程、进程、协程或根本不使用完全取决于用例。做出这个决定最重要的先决条件是能够描述你的申请<em class="jd">。</em> 如果不进行性能分析，准确预测性能几乎是不可能的。尤其是当考虑到GIL的强加。如果您还没有对您的程序进行评测，请在继续之前跳到下一节以获得相关说明。</p><p id="8d33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设您已经分析了您的程序，这个决策树可以作为判断哪个并发原语最适合您的经验法则:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es ml"><img src="../Images/d9d5127e32b7b8c4d60d1702008117fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1352/format:webp/1*wJT0q0sgRuJvGrBW902ZJg.png"/></div><figcaption class="jm jn et er es jo jp bd b be z dx translated">这张图展示了——我不是设计师</figcaption></figure><p id="e722" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该树隐含地偏向线程而不是进程，仅仅是因为线程更容易实现。线程已经在同一个地址空间中运行，因为GIL将强制互斥，所以不需要额外的工作来管理共享资源。</p><h1 id="0d97" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">剖析您的程序</h1><p id="2816" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">剖析可以让您大开眼界，更好地了解Python程序的性能。当给定详细的分析信息时，隐藏的瓶颈通常变得容易追踪。幸运的是，这在Python中很容易做到。</p><p id="a133" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Python标准库附带了两个分析器:<a class="ae jc" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>和<a class="ae jc" href="https://docs.python.org/3/library/profile.html#module-profile" rel="noopener ugc nofollow" target="_blank"> profile </a>，建议大多数用户使用cProfile。作为分析器能做什么的一个例子，请看下面这个取自Python文档的例子:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="b5cb" class="kz js hh kv b fi la lb l lc ld">import cProfile<br/>import re<br/>cProfile.run('re.compile("foo|bar")')</span></pre><p id="e7ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行上述程序后，您会得到如下输出:</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="ca60" class="kz js hh kv b fi la lb l lc ld">197 function calls (192 primitive calls) <strong class="kv hi">in</strong> 0.002 seconds</span><span id="f06a" class="kz js hh kv b fi mm lb l lc ld">Ordered by: standard name</span><span id="4d98" class="kz js hh kv b fi mm lb l lc ld">ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>     1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)<br/>     1    0.000    0.000    0.001    0.001 re.py:212(compile)<br/>     1    0.000    0.000    0.001    0.001 re.py:268(_compile)<br/>     1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)<br/>     1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)<br/>     4    0.000    0.000    0.000    0.000 sre_compile.py:25(_identityfunction)<br/>   3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)</span></pre><p id="66a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些文档包括一个简单的用户手册，用于理解从这些统计数据中可以收集到的大量信息。</p><p id="688c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="jd">注意(针对Docker用户):Docker使用</em> <a class="ae jc" href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html" rel="noopener ugc nofollow" target="_blank"> <em class="jd"> Seccomp过滤器</em> </a> <em class="jd">来限制容器进程可以进行哪些系统调用。您必须在启动容器时启用</em> <code class="du mn mo mp kv b">--cap-add SYS_PTRACE</code> <em class="jd">来启用Py-Spy之类的采样分析器(它依赖于</em><a class="ae jc" href="https://man7.org/linux/man-pages/man2/process_vm_readv.2.html" rel="noopener ugc nofollow" target="_blank">process _ VM _ readv</a>)<em class="jd">来探查您的程序的地址空间)。</em></p><h2 id="dc6a" class="kz js hh bd jt lj lk ll jx lm ln lo kb ip lp lq kf it lr ls kj ix lt lu kn lv bi translated">选择分析器</h2><p id="6b30" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">并非所有的分析器都是相同的。最适合您的profiler还是取决于用例。然而，主要的考虑因素通常是确定性的<strong class="ig hi">与统计性的</strong>。</p><p id="6fcf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">确定性</strong>剖析器<strong class="ig hi"> </strong>执行跟踪功能，记录所有感兴趣的事件(函数调用、函数返回等)。).这些分析器记录高分辨率的分析信息，但通常会产生很高的开销。如果应用程序有大量的函数调用，分析器将有大量的函数要收集，如果函数很小，由于测量本身的开销，它们的执行时间可能不准确。</p><p id="10b4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">统计</strong>评测器周期性中断程序，采样执行状态。然后分析执行状态(即调用堆栈)。这些分析器不能捕获所有的函数调用，但是它们的开销通常很低(更适合在生产中使用)。</p><p id="1471" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其他考虑因素包括分析器是否在内存中运行(即，将分析器模块导入Python程序并选择开始/停止记录的位置)，或者它是否附加到现有的Python进程。</p><p id="1104" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是一个简单的图表，比较了三个流行的Python分析器:<a class="ae jc" href="https://docs.python.org/3/library/profile.html#module-cProfile" rel="noopener ugc nofollow" target="_blank"> cProfile </a>、<a class="ae jc" href="https://github.com/sumerc/yappi" rel="noopener ugc nofollow" target="_blank"> Yappi </a>和<a class="ae jc" href="https://github.com/benfred/py-spy" rel="noopener ugc nofollow" target="_blank"> Py-Spy </a>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es mq"><img src="../Images/13f269a085762680ef8fe6c0661ae694.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*_xPEJ0sHQcO-8gQOHKocLg.png"/></div></figure><h1 id="2245" class="jr js hh bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">就是这样！</h1><p id="5b3e" class="pw-post-body-paragraph ie if hh ig b ih kp ij ik il kq in io ip kr ir is it ks iv iw ix kt iz ja jb ha bi translated">希望这为您提供了足够的信息，可以开始将并发性引入您的Python程序！请随意评论或提问。</p></div></div>    
</body>
</html>