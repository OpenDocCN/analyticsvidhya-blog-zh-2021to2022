<html>
<head>
<title>Session Authentication with Lambda and DynamoDB</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Lambda和DynamoDB进行会话认证</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/session-authentication-with-lambda-and-dynamodb-60355bff8a97?source=collection_archive---------0-----------------------#2021-02-10">https://medium.com/analytics-vidhya/session-authentication-with-lambda-and-dynamodb-60355bff8a97?source=collection_archive---------0-----------------------#2021-02-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/bf13212c53ec15fb38d6b6beaa0da74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JZh9ov9VQXvrrvTIcIDAPA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">亚历克斯·库利科夫在<a class="ae iu" href="https://unsplash.com" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a071" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本教程中，我们使用AWS Lambda和DynamoDB创建会话认证。我们回顾了什么是会话认证，为什么我们使用Lambda，并从头开始构建它。我们还将使用无服务器应用模型(SAM)框架来测试、打包和部署Lambda函数。</p><h1 id="3026" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">什么是会话认证？</h1><p id="a65c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">你可能已经猜到了，会话认证是一种最广泛使用的认证，也是最容易实现的认证。</p><h2 id="3c52" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">它是如何工作的？</h2><p id="403e" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">当用户输入凭据并提交登录请求时，后端首先检查凭据是否有效，如果有效，将生成一个随机字符串。这个随机生成的字符串就是我们的会话令牌。</p><p id="f268" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，该字符串与其他一些必需的数据(如用户ID)一起存储在数据库中。让我们称这个字符串为<em class="lk">令牌</em>，因为这就是它，一个用来访问一组服务的令牌。然后，这个令牌作为Cookie存储在客户端，并在每次后续请求时发送到应用程序的后端。</p><p id="e307" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当用户向API发送请求时，会发生以下情况:</p><ol class=""><li id="5851" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">该请求被发送到包含cookies的服务器</li><li id="6e21" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">后端解析cookies并获取会话令牌</li><li id="35e2" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">验证会话令牌，如果有效，则通过向存储会话令牌的数据库发送请求来获取会话数据</li></ol><p id="6a45" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是我们可以实现的最简单的会话认证版本。</p><p id="a61c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="lk">注意，数据库可以是任何类型的。然而，由于会话信息经常被读取，因此将它存储在具有极快读取速度的数据库中是很有用的。</em></p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es lz"><img src="../Images/c98dc32f1ad94d73221d70e4cd56306b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*ZbEvWnPfiY7Msf5mBBlG7g.png"/></div></figure><h2 id="56a2" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">但是为什么要用Lambda呢？</h2><p id="f3fc" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您可能想知道为什么我们需要使用Lambda进行会话认证，而实现它的逻辑并不复杂，只需要很少的工作。这个问题的答案，就像今天的许多其他问题一样，是微服务。</p><p id="43e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于一个单一的应用程序，使用Lambda可能会适得其反，因为你通常只有一个包含所有逻辑的代码库。甚至可能会有性能下降，因为每次用户发送请求时，您都要向Lambda函数发送请求。</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es me"><img src="../Images/7bddd9e0559329e4a8350dc38b402863.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*P6N9RWKRpDqsEK0TkqKxEA.png"/></div></figure><p id="1e65" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是，在现代应用程序中，通常会有数十、数百甚至数千个微服务，在每个服务中重新实现验证用户身份所需的逻辑会变得非常繁琐，难以编写和维护。</p><p id="552a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开发人员遵循的最常见的规则可能是DRY(<strong class="ix hj">D</strong>o not<strong class="ix hj">R</strong>EPE at<strong class="ix hj">Y</strong>yourself)，这正是我们想要达到的目标。有了Lambda，我们的流程图就像下面这样，所有的逻辑都在一个地方，维护变得更加容易。这也创造了一个非常有用的额外的抽象层。</p><figure class="ma mb mc md fd ij er es paragraph-image"><div class="er es mf"><img src="../Images/b405f43794178b7ef826d5b2347c1ded.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*kLqr7DoqUjzLP71ZQeBEig.png"/></div></figure><p id="ca58" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lk">重要:</em> </strong> <em class="lk">这并不意味着你要一直朝着干代码努力。</em> <a class="ae iu" href="https://www.deconstructconf.com/2019/dan-abramov-the-wet-codebase" rel="noopener ugc nofollow" target="_blank"> <em class="lk">下面大谈湿码(干码的反义词)</em> </a> <em class="lk">。</em></p><h1 id="4c4a" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">JWTs呢？</h1><p id="1b75" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">如果你不知道，<a class="ae iu" href="https://jwt.io" rel="noopener ugc nofollow" target="_blank"> JWT </a>代表JSON Web令牌。这是另一种认证方式，近年来获得了极大的普及和采用。</p><p id="03a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">主要优势是JWT经过加密签名，会话数据存储在令牌本身中，这意味着后端不必在每次用户发送请求时都向数据库发送请求，这在很多情况下可能会带来更好的性能。</p><p id="1834" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，jwt并不都是华而不实的。</p><h2 id="ea51" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">jwt的缺点</h2><ol class=""><li id="fb31" class="ll lm hi ix b iy kr jc ks jg mg jk mh jo mi js lq lr ls lt bi translated">更难实现安全的东西。这里有一篇<a class="ae iu" href="https://www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html" rel="noopener ugc nofollow" target="_blank">文章</a>描述了用jwt实现所需要的一些更难的东西，没有这些东西它是不安全的。</li><li id="aa44" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">可存储数据的限制。关于用户的敏感数据不能存储在JWTs中，因为这些数据会公开。</li><li id="3c71" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">要求您知道用户登录了哪些设备的功能是不可能的。例如，如果您想要向用户显示他们登录的所有设备以及从一个设备注销另一个设备。</li></ol><h1 id="1b20" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">先决条件</h1><ol class=""><li id="e8f3" class="ll lm hi ix b iy kr jc ks jg mg jk mh jo mi js lq lr ls lt bi translated">一个<a class="ae iu" href="https://aws.amazon.com" rel="noopener ugc nofollow" target="_blank"> AWS账户</a>。不要担心，我们将使用DynamoDB和Lambda，在一定的限制下可以免费使用，因此不会向您收取任何费用。</li><li id="8624" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated"><a class="ae iu" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">节点和NPM </a></li><li id="65b3" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">在本地运行我们的Lambda函数</li><li id="9bdf" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">你选择的编辑</li></ol></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="0001" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果您对以下步骤使用AWS命令行界面感到满意，您可以这样做。不过，我们将直接使用AWS Dashboard，因为它的入门更加简单。</p><p id="9115" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请确保您登录到了一个AWS帐户，该帐户具有使用DynamoDB、Lambda、CloudFormation和S3所需的权限。如果使用的是个人帐户或根用户帐户，则不必担心权限问题，可以继续前进。</p><h1 id="191d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建动态数据库表</h1><p id="edde" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">首先，登录到你的<a class="ae iu" href="http://AWS Console" rel="noopener ugc nofollow" target="_blank"> AWS控制台</a>然后前往<a class="ae iu" href="http://console.aws.amazon.com/dynamodb" rel="noopener ugc nofollow" target="_blank">动力数据库</a>。然后，点击<em class="lk">创建表格。</em></p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/b5d88e492ebc3d70f89f9eac735efca1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*apdG0q28kIfDM8bDiIBD6g.png"/></div></div></figure><p id="25ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">DynamoDB是一个没有schemaless的NoSQL数据库。它是文档数据库和密钥值存储的混合。我们使用DynamoDB是因为它是无服务器的，这意味着我们几乎没有什么需要管理的，它非常快速可靠，而且由于它是无模式的，我们可以存储非结构化数据。</p><p id="4fce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你以前从未使用过像DynamoDB或MongoDB这样的NoSQL数据库，而你正在使用一个像PostgreSQL这样的传统关系数据库，我建议你阅读AWS文档中的<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.html" rel="noopener ugc nofollow" target="_blank">这一节，进一步了解它们是如何比较的，以及它们是如何工作的。</a></p><div class="mr ms ez fb mt mu"><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/SQLtoNoSQL.html" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hj fi z dy mz ea eb na ed ef hh bi translated">从SQL到NoSQL</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">如果您是应用程序开发人员，您可能有一些使用关系数据库管理系统的经验…</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">docs.aws.amazon.co</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni io mu"/></div></div></a></div><p id="1f06" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">点击<em class="lk">创建表格</em>，进入下页。</p><figure class="ma mb mc md fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mq"><img src="../Images/8e89813981ac1e5191addfcbc54fe895.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LoGY3n4KiFdXCCgzQ2Huiw.png"/></div></div></figure><p id="f3bc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们来分析一下DynamoDB表中的不同组成部分。</p><ol class=""><li id="33ab" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated">表名—确切地说，是表的名称</li><li id="7a8a" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">主键—就像在关系数据库中，我们使用主键来标识某个记录一样，我们在DynamoDB中使用主键。</li></ol><p id="5cfe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你仔细观察，你还会注意到一个叫做“分区密钥”的东西和一个“排序密钥”的复选框。</p><blockquote class="nj nk nl"><p id="738d" class="iv iw lk ix b iy iz ja jb jc jd je jf nm jh ji jj nn jl jm jn no jp jq jr js hb bi translated">主密钥由分区密钥(哈希密钥)和可选的排序密钥组成。分区密钥用于跨主机对数据进行分区，以实现可扩展性和可用性。选择一个具有大范围值并且可能具有均匀分布的访问模式的属性。例如，CustomerId是好的，而GameId是坏的，如果你的大部分流量与一些流行的游戏有关。</p><p id="0bfb" class="iv iw lk ix b iy iz ja jb jc jd je jf nm jh ji jj nn jl jm jn no jp jq jr js hb bi translated">排序关键字允许在分区内进行搜索。例如，具有主属性CustomerId和排序属性OrderTimestamp的Orders表将允许查询给定日期范围内特定客户的所有订单。</p></blockquote><p id="3ebe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这一点上，如果你对使用的术语感到困惑，不要担心，你并不孤单。分区和排序键的命名与DynamoDB的内部工作方式以及它如何使用这两者来分发和存储数据有关，您不必了解它们是什么。然而，对于那些好奇的人来说，你可以查看AWS文档的<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/HowItWorks.Partitions.html" rel="noopener ugc nofollow" target="_blank">这一节</a>，它对这两者进行了更详细的解释。</p><p id="7c6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们继续将表命名为<code class="du np nq nr ns b">UserSessions</code>并将主键命名为<code class="du np nq nr ns b">sessionId</code>，主键的类型为<code class="du np nq nr ns b">string</code>。</p><p id="e92d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将坚持使用默认设置，因为这将有助于我们快速开始，我们不需要修改任何东西来启动和运行我们的应用程序。</p><p id="bc36" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，点击<em class="lk">创建。</em></p><h1 id="a7e6" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用DynamoDB</h1><p id="2581" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">使用DynamoDB的API相当简单。您可以使用<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Using.API.html" rel="noopener ugc nofollow" target="_blank"> REST API </a>、<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Tools.CLI.html" rel="noopener ugc nofollow" target="_blank"> AWS CLI </a>或使用<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.NodeJs.html" rel="noopener ugc nofollow" target="_blank"> DynamoDB SDK </a>来执行命令。在本教程中，我们将只涉及使用DynamoDB的基础知识，不会深入探讨，但是如果你想了解更多关于使用DynamoDB的知识，请随时浏览<a class="ae iu" href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="8562" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在DynamoDB中，<em class="lk">项</em>是属性的集合，其中每个属性是一个键-值对，值可以是标量、集合或文档类型(文档类似于JSON对象)。简单地说，一个<em class="lk">条目</em>是一个具有多个属性的记录，这些属性被存储为键值对。每个表有多个条目，每个条目有多个属性。</p><p id="4bec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了处理DynamoDB中的数据，我们使用了操作。操作是我们可以用来修改DynamoDB表中数据的命令。创建、写入、更新和删除(CRUD)功能有四个主要操作，即<code class="du np nq nr ns b">PutItem</code>、<code class="du np nq nr ns b">GetItem</code>、<code class="du np nq nr ns b">UpdateItem</code>和<code class="du np nq nr ns b">DeleteItem</code>。</p><h2 id="95db" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">写入数据</h2><p id="afb9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了将数据写入DynamoDB表，我们使用了<code class="du np nq nr ns b">PutItem</code>操作。</p><pre class="ma mb mc md fd nt ns nu nv aw nw bi"><span id="adc7" class="kw ju hi ns b fi nx ny l nz oa">{ <br/>  "sessionId": { "S": "abcd-abcd-abcd" },<br/>  "userId": { "S": "dcba-dcba-dcba" },<br/>  "timestamp": { "N": 1612969254 },<br/>  "isActive": { "BOOL": true }<br/>}</span></pre><p id="3250" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果我们用上面的输入在我们创建的表上执行<code class="du np nq nr ns b">PutItem</code>操作，一个新的项目<em class="lk"> </em>在我们的表中被创建，其中<code class="du np nq nr ns b">sessionId</code>被设置为<code class="du np nq nr ns b">abcd-abcd-abcd</code> , <code class="du np nq nr ns b">userId</code>被设置为<code class="du np nq nr ns b">dcba-dbca-dcba</code>，而<code class="du np nq nr ns b">timestamp</code>被设置为<code class="du np nq nr ns b">1612969254</code>。记住，我们将<code class="du np nq nr ns b">sessionId</code>设置为我们的主键，并且类型为string，所以这个字段的值必须是惟一的，并且类型为string，否则将会抛出一个错误。</p><p id="3242" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">但是什么是</strong><code class="du np nq nr ns b">S</code><code class="du np nq nr ns b">N</code><code class="du np nq nr ns b">BOOL</code>？这是我们提供的值的数据类型。<code class="du np nq nr ns b">S</code>代表字符串，<code class="du np nq nr ns b">N</code>代表数字，<code class="du np nq nr ns b">BOOL</code>代表布尔。您可以在官方文档中找到所有可用数据类型及其约束的完整列表。</p><h2 id="f83b" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">更新数据</h2><p id="90c0" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">类似于<code class="du np nq nr ns b">PutItem</code>操作，我们使用<code class="du np nq nr ns b">UpdateItem</code>操作来更新表中的数据。然而，<code class="du np nq nr ns b">UpdateItem</code>操作的工作方式略有不同。我们必须提供想要修改其数据的项目的主键，并提供一个<strong class="ix hj">更新表达式</strong>。更新表达式指定要修改哪个属性值。</p><p id="35ff" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设我们想要修改我们在上一节中刚刚创建的项目的<code class="du np nq nr ns b">isActive</code>属性，我们的更新表达式应该是<code class="du np nq nr ns b">SET active = :activeStatus</code>，其中<code class="du np nq nr ns b">:activeStatus</code>是属性值的占位符，我们使用更新表达式属性参数传递它。</p><p id="51dc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">更新表达式属性参数看起来类似于我们提供给<code class="du np nq nr ns b">PutItem</code>操作的输入，如下所示。</p><pre class="ma mb mc md fd nt ns nu nv aw nw bi"><span id="1286" class="kw ju hi ns b fi nx ny l nz oa">{ <br/>  ":activeStatus": { "BOOL": true }<br/>}</span></pre><p id="bf0e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们指定占位符键和占位符的值以及类型的值。</p><h2 id="d3cf" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">读取数据</h2><p id="856c" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了读取数据，我们向<code class="du np nq nr ns b">GetItem</code>操作提供我们想要检索的项目的主键。</p><p id="bedb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">到目前为止，我们已经讨论过的操作以及我们如何使用它们可能看起来有点模糊，因为我们还没有运行它们。希望当我们在下一节使用Lambda和DynamoDB编写一些代码时，事情会变得更加清楚。</p><h1 id="2f3d" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">创建Lambda函数</h1><p id="a9b4" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">与我们如何直接从AWS仪表板使用DynamoDB不同，当使用Lambda时，我们将只从我们的文本编辑器和终端工作。我们甚至将直接从我们的终端捆绑和部署Lambda函数，这将在下一节中讨论。</p><h2 id="cbb5" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">我们将要创建的函数</h2><ol class=""><li id="6c60" class="ll lm hi ix b iy kr jc ks jg mg jk mh jo mi js lq lr ls lt bi translated">创建会话</li><li id="fcb6" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">验证并获取会话信息</li><li id="bbb9" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">停用会话</li></ol><h2 id="691d" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">项目设置</h2><ol class=""><li id="998d" class="ll lm hi ix b iy kr jc ks jg mg jk mh jo mi js lq lr ls lt bi translated">创建三个单独的文件夹，分别命名为<code class="du np nq nr ns b">create-session</code>、<code class="du np nq nr ns b">get-session-info</code>和<code class="du np nq nr ns b">deactivate-session</code>，每个功能一个。</li><li id="bdd4" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">在每个文件夹中运行<code class="du np nq nr ns b">npm init -y</code>来初始化NPM</li><li id="e6e8" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated">所有的Lambda函数都需要与DynamoDB交互，我们将使用AWS JavaScript SDK来完成。我们还将需要<code class="du np nq nr ns b">@aws-sdk/util-dynamodb</code>包，其中包含实用功能，使工作与SDK更容易。要安装SDK和实用程序库，请在每个文件夹中运行<code class="du np nq nr ns b">npm i @aws-sdk/client-dynamodb @aws-sdk/util-dynamodb</code>。</li></ol><h2 id="3524" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">创建会话功能</h2><p id="df69" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">对于create-session函数，我们将使用一个名为<code class="du np nq nr ns b">crypto-js</code>的附加包，它包含使用不同算法生成散列的函数。要安装它，运行<code class="du np nq nr ns b">npm i crypot-js</code>。</p><p id="21ef" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们首先创建一个<code class="du np nq nr ns b">generateId</code>函数，它使用<code class="du np nq nr ns b">SHA256</code>散列函数随机生成一个会话ID，输入是用户ID、当前时间戳和一个随机生成的数字的串联字符串。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="9f03" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们初始化DynamoDB客户端的一个实例。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="045b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后，我们创建Lambda函数处理程序，其输入将是用户信息，如用户ID，输出将是会话信息，包括会话ID、到期日期、活动状态和创建时间。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><p id="bbf1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在上一节中，我们讨论了如何提供参数值的数据类型。但是请注意我们在这里没有这样做。相反，我们创建一个常规的JavaScript对象，并将其从<code class="du np nq nr ns b">@aws-sdk/util-dynamodb</code>包传递给<code class="du np nq nr ns b">marshall</code>函数。</p><p id="57c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du np nq nr ns b">marshall</code>函数将一个常规的JavaScript对象作为输入，解释每个参数的数据类型，并返回一个具有DynamoDB所期望的格式的对象，其中提供了属性值的数据类型。</p><p id="c28b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，如果我们向<code class="du np nq nr ns b">marshall</code>函数提供输入<code class="du np nq nr ns b">{ sessionId: "abcd-abcd-abcd" }</code>，我们将得到输出<code class="du np nq nr ns b">{ sessionId: { S: "abcd-abcd-abcd" } }</code>。</p><p id="5754" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们调用<code class="du np nq nr ns b">DynamoDB</code>实例上的<code class="du np nq nr ns b">.putItem()</code>方法，将表名和项目属性作为输入来执行<code class="du np nq nr ns b">PutItem</code>命令。</p><h2 id="316a" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">验证会话并获取会话数据</h2><p id="4c4b" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">类似于create-session函数，我们首先初始化一个<code class="du np nq nr ns b">DynamoDB</code>的实例。在这种情况下，Lambda函数的输入将是一个具有单一<code class="du np nq nr ns b">sessionId</code>属性的对象，输出将是会话信息。</p><p id="43cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们通过运行<code class="du np nq nr ns b">.getItem()</code>方法来执行<code class="du np nq nr ns b">GetItem</code>操作，将我们想要访问的条目的表名和键作为输入，在本例中是会话ID。</p><p id="1470" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du np nq nr ns b">GetItem</code>操作的响应结构类似于我们提供给<code class="du np nq nr ns b">PutItem</code>操作的输入，即提供属性值的数据类型。但是，我们不想处理这个问题，因为这会使访问数据变得很麻烦。为了从对象中移除数据类型，我们使用了<code class="du np nq nr ns b">unmarshall</code>实用程序，它的功能与<code class="du np nq nr ns b">marshall</code>功能正好相反。例如，如果我们提供字符串<code class="du np nq nr ns b">{ sessionId: { S: "abcd-abcd-abcd" } }</code>作为输入，输出将是<code class="du np nq nr ns b">{ sessionId: "abcd-abcd-abcd" }</code>。</p><p id="9fb8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在返回会话信息之前，我们检查会话是否过期，如果过期，我们通过运行<code class="du np nq nr ns b">.updateItem()</code>方法执行<code class="du np nq nr ns b">UpdateItem</code>操作，并将<code class="du np nq nr ns b">isActive</code>属性设置为false并返回会话信息对象。如果它没有过期，我们将会话的过期日期更新为从当前时间算起的14天，并返回带有更新的过期日期的会话信息对象。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h2 id="ca74" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">停用会话</h2><p id="db7d" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">您可能会问，为什么我们要停用会话而不删除它。想象一下，在创建会话之后，用户注销，但在此之前，用户存储在其他地方创建的会话令牌。</p><p id="11ca" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，让我们考虑在用户注销时删除令牌，而不是停用它。在未来的某个时候，不管可能性有多小，想象一下创建了一个令牌，它与我们之前为前一个用户创建并删除的令牌完全匹配。</p><p id="e063" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前一个用户仍然可以访问该令牌，如果他们尝试使用该会话令牌访问应用程序，他们将可以完全访问第二个用户的帐户。</p><p id="c230" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了防止上述情况，我们确保令牌直到时间结束都是唯一的(字面上)。做到这一点最简单的方法是拥有一个活动状态，并存储该令牌是否活动。这样，数据库中有一个内置的约束，防止我们创建重复的会话令牌，包括那些被停用的会话令牌。</p><p id="fd75" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">类似于validate和get会话数据函数，该函数的输入也是一个对象，其属性是会话ID。然后，我们运行<code class="du np nq nr ns b">UpdateItem</code>操作，并将<code class="du np nq nr ns b">isActive</code>属性设置为false，并返回更新后的会话信息。</p><p id="5136" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们还将<code class="du np nq nr ns b">UpdateItem</code>命令的<code class="du np nq nr ns b">ReturnValues</code>属性设置为<code class="du np nq nr ns b">ALL_NEW</code>，告诉DynamoDB在更新项目后返回所有属性。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h1 id="83a7" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">使用SAM进行本地测试和部署</h1><p id="b9bd" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated"><a class="ae iu" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/what-is-sam.html" rel="noopener ugc nofollow" target="_blank">无服务器应用模型(SAM) </a>是一个帮助我们构建、测试、打包和部署无服务器应用的框架。在我们的例子中，我们将使用它来测试和部署我们刚刚创建的Lambda函数。</p><h2 id="9d02" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">山姆是如何工作的</h2><p id="2e28" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了在本地测试Lambda函数，SAM使用Docker创建一个执行环境，并基于SAM模板执行函数。为了打包和部署这些功能，SAM使用了S3和AWS CloudFormation。</p><h2 id="c021" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">SAM模板</h2><p id="1e35" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">SAM模板是一个YAML文件，它提供了所需的信息，比如函数的运行时间和函数代码的位置。</p><p id="5596" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在模板的顶部，我们提供了应用程序的描述和CloudFormation所需的一些基本信息，这是我们不必担心的。</p><p id="2db2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在参考资料部分，我们有三个刚刚创建的函数，它们都是类型<code class="du np nq nr ns b">AWS::Serverless::Function</code>，即一个Lambda函数。</p><p id="2cd3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后，我们为<code class="du np nq nr ns b">Properties</code>下的每个函数提供以下属性:</p><ol class=""><li id="3814" class="ll lm hi ix b iy iz jc jd jg ln jk lo jo lp js lq lr ls lt bi translated"><code class="du np nq nr ns b">CodeUri</code> —包含代码的目录的相对路径</li><li id="da94" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated"><code class="du np nq nr ns b">Handler</code>—Lambda处理函数，在我们的例子中是<code class="du np nq nr ns b">index.lambdaHandler</code>，也就是我们在<code class="du np nq nr ns b">index.js</code>中导出的<code class="du np nq nr ns b">lambdaHandler</code>函数。</li><li id="7ba6" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js lq lr ls lt bi translated"><code class="du np nq nr ns b">Runtime</code>—Lambda函数的执行环境，将为<code class="du np nq nr ns b">nodejs12.x</code>。</li></ol><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h2 id="0e2c" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">设置AWS凭据</h2><p id="bc87" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了通过AWS认证，我们需要我们的a <em class="lk">访问密钥ID </em>和s <em class="lk"> ecret访问密钥。</em>您可以通过点击AWS仪表板中您的用户名下的<em class="lk">我的安全凭证</em>来获取它们。在<em class="lk">您的安全凭证</em>页面中，在访问密钥部分下单击<em class="lk">创建新的访问密钥。确保记下或下载s <em class="lk">密码进入键</em>，因为它不会再出现。</em></p><div class="ma mb mc md fd ab cb"><figure class="od ij oe of og oh oi paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/aaeceef6a1376110d1fa6f691fe2cebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/1*scKKWSnjfzJELmbao-61EA.png"/></div></figure><figure class="od ij oj of og oh oi paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/7cb26d86ac6bf6c674101c234f13b39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1588/format:webp/1*ZSq9FGlxGXUjmgolEtdMQw.png"/></div></figure></div><p id="daa9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以使用AWS CLI 、凭证文件或环境变量来设置您的AWS凭证<a class="ae iu" href="https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-getting-started-set-up-credentials.html" rel="noopener ugc nofollow" target="_blank">。要使用环境变量设置您的凭证，请在您的终端中运行以下命令。</a></p><pre class="ma mb mc md fd nt ns nu nv aw nw bi"><span id="ac1b" class="kw ju hi ns b fi nx ny l nz oa">$ export AWS_ACCESS_KEY_ID=<em class="lk">your_access_key_id</em><br/>$ export AWS_SECRET_ACCESS_KEY=<em class="lk">your_secret_access_key</em></span></pre><h2 id="78d8" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">调用函数</h2><p id="61c2" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">要启动一个dev服务器，它将是调用我们的Lambda函数的端点，运行<code class="du np nq nr ns b">sam local start-lambda</code>。默认情况下，该命令将在<code class="du np nq nr ns b">localhost:3001</code>启动服务器。</p><p id="c199" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设您有一个<code class="du np nq nr ns b">/login</code>端点。一旦您验证了用户输入的凭证是正确的，您将调用带有用户信息的<code class="du np nq nr ns b">CreateUserSessionFunction</code>作为输入，然后将来自输出的<code class="du np nq nr ns b">sessionId</code>存储在用户的cookies中。这样，每次用户向您的后端发送请求时，您都可以从cookies中获得<code class="du np nq nr ns b">sessionId</code>，并使用该<code class="du np nq nr ns b">sessionId</code>作为输入来调用<code class="du np nq nr ns b">GetSessionInfoFunction</code>，从而获得会话信息。</p><p id="b39b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要使用AWS JavaScript SDK for node调用该函数，可以使用下面的代码。它调用SAM模板文件中提到的<code class="du np nq nr ns b">GetSessionInfoFunction</code>。</p><figure class="ma mb mc md fd ij"><div class="bz dy l di"><div class="ob oc l"/></div></figure><h2 id="6092" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">部署功能</h2><p id="ca8a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">最后，要打包函数run <code class="du np nq nr ns b">sam build</code>并将其部署到AWS，运行<code class="du np nq nr ns b">sam deploy</code>。真的就那么简单！</p><p id="bcf2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要调用部署中的函数，请从上面的示例中删除端点，这样就可以开始了！</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><h1 id="4da3" class="jt ju hi bd jv jw ok jy jz ka ol kc kd ke om kg kh ki on kk kl km oo ko kp kq bi translated">结论</h1><p id="2ee9" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们可以有很多方法来进行会话认证，正如前面提到的，使用我们刚刚在Lambda和DynamoDB中使用的方法并不适合每种用例，尤其是不适合单片应用程序。</p><p id="9d71" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">总的来说，我们的方法和无服务器的伟大之处在于，它从第一天起就为生产做好了准备。而且用更少的努力，我们的方法就像一些使用jwt的更安全的方法一样安全。</p><h2 id="6b11" class="kw ju hi bd jv kx ky kz jz la lb lc kd jg ld le kh jk lf lg kl jo lh li kp lj bi translated">下一步怎么样</h2><ul class=""><li id="2280" class="ll lm hi ix b iy kr jc ks jg mg jk mh jo mi js op lr ls lt bi translated">您可以尝试使用像Redis这样的内存数据库来获得最佳性能。</li><li id="80a9" class="ll lm hi ix b iy lu jc lv jg lw jk lx jo ly js op lr ls lt bi translated">使用一个<code class="du np nq nr ns b">.env</code>文件或凭证文件来存储您的AWS凭证，这样您就不必每次都设置环境变量。</li></ul><p id="6ebf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">教程的最终代码可以在GitHub的<em class="lk"/><a class="ae iu" href="https://github.com/shreyas44/session-auth-tutorial" rel="noopener ugc nofollow" target="_blank"><em class="lk">shreyas 44/session-auth-tutorial</em></a>找到</p></div></div>    
</body>
</html>