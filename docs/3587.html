<html>
<head>
<title>Complete guide to Pandas library (Python Code) — Part 1 / 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">熊猫图书馆完整指南(Python代码)——第1 / 4部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/complete-guide-to-pandas-library-python-code-part-1-4-420cd5bd8249?source=collection_archive---------9-----------------------#2021-07-11">https://medium.com/analytics-vidhya/complete-guide-to-pandas-library-python-code-part-1-4-420cd5bd8249?source=collection_archive---------9-----------------------#2021-07-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6513" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我作为数据科学家的职业生涯中，我亲自实现了许多东西，今天在这篇文章中，我将重点关注一个Python库，它真正帮助我度过了所有困难的分析情况，从基本到高级数据操作和使用Pandas库的探索技术。</p><p id="d51b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">熊猫图书馆就像你想象的那样强大。以这种方式，无论你开始哪种类型的项目，你都将使用熊猫来开始它的探索。</p><h2 id="02e0" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">索引</h2><ol class=""><li id="69c6" class="jx jy hh ig b ih jz il ka ip kb it kc ix kd jb ke kf kg kh bi translated">导入数据</li><li id="e26e" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb ke kf kg kh bi translated">索引、子集设置、选择</li><li id="0d86" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb ke kf kg kh bi translated">数据类型转换(日期/时间戳)</li><li id="2c22" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb ke kf kg kh bi translated">处理缺失数据</li><li id="e6a1" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb ke kf kg kh bi translated">数据汇总</li></ol><p id="f3d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个例子，我们将使用一个关于心脏病的数据集，在这里获取数据<a class="ae kn" href="https://www.kaggle.com/rashikrahmanpritom/heart-attack-analysis-prediction-dataset" rel="noopener ugc nofollow" target="_blank"/>。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="10df" class="jc jd hh kt b fi kx ky l kz la"><em class="lb">## Import Essential Libraries</em></span><span id="481b" class="jc jd hh kt b fi lc ky l kz la">import pandas as pd<br/>import numpy as np</span><span id="2c73" class="jc jd hh kt b fi lc ky l kz la"><em class="lb">## To let pandas display max columns , rows</em></span><span id="6da4" class="jc jd hh kt b fi lc ky l kz la">pd.options.display.max_rows = 500<br/>pd.options.display.max_columns = 500</span></pre><h2 id="0bc5" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">导入数据</h2><p id="ef19" class="pw-post-body-paragraph ie if hh ig b ih jz ij ik il ka in io ip ld ir is it le iv iw ix lf iz ja jb ha bi translated">根据文件格式的类型，Pandas有几种导入数据集的方法。</p><ul class=""><li id="699e" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated">CSV格式(<em class="lb">注意:将数据文件保存在与jupyter笔记本相同的目录中，否则使用完整路径)</em></li></ul><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e8b4" class="jc jd hh kt b fi kx ky l kz la">df = pd.read_csv("heart.csv")</span></pre><ul class=""><li id="76dd" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated">Excel格式</li></ul><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="35ef" class="jc jd hh kt b fi kx ky l kz la">df = pd.read_excel("heart.xlsx"  , sheet_name = '')</span></pre><p id="60d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些只不过是pandas提供给你的几个工具，你可以用它们作为阅读器功能将数据读入pandas。类似地，如果您想在EDA过程结束时导出数据集，您可以使用它们的writer函数作为<em class="lb"> pd.to_csv() </em>和pd。<em class="lb"> to_excel()。</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="569e" class="jc jd hh kt b fi kx ky l kz la">df.head()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/c08eb468b9886d155912b6e52eabbde9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cejv-KW3EdhpIx2lUGdNZA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图片由<a class="lw lx ge" href="https://medium.com/u/7a227215482f?source=post_page-----420cd5bd8249--------------------------------" rel="noopener" target="_blank"> Vijay yadav </a>提供</figcaption></figure><p id="b765" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">快速浏览数据集总是一个更好的开始，您可以使用head方法查看前几行，同样，如果您需要查看数据集的最后几行，您可以通过。tail()方法。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="974a" class="jc jd hh kt b fi kx ky l kz la">df.tail()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ly"><img src="../Images/7ea9c0e3e68ec547a29d63540a3ae3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TN00TPRy7pyEPsGXg3WLA.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图片由<a class="lw lx ge" href="https://medium.com/u/7a227215482f?source=post_page-----420cd5bd8249--------------------------------" rel="noopener" target="_blank"> Vijay yadav </a>提供</figcaption></figure><h2 id="fe9c" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">索引、子集设置、选择</h2><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lz"><img src="../Images/e78357be29656159eb575d85a1c74e96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7JqOE6KiEvE5xG8-"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">照片由<a class="ae kn" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">米卡·鲍梅斯特</a>在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="8bf8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请记住使用excel表格时的筛选功能，如何简单地选择和处理数据子集，如何从整个数据集中选择任何特定的数据并对其进行几乎所有的操作。这正是Python索引操作符“[ ]”和属性操作符“.”的用法在熊猫工作。</p><p id="6b9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本上我们将使用基于标签的索引<strong class="ig hi">。loc、</strong>和<strong class="ig hi"> </strong>基于整数的索引<strong class="ig hi">。iloc </strong>用于多轴分度。仔细理解这一点，这很棘手但非常重要。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6dd5" class="jc jd hh kt b fi kx ky l kz la">df.loc[:]</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ma"><img src="../Images/5381c9ec0ba64b5de6c57ad336cdddb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ny9eZd_1JMR80SfQRwfDdg.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图片由<a class="lw lx ge" href="https://medium.com/u/7a227215482f?source=post_page-----420cd5bd8249--------------------------------" rel="noopener" target="_blank"> Vijay yadav </a>提供</figcaption></figure><blockquote class="mb mc md"><p id="3477" class="ie if lb ig b ih ii ij ik il im in io me iq ir is mf iu iv iw mg iy iz ja jb ha bi translated"><strong class="ig hi"> LOC(行索引器、列索引器)</strong></p></blockquote><p id="5072" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lb"> loc </em>方法有两个输入，第一个称为行索引器，它将索引标签作为值，第二个参数称为列索引器，它将列标签作为选择数据的标识符，符号“:”表示要子集化的值的范围。<br/>假设您没有提供任何值，但提供了':'符号，如上例所示，loc方法默认显示数据集的每个标签。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8d31" class="jc jd hh kt b fi kx ky l kz la">df.loc[0:5]</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mh"><img src="../Images/ba3eef3b2b86e351aec6f22bc0c2142e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EL-qP8vzyuIS9cjjMmpFXA.png"/></div></div></figure><p id="38fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个例子中，我们提到了从索引标签0到5中进行选择的loc方法，因为没有指定列标签，所以默认情况下它会选择所有的列标签。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6c33" class="jc jd hh kt b fi kx ky l kz la">df.loc[0:10,'age']</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div class="er es mi"><img src="../Images/4a500c735977c4ae1558b17f46f3b17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/format:webp/1*rf4B0uKxh7glvBPBQw5y0w.png"/></div></figure><p id="86e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本例中，我们只提到了一个列索引器标签“age ”,因此输出按照行索引器对数据进行行子集化，按照列索引器对数据进行列子集化。</p><p id="ba39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，我们可以对任意范围的数据进行切片，并在范围中随机指定其标签。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6ab3" class="jc jd hh kt b fi kx ky l kz la">df.loc[50:60 , ['age' , 'sex', 'cp']]</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div class="er es mj"><img src="../Images/41a7696ab7467f36f5b8103e7bcb8089.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*tcEolPtMeIh2NXoCmgwVFA.png"/></div></figure><p id="3f3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是一个有趣的结果，您可能会注意到，我们从范围50:60中指定了row_indexer，并且在列索引器中传递了一个列索引器列表。</p><p id="34d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，您可以想象在基于标签对数据集进行切片的情况下，这个工具是多么强大。</p><ul class=""><li id="9414" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated">单个标签，例如<code class="du mk ml mm kt b">5</code>或<code class="du mk ml mm kt b">'a'</code></li><li id="5d93" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">标签的列表或数组<code class="du mk ml mm kt b">['a', 'b', 'c']</code></li><li id="8f62" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">带标签的切片对象<code class="du mk ml mm kt b">'a':'f'</code></li></ul><blockquote class="mb mc md"><p id="f8bb" class="ie if lb ig b ih ii ij ik il im in io me iq ir is mf iu iv iw mg iy iz ja jb ha bi translated"><strong class="ig hi">。iloc基于整数的索引</strong></p></blockquote><p id="71e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基于整数的索引仅仅意味着通过整数索引定位任何特定的行或列(从轴的<code class="du mk ml mm kt b">0</code>到<code class="du mk ml mm kt b">length-1</code>)。这就是为什么这种方法可能是选择子集的更健壮的方法，因为它不会受到影响，即使列名在整个程序中被改变。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="02ca" class="jc jd hh kt b fi kx ky l kz la">df.iloc[50:55 , [ 0,6,10]]</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div class="er es mn"><img src="../Images/af4b2c8ac859b90b299c0ff3145c9218.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/1*vDKTF5TgClxTkDBR2p9Y4w.png"/></div></figure><p id="a8d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您所看到的，我们使用了50:55的行索引，通过指定它们各自的索引来子集化行和列索引。</p><h2 id="dddd" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">使用isin()函数进行选择</h2><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="aef1" class="jc jd hh kt b fi kx ky l kz la"># Create a new column <br/>old_age = list(range(60,100))</span><span id="f12b" class="jc jd hh kt b fi lc ky l kz la"># First Method<br/>df[df['age'] &gt; 60]</span><span id="1a38" class="jc jd hh kt b fi lc ky l kz la"># Second Method<br/>df['senior_citizens']  = df['age'].isin(old_age)</span><span id="7e89" class="jc jd hh kt b fi lc ky l kz la">df[df['senior_citizens'] == True ].head()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mo"><img src="../Images/641baba31f783d36a45d99ef52df95b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eswm_7OjdIQu-bs1WTUu5A.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图片由<a class="lw lx ge" href="https://medium.com/u/7a227215482f?source=post_page-----420cd5bd8249--------------------------------" rel="noopener" target="_blank"> Vijay yadav </a>提供</figcaption></figure><p id="002d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们随机创建了一个名为“老年人”的额外功能，给每个60岁以上的人贴上标签。在本例中，我们可以看到创建数据子集的两种方式。第一种方法使用一个简单的大于运算符来比较数值，这样我们就能得到正确的数据集。</p><p id="8561" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，如果我们有分类值或者需要比较多个值的条件，这种方法就没有用了。<br/>这就是我们使用<strong class="ig hi"> isin() </strong>函数的地方，它允许我们迭代列表或数组格式中提供的每个值。在这种方法中，即使原始变量“old age”的值或范围发生变化，我们也不需要担心我们的代码。因为我们使用的是isin()函数，所以只要变量存在，它就为真。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="588b" class="jc jd hh kt b fi kx ky l kz la">## Also you can index data by using the index of the data</span><span id="2e0c" class="jc jd hh kt b fi lc ky l kz la">df[df.index &gt; 10]</span><span id="4630" class="jc jd hh kt b fi lc ky l kz la">df[df.index.isin([2,5,7,8,4,5,7,8,7,5,4,3,5,7,8,84])]</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mp"><img src="../Images/581b8f101a68b758bd617d6886091acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uWAXAEgiigf6FWjOfwIVnQ.png"/></div></div></figure><h2 id="5a11" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">数据类型转换(日期/时间戳)</h2><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mq"><img src="../Images/3a2d8e5ee141863a1b7c42f844b9bc6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3Z2kP3LXnrHTQSay"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">照片由<a class="ae kn" href="https://unsplash.com/@waldemarbrandt67w?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">瓦尔德马·布兰德</a>在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="e132" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Pandas非常灵活地处理数据帧中的各种数据类型。因此，它也为将一个系列的任何给定数据类型转换为其他有效的数据类型提供了极大的可行性。<br/>例如，当您将数据从excel导入jupyter notebook for EDA时，日期列可能会转换为字符串格式，如果不将其转换回日期格式，则实际上无法使用。</p><p id="95d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们创建一个示例数据框架来演示这种情况。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6fee" class="jc jd hh kt b fi kx ky l kz la">import datetime</span><span id="f577" class="jc jd hh kt b fi lc ky l kz la">date = pd.date_range('2020/01/01', end = '2020/12/31' , freq= 'D')</span><span id="339f" class="jc jd hh kt b fi lc ky l kz la">df_date = pd.DataFrame(date , columns = {'Date'})<br/>df_date.head()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div class="er es mr"><img src="../Images/cc3323e5b422ee00c73445e0b09725a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:460/format:webp/1*c5fpqBoZIoeteoPVyFe-9Q.png"/></div></figure><p id="15ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">pandas中的此功能根据提供的属性创建一个日期范围，如指定的开始日期、结束日期，频率可以是日、周、月和年。</p><p id="edbe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">日期列<br/>的默认dypte是datetime。Datetimeindex，我们可以将其转换为object，反之亦然，只是为了演示。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f9c2" class="jc jd hh kt b fi kx ky l kz la">df_date['Date'] = df_date['Date'].astype('object')</span><span id="d62f" class="jc jd hh kt b fi lc ky l kz la">df_date['Date'] = df_date['Date'].apply(pd.to_datetime)</span></pre><p id="1a4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述函数将日期类型转换为对象，然后再转换回日期时间格式。同样，您可以使用这个方法来转换所需的列，或者为您希望解析为日期的列提供一个预检查。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="6ca6" class="jc jd hh kt b fi kx ky l kz la">df_date['Day Name']  = date.day_name()</span><span id="ac77" class="jc jd hh kt b fi lc ky l kz la">df_date['Month_Number'] = date.month</span><span id="e92a" class="jc jd hh kt b fi lc ky l kz la">df_date['Month_Name'] = date.month_name()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ms"><img src="../Images/4aff45efe838b7fbee3fb3e551ae53e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovd3pAwAmd61OZT-qjxztA.png"/></div></div></figure><p id="3ab1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如您在上面的代码中看到的，我们可以生成多个额外的特征，这对进一步分析、全面理解数据或只是为了自我探索非常重要。然而，当您必须处理日期时间格式时，pandas中的这个功能非常方便。</p><h2 id="72d5" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">处理缺失数据</h2><blockquote class="mb mc md"><p id="0fc7" class="ie if lb ig b ih ii ij ik il im in io me iq ir is mf iu iv iw mg iy iz ja jb ha bi translated">“由于数据以多种形状和形式出现，<a class="ae kn" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/missing_data.html" rel="noopener ugc nofollow" target="_blank"> pandas </a>旨在灵活处理缺失数据。虽然出于计算速度和方便的原因，<code class="du mk ml mm kt b">NaN</code>是默认的缺失值标记，但我们需要能够轻松地检测不同类型数据的值:浮点、整数、布尔和一般对象。”</p></blockquote><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mt"><img src="../Images/de0e415ba54c93220f47de12c91ba22b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CaERCcjbyBmmI8kC"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">布雷特·乔丹在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="0f2d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">处理缺失数据是任何预处理方法中最重要的步骤之一，事实上也是必不可少的步骤。缺失值就像缺失的乐高积木一样，可能会决定整个数据集的成败。识别缺失数据，找出缺失数据背后的原因，并选择适当的方法来估算数据是一项非常耗时耗力的任务，因此让我们来了解其中的一些方法。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="8af3" class="jc jd hh kt b fi kx ky l kz la"># First lets check if we have any null value in data</span><span id="5334" class="jc jd hh kt b fi lc ky l kz la">print("There are total {} null values".format(df.isnull().any().sum()))</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mu"><img src="../Images/61c8b00e378431a8b0009464a53f4d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u-WCtlQAUyAgDT4x9FQHLg.png"/></div></div></figure><p id="bd2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为我们的数据集中没有任何空值，所以让我们创建一些空值。我们可以简单地使用loc或iloc函数选择某些行，就像我们在本文前面讨论的那样，然后分配np.nan值。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f838" class="jc jd hh kt b fi kx ky l kz la"># assign null values to age and sex column.</span><span id="c6a4" class="jc jd hh kt b fi lc ky l kz la">df.loc[50:70, ['age' , 'sex']] = np.nan</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mv"><img src="../Images/912b582641429c9b96ed7083d93b2d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PHv0AsA8WVXMpm0PamiYdw.png"/></div></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="cb74" class="jc jd hh kt b fi kx ky l kz la"># now lets check again for any null value in data</span><span id="b16a" class="jc jd hh kt b fi lc ky l kz la">print("There are total {} null values".format(df.isnull().any().sum()))</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mv"><img src="../Images/ffdd341525225f2e3b4d7394c9281ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nmSgPN-nDfaMxfsbe-ZVg.png"/></div></div></figure><p id="5fe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们已经成功地将值np.nan赋给了这里的两列即“年龄”和“性别”，我们可以通过再次调用isnull()函数再次验证它。</p><p id="34e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">向缺失的列输入数据是一件需要在继续之前好好考虑的事情。在开始估算价值之前，先问问自己这些问题。</p><ul class=""><li id="289f" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated"><em class="lb">为什么数据首先会丢失，丢失的原因是实际原因、数据不可用还是数据不适用。</em></li><li id="8af9" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated"><em class="lb">不管怎样，有多少数据丢失了，它是如何代表全部数据的。</em></li><li id="d8dd" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated"><em class="lb">是我的失踪栏。包含数字或分类数据。</em></li><li id="5562" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">数据缺失是否有某种模式。</li></ul><p id="270a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，如你所见，在进入while数据插补过程之前，你可以尝试回答几个问题。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="163d" class="jc jd hh kt b fi kx ky l kz la">#First Method<br/>df.loc[50:70, ['age']] = 0</span><span id="ff03" class="jc jd hh kt b fi lc ky l kz la">#Second Method<br/>df['sex'] = df.loc[50:70, ['sex']].fillna(df['sex'].mode()[0])</span><span id="ed56" class="jc jd hh kt b fi lc ky l kz la">#Third Method<br/>df['age'] = df.loc[50:70, ['age']].fillna(df['age'].mean())</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mw"><img src="../Images/fd65e2cacd2dcca65461aaab537d1eaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Rv-53oB2jamLeBAk76E4A.png"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">图片由<a class="lw lx ge" href="https://medium.com/u/7a227215482f?source=post_page-----420cd5bd8249--------------------------------" rel="noopener" target="_blank"> Vijay yadav </a>提供</figcaption></figure><p id="cc11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个方法是一个简单的赋值方法，你可以简单地给这个列赋值，如果这个值没有任何意义的话，或者说你不确定应该放什么值，所以你只给每个人赋值“0”。</p><p id="d671" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，假设您缺少的列是一个分类值，您显然不能通过任何统计或聚合方法生成任何新值。在这种情况下，您可以查看哪个值在数据中出现得最多，并且您可以采用列的模式，通过访问第一个值来估算该值。<br/>当然，这不是最好的估算方法，但正如我之前所说，这取决于你对上述问题的回答。</p><p id="d8a7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似地，在第三种情况下，我们有Pandas的<strong class="ig hi"> fillna() </strong>函数，它很容易处理缺失值。使用fillna()，缺失值可以由特殊值或聚合值(如平均值、中值)替换。此外，使用向前填充方法和向后填充方法，可以用缺失值之前或之后的值替换缺失值，这对于时间序列数据集非常有用。</p><h2 id="f765" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">删除缺少的值</h2><ul class=""><li id="1c63" class="jx jy hh ig b ih jz il ka ip kb it kc ix kd jb lj kf kg kh bi translated"><em class="lb">什么时候应该考虑从数据集中删除任何值？</em></li></ul><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mx"><img src="../Images/0ed25ec39fdfab852830349b36aa8604.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7puE_LbpJEd5V1hU"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">辛蒂娅·玛丽莎在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="b715" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很简单，假设您有1000行数据，而您只有10行或最多100行空值，这相当于最多10%的数据。删除这么多记录可能不会影响您的整体数据集质量或任何基础信息(大多数情况下)，但是它肯定会使您的数据集在丢失值记录方面更加整洁。记住这是一个权衡，是否值得将取决于数据集本身或具体情况。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f4a1" class="jc jd hh kt b fi kx ky l kz la">df.dropna(axis=0, inplace=True)</span><span id="9309" class="jc jd hh kt b fi lc ky l kz la">print("There are total {} null values".format(df.isnull().any().sum()))</span><span id="9212" class="jc jd hh kt b fi lc ky l kz la">print("Updated Shape of the dataset is {}".format(df.shape))</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es my"><img src="../Images/e317ab0c6e2ce9824150f26c0ba03e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G4Dw2JMqYNtms-FqTvz2_w.png"/></div></div></figure><p id="a647" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请注意，我们现在总共有“0”个空值，但是数据集的总形状从303行减少到282行。这意味着我们已经成功地删除了所有具有NaN或缺失值的行，从而使我们的数据集没有缺失值。此外，我们使用(<strong class="ig hi">轴= 0) </strong>，因为我们打算跨行删除丢失的值。</p><p id="562b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当我们使用值为true的<strong class="ig hi"> "inplace" </strong>属性时，该函数会从原始数据集中删除这些行，因此这是对原始数据集所做的永久更改，并且无法恢复。解决方法是在删除前创建数据集的副本，或者在删除时创建数据集的另一个实例。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="c6c9" class="jc jd hh kt b fi kx ky l kz la">upated_dataset = df.dropna(axis=0) ## assigning new instance of Data</span><span id="dd64" class="jc jd hh kt b fi lc ky l kz la">print("There are total {} null values in the Updated dataset".format(df.isnull().any().sum()))<br/>print("Updated Shape of the new dataset is {}".format(df.shape))</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es mz"><img src="../Images/2727e0c1c427ba897fef896eb934524a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOHlZEbl4ZYwhV-JYCzh1w.png"/></div></div></figure><h2 id="ac36" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">数据汇总</h2><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es na"><img src="../Images/7bf5b389fe23f39724caac3be6824e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QCOXEjiJ8uK49HYj"/></div></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">照片由<a class="ae kn" href="https://unsplash.com/@kchance8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">凯尔西·钱斯</a>在<a class="ae kn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fda5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">太棒了，你已经完成了本文的最后一部分，我希望一切顺利。汇总是任何数据分析过程的关键，我们还没有完成，因为使用pandas进行<strong class="ig hi">数据争论、绘图、可视化和统计建模</strong>还有很多事情要做，这些将分别在本系列的第2、3和4部分中介绍。<br/>但是首先，让我们习惯一些总结技巧。</p><p id="fb6e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">内容:</strong> <em class="lb"> info()、describe()、value_counts()、nunique()、groupby()。</em></p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="861b" class="jc jd hh kt b fi kx ky l kz la"># This method prints information about a DataFrame including the index dtype and columns, non-null values and memory usage.</span><span id="5ef0" class="jc jd hh kt b fi lc ky l kz la">df.info()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nb"><img src="../Images/8bc902161206fb10bb86c2cacd33db5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiR1lQcwRIJ5enqljGxrqA.png"/></div></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b20c" class="jc jd hh kt b fi kx ky l kz la"># This function will describe you numerical as well as categorical data will all important stats at a glance.</span><span id="529e" class="jc jd hh kt b fi lc ky l kz la">df.describe(percentiles=None, include=None, exclude=None, datetime_is_numeric=False)</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nc"><img src="../Images/29ddfc7f829fcb29b6bad6ac6766a322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VkLUaYPqAxguWC_r_lJNQ.png"/></div></div></figure><ul class=""><li id="adb0" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated"><strong class="ig hi">百分点</strong>属性表示数据集的四分位数范围(数据的25%、50%和75%)</li><li id="1d19" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated"><strong class="ig hi"> std </strong>是观察值的标准偏差，<strong class="ig hi"> mean </strong>是数值的平均值</li><li id="3cbf" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated"><strong class="ig hi"> Count </strong>是观测值的总数，<strong class="ig hi"> min -max </strong>是数据集中的最小值和最大值。</li></ul><p id="b46e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">默认情况下，这个函数只对数字列有效，但是如果您想对分类值有一个很好的描述，您可以通过包含一个“include”对象来实现。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="580d" class="jc jd hh kt b fi kx ky l kz la"># In my dataset , I only have one categorical column.</span><span id="bce7" class="jc jd hh kt b fi lc ky l kz la">df.describe(include='object')</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div class="er es nd"><img src="../Images/a30fc61d47b7994c123b40c7c3135cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*pnAjXGLWk6LVrA-py3L5AA.png"/></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="f569" class="jc jd hh kt b fi kx ky l kz la"># value_counts() function will give you the count of all different types of values available in the Dataframe or series.</span><span id="7aa0" class="jc jd hh kt b fi lc ky l kz la">df['senior_citizens'].value_counts()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ne"><img src="../Images/4eaf1b2b7b3569ea87a81d7ecb2923f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yA9NjJI1we0cVTg1U4XD3w.png"/></div></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="ed2a" class="jc jd hh kt b fi kx ky l kz la"># unique() and nunique() function will give you all the unique values in a particular series and number of unique values in the series respectively.</span><span id="3d2a" class="jc jd hh kt b fi lc ky l kz la">df['senior_citizens'].unique()</span><span id="041f" class="jc jd hh kt b fi lc ky l kz la">df['senior_citizens'].nunique()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nf"><img src="../Images/f522c14a5159aedd1fb4c0a6d80333ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*atWU6E2bZHp53nxpHUUHxw.png"/></div></div></figure><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="b406" class="jc jd hh kt b fi kx ky l kz la">## A groupby operation involves some combination of splitting the object, applying a function, and combining the results. This can be used to group large amounts of data and compute operations on these groups.</span><span id="7ce7" class="jc jd hh kt b fi lc ky l kz la">df.groupby('sex').count()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ng"><img src="../Images/ad4c0fa9fb36cbe6be62e17aa788c0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3QwLdZDsCw2VKUjxtDsmQ.png"/></div></div></figure><p id="d03a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，函数的第一个参数是“by”参数，它将根据该参数对所有列的其余部分进行分组。类似地，您可以使用任何其他分类特性对其余的列进行分组。它还可以将值列表作为“by”参数，并将创建一个多索引数据帧。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="e742" class="jc jd hh kt b fi kx ky l kz la">df.groupby(['sex' , 'senior_citizens']).count()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es nh"><img src="../Images/a3cda212471d93af2a8a534879832123.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PECpOtPN20h_YzdnBxaMTg.png"/></div></div></figure><p id="3b2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，您可以筛选出想要实际分组的列数，并只显示这些特定列的结果。使用列表理解来传递列的标签。</p><pre class="ko kp kq kr fd ks kt ku kv aw kw bi"><span id="252b" class="jc jd hh kt b fi kx ky l kz la">df.groupby(['sex' , 'senior_citizens'])[['age' , 'cp' , 'chol' , 'fbs']].count()</span></pre><figure class="ko kp kq kr fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es ni"><img src="../Images/89c695809c7ae2675d84e0cd3b50abb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MU4jmu4LTXzOVOHGv675rQ.png"/></div></div></figure></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="468c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论。</strong></p><ul class=""><li id="5fac" class="jx jy hh ig b ih ii il im ip lg it lh ix li jb lj kf kg kh bi translated">我们使用了几种方法通过pandas库、read.csv()和read.excel()导出数据。</li><li id="48ed" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">使用基于标签或基于整数的标签，通过loc、iloc函数对数据进行选择和索引。</li><li id="62d0" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">我们还了解了如何处理数据帧中的日期数据类型、日期时间函数中的不同参数，以及如何使用它来创建新功能。</li><li id="3416" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">处理缺失值并确定缺失值背后的原因。</li><li id="83ea" class="jx jy hh ig b ih ki il kj ip kk it kl ix km jb lj kf kg kh bi translated">Pandas提供了多种数据汇总功能，这使得对数据集的探索变得更加容易和有趣。</li></ul></div><div class="ab cl nj nk go nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ha hb hc hd he"><p id="f7e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">感谢你阅读我文章的第一部分。现在，您对基本功能有了很好的理解，现在可以进入第2部分，继续阅读数据争论文章。</p><h1 id="554d" class="nq jd hh bd je nr ns nt ji nu nv nw jm nx ny nz jp oa ob oc js od oe of jv og bi translated">其他文章。</h1><ul class=""><li id="3746" class="jx jy hh ig b ih jz il ka ip kb it kc ix kd jb lj kf kg kh bi translated"><a class="ae kn" href="https://datasciencestuff.medium.com/complete-guide-to-pandas-library-python-code-part-2-4-4c0d9d9bd511" rel="noopener">第二部</a>和<a class="ae kn" href="https://datasciencestuff.medium.com/complete-guide-to-pandas-library-python-code-part-3-4-6bc11f9465d0" rel="noopener">第三部</a>在这里链接，如果你还没有看的话，一定要看看。</li></ul></div></div>    
</body>
</html>