<html>
<head>
<title>Decision Trees For Classification (ID3)| Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">分类决策树(ID3)|机器学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/decision-trees-for-classification-id3-machine-learning-6844f026bf1a?source=collection_archive---------1-----------------------#2021-07-05">https://medium.com/analytics-vidhya/decision-trees-for-classification-id3-machine-learning-6844f026bf1a?source=collection_archive---------1-----------------------#2021-07-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="48a1" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">决策树和如何构建决策树概述</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/40ebd068cdcd1a310af91f6d171b9d6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*puaHe0wm9zXZDECLx__Bfw.png"/></div></div></figure><p id="63e3" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">决策树是一种机器学习算法，可用于分类和回归(在这种情况下，它将被称为回归树)。这个博客集中在分类决策树上。</p><h1 id="9fda" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">什么是决策树？</h1><p id="b9f7" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">决策树类似于计算机科学树，具有层次结构。它有节点，这些节点由边连接。决策树通过在每个节点提问来对数据进行分类。(<em class="ke">在典型情况下，如果答案是肯定的，就去找合适的孩子。如果没有，就去左边的孩子</em>。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lc"><img src="../Images/65271229ae3b31cdf7e5413ae744c3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ej7mRKn1WUpTmuZ1Mjbecg.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图1.1:一个示例决策树</figcaption></figure><p id="a90e" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">图1.1显示了一个简单的决策树，用于对客户是否获得贷款进行分类。输入特征是人的工资、孩子的数量和人的年龄。决策树使用这些属性或特征，并在正确的步骤或节点提出正确的问题，以便分类是否可以向该人提供贷款。</p><h2 id="0279" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">术语</h2><p id="496d" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在进一步深入之前，有一些重要的术语需要理解。这些术语参照图1.1进行说明。</p><p id="421b" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">节点</strong>:上面显示的蓝色矩形就是我们所说的树的节点。在决策树中，在每个节点上提出一个问题，根据答案，给出某个选定的结果。</p><p id="aa03" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">根节点或根</strong>:在决策树中，最顶层的节点称为<strong class="jk hi">根节点。</strong>在上面的树中，询问“年龄30岁以上？”是根节点。</p><p id="0d1c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi">叶节点</strong>:没有任何子节点的节点称为叶节点。(<em class="ke">获得贷款，不获得贷款</em>)。叶节点保存输出标签。</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="7d5d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">上面决策树的高度是3，在最顶层，我们有根节点，在最底层，我们有叶节点。尽管在图1.1中所有的叶节点都在同一层，但情况可能并不总是这样。在上面的决策树中，每个节点有两个子节点。这很常见，但并不总是如此。如果为一个节点选择了具有多于2个结果的特定分类特征来分割实例，则该节点的子节点的数量也可以多于2个。</p><h1 id="856a" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">熵和信息增益</h1><p id="9d62" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在进入如何构建决策树之前，我们需要了解什么是<strong class="jk hi">熵</strong>和<strong class="jk hi">信息增益。</strong></p><h2 id="ce07" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">熵</h2><p id="4c64" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">它是节点杂质的量度。通过杂质，我们的意思是测量一个特定节点的异质性。<br/> <strong class="jk hi">例如:</strong> <br/>假设我们一组有50个红球和50个蓝球。在这种情况下，两种颜色的球的比例相等。因此，熵将是1。也就是说这个布景不纯。<br/>但是，如果该组有98个红球和2个蓝球，而不是50–50的比例<em class="ke">(同样的逻辑可以适用于一组98个蓝球和2个红球|哪一类并不重要。重要的是一个类别远远超过另一个类别)</em>，那么熵将会很低<em class="ke">(接近0的某个地方)。</em>这是因为现在该套球基本上是纯净的，因为它主要包含属于一个类别的球。正因为如此，异质性降低了。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mc"><img src="../Images/246e69807f4be2164b75cb1d789085cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*KgxR5zjsqFM4SFzlAXmiwA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图2.1:熵公式</figcaption></figure><p id="ba7f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">图2.1是一个表示熵的好函数。<strong class="jk hi"> C </strong>是班级人数。<strong class="jk hi"> Pi </strong>是该集合中第<strong class="jk hi"> i </strong>类的比例。已经表明，这个函数足以很好地代表异质性。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es md"><img src="../Images/e1f0bba0d5c199e33d3475bf2858bd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*SzLfZV2X4yspiFFnrHaBdA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图2.2:两类的熵图。</figcaption></figure><p id="4c17" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们以两个类为例。图2.2表示了随着属于特定类别的实例数量的比例变化，熵的变化</p><p id="cd43" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated"><strong class="jk hi"> <em class="ke">注:</em> </strong> <em class="ke">在一个2类问题中，一类的比例永远会是1 —(另一类的比例)。所以，一类的比例足以画出这个熵图。</em></p><p id="9c66" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">假设图2.2的x轴代表集合中<strong class="jk hi">A类</strong>的比例。由于更接近于0，我们确定另一个类(<strong class="jk hi">B类</strong>)在集合中占优。因此，同质性得以保持，集合更接近纯净，因此熵较低。(<em class="ke">当A类的比例更接近1 </em>时也是如此)。但是当两个类在给定的集合中几乎具有相等比例的实例时，杂质就高，并且是高度异质的。因此，熵很高。因为该函数满足所有情况，所以它可以用作给定集合的杂质的良好度量。</p><h2 id="28df" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">信息增益</h2><p id="5986" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">并不是决策树在每个节点随机提问才能得出结论。我们在正确的时间问正确的问题，以确保熵在特定的水平上尽可能地减少。这样做是为了尽可能快地在所有叶节点上获得同质性，并且得到同样简单的最佳分类树。</p><p id="2027" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">简单地说，我们的目标是使用熵来得出一个小而简单的树，并具有良好的分类精度。这是通过在下一步减少总熵来实现的。为了减少熵，我们需要理解在特定的节点上，哪一个属性是提问的最佳属性。这是通过一种叫做信息增益的方法来实现的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es me"><img src="../Images/103616061be4c2cbbc9a787393d12a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EZDb-zLv5nrHoU6E-owHmA.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图2.3:信息增益公式</figcaption></figure><p id="1d61" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在一个特定的节点，计算数据集中所有特征的信息增益，以检查哪个特征在下一级减少的熵更多。这是通过将父项的熵减去下一个直接子项的熵的加权和来实现的，如果选择了某个特定的特征，我们就会得到该子项。在特定节点获得最高信息增益的特征或属性或问题被选择作为在当前节点拆分数据的问题。<br/>分配给每个子节点熵的权重基于该子节点中实例的比例。因此，不需要太多的努力，我们就可以看到这个公式做了它应该做的事情。</p><h1 id="dbdb" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">构建决策树以便更好地理解</h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mf"><img src="../Images/567ef1d1c2a4a02b91f81151e29d3ed0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*hID4-LuYwP-Z36qNvFx8gA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图3.1:数据集</figcaption></figure><p id="0326" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">现在数据集已经准备好了，让我们来构建树。作为第一步，我们需要选择根节点。因此，需要计算X、Y和Z的信息增益。</p><h2 id="4a8f" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">在X轴上分割</h2><p id="5b34" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">当我们用X作为根节点时，这就是我们得到的。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/11f36c1036e49b578054fcdf9ce549f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UacHGmDwzd8uj_lNmNADnQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图3.2:在X轴上分割</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mh"><img src="../Images/1362c7e254aa553a76e5ae4795726982.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*3dnbd0UR2kfAqMWXOMlPZw.png"/></div></figure><h2 id="07b5" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">在Y轴上拆分</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/55de02c829a7536625f874c7e563ac01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kRGEthDN0VlWy48cQzQhZg.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图3.3:在Y轴上分割</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mi"><img src="../Images/6eccda4aa7bcab76c26013ccdff2fd0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*H33x2Ca1BDAls-UJ4yR50g.png"/></div></figure><h2 id="761b" class="lh kg hh bd kh li lj lk kl ll lm ln kp jr lo lp kr jv lq lr kt jz ls lt kv lu bi translated">在Z轴上分割</h2><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mg"><img src="../Images/c883b7c40a494aab80ff935e9ff460bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*itxIn3x4Z253Rtfp4-Iu6Q.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图3.4:在Z轴上分割</figcaption></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mj"><img src="../Images/71d54f6b20dede23193554bb4418a57a.png" data-original-src="https://miro.medium.com/v2/resize:fit:840/format:webp/1*BDsZYg9VsYPPzUOcx8vnfA.png"/></div></figure></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><p id="2196" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">从上面的3次分割中，我们可以看到，当我们使用特征<strong class="jk hi"> Y. </strong>分割数据集时，信息增益最大。因此，我们可以在根节点使用Y。但是，当我们在根节点使用Y时，我们也可以看到两个叶节点都变成了纯叶节点<em class="ke">(只包含一个类的对象。</em>非0即1。因此，我们可以在这个阶段停止构建树。其他特征已经变得多余，因为<strong class="jk hi"> Y </strong>本身能够完美地对所有数据进行分类。</p><p id="702c" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">因此，生成的决策树如图3.3所示。在给出新数据时，该树将检查该数据的属性<strong class="jk hi"> Y </strong>是0还是1，并将根据它对新数据进行分类。</p><p id="99fc" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">如果Y不能完美地对数据进行分类，并且其中一个叶节点不纯，我们可以继续使用该节点上的其他两个特征来进一步构建决策树，直到我们获得纯叶节点。</p><h1 id="783e" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">连续变量</h1><p id="cf80" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">到目前为止，我们已经看到了决策树如何在分类特征上使用熵和信息增益来选择最佳分割。但是，这如何对连续变量起作用呢？</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mk"><img src="../Images/eed903065077e9afee26a759ac802d07.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*slwgtkq3EZPovkuJ5czZeQ.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图4.1:样本数据集</figcaption></figure><p id="8978" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">让我们考虑图4.1中的数据集，其中X是连续变量，Y是因变量。在这里，决策树选择某些点在其节点上提问。</p><p id="2c1d" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在选择点之前，算法将按x对数据集进行排序。<br/>上例中的点将是:(13+20)/2，(20+25)/2，(25+40)/2。<br/> = &gt; 16.5，22.5，32.5。</p><p id="c1ea" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在根节点中，我们评估应该使用哪个点来分割数据集，类似于我们如何使用分类特征来分割。<br/>例如，数据是否应该在<strong class="jk hi"> <em class="ke"> (x≤16.5) </em> </strong>或<strong class="jk hi"> <em class="ke"> (x≤22.5) </em> </strong>或<strong class="jk hi"> <em class="ke"> (x≤32.5) </em> </strong>或<strong class="jk hi"> <em class="ke"> (x &gt; 32.5) </em> </strong>上拆分，根据哪个拆分提供最高的信息增益来选择。在本例中，不难看出将选择<strong class="jk hi"> x≤22.5 </strong>，因为它最好地分割了因变量</p><p id="9a2f" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">当我们基于所有这些间隔分割数据并计算所有数据的信息增益时，当数据集很大时，这个过程在计算上变得昂贵。</p></div><div class="ab cl lv lw go lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ha hb hc hd he"><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/01253322fb7b845d04ca687f5a79d2f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hNfx9gKnIHMshr88Tpo10w.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">图5.1:决策树示例</figcaption></figure><p id="21b2" class="pw-post-body-paragraph ji jj hh jk b jl jm ii jn jo jp il jq jr js jt ju jv jw jx jy jz ka kb kc kd ha bi translated">在上面所有的例子中，我使用了定制的数据集(来自多个来源的<em class="ke"/>),这样就可以做出简短的决策树。这是为了计算的目的。这是一个决策树的例子，它的分类显示在二维空间中。</p><h1 id="c01e" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">何时停止构建树</h1><ul class=""><li id="9b69" class="mm mn hh jk b jl kx jo ky jr mo jv mp jz mq kd mr ms mt mu bi translated">当所有叶节点都是纯的时(<em class="ke">叶节点具有属于一个类别</em>的数据)</li><li id="3cc2" class="mm mn hh jk b jl mv jo mw jr mx jv my jz mz kd mr ms mt mu bi translated">当满足特定标准时(<em class="ke">例如树的高度超过特定限制，在这种情况下，叶节点可能不是纯的，而是可能输出类的概率而不是类本身</em></li><li id="82c4" class="mm mn hh jk b jl mv jo mw jr mx jv my jz mz kd mr ms mt mu bi translated">当所有功能都被使用时。</li></ul><h1 id="39f6" class="kf kg hh bd kh ki kj kk kl km kn ko kp in kq io kr iq ks ir kt it ku iu kv kw bi translated">结论</h1><p id="846a" class="pw-post-body-paragraph ji jj hh jk b jl kx ii jn jo ky il jq jr kz jt ju jv la jx jy jz lb kb kc kd ha bi translated">在这篇博客中，我们看到了什么是决策树和其他一些基本术语，以及如何建立一个，给定数据集和何时停止建立树。尽管决策树很强大，但它们容易过度拟合，讨论哪一个是单独的主题。<br/>决策树是一种强大的算法，可用于分类，可用于非线性关系的数据。这也是一种算法，从中获得推理和变量之间的关系比其他一些算法更简单。决策树也有点像自动特征选择(假设满足一些其他条件),因为它使用信息增益。总的来说，这是一个很棒的算法。</p></div></div>    
</body>
</html>