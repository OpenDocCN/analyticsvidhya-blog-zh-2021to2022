<html>
<head>
<title>Predict the Sales Volume of the Google Stock Price</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预测谷歌股票价格的销售量</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predict-the-sales-volume-of-the-google-stock-price-6d44da3ecb02?source=collection_archive---------20-----------------------#2021-06-20">https://medium.com/analytics-vidhya/predict-the-sales-volume-of-the-google-stock-price-6d44da3ecb02?source=collection_archive---------20-----------------------#2021-06-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4eb99523a77fa780a0fe33d40bbdecdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lGbruP6yrpkPmMhy9smww.jpeg"/></div></div></figure><p id="ed3f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">数据集:<a class="ae jn" href="https://drive.google.com/file/d/1oAQFQu9PSk0DRhEocefULy_qhzb9KHmO/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">点击</a></p><h1 id="98b6" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">可重现结果的设置</h1><p id="ccd3" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">要获得可重复的结果，您必须执行以下步骤，否则您将获得不同的结果:</p><p id="3f54" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1)将PYTHONHASHSEED环境变量设置为固定值</p><p id="7ea8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2)将python内置的伪随机生成器设置为固定值</p><p id="bdaa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">3)将numpy伪随机发生器设置为固定值</p><p id="c8cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">4)将张量流伪随机生成器设置为固定值</p><p id="affc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">5)配置新的全局张量流会话</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2a15" class="la jp hh kw b fi lb lc l ld le"># Seed value<br/># Apparently you may use different seed values at each stage<br/>seed_value= 0</span><span id="699a" class="la jp hh kw b fi lf lc l ld le"># 1. Set the `PYTHONHASHSEED` environment variable at a fixed value<br/>import os<br/>os.environ['PYTHONHASHSEED']=str(seed_value)</span><span id="22d9" class="la jp hh kw b fi lf lc l ld le"># 2. Set the `python` built-in pseudo-random generator at a fixed value<br/>import random<br/>random.seed(seed_value)</span><span id="5fa4" class="la jp hh kw b fi lf lc l ld le"># 3. Set the `numpy` pseudo-random generator at a fixed value<br/>import numpy as np<br/>np.random.seed(seed_value)</span><span id="8f74" class="la jp hh kw b fi lf lc l ld le"># 4. Set the `tensorflow` pseudo-random generator at a fixed value<br/>import tensorflow as tf<br/>tf.random.set_seed(seed_value)</span><span id="2794" class="la jp hh kw b fi lf lc l ld le"># for latest versions:<br/># tf.compat.v1.set_random_seed(seed_value)<br/># 5. Configure a new global `tensorflow` session</span><span id="805b" class="la jp hh kw b fi lf lc l ld le">from keras import backend as K<br/>session_conf = tf.compat.v1.ConfigProto(intra_op_parallelism_threads=1, inter_op_parallelism_threads=1)<br/>sess = tf.compat.v1.Session(graph=tf.compat.v1.get_default_graph(), config=session_conf)</span><span id="99a1" class="la jp hh kw b fi lf lc l ld le">K.set_session(sess)</span></pre><p id="aa74" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过遵循上述代码，您可以获得可重复的结果</p><p id="99c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们必须导入一些库。因为大多数python库都有一组有用的函数，可以简单地消除从头编写代码的需要。所以我导入了下面的库</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8c62" class="la jp hh kw b fi lb lc l ld le">import warnings<br/>warnings.filterwarnings('ignore')<br/>import os<br/>import numpy as np<br/>import pandas as pd<br/>import scipy.stats as stats<br/>from matplotlib import pyplot as plt<br/>%matplotlib inline</span><span id="dbff" class="la jp hh kw b fi lf lc l ld le">import sklearn<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.metrics import accuracy_score<br/>from sklearn import preprocessing</span></pre><p id="230c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">安装Google Drive并加载数据集</p><p id="e871" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经添加了以下代码，用于将google drive帐户安装到google colaboratory，以访问drive上可用的文件。当我们执行下面的代码时，我们必须转到生成的URL，并获得授权代码才能进入这里。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4711" class="la jp hh kw b fi lb lc l ld le">from google.colab import drive<br/>drive.mount('/content/drive')</span></pre><p id="55fe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">输入授权码后。您将收到一条消息，显示“安装在<a class="ae jn" href="https://colab.research.google.com/drive/1LPOegMGgG8ubnJmQ9oSG1AmXIYhSzPJd?authuser=1#" rel="noopener ugc nofollow" target="_blank">/内容/驱动器</a>”。此后，通过下面的代码，您可以访问您连接的google drive上的文件。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="87ef" class="la jp hh kw b fi lb lc l ld le">import pandas as pd</span><span id="da6b" class="la jp hh kw b fi lf lc l ld le">df = pd.read_csv('/content/drive/My Drive/Colab Notebooks/data/Google_Stock_Price.csv')</span></pre><p id="bf66" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，您可以看到该变量中存储的前10个数据行。Pandas libary提供了一个名为head()的方法，广泛用于返回数据帧或数据系列的前n行。默认情况下，该方法返回存储数据集的前5行。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0be6" class="la jp hh kw b fi lb lc l ld le">df.head(10)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/4bfab18e225e54cd9cc5f931ddecc028.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*f3ZF2CL5jJCJt79qg4e_Dg.png"/></div></figure><p id="d334" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，我们可以检查数据集上可用的记录数</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6037" class="la jp hh kw b fi lb lc l ld le">len(df)</span></pre><p id="f085" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">1258是上述代码的输出。数据集上有1258条可用记录。</p><h1 id="523f" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤01 —数据预处理</h1><p id="3dfd" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">数据预处理是一个主要步骤，因为从数据集中提取的有用信息直接影响到模型的质量，所以在将数据输入模型之前，至少对数据进行必要的预处理是非常重要的。</p><h2 id="5093" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">步骤01 A-处理缺失值和异常值</h2><blockquote class="lu lv lw"><p id="5e2d" class="ip iq lx ir b is it iu iv iw ix iy iz ly jb jc jd lz jf jg jh ma jj jk jl jm ha bi translated">步骤01 A —处理缺失值</p></blockquote><p id="4cfc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，我们可以检查数据集中缺失的值。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="6eb8" class="la jp hh kw b fi lb lc l ld le">df.isnull().any()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mb"><img src="../Images/14941cc29b901be2c7a03414f3718b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:378/format:webp/1*1TulDTkoh2ZL0SPblFmB7g.png"/></div></figure><p id="9c43" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的输出我们可以得出结论，我们在数据集中没有任何丢失的值。所以我们可以进行下一步。</p><blockquote class="lu lv lw"><p id="7ce1" class="ip iq lx ir b is it iu iv iw ix iy iz ly jb jc jd lz jf jg jh ma jj jk jl jm ha bi translated">步骤01 B —处理重复值</p></blockquote><p id="4e1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，我们可以检查数据集中的重复行。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="34b2" class="la jp hh kw b fi lb lc l ld le">print(df.duplicated().value_counts()) # To check duplicated values</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/416abd9b182bc4ad8d80b8e643b106c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:376/format:webp/1*ClEH0ZYRtwIJNjmFdnqEGQ.png"/></div></figure><p id="be62" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上面的输出我们可以得出结论，数据集中没有重复的行</p><blockquote class="lu lv lw"><p id="964f" class="ip iq lx ir b is it iu iv iw ix iy iz ly jb jc jd lz jf jg jh ma jj jk jl jm ha bi translated">步骤01c-处理异常值</p></blockquote><p id="5030" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">a)检查列名“Open”上的异常值</p><p id="7c37" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">开盘价是交易所当天开市时证券首次交易的价格。开盘价不同于前一天的收盘价。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5695" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 3)<br/>temp_df = pd.DataFrame(df, columns=['Open'])temp_df.boxplot(vert=False)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/148a6c76058a6fa36561ddd778afeaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9tyXl5WjWCJl-8w0Ylpqcw.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cd2d" class="la jp hh kw b fi lb lc l ld le">from matplotlib import pyplot<br/>plt.rcParams["figure.figsize"] = (24, 8)<br/>plt.plot(df['Open'])<br/>plt.title("Google Stock Open Price Changes")<br/>plt.xlabel("Time")<br/>plt.ylabel("Open Price")<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/5af5a560da9c1d33f4cde6dc293064f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQBrOpRbn1XfAbEOyYiipA.png"/></div></div></figure><p id="48cf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看上面的输出，我们可以说在特性方面没有太大的问题，</p><p id="5cbe" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">b)检查列名“高”上的异常值</p><p id="93dd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">高点是一段时间内股票交易的最高价格。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e94c" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 3)<br/>temp_df = pd.DataFrame(df, columns=['High'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mf"><img src="../Images/2474aea6f92b73886174e5d941df622c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T7aeV9otMZBW84B_Sf7Tew.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e851" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 8)<br/>plt.plot(df['High'])<br/>plt.title("Google Stock High Price Changes")<br/>plt.xlabel("Time")<br/>plt.ylabel("High Price")<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/b38d42bb17819c19c362d1cc552a830f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GLQ3bY3t6mGzGQIhcFnLNQ.png"/></div></div></figure><p id="4730" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看上面的输出，我们可以说在特性方面没有太大的问题，</p><p id="594b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">c)检查列名“低”上的异常值</p><p id="4d1c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">低点是这一时期的最低价。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0e5f" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 3)<br/>temp_df = pd.DataFrame(df, columns=['Low'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mg"><img src="../Images/b86d4468e69ae3a85fb94b73989b2064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcPhHhq2A31_ypkOg1rFzg.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="fa12" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 8)<br/>plt.plot(df['Low'])<br/>plt.title("Google Stock Low Price Changes")<br/>plt.xlabel("Time")<br/>plt.ylabel("Low Price")<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es me"><img src="../Images/fec7a25d92e8843289c0d093991b5f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCKXhp212JDHelVjgdRXkw.png"/></div></div></figure><p id="eed9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看上面的输出，我们可以说在特性方面没有太大的问题，</p><p id="1125" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">d)检查列名“Close”上的异常值</p><p id="b6c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">收盘价是一种证券在正常交易日的最后交易价格。证券的收盘价是投资者用来跟踪其长期表现的标准基准。收盘价不会反映现金股利、股票股利或股票分割的影响。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8315" class="la jp hh kw b fi lb lc l ld le">df['Close'] = df['Close'].str.replace(',','')<br/>df['Close'] = df['Close'].astype('float')<br/>plt.rcParams["figure.figsize"] = (24, 3)<br/>temp_df = pd.DataFrame(df, columns=['Close'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/d75745d3bfedb067b2e85917762ae35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MpsijQxOkERMAB1EORGX3g.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3e30" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 8)<br/>plt.title("Google Stock Close Price Changes")<br/>plt.xlabel("Time")<br/>plt.ylabel("Close Price")<br/>plt.plot(df['Close'])<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mh"><img src="../Images/e10534d895e05f4b8c86e2d1bf89c354.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Wq9G65XnxjIQw2GlpZ-EKA.png"/></div></div></figure><p id="c768" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看上面的输出，我们可以说在功能上有相当多的问题，</p><p id="660f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我检查了以下情况:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="a95d" class="la jp hh kw b fi lb lc l ld le">df[ df['High']&lt; df['Close']]</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mi"><img src="../Images/880b7bfaf79a914bf1ec7781e1c4efdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*UNyx5gFRv7jxtJD0l-J3GA.png"/></div></figure><p id="4a10" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经放弃了收盘价值，因为这些价值中的大多数都大于高价格价值，所以实际上不可能像那样。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="4c3a" class="la jp hh kw b fi lb lc l ld le">df = df.drop(‘Close’, axis = 1)</span></pre><p id="4165" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">e)检查列名“Volume”上的异常值</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="f2fd" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 3)<br/>df['Volume'] = df['Volume'].str.replace(',','')<br/>df['Volume'] = df['Volume'].astype('float')<br/>temp_df = pd.DataFrame(df, columns=['Volume'])<br/>temp_df.boxplot(vert=False)</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/ae9fc8281723beeb73c12c749befd96b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NxsYYQdvmMQp1wn1qPT1KQ.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="da62" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 8)<br/>plt.title("Google Stock Volume Changes")<br/>plt.xlabel("Time")<br/>plt.ylabel("Volume")<br/>plt.plot(df['Volume'])<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/c61f9489ef370b47f2ea4a4d28b0e0ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1VRKDnJcu3WrxbTTo3xow.png"/></div></div></figure><p id="e5e0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过查看上面的输出，我们可以说在功能上没有太大的问题</p><h1 id="da6d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤02 —特征编码</h1><p id="da2a" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">人工神经网络模型要求所有的输入和输出值都应该是数值。因此，如果数据集包含分类数据，您必须在拟合和评估模型之前将其编码为数字。有几种方法可以完成这项任务，如一键编码、整数(标签)编码。这里我使用了一键编码</p><h2 id="31f5" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">什么是周末效应？</h2><p id="c9ef" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">周末效应是金融市场中的一种现象，在这种市场中，周一的股票回报率往往显著低于前一个周五的回报率。周末效应也被称为周一效应。</p><h2 id="7578" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">什么是月末效应？</h2><p id="adf5" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">“月末效应”一直是许多科学研究的主题。统计数据显示，股票价格，尤其是美国股票价格，往往会在这个月的最后几天和头几天上涨。</p><h2 id="4a3c" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">买股票最好的月份是哪个月？</h2><p id="6082" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">在岁末年初以及夏季，市场往往会有强劲的回报。九月传统上是一个淡季。尽管1929年和1987年分别下跌了19.7%和21.5%，但10月份的平均回报率从历史上看是正的。</p><p id="eff5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">考虑到上面的实践，我增加了一个额外的列“日-周”来显示一周中的哪一天。余即吾得月，日也。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8b34" class="la jp hh kw b fi lb lc l ld le">df['Date'] = pd.to_datetime(df['Date'])<br/>df['Day_week'] = df['Date'].dt.day_name()</span><span id="3abd" class="la jp hh kw b fi lf lc l ld le">#df['Year'] = pd.DatetimeIndex(df['Date']).year<br/>df['Month'] = pd.DatetimeIndex(df['Date']).month<br/>df['Day'] = pd.DatetimeIndex(df['Date']).day<br/>df = df.drop('Date', axis = 1)<br/>df.head(10)</span></pre><p id="665e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在从数据中获得一些附加特征之后，</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es ml"><img src="../Images/b4beae75f6a96e35735a20b424e2d285.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*JTGGFP9EwL-WwF-c8NV-pw.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="0a51" class="la jp hh kw b fi lb lc l ld le">month_dummies = pd.get_dummies(df[‘Month’],prefix=’M’)<br/>df=pd.concat([df, month_dummies], axis=1)</span><span id="552e" class="la jp hh kw b fi lf lc l ld le">day_dummies = pd.get_dummies(df['Day_week'],prefix='W')<br/>df=pd.concat([df, day_dummies], axis=1)</span><span id="e544" class="la jp hh kw b fi lf lc l ld le">dayNum_dummies = pd.get_dummies(df['Day'],prefix='D')<br/>df=pd.concat([df, dayNum_dummies], axis=1)</span><span id="2118" class="la jp hh kw b fi lf lc l ld le">df = df.drop('Month', axis = 1)<br/>df = df.drop('Day_week', axis = 1)<br/>df = df.drop('Day', axis = 1)</span><span id="895d" class="la jp hh kw b fi lf lc l ld le">df.head(10)</span></pre><p id="5a38" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">修改数据集，</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mm"><img src="../Images/420a4d60fd4c3972043c09336591e4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXWZZisF1QPHBaXWWon9MQ.png"/></div></div></figure><h1 id="7099" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤03数据转换</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="eb57" class="la jp hh kw b fi lb lc l ld le">plt.rcParams["figure.figsize"] = (24, 12)<br/>X[['High','Low','Open']].hist()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/b2380a1446abf3b7243a7f0daee8a8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Do4eHtn32wgpbn4phLx0dQ.png"/></div></div></figure><p id="8008" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于最终值，不需要体积列转换。</p><h1 id="172a" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤04-缩放和/或标准化特征</h1><p id="49ab" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过执行以下代码，我删除了数据集中分类列，以便进行缩放:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="06f3" class="la jp hh kw b fi lb lc l ld le">dummies = day_dummies.columns.tolist() + month_dummies.columns.tolist()+dayNum_dummies.columns.tolist()</span><span id="b04f" class="la jp hh kw b fi lf lc l ld le">Remove_columns_values = dummies</span><span id="8e51" class="la jp hh kw b fi lf lc l ld le">X_without_Cat=X.drop(Remove_columns_values, axis = 1)<br/>X_without_Cat.head(5)</span></pre><p id="57b5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">删除分类列后，</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/1dd47de576049777c69f4d606264ddbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:748/format:webp/1*mu0xLhgEkFZw545G6mCGVQ.png"/></div></figure><p id="e30f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，我使用sklearn的minmax scaler缩放了表中的连续值</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2bd7" class="la jp hh kw b fi lb lc l ld le">from sklearn.preprocessing import MinMaxScaler<br/>scaler = MinMaxScaler()</span><span id="e9e0" class="la jp hh kw b fi lf lc l ld le">data_training = scaler.fit_transform(X_without_Cat)<br/>data_training</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es mp"><img src="../Images/7ce5d066ea2077bf0b83ea0574e69d39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*DRBjL284NW_o9ncDvq6gFQ.png"/></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="62f4" class="la jp hh kw b fi lb lc l ld le">columns_value_new=X_without_Cat.columns<br/>X_Scaled_Except = pd.DataFrame(data_training, columns=columns_value_new)</span><span id="e42a" class="la jp hh kw b fi lf lc l ld le">plt.rcParams[“figure.figsize”] = (24, 12)<br/>X_Scaled_Except.hist()</span></pre><p id="d6d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">显示缩放/标准化效果，</p><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mn"><img src="../Images/09611f4d1d07f361479cbbfe1182c533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UCUdzkV5K3JERi8dx3MpPg.png"/></div></div></figure><p id="a7a5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，我已经分别缩放了体积列，用于模型输出的逆变换，</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="93de" class="la jp hh kw b fi lb lc l ld le">scalerVol= MinMaxScaler()<br/>data_trainingVol= scalerVol.fit_transform(X_without_Cat.iloc[:,3:4])<br/>data_trainingVol</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/2161bf9e54525e5235389b6698d5d308.png" data-original-src="https://miro.medium.com/v2/resize:fit:562/format:webp/1*3nzSV4nqdTYbnLLIOs-7CA.png"/></div></div></figure><h1 id="f85c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤05相关矩阵</h1><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5ba2" class="la jp hh kw b fi lb lc l ld le">import seaborn as sns<br/>plt.rcParams["figure.figsize"] = (24, 8)<br/>sns.heatmap(X_Scaled_Except.corr(),annot=True);</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/83126d6a831716d8ce8cd92f741fbb14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txtOpVdPQFBYTosewrtqSA.png"/></div></div></figure><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="606d" class="la jp hh kw b fi lb lc l ld le">X_Scaled_Except.corr()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div class="er es ms"><img src="../Images/49303d1deccc58b5b486e067282c1e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*z57dz3zq7-vIiNfMydOFcA.png"/></div></figure><p id="94d6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">从上表和相关矩阵我们可以看出，低开高走之间有很高的相关性。所以我们只能选择一个1来平衡工作。由于价格之间的差异很小，我选择了平衡工作的所有功能</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5952" class="la jp hh kw b fi lb lc l ld le">data_Final =X_Scaled_Except<br/>for f in dummies:<br/>    data_Final = data_Final.join(X[f])</span></pre><h1 id="a68c" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">步骤06递归神经网络</h1><p id="90fc" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated"><strong class="ir hi">将多元序列分割成样本，</strong></p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1742" class="la jp hh kw b fi lb lc l ld le">def split_series(series, n_past):<br/>     X, y = list(), list()<br/>     for window_start in range(len(series)):<br/>          past_end = window_start + n_past<br/>          if past_end &gt;= len(series):<br/>          break</span><span id="f5f6" class="la jp hh kw b fi lf lc l ld le"># slicing the past and future parts of the window<br/>           past, future = series[window_start:past_end, 0:4]<br/>                          ,series[past_end,3]<br/>           X.append(past)<br/>           y.append(future)<br/>      return np.array(X), np.array(y)</span></pre><p id="de22" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经使用了上面的函数，按照下面的代码做了这个例子。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="34f9" class="la jp hh kw b fi lb lc l ld le">X, y = split_series(data_Final.to_numpy(), 6)</span></pre><p id="fd98" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我考虑了过去6天的记录来预测第7天的交易量</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8ee5" class="la jp hh kw b fi lb lc l ld le">import math<br/>n_test = math.floor(len(y)*0.2)<br/>X_train, X_test, y_train, y_test = X[:-n_test], X[-n_test:], y[:-n_test], y[-n_test:]<br/>print(X_train.shape, X_test.shape, y_train.shape, y_test.shape)</span></pre><p id="6ec2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我将数据集分成20 %用于测试，80 %用于训练。我以适当的方式使用了上述代码。因为我们必须在不改变顺序的情况下拆分数据集。</p><p id="e435" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">长短期记忆(LSTM) </strong></p><p id="b83c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">长短期记忆(LSTM)网络是一种能够在序列预测问题中学习顺序依赖性的递归神经网络。</p><p id="9552" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过下面的代码，你可以定义一个模型。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="aeb5" class="la jp hh kw b fi lb lc l ld le">from tensorflow.keras import Sequential<br/>from tensorflow.keras.layers import Dense, LSTM, Dropout<br/>from tensorflow.keras.layers import RNN</span><span id="6ff3" class="la jp hh kw b fi lf lc l ld le">regressor = Sequential()<br/>regressor.add(LSTM(units = 60, activation = 'relu', return_sequences = True, input_shape = (6, 4)))<br/>regressor.add(Dropout(0.2))<br/>regressor.add(LSTM(units = 60, activation = 'relu', return_sequences = True))<br/>regressor.add(Dropout(0.2))<br/>regressor.add(LSTM(units = 80, activation = 'relu', return_sequences = True))<br/>regressor.add(Dropout(0.2))<br/>regressor.add(LSTM(units = 120, activation = 'relu'))<br/>regressor.add(Dropout(0.2))<br/>regressor.add(Dense(units = 1))<br/>regressor.summary()</span></pre><h2 id="c3db" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated"><strong class="ak">模型的编制</strong></h2><p id="f28d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面给定的代码来编译模型，我使用了一个优化器作为“亚当”和损失作为“均方误差”。在优化算法部分，我们必须计算模型当前状态的误差，并且要反复估计误差。因此，它可以用来估计训练模型的损失，从而可以更新训练模型的权重，以减少与下一阶段一样多的损失。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="79fd" class="la jp hh kw b fi lb lc l ld le">regressor.compile(optimizer=’adam’, loss = ‘mean_squared_error’)</span></pre><h2 id="f820" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated"><strong class="ak">拟合模型</strong></h2><p id="d628" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">批量大小控制在模型的内部参数更新之前要处理的训练样本的数量。历元数控制训练数据集中的完整遍数。我给了150个纪元。因此，将会发生150次对训练数据集的完整遍历。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d4b0" class="la jp hh kw b fi lb lc l ld le">history=regressor.fit(X_train, y_train, epochs=150, batch_size=32, verbose=2,validation_data=(X_test, y_test) )</span></pre><h2 id="e0f7" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">评估模型</h2><p id="d17e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面的代码，我们可以得到均方差(MSE ),它告诉你一条回归线离一组点有多近。这是通过从点到回归线的距离并平方它们来实现的。均方根误差(RMSE)是以MSE的平方根表示的误差率。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="eb26" class="la jp hh kw b fi lb lc l ld le">from numpy import sqrt<br/>mse = regressor.evaluate(X_test, y_test, verbose=0)<br/>print('MSE: %.9f, RMSE: %.9f' % (mse, sqrt(mse)))</span></pre><p id="9a77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我已经收到了MSE: 0.000936066，和RMSE:0.0399536567</p><h2 id="3760" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">绘制学习曲线</h2><p id="d3a7" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面的代码，我们可以绘制模型的学习曲线。我们可以使用学习曲线来诊断学习中的问题，例如训练期间模型的欠拟合或过拟合。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="30b6" class="la jp hh kw b fi lb lc l ld le">plt.figure(figsize=(14,5))<br/>from matplotlib import pyplot<br/>pyplot.title('Learning Curves')<br/>pyplot.xlabel('Epoch')<br/>pyplot.ylabel('Root Mean Squared Error')<br/>pyplot.plot(history.history['loss'], label='train')<br/>pyplot.plot(history.history['val_loss'], label='val')<br/>pyplot.legend()<br/>pyplot.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/aa5e7ce74ad7c771175ab9e64a79bdb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ndYaJQQ5uv3E2Yup9c3Cdg.png"/></div></div></figure><p id="c9c0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">通过使用学习曲线，在过拟合和欠拟合模型条件之间存在良好的拟合。我们可以说良好拟合是指训练和验证损失都降低到一个稳定点，两个最终损失值之间的差距最小。</p><h2 id="eb3f" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">预言；预测；预告</h2><p id="accf" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面的代码，我们可以预测给定输入的音量。然而最终出来的不是量。因为我们已经把它作为模型的输入。因此，我们必须重新调整输出值，以获得预测的体积。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="8273" class="la jp hh kw b fi lb lc l ld le">y_pred = regressor.predict(X_test)</span></pre><h2 id="1021" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">重新调整输出</h2><p id="937d" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我们可以通过下面的代码重新调整模型的输出来得到体积。我已经用逆变换函数做了相关的工作。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ba0f" class="la jp hh kw b fi lb lc l ld le">y_predVol = scalerVol.inverse_transform(y_pred)<br/>y_test = y_test.reshape(y_test.shape[0], 1)<br/>y_testVol = scalerVol.inverse_transform(y_test)</span><span id="579f" class="la jp hh kw b fi lf lc l ld le">volume_pred= []<br/>for i in range(len(y_predVol)):<br/>     volume_pred.append(y_predVol[i,0])</span><span id="cd47" class="la jp hh kw b fi lf lc l ld le">volume_test= []<br/>for i in range(len(y_testVol)):<br/>     volume_test.append(y_testVol[i,0])</span></pre><h2 id="bb38" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">可视化结果</h2><p id="05a7" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面的代码，我们可以绘制出显示实际谷歌量与预测谷歌量的图表。我用红色线显示了真实的谷歌量，用蓝色线预测了谷歌量。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="2795" class="la jp hh kw b fi lb lc l ld le">plt.figure(figsize=(14,5))<br/>plt.plot(volume_test, color = 'red', label = 'Real Google Volume')<br/>plt.plot(volume_pred, color = 'blue', label = 'Predicted Google Volume')</span><span id="e167" class="la jp hh kw b fi lf lc l ld le">plt.title('Google Stock Volume Prediction')<br/>plt.xlabel('Time')<br/>plt.ylabel('Google Stock Volume')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="kr ks kt ku fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/31419f991a3ec4e38feef015586b4974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U2oHSp8Q-e9FqkXMP9zxrg.png"/></div></div></figure><h2 id="a6d6" class="la jp hh bd jq lh li lj ju lk ll lm jy ja ln lo kc je lp lq kg ji lr ls kk lt bi translated">使用𝑅^2统计计算模型的准确性</h2><p id="ead6" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">通过下面的代码，我们可以得到模型的r2分数。对r平方最常见的解释是回归模型与观测数据的拟合程度。通常，较高的r平方表示模型更适合</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5a98" class="la jp hh kw b fi lb lc l ld le">from sklearn import metrics</span><span id="0fc2" class="la jp hh kw b fi lf lc l ld le">accuracy = metrics.r2_score(volume_test,volume_pred)<br/>print(" Accuracy:", accuracy)</span></pre><p id="dc3c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">精确度:0.38386868686</p></div></div>    
</body>
</html>