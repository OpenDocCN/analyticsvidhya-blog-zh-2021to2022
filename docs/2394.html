<html>
<head>
<title>Convert a Regular Matrix into Sparse Matrix in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python将规则矩阵转换成稀疏矩阵</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/convert-a-regular-matrix-into-sparse-matrix-in-python-3f415614b837?source=collection_archive---------6-----------------------#2021-04-21">https://medium.com/analytics-vidhya/convert-a-regular-matrix-into-sparse-matrix-in-python-3f415614b837?source=collection_archive---------6-----------------------#2021-04-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6147" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将一步一步地使用Python将一个规则矩阵转换成一个稀疏矩阵。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/5d34364b1302f0ea139e21e43016c45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lCLeKwHmxAxoIXl9"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">由<a class="ae js" href="https://unsplash.com/@marco_pregnolato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Marco Pregnolato </a>在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="28e7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">介绍</h1><p id="8a33" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">矩阵是一种类似于数组的数据结构，其中值存储在行和列中。这里，值是一种独特的类型。当在机器学习和NLP中处理矩阵(线性代数)时，我们经常听到两种类型的矩阵作为-</p><ul class=""><li id="7baa" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated"><strong class="ig hi">密集矩阵</strong> —大部分元素不为零的矩阵。在这个矩阵中，零元素非常少。</li><li id="e364" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><strong class="ig hi">稀疏矩阵</strong> —相反，大部分元素为零，极少数元素不为零的矩阵。</li></ul><p id="1921" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意</strong>——没有这样的标准，即矩阵中有多少个零值确定需要稀疏矩阵。</p><h1 id="5b35" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">算法解释</h1><p id="64b9" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">假设您有一个包含<code class="du lk ll lm ln b">N</code>行和<code class="du lk ll lm ln b">M</code>列的大型矩阵，其中大多数值为零。您被要求只考虑非零元素，因为零元素不会增加多少价值。毫无疑问，你有时间和空间的限制，因为你正在处理一个非常大的矩阵。</p><p id="1642" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里简单的方法是忽略所有的<code class="du lk ll lm ln b">0</code>，以<strong class="ig hi"/><code class="du lk ll lm ln b">row_index</code><code class="du lk ll lm ln b">col_index</code><code class="du lk ll lm ln b">non-zero_value</code><strong class="ig hi"/>的形式存储非零元素。</p><p id="8de1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">方法:</strong></p><ol class=""><li id="f9f0" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lo lc ld le bi translated">遍历输入矩阵的每个<code class="du lk ll lm ln b">row</code>。</li><li id="4667" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lo lc ld le bi translated">迭代每个<code class="du lk ll lm ln b">row</code>的每个<code class="du lk ll lm ln b">value</code>。</li><li id="f8d7" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lo lc ld le bi translated">如果<strong class="ig hi">(值== 0) </strong> →跳过。</li><li id="2615" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lo lc ld le bi translated">如果<strong class="ig hi">(值！= 0) </strong> →从输入矩阵中获取<code class="du lk ll lm ln b">row</code>号和<code class="du lk ll lm ln b">column</code>号以及<code class="du lk ll lm ln b">value</code>号。</li><li id="4c70" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lo lc ld le bi translated">将每个<code class="du lk ll lm ln b">row</code>和<code class="du lk ll lm ln b">column</code>的结果保存为<strong class="ig hi"> [ </strong>，<code class="du lk ll lm ln b">column</code>，<code class="du lk ll lm ln b">value</code> <strong class="ig hi"> ] </strong>。</li><li id="3474" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lo lc ld le bi translated">停下来。</li></ol><h1 id="2aec" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">视觉解释</h1><p id="a0f2" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">假设我们得到了一个矩阵，这个矩阵的大部分元素都是<code class="du lk ll lm ln b">0</code>。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lp"><img src="../Images/6cfa8f4eb00775c7373e3b7e7937e18a.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*LAnY6nPTxNSFdd6oCf-1dw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者图片</figcaption></figure><p id="e93f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面<code class="du lk ll lm ln b">GIF</code>解释如何获得稀疏矩阵。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lq"><img src="../Images/147daf6d1cdec9375db283ad33942440.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/1*-Pn0x6G5OBGiGPvQhIme4w.gif"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">作者GIF</figcaption></figure><h1 id="f399" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">编码时间到了</h1><p id="05ed" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">在本节中，我们将尝试用两种不同的方式对此进行编码。一个是在<code class="du lk ll lm ln b">scipy</code>模块的帮助下，另一个是实现我们自己的稀疏矩阵。</p><p id="3be5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lr">让我们开始吧……</em></p><p id="2599" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">必要的进口</strong></p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="1bd9" class="lw ju hh ln b fi lx ly l lz ma">import numpy as np<br/>from scipy.sparse import csr_matrix</span></pre><p id="8b56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">随机矩阵创建</strong></p><p id="b413" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">只是为了演示，我们将确保矩阵包含最多的<code class="du lk ll lm ln b">0</code>元素。</p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="69be" class="lw ju hh ln b fi lx ly l lz ma">&gt;&gt;&gt; mat = np.random.randint(low=0, high=3, size=(5, 5))<br/>&gt;&gt;&gt; print(mat)<br/>[[2 2 0 2 0]<br/> [2 1 0 0 2]<br/> [2 1 0 1 0]<br/> [0 1 2 0 2]<br/> [0 1 2 2 1]]</span></pre><h1 id="dd66" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">SCIPY实现</h1><p id="aa0b" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">借助于<code class="du lk ll lm ln b">csr_matrix()</code>的方法，我们可以很容易地得到稀疏矩阵。</p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="0396" class="lw ju hh ln b fi lx ly l lz ma">&gt;&gt;&gt; smat = csr_matrix(mat)<br/>&gt;&gt;&gt; print(smat)<br/>(0, 0)    2<br/>(0, 1)    2<br/>(0, 3)    2<br/>(1, 0)    2<br/>(1, 1)    1<br/>(1, 4)    2<br/>(2, 0)    2<br/>(2, 1)    1<br/>(2, 3)    1<br/>(3, 1)    1<br/>(3, 2)    2<br/>(3, 4)    2<br/>(4, 1)    1<br/>(4, 2)    2<br/>(4, 3)    2<br/>(4, 4)    1</span></pre><p id="c67a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以认为python中的<code class="du lk ll lm ln b">dictionary</code>是一对<code class="du lk ll lm ln b">key</code>和<code class="du lk ll lm ln b">value</code>。上面的输出类似于<code class="du lk ll lm ln b">dictionary</code>，其中键是索引位置(行、列)，值是实际的非零元素。</p><h1 id="9d7e" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">自定义实现</h1><p id="cc4a" class="pw-post-body-paragraph ie if hh ig b ih kr ij ik il ks in io ip kt ir is it ku iv iw ix kv iz ja jb ha bi translated">为了从头开始实现它，我们可以遵循我之前解释过的算法方法。</p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="0411" class="lw ju hh ln b fi lx ly l lz ma"><strong class="ln hi">class</strong> SparseMatrix():<br/>    <strong class="ln hi">def</strong> __init__(self, arr):<br/>        self.arr = arr</span><span id="f66c" class="lw ju hh ln b fi mb ly l lz ma">    <strong class="ln hi">def</strong> retain_sparsity(self, to_dict=False):<br/>        sparse_mat = [<br/>            [rindx, cindx, val]<br/>            <strong class="ln hi">for</strong> (rindx, row) <strong class="ln hi">in</strong> <strong class="ln hi">enumerate</strong>(self.arr)<br/>            <strong class="ln hi">for</strong> (cindx, val) <strong class="ln hi">in</strong> <strong class="ln hi">enumerate</strong>(row)<br/>            <strong class="ln hi">if</strong> (val != 0)<br/>        ]</span><span id="409e" class="lw ju hh ln b fi mb ly l lz ma">        <strong class="ln hi">if</strong> to_dict:<br/>            sparse_mat = {(r, c) : v <strong class="ln hi">for</strong> (r, c, v) <strong class="ln hi">in</strong> sparse_mat}<br/>        <strong class="ln hi">return</strong> sparse_mat</span></pre><p id="f3c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的类<code class="du lk ll lm ln b">SparseMatrix()</code>有一个方法<code class="du lk ll lm ln b">retain_sparsity</code>，其中默认参数<code class="du lk ll lm ln b">to_dict</code>是<code class="du lk ll lm ln b">False</code>。参数<code class="du lk ll lm ln b">to_dict</code>用于是否以<code class="du lk ll lm ln b">dictionary</code>的形式获得输出。</p><p id="0d1e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">对象创建</strong></p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="8435" class="lw ju hh ln b fi lx ly l lz ma">sparse = SparseMatrix(arr=mat)</span></pre><p id="b594" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">输出—列表</strong></p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="502f" class="lw ju hh ln b fi lx ly l lz ma">&gt;&gt;&gt; smat_c = sparse.retain_sparsity()<br/>&gt;&gt;&gt; print(smat_c)<br/>[[0, 0, 2],<br/> [0, 1, 2],<br/> [0, 3, 2],<br/> [1, 0, 2],<br/> [1, 1, 1],<br/> [1, 4, 2],<br/> [2, 0, 2],<br/> [2, 1, 1],<br/> [2, 3, 1],<br/> [3, 1, 1],<br/> [3, 2, 2],<br/> [3, 4, 2],<br/> [4, 1, 1],<br/> [4, 2, 2],<br/> [4, 3, 2],<br/> [4, 4, 1]]</span></pre><p id="01fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">输出—字典</strong></p><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="2519" class="lw ju hh ln b fi lx ly l lz ma">&gt;&gt;&gt; smat_d = sparse.retain_sparsity(to_dict=True)<br/>&gt;&gt;&gt; print(smat_d)<br/>{(0, 0): 2,<br/> (0, 1): 2,<br/> (0, 3): 2,<br/> (1, 0): 2,<br/> (1, 1): 1,<br/> (1, 4): 2,<br/> (2, 0): 2,<br/> (2, 1): 1,<br/> (2, 3): 1,<br/> (3, 1): 1,<br/> (3, 2): 2,<br/> (3, 4): 2,<br/> (4, 1): 1,<br/> (4, 2): 2,<br/> (4, 3): 2,<br/> (4, 4): 1}</span></pre><h1 id="d81d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">结论</h1><ul class=""><li id="1e57" class="kw kx hh ig b ih kr il ks ip mc it md ix me jb lb lc ld le bi translated">当我们在处理大型矩阵时有空间限制时，通常倾向于将矩阵转换为稀疏表示，这与原始矩阵相比占用的空间更少。</li><li id="b57b" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">事实上，我们可以检查原始矩阵<code class="du lk ll lm ln b">mat</code>和<code class="du lk ll lm ln b">sparse</code>矩阵所占用的空间(以字节为单位)。</li></ul><pre class="jd je jf jg fd ls ln lt lu aw lv bi"><span id="4235" class="lw ju hh ln b fi lx ly l lz ma">&gt;&gt;&gt; from sys import getsizeof<br/>&gt;&gt;&gt; # checking the space of original matrix<br/>&gt;&gt;&gt; getsizeof(mat) <br/>156<br/>&gt;&gt;&gt; # checking the space of scipy sparse matrix<br/>&gt;&gt;&gt; getsizeof(smat)<br/>24<br/>&gt;&gt;&gt; # checking the custom implementation sparse matrix<br/>&gt;&gt;&gt; getsizeof(smat_c)<br/>92</span></pre><ul class=""><li id="3f54" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">我们可以观察到的是，<code class="du lk ll lm ln b">scipy</code>方法比我们的自定义方法占用的空间少。因为<code class="du lk ll lm ln b">scipy</code>是一个优化完善的库，主要用于各种科学计算。</li><li id="54b2" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">使用库方法总是比我们自己的代码更好，这样可以在更少的空间限制下更快地获得结果。</li></ul></div><div class="ab cl mf mg go mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ha hb hc hd he"><p id="756c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请我喝咖啡</p><p id="cca5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你喜欢我的文章，你可以买些咖啡，在这里支持我。这将激励我去写作和学习更多我所知道的东西。</p></div></div>    
</body>
</html>