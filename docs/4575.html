<html>
<head>
<title>Time Series Forecasting using TBATS Model</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于TBATS模型的时间序列预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/time-series-forecasting-using-tbats-model-ce8c429442a9?source=collection_archive---------0-----------------------#2021-11-21">https://medium.com/analytics-vidhya/time-series-forecasting-using-tbats-model-ce8c429442a9?source=collection_archive---------0-----------------------#2021-11-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="c4cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">基于python和R代码的多季节时间序列预测模型</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/285799a64e4e02ccadbbdef4d62a9bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwZjPejTwhdItHqzJZGonQ.png"/></div></div></figure><h1 id="744b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="90ed" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated"><a class="ae ks" rel="noopener" href="/analytics-vidhya/time-series-forecasting-101-9353f9e30c20">时间序列预测</a>是指根据以前观察到的值，使用模型来预测未来值。许多研究人员熟悉时间序列预测，但他们对特定类型的时间序列数据感到困惑。一种这样的数据是带有 <strong class="ih hj">季节性</strong>的<strong class="ih hj">数据。可能存在许多类型的季节性(例如，一天中的时间、每天、每周、每月、每年)。</strong></p><p id="ffd1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TBATS是一种对时间序列数据建模的预测方法。其主要目的是使用指数平滑法预测具有复杂季节模式的时间序列</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kt"><img src="../Images/bd86a384770a6df0adb43abcdaf42247.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YplGt73W0QbEgNmUV9jKeQ.png"/></div></div></figure><p id="89f8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TBATS: <strong class="ih hj"> T </strong>精确季节性，<strong class="ih hj"> B </strong> ox-Cox变换，<a class="ae ks" rel="noopener" href="/analytics-vidhya/arima-fc1f962c22d4"> <strong class="ih hj"> A </strong> RMA </a>误差，<strong class="ih hj"> T </strong>趋势和<strong class="ih hj"> S </strong>季节性分量。</p><h1 id="fe2b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">概观</h1><p id="1bb8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">为了开始预测，我们需要首先<strong class="ih hj">安装tbats包</strong>。应该执行以下步骤来创建模型:</p><ul class=""><li id="88ee" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">将数据分成两部分(比如说，train_data和test_data)。Train_data用于训练模型，并使模型符合数据。使用test_data评估训练的模型。</li><li id="51ba" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">向模型提供有关季节长度的信息(例如，如果存在每小时的数据，则可以每周为一周中的所有24*7小时绘制模型)。</li><li id="eaff" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">使用模型的train_data来拟合模型的train_data。</li><li id="c091" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">在您想要预测的某段时间之前预测模型。</li></ul><h1 id="3f1f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TBATS如何选择最终模型</h1><p id="0ee5" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">TBATS将考虑各种备选方案，并适合相当多的型号。它将考虑模型:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/43248c8b2b80a9b046a123c0ca238be9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uAzCuU6lUiPQAqu9oNOl3w.png"/></div></div></figure><ul class=""><li id="8972" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">有无Box-Cox变换。</li><li id="f87b" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">有考虑趋势和无趋势。</li><li id="2f68" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">有趋势阻尼和没有趋势阻尼。</li><li id="d1a0" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">用ARIMA(p，q)和不用ARMA(p，q)过程来模拟残差。</li><li id="76e0" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">非季节性模型。</li><li id="1adb" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">用于模拟季节效应的各种谐波量</li></ul><p id="7283" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">将使用<a class="ae ks" href="https://en.wikipedia.org/wiki/Akaike_information_criterion" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">赤池信息标准</strong></a><strong class="ih hj">【AIC】</strong>选择最终模型。</p><p id="4b16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">特别是，自动<a class="ae ks" rel="noopener" href="/analytics-vidhya/arima-fc1f962c22d4"> ARIMA </a>用于决定残差是否需要建模以及什么p和q值是合适的。</p><h1 id="4a3f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">现有实施</h1><p id="bf81" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">到目前为止，唯一可用的实现是R语言，在<a class="ae ks" href="https://www.rdocumentation.org/packages/forecast" rel="noopener ugc nofollow" target="_blank">预测</a>包中。使用Python的数据科学家要么不得不放弃测试这些模型，要么被迫使用R包装器如<a class="ae ks" href="https://rpy2.bitbucket.io/" rel="noopener ugc nofollow" target="_blank"> rpy2 </a>来运行它们。</p><h1 id="0f7e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">新实现</h1><p id="7ac4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">关于Python 中<strong class="ih hj"> TBATS的新实现，可从GitHub获得。在本文的其余部分，我们将提供示例用法，并将该实现的性能与其他方法进行比较。</strong></p><h1 id="3b54" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">装置</h1><p id="9d9e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">来自PyPI:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="2a8f" class="lo jq hi lk b fi lp lq l lr ls">pip install tbats</span></pre><p id="56e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过以下方式导入:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="a050" class="lo jq hi lk b fi lp lq l lr ls">from tbats import BATS, TBATS</span></pre><h1 id="7a1a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">最小工作示例:</h1><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="6872" class="lo jq hi lk b fi lp lq l lr ls">from tbats import TBATS<br/>import numpy as np</span><span id="5bcc" class="lo jq hi lk b fi lt lq l lr ls"># required on windows for multi-processing,<br/># see <a class="ae ks" href="https://docs.python.org/2/library/multiprocessing.html#windows" rel="noopener ugc nofollow" target="_blank">https://docs.python.org/2/library/multiprocessing.html#windows</a><br/>if __name__ == '__main__':<br/>    np.random.seed(2342)<br/>    t = np.array(range(0, 160))<br/>    y = 5 * np.sin(t * 2 * np.pi / 7) + 2 * np.cos(t * 2 * np.pi / 30.5) + \<br/>        ((t / 20) ** 1.5 + np.random.normal(size=160) * t / 50) + 10<br/>    <br/>    # Create estimator<br/>    estimator = TBATS(seasonal_periods=[14, 30.5])<br/>    <br/>    # Fit model<br/>    fitted_model = estimator.fit(y)<br/>    <br/>    # Forecast 14 steps ahead<br/>    y_forecasted = fitted_model.forecast(steps=14)<br/>    <br/>    # Summarize fitted model<br/>    print(fitted_model.summary())</span></pre><p id="2c73" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">读取模型细节</strong></p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d152" class="lo jq hi lk b fi lp lq l lr ls"># Time series analysis<br/>print(fitted_model.y_hat) # in sample prediction<br/>print(fitted_model.resid) # in sample residuals<br/>print(fitted_model.aic)</span><span id="230c" class="lo jq hi lk b fi lt lq l lr ls"># Reading model parameters<br/>print(fitted_model.params.alpha)<br/>print(fitted_model.params.beta)<br/>print(fitted_model.params.x0)<br/>print(fitted_model.params.components.use_box_cox)<br/>print(fitted_model.params.components.seasonal_harmonics)</span></pre><h1 id="1cb4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">解决纷争</h1><p id="d34e" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">bat和TBATS会尝试引擎盖下的众多模型，在拟合太长的时间序列时可能会显得很慢。为了加快速度，可以从约束模型搜索空间开始。建议在没有Box-Cox变换和ARMA误差建模的情况下运行它，它们是最慢的模型元素:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="94ba" class="lo jq hi lk b fi lp lq l lr ls"># Create estimator<br/>estimator = TBATS(<br/>    seasonal_periods=[14, 30.5],<br/>    use_arma_errors=False,  # shall try only models without ARMA<br/>    use_box_cox=False  # will not use Box-Cox<br/>)<br/>fitted_model = estimator.fit(y)</span></pre><p id="ce57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在某些环境配置中，模型的并行计算会冻结。其原因尚不清楚。如果进程出现停滞，您可以尝试在单核上运行它:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="57f8" class="lo jq hi lk b fi lp lq l lr ls">estimator = TBATS(<br/>    seasonal_periods=[14, 30.5],<br/>    n_jobs=1<br/>)<br/>fitted_model = estimator.fit(y)</span></pre><p id="a38a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预测包比较测试。那些不使用默认测试命令运行的应用程序，您需要安装R forecast包:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="7245" class="lo jq hi lk b fi lp lq l lr ls">python setup.py test_r</span></pre><h1 id="2d08" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">与R实现的比较</h1><p id="86e7" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">Python实现意味着尽可能等同于预测包中的R实现。</p><ul class=""><li id="590d" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">BATS in R<a class="ae ks" href="https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/bats" rel="noopener ugc nofollow" target="_blank">https://www . rdocumentation . org/packages/forecast/versions/8.4/topics/BATS</a></li><li id="e60d" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">R中的TBATS:<a class="ae ks" href="https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/tbats" rel="noopener ugc nofollow" target="_blank">https://www . rdocumentation . org/packages/forecast/versions/8.4/topics/TBATS</a></li></ul><h1 id="d79a" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">一些例子和时间序列数据集</h1><p id="6c26" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">为了检验预测方法，我们需要一些时间序列数据。让我们使用<a class="ae ks" href="https://www.kaggle.com/c/demand-forecasting-kernels-only" rel="noopener ugc nofollow" target="_blank"> Kaggle商店项目需求预测挑战</a>中的时间序列。这是一个游乐场的挑战，场景很可能是人造的(参见<a class="ae ks" href="https://www.kaggle.com/thexyzt/keeping-it-simple-by-xyzt" rel="noopener ugc nofollow" target="_blank">内核</a>和<a class="ae ks" href="https://www.kaggle.com/c/demand-forecasting-kernels-only/discussion/65967" rel="noopener ugc nofollow" target="_blank">讨论</a>中的评论)。那里的数据包含5年内10家商店50种商品的日销售额(总共500个不同的时间序列)。出于我们的目的，我们只需要一个时间序列，所以我将任意选择商店1中商品1的销售额。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="22d7" class="lo jq hi lk b fi lp lq l lr ls">import pandas as pddf = pd.read_csv('kaggle_sales.csv')<br/>df = df[(df['store'] == 1) &amp; (df['item'] == 1)] # item 1 in store 1<br/>df = df.set_index('date')<br/>y = df['sales']y_to_train = y.iloc[:(len(y)-365)]<br/>y_to_test = y.iloc[(len(y)-365):] # last year for testing</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/c571b2b24b217ef5484c7e5fcadb54e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uDWBXgkIyVOc2AWd.png"/></div></figure><p id="1a9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图1:商店1中商品1的日销售额</p><p id="9117" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">销售数据包含每日观察。它<strong class="ih hj">展示每周和每年的季节模式</strong>。这意味着我们正在处理包含多重季节效应的时间序列。其中一个季节性很长，包含365次(闰年为366次)观测。这就是TBATS的设计目的。</p><h1 id="76c9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">TBATS模型</h1><p id="8e11" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">为了开始预测，我们需要安装tbats包并拟合模型。我们唯一需要手动提供给模型的是季节长度:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="e4e8" class="lo jq hi lk b fi lp lq l lr ls">from tbats import TBATS, BATS# Fit the model<br/>estimator = TBATS(seasonal_periods=(7, 365.25))<br/>model = estimator.fit(y_to_train)# Forecast 365 days ahead<br/>y_forecast = model.forecast(steps=365)</span></pre><p id="d23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可能已经注意到每年的季节长度不是一个整数。考虑到闰年，它等于365.25，这是TBATS能够处理的功能。</p><p id="7f95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TBATS似乎在模拟季节效应方面做得相当不错:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/437b2c380d3dafc0a8434b2ad01b8fda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*a4bCddm72eLn3tCz.png"/></div></figure><p id="2d96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图2: 3最近几年的销售数据。TBATS正在模拟每年的季节性影响。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/abd7da2fed41fd459e7cb85fabeb437f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q__HGt96GheQcFUd.png"/></div></figure><p id="68e9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图3: 12周的数据。TBATS也在模拟每周的季节性影响。</p><p id="69ce" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们深入了解并查看模型参数，我们会发现3个季节谐波用于模拟周模式，11个谐波用于模拟年模式。TBATS选择使用λ为0.234955的Box-Cox变换。趋势没有被建模，ARMA没有被用于建模残差，因为p，q是0。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="217d" class="lo jq hi lk b fi lp lq l lr ls">Use Box-Cox: True<br/>Use trend: False<br/>Use damped trend: False<br/>Seasonal periods: [  7.   365.25]<br/>Seasonal harmonics [ 3 11]<br/>ARMA errors (p, q): (0, 0)<br/>Box-Cox Lambda 0.234955<br/>Smoothing (Alpha): 0.015789</span></pre><h1 id="48cd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">具有周季节性的SARIMA模型</h1><p id="8c66" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">让我们将传统助产士与另一种广泛使用且广为人知的方法进行比较:<a class="ae ks" href="https://www.statsmodels.org/dev/generated/statsmodels.tsa.statespace.sarimax.SARIMAX.html" rel="noopener ugc nofollow" target="_blank"> SARIMA </a>。<a class="ae ks" rel="noopener" href="/analytics-vidhya/arima-fc1f962c22d4"> SARIMA </a>已经被证明能够为时间序列预测提供最先进的解决方案。不幸的是，它有两个主要缺点:(1)人们只能模拟单一的季节效应，(2)季节长度不能太长。</p><p id="cf27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，让我们使用来自<a class="ae ks" href="https://github.com/tgsmith61591/pmdarima" rel="noopener ugc nofollow" target="_blank"> pmdarima </a>包的auto_arima来构建<a class="ae ks" rel="noopener" href="/analytics-vidhya/arima-fc1f962c22d4"> SARIMA </a>模型。我们将忽略每年的季节性，而专注于模拟每周的季节性模式:</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="d1cc" class="lo jq hi lk b fi lp lq l lr ls">from pmdarima import auto_arima<br/>arima_model = auto_arima(y_to_train, seasonal=True, m=7)<br/>y_arima_forecast = arima_model.predict(n_periods=365)</span></pre><p id="51da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Auto arima选择了SARIMA(0，1，1)x(1，0，1，7)模型。因为没有模拟预期的年度模式(见图4)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/90e6e8609b77aae1236cc71ce99de071.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-mvSjqeN_UmlBqDE.png"/></div></figure><p id="4f9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图4: SARIMA只模拟周线模式。与图2相比。</p><h1 id="1b3c" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">带有傅立叶项的SARIMAX</h1><p id="1cc8" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">人们可以运用<a class="ae ks" href="https://content.pivotal.io/blog/forecasting-time-series-data-with-multiple-seasonal-periods" rel="noopener ugc nofollow" target="_blank">技巧</a>【4】利用SARIMAX中的外生变量，用傅立叶项模拟额外的季节性。</p><p id="1cf1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将继续用萨里玛的季节部分来模拟每周的模式。对于每年的季节模式，我们将使用上述技巧。我比较了傅里叶项数的多种选择，2提供了最准确的预测。因此，我们将使用2个傅立叶项作为外生变量。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="69f9" class="lo jq hi lk b fi lp lq l lr ls"># prepare Fourier terms<br/>exog = pd.DataFrame({'date': y.index})<br/>exog = exog.set_index(pd.PeriodIndex(exog['date'], freq='D'))<br/>exog['sin365'] = np.sin(2 * np.pi * exog.index.dayofyear / 365.25)<br/>exog['cos365'] = np.cos(2 * np.pi * exog.index.dayofyear / 365.25)<br/>exog['sin365_2'] = np.sin(4 * np.pi * exog.index.dayofyear / 365.25)<br/>exog['cos365_2'] = np.cos(4 * np.pi * exog.index.dayofyear / 365.25)<br/>exog = exog.drop(columns=['date'])<br/>exog_to_train = exog.iloc[:(len(y)-365)]<br/>exog_to_test = exog.iloc[(len(y)-365):]# Fit model<br/>arima_exog_model = auto_arima(y=y_to_train, exogenous=exog_to_train, seasonal=True, m=7)# Forecast<br/>y_arima_exog_forecast = arima_exog_model.predict(n_periods=365, exogenous=exog_to_test)</span></pre><p id="f42d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">借助傅立叶项，SARIMAX能够模拟两种季节模式(图5)。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lu"><img src="../Images/f2c6f011848bf8a90ae72303c0ced4a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iR2H1miJg3GB43ZQ.png"/></div></figure><p id="c23e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图5:带有傅立叶项的SARIMAX模拟了周模式和年模式</p><h1 id="008e" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">模型比较</h1><p id="5b94" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">到目前为止，我们只看了情节。让我们使用365天的预测来比较模型的性能。我们将使用平均绝对误差作为衡量标准:</p><ul class=""><li id="cae3" class="ku kv hi ih b ii ij im in iq kw iu kx iy ky jc kz la lb lc bi translated">TBATS: 3.8577</li><li id="2206" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">萨里玛:7.2249</li><li id="6a78" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc kz la lb lc bi translated">具有两个傅立叶项的SARIMAX:3.9045</li></ul><p id="cf3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如预期的那样，SARIMA提供了一个很差的模型，因为它不能模拟每年的季节性。带有傅立叶项的TBATS和SARIMAX提供了更好的模型。</p><h1 id="8ddd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">优势</h1><p id="f7e4" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">许多时间序列表现出复杂的多重季节性模式(例如，包含日模式、周模式和年模式的每小时数据)。最流行的模型(如<a class="ae ks" rel="noopener" href="/analytics-vidhya/arima-fc1f962c22d4"> ARIMA </a>和指数平滑)只能解释一个季节性。</p><p id="c9fd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">TBATS模型能够处理复杂的季节性因素(例如，非整数季节性因素、非嵌套季节性因素和大周期季节性因素),不受季节性因素的限制，因此可以创建详细的长期<a class="ae ks" rel="noopener" href="/analytics-vidhya/time-series-forecasting-101-9353f9e30c20">预测。</a></p><h1 id="e5a9" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">缺点</h1><p id="5b86" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">不幸的是，蝙蝠和TBATS的能力不是免费的。该方法非常通用。在引擎盖下，它构建并评估许多候选模型。这导致了计算的缓慢。当需要为大量并行时间序列训练模型时，这可能是至关重要的。</p><p id="685f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与SARIMAX不同，bat和TBATS不允许将外生变量添加到模型中以改进预测。根据Rob J Hyndmann 的说法，将它们包含在内并且不陷入可预测性问题中并不容易。</p><p id="94cc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> TBATS模型(具有Box-Cox变换、ARMA误差、趋势和季节性成分的指数平滑状态空间模型)</strong></p><p id="fc71" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">符合应用于<code class="du lv lw lx lk b">y</code>的TBATS模型，如De Livera，Hyndman &amp; Snyder (2011)所述。默认情况下，使用并行处理来加速计算。</p><pre class="je jf jg jh fd lj lk ll lm aw ln bi"><span id="772b" class="lo jq hi lk b fi lp lq l lr ls">tbats(<br/>  y,<br/>  use.box.cox = NULL,<br/>  use.trend = NULL,<br/>  use.damped.trend = NULL,<br/>  seasonal.periods = NULL,<br/>  use.arma.errors = TRUE,<br/>  use.parallel = <a class="ae ks" href="https://rdrr.io/r/base/length.html" rel="noopener ugc nofollow" target="_blank">length</a>(y) &gt; 1000,<br/>  num.cores = 2,<br/>  bc.lower = 0,<br/>  bc.upper = 1,<br/>  biasadj = FALSE,<br/>  model = NULL,<br/>  ...<br/>)</span></pre><h1 id="042f" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="716d" class="pw-post-body-paragraph if ig hi ih b ii kn ik il im ko io ip iq kp is it iu kq iw ix iy kr ja jb jc hb bi translated">TBATS使用户能够轻松处理多种季节模式的数据。当季节性随时间变化时，这种模式更可取。</p><h1 id="e915" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">参考</h1><ol class=""><li id="ecf0" class="ku kv hi ih b ii kn im ko iq ly iu lz iy ma jc mb la lb lc bi translated">De Livera，A.M .，Hyndman，R.J .，&amp; Snyder，R. D. (2011)，<a class="ae ks" href="https://www.tandfonline.com/doi/abs/10.1198/jasa.2011.tm09771" rel="noopener ugc nofollow" target="_blank"> <em class="mc">使用指数平滑法预测具有复杂季节模式的时间序列</em> </a>，《美国统计协会杂志》，106(496)，1513–1527。工作文件版本可在https://robjhyndman.com/papers/ComplexSeasonality.pdf<a class="ae ks" href="https://robjhyndman.com/papers/ComplexSeasonality.pdf" rel="noopener ugc nofollow" target="_blank">获得</a></li><li id="4249" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc mb la lb lc bi translated">bat和TBATS的Python实现:<a class="ae ks" href="https://github.com/intive-DataScience/tbats" rel="noopener ugc nofollow" target="_blank">https://github.com/intive-DataScience/tbats</a></li><li id="9c90" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc mb la lb lc bi translated">R预测包中的TBATS:<a class="ae ks" href="https://www.rdocumentation.org/packages/forecast/versions/8.4/topics/tbats" rel="noopener ugc nofollow" target="_blank">https://www . rdocumentation . org/packages/forecast/versions/8.4/topics/TBATS</a></li><li id="aa5a" class="ku kv hi ih b ii ld im le iq lf iu lg iy lh jc mb la lb lc bi translated">具有多个季节周期的预测时间序列数据(傅立叶项):<a class="ae ks" href="https://content.pivotal.io/blog/forecasting-time-series-data-with-multiple-seasonal-periods" rel="noopener ugc nofollow" target="_blank">https://content . pivotal . io/blog/forecasting-Time-Series-Data-with-Multiple-Seasonal-Periods</a></li></ol></div></div>    
</body>
</html>