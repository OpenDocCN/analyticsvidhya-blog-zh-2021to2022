<html>
<head>
<title>Pitfalls of Python Lists</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python列表的陷阱</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pitfalls-of-python-lists-67299d038884?source=collection_archive---------13-----------------------#2021-01-19">https://medium.com/analytics-vidhya/pitfalls-of-python-lists-67299d038884?source=collection_archive---------13-----------------------#2021-01-19</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="56e2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">列表是python中的一种数据结构，类似于其他编程语言的动态数组。列表是非常优秀和有用的数据结构，它提供了各种功能，如插入，追加，排序，删除，弹出等，这使我们的生活更容易。借助python中的list，我们还可以轻松地创建复杂的数据结构，如优先级队列、堆栈等。</p><p id="93cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果python list有很多额外的好处，那么它肯定会有一些缺点。在这篇短文中，我们将看到在使用python list时可能会遇到的一些问题及其解决方案。</p><p id="e2a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">创建嵌套列表(2D数组):</strong></p><p id="46d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在python中创建嵌套列表有多种方法。以下示例显示了在python中创建嵌套列表的最简单方法:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="c2f0" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a = [[]]*3<br/>&gt;&gt;&gt; a<br/>[[], [], []]</span></pre><p id="6910" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，我们刚刚在乘法的帮助下创建了2D列表。但是等等，让我们试着向列表中插入值，</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="f701" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a[0].append(0)</span></pre><p id="0a0f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">预期产出:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="a748" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a<br/>[[0], [], []]</span></pre><p id="4121" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际产量:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="eda8" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a[0].append(0)<br/>&gt;&gt;&gt; a<br/>[[0], [0], [0]]</span></pre><p id="4753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，值0被追加到列表“a”的每个内部列表中。现在的问题是，幕后发生了什么？</p><p id="6ef2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们使用乘法在列表中创建列表时，解释器创建对所有列表的公共引用。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="155c" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; [id(x) for x in a]<br/>[2382774602888, 2382774602888, 2382774602888]</span></pre><p id="c753" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你在上面看到的，列表‘a’的每个列表都有相同对象的引用。从下面的图片，你可以很容易地理解这个概念。</p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es js"><img src="../Images/9daee6abf6b2f5a3ccf5c5c9c81a7f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*vHFX7V3Wx-ckpa3RmDfRmw.png"/></div></figure><p id="bfb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看这个问题解决方案，</p><p id="c40a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案1: </strong></p><p id="b907" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以创建一个列表，并添加另一个列表，如下所示</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="e425" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a = []<br/>&gt;&gt;&gt; a.append([])<br/>&gt;&gt;&gt; a.append([])<br/>&gt;&gt;&gt; a.append([])<br/>&gt;&gt;&gt; a<br/>[[], [], []]</span></pre><p id="edac" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，每次我们添加新的列表时，都会创建新的对象。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="d85f" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; [id(x) for x in a]<br/>[1876972816904, 1876972816712, 1876972866504]</span></pre><p id="2886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果我们把值追加到a的第一个列表，它不会改变其他列表。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4879" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a[0].append(0)<br/>&gt;&gt;&gt; a<br/>[[0], [], []]</span></pre><p id="e1bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">方案二:</strong></p><p id="836e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加一个列表来制作嵌套列表需要很少的努力，我们可以使用列表理解来简化我们的工作。</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="4d22" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; a = [[] for _ in range(3)]<br/>&gt;&gt;&gt; a<br/>[[], [], []]<br/>&gt;&gt;&gt; a[0].append(0)<br/>&gt;&gt;&gt; a<br/>[[0], [], []]</span></pre><p id="5660" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">列表作为默认参数:</strong></p><p id="2c16" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有时，我们在定义函数时设置默认参数。让我们看看将列表设置为默认参数会导致什么问题:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="8139" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; def func(li = []):<br/> li.append(5)<br/> print(li)</span><span id="322c" class="jm jn hi ji b fi jw jp l jq jr">&gt;&gt;&gt; func([1,4,2])<br/>[1, 4, 2, 5]<br/>&gt;&gt;&gt; func([3,6,8])<br/>[3, 6, 8, 5]</span></pre><p id="8e3f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">函数按预期工作，让我们尝试不传递参数调用函数:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="06ea" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; func()<br/>[5]<br/>&gt;&gt;&gt; func()<br/>[5, 5]</span></pre><p id="9d0e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里，输出是意外的，第二个函数调用返回两个值而不是一个值的列表。之所以会出现这种情况，是因为默认参数是在<strong class="ih hj">函数定义中创建的。</strong></p><p id="6d76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，每当我们调用不带参数的函数时，将使用相同的默认实参对象。</p><p id="5983" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下面的可视化将帮助你更清楚地理解:</p><p id="2ece" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jx">功能定义:</em> </strong></p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es jy"><img src="../Images/de2ef2a90cdc511378239dc07cb71e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*hUOywFGrErOl56b8C8g33g.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">def func(li=[])</figcaption></figure><p id="4eab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jx">第一次函数调用:</em> </strong></p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es kd"><img src="../Images/7a142901c53a486a1b9508d9e7a16beb.png" data-original-src="https://miro.medium.com/v2/resize:fit:630/format:webp/1*xB2dLXgBPRH2QGPW2551rg.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">函数()</figcaption></figure><p id="9e5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jx">第二个函数调用:</em> </strong></p><figure class="jd je jf jg fd jt er es paragraph-image"><div class="er es ke"><img src="../Images/4764a9ac6d9d86c6983b0849f2ecd825.png" data-original-src="https://miro.medium.com/v2/resize:fit:660/format:webp/1*wkQJFvzfsBb8mmYuTwkQQA.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">函数()</figcaption></figure><p id="4e3b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">解决方案:</strong></p><p id="faf0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解决这个问题的方法是对默认参数只使用不可变类型:</p><pre class="jd je jf jg fd jh ji jj jk aw jl bi"><span id="6d25" class="jm jn hi ji b fi jo jp l jq jr">&gt;&gt;&gt; def func(li = None):<br/> if not li:<br/>  li = []<br/> li.append(5)<br/> print(li)</span><span id="6a61" class="jm jn hi ji b fi jw jp l jq jr">&gt;&gt;&gt; func()<br/>[5]<br/>&gt;&gt;&gt; func()<br/>[5]</span></pre><p id="f1a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">结论:</strong></p><p id="588b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们已经看到，当我们借助乘法和传递列表作为函数及其解决方案中的默认参数来创建嵌套列表时，python list会返回意外的输出。</p></div></div>    
</body>
</html>