<html>
<head>
<title>Defer, Panic and Recover Control flow Concepts in Go</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Go中的延迟、死机和恢复控制流概念</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/defer-panic-and-recover-control-flow-concepts-in-go-c84265a05993?source=collection_archive---------1-----------------------#2021-06-15">https://medium.com/analytics-vidhya/defer-panic-and-recover-control-flow-concepts-in-go-c84265a05993?source=collection_archive---------1-----------------------#2021-06-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="d038" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="d4b1" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">开发Go应用程序时，延迟、死机和恢复是基本概念。使用<code class="du kb kc kd ke b">defer</code>函数，您可以调用一个函数，但要等到其他函数执行后才能执行。如果你熟悉Python语言，<code class="du kb kc kd ke b">defer </code>函数类似于Python中的<code class="du kb kc kd ke b">finally</code>关键字。<br/>对于<code class="du kb kc kd ke b">panic</code>的Go应用程序来说，它必须达到一个不能再运行的点，因为它不知道该做什么。这可以由编译器触发，也可以在我们的代码中手动触发。<br/>至于<code class="du kb kc kd ke b">recover</code>关键词，与<code class="du kb kc kd ke b">panic</code>密切相关。当一个程序进入恐慌状态时，我们有一个选项来帮助它恢复，我们使用<code class="du kb kc kd ke b">recover</code>关键字。</p><p id="aefc" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">在本文中，您将了解到<code class="du kb kc kd ke b">defer</code>、<code class="du kb kc kd ke b">panic</code>和<code class="du kb kc kd ke b">recover</code>函数是如何工作的，它的属性和用例。</p><h1 id="d4a2" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">先决条件</h1><ol class=""><li id="81c8" class="kk kl hi jf b jg jh jk jl jo km js kn jw ko ka kp kq kr ks bi translated">Golang基础知识</li></ol><h1 id="2b95" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">推迟</h1><p id="bb83" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">defer</code>语句使您能够阻止一个函数的执行，直到稍后，这取决于您试图完成的任务。<br/>用一个真实世界的例子来说，每个男人都有蓄胡子的能力，但这种能力会因为某种原因一直保持到你长大。基本上，这就是<code class="du kb kc kd ke b">defer</code>的工作方式。</p><h2 id="f6fc" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">性能</h2><ol class=""><li id="d0ed" class="kk kl hi jf b jg jh jk jl jo km js kn jw ko ka kp kq kr ks bi translated">Defer语句不运行函数，它运行函数调用。</li><li id="a855" class="kk kl hi jf b jg lh jk li jo lj js lk jw ll ka kp kq kr ks bi translated">它遵循后进先出的顺序，即最后调用的<code class="du kb kc kd ke b">defer</code>语句将首先执行。</li></ol><h2 id="06b5" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">如何使用延期</h2><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="dc00" class="kt ig hi ke b fi lu lv l lw lx">package main<br/>import("fmt")</span><span id="7a97" class="kt ig hi ke b fi ly lv l lw lx">func main() {<br/>         fmt.Println("one")<br/>         defer fmt.Println("three")<br/>         fmt.Println("two")</span><span id="7e44" class="kt ig hi ke b fi ly lv l lw lx">}</span></pre><p id="cdc0" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">输出:</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="d158" class="kt ig hi ke b fi lu lv l lw lx">one<br/>two<br/>three</span></pre><p id="99d4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">注意<code class="du kb kc kd ke b">three</code>是最后打印的。这是因为在使用了<code class="du kb kc kd ke b">defer</code>的函数结束之前，不会调用任何以<code class="du kb kc kd ke b">defer</code>关键字开头的语句。</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="a78c" class="kt ig hi ke b fi lu lv l lw lx">package main<br/>import("fmt")</span><span id="b4a2" class="kt ig hi ke b fi ly lv l lw lx">func main() {<br/>         defer fmt.Println("one")<br/>         defer fmt.Println("two")<br/>         defer fmt.Println("three")</span><span id="7378" class="kt ig hi ke b fi ly lv l lw lx">}</span></pre><p id="a316" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">输出:</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="2cf4" class="kt ig hi ke b fi lu lv l lw lx">three<br/>two<br/>one</span></pre><p id="93cd" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">如上面的属性所述，第一个被调用的defer语句是最后一个被执行的。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h2 id="d9fa" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">恐慌</h2><p id="7945" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">panic</code>是一个内置函数，用于停止程序的控制流。这可以由编译器完成，也可以手动添加到代码流中。当您的应用程序进入无法恢复的状态时，我们会使用紧急语句。例如:试图将一个数除以0。<br/>当程序根本无法继续时，它们就会发生。</p><h2 id="78b0" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">性能</h2><ol class=""><li id="fed4" class="kk kl hi jf b jg jh jk jl jo km js kn jw ko ka kp kq kr ks bi translated">在执行一条<strong class="jf hj"> </strong> <em class="mg">延期</em> <strong class="jf hj"> </strong>语句后会发生死机。</li><li id="6c82" class="kk kl hi jf b jg lh jk li jo lj js lk jw ll ka kp kq kr ks bi translated">运行panic语句后，程序结束。</li></ol><h2 id="1009" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">如何利用恐慌</h2><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="3dcf" class="kt ig hi ke b fi lu lv l lw lx">package main<br/>import "fmt"</span><span id="bd44" class="kt ig hi ke b fi ly lv l lw lx">func main(){<br/>        fmt.Println("one")<br/>        defer fmt.Println("three")<br/>        panic("a panic happened")<br/>        fmt.Println("four")</span><span id="f9bc" class="kt ig hi ke b fi ly lv l lw lx">}</span></pre><p id="08ec" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">输出:</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="c5a6" class="kt ig hi ke b fi lu lv l lw lx">one<br/>three<br/>panic: a panic happened</span></pre><p id="ccd2" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">正如你在上面看到的，由于代码编译器中调用的恐慌，我们没有执行程序的其余部分。</p><p id="a9b4" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><strong class="jf hj">再比如:</strong></p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="ba74" class="kt ig hi ke b fi lu lv l lw lx">package main</span><span id="2a1e" class="kt ig hi ke b fi ly lv l lw lx">import "fmt"</span><span id="3401" class="kt ig hi ke b fi ly lv l lw lx">func main() {<br/> x := 0<br/> y := 20<br/> fmt.Println(y/x)<br/>}</span></pre><p id="be67" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">输出:</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="ece4" class="kt ig hi ke b fi lu lv l lw lx">panic: runtime error: integer divide by zero<br/><br/>goroutine 1 [running]:<br/>main.main()<br/>	/tmp/sandbox064477089/prog.go:8 +0x11</span></pre><p id="a658" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">上面的输出显示，defer语句不是最后运行，而是在死机发生之前首先执行。注意:Go编译器也可能导致死机。</p></div><div class="ab cl lz ma gp mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hb hc hd he hf"><h1 id="b2be" class="if ig hi bd ih ii mh ik il im mi io ip iq mj is it iu mk iw ix iy ml ja jb jc bi translated">恢复</h1><p id="2cd4" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><code class="du kb kc kd ke b">recover</code>功能用于从<code class="du kb kc kd ke b">panic</code>恢复功能。<strong class="jf hj">恢复</strong>只在<strong class="jf hj">延迟</strong>函数内部有用。在正常执行中，对<strong class="jf hj"> recover </strong>的调用将返回<code class="du kb kc kd ke b">nil</code>，并且没有其他影响。一个<code class="du kb kc kd ke b">recover</code>函数应该总是在一个<code class="du kb kc kd ke b">defer</code>函数内部被调用，因为如果程序死机，延迟函数不会停止执行，所以<code class="du kb kc kd ke b">recover</code>函数会停止死机。</p><h2 id="db06" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">性能</h2><ol class=""><li id="e51a" class="kk kl hi jf b jg jh jk jl jo km js kn jw ko ka kp kq kr ks bi translated"><em class="mg">恢复</em> <strong class="jf hj"> </strong>报表是用来出<strong class="jf hj">恐慌</strong>的</li><li id="818a" class="kk kl hi jf b jg lh jk li jo lj js lk jw ll ka kp kq kr ks bi translated">在延迟函数中很有用。这是因为当应用程序崩溃时，除了延迟的函数之外，它不再执行程序的其余部分。</li></ol><h2 id="83d7" class="kt ig hi bd ih ku kv kw il kx ky kz ip jo la lb it js lc ld ix jw le lf jb lg bi translated">如何使用Recov <code class="du kb kc kd ke b">er</code></h2><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="7a5c" class="kt ig hi ke b fi lu lv l lw lx">package main</span><span id="3342" class="kt ig hi ke b fi ly lv l lw lx">import "fmt"</span><span id="07e6" class="kt ig hi ke b fi ly lv l lw lx">func main() {<br/> x := 0<br/> y := 20<br/> printAllOperations(x, y)<br/>}</span><span id="dbf6" class="kt ig hi ke b fi ly lv l lw lx">func printAllOperations(x int, y int) {</span><span id="a82e" class="kt ig hi ke b fi ly lv l lw lx">defer func() {<br/> // defer function to escape the panic when y/x runs<br/>  if r := recover(); r != nil {<br/>   fmt.Printf("Recovering from panic in printAllOperations error is: %v \n", r)<br/>   fmt.Println("Proceeding to alternative flow skipping division.")<br/>   printOperationsSkipDivide(x, y)<br/>  }<br/> }()</span><span id="2803" class="kt ig hi ke b fi ly lv l lw lx">sum, divide, multiply := x+y, y/x, x*y<br/> fmt.Printf("sum=%v, divide=%v, multiply=%v \n", sum, divide, multiply)<br/>}</span><span id="ca97" class="kt ig hi ke b fi ly lv l lw lx">func printOperationsSkipDivide(x int, y int) {<br/> sum, multiply := x+y, y*x<br/> fmt.Printf("sum=%v, multiply=%v \n", sum, multiply)<br/>}</span></pre><p id="298d" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated">输出:</p><pre class="lm ln lo lp fd lq ke lr ls aw lt bi"><span id="2c8b" class="kt ig hi ke b fi lu lv l lw lx">Recovering from panic in printAllOperations error is: runtime error: integer divide by zero <br/>Proceeding to alternative flow skipping division.<br/>sum=20, multiply=0</span></pre><p id="6f51" class="pw-post-body-paragraph jd je hi jf b jg kf ji jj jk kg jm jn jo kh jq jr js ki ju jv jw kj jy jz ka hb bi translated"><code class="du kb kc kd ke b">20/0</code>在Go编译器中引起了混乱，因此它调用了defer函数，该函数打印了其余结果的结果</p><h1 id="7b27" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结论</h1><p id="450b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本教程中，我们能够了解如何在Golang应用程序中使用defer、recover和panic函数。我希望这个指南能帮助你用那些函数写出更好的Golang。</p></div></div>    
</body>
</html>