<html>
<head>
<title>Facial expression detection using Machine Learning in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于Python的机器学习人脸表情检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/facial-expression-detection-using-machine-learning-in-python-c6a188ac765f?source=collection_archive---------1-----------------------#2021-01-05">https://medium.com/analytics-vidhya/facial-expression-detection-using-machine-learning-in-python-c6a188ac765f?source=collection_archive---------1-----------------------#2021-01-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="7d85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用<em class="jd">机器学习算法</em>如<strong class="ih hj"> CNN </strong>来检测<strong class="ih hj">面部表情</strong>，然后预测表现出哪种表情。</p><p id="4c95" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">举例</strong>:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/c222ca1e511b41e19a29dcb992363a98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ko6oX3rRb0aTgdUI.gif"/></div></div></figure><p id="b89a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的视频中，我们可以看到一个蓝色的盒子突出了女士的脸。在青色的方框上方，显示了由我们的机器学习算法预测的表达式。较大的灰色文本是实际表达。</p><h1 id="5038" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">解决方案/方法</strong>:</h1><p id="4aa5" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated"><strong class="ih hj">简介(为什么需要它)——&gt;T11】</strong></p><p id="f801" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，对于许多公司来说，情绪检测是一项非常重要的任务，以了解消费者对他们推出的产品的反应。它还可以用来了解他们的员工是否对提供给他们的设施感到满意。此外，它还有许多其他用例，如检查一个人的情绪，而不用靠近他，因为我们使用相机来检测。同样的算法只需要一点点修改，可以用于其他领域，如人脸检测，考勤系统，面具检测等等…</p><h1 id="07f4" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">步骤# 1-&gt;-T13】</strong></h1><p id="f8b0" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">导入所需的python库，如<strong class="ih hj"/><a class="ae kt" href="https://www.geeksforgeeks.org/python-numpy/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">numpy</strong></a><strong class="ih hj">，</strong><a class="ae kt" href="https://www.geeksforgeeks.org/seaborn-distribution-plots/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">seaborn</strong></a><strong class="ih hj">，</strong><a class="ae kt" href="https://www.geeksforgeeks.org/python-introduction-matplotlib/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">matplotlib</strong></a><strong class="ih hj">，</strong><a class="ae kt" href="https://www.geeksforgeeks.org/introduction-to-tensorflow/" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj">tensor flow</strong></a></p><p id="a60b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="3d06" class="kz jr hi kv b fi la lb l lc ld">import numpy as np<br/>import seaborn as sns<br/>import matplotlib.pyplot as plt<br/>import utils<br/>import os</span><span id="f7ee" class="kz jr hi kv b fi le lb l lc ld">from tensorflow.keras.preprocessing.image import ImageDataGenerator<br/>from tensorflow.keras.layers import Dense, Input, Dropout,Flatten, Conv2D<br/>from tensorflow.keras.layers import BatchNormalization, Activation, MaxPooling2D<br/>from tensorflow.keras.models import Model, Sequential<br/>from tensorflow.keras.optimizers import Adam<br/>from tensorflow.keras.callbacks import ModelCheckpoint, ReduceLROnPlateau<br/>from tensorflow.keras.utils import plot_model</span><span id="f1b1" class="kz jr hi kv b fi le lb l lc ld">from IPython.display import SVG, Image<br/>from livelossplot.inputs.tf_keras import PlotLossesCallback<br/>import tensorflow as tf<br/>print("Tensorflow version:", tf.__version__)</span></pre><p id="e74c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们从tensorflow的包装<a class="ae kt" href="https://www.geeksforgeeks.org/python-image-classification-using-keras/" rel="noopener ugc nofollow" target="_blank"> keras </a>中导入了不同的模块。我们特别从keras引进了这些模块，这将有助于建立一个CNN模型。在上面代码的最后一行，我们打印了系统中tensorflow的当前版本。</p><p id="28bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">请注意- &gt; </strong>所需的tensorflow版本必须大于或等于2.0</p><h1 id="6aaf" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">步骤2-&gt;-</strong></h1><p id="d595" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在，我们将获得我们的模型将在其上进行训练的数据集，我们将验证我们的模型在该特定数据集上的表现如何，以便我们可以提高准确性分数。我已经在Kaggle上上传了我使用的数据集，这样任何人都可以访问它。<strong class="ih hj">数据集的链接是:——</strong><a class="ae kt" href="https://www.kaggle.com/aadityasinghal/facial-expression-dataset" rel="noopener ugc nofollow" target="_blank">https://www . ka ggle . com/aadityasinghal/face-expression-dataset</a></p><p id="c9a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">数据集有七类表达式。</em> </strong></p><h1 id="c58f" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第三步-&gt;T9】</strong></h1><p id="8ec7" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们已经获得了数据集，现在让我们获得一些关于train和test文件夹的信息。</p><p id="5e10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="822e" class="kz jr hi kv b fi la lb l lc ld">for expression in os.listdir("PATH OF TRAIN FOLDER"):<br/>    print(str(len(os.listdir("PATH OF TRAIN FOLDER" + expression))) + " " + expression + " images")</span></pre><p id="0c9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码使用<strong class="ih hj"> <em class="jd"> os </em> </strong>库来获取train文件夹路径，然后我们打印每个表达式文件夹的总数和类别。</p><h1 id="0ff0" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第4步-&gt;T15】</strong></h1><p id="f686" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在，我们将<strong class="ih hj"> <em class="jd">生成训练和测试(验证)批次</em> </strong>，以便我们的模型可以根据测试数据进行训练和评估/验证。这是非常重要的一步，因为没有这一步，我们就不能有一个准确的模型，而且没有训练，模型也不知道它要寻找什么，也不知道要预测什么。</p><p id="6e02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="679b" class="kz jr hi kv b fi la lb l lc ld">img_size = 48<br/>batch_size = 64</span><span id="34d6" class="kz jr hi kv b fi le lb l lc ld">datagen_train = ImageDataGenerator(horizontal_flip=True)</span><span id="0513" class="kz jr hi kv b fi le lb l lc ld">train_generator = datagen_train.flow_from_directory("PATH OF TRAIN FOLDER",<br/>                                                    target_size=(img_size,img_size),<br/>                                                    color_mode="grayscale",<br/>                                                    batch_size=batch_size,<br/>                                                    class_mode='categorical',<br/>                                                    shuffle=True)</span><span id="f592" class="kz jr hi kv b fi le lb l lc ld">datagen_validation = ImageDataGenerator(horizontal_flip=True)<br/>validation_generator = datagen_validation.flow_from_directory("PATH OF TEST FOLDER",<br/>                                                    target_size=(img_size,img_size),<br/>                                                    color_mode="grayscale",<br/>                                                    batch_size=batch_size,<br/>                                                    class_mode='categorical',<br/>                                                    shuffle=False)</span></pre><p id="3755" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们已经将<strong class="ih hj"> <em class="jd">的图像尺寸定义为48 </em> </strong>，因此每张图像的尺寸都将被缩小到48x48。之后，我们将<strong class="ih hj"> <em class="jd">批次大小定义为等于64 </em> </strong>，这意味着在每个时期，即当模型在每个周期穿过训练数据集时，<strong class="ih hj"> <em class="jd">将通过的图像数量将为64 </em> </strong>。这意味着该模型将通过第一个时期获取前64个图像用于训练，并将继续如此，直到所有时期完成。</p><p id="c35a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们使用keras模块  <em class="jd"> </em>中的<em class="jd"><strong class="ih hj"><em class="jd">imagedata generator生成批量的张量图像数据，并进行实时数据扩充。在这里，我们保持<strong class="ih hj"> <em class="jd">水平翻转真</em> </strong>这意味着它将随机水平翻转输入图像。</em></strong></em></p><p id="e159" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将执行主要且最重要的步骤，即<strong class="ih hj"> <em class="jd">生成训练和测试数据图像</em> </strong>。</p><p id="afc2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们将获取训练数据。这里，我们使用了来自ImageDataGenerator的datagen_train函数，即<strong class="ih hj"><em class="jd">flow _ from _ directory</em></strong>，它采用了几个参数，如数据集的路径、target_size(输出图像的大小)、color_mode(输出图像的颜色，我们已经设置了给出灰色图像的gayscale)、batch_size、class_mode(确定返回的标签数组的类型，我们已经指定了categorical)以及shuffle False。</p><p id="edfb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们将执行上面的<strong class="ih hj"> <em class="jd">来生成测试数据集图像</em> </strong>。唯一的变化是测试文件夹的路径。</p><h1 id="c18b" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第5步-&gt;T9】</strong></h1><p id="8941" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">到目前为止，我们已经导入了库，获得了数据集，并创建了训练和测试图像。现在是时候进入另一个重要的步骤了，那就是<strong class="ih hj"> <em class="jd">建立CNN模型。</em>T13】</strong></p><p id="7f39" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="a7dc" class="kz jr hi kv b fi la lb l lc ld"># Initialising the CNN<br/>model = Sequential()</span><span id="ca52" class="kz jr hi kv b fi le lb l lc ld"># 1 - Convolution<br/>model.add(Conv2D(64,(3,3), padding='same', input_shape=(48, 48,1)))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="5c4c" class="kz jr hi kv b fi le lb l lc ld"># 2nd Convolution layer<br/>model.add(Conv2D(128,(5,5), padding='same'))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="037f" class="kz jr hi kv b fi le lb l lc ld"># 3rd Convolution layer<br/>model.add(Conv2D(512,(3,3), padding='same'))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="a1bc" class="kz jr hi kv b fi le lb l lc ld"># 4th Convolution layer<br/>model.add(Conv2D(512,(3,3), padding='same'))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(MaxPooling2D(pool_size=(2, 2)))<br/>model.add(Dropout(0.25))</span><span id="ab1f" class="kz jr hi kv b fi le lb l lc ld"># Flattening<br/>model.add(Flatten())</span><span id="d22e" class="kz jr hi kv b fi le lb l lc ld"># Fully connected layer 1st layer<br/>model.add(Dense(256))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(Dropout(0.25))</span><span id="e190" class="kz jr hi kv b fi le lb l lc ld"># Fully connected layer 2nd layer<br/>model.add(Dense(512))<br/>model.add(BatchNormalization())<br/>model.add(Activation('relu'))<br/>model.add(Dropout(0.25))</span><span id="b287" class="kz jr hi kv b fi le lb l lc ld">model.add(Dense(7, activation='softmax'))</span><span id="47cd" class="kz jr hi kv b fi le lb l lc ld">opt = Adam(lr=0.0005)<br/>model.compile(optimizer=opt, loss='categorical_crossentropy', metrics=['accuracy'])<br/>model.summary()</span></pre><p id="65d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们已经创建了神经网络的基本结构。为此，我们从keras模块<strong class="ih hj"><em class="jd"/></strong>中获得了帮助，它是tensorflow库的一个很好的包装器，有助于减少我们的工作。首先我们已经通过使用顺序( )函数<strong class="ih hj"> <em class="jd">初始化了CNN模型。之后我们创建了<strong class="ih hj"> <em class="jd">神经网络的前四层</em> </strong>即<strong class="ih hj"> <em class="jd">卷积层。</em>T29】</strong></em></strong></p><p id="de5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络，或简称为CNN，是一种专门类型的神经网络模型，设计用于处理<strong class="ih hj"> <em class="jd">二维图像数据</em> </strong>，尽管它们可以用于一维和三维数据。<strong class="ih hj"> <em class="jd">卷积是一种线性运算</em> </strong>，它涉及一组权重与输入的相乘，很像传统的神经网络。乘法是在输入数据数组和二维权重数组(称为过滤器或内核)之间执行的。这方面的可视化如下所示</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lf"><img src="../Images/c4ded46de18c572a34d5f5ca8610be7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*wRf357Ve7FUCCaZn.gif"/></div></figure><p id="dfc1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以使用model.add ()将卷积层<strong class="ih hj">添加到我们的模型中。这需要几个参数，如<strong class="ih hj"> Conv2D </strong>，它指定要添加的层是卷积层。这个方法也需要两个参数，第一个是过滤器数量<strong class="ih hj"><em class="jd"/></strong>和池数量<strong class="ih hj"/>。之后，我们应用<strong class="ih hj"> <em class="jd">批量标准化</em> </strong>，该标准化应用了一个保持平均输出接近0和输出标准偏差接近1的变换。之后，添加激活功能<strong class="ih hj"><em class="jd"/></strong>，它对输入信号进行非线性变换。然后，这个转换后的输出被发送到下一层神经元作为输入。之后我们应用了<strong class="ih hj"> <em class="jd"> MaxPolling2D </em> </strong>，它只从池中取出最大值。最后我们添加了<strong class="ih hj"><em class="jd"/></strong>来防止模型过拟合。这里我们完成了卷积层的构建。</strong></p><p id="9b15" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="jd">此处，对于所有四个卷积层，除Conv2D之外的所有参数保持不变。对于第一个Conv，我们也提到了输入大小，即要接收的图像的大小。</em></p><p id="b241" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们添加了<strong class="ih hj"> <em class="jd">展平层</em> </strong>，它将数据转换成一个<strong class="ih hj"> <em class="jd">一维数组</em> </strong>用于输入到下一层。我们展平卷积层的输出以创建单个<strong class="ih hj"> <em class="jd">长特征向量</em> </strong>。并且它连接到最终的分类模型，该分类模型被称为全连接层。</p><p id="0d8b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们将完全连接的层添加到模型中。为了创建一个完全连接的层，我们首先添加一个<strong class="ih hj"> <em class="jd">密集层</em> </strong>，它是一个规则的深度连接的神经网络层。这是最常见和最常用的层。之后我们添加<strong class="ih hj"> <em class="jd">批量归一化图层。</em> </strong>和最后<strong class="ih hj"> <em class="jd">激活</em> </strong>和<strong class="ih hj"> <em class="jd">脱落层。</em>T57】</strong></p><p id="cc5b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于所有的层，到目前为止，我们一直保持激活函数ReLU，因为ReLU是半整流的(从底部)。当z小于零时f(z)为零，当z大于或等于零时f(z)等于z。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/4357daa20d539c6e3a812757061aa441.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*WusNZIQhDyi7AJ17.png"/></div></figure><p id="9416" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但在所有上述层之后，我们将最终添加一个<strong class="ih hj"> <em class="jd">密集层</em> </strong>层，激活设置为<strong class="ih hj"> <em class="jd"> Softmax </em> </strong>，这将数字(又名逻辑)转换为<strong class="ih hj"> <em class="jd">概率，总和为一个</em> </strong>。Softmax函数输出一个向量，该向量表示一系列潜在结果的概率分布。</p><p id="df96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，在上述模型的输出中，我们最终得到0到1范围内的概率，从而使我们易于对表达式进行分类。</p><p id="3f25" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后我们使用<strong class="ih hj"><em class="jd">model . compile</em></strong>来编译模型。它采用一些类似于<strong class="ih hj"> <em class="jd">优化器</em> </strong>的参数，通过比较预测和损失函数来优化输入权重。我们已经用指定的学习速率(lr)将优化器保持为<strong class="ih hj"> <em class="jd">亚当</em> </strong>。之后，我们将<strong class="ih hj"> <em class="jd">损失</em> </strong>添加到<strong class="ih hj"> <em class="jd">分类_交叉熵</em> </strong>中，并保留了<strong class="ih hj"> <em class="jd">度量值(</em> </strong>，用于评估模型的性能，等于<strong class="ih hj"> <em class="jd"> ) </em> </strong> <strong class="ih hj"> <em class="jd">精度。</em> </strong>最后我们使用<strong class="ih hj"> <em class="jd"> model.summary()输出了模型摘要。</em>T47】</strong></p><h1 id="1b29" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第6步-&gt;T49】</strong></h1><p id="acaa" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">到目前为止，我们已经编译了我们的模型。现在让我们使用下面给出的代码来可视化<strong class="ih hj"> <em class="jd">模型架构</em> </strong>。</p><p id="cd9f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="8793" class="kz jr hi kv b fi la lb l lc ld">plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)<br/>Image('model.png',width=400, height=200)</span></pre><p id="773e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们使用了<strong class="ih hj"> <em class="jd"> plot_model </em> </strong>，这也是keras库的一个功能。我们给了它相同的参数，如<strong class="ih hj"> <em class="jd">模型名称</em> </strong>，文件名，即<strong class="ih hj"> <em class="jd"> to_file </em> </strong>，<strong class="ih hj"> <em class="jd"> show_shapes </em> </strong>显示形状信息，以及<em class="jd"> show_layer_names </em> :显示图层名称。</p><p id="7b00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后我们使用了<strong class="ih hj"> <em class="jd"> Ipython库</em> </strong>函数<strong class="ih hj"> <em class="jd">图像</em> </strong>来显示输出中的模型架构。它需要几个<strong class="ih hj"> <em class="jd">参数</em> </strong>像<strong class="ih hj"> <em class="jd">文件名，宽度和高度</em> </strong>的图像来显示。这个(图像)的输出如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lh"><img src="../Images/2537d0cd4fb876e5234e0074bc4cccb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:100/format:webp/0*AMxp-6cuj6ylE0sV.png"/></div></figure><h1 id="efae" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第7步-&gt;T91】</strong></h1><p id="7d31" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">既然我们已经成功构建了模型架构，现在是时候<strong class="ih hj"> <em class="jd">训练模型并评估结果了。</em>T95】</strong></p><p id="7544" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="3cc6" class="kz jr hi kv b fi la lb l lc ld">%%time</span><span id="4f60" class="kz jr hi kv b fi le lb l lc ld">epochs = 15<br/>steps_per_epoch = train_generator.n//train_generator.batch_size<br/>validation_steps = validation_generator.n//validation_generator.batch_size</span><span id="bbfc" class="kz jr hi kv b fi le lb l lc ld">reduce_lr = ReduceLROnPlateau(monitor='val_loss', factor=0.1,<br/>                              patience=2, min_lr=0.00001, mode='auto')<br/>checkpoint = ModelCheckpoint("model_weights.h5", monitor='val_accuracy',<br/>                             save_weights_only=True, mode='max', verbose=1)<br/>callbacks = [PlotLossesCallback(), checkpoint, reduce_lr]</span><span id="49c6" class="kz jr hi kv b fi le lb l lc ld">history = model.fit(<br/>    x=train_generator,<br/>    steps_per_epoch=steps_per_epoch,<br/>    epochs=epochs,<br/>    validation_data = validation_generator,<br/>    validation_steps = validation_steps,<br/>    callbacks=callbacks<br/>)</span></pre><p id="4b46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上面的代码<strong class="ih hj"> <em class="jd">在<strong class="ih hj"> <em class="jd">训练数据集</em> </strong>上训练我们的模型</em> </strong>，同时它<strong class="ih hj"> <em class="jd">在<strong class="ih hj"> <em class="jd">测试/验证数据集</em> </strong>上验证</em>。</strong></p><p id="5f2c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">首先，我们已经设置了<strong class="ih hj"> <em class="jd">个历元</em> </strong>，其中一个<strong class="ih hj"> <em class="jd">历元</em> </strong>是整个数据集仅通过神经网络向前和向后传递一次。由于一个时期太大，不能一次输入计算机，我们把它分成几个更小的批次。 随着历元数的增加，神经网络中权值改变的次数越多，曲线从<strong class="ih hj"> <em class="jd">欠拟合到最优再到过拟合曲线</em> </strong>。</p><p id="ea27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要提示:- </strong>我将历元数保持为15，您可以增加它以获得更高的精度和更好的结果。</p><p id="6359" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们将每个时期的步骤和验证步骤设置为等于图像总数除以批量大小的整数输出。</p><p id="248f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们设置了<strong class="ih hj"><em class="jd">ReduceLROnPlateau</em></strong>，用于在检测到模型性能平稳时调整学习率，例如，给定数量的训练时期没有变化。之后我们设置了<strong class="ih hj"> <em class="jd">模型检查点</em> </strong>，它允许你定义在哪里检查<strong class="ih hj"> <em class="jd">模型权重</em> </strong>，文件应该如何命名以及在什么情况下做模型的检查点。在这之后，我们用<strong class="ih hj"><em class="jd">PlotLossesCallback()</em></strong>设置了<strong class="ih hj"> <em class="jd">回调</em> </strong>，它给出了训练如何进行的实时报告，我们还添加了<strong class="ih hj"> <em class="jd">检查点</em> </strong>和<strong class="ih hj"> <em class="jd"> reduce_lr </em> </strong>。</p><p id="a263" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后我们完成了<strong class="ih hj"> <em class="jd"> model.fit() </em> </strong>开始了的训练和验证</p><p id="d1be" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的模型。其以一些参数作为输入，如<strong class="ih hj"> <em class="jd"> x - &gt;训练数据集</em> </strong>即每历元<strong class="ih hj"> <em class="jd">步数</em> </strong>、<strong class="ih hj"> <em class="jd">验证数据、验证步数</em> </strong>和<strong class="ih hj"> <em class="jd">回调</em> </strong>。运行上述代码后的输出如下所示。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es lg"><img src="../Images/5022b06fa6a7cf82aa42dbd6b8500904.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/0*HONxHHBZjWdx1PlX.png"/></div></figure><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="cbbe" class="kz jr hi kv b fi la lb l lc ld">Log-loss (cost function):<br/>training   (min:    0.866, max:    1.786, cur:    0.866)<br/>validation (min:    0.970, max:    1.705, cur:    0.970)</span><span id="d18c" class="kz jr hi kv b fi le lb l lc ld">accuracy:<br/>training   (min:    0.313, max:    0.675, cur:    0.675)<br/>validation (min:    0.381, max:    0.643, cur:    0.643)</span><span id="1f1e" class="kz jr hi kv b fi le lb l lc ld">Epoch 00015: saving model to model_weights.h5<br/>448/448 [==============================] - 27s 60ms/step - loss: 0.8659 - accuracy: 0.6748 - val_loss: 0.9700 - val_accuracy: 0.6426<br/>CPU times: user 6min 50s, sys: 57.4 s, total: 7min 47s<br/>Wall time: 6min 46s</span></pre><p id="d4b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们通过仅运行15个时期，在数据集上获得了接近68%的准确率。您可以运行更多的时期，并可以更改一些其他参数，以获得更高的准确性。</p><h1 id="dc5c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">步骤# 8-&gt;-</strong></h1><p id="ca32" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们已经得到了一个训练好的模型，让<strong class="ih hj"> <em class="jd">将模型</em> </strong>保存为<strong class="ih hj"> <em class="jd"> json </em> </strong>格式，同时保存其<strong class="ih hj"> <em class="jd">权重</em> </strong>。</p><p id="1c54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="5660" class="kz jr hi kv b fi la lb l lc ld">model_json = model.to_json()<br/>model.save_weights('model_weights.h5')<br/>with open("model.json", "w") as json_file:<br/>    json_file.write(model_json)</span></pre><p id="3876" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们首先将<strong class="ih hj"> <em class="jd">模型转换为json格式。</em> </strong>之后我们已经<strong class="ih hj"> <em class="jd">以. h5格式</em> </strong>保存了模型的权重。之后，我们以写模式打开一个model.json文件，并将转换成json格式的模型写入该文件。现在我们得到了两个名为<strong class="ih hj"> <em class="jd"> model.json和model_weights.h5 </em> </strong>的文件，分别用于模型及其权重，可以在任何地方使用它们进行预测。</p><h1 id="69bc" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第9步-&gt;T25】</strong></h1><p id="e719" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们将为<strong class="ih hj"> <em class="jd">编写一个Python代码来加载模型和权重，并进行预测</em> </strong>。</p><p id="b768" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="449c" class="kz jr hi kv b fi la lb l lc ld">from tensorflow.keras.models import model_from_json</span><span id="2a9b" class="kz jr hi kv b fi le lb l lc ld">class FacialExpressionModel(object):</span><span id="3f7d" class="kz jr hi kv b fi le lb l lc ld">    EMOTIONS_LIST = ["Angry", "Disgust",<br/>                    "Fear", "Happy",<br/>                    "Neutral", "Sad",<br/>                    "Surprise"]</span><span id="15ff" class="kz jr hi kv b fi le lb l lc ld">    def __init__(self, model_json_file, model_weights_file):<br/>        # load model from JSON file<br/>        with open(model_json_file, "r") as json_file:<br/>            loaded_model_json = json_file.read()<br/>            self.loaded_model = model_from_json(loaded_model_json)</span><span id="0487" class="kz jr hi kv b fi le lb l lc ld">        # load weights into the new model<br/>        self.loaded_model.load_weights(model_weights_file)<br/>        self.loaded_model.make_predict_function()</span><span id="14e8" class="kz jr hi kv b fi le lb l lc ld">    def predict_emotion(self, img):<br/>        self.preds = self.loaded_model.predict(img)<br/>        return FacialExpressionModel.EMOTIONS_LIST[np.argmax(self.preds)]</span></pre><p id="4154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们首先导入了<strong class="ih hj"><em class="jd">model _ from _ json</em></strong>函数，它帮助我们从JSON文件中导入模型。之后，我们编写了一个<strong class="ih hj"> <em class="jd"> python类</em> </strong>，其中首先有一个<strong class="ih hj"> <em class="jd">情感列表</em> </strong>，它包含了我们的数据集。之后我们定义了<strong class="ih hj"> <em class="jd"> init方法</em> </strong>，它采用了<strong class="ih hj"> <em class="jd"> model.json文件和. h5格式的模型权重文件</em> </strong>。在此之后，我们将<strong class="ih hj"> <em class="jd">读取json </em> </strong>文件，并使用model_from_json函数<strong class="ih hj"> <em class="jd">加载模型</em> </strong>。之后，我们将<strong class="ih hj"> <em class="jd">将重量</em> </strong>加载到模型中。</p><p id="af0d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后在这个类中我们定义了一个<strong class="ih hj"> <em class="jd">方法</em> </strong>命名为<strong class="ih hj"><em class="jd">predict _ emotion</em></strong>它给出了图像的预测。首先它使用<strong class="ih hj"> <em class="jd">。预测</em> </strong>方法给出预测之后，我们用<strong class="ih hj"> <em class="jd"> numpy argmax </em> </strong>得到一个<strong class="ih hj"> <em class="jd">整数b/w 0–6</em></strong>表示列表中对应的情感。最后我们<strong class="ih hj"> <em class="jd">返回那个特定的情感名称。</em>T85】</strong></p><h1 id="4375" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第十步-&gt;T87】</strong></h1><p id="2da1" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们已经有了将权重加载到模型中的模式代码，现在我们将g <strong class="ih hj"> <em class="jd">设置视频的帧，并将对其执行预测</em> </strong>。</p><p id="9d02" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="e21d" class="kz jr hi kv b fi la lb l lc ld">import cv2</span><span id="a34f" class="kz jr hi kv b fi le lb l lc ld">facec = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')<br/>model = FacialExpressionModel("model.json", "model_weights.h5")<br/>font = cv2.FONT_HERSHEY_SIMPLEX</span><span id="4e50" class="kz jr hi kv b fi le lb l lc ld">class VideoCamera(object):<br/>    def __init__(self):<br/>        self.video = cv2.VideoCapture(0)</span><span id="3a2d" class="kz jr hi kv b fi le lb l lc ld">    def __del__(self):<br/>        self.video.release()</span><span id="4a4c" class="kz jr hi kv b fi le lb l lc ld">    # returns camera frames along with bounding boxes and predictions<br/>    def get_frame(self):<br/>        _, fr = self.video.read()<br/>        gray_fr = cv2.cvtColor(fr, cv2.COLOR_BGR2GRAY)<br/>        faces = facec.detectMultiScale(gray_fr, 1.3, 5)</span><span id="0dd1" class="kz jr hi kv b fi le lb l lc ld">        for (x, y, w, h) in faces:<br/>            fc = gray_fr[y:y+h, x:x+w]</span><span id="0f5a" class="kz jr hi kv b fi le lb l lc ld">            roi = cv2.resize(fc, (48, 48))<br/>            pred = model.predict_emotion(roi[np.newaxis, :, :, np.newaxis])</span><span id="0b30" class="kz jr hi kv b fi le lb l lc ld">            cv2.putText(fr, pred, (x, y), font, 1, (255, 255, 0), 2)<br/>            cv2.rectangle(fr,(x,y),(x+w,y+h),(255,0,0),2)</span><span id="b41b" class="kz jr hi kv b fi le lb l lc ld">        return fr</span></pre><p id="bf56" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们首先<strong class="ih hj"> <em class="jd">导入OpenCV模块。</em> </strong>之后，我们设置<strong class="ih hj"> <em class="jd"> CascadeClassifier和Haar Cascade classifier</em></strong>，用于通过在人脸片段上叠加预定义的模式来检测特征，并用作XML文件。在我们的模型中。</p><p id="53cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们使用的<strong class="ih hj"> <em class="jd">哈尔级联分类器</em> </strong>在这里  <strong class="ih hj">可以找到<a class="ae kt" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_frontalface_default.xml" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">。</strong></a></strong></p><p id="f9d9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们通过传递model.json文件和权重文件来调用模型。在这之后，我们已经为CV2设置了字体。之后我们又写了一个<strong class="ih hj"> <em class="jd">的python类</em> </strong>。在类中，我们首先声明了<strong class="ih hj"> <em class="jd"> init方法</em> </strong>，它使用<strong class="ih hj"><em class="jd">cv2 video capture</em></strong>方法来访问您想要预测的摄像机或视频文件。</p><p id="5c85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> <em class="jd">重要注意:- </em> </strong></p><p id="a6b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们将<strong class="ih hj"> <em class="jd"> 0作为参数传递给了VideoCapture。</em> </strong>您可以将0改为视频文件的路径来对视频文件进行预测。这里0表示CV2将从您的PC的网络摄像头获取视频。</p><p id="fc21" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们为类 声明了<strong class="ih hj"> <em class="jd">析构函数，当你想停止时，它释放视频并停止方法。</em></strong></p><p id="b06f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们声明了一个名为<strong class="ih hj"> <em class="jd"> get_frame </em> </strong>的方法，它首先读取视频。之后，我们使用了<strong class="ih hj"> <em class="jd"> cv2.cvtColor() </em> </strong>方法将图像从一个颜色空间转换到另一个颜色空间。这里我们用了<strong class="ih hj"> <em class="jd"> cv2。COLOR_BGR2GRAY </em> </strong>它将图像转换为灰色，因为我们的模型是在灰色图像上训练的。之后我们使用了<strong class="ih hj"><em class="jd">detect multi scale()</em></strong>来检测输入图像中不同大小的物体。检测到的对象以矩形列表的形式返回。之后，我们循环到返回图像的不同坐标，并使用<strong class="ih hj"> <em class="jd"> CV2.resize() </em> </strong>函数调整图像大小。最后我们用<strong class="ih hj"><em class="jd">model . predict _ emotion</em></strong>得到预测的情绪。之后，我们将文本放在图像的框架上，该图像显示了预测的情绪，我们还将矩形框放在检测到人脸的区域周围。 最后我们让<strong class="ih hj"> <em class="jd">返回那个帧</em> </strong>以及预测的框和文本。</p><h1 id="7645" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第11步-&gt;T41】</strong></h1><p id="7fc3" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们已经有了mode所有重要的函数，现在让我们制作<strong class="ih hj"> <em class="jd">函数来调用上面的代码并显示输出视频。</em>T45】</strong></p><p id="ac9d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="c6e2" class="kz jr hi kv b fi la lb l lc ld">def gen(camera):<br/>    while True:<br/>        frame = camera.get_frame()<br/>        cv2.imshow('Facial Expression Recognization',frame)<br/>        if cv2.waitKey(1) &amp; 0xFF == ord('q'):<br/>            break<br/>    cv2.destroyAllWindows()</span></pre><p id="c01c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们声明了一个名为<strong class="ih hj"> <em class="jd"> gen </em> </strong>的python函数，它将<strong class="ih hj"> <em class="jd">相机作为参数。</em> </strong>在此我们运行一个<strong class="ih hj"> <em class="jd"> while循环为真</em> </strong>，连续进行。在此我们先调用<strong class="ih hj"> <em class="jd">获取摄像机的_frame函数。</em> </strong>之后我们用<strong class="ih hj"> <em class="jd"> imshow </em> </strong>的方法对CV2进行处理。将视频显示为输出。在此之后我们编写了<strong class="ih hj"> <em class="jd">代码来停止</em> </strong>代码。我们添加了if条件，即如果按下<strong class="ih hj"> <em class="jd">键“q ”,则循环将被中断</em> </strong>,输出屏幕将使用<strong class="ih hj"><em class="jd">destroyAllWindows()</em></strong>功能被破坏。</p><h1 id="904c" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">第12步-&gt;T79】</strong></h1><p id="3be2" class="pw-post-body-paragraph if ig hi ih b ii ko ik il im kp io ip iq kq is it iu kr iw ix iy ks ja jb jc hb bi translated">现在我们将编写最后一行代码，它将通过调用gen函数<strong class="ih hj"><em class="jd">运行上述所有代码。</em></strong></p><p id="9d86" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Python3</p><pre class="jf jg jh ji fd ku kv kw kx aw ky bi"><span id="e10c" class="kz jr hi kv b fi la lb l lc ld">gen(VideoCamera())</span></pre><p id="d40f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的代码中，我们调用了<strong class="ih hj"> <em class="jd"> gen函数，并传递了VideoCamera类对象</em> </strong>作为参数，最后，当我们运行上面的代码行时，输出屏幕将打开，显示实时预测，如下所示。</p><h1 id="96b6" class="jq jr hi bd js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn bi translated"><strong class="ak">输出:</strong></h1><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/1efd943dc62831ea96355f4470049636.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AczXF6GhwWOwaz9Y.gif"/></div></div></figure><p id="e7f0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要点:- </strong></p><ul class=""><li id="5734" class="li lj hi ih b ii ij im in iq lk iu ll iy lm jc ln lo lp lq bi translated">要获得<strong class="ih hj"> <em class="jd">数据集</em> </strong>点击<a class="ae kt" href="https://www.kaggle.com/aadityasinghal/facial-expression-dataset" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">此处</strong> </a></li><li id="cdfc" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">要得到<strong class="ih hj"> <em class="jd">哈尔级联分类器</em> </strong>文件，点击<a class="ae kt" href="https://github.com/opencv/opencv/blob/master/data/haarcascades/haarcascade_frontalface_default.xml" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">此处</strong> </a></li><li id="3ba5" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">要获得所有带有模型文件的代码如JSON和Weights以及所有其他代码，这里的<strong class="ih hj"> <em class="jd"> GITHUB链接</em> </strong>是<a class="ae kt" href="https://github.com/Aaditya1978/Face_Expression_Prediction" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">这里的</strong> </a></li><li id="2ec1" class="li lj hi ih b ii lr im ls iq lt iu lu iy lv jc ln lo lp lq bi translated">链接到<strong class="ih hj"> <em class="jd"> Kaggle笔记本</em> </strong>这里是<a class="ae kt" href="https://www.kaggle.com/aadityasinghal/facial-expression-recognization-using-tensorflow" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a></li></ul></div></div>    
</body>
</html>