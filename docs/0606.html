<html>
<head>
<title>Using Queues in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Python中使用队列</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/queues-in-python-7783244ac507?source=collection_archive---------2-----------------------#2021-01-24">https://medium.com/analytics-vidhya/queues-in-python-7783244ac507?source=collection_archive---------2-----------------------#2021-01-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/4a4a6c2d26bf14b2e7ae34a76b5f539a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*Van6cJP7YL4iF_Djr3IZUw.jpeg"/></div><figcaption class="im in et er es io ip bd b be z dx translated">人们在路易威登商店旁排队。来自<a class="ae iq" href="https://unsplash.com/@melanie_sophie" rel="noopener ugc nofollow" target="_blank">梅勒妮·庞格拉茨</a></figcaption></figure><p id="5522" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">在编程和软件开发中，数据结构用于存储和排列一组值。不同的用例有不同类型的数据结构。它们包括堆栈、队列、列表等。本文主要关注队列和可以在队列上执行的基本操作。</p><h1 id="eb3b" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">队列数据结构是什么？</h1><p id="b0c4" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">队列数据结构的工作方式类似于现实生活中的队列，比如在商场、付款柜台和登机处。</p><h1 id="7fda" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">队列的应用有哪些？</h1><ul class=""><li id="9a26" class="ks kt hi it b iu kn iy ko jc ku jg kv jk kw jo kx ky kz la bi translated">打印机队列</li><li id="2ca5" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">客户服务热线</li><li id="6df8" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo kx ky kz la bi translated">CPU调度</li></ul><h1 id="41ff" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">先进先出概念</h1><p id="9f6a" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated"><em class="lg"> FIFO </em>是先进先出的缩写，它解释了队列工作中执行操作的顺序。第一个进入队列的对象是第一个出去的对象。</p><p id="7617" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，新元素的添加发生在队列的末尾，而元素的删除发生在队列的开头，就像商场中的队列一样。</p><p id="f366" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">这与<a class="ae iq" href="https://jkaylight.medium.com/stacks-in-python-bbacc60510a" rel="noopener">堆栈数据结构</a>形成对比，后者元素的添加(<code class="du lh li lj lk b">push</code>)和移除(<code class="du lh li lj lk b">pop</code>)发生在队列的末尾。这被描述为后进先出，<em class="lg"> LIFO </em>你可以在本文中了解更多关于栈的知识，Python中的<a class="ae iq" href="https://jkaylight.medium.com/stacks-in-python-bbacc60510a" rel="noopener"> <em class="lg">栈</em> </a>。</p><h1 id="b9bd" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">主要队列操作</h1><ol class=""><li id="e8b9" class="ks kt hi it b iu kn iy ko jc ku jg kv jk kw jo ll ky kz la bi translated">enqueue():这需要在队列末尾添加新元素</li><li id="6011" class="ks kt hi it b iu lb iy lc jc ld jg le jk lf jo ll ky kz la bi translated">dequeue():这涉及到从队列前面删除队列成员。</li></ol><figure class="ln lo lp lq fd ij er es paragraph-image"><div role="button" tabindex="0" class="lr ls di lt bf lu"><div class="er es lm"><img src="../Images/a094c748dc4a3b79766266fb5de064b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-I6nl8iQjoAHaOUvsk-idg.png"/></div></div><figcaption class="im in et er es io ip bd b be z dx translated">描述主要队列操作、入队和出队的图表</figcaption></figure><h1 id="8cb4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">用Python编写队列类</h1><p id="c4eb" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">在面向对象编程概念中，类是计算机程序的模块化元素。对OOP中类的工作原理有一个基本的了解对于使用类是很重要的。可以通过本教程学习Python中的面向对象编程，<a class="ae iq" href="https://www.tutorialspoint.com/python/python_classes_objects.htm" rel="noopener ugc nofollow" target="_blank"> <em class="lg"> Python —面向对象</em> </a>。</p><p id="5104" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">接下来，我们将导入<code class="du lh li lj lk b">deque()</code>数据类型，因为像在堆栈类中一样使用列表数据类型只有当我们想要在列表末尾添加或删除时才是有效的。</p><p id="b18c" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">试图从列表的开头移除列表的元素是困难且缓慢的。然而，我们需要从头删除一个队列元素。</p><p id="7cb0" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">因此，我们将导入Python中内置的<code class="du lh li lj lk b">deque()</code>数据类型。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="dd60" class="lz jq hi lk b fi ma mb l mc md">from collections import deque</span></pre><p id="6910" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">然后，让我们宣布我们的<code class="du lh li lj lk b">Queue</code>类。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="a060" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>#new addition<br/>class Queue:<br/> def __init__(self):<br/>        self.items = deque()</span></pre><p id="cae4" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们已经声明了Queue类并添加了<code class="du lh li lj lk b">__init__()</code>构造函数，这使我们能够使用<code class="du lh li lj lk b">Queue</code>类的对象。</p><p id="d3ad" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated"><code class="du lh li lj lk b">items</code>是一个我们用来保存队列元素的列表。</p><h1 id="74ae" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">排队()</h1><p id="3260" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">我们现在将添加<code class="du lh li lj lk b">enqueue()</code>函数，它从后面向队列添加一个新元素。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="ff83" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    #new addition<br/>    def enqueue(self, item):<br/>        self.items.append(item)</span></pre><h1 id="81c4" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">出列()</h1><p id="b3ea" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated"><code class="du lh li lj lk b">dequeue()</code>函数将用于删除队列前面的元素。我们将使用<code class="du lh li lj lk b">popleft()</code>功能从左侧移除一个项目。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="4a16" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    #new addition<br/>    def dequeue(self):<br/>        return self.items.popleft()</span></pre><h1 id="0bac" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">peek()</h1><p id="322b" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">现在，我们将添加<code class="du lh li lj lk b">peek()</code>函数来返回队列中最前面的数据项，而不删除它。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="943c" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    def dequeue(self):<br/>        return self.items.popleft()<br/>    <br/>    #new addition<br/>    def peek(self):<br/>        return self.items[0]</span></pre><h1 id="1607" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">is_empty()</h1><p id="de8a" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">让我们添加一个<code class="du lh li lj lk b">is_empty()</code>函数，告诉我们队列是否为空。<code class="du lh li lj lk b">len()</code>函数返回列表中元素的数量。因此，当我们的队列长度为0时，我们将使用<code class="du lh li lj lk b">len()</code>进行检查。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="a49f" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    def dequeue(self):<br/>        return self.items.popleft()<br/>    <br/>    def peek(self):<br/>        return self.items[0]<br/>    <br/>    #new addition<br/>    def is_empty(self):<br/>        return len(self.items) == 0</span></pre><h1 id="d798" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">大小()</h1><p id="9721" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">我们还可以使用<code class="du lh li lj lk b">len()</code>功能来检查队列中的项目数量。因此，让我们创建一个函数，我们可以调用它来返回队列的大小</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="5660" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    def dequeue(self):<br/>        return self.items.popleft()<br/>    <br/>    def peek(self):<br/>        return self.items[0]<br/>    <br/>    def is_empty(self):<br/>        return len(self.items) == 0<br/>        <br/>    #new addition<br/>    def size(self):<br/>        return len(self.items)</span></pre><p id="38fd" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">上述函数是可以在队列上完成的一些常见操作。</p><p id="a9f1" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">现在，让我们将<code class="du lh li lj lk b">__str__()</code>添加到，以便在我们的程序中使用<code class="du lh li lj lk b">print</code>语句</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="438d" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    def dequeue(self):<br/>        return self.items.popleft()<br/>    <br/>    def peek(self):<br/>        return self.items[0]<br/>    <br/>    def is_empty(self):<br/>        return len(self.items) == 0<br/>        <br/>    def size(self):<br/>        return len(self.items)<br/>        <br/>    #new addition<br/>    def __str__(self):<br/>        return str(self.items)</span></pre><p id="c022" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">我们可以用下面的打印语句测试上面的代码。在使用print语句之前，我们需要添加一个条件语句，<code class="du lh li lj lk b">if "__name__" = "__main__"</code>来检查当前文件是否是主文件。这只是帮助我们能够在其他Python文件中导入我们的<code class="du lh li lj lk b">Queue</code>类，这样就可以在那里使用该类。</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="6b52" class="lz jq hi lk b fi ma mb l mc md">from collections import deque<br/>​<br/>class Queue:<br/>    def __init__(self):<br/>        self.items = deque()<br/>    <br/>    def enqueue(self, item):<br/>        self.items.append(item)<br/>    <br/>    def dequeue(self):<br/>        return self.items.popleft()<br/>    <br/>    def peek(self):<br/>        return self.items[0]<br/>    <br/>    def is_empty(self):<br/>        return len(self.items) == 0<br/>        <br/>    def size(self):<br/>        return len(self.items)<br/>        <br/>    def __str__(self):<br/>        return str(self.items)<br/>     <br/>#new addition<br/>if "__name__" = "__main__":<br/>    q = Queue()<br/>​<br/>    print(q)<br/>    print(q.is_empty())<br/>​<br/>    q.enqueue("1")<br/>    q.enqueue("2")<br/>    q.enqueue("3")<br/>​<br/>    q.dequeue()<br/>​<br/>    q.enqueue("4")<br/>    q.enqueue("5")<br/>    q.enqueue("6")<br/>​<br/>    q.dequeue()<br/>​<br/>    print(q)<br/>    print("size of the queue: ", q.size())<br/>​<br/>    print("foremost item in the queue:", q.peek())<br/>    print(q)</span></pre><p id="cf75" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">对于上面代码中的每个<code class="du lh li lj lk b">print</code>语句，我们有以下输出:</p><pre class="ln lo lp lq fd lv lk lw lx aw ly bi"><span id="c0e4" class="lz jq hi lk b fi ma mb l mc md">deque([])<br/>True<br/>deque(['3', '4', '5', '6'])<br/>size of the queue:  4<br/>foremost item in the queue: 3<br/>deque(['3', '4', '5', '6'])</span></pre><h1 id="cc58" class="jp jq hi bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="202f" class="pw-post-body-paragraph ir is hi it b iu kn iw ix iy ko ja jb jc kp je jf jg kq ji jj jk kr jm jn jo hb bi translated">我们简要讨论了队列数据结构和对队列执行的主要操作。队列操作按照先进先出的顺序发生。在实现计算机科学中的算法时，队列非常有用，例如在航班预订系统中使用的广度优先搜索算法。</p><p id="7df9" class="pw-post-body-paragraph ir is hi it b iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo hb bi translated">感谢您的耐心和抽出时间来阅读我的帖子。我在这里写在<a class="ae iq" href="https://jkaylight.medium.com/" rel="noopener">介质</a>上。你可以通过推特<a class="ae iq" href="https://twitter.com/JKayLight" rel="noopener ugc nofollow" target="_blank">@ JK ailight</a>向我提出问题和想法</p></div></div>    
</body>
</html>