<html>
<head>
<title>Imputing Missing Values Smartly with DataWig</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用DataWig智能输入缺失值</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/imputing-missing-values-smartly-with-datawig-f2f6b4a07c27?source=collection_archive---------0-----------------------#2021-04-06">https://medium.com/analytics-vidhya/imputing-missing-values-smartly-with-datawig-f2f6b4a07c27?source=collection_archive---------0-----------------------#2021-04-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/896be8c5a334ddee927e20e8ff47c908.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0Qb4EfhVurspqw8N"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">艾米丽·莫特在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="c5ee" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">数据，尤其是高质量的数据(以及其他东西)，在机器学习模型的成功中起着关键作用。不幸的是，真实世界的数据集远非完美，并且经常被噪声和缺失值所污染。尤其是缺少值可能会有问题。将它们一起删除会产生更小的数据集-当数据集很小时，这不是理想的情况。而且，即使你试图填补那些烦人的<em class="js">、</em>的数据，估算的数据也不一定能代表缺失的数据。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div class="er es jt"><img src="../Images/32edc332fe16f741724009399f8e133a.png" data-original-src="https://miro.medium.com/v2/resize:fit:534/format:webp/1*1eIJIjk_bfedtpdebg1nKQ.jpeg"/></div></figure><p id="fd27" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是DataWig的用武之地。正如你可能已经猜到的名字，这是一个假发的秃头补丁在您的数据。看，虽然有很多方法来估算你的数据，但DataWig是最重要的。</p><p id="c00f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将首先了解什么是DataWig以及它是如何工作的，然后我们将它与一些最流行的方法进行比较，看看它的性能如何。</p><p id="5c30" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">DataWig是大约3年前由AWS实验室开发的。它试图理解你的数据，并使用这种学习做插补。因此，如果您有3列—‘X’、‘Y’和‘Z’—并且我们想要估算‘Z’，DataWig会学习其他两列的内容来施展它的魔法。</p><p id="f106" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">DataWig支持分类列和数字列的插补。许多插补方法仅适用于数值插补，而那些适用于<a class="ae it" href="https://dl.acm.org/doi/pdf/10.1145/3269206.3272005" rel="noopener ugc nofollow" target="_blank">分类的方法在生产中并不那么好或可伸缩</a>。因此，当您想要估算分类列时，这变得非常有用。</p><p id="675b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们更深入地了解一下DataWig是如何工作的。这是基于它的<a class="ae it" href="https://dl.acm.org/doi/pdf/10.1145/3269206.3272005" rel="noopener ugc nofollow" target="_blank">研究论文</a>，所以如果你不想进入技术细节，请随意跳到下一节如何使用它。虽然我建议你读这一部分，但在我看来它非常有趣。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jy"><img src="../Images/6cebf26347b7c8e4cc9e5646f89a47a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DpOu0HVrWD8GND05IDQ96A.png"/></div></div></figure><p id="64a3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该图像显示了几列，其中列“颜色”是要估算的。DataWig首先确定每个列的类型。之后，每一列都被转换成数字表示(以便机器理解)。分类列是热编码的，而顺序(文本)列则根据字符串的长度和字符转换成序列。接下来是最重要的一步——特色化。独热编码数据通过嵌入层传递，而顺序数据通过LSTM层传递，或者在其上进行n-gram散列。最后，所有特征被合并并通过逻辑层(因为“颜色”是分类的)进行插补。</p><p id="0780" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是理论，让我们看看如何使用DataWig。它可以作为Python包安装。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="9263" class="ke kf hh ka b fi kg kh l ki kj">pip install datawig</span></pre><p id="de67" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意:当我最后一次尝试时，有一个关于依赖项的安装问题。查看这个<a class="ae it" href="https://github.com/awslabs/datawig/issues/121" rel="noopener ugc nofollow" target="_blank">链接</a>，将' == '替换为'&gt; = '以获得依赖关系。</p><p id="b5f4" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用DataWig也非常简单。它提供了两种类型的估算器——简单估算器和估算器。当你不关心DataWig如何工作时，使用SimpleImputer。但是如果你想根据你的需求定制工作，使用估算器。例如，您可以选择是否要使用LSTM或n-gram散列进行特征化。两个估算器都带有易于使用的fit()和predict()方法(类似于sklearn)。下面我们会做一些编码，你会了解更多关于这些功能。但是如果你想成为一个数据怪才，参考他们的<a class="ae it" href="https://datawig.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="6ebd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">实用</strong></p><p id="663f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们从例子开始。在这里，我们将使用DataWig进行数值插补，并将其与其他流行的方法进行比较。我们首先加载一个航班数据集，其中包含每个航班的字段- <strong class="iw hi">年、月和乘客- </strong>。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="17c2" class="ke kf hh ka b fi kg kh l ki kj">import seaborn as sns<br/>flights = sns.load_dataset("flights")<br/>flights['month'] = flights['month'].astype(str)<br/>flights['year'] = flights['year'].astype(str)</span><span id="35d6" class="ke kf hh ka b fi kr kh l ki kj">flights.head()</span></pre><figure class="ju jv jw jx fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/2f4005db550f42143ab3ff95067b29fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*gCp_mB34BiwYbk9ZD5VtWg.png"/></div></figure><p id="b1dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们在<em class="js">乘客</em>字段中随机选择一些单元格进行隐藏。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="8bbe" class="ke kf hh ka b fi kg kh l ki kj">flights_train, flights_test = datawig.utils.random_split(flights)</span></pre><p id="4b82" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在是表演时间了。让我们使用DataWig来预测flights_test中的值。</p><pre class="ju jv jw jx fd jz ka kb kc aw kd bi"><span id="fa1c" class="ke kf hh ka b fi kg kh l ki kj">imputer = datawig.SimpleImputer(<br/>    input_columns=['year', 'month'],<br/>    output_column='passengers'<br/>    )</span><span id="95a5" class="ke kf hh ka b fi kr kh l ki kj">imputer.fit(train_df = flights_train)</span><span id="7234" class="ke kf hh ka b fi kr kh l ki kj">imputed = imputer.predict(flights_test)</span></pre><p id="047e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里我们使用简单估算器。我们为它提供输入和输出列，使它适合训练数据，并预测测试中的缺失值。</p><p id="ca02" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我还比较了另外两种流行的方法——均值法和KNN插补法。这两种方法的代码可以在我的GitHub上找到。在使用这两种插补策略后，我将它们与RMSE度量的DataWig进行了比较。结果如下:</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kt"><img src="../Images/117ae843711cddbe0f0ec3269ce72fbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvC_FUuSTEZvyo3iFmjiQg.png"/></div></div></figure><p id="e5c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这方面，DataWig表现最好，紧随其后的是KNN。</p><p id="425e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据数据是随机缺失<a class="ae it" href="https://www.theanalysisfactor.com/mar-and-mcar-missing-data/" rel="noopener ugc nofollow" target="_blank">还是非随机缺失</a>，估算器的性能也会有所不同。例如，均值插补假设数据随机缺失，而<a class="ae it" href="https://heartbeat.fritz.ai/hands-on-with-feature-engineering-techniques-imputing-missing-values-6c22b49d4060" rel="noopener ugc nofollow" target="_blank">任意值插补假设相反</a>。所以我又用非随机缺失的数据做了一个对比。从我们的航班数据集中，我屏蔽了夏季的5月和6月，并将DataWig与KNN和任意值估算器进行了比较。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ku"><img src="../Images/db4b5808353d9bc990ee884e1f6c2280.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*43qOfsBUUcq3uVhZBsb9SQ.png"/></div></div></figure><p id="c4ea" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">结果与我们之前观察到的相似，DataWig名列前茅，KNN紧随其后。仅供参考，仅仅因为任意值插补在这里表现不好，并不意味着你不应该尝试它。它的性能很大程度上取决于您选择的任意值，因此如果您碰巧选择了正确的值(但这有点靠运气)，您可能会得到好的结果。</p><p id="8187" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这本<a class="ae it" href="https://github.com/anshbordia/DataWig-examples" rel="noopener ugc nofollow" target="_blank"> Jupyter笔记本</a>中，我还比较了使用DataWig的分类插补和其他方法，如果你感兴趣的话，可以看看。需要记住的是，DataWig或KNN等估算工具的一个缺点是，在处理大量分类和序列数据时，它们会很慢。在这种情况下，像最频繁或随机抽样插补这样的简单方法可能要快得多(但可能没有那么准确)。</p><p id="04bc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为一项有趣的活动，为了进一步了解DataWig有多好，为什么不使用<a class="ae it" href="https://heartbeat.fritz.ai/hands-on-with-feature-engineering-techniques-imputing-missing-values-6c22b49d4060" rel="noopener ugc nofollow" target="_blank">不同的技术</a>估算您的数据，然后比较您用于预测的ML模型的性能；看到结果你会大吃一惊的。</p><p id="7c00" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢你阅读这篇文章，我希望你现在能更好地应对缺失的价值观。</p><figure class="ju jv jw jx fd ii er es paragraph-image"><div class="er es ks"><img src="../Images/1037c93e72c9d528cc4addf7e5e28b0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*lIibrd86qETqca0tUM1Zdw.png"/></div></figure></div></div>    
</body>
</html>