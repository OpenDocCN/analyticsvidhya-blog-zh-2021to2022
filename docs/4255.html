<html>
<head>
<title>Building a Random Movie Picker Using Python and Selenium</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python和Selenium构建随机电影选择器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-random-movie-picker-using-python-and-selenium-6a63c9006e64?source=collection_archive---------13-----------------------#2021-09-12">https://medium.com/analytics-vidhya/building-a-random-movie-picker-using-python-and-selenium-6a63c9006e64?source=collection_archive---------13-----------------------#2021-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/ee055a4f4a5910837c81ed7d18544d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*zJFXZFeecnEakYH_.png"/></div></div></figure><div class=""/><p id="bfa9" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我妻子(丹妮)每周都在评论电影，并把它们上传到她的Youtube频道。她最近问我，是否有可能搜集这些导演的名单，并随机返回一部他们执导的电影，以帮助她决定下一部要评论的电影。</p><p id="280f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">听起来像是某个<em class="jo">好-ol-web- </em> <a class="ae jn" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> <em class="jo">硒</em> </a>的工作。</p><h2 id="6d20" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">我选择如何解决这个问题。</h2><blockquote class="kk kl km"><p id="a4b3" class="ip iq jo ir b is it iu iv iw ix iy iz kn jb jc jd ko jf jg jh kp jj jk jl jm ha bi translated">抓取网站可能很挑剔。你是在内容创作者的心血来潮的降价决策。</p></blockquote><p id="79f6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae jn" href="https://www.elacervo.com/directores" rel="noopener ugc nofollow" target="_blank"> Elacervo </a>的标记比较棘手。他们主任的页面是一致的，但是个别主任的帖子却不是。有些director页面的电影列表有单独的<code class="du kq kr ks kt b">p</code>标签，而有些页面的整个电影列表被格式化在一个<code class="du kq kr ks kt b">span</code>元素中。<strong class="ir ht">这是个问题</strong>。</p><p id="b50a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我没有试图拼凑出一种方法来获得大多数导演的视频，而是选择获得导演的名单，并从可靠的来源收集他们的电影名单。</p><p id="66d5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我选择了IMDB，它的API <a class="ae jn" href="https://imdbpy.github.io/" rel="noopener ugc nofollow" target="_blank"> IMDbPY </a>周围有一个方便的python包装器。</p><h2 id="4583" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">为什么我选择Selenium作为工具呢？</h2><p id="e528" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Dany是一个初学web开发的人，对Python很好奇。Selenium为开发人员提供了自动化浏览器交互的可视化确认。生成一个新的浏览器实例并点击站点确实会影响性能，但是我相信Selenium在视觉方面的优势超过了性能问题。</p><p id="5762" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">像<a class="ae jn" href="https://scrapy.org/" rel="noopener ugc nofollow" target="_blank"> Scrapy </a>这样的框架可以更快地提供数据，但是我做这个的一个重要原因是帮助丹妮学习Python。</p><h2 id="d508" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">设置Selenium以自动化我的浏览器</h2><p id="29c3" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">Selenium需要进行一些设置，以便开始自动化您的浏览器。</p><p id="d3e6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用Python 3的内置包管理器<a class="ae jn" href="https://pypi.org/project/pip/" rel="noopener ugc nofollow" target="_blank"> pip </a>，用命令<code class="du kq kr ks kt b">pip install selenium</code>下载Selenium。</p><blockquote class="kk kl km"><p id="2bdb" class="ip iq jo ir b is it iu iv iw ix iy iz kn jb jc jd ko jf jg jh kp jj jk jl jm ha bi translated">我强烈推荐利用一个<a class="ae jn" href="https://virtualenv.pypa.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> virtualenv </a>并创建一个隔离的Python环境。</p></blockquote><p id="f67e" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您还需要下载适当的网络驱动程序。Selenium的<a class="ae jn" href="https://selenium-python.readthedocs.io/installation.html#drivers" rel="noopener ugc nofollow" target="_blank">文档</a>有最流行的浏览器驱动的链接。对于本教程，我将使用谷歌浏览器和Chrome驱动程序。</p><h2 id="dd03" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">使用Selenium和Python收集控制器</h2><p id="9245" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">下面是我决定使用的代码片段。我附加了numbers注释来描述代码片段中的重要选择。</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="86bb" class="jp jq hs kt b fi lh li l lj lk">import json<br/>from selenium import webdriver<br/><br/>driver = webdriver.Chrome('chromedriver') // 1<br/>driver.get('https://www.elacervo.com/directores') // 2<br/><br/>// 3<br/>for i in range(4):<br/>  time.sleep(5)<br/>  driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")<br/><br/>// 4<br/>directors = driver.find_elements_by_css_selector(<br/>  "a[href*='https://www.elacervo.com/post/']"<br/>  )<br/><br/>// 5<br/>unique_directors = []<br/>for link in directors:<br/>  if (link.get_attribute("href")) not in unique_directors:<br/>    unique_directors.append(link.get_attribute("href"))<br/><br/>// 6<br/>names = []<br/>for link in unique_directors:<br/>  slug = link.split('/')[-1]<br/>  name = slug.replace('-', ' ').title()<br/>  names.append({"name": name})<br/><br/>// 7<br/>with open('directors.json', 'w') as outfile:<br/>  json.dump(names, outfile)<br/><br/>// 8<br/>driver.quit()</span></pre><ol class=""><li id="8d93" class="ll lm hs ir b is it iw ix ja ln je lo ji lp jm lq lr ls lt bi translated">这是我们告诉Selenium使用spawn一个新的Google Chrome实例的地方。我们传递给<code class="du kq kr ks kt b">.Chrome()</code>方法的值<code class="du kq kr ks kt b">chromedriver</code>是我们在上一步下载的chromedriver文件的位置。</li><li id="eaa0" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated"><code class="du kq kr ks kt b">driver.get('https://www.elacervo.com/directores')</code> -这里我们告诉我们现在制作的Selenium驱动程序导航到URL <code class="du kq kr ks kt b"><a class="ae jn" href="https://www.elacervo.com/directores." rel="noopener ugc nofollow" target="_blank">https://www.elacervo.com/directores</a></code> <a class="ae jn" href="https://www.elacervo.com/directores." rel="noopener ugc nofollow" target="_blank">。</a></li><li id="7694" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated">我抓取的网站有一些惰性加载逻辑，只有一定数量的控制器被加载，直到页面滚动到底部。这是执行一些客户端javascript以滚动到页面底部，等待几秒钟以加载新的控制器，然后滚动到页面的新底部。</li><li id="5029" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated">在这里，我收集了所有包含带有标签的<code class="du kq kr ks kt b">a</code>和包含<code class="du kq kr ks kt b">https://www.elacervo.com/post/</code>的<code class="du kq kr ks kt b">href</code>的html事件。这是使用包含通配符<code class="du kq kr ks kt b">*</code>的逻辑<code class="du kq kr ks kt b">href*=</code>。</li><li id="2c63" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated">这是提取位于<code class="du kq kr ks kt b">href</code>源中的directors URL。然后它将URL放入一个<code class="du kq kr ks kt b">unique_directors</code>列表中。这个页面上的一些导演有他们的链接两次，所以我删除任何重复的网址。</li><li id="c9d2" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated">我正在清理URL链接，以便简单地从它们那里获取导演的名字。聚集的链接看起来像<code class="du kq kr ks kt b">https://www.elacervo.com/post/martin-scorsese</code>。这里的逻辑是取最后一个<code class="du kq kr ks kt b">/</code>字符之后的所有内容，用空格替换<code class="du kq kr ks kt b">-</code>，然后将名称中每个单词的第一个字母大写。</li><li id="efb3" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated">然后，我使用<code class="du kq kr ks kt b">json.dump</code>将收集到的控制器名称写入到一个<code class="du kq kr ks kt b">json</code>文件中，以便以后更快地使用。从一个<code class="du kq kr ks kt b">json</code>文件中读取要比生成一个浏览器点击并提取数据快得多。</li><li id="bcde" class="ll lm hs ir b is lu iw lv ja lw je lx ji ly jm lq lr ls lt bi translated"><code class="du kq kr ks kt b">driver.quit()</code> -这将关闭一个Selenium Chrome实例。</li></ol><h2 id="6d9b" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">使用IMDbPY查询IMDBs数据库</h2><p id="e70b" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">IMDbPY 是一个非常简洁的用于查询IMDB数据的包。只需几行Python代码，我们就可以看到一个目录的整个电影画面。</p><h2 id="9c98" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">这个Python片段将返回每个导演的每部电影</h2><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="0e03" class="jp jq hs kt b fi lh li l lj lk">import json<br/>from imdb import IMDb<br/><br/>file = open('directors.json',)<br/>directors = json.load(file)<br/><br/>movies = []<br/>ia = IMDb()<br/>for person in directors:<br/>  try:<br/>    director = ia.search_person(person['name'])[0]<br/>    try:<br/>      films = ia.get_person_filmography(director.personID)['data']['filmography']['director']<br/>      for film in films:<br/>        if film['kind'] == 'movie':<br/>          try:<br/>            if (film['year']):<br/>              movies.append(film)<br/>          except KeyError:<br/>            continue<br/>    except AttributeError:<br/>      continue<br/>  except IndexError:<br/>    continue<br/><br/>  with open('movies.json', 'w') as outfile:<br/>    json.dump([{"title": movie['title'], 'year': movie['year']} for movie in movies], outfile)</span></pre><p id="9783" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用Python内置的<a class="ae jn" href="https://docs.python.org/3/library/functions.html#open" rel="noopener ugc nofollow" target="_blank"> open </a>函数来打开我们在Selenium部分创建的<code class="du kq kr ks kt b">directors.json</code>文件。然后使用Python的<a class="ae jn" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"> JSON解码器</a>，我们可以将文件中的数据加载成可用的JSON格式。</p><p id="c26f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">初始化一个IMDb对象使我们能够访问软件包的功能，允许我们查询IMDb的数据库。</p><p id="7537" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">方法<code class="du kq kr ks kt b">.search_person(person['name'])</code>返回IMDb数据库中的人员列表。似乎返回列表中的第一个结果是最受欢迎的，也是<code class="du kq kr ks kt b">[0]</code>后面的推理。对于这个项目，我假设他是我想合作的导演。</p><h2 id="0dee" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">区分电影和其他电影类型</h2><p id="7c21" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">IMDbPY <code class="du kq kr ks kt b">Movie</code>对象的属性可以在这里看到<a class="ae jn" href="https://imdbpy.readthedocs.io/en/latest/usage/movie.html" rel="noopener ugc nofollow" target="_blank">。对于这个项目，我只对电影感兴趣，所以我应用了一个条件来检查，将接受的电影附加到电影列表中。</a></p><p id="5223" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">原来IMDbPY的Movie对象只有在电影已经上映的情况下才有属性<code class="du kq kr ks kt b">year</code>，否则就有属性<code class="du kq kr ks kt b">status</code>。我只想要现在可以看的电影，并相应地过滤掉数据。</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="971e" class="jp jq hs kt b fi lh li l lj lk">movies = []<br/>if film['kind'] == 'movie':<br/>    try:<br/>        if (film['year']):<br/>            movies.append(film)<br/>    except KeyError:<br/>        continue</span></pre><h2 id="686b" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">将电影数据写入可重用的JSON文件</h2><p id="d8fb" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">与使用Selenium提取的数据一样，我决定通过将获得的数据写入可重用的JSON文件来减少对IMDb的API请求的数量。</p><p id="579f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我决定只取电影的标题和年份值，而不是提取IMDb电影对象的所有数据。将来，提取额外的数据来进行高级过滤可能会很酷。例如，想要仅观看1970年和1980年之间的分级大于9.0的电影。虽然IMDb电影对象说它有某些属性，但它最终有点挑剔，我决定暂时不要它。</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="9581" class="jp jq hs kt b fi lh li l lj lk">with open('movies.json', 'w') as outfile:<br/>    json.dump([{"title": movie['title'], 'year': movie['year']} for movie in movies], outfile)</span></pre><h2 id="7250" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">从我们的列表中随机选择电影</h2><p id="c8f9" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated">现在我们在json文件中有了我们导演组的所有电影的列表，我可以使用Python的<a class="ae jn" href="https://docs.python.org/3/library/random.html#random.choice" rel="noopener ugc nofollow" target="_blank"> random.choice </a>来随机选择一部电影。</p><pre class="kz la lb lc fd ld kt le lf aw lg bi"><span id="cc09" class="jp jq hs kt b fi lh li l lj lk">import random<br/>import json<br/><br/>file = open('movies.json')<br/>data = json.load(file)<br/>print(random.choice(data))</span></pre><h2 id="4ad4" class="jp jq hs bd jr js jt ju jv jw jx jy jz ja ka kb kc je kd ke kf ji kg kh ki kj bi translated">随机看电影很好玩！</h2><p id="d180" class="pw-post-body-paragraph ip iq hs ir b is ku iu iv iw kv iy iz ja kw jc jd je kx jg jh ji ky jk jl jm ha bi translated"><strong class="ir ht">认真地</strong>试一试。至少，随机选择一部电影，看它的预告片。这些电影中有许多我从未听说过，但它们很吸引人，富有创造性和艺术性。</p><p id="21c7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我希望这篇文章是有帮助的！</p></div></div>    
</body>
</html>