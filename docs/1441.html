<html>
<head>
<title>Inflation Forecasting with Deep Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于深度学习的通货膨胀预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/inflation-forecasting-with-deep-learning-d3067711fff1?source=collection_archive---------5-----------------------#2021-03-02">https://medium.com/analytics-vidhya/inflation-forecasting-with-deep-learning-d3067711fff1?source=collection_archive---------5-----------------------#2021-03-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="16c6" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">摘要</strong></h1><p id="0ff0" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">我们打算将深度学习模型的性能与主要金融机构在通胀预测领域建立的宏观经济模型进行比较。所有的分析都是根据巴西中央银行发布的数据进行的，包括对未来通货膨胀的预测。我们的分析表明，神经网络可以实现比传统模型更好的性能，在不久的将来开辟新的研究可能性。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="d623" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">介绍</h1><p id="2569" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">通货膨胀是公共和私营部门研究的主要宏观经济指标之一。它包括给定货币在给定时间内的价值损失。虽然有些通货膨胀被认为是可取的，因为它通过货币贬值减少了实际债务负担。它可能以恶性通货膨胀的形式成为经济良好运行的克星。而大多数发达经济体近期并未经历恶性通货膨胀。在1970-1980年代，即使对世界主要储备货币美元来说，这也是一个真正的克星。[1][2][3]</p><p id="b83a" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">恶性通货膨胀降低了整个社会的购买力，但最贫穷的人受到的影响最大，因为他们通常无法获得旨在保护财富免受其害的金融工具(通货膨胀保值债券、外汇、黄金、股票等)。适度的通货膨胀虽然不是灾难性的，但私营企业在借款、扩大活动和产品定价等战略决策中必须考虑到这一点。对于家庭来说，通货膨胀减少了可用于支出的实际收入，除非他们在谈判工资时有一些讨价还价的能力。中央银行通常有低通胀目标，他们手中管理这一目标的主要工具是基本利率。银行在制定自己的贷款政策时必须考虑通货膨胀。对于买方机构，如养老基金。通货膨胀侵蚀了他们的投资收益。一个通货膨胀预测工具，可以帮助这些玩家规划他们的未来。[1][2]</p><p id="acda" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">目前有一些通货膨胀预测模型，这些模型大多涉及传统的计量经济学模型，加上领域专家的判断。在本文中，我们将使用深度学习方法，使用全连接和LSTM(长短期记忆)层，并将它与使用当前模型做出的预测进行比较。[4]</p><p id="499b" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">我们在这项工作中的重点将是巴西经济。巴西在20世纪80年代和90年代初经历了恶性通货膨胀，因此我们的模型有关于所有通货膨胀水平的最新数据。巴西中央银行从所有主要的地方金融机构收集未来通货膨胀的估计数，并在公开的API中与通货膨胀数据一起发布。我们的工作将包括开发一个神经网络算法，该算法将接收不可贸易IPCA(巴西消费价格指数)的滞后值，以及相关的宏观经济数据(只要在预测日期之前可以获得)，并将其与金融机构的预测进行比较。[1][5]</p><p id="2158" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">这项工作的一个有趣之处在于，它会将其预测与经济学领域的学科领域专家团队所做的预测进行比较。如果当前模型已经处于贝叶斯理论误差中，或者是否有进一步研究和模型改进的空间，它可能会揭示洞察力。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="c066" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">简要回顾金融领域的神经网络</strong></h1><p id="e77a" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">神经网络不是最近才发展起来的:提出它们的第一篇论文发表于1943年，最近才提出了诸如递归神经网络的架构。传统的神经网络接收单个方向的输入，这称为前向传播，而递归神经网络允许一个层接收来自其自身的滞后输入，这允许在没有额外数据准备的情况下捕获时间维度。1997年引入的LSTM(长短期记忆)包括一个递归神经网络，该网络具有用于输入、输出和遗忘的“门”:这些门是附加层，控制滞后输入的哪一部分将被向前传递，哪一部分将被忽略。[6]</p><p id="73d9" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">人们已经尝试在金融数据中使用神经网络。例如，股票价格预测是一个充满活力的领域，无论是在学术界还是在主要机构的自营交易部门内部。使用神经网络进行交易对高频交易特别有意义:HFT涉及在短时间窗口(毫秒)内下单，以在市场的小幅波动中获取利润。神经网络，尤其是LSTM神经网络，接收过去的价格数据作为输入，并试图预测下一个市场运动。[6][7]</p><p id="82b6" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">这项工作的目的是用神经网络进行通货膨胀预测，在以前的学术工作中也进行了研究，这些学术工作试图建立一个浅层多层感知器算法，该算法接收宏观经济数据来预测通货膨胀率。[6][8]</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="cff8" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">数据描述</strong></h1><p id="6ea0" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">数据将从巴西中央银行应用程序编程接口(API)收集。从这些来源检索的利息变量将是巴西基本利率(称为SELIC利率)、巴西卢布汇率、巴西以前的IPCA(消费者价格指数)以及巴西金融机构对12个月通货膨胀的预测。每个数据集都是从不同的API端点检索的。[9][10][11][12]</p><p id="56fa" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">就IPCA而言，自1992年以来就有数据，而且是十进制格式。从2001年开始，该指数的预测可以从中央银行数据集中以百分比的形式检索。我们使用的SELIC利率是隔夜回购-本地发行的主权债券的反向回购利率，该数据可以追溯到1986年6月，并且是十进制格式。[10][12]</p><p id="da71" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">最相关的讨论是关于BRL对美元的汇率。由于巴西在20世纪80年代和90年代经历了恶性通货膨胀，自1984年以来，货币名称和名义价值已经改变了六次。因此，尽管我们将该数据命名为“美元对BRL”，但在1984-1994年期间，该数据可能是美元对克鲁塞罗、克鲁扎多、克鲁扎多诺、克鲁塞罗雷亚尔或雷亚尔的汇率。在此期间，可以观察到汇率的大幅波动。我们已经决定使用美元汇率的月度百分比变化来标准化该数据集，以避免消失/爆炸梯度问题。[11]</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><h1 id="d757" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">给我看看代码！</h1></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="fd6c" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">这个分析将在Python中完成，首先我们将导入一些依赖关系:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="18b1" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">import</strong> <strong class="kr hi">urllib.request</strong><br/><strong class="kr hi">import</strong> <strong class="kr hi">pandas</strong> <strong class="kr hi">as</strong> <strong class="kr hi">pd</strong><br/><strong class="kr hi">import</strong> <strong class="kr hi">numpy</strong> <strong class="kr hi">as</strong> <strong class="kr hi">np</strong><br/><strong class="kr hi">import</strong> <strong class="kr hi">datetime</strong><br/><strong class="kr hi">import</strong> <strong class="kr hi">json</strong><br/><strong class="kr hi">from</strong> <strong class="kr hi">scipy.stats</strong> <strong class="kr hi">import</strong> linregress<br/><strong class="kr hi">from</strong> <strong class="kr hi">numpy</strong> <strong class="kr hi">import</strong> array</span></pre></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="56b3" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">并定义API的端点:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="198d" class="kv im hh kr b fi kw kx l ky kz">StrURLPrevIPCA="https://olinda.bcb.gov.br/olinda/servico/Expectativas/versao/v1/odata/ExpectativasMercadoInflacao12Meses?$top=10000&amp;$filter=Indicador<strong class="kr hi">%20e</strong>q%20'IPCA'<strong class="kr hi">%20a</strong>nd%20Suavizada<strong class="kr hi">%20e</strong>q%20'N'&amp;$format=json&amp;$select=Indicador,Data,Media,Mediana,DesvioPadrao,CoeficienteVariacao,Minimo,Maximo"</span><span id="268f" class="kv im hh kr b fi la kx l ky kz">StrURLIPCA="http://api.bcb.gov.br/dados/serie/bcdata.sgs.4448/dados?formato=json"</span><span id="5c24" class="kv im hh kr b fi la kx l ky kz">StrURLUSD="https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='01-01-1980'&amp;@dataFinalCotacao='01-01-2020'&amp;$top=10000&amp;$format=json&amp;$select=cotacaoVenda,dataHoraCotacao"</span><span id="54c4" class="kv im hh kr b fi la kx l ky kz">StrURLSELIC="https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json"</span></pre></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="86cf" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">Bacen API非常简单，有非常好的文档，但是大部分是用葡萄牙语写的。</p></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="7efc" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">接下来，我们将定义一个接收上述API端点并返回熊猫数据帧的函数:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="1056" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">def</strong> getBACENDATA(columns,StringURL,value=<strong class="kr hi">False</strong>):<br/>  <strong class="kr hi">with</strong> urllib.request.urlopen(StringURL) <strong class="kr hi">as</strong> url: JsonInter=json.loads(url.read())            <br/>  df=pd.DataFrame(columns=columns)<br/><strong class="kr hi">if</strong> value:<br/>    <strong class="kr hi">for</strong> item <strong class="kr hi">in</strong> JsonInter['value']:<br/>      row=[]<br/>      <strong class="kr hi">for</strong> column <strong class="kr hi">in</strong> columns:<br/>        row.append(item[column])<br/>      df.loc[len(df)]=row<br/>  <strong class="kr hi">else</strong>:<br/>    <strong class="kr hi">for</strong> item <strong class="kr hi">in</strong> JsonInter:<br/>      row=[]<br/>      <strong class="kr hi">for</strong> column <strong class="kr hi">in</strong> columns:<br/>        row.append(item[column])<br/>      df.loc[len(df)]=row<br/><strong class="kr hi">return</strong> df</span></pre></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="229d" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">下面我们将下载有效通货膨胀数据，获得自数据集开始以来的累积通货膨胀(fator_acumulado)，并获得过去12个月的累积通货膨胀(inflacao_12_meses):</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="d722" class="kv im hh kr b fi kw kx l ky kz">StringURL=StrURLIPCA<br/>columns=['data','valor']<br/>df_IPCA=getBACENDATA(columns,StringURL)<br/>df_IPCA['fator']=1+(df_IPCA['valor'].astype(float))/100<br/>df_IPCA['fator_acumulado']=1.000000<br/>df_IPCA['fator_acumulado'][0]=df_IPCA['fator'][0]<br/><strong class="kr hi">for</strong> i <strong class="kr hi">in</strong> range(1,len(df_IPCA)):<br/>  df_IPCA['fator_acumulado'][i]=df_IPCA['fator'][i]*df_IPCA['fator_acumulado'][i-1]<br/>df_IPCA['Inflacao_12_Meses']=(df_IPCA['fator_acumulado']/df_IPCA['fator_acumulado'].shift(12)-1)*100<br/>df_IPCA['data']=pd.to_datetime(df_IPCA['data'],format="<strong class="kr hi">%d</strong>/%m/%Y")<br/>df_IPCA=df_IPCA.rename(columns={"data": "Data",'valor':'IPCA'})<br/>df_IPCA.head(20)</span></pre><p id="827a" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">向我们展示了数据框架:</p><figure class="km kn ko kp fd lc er es paragraph-image"><div class="er es lb"><img src="../Images/2dd4c532cbef68c3e241c82ee0d1b971.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/1*5atQ6EH6I-7k_rX56NOdoQ.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">表1:通货膨胀数据集，IPCA一栏显示了月通货膨胀率，请注意，在此期间，巴西经历了恶性通货膨胀，因此，20-30%的月通货膨胀率相当普遍。</figcaption></figure></div><div class="ab cl ie if go ig" role="separator"><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij ik"/><span class="ih bw bk ii ij"/></div><div class="ha hb hc hd he"><p id="a690" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">下一部分涉及通胀预测的收集:巴西中央银行对所有主要金融机构做出的不同指数预测进行定期调查，并作为“boletim Focus”发布，它还允许从API端点检索该数据:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="04d1" class="kv im hh kr b fi kw kx l ky kz">StringURL=StrURLPrevIPCA<br/>columns=['Indicador','Data','Media','Mediana','DesvioPadrao','CoeficienteVariacao','Minimo','Maximo']<br/>df_IPCA_Prev=getBACENDATA(columns,StringURL,<strong class="kr hi">True</strong>)<br/>df_IPCA_Prev['Date_Prediction']=pd.to_datetime(df_IPCA_Prev['Data'])+datetime.timedelta(days=365)<br/>df_IPCA_Prev['Data']=pd.to_datetime(df_IPCA_Prev['Data'],format='%Y-%m-<strong class="kr hi">%d</strong>')<br/>df_IPCA_Prev.head(20)</span></pre><figure class="km kn ko kp fd lc er es paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="er es lj"><img src="../Images/d314670b569125e846d5f2056f94902f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AC6uzp6gFsAb4ImQRZhASw.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">表02，金融机构对巴西通货膨胀的预测，该数据集中的列是:Indicador =该日期仅指IPCA的指数；数据=做出预测的日期；中=一般；Mediana =中位数；DesvioPadrao =标准偏差；CoeficienteVariacao=(标准差/平均值)* 100；Minimo = minMaximo = maxDate _ Prediction = 12M在预测日期之后。</figcaption></figure><p id="5bc9" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">我们将下载的下一个数据集是巴西货币对美元的汇率。最近(自1994年7月以来)，巴西货币的名称是真实的(BRL):</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="837a" class="kv im hh kr b fi kw kx l ky kz">StringURL=StrURLUSD<br/>columns=['cotacaoVenda','dataHoraCotacao']<br/>df_USD=getBACENDATA(columns,StringURL,<strong class="kr hi">True</strong>)<br/>df_USD['dataHoraCotacao']=df_USD['dataHoraCotacao'].values.astype('&lt;M8[D]')<br/>df_USD['dataHoraCotacao']=pd.to_datetime(df_USD['dataHoraCotacao'],format="<strong class="kr hi">%d</strong>/%m/%Y")<br/>df_USD=df_USD.rename(columns={"cotacaoVenda": "USD_2_BRL","dataHoraCotacao":"Data"})<br/>df_USD.head(10)</span></pre><figure class="km kn ko kp fd lc er es paragraph-image"><div class="er es lo"><img src="../Images/7e2c095be9594105543f0931852f3af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*jbXtNRiQsmAapFkLscn0DA.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">表03，以巴西货币单位表示的购买一单位美元(2美元BRL)的汇率和相应的日期(数据)</figcaption></figure><p id="466a" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">让我们绘制一个图表来快速了解一种货币的恶性通货膨胀的影响:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="af97" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">import</strong> <strong class="kr hi">matplotlib.pyplot</strong> <strong class="kr hi">as</strong> <strong class="kr hi">plt</strong><br/>x_chart=pd.to_datetime(df_USD['Data'])<br/>y_chart=df_USD['USD_2_BRL']<br/><br/>plt.plot(x_chart, y_chart, 'o', label='Exchange Rate')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="km kn ko kp fd lc er es paragraph-image"><div class="er es lp"><img src="../Images/56b9d65b828ad1eb2d6ebf96264ad855.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/0*5eXOglGKhZakd0cS"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">图1:1986年至1996年期间巴西货币(多种货币名称)对美元的汇率，注意曲线的不连续性，这发生在货币名称和面值改变的时候。值是名义上的，没有任何平滑或校正</figcaption></figure><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="fcdf" class="kv im hh kr b fi kw kx l ky kz">x_chart=pd.to_datetime(df_USD['Data'][len(df_USD)-int(len(df_USD)*0.3):])<br/>y_chart=df_USD['USD_2_BRL'][len(df_USD)-int(len(df_USD)*0.3):]<br/><br/>plt.plot(x_chart, y_chart, 'o', label='Exchange Rate')<br/>plt.legend()<br/>plt.show()</span></pre><figure class="km kn ko kp fd lc er es paragraph-image"><div class="er es lq"><img src="../Images/3c7f5e6d840dff8a39b3a356ce0211e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:744/0*JhuKO8-dgwzfNdDb"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">图2:2010–2020年期间巴西雷亚尔对美元的汇率:请注意，虽然可以观察到贬值，但其波动性比前一时期小得多。值是名义上的，没有任何平滑或校正。</figcaption></figure><p id="5f76" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">最后，我们将下载巴西基本利率(SELIC Rate ),这是当地发行的主权债券的隔夜回购-反向回购(债券借贷)利率，该数据可以追溯到1986年6月，采用十进制格式。[10][12]</p><figure class="km kn ko kp fd lc er es paragraph-image"><div class="er es lr"><img src="../Images/7a51325d8de61b1c2231ef0ad9f39029.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*5VPqnBjmi3ivqNi6miZrHw.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">表04: Selic利率虽然主权债券每天6%的利率听起来可能是一个有吸引力的投资机会，但人们应该记住，通货膨胀率与这些利率是一致的。</figcaption></figure><p id="cdf7" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">现在，让我们连接这些数据集:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="fe3a" class="kv im hh kr b fi kw kx l ky kz">df=df_IPCA[['Data',	'IPCA','Inflacao_12_Meses']].merge(df_USD, left_on='Data', right_on='Data')<br/>df=df.merge(df_SELIC, left_on='Data', right_on='Data')<br/>df['Inflacao_12_Meses_Shift']=df['Inflacao_12_Meses'].shift(-12)<br/>df['USD_2_BRL_Variation']=df['USD_2_BRL'].pct_change()</span></pre><p id="cd2f" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">并执行探索性分析以寻找潜在的解释变量。为此，我们将使用scipy.stats python包的linregress函数。</p><p id="be5c" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">我们的目标是计算我们的目标变量(未来12个月的通货膨胀)和我们的每个变量之间的线性回归的p值和R平方。[13]</p><p id="53a1" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">p值表示两个变量之间的相关性为零(即完全不相关)的概率，而R平方表示一个变量在多大程度上解释了另一个变量的可变性。因此，低p值表明两个变量之间存在相关性，而高R平方表明该变量与我们的模型相关[13]</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="18a3" class="kv im hh kr b fi kw kx l ky kz">X=df.dropna(how='any')[['IPCA','USD_2_BRL_Variation','Daily_Base_Interest_Rate','Inflacao_12_Meses']]<br/>Y=df.dropna(how='any')['Inflacao_12_Meses_Shift']<br/>df=df.merge(df_IPCA_Prev[['Date_Prediction','Media']],left_on='Data',right_on='Date_Prediction',how='left')</span><span id="d160" class="kv im hh kr b fi la kx l ky kz"><strong class="kr hi">for</strong> column <strong class="kr hi">in</strong> X.columns:<br/>        x=np.array(X[column],dtype=np.float32)<br/>        y=np.array(Y,dtype=np.float32)<br/>        slope, Intercept, r_value, p_value, std_err = linregress(x,y)<br/>        print('Analysis for: ' + column +' vs Future Inflation:')<br/>        print('p_value: '+str(p_value))<br/>        print('R-Squared: '+str(r_value**2))</span><span id="7500" class="kv im hh kr b fi la kx l ky kz">Analysis for: IPCA vs Future Inflation:<br/>p_value: 3.9022881402400923e-10<br/>R-Squared: 0.19897545195951064<br/>Analysis for: USD_2_BRL_Variation vs Future Inflation:<br/>p_value: 0.0009864777146704018<br/>R-Squared: 0.059635465282588604<br/>Analysis for: Daily_Base_Interest_Rate vs Future Inflation:<br/>p_value: 1.1804946786027202e-12<br/>R-Squared: 0.24888992823722614<br/>Analysis for: Inflacao_12_Meses vs Future Inflation:<br/>p_value: 0.0005769016381291179<br/>R-Squared: 0.06492842819910233</span></pre><p id="adfa" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">所有变量都有有意义的p值。他们各自的R平方很小，但是很有意义。这些数字表明，虽然通胀预测是不精确的，但我们有一组变量肯定有机会解释我们的目标变量。因此，我们将在我们的预测模型中对所有这些进行处理。</p><p id="ed3f" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">下一步将导入tensorflow和keras依赖项:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="f00a" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">from</strong> <strong class="kr hi">keras.models</strong> <strong class="kr hi">import</strong> Sequential<br/><strong class="kr hi">from</strong> <strong class="kr hi">keras.layers</strong> <strong class="kr hi">import</strong> Dense, Dropout, LSTM<br/><strong class="kr hi">import</strong> <strong class="kr hi">tensorflow</strong> <strong class="kr hi">as</strong> <strong class="kr hi">tf</strong></span></pre><p id="1060" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">我们将使用具有以下层的Keras顺序神经网络模型:</p><ul class=""><li id="c413" class="ls lt hh jl b jm kh jq ki ju lu jy lv kc lw kg lx ly lz ma bi translated">一个LSTM(长短期记忆)层，有100个神经元，辍学率为0.3，重复辍学率也为0.3。</li><li id="f962" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">辍学0.3</li><li id="1a15" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">64个神经元的密集(完全连接)层，激活双曲正切(“tanh”)</li><li id="0f8a" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">辍学0.3</li><li id="5f54" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">32个神经元的密集(完全连接)层，激活整流线性单元(“relu”)</li><li id="b995" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">辍学0.3</li><li id="30c1" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">16个神经元的密集(完全连接)层，激活标准化指数(“softmax”)</li><li id="1657" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">辍学0.3</li><li id="b541" class="ls lt hh jl b jm mb jq mc ju md jy me kc mf kg lx ly lz ma bi translated">单个神经元完全连接的线性激活层，其目标是输出回归值</li></ul><p id="46f7" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">上面的架构旨在捕捉LSTM层的时间序列行为。每个完全连接的层都有不同的激活函数，因此它可以捕捉上一层可能错过的非线性。退出率是层中的每个神经元在一轮反向传播过程中被“退出”的概率，具有正则化的效果，类似于线性回归中的套索或岭回归。虽然通常使用0.1的比率，但我们决定使用更高的比率，以避免过度拟合，因为我们的数据集包含很少的样本(数百行)[6][14]</p><p id="bf53" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">使用的优化算法是自适应矩估计(“adam”)，而损失是均方误差。训练发生在350个纪元中。[6]</p><p id="4e3d" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">由于第一个图层是Keras LSTM，因此必须将输入数据转换为3D格式，以便对该图层进行处理。3D必须采用以下形式(样本、时间步长、特征)。样本是观察值的数量。时间步长要观察的先前时间步长的数量。以及我们想要分析的不同特征的数量。[6][15][16]</p><p id="19fe" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">在我们的特殊情况下，我们将选择12个时间步长，因为我们的每个数据点代表一个月的日期，我们对每年的通货膨胀感兴趣。如前所述，特征的数量是4。[6][15][16]</p><p id="439b" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">在代码中:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="3f74" class="kv im hh kr b fi kw kx l ky kz">n_neurons_dense=64<br/>dropout_ratio=0.3<br/>model=Sequential()<br/>model.add(LSTM(100,dropout=dropout_ratio,recurrent_dropout=dropout_ratio,input_shape=(n_steps,n_features)))<br/>model.add(Dropout(dropout_ratio))<br/>model.add(Dense(n_neurons_dense,activation='tanh'))<br/>model.add(Dropout(dropout_ratio))<br/>model.add(Dense(n_neurons_dense/2,activation='relu'))<br/>model.add(Dropout(dropout_ratio))<br/>model.add(Dense(n_neurons_dense/(2**2),activation='softmax'))<br/>model.add(Dropout(dropout_ratio))<br/>model.add(Dense(1,activation='linear'))<br/><br/>model.compile(optimizer='adam',loss='mse')</span></pre><p id="9eb0" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">Keras LSTM必须接收3D形状的数据:(样本、时间步长、要素)，我们将时间步长视为12(相当于前一年)，并保留在上述p值和R平方建模中研究的要素:[16]</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="9dfb" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">def</strong> split_sequence(df,Y,n_steps):<br/>  columns=list(df.columns)<br/>  X, y = list(), list()<br/>  <strong class="kr hi">for</strong> i <strong class="kr hi">in</strong> range(len(df)):<br/>    <em class="mg"># find the end of this pattern</em><br/>    end_ix = i + n_steps<br/>    <em class="mg"># check if we are beyond the sequence</em><br/>    <strong class="kr hi">if</strong> end_ix &gt; len(df)-1:<br/>      <strong class="kr hi">break</strong><br/>    <em class="mg"># gather input and output parts of the pattern</em><br/>    seq_x, seq_y = df[columns][i:end_ix].values, Y[end_ix]<br/>    X.append(seq_x)<br/>    y.append(seq_y)<br/>  <strong class="kr hi">return</strong> np.array(X), np.array(y).reshape(-1,1)</span><span id="3c7e" class="kv im hh kr b fi la kx l ky kz">X,Y_fin=split_sequence(df[['IPCA','USD_2_BRL_Variation','Daily_Base_Interest_Rate','Inflacao_12_Meses']],df['Media'],n_steps)<br/>X,Y=split_sequence(df[['IPCA','USD_2_BRL_Variation','Daily_Base_Interest_Rate','Inflacao_12_Meses']],df['Inflacao_12_Meses_Shift'],n_steps)</span></pre><p id="a7ca" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">x是独立变量，Y是未来12个月的通胀，Y-fin是巴西金融机构预测的未来12个月的通胀</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="a6cf" class="kv im hh kr b fi kw kx l ky kz">print("X Shape: "+str(X.shape))<br/>print("Y Shape: "+str(Y.shape))<br/>print("Y_fin Shape: "+str(Y_fin.shape))</span><span id="a9c8" class="kv im hh kr b fi la kx l ky kz">X Shape: (186, 12, 4)<br/>Y Shape: (186, 1)<br/>Y_fin Shape: (186, 1)</span></pre><p id="961b" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">考虑到大量的nan，我们减少到一个小的数据集，这导致过度拟合成为一个问题。因此，我们将进行70%-30%的训练测试集拆分，这在scikit-learn机器学习中很常见，但在深度学习中并不常见。测试集将是可用的最新数据:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="08e5" class="kv im hh kr b fi kw kx l ky kz">X_train=X[:int(df.shape[0]*0.7),:,:]<br/>X_test=X[-(len(X)-int(df.shape[0]*0.7)):,:,:]<br/>Y_Train=Y[:int(df.shape[0]*0.7)]<br/>Y_Test=Y[-(len(X)-int(df.shape[0]*0.7)):]<br/>Y_fin_Test=Y_fin[-(len(X)-int(df.shape[0]*0.7)):]<br/>print(X_train.shape)<br/>print(X_test.shape</span></pre><p id="5a74" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">并适合:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="32a1" class="kv im hh kr b fi kw kx l ky kz">model.fit(X_train.astype(np.float32), Y_Train.astype(np.float32), epochs=350, verbose=1)</span></pre><p id="0bde" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">拟合之后，我们将得到我们的预测:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="5f73" class="kv im hh kr b fi kw kx l ky kz">Y_pred=model.predict(X_test.astype(np.float32))</span></pre><p id="5097" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">最后，评估:</p><pre class="km kn ko kp fd kq kr ks kt aw ku bi"><span id="c3a2" class="kv im hh kr b fi kw kx l ky kz"><strong class="kr hi">from</strong> <strong class="kr hi">sklearn.metrics</strong> <strong class="kr hi">import</strong> mean_squared_error<br/><br/>df_result=pd.DataFrame()<br/>df_result['Ground_Truth']=Y_Test.reshape(1,-1)[0]<br/>df_result['NN_Prediction']=Y_pred.reshape(1,-1)[0]<br/>df_result['FI_Prediction']=Y_fin_Test.reshape(1,-1)[0]<br/>df_result=df_result.dropna(how='any')<br/><br/><em class="mg">#Mean Squared error of neural network prediction:</em><br/>print("Mean Squared Error of neural network prediction: "+str(mean_squared_error(df_result['Ground_Truth'],df_result['NN_Prediction'])))<br/><em class="mg">#Mean squared error of predictions from Financial Institutions:</em><br/>print("Mean Squared Error of predictions from Financial Institutions: "+str(mean_squared_error(df_result['Ground_Truth'],df_result['FI_Prediction'])))</span><span id="0cc2" class="kv im hh kr b fi la kx l ky kz">Mean Squared Error of neural network prediction: 6.162676151752825<br/>Mean Squared Error of predictions from Financial Institutions: 7.155896426248233</span></pre><h1 id="11cd" class="il im hh bd in io mh iq ir is mi iu iv iw mj iy iz ja mk jc jd je ml jg jh ji bi translated">结论</h1><p id="a4b7" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">所获得的结果表明，在金融机构中使用传统的宏观经济模型，神经网络在长期通货膨胀预测方面可以达到比专业团队更好的性能。自然，这样的结果可能会由于小数据集而波动，但是，它表明深度学习是这种预测的一种替代方法。</p><p id="556c" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">该模型是在各种恶性通货膨胀和轻度通货膨胀的情况下训练出来的。迁移学习对于预测不同货币的通货膨胀是可能的。由于使用的汇率是美元对BRL，任何打算预测美国通胀的用户都应该将汇率改为黄金价格或国际货币基金组织的特别提款权(最接近全球货币)，因为没有其他法定货币具有与美元相同的全球储备地位。该模型的代码可以在github上公开获得。[17]</p><h1 id="831d" class="il im hh bd in io mh iq ir is mi iu iv iw mj iy iz ja mk jc jd je ml jg jh ji bi translated">参考</h1><p id="2c28" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg ha bi translated">[1] —洛佩斯和罗塞蒂—货币经济学(9版)—ISBN 978–85–224–3969–0</p><p id="d518" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[2] —曼昆，乔治—宏观经济学(第8版)—ISBN 978–2–4393–4002–4</p><p id="6367" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[3]——圣路易斯美联储银行和世界银行——美国通货膨胀和消费者价格(系列代码:FPCPITOLZGUSA)</p><p id="7321" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[4]-<a class="ae mm" href="https://www.oecd-ilibrary.org/economics/inflation-forecast" rel="noopener ugc nofollow" target="_blank">https://www.oecd-ilibrary.org/economics/inflation-forecast</a>2020年9月9日检索</p><p id="3534" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[5]-dado sabertos . BCB . gov . br-于2020年9月7日检索</p><p id="5666" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[6] — Géron，A. —动手:用Scikit-Learn和TensorFlow进行机器学习—ISBN 978–85–508–0381–4</p><p id="f916" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[7] — <a class="ae mm" href="https://content.iospress.com/search?q=author%3A%28%22Roy+Choudhury%2C+Ahana%22%29" rel="noopener ugc nofollow" target="_blank">罗伊·乔杜里，阿哈纳</a> | <a class="ae mm" href="https://content.iospress.com/search?q=author%3A%28%22Abrishami%2C+Soheila%22%29" rel="noopener ugc nofollow" target="_blank">阿布拉沙米，索赫拉</a> | <a class="ae mm" href="https://content.iospress.com/search?q=author%3A%28%22Turek%2C+Michael%22%29" rel="noopener ugc nofollow" target="_blank">图雷克，迈克尔</a> | <a class="ae mm" href="https://content.iospress.com/search?q=author%3A%28%22Kumar%2C+Piyush%22%29" rel="noopener ugc nofollow" target="_blank">库马尔，皮尤什</a> — <a class="ae mm" href="https://content.iospress.com/articles/ai-communications/aic200629" rel="noopener ugc nofollow" target="_blank">利用神经网络提高股票交易利润</a></p><p id="d195" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[8] — <a class="ae mm" href="http://www.scielo.br/cgi-bin/wxis.exe/iah/?IsisScript=iah/iah.xis&amp;base=article%5Edlibrary&amp;format=iso.pft&amp;lang=p&amp;nextAction=lnk&amp;indexSearch=AU&amp;exprSearch=TERRA,+LEONARDO+AUGUSTO+AMARAL" rel="noopener ugc nofollow" target="_blank">地球,莱昂纳多·奥古斯托·阿马拉尔(T1)和</a><a class="ae mm" href="http://www.scielo.br/cgi-bin/wxis.exe/iah/?IsisScript=iah/iah.xis&amp;base=article%5Edlibrary&amp;format=iso.pft&amp;lang=p&amp;nextAction=lnk&amp;indexSearch=AU&amp;exprSearch=PASSADOR,+JOAO+LUIZ" rel="noopener ugc nofollow" target="_blank">帕萨多尔,约翰·路易斯(T3)。通货膨胀预测中的人工神经网络:作为小型组织财务决策分析支持工具的应用。</a></p><p id="4f0a" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[9] — 巴西中央银行,开放数据,终点(通货膨胀率预测):“https://olinda.bcb.gov.br/olinda/servico/Expectativas/vers/v1/data/ExpectativasMercadoInflacao12月?$top=10000&amp;$filter=Indicator%20eq%20'IPCA'%20and%20Shift%20eq%20'N'&amp;$format=json&amp;$select=Indicator,Data,Media,Mediana,偏移量,系数Variacao,Medium,Maximo"</p><p id="cc00" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[10] — 巴西中央银行,开放数据,终端(通货膨胀率效应):“<a class="ae mm" href="http://api.bcb.gov.br/dados/serie/bcdata.sgs.4448/dados?formato=json" rel="noopener ugc nofollow" target="_blank"> http://api.bcb.gov.br/dados/serie/bcdata.sgs.4448/dados?format=json </a></p><p id="8973" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[11] — 巴西中央银行,开放数据,终端(美元/ BRL 交换率):“https://olinda.bcb.gov.br/olinda/servico/PTAX/vers/v1/data/CotacaoDolar期间(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?@dataInicial='01-01-1980'&amp;@dataFinalCotacao='01-01-2020'&amp;$top=10000&amp;$format=json&amp;$select=cotacao销售,dataHoraCotacao"</p><p id="1b71" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[12] — 巴西中央银行,开放数据,终端(SELIC Interest Rate): “<a class="ae mm" href="https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?formato=json" rel="noopener ugc nofollow" target="_blank"> https://api.bcb.gov.br/dados/serie/bcdata.sgs.11/dados?格式=json </a></p><p id="18b4" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[13]十,大卫。Çetinkaya-Rundel, 矿山巴尔D。Christopher - OpenIntro Statisticcs, 第四版</p><p id="86e1" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[14] 詹姆斯,加雷斯维滕,丹妮拉;哈斯提,特雷弗Robert Tibshirani, An Introduction to Statistical Learning 《统计学习导论》</p><p id="faa8" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[15] — Brownlee, Jason — How to Develop LSTM Models for Time Series Forecasting — <a class="ae mm" href="https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/" rel="noopener ugc nofollow" target="_blank"> https://machinelearningmastery.com/how-to-develop-lstm-models-for-time-series-forecasting/ </a></p><p id="9ba6" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[16] — Brownlee, Jason -How to Reshape Input Data for Long Short-Term Memory Networks in Keras — <a class="ae mm" href="https://machinelearningmastery.com/reshape-input-data-long-short-term-memory-networks-keras/" rel="noopener ugc nofollow" target="_blank">https://machinelearningmastery.com/reshape-input-data-long-short-term-memory-networks-keras/ </a></p><p id="aa00" class="pw-post-body-paragraph jj jk hh jl b jm kh jo jp jq ki js jt ju kj jw jx jy kk ka kb kc kl ke kf kg ha bi translated">[17]—<a class="ae mm" href="https://github.com/pfmoro/Brazilian_Inflation_Modelling" rel="noopener ugc nofollow" target="_blank">https://github.com/pfmoro/Brazilian_Inflation_Modelling</a></p></div></div>    
</body>
</html>