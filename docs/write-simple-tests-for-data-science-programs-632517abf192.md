# 如何为数据科学程序编写简单的测试

> 原文：<https://medium.com/analytics-vidhya/write-simple-tests-for-data-science-programs-632517abf192?source=collection_archive---------24----------------------->

![](img/5da943bc9529ac72ae0da6163e1d97d6.png)

照片由[克里斯·利维拉尼](https://unsplash.com/@chrisliverani?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)在 [Unsplash](/s/photos/test?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) 上拍摄

## 写测试很无聊

或者看起来是这样，直到你掌握了窍门！在大量复杂的调试和复杂的建模之后，这通常是你最不想做的事情。

快速搜索谷歌会告诉你，从长远来看，为你的代码编写测试真的会节省你的时间。嘿，理想情况下，你甚至会习惯于在编写程序时编写它们，并强迫自己创建更多的模块化代码。

但是，如果你像我一样，当你试图为数据科学代码实际实现这些理论时，你经常会遇到绊脚石。所有的例子都是关于如何为一个数的平方函数编写代码，这与你的程序抓取一个网站、解析数据、预处理文本、构建一个稀疏矩阵、加载一个预先训练好的分类器等等相差甚远。等等。等等。

如果你一直在纠结这些问题，那么这篇文章就是为你准备的:

*   如果每次发送请求时网站都不一样，你应该如何测试抓取网站的功能？
*   你应该如何测试一个在处理完数据后写入文件的函数——你不希望它覆盖你已经完成的工作吧！
*   你应该如何测试一个因为速率限制而永远运行的 API 调用呢？

Pytest 是你的朋友

所以，从`pip install pytest`开始吧。有很多方法可以用测试来设计应用程序，但是我发现一个简单的方法是这样的:

```
project_name/
│
├── app/
│   ├── __init__.py
│   ├── program_file.py
│
├── tests/
│   ├── tests.py
│
├── conftest.py
```

这样，在您的 tests.py 中，您可以通过放置像`from app.program_file import my_function`这样的代码来导入您需要的所有文件，这使得事情变得相当简单。

如果您将一个空的 conftest.py 文件放在主项目目录中，那么 pytest 就很容易找到测试文件的位置。要运行测试，你可以点击主项目目录中的`python -m pytest tests/`，pytest 将运行目录中的所有测试，不会问任何问题。

像这样构建您的项目也是非常可伸缩的——您可以在测试目录中添加额外的测试，如 test_one.py 或 test_two.py，pytest 将测试它们。您还将您的测试与主应用程序代码分离开来，这保持了整洁。

**嘲讽请求**

所以，你想测试一个从网站抓取数据的功能。这个其实挺简单的——`pip install requests-mock`。然后你可以这样做:

如果你想要更多的上下文，这里的原始源代码是。

但是通过将 requests_mock 传递给 test_get_listing 函数，您可以有效地防止该函数实际发出请求并提供您想要的输出。

这里我指定 requests.get 返回的 response.content 对象将是`b"data`，但是我也可以说通过在第 15 行添加`text='test_data'`使 response.text 对象等于‘test _ data’。

然后在 assert 中，我测试的函数返回 response.content 对象，所以我只是检查它等于什么。但是，如果您有一个解析响应数据的函数，您可以在这里将预期输出设置为等于函数实际返回的内容。

这里的要点是，通过模仿 requests.get 方法，您可以完全控制它返回的数据，如果您将 get 请求发送到一个不断更新的网站，您就不会这样做。

**防止测试覆盖文件**

假设您进行了多次 api 调用，每次获得数据后，您都将其作为 json 转储。作为一个题外话，这实际上非常有帮助，因为如果你试图为多个 api 调用调用`json.dump`并不能很好地工作。

总之，一旦你完成了，你就可以把所有的 json 文件读入一个大熊猫数据帧，并把它写成 csv 或类似的格式。

好吧，如果你这样做，你可能不希望测试覆盖你的数据！因此，您可以通过将`tmp_path`传递给测试函数来解决这个问题，如下例所示。

这可以防止您编写的测试函数接触您的主代码中的文件——在上面的示例中，在 project_name/app/目录中。它实际上在 tests 目录中创建了一个临时目录，在那里它完成了所有这些工作。

对于上下文，在我测试的方法中—alerts _ testing . check _ for _ updates()—有相当多的代码是这样做的:

```
with open('file_path', 'w') as f:
    f.write(response_info)
with open('old_file_path', 'r') as f:
    if not response_info == old_info:
        return response_info
```

所以我需要检查这个函数中的代码是否工作正常，但是我想在不写入文件的情况下保存应用程序源目录中的内容，这使得传递`tmp_path`成为一个简单的修复！

**测试慢速 API**

这里有一篇关于如何做到这一点的很好的文章会更深入一点，但是现在我将用这个非常简单的例子来结束。

假设我在其他示例中使用的 alerts 程序进行了一次缓慢的 API 调用，我必须让函数每隔 10m 休眠一次，以避免用完我的配额。

但是我想测试这个函数在完成所有调用后是否正确地解析了来自 API 的数据——这是我在以后调整代码时不想破坏的一点。

你可以通过这样的测试达到这样的效果:

这有点复杂……这里发生的事情是，Alerts 类中有一个方法— `make_api_call()`,在这个测试文件中被实例化为`alerts_testing`——它进行多个 api 调用，需要一段时间来运行。

为了进行这些调用，它调用 Alerts 类中的另一个方法`api()`，然后解析返回的数据。

因此，我们基本上想检查它是否解析了数据，而不需要进行 api 调用。为此，我们只需告诉 pytest 为`api()`方法“打补丁”,使其返回我们想要的任何内容，在本例中，字典包含第 4–7 行的天气信息。

现在测试不会进行 API 调用，我们可以指定这个`api()`方法返回的数据，这意味着我们确切地知道如果正确解析数据的话`make_api_call()`方法应该返回什么。因此，我们将其设置为 expected，并检查它是否与该方法使用 assert 语句实际返回的内容相匹配。

我希望这有意义！如果没有，我建议您尝试一下，运行一个测试，看看 pytest 会给出什么样的错误。

作为一个离别的想法，我经常发现仅仅写一个测试用例并看看它做什么要容易得多。即使它失败了，一旦它完全从你的头脑中消失了，你通常会更直接地知道下一步该做什么。