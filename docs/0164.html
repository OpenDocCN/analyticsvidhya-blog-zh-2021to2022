<html>
<head>
<title>Part 4: Memory Functionality Of Git</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第4部分:Git的内存功能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/part-4-memory-functionality-of-git-5890e3d26ca3?source=collection_archive---------27-----------------------#2021-01-06">https://medium.com/analytics-vidhya/part-4-memory-functionality-of-git-5890e3d26ca3?source=collection_archive---------27-----------------------#2021-01-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="bd71" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">今天，我们深入探讨git存储系统。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/9fd66b41f4ef2eff9d45b6935cb7160e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SABnYfT-DtAuwGOgkqs79g.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">由<a class="ae js" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">约书亚·索蒂诺</a>在<a class="ae js" href="https://unsplash.com/@sortino?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><p id="2c78" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">git的内存功能没有你想象的那么难，但暂时还是很难理解。在我看来，最好的理解方式不是使用电梯，而是步行。这意味着我们将手动创建散列和提交。但首先要做的是。☕️，喝杯咖啡，我们开始吧。</p><blockquote class="jt ju jv"><p id="b9c0" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated">今天我们将手动创建各种散列。我在上一篇文章里给他们都解释过了。所以在这里，我将只研究git如何将更改存储到git数据库中。如果你不清楚blob树或提交是什么，我强烈建议你先阅读我的文章-&gt;<a class="ae js" rel="noopener" href="/analytics-vidhya/git-part-3-discover-the-git-folder-ca3e828eab3d">git-part-3-discover-the-git-folder</a>。</p></blockquote><h1 id="dd76" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">议程</h1><ul class=""><li id="5d61" class="ky kz hh ig b ih la il lb ip lc it ld ix le jb lf lg lh li bi translated">一滴</li><li id="bd49" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">三</li><li id="a857" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">犯罪</li><li id="bc5b" class="ky kz hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">结论</li></ul><h1 id="c053" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">一滴</h1><p id="10a6" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">首先，我们需要一个新的git存储库。接下来，我们必须做出一些改变。因此类型</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="7b77" class="lw kb hh ls b fi lx ly l lz ma">echo 'text' &gt;&gt; text.txt; echo 'text' &gt;&gt; text2.txt; echo 'text2' &gt;&gt; text3.txt</span></pre><p id="9277" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在你的终端里。在那之后，我们有东西要上演。现在，激动人心的部分开始了。要将我们的更改转换成blobs，我们必须编写<code class="du mb mc md ls b">git hash-object *filename</code>。在我们的例子中，我们需要用<em class="jw"> text.txt、text2.txt和text3.txt替换文件名，或者我们可以使用通配符* </em>。该命令创建一个<strong class="ig hi"> 160位散列</strong>，并在控制台中显示为一个<strong class="ig hi"> 40十六进制数</strong>。但实际上，我们不只是想看到斑点。我们想要的是将它们存储在数据库中。为此，我们需要在命令的hash对象和文件名之间添加-w。</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="4ced" class="lw kb hh ls b fi lx ly l lz ma">git hash-object -w *</span></pre><p id="801f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">之后，我们坚持保存我们的更改。但仅仅是内容。blob不关心文件/文件夹名称或其他附加信息。下面我们看到生成的斑点。你可能想知道为什么只有两个斑点。这是因为我们的两个变化是相同的。你还记得blobs只存储内容吗？因此，我们有一个blob来存储两个不同文件的内容。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/83cfa05703985475220775550819b652.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZuuc-a07OZuuQnhBF_6vg.png"/></div></div></figure><p id="5d33" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一步是创建我们的提交。这家店的更重要的信息是关于我们的变化。我们已经知道，当我们正常生成提交时，git会创建一棵树和一个提交散列。让我们做那个手册。然而，我们需要先做一些事情。几个步骤前，我们将blobs存储在本地git数据库中。现在我们需要将更改添加到索引中，也称为临时区域。通常这是用<code class="du mb mc md ls b">git add</code>命令自动完成的，但现在我们已经手动保存了我们的更改。因此，我们必须用命令<code class="du mb mc md ls b">git update-index --add *</code>将我们的更改附加到索引上。我们需要追加<strong class="ig hi"> -添加</strong>，因为通常情况下，<strong class="ig hi">更新索引</strong>会忽略新文件。之后，我们准备创建树。</p><h1 id="6f5d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">树</h1><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="8943" class="lw kb hh ls b fi lx ly l lz ma">git write-tree</span></pre><p id="abc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的命令创建了一个树散列，其中整个索引的所有条目都是树项目。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/b6020a6cb7cc4f040f861699b64b97a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIL0Az8i21NFymiGscd79A.png"/></div></div></figure><p id="b975" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要检查我们的树，键入<code class="du mb mc md ls b">git cat-file -p 9c...</code>。在我们的例子中，我们有三个条目。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/69b5a11dbcb938d0da62373f1fac8200.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OMpfjsWUxa-i3NXdmAu4rQ.png"/></div></div></figure><p id="d673" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 100644 </strong>表示文件的种类。在我们的例子中，它是一个<strong class="ig hi">普通文本文件</strong>。其他可能是<strong class="ig hi"> 100755 </strong>这意味着它是一个<strong class="ig hi">可执行文件</strong>或<strong class="ig hi"> 120000 </strong>来指定引用为一个<strong class="ig hi">符号链接</strong>。我认为blob应该是不言自明的。十六进制数字是对我们保存的更改的blob的引用，在末尾，text.txt、text2.txt和text3.txt是相应的文件名。您可能想知道为什么三个条目中的两个具有相同的引用。如上所述，这是因为两个文件具有相同的内容，并且这导致相同的blob被引用。现在你应该知道git树存储了什么。简而言之，git树包含哪个文件或目录与哪个blob相关联。</p><h1 id="4e8e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">犯罪</h1><p id="4fe2" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">最后，该树允许我们创建一个提交对象。为此，您需要输入以下内容:</p><pre class="jd je jf jg fd lr ls lt lu aw lv bi"><span id="68c4" class="lw kb hh ls b fi lx ly l lz ma">echo 'feat: Add new test.txt file with content test' | git commit-tree *tree-hash.</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/72308650130a80af1535f62c4053ef61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T00x5KuDenAWJdqbxKSk3w.png"/></div></div></figure><p id="c1b8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们检查一下提交对象。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es me"><img src="../Images/1697bdfc73d5d36aa6695a929848fe07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0u9EH-rJsU5Xx0-m2WRCDQ.png"/></div></div></figure><p id="66d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在顶部，我们看到对我们的树散列、作者和提交代理的引用，以及日期和提交消息。但是第一次提交是特殊的。通常我们也会看到对前一次提交的引用，但实际提交是第一次。一个提交也可能有多个父提交。</p><h1 id="fa9a" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">结论</h1><p id="c893" class="pw-post-body-paragraph ie if hh ig b ih la ij ik il lb in io ip lo ir is it lp iv iw ix lq iz ja jb ha bi translated">今天，您简要回顾了git如何存储内容。此外，您现在应该知道git的数据库(文件系统)是如何工作的。我希望这次旅行有趣且有帮助。如果你有什么要提的或有问题，请在评论区留言。再见😃。</p></div></div>    
</body>
</html>