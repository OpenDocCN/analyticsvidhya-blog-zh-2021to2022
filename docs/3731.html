<html>
<head>
<title>A brief overview of Queue in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中队列的简要概述</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-brief-overview-of-queue-in-python-7e9ea57a47e4?source=collection_archive---------12-----------------------#2021-07-20">https://medium.com/analytics-vidhya/a-brief-overview-of-queue-in-python-7e9ea57a47e4?source=collection_archive---------12-----------------------#2021-07-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/be7cd4d9c2930f36a19453a92b069f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZdViWSGDs3WIZe0-rs1zaA.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">阿德里安·德尔福吉在<a class="ae it" href="https://unsplash.com/s/photos/queue?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><h1 id="dfd3" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">长队</h1><p id="64ec" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">队列是根据先进先出(FIFO)原则插入和移除的对象的集合。</p><p id="6166" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">参考上图，移除对象的确切原则适用于队列。我们从队伍的前面移走，插在最后，因此，先进先出(来的早走的早)。</p><p id="37a4" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">队列的主要操作</strong></p><ul class=""><li id="652e" class="kv kw hh ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">入队:将元素添加到队列中。</li><li id="828f" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">出列:删除队列中最长的元素。</li></ul><h1 id="4b9d" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用Deque的单端队列包装类</h1><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9e4e" class="ls iv hh lo b fi lt lu l lv lw">from collections import deque<br/>class Queue():<br/>    <br/>    def __init__(self):<br/>        self.queue = deque()<br/>        self.size = 0<br/>        <br/>    def enqueue(self, item):<br/>        self.queue.append(item)<br/>        self.size += 1<br/>        <br/>    def dequeue(self, item):<br/>        if self.size &gt; 0:<br/>            self.size -= 1<br/>            return self.queue.popleft()<br/>        else: <br/>            return None<br/>        <br/>    def peek(self):<br/>        if self.size &gt; 0:<br/>            ret_val = self.queue.popleft()<br/>            self.queue.appendleft(ret_val)<br/>            return ret_val<br/>        else:<br/>            return None<br/>    def get_size(self):<br/>        return self.size<br/>    <br/>    def __str__(self):<br/>        queue_items = []<br/>        if self.size &gt; 0:<br/>            counter=0<br/>            while self.size &gt; counter:<br/>                val = self.queue.popleft()<br/>                queue_items.append(val)<br/>                counter+=1<br/>                <br/>            while counter&gt;0:<br/>                self.queue.appendleft(queue_items[counter-1])<br/>                counter-=1<br/>            return str(queue_items)<br/>        else:<br/>            return None</span></pre><h2 id="6aff" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">运行代码:</h2><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="3551" class="ls iv hh lo b fi lt lu l lv lw"># creating queue object<br/>my_queue = Queue()<br/><br/><br/>my_queue.enqueue(1)<br/>my_queue.enqueue(2)<br/>my_queue.enqueue(3)<br/>print('Complete queue as of now')<br/>print(my_queue)<br/>print('Size: ', my_queue.get_size())</span><span id="8ed3" class="ls iv hh lo b fi mk lu l lv lw"><br/>print('\nQueue after applying peek')<br/>print(my_queue.peek())<br/>print(my_queue)<br/>print('Size: ', my_queue.get_size())<br/><br/><br/>print('\nQueue after applying dequeue once')<br/>print(my_queue.dequeue(3))<br/>print(my_queue)<br/>print('Size: ', my_queue.get_size())</span><span id="94e2" class="ls iv hh lo b fi mk lu l lv lw"><br/>print('\nQueue after applying peek')<br/>print(my_queue.peek())<br/>print(my_queue)<br/>print('Size: ', my_queue.get_size())</span><span id="46e3" class="ls iv hh lo b fi mk lu l lv lw"># Results: *******************************************************</span><span id="8f4b" class="ls iv hh lo b fi mk lu l lv lw">Complete queue as of now<br/>[1, 2, 3]<br/>Size:  3<br/><br/>Queue after applying peek<br/>1<br/>[1, 2, 3]<br/>Size:  3<br/><br/>Queue after applying dequeue once<br/>1<br/>[2, 3]<br/>Size:  2<br/><br/>Queue after applying peek<br/>2<br/>[2, 3]<br/>Size:  2</span></pre><h1 id="551e" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">双端队列</h1><p id="4f06" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">一种支持在队列前端和后端插入和删除的数据结构。</p><p id="c611" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated"><strong class="ju hi">对deque </strong>的主要操作</p><ul class=""><li id="6e99" class="kv kw hh ju b jv kq jz kr kd kx kh ky kl kz kp la lb lc ld bi translated">append(e):-将值插入到deque的右端。</li><li id="e67e" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">appendleft(e):-将值插入到deque的左端。</li><li id="65c2" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">pop( ) :-删除deque右端的值。</li><li id="006f" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">popleft( ) :-删除deque左端的值。</li></ul><h2 id="b4b2" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">优势:</h2><ul class=""><li id="6db3" class="kv kw hh ju b jv jw jz ka kd ml kh mm kl mn kp la lb lc ld bi translated">在我们需要从容器两端进行更快的追加和弹出操作的情况下，dequee优于list，因为与提供O(n)时间复杂度的list相比，dequee为追加和弹出操作提供O(1)时间复杂度。</li></ul><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9115" class="ls iv hh lo b fi lt lu l lv lw"># Python code to demonstrate deque<br/><br/>from collections import deque<br/><br/>Dqueue = deque([1,2,3])<br/>print ("\nThe original deque is : ")<br/>print(Dqueue)<br/><br/>Dqueue.append(4)<br/>print ("\nThe deque after appending '4' at right is : ")<br/>print (Dqueue)<br/><br/><br/>Dqueue.appendleft(0)<br/>print ("\nThe deque after appending '0' at left is : ")<br/>print (Dqueue)<br/><br/><br/>Dqueue.pop()<br/>print ("\nThe deque after deleting from right is : ")<br/>print (Dqueue)<br/><br/><br/>Dqueue.popleft()<br/>print ("\nThe deque after deleting from left is : ")<br/>print (Dqueue)</span><span id="0131" class="ls iv hh lo b fi mk lu l lv lw"># Results: *******************************************************</span><span id="8299" class="ls iv hh lo b fi mk lu l lv lw">The original deque is : <br/>deque([1, 2, 3])<br/><br/>The deque after appending '4' at right is : <br/>deque([1, 2, 3, 4])<br/><br/>The deque after appending '0' at left is : <br/>deque([0, 1, 2, 3, 4])<br/><br/>The deque after deleting from right is : <br/>deque([0, 1, 2, 3])<br/><br/>The deque after deleting from left is : <br/>deque([1, 2, 3])</span></pre><h1 id="dc95" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">优先队列</h1><p id="f2bd" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">优先级队列是抽象的数据结构，其中队列中的每个数据/值都有特定的优先级。</p><h2 id="5e71" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">优先级队列与队列:</h2><ul class=""><li id="c6c2" class="kv kw hh ju b jv jw jz ka kd ml kh mm kl mn kp la lb lc ld bi translated">在队列中，最老的元素首先出队，但是在优先级队列中，基于最高优先级的元素出队。</li><li id="941c" class="kv kw hh ju b jv le jz lf kd lg kh lh kl li kp la lb lc ld bi translated">当元素从优先级队列中弹出时，所获得的结果或者按升序排序，或者按降序排序。而当从简单队列中弹出元素时，在结果中获得数据的FIFO顺序。</li></ul><h2 id="ed95" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">使用队列的优先级队列包装类。</h2><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="e319" class="ls iv hh lo b fi lt lu l lv lw">class PriorityQueue():<br/>    <br/>    def __init__(self):<br/>        self.queue = []<br/><br/>    def isEmpty(self):<br/>        return len(self.queue) == 0<br/><br/>    def insert(self, data):<br/>        self.queue.append(data)<br/><br/>    # popping an element based on Priority(using high value as high   priority in this implementation)<br/>    def delete(self):<br/>        try:<br/>            max = 0<br/>            for i in range(len(self.queue)):<br/>                if self.queue[i] &gt; self.queue[max]:<br/>                    max = i<br/>            item = self.queue[max]<br/>            self.queue.pop(max)<br/>            return item<br/>        except IndexError:<br/>            print('Index error: ')<br/>            exit()<br/>            <br/>    def __str__(self):<br/>        return ' '.join([str(i) for i in self.queue])</span></pre><h2 id="256a" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">运行代码:</h2><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="bfc0" class="ls iv hh lo b fi lt lu l lv lw"># creating PriorityQueue object</span><span id="ec89" class="ls iv hh lo b fi mk lu l lv lw">myQueue = PriorityQueue()<br/>myQueue.insert(4)<br/>myQueue.insert(2)<br/>myQueue.insert(3)<br/><br/>print ("\nThe original PriorityQueue is : ")<br/>print(myQueue, '\n')<br/><br/>print('\nRemoving all items based on priority: ')<br/>while not myQueue.isEmpty():<br/>    print(myQueue.delete())</span><span id="6b93" class="ls iv hh lo b fi mk lu l lv lw"># Results: *******************************************************</span><span id="7428" class="ls iv hh lo b fi mk lu l lv lw">The original PriorityQueue is : <br/>4 2 3 <br/><br/><br/>Removing all items based on priority: <br/>4<br/>3<br/>2</span></pre><h2 id="e51b" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">使用python内置的PriorityQueue实现(最小值具有更高的优先级)</h2><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="49ea" class="ls iv hh lo b fi lt lu l lv lw">import queue as Q<br/><br/>queue = Q.PriorityQueue()<br/>queue.put(4)<br/>queue.put(2)<br/>queue.put(3)<br/>    <br/>print('size:', queue.qsize())<br/><br/>print ("\nThe original PriorityQueue is : ")<br/>print(queue.queue)</span><span id="9105" class="ls iv hh lo b fi mk lu l lv lw">print('\nRemoving all items based on priority(high to min value): ')<br/><br/>print(queue.get())<br/>print(queue.get())<br/>print(queue.get())</span><span id="3097" class="ls iv hh lo b fi mk lu l lv lw">print('size:', queue.qsize())</span><span id="e86b" class="ls iv hh lo b fi mk lu l lv lw"># Results: *******************************************************</span><span id="d197" class="ls iv hh lo b fi mk lu l lv lw">size: 3<br/><br/>The original PriorityQueue is : <br/>[2, 4, 3]</span><span id="11bd" class="ls iv hh lo b fi mk lu l lv lw">Removing all items based on priority(high to min value): <br/>2<br/>3<br/>4<br/>size: 0</span></pre><h1 id="e8e6" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">使用案例:</h1><p id="b5b8" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp ha bi translated">查看这篇文章，了解我们日常生活中队列数据结构的有趣用例。</p><div class="mo mp ez fb mq mr"><a href="https://www.geeksforgeeks.org/applications-of-queue-data-structure/" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab dw"><div class="mt ab mu cl cj mv"><h2 class="bd hi fi z dy mw ea eb mx ed ef hg bi translated">队列数据结构的应用</h2><div class="my l"><h3 class="bd b fi z dy mw ea eb mx ed ef dx translated">当事情不是必须立即处理，而是必须以先进先出的顺序处理时，使用队列…</h3></div><div class="mz l"><p class="bd b fp z dy mw ea eb mx ed ef dx translated">www.geeksforgeeks.org</p></div></div><div class="na l"><div class="nb l nc nd ne na nf in mr"/></div></div></a></div><p id="44d7" class="pw-post-body-paragraph js jt hh ju b jv kq jx jy jz kr kb kc kd ks kf kg kh kt kj kk kl ku kn ko kp ha bi translated">既然您已经熟悉了队列的概念，那么请访问<a class="ae it" href="https://leetcode.com/tag/queue/" rel="noopener ugc nofollow" target="_blank"> Leet code </a>来练习一些现实生活中的问题，并使用本概述中总结的思想来解决它们。万事如意！</p><h2 id="8e3b" class="ls iv hh bd iw lx ly lz ja ma mb mc je kd md me ji kh mf mg jm kl mh mi jq mj bi translated">谢谢你看我的帖子。我希望你学到了一些有用的东西*🙌 🎉</h2></div></div>    
</body>
</html>