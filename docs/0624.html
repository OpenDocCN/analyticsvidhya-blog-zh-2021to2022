<html>
<head>
<title>Things to keep in mind while building ML models from scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始构建ML模型时要记住的事情</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/things-to-keep-in-mind-while-building-ml-models-from-scratch-158b9fe5c4af?source=collection_archive---------20-----------------------#2021-01-24">https://medium.com/analytics-vidhya/things-to-keep-in-mind-while-building-ml-models-from-scratch-158b9fe5c4af?source=collection_archive---------20-----------------------#2021-01-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="0f6c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">许多机器学习的初学者喜欢从scikit-learn库开始，我也不例外。但是他们往往会忘记从头开始构建模型的重要性。从头开始给你真正的答案。权重和特征怎么相乘？偏见呢？事实上，什么是偏见？如何执行乙状结肠功能？损失怎么算？如何找到权重的优化值？如果你有这些问题，那么你就在正确的轨道上，芽！而且是时候从头开始了！</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div></figure><p id="35dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，在做这件事的时候，你将拥有的最重要的工具之一就是NumPy库。这是一个非常强大的库，可以在任何时间计算繁重的计算。你可以把它想象成“数学”库，但是对于巨大的矩阵来说，它更加强大和庞大。</p><p id="d4cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我不会讨论NumPy的基础知识，而是讨论在使用NumPy从头构建模型时证明对我有用的解决问题的技术。</p><h2 id="72ae" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated"><strong class="ak">秩1数组</strong></h2><p id="81c9" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">在确定数组的形状时，您经常会遇到类似于'(5，) '的东西。这被称为“秩1数组”。这既不像行向量，也不像列向量。所以，使用<strong class="ig hi">断言</strong>函数总是一个好习惯。该函数用于确定内部所述的条件是否为真。如果不是，它将引发一个我们不想要的<strong class="ig hi"> AssertionError，</strong>。为了更好地理解，请考虑以下示例:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="0ee8" class="jj jk hh kk b fi ko kp l kq kr">import numpy as np<br/>a = np.array([12,3,4,55,6])</span></pre><p id="2d67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">乍一看，vector <strong class="ig hi"> a </strong>的形状看起来像(5，1)或者可能是(1，5)(上帝，我希望这不会变成另一个Yammy/Laurel困境，或者更糟，蓝色/黑色连衣裙！).</p><figure class="jc jd je jf fd jg"><div class="bz dy l di"><div class="jh ji l"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">因为编程中的模糊性是什么？对吗？</figcaption></figure><p id="db88" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我们使用<strong class="ig hi">断言</strong>函数来确保它看起来是这样的:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="11d3" class="jj jk hh kk b fi ko kp l kq kr">assert(a.shape==(5,1))</span></pre><p id="2c6b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的代码抛出了一个<strong class="ig hi"> AssertionError。</strong>这是因为矢量<strong class="ig hi"> a </strong>的形状不是(5，1)。</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="0db3" class="jj jk hh kk b fi ko kp l kq kr">print(a.shape)</span><span id="bd3d" class="jj jk hh kk b fi kw kp l kq kr">(5,)</span></pre><p id="fb4d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个问题的解决方案是:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="e37c" class="jj jk hh kk b fi ko kp l kq kr">a = a.reshape((5,1))<br/>print(a.shape)<br/>assert(a.shape==(5,1))</span><span id="de17" class="jj jk hh kk b fi kw kp l kq kr">(5, 1)</span></pre><p id="9f04" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">显示的输出没有引发任何错误。请随时使用<strong class="ig hi">重塑</strong>方法，即使它看起来是多余的，因为这可以创造奇迹！</p><p id="5575" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，如果你好奇的话，向量<strong class="ig hi"> a </strong>最终看起来像这样。</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="3f27" class="jj jk hh kk b fi ko kp l kq kr">print(a)</span><span id="8b81" class="jj jk hh kk b fi kw kp l kq kr">[[12]<br/> [ 3]<br/> [ 4]<br/> [55]<br/> [ 6]]</span></pre><p id="1a24" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，我猜是‘劳蕾尔’。嗯，不要看太多，可能会变成‘Yammy’！</p><h2 id="5d70" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">广播</h2><p id="a7d3" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">有一个非常简单的概念叫做广播。简单地说，它告诉NumPy如何处理不同形状的数组。所以，如果你遇到了一个错误，说“操作数不能和shapes (4，2) (2，2)一起传播”，那么你很幸运在这里。当我尝试执行以下操作时，会出现此错误:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="3ff6" class="jj jk hh kk b fi ko kp l kq kr">mat1 = np.array([[1,2],<br/>        [9,8],<br/>        [3,4],<br/>        [5,6]])<br/>mat2 = np.array([[3,5],<br/>                [10,2]])<br/>ans = mat1 + mat2</span></pre><p id="6441" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果<strong class="ig hi"> mat1 </strong>和<strong class="ig hi"> mat2 </strong>不是NumPy数组，而只是嵌套的列表，<strong class="ig hi"> mat2 </strong>会被连接到<strong class="ig hi"> mat1 </strong>，结果会是这样:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="e17f" class="jj jk hh kk b fi ko kp l kq kr">[[1, 2], [9, 8], [3, 4], [5, 6], [3, 5], [10, 2]]</span></pre><p id="d3b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，既然是NumPy，重点就在计算上。因此，两个不同阶的矩阵，即<strong class="ig hi"> (4，2) </strong>阶的<strong class="ig hi"> mat1 </strong>和<strong class="ig hi"> (2，2) </strong>阶的<strong class="ig hi"> mat2 </strong>不能相加。除了，当我这样做的时候:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="5b5c" class="jj jk hh kk b fi ko kp l kq kr">mat1 = np.array([[1,2],<br/>        [9,8],<br/>        [3,4],<br/>        [5,6]])<br/>mat2 = np.array([[3,5]])<br/>ans = mat1 + mat2<br/>print(ans)</span><span id="ff19" class="jj jk hh kk b fi kw kp l kq kr">[[ 4  7]<br/> [12 13]<br/> [ 6  9]<br/> [ 8 11]]</span></pre><p id="ac14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意现在<strong class="ig hi"> mat2 </strong>的顺序，是<strong class="ig hi"> (1，2) </strong>。我们在<strong class="ig hi">和</strong>得到结果，没有因为广播而有任何误差。简单来说，<strong class="ig hi"> mat2 </strong>不断重复自己，直到它的顺序变得和<strong class="ig hi"> mat1 </strong>一样，并把自己加到<strong class="ig hi"> mat1 </strong>上，给出了上面的结果。因此，在矩阵中传播的条件是，其中一项必须是1D阵列(不，不是一个方向的带)或整数的向量。以下是整数运算:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="6718" class="jj jk hh kk b fi ko kp l kq kr">mat1 = np.array([[1,2],<br/>        [9,8],<br/>        [3,4],<br/>        [5,6]])<br/>b = 12<br/>ans = mat1 + b<br/>print(ans)</span><span id="8f75" class="jj jk hh kk b fi kw kp l kq kr">[[13 14]<br/> [21 20]<br/> [15 16]<br/> [17 18]]</span></pre><p id="f5a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一概念将被证明是有用的，同时将偏差添加到矩阵中，该矩阵是特征矩阵和权重矩阵的点积。</p><h2 id="ab25" class="jj jk hh bd jl jm jn jo jp jq jr js jt ip ju jv jw it jx jy jz ix ka kb kc kd bi translated">点积</h2><p id="401f" class="pw-post-body-paragraph ie if hh ig b ih ke ij ik il kf in io ip kg ir is it kh iv iw ix ki iz ja jb ha bi translated">如果你来自非数学背景，点积可能会让你有点困惑。为了简单起见，本文将只讨论它的编码部分。点积是矩阵的乘法，只有当第一个<strong class="ig hi">矩阵的列数等于第二个<strong class="ig hi">矩阵的行数时才会发生。这是必要的，因为乘法发生在第<strong class="ig hi">第一</strong>矩阵的行和第<strong class="ig hi">第二</strong>矩阵的相应列之间。因此，<strong class="ig hi">结果</strong>矩阵的行数与第<strong class="ig hi">第一</strong>矩阵的行数相同，<strong class="ig hi">结果</strong>矩阵的列数等于第<strong class="ig hi">第二</strong>矩阵的列数。例如:</strong></strong></p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="3ea1" class="jj jk hh kk b fi ko kp l kq kr">first = np.array([[2,2],[5,6],[4,3],[3,1]])<br/>second = np.array([[3,7,1],[5,5,2]])<br/>print(first.shape, second.shape)</span><span id="2a7a" class="jj jk hh kk b fi kw kp l kq kr">(4, 2) (2, 3)<br/>    ------</span></pre><p id="8a2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注意，他们之间的共同点。</p><p id="15f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">猜测<strong class="ig hi">结果</strong>矩阵的顺序。正确！是(4，3)。</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="6d26" class="jj jk hh kk b fi ko kp l kq kr">import numpy<br/>result = np.dot(first,second)<br/>print(result)</span><span id="100d" class="jj jk hh kk b fi kw kp l kq kr">[[16 24  6]<br/> [45 65 17]<br/> [27 43 10]<br/> [14 26  5]]</span></pre><blockquote class="kx ky kz"><p id="42e3" class="ie if la ig b ih ii ij ik il im in io lb iq ir is lc iu iv iw ld iy iz ja jb ha bi translated">我们使用了<strong class="ig hi"> np.dot() </strong>，因为它是矩阵乘法。使用'<strong class="ig hi"> * ' </strong>到<strong class="ig hi"> </strong>乘法会导致我们之前讨论过的广播错误。</p></blockquote><p id="e374" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在解决问题时，可能会给你一个输入特征矩阵<strong class="ig hi"> X </strong>的阶数，比如说(5，3)，以及一个权重矩阵<strong class="ig hi"> w </strong>的阶数(1，3)。立刻，看起来他们的点积是不可能的，但是如果我们使用<strong class="ig hi"> w </strong>的转置呢？这将使<strong class="ig hi"> w </strong>的形状变为(3，1)。</p><p id="34f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我举个例子:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="4f99" class="jj jk hh kk b fi ko kp l kq kr">X = np.array([[1,2,3], <br/>              [6,5,4], <br/>              [7,8,9],<br/>              [12,11,10],<br/>              [13,14,15]])</span><span id="3bf1" class="jj jk hh kk b fi kw kp l kq kr">w = np.array([[2,6,4]])<br/>w_tp = w.T<br/>output = np.dot(X,w_tp)<br/>print(output)</span><span id="6587" class="jj jk hh kk b fi kw kp l kq kr">[[ 26]<br/> [ 58]<br/> [ 98]<br/> [130]<br/> [170]]</span></pre><p id="76d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> w_tp </strong>存储<strong class="ig hi"> w </strong>的转置，即:</p><pre class="jc jd je jf fd kj kk kl km aw kn bi"><span id="18dd" class="jj jk hh kk b fi ko kp l kq kr">print(w_tp)</span><span id="5290" class="jj jk hh kk b fi kw kp l kq kr">[[2]<br/> [6]<br/> [4]]</span></pre><p id="3cdb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你也可以使用<strong class="ig hi"> np.transpose(w) </strong>找到<strong class="ig hi"> w. </strong>的转置</p><p id="a78e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">最后</strong>但绝对不是最不重要的，从零开始制作东西需要时间。但是，在你看到你的模型给出了60%的准确率之后(*暗暗痛哭*)这一切都是值得的。</p></div><div class="ab cl le lf go lg" role="separator"><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj lk"/><span class="lh bw bk li lj"/></div><div class="ha hb hc hd he"><figure class="jc jd je jf fd jg er es paragraph-image"><div class="er es ll"><img src="../Images/04e6a46d2ee6b3c2ed2fb602ec189aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/1*LdwtlqVdwYCCG36QBh8YZg.gif"/></div></figure><blockquote class="lo"><p id="9958" class="lp lq hh bd lr ls lt lu lv lw lx jb dx translated">感谢您的阅读！希望你觉得有用:)</p></blockquote></div></div>    
</body>
</html>