<html>
<head>
<title>Linear Regression — Everything you need to know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">线性回归—您需要知道的一切</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/linear-regression-everything-you-need-to-know-b4b7a1f8a409?source=collection_archive---------5-----------------------#2021-08-11">https://medium.com/analytics-vidhya/linear-regression-everything-you-need-to-know-b4b7a1f8a409?source=collection_archive---------5-----------------------#2021-08-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="dd80" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每当我们谈论线性回归时，我们总是谈论找到数据的最佳拟合线，这正是线性回归的目标，但它不仅仅是拟合直线，所以让我们谈谈为什么以及如何找到最佳拟合线。</p><h1 id="d893" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">为什么需要找到最佳拟合线？</strong></h1><p id="2f9a" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">顾名思义，该算法对遵循线性趋势的数据进行处理，因此，如果我们可以找到一条可以正确定义数据趋势的线，我们就很可能使用同一条线来定义整个数据集，因此，使用同一条线，我们甚至可以获得数据集中不存在的点的值，这称为预测。</p><h1 id="f869" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">下一个问题是，我们如何找到这条最佳拟合线？</strong></h1><p id="9e89" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">看看下面的数据集，很明显，它遵循一个线性趋势。<br/>因此，仅仅通过查看数据集，我们就可以找到任何一点的输出，是的，我们可以，但现实世界的数据并不容易解释，在这些情况下，我们可以依靠算法的底层数学来找到可以理解数据趋势并适应它的线。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/2f742d8289b2ebf87daf69d4e8d1da6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:844/format:webp/1*9DsrKk3BKiTzvNuQgakoZw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated"><strong class="bd je">图1 </strong></figcaption></figure><p id="e862" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一下图1所示的数据。X和Y之间有线性关系，如果这种关系是线性的，那么一定有一条线来定义这种关系。众所周知，直线的方程是Y = M*X + C，我们可以很容易地将这个方程与我们的图1联系起来，其中X是数据集，Y是目标变量(我们必须找到它的值)，但什么是M和C呢？这些是用于创建直线的参数，其中M是直线的斜率，即直线与X轴的倾斜度，C是截距，即直线与Y轴相交的点。</p><p id="38dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">我们的目标是找到最能描述数据的直线，</strong>这可以使用我们手头的数据来完成，我们使用这些数据来找到趋势，然后使用直线来概括这个趋势，并使用这条直线来预测x的未知值。</p><p id="22e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">先来了解一下算法是怎么开始的。</strong> <br/>该算法做的第一件事是输出一条随机生成的线，即输出M和C的一些随机值，并使用这些值创建一条线。</p><p id="ffd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们来衡量这条线定义数据或拟合数据的程度。</p><p id="5db8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果是，它在描述X和y之间的关系时表现得很差，但是这条线表现得有多好呢？为了测量这一点，我们需要一个数值来告诉我们这条线与数据拟合的好坏。</p><p id="969c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们找到了实际数据点之间的距离，以及对于某个X值，直线距离该数据点有多远，简单地说，计算它们之间的距离，如果距离更小，那么我们可以说直线很好地定义了数据。</p><p id="66d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们需要用什么条件来找到这个距离，我们的目标是能够预测X的某个值，让我们用同样的方法，找到直线和数据点的Y坐标，然后找到这两者之间的距离。基于这一逻辑，我们可以将等式写成如下:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kr"><img src="../Images/1fc6a69ae5485d359502e812fe336b08.png" data-original-src="https://miro.medium.com/v2/resize:fit:102/1*7UXikLy4Hy9Djz3F28lhEg.gif"/></div></figure><p id="df18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">其中Y-Hat是线上的点，Y是某个X值的实际数据点，这个等式也可以称为误差。</p><p id="0693" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但这只是描述了一个数据点，如果另一个数据点的线非常远，假设我们对所有数据点进行相同的计算，然后对输出求和并取该值的平均值，我们就可以得到一个数字来描述我们定义的系统的综合误差。从而获得下面的等式，其中n是数据点的数量:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ks"><img src="../Images/8320a5437723409892b372faf5a9ba0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:216/1*XYUtEDzyr4WvQQzZMePyeA.gif"/></div></figure><p id="96c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如我们所见，目标是将直线与数据拟合，因此直线将穿过数据，在这种情况下，许多数据点将位于直线下方，这将为(Y-Yhat)计算提供负值，如果我们将所有正值和负值相加，结果有可能非常接近0，等等，什么！这意味着误差很小，线条很好，但事实并非如此。我们需要处理这件事。</p><p id="96da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们做一件事，在添加单个误差值之前，我们取它们的平方。因此，我们的等式将变成:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kt"><img src="../Images/e19f9eeb03790fae05073261681ee9f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/1*t3RnC1FGQOclPUbCkTXd-g.gif"/></div></figure><p id="c7a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们不会得到任何负值，但为什么我们要取一个平方，而不仅仅是误差的模，因为这样当数据点离线非常远时，我们会得到更高的误差项值，因此如果线离点非常远，会增加更多的惩罚。</p><p id="765c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，我们现在有一个完美的术语来描述系统的综合误差，我们可以称这个术语为损失函数。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ku"><img src="../Images/7ecb4839714e3bec27743cb3ba7bf527.png" data-original-src="https://miro.medium.com/v2/resize:fit:474/1*STqmormctTfR3CHg9ccC2A.gif"/></div></figure><p id="c9c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，非常清楚的是，如果直线与数据吻合，误差项将会非常小，因此，如果我们以某种方式找到减少误差的方法，我们可能会找到完美的直线。这正是我们的下一个目标。</p><p id="afe0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是我们如何找到，误差项和直线的关系。我们是否可以说这条线完全依赖于M和C，如果我们减少或增加M和C，这条线就会改变，如果是这样，那么一定存在M和C的某个值，对于这个值，我们将得到一条误差最小的线。但是我们如何知道M和C的值是最优的，为了回答这个问题，让我们画出损失函数w . r . t . M。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kv"><img src="../Images/cd71cbc65799f16206b84de80f3beb12.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*h3X2E_uFqJGXoYAX52xulA.png"/></div></figure><p id="180a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以清楚地看到，在点A，对于M的某个值，误差最小，所以我们需要某种方法来找到M的这个特定值，但是怎么做呢？</p><p id="3d92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，微分开始起作用，我们知道，对二阶曲线在任意点进行微分，将得到该曲线的切线，使用切线，我们可以发现该曲线在该点是增加还是减少，也就是说，如果切线的斜率为负，我们将在曲线上向下移动，如果切线的斜率为正，我们将在曲线上向上移动。</p><p id="b5a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们的目标是朝着这条曲线上的最小点移动，这将最终使我们达到M的最佳值，换句话说，如果我们根据我们在曲线上的位置相应地改变M的值，我们将最终朝着这个最小误差点移动。</p><p id="da4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很好，我们能够找到误差和斜率m之间的关系。</p><p id="8752" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以我们先求误差方程关于M的偏导数，在此之前，先写出误差项w.r.t M和c。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kw"><img src="../Images/42b028403a08f246b0387cdcdc34e8b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/1*kvlSoNEVXqkDLMurf-edZw.gif"/></div></figure><p id="8909" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以在损失函数中使用Yhat的值。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kx"><img src="../Images/57f699737e875b600f2aa402707c14a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:386/1*EoRzi_Jsf-kQcuk5UAffSA.gif"/></div></figure><p id="8f0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们找到上述方程的偏导数，我们将得到:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ky"><img src="../Images/a6d8c5ba5789c877f2c85a5c470a5745.png" data-original-src="https://miro.medium.com/v2/resize:fit:424/1*Y2UQTbq26-b5Ua0ZndVqYA.gif"/></div></figure><p id="3df3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以重写为:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kz"><img src="../Images/6abf91aba5995c1552747bbc6a54eea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/1*-Y6B3A33nBoMKpC_X72q3A.gif"/></div></figure><p id="cfdc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Tada！！我们找到了导数，现在让我们用这个导数值来增加或减少m的值。</p><p id="7830" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们知道负微分(正切)值意味着我们在正确的路径上到达曲线上的最小点，我们需要在曲线上向下移动，而正微分值意味着我们远离最小值，在曲线上向上移动，因此我们需要在曲线上向左和向下移动。这意味着，如果我们使用M的某个值生成了一条线，并且获得的损耗的相应微分值为负，这意味着我们在正确的路径上，我们只需要增加M，以便在曲线中向右和向下移动，类似地，如果我们获得损耗微分的正值，我们需要减小M的值，以便在曲线上向左和向下移动。记住这一点，让我们建立下面的等式，它可以帮助我们改变m的值。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es la"><img src="../Images/5eff3cfe3118edf88be8b911d27f521f.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/1*13AbrzekUjRbA9T0iY_Oww.gif"/></div></figure><p id="079a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里您可以看到一个额外的项——α，我们为什么需要它，结果是导数值会相当大，因此，如果我们减去或加上M，我们可能会得到一个远离最佳M的值，也就是说，M的值会有很大的变化，而不是这样，让我们非常缓慢地改变M的值，或者通过将一些非常小的值α乘以导数值来限制M的快速变化。</p><p id="fa20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里的<strong class="ig hi"> Alpha </strong>指的是学习率。</p><p id="644c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似地，我们也会找到C的值，只是导数方程有一点点变化，如下所示。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lb"><img src="../Images/34ef0c227617c37787a1443f23c8d63a.png" data-original-src="https://miro.medium.com/v2/resize:fit:338/1*tXTtI4cjJOQMrZ3YYgm0Kg.gif"/></div></figure><p id="9546" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">C的值将以与我们更新M的值相同的方式更新，即，使用下面的等式:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lc"><img src="../Images/644826352bfea8a2eb37a88900c66878.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/1*GzMI7VDVs8L3HZt9_REquQ.gif"/></div></figure><p id="7936" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述寻找误差函数的导数并在此基础上改变参数值的过程称为<strong class="ig hi">梯度下降</strong>。</p><p id="1653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们重复上述过程几次，我们可以慢慢地改变M和C的值，最终将获得一个最佳值。使用这些值创建的线误差最小，称为最佳拟合线。现在我们可以用这条线来做预测。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ld"><img src="../Images/2fe401469c26d0139a41e2ff07e2fe58.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*V7g_SV0CX4mgI5NvrbaUDQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated"><strong class="bd je">最佳拟合线</strong></figcaption></figure><p id="8437" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">太好了，我们现在知道线性回归算法是如何工作的了。</p><p id="7bc0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">总结算法:</strong> <br/> 1 .随机初始化M和C <br/> 2。使用M和c的这些值创建一条随机线。<br/> 3 .计算该行的误差(损失)。<br/> 4。使用误差项w.r.t. M和C的导数并分别从M和C中减去它，使用Alpha(学习率)来控制这种变化。<br/> 5。使用M和c的新值创建一条新线。重复第3步到第5步，直到误差最小。</p><p id="532d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">查看<a class="ae le" href="https://github.com/Modojojo/ML_ALGOS_from_scratch/blob/master/regression_univariate.ipynb" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> <em class="lf">代码</em> </strong> </a>用Python实现线性回归算法。</p></div></div>    
</body>
</html>