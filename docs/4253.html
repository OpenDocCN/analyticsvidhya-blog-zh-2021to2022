<html>
<head>
<title>What are *args and **kwargs? Let’s debug it…</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是*args和**kwargs？我们来调试一下…</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/what-are-args-and-kwargs-lets-debug-it-fe0b430ac36c?source=collection_archive---------11-----------------------#2021-09-12">https://medium.com/analytics-vidhya/what-are-args-and-kwargs-lets-debug-it-fe0b430ac36c?source=collection_archive---------11-----------------------#2021-09-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/711f726305ed461dc75480d9cf86c59b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bqRCmYtjlJL4D50nM3Bz-w.jpeg"/></div></div></figure><p id="8096" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我听很多人说，他们不明白什么时候用(单星)*，或者(双星)**。<code class="du jn jo jp jq b">*<strong class="ir hi">args</strong></code>和<code class="du jn jo jp jq b">**<strong class="ir hi">kwargs</strong></code>有什么用？难道每次都要用<code class="du jn jo jp jq b"><strong class="ir hi">args</strong></code><strong class="ir hi"/><code class="du jn jo jp jq b"><strong class="ir hi">kwargs</strong></code>就不能用别的名字吗？在我们继续我们的旅程之前，让我们先了解一下我们是否需要<code class="du jn jo jp jq b">*<strong class="ir hi">args</strong></code> <strong class="ir hi"> </strong>和<code class="du jn jo jp jq b"><strong class="ir hi">**kwargs</strong></code>。</p><blockquote class="jr"><p id="094b" class="js jt hh bd ju jv jw jx jy jz ka jm dx translated"><strong class="ak">需要是发明之母。</strong></p></blockquote><pre class="kb kc kd ke kf kg jq kh ki aw kj bi"><span id="5868" class="kk kl hh jq b fi km kn l ko kp">def addition(a, b):<br/>   return a+b</span></pre><p id="ec2d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个函数对于数字的相加是正确的，但是如果我们需要3个数字或者4个数字呢？我不知道，传递的参数数量只能在运行时确定。创建一个函数，不管传递给它的整数有多少，它都可以对所有整数求和，这不是很好吗？哇！！听起来很棒，图片中出现了<code class="du jn jo jp jq b"><strong class="ir hi">*args</strong></code>和<code class="du jn jo jp jq b"><strong class="ir hi">**kwargs</strong></code> <strong class="ir hi"> </strong>，稍等片刻我想我仍然可以不使用<code class="du jn jo jp jq b"><strong class="ir hi">*args</strong></code>和<code class="du jn jo jp jq b"><strong class="ir hi">**kwargs</strong></code> <strong class="ir hi">，</strong>我只是简单地将一个<strong class="ir hi">列表</strong>或一个<strong class="ir hi">集合</strong>中的所有参数传递给我的函数。所以对于<code class="du jn jo jp jq b">addition()</code>，我可以传递一个你需要添加的所有整数的列表:</p><pre class="kr ks kt ku fd kg jq kh ki aw kj bi"><span id="c3d2" class="kk kl hh jq b fi km kn l ko kp"># sum_integers_list.py<br/>def <!-- -->addition<!-- -->(numbers):<br/>    result = 0<br/>    for x in numbers:<br/>        result += x<br/>    return result<br/><br/>list_of_numbers = [1, 2, 3]<br/>print(<!-- -->addition<!-- -->(list_of_numbers))  #Output: 6</span></pre><p id="8362" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是的，这是一种实现方式，每当你需要调用函数时，你必须将<code class="du jn jo jp jq b">list</code>或<code class="du jn jo jp jq b">set</code>作为参数传递给函数。这可能不太方便，尤其是如果你事先不知道应该进入列表的所有值。<br/>这就是<strong class="ir hi"> *args </strong>发挥作用的地方，它真的很有用，因为它允许你传递不同数量的位置参数。拿下面这个例子:<br/> <strong class="ir hi">注意</strong>那个<code class="du jn jo jp jq b"><strong class="ir hi">args</strong></code> <strong class="ir hi"> <em class="kq">只是一个名字</em>。</strong>你不需要使用名称<code class="du jn jo jp jq b">args</code>。您可以选择任何您喜欢的名称，例如<code class="du jn jo jp jq b">numbers</code>:</p><pre class="kr ks kt ku fd kg jq kh ki aw kj bi"><span id="6355" class="kk kl hh jq b fi km kn l ko kp">def addition(*numbers):<br/>  results = 0<br/>  for each in numbers:<br/>    results += each<br/>  return results</span><span id="e914" class="kk kl hh jq b fi kv kn l ko kp">print(addition(1,2,3))  # Output: 6</span></pre><p id="abf5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这个方法非常好，你可以使用一个可迭代的对象作为一个整数。这里重要的是使用<strong class="ir hi">解包操作符</strong> ( <code class="du jn jo jp jq b"><strong class="ir hi">*</strong></code>)。<br/> <br/>传递给加法函数的参数存储在一个元组中。因此，我们可以迭代args变量。为什么<code class="du jn jo jp jq b">tuple</code>不是<code class="du jn jo jp jq b">list</code>？因为<code class="du jn jo jp jq b">tuple</code>比<code class="du jn jo jp jq b">list</code>使用更少的空间，<code class="du jn jo jp jq b">list</code>是<strong class="ir hi">可变的</strong>而<code class="du jn jo jp jq b">tuple</code>是<strong class="ir hi">不可变的，</strong>比<code class="du jn jo jp jq b">list</code>更快。</p><p id="599c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最好理解位置参数和关键字参数之间的区别。<br/>位置参数仅由名称声明。</p><ul class=""><li id="12f4" class="kw kx hh ir b is it iw ix ja ky je kz ji la jm lb lc ld le bi translated">位置参数仅由名称声明。</li><li id="d420" class="kw kx hh ir b is lf iw lg ja lh je li ji lj jm lb lc ld le bi translated">关键字参数由名称和默认值声明</li></ul><p id="9e88" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">调用函数时，必须给出位置参数的值。否则，我们会得到一个错误。</p><pre class="kr ks kt ku fd kg jq kh ki aw kj bi"><span id="4287" class="kk kl hh jq b fi km kn l ko kp">def fn (a, b, c = 1):          # a/b required, c optional.<br/>    return a * b + c<br/><br/>print fn (1, 2)                # returns 3, positional and default.<br/>print fn (1, 2, 3)             # returns 5, positional.<br/>print fn (c = 5, b = 2, a = 2) # returns 9, named.<br/>print fn (b = 2, a = 2)        # returns 5, named and default.<br/>print fn (5, c = 2, b = 1)     # returns 7, positional and named.<br/>print fn (8, b = 0)            # returns 1, positional, named and default.</span></pre><p id="42e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Python中，<strong class="ir hi"> <em class="kq">总是把关键字参数放在位置参数</em> </strong>之后。<br/> <code class="du jn jo jp jq b">arg_printer(a=4, 2, 4, 5)</code>它会给出一个错误<code class="du jn jo jp jq b">SyntaxError: positional argument follows keyword argument</code></p><p id="f2aa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，你已经明白了<code class="du jn jo jp jq b">*args</code>是干什么的，但是<code class="du jn jo jp jq b">**kwargs</code>呢？<br/>收集所有未明确定义的关键字参数，其工作方式与<code class="du jn jo jp jq b">args</code>类似，但接受关键字(或名为的<strong class="ir hi">参数)，因为它代表<strong class="ir hi">K</strong>ey<strong class="ir hi">W</strong>ord<strong class="ir hi">Arg</strong>ument<strong class="ir hi">s .</strong></strong></p><blockquote class="jr"><p id="4dd3" class="js jt hh bd ju jv jw jx jy jz ka jm dx translated">**kwargs允许函数接受任意数量的关键字参数。</p></blockquote><p id="6a11" class="pw-post-body-paragraph ip iq hh ir b is lk iu iv iw ll iy iz ja lm jc jd je ln jg jh ji lo jk jl jm ha bi translated">传递给<code class="du jn jo jp jq b">**kwargs</code>的参数存储在字典中。默认情况下，<code class="du jn jo jp jq b">**kwargs</code>是一个空字典。每个未定义的关键字参数作为键值对存储在<code class="du jn jo jp jq b">**kwargs</code>字典中。</p><pre class="kr ks kt ku fd kg jq kh ki aw kj bi"><span id="3e14" class="kk kl hh jq b fi km kn l ko kp">def concatenate(**kwargs):<br/>    result = ""<br/>    # Iterating over the Python kwargs dictionary<br/>    for arg in kwargs.values():<br/>        result += arg<br/>    return result<br/><br/>print(concatenate(a="Please", b="Like", c="And", d="Share", e="."))<br/>#Output: PleaseLikeAndShare.</span></pre><p id="b896" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您可以在<code class="du jn jo jp jq b">**kwargs</code>上执行所有可以在字典上执行的操作。</p><blockquote class="jr"><p id="54bd" class="js jt hh bd ju jv jw jx jy jz ka jm dx translated">我们可以在函数中同时使用*args和**kwargs，但是*args必须放在**kwargs之前。</p></blockquote><pre class="kb kc kd ke kf kg jq kh ki aw kj bi"><span id="fad6" class="kk kl hh jq b fi km kn l ko kp">def arg_printer(a, b, *args, **kwargs):<br/>   print(a, b)<br/>   print(args)<br/>   print(option)<br/>   print(kwargs)arg_printer(1, 4, 6, 5, param1=5, param2=6)</span><span id="45e3" class="kk kl hh jq b fi kv kn l ko kp"><strong class="jq hi">Output:</strong><br/>1 4<br/>(6, 5)<br/>True<br/>{'param1': 5, 'param2': 6}</span></pre><blockquote class="lp lq lr"><p id="ddd4" class="ip iq kq ir b is it iu iv iw ix iy iz ls jb jc jd lt jf jg jh lu jj jk jl jm ha bi translated">单星(*)用于解包任何可迭代对象，而双星(**)用于字典。</p></blockquote><p id="48e1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="kq">感谢阅读。如果您有任何反馈，请告诉我。<br/>快乐学习！！！</em>T48】</strong></p><p id="3062" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果这篇文章有帮助，请点击拍手👏按钮几下，以示你对作者的支持👇</p></div></div>    
</body>
</html>