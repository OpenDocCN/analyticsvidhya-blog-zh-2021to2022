<html>
<head>
<title>Build your own Resume Scanner Using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python构建自己的简历扫描仪</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/build-your-own-resume-scanner-using-python-b3de12a8199b?source=collection_archive---------6-----------------------#2021-05-26">https://medium.com/analytics-vidhya/build-your-own-resume-scanner-using-python-b3de12a8199b?source=collection_archive---------6-----------------------#2021-05-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/8623a1e4104adda72f06eb14b6bda027.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*EkFfMHwKM_1LFGSg.png"/></div></figure><p id="3974" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们想一个虚构的场景。你想换一份工作。你开始浏览求职门户。突然，一份工作描述引起了你的注意。它看起来非常合适！这个角色似乎是专为你而生的！很快，你上传了简历申请。你如此确信你会很快接到面试电话。但不幸的是，那个电话一直没有打来！想起来了吗？你也是这样吗？对我来说，这是“在那里做的”！(很多！)</p><p id="fcbc" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">嗯，找工作是一个复杂的过程。不同层次都有障碍。可悲的是，直到几天前我提交职位申请后立即给招聘人员打电话时，我才意识到为什么我没有接到第一个电话。她说，“<em class="jj">你的资料与这个角色有36%的匹配，我会给你回电话的！</em>“我不确定她在说什么！后来我知道，我们的简历甚至在送到招聘经理手里之前，甚至在被人看到之前，就已经被自动NLP程序扫描过了。于是我得知第一个障碍的名字是<a class="ae jk" href="https://en.wikipedia.org/wiki/Applicant_tracking_system" rel="noopener ugc nofollow" target="_blank"><strong class="in hi">【ATS】</strong></a>。</p><p id="78d2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我确信不同的公司使用不同复杂程度的简历扫描仪。我想要一个简单的——我自己的简历扫描仪。所以这篇文章是关于<strong class="in hi">创建你自己的简历扫描仪</strong>——一个查看你的简历与特定工作描述匹配程度的程序。</p><h2 id="704e" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">方法:</h2><p id="3f18" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">我想创建一个Python程序，它将返回简历和工作描述之间的匹配百分比。此外，我将使用职位描述创建一个单词云，这样我们就可以清楚地看到所有重要的关键字。</p><h2 id="1624" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">安装和导入库:</h2><p id="68f5" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">首先，我们将导入这个项目所需的所有库。</p><p id="e641" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，简历没有固定的文件格式，因此可以是任何文件格式，如。pdf或。所以我们的第一个挑战是阅读简历并将其转换为纯文本。为此，我们可以使用两个Python模块:<a class="ae jk" href="https://github.com/euske/pdfminer" rel="noopener ugc nofollow" target="_blank"> pdfminer </a>和<a class="ae jk" href="https://github.com/ankushshah89/python-docx2txt" rel="noopener ugc nofollow" target="_blank"> doc2text </a>。这些模块帮助提取文本from.pdf或。医生或者。docx文件格式。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="32cc" class="jl jm hh kq b fi ku kv l kw kx">pip install pdfminer <br/>pip install docx2txt</span></pre><p id="608c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们导入这个项目所需的所有库。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="5ceb" class="jl jm hh kq b fi ku kv l kw kx">import io <br/>from pdfminer.converter <br/>import TextConverter <br/>from pdfminer.pdfinterp <br/>import PDFPageInterpreter <br/>from pdfminer.pdfinterp <br/>import PDFResourceManager <br/>from pdfminer.pdfpage <br/>import PDFPage </span><span id="0d1a" class="jl jm hh kq b fi ky kv l kw kx">#Docx resume <br/>import docx2txt </span><span id="77a3" class="jl jm hh kq b fi ky kv l kw kx">#Wordcloud <br/>import re <br/>import operator <br/>from nltk.tokenize import word_tokenize <br/>from nltk.corpus <br/>import stopwords <br/>set(stopwords.words('english')) <br/>from wordcloud import WordCloud <br/>from nltk.probability import FreqDist <br/>import matplotlib.pyplot as plt </span><span id="9fd3" class="jl jm hh kq b fi ky kv l kw kx">from sklearn.feature_extraction.text import CountVectorizer <br/>from sklearn.metrics.pairwise import cosine_similarity</span></pre><h2 id="0cb8" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">阅读简历:</h2><p id="d76b" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">在这里，我将创建两个不同的函数。一个看pdf文件格式的简历。又一个要读的。doc格式。这两个函数都将返回简历中的文本。</p><p id="15b1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">阅读PDF简历:</strong></p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="60f2" class="jl jm hh kq b fi ku kv l kw kx">def read_pdf_resume(pdf_doc): <br/>    resource_manager = PDFResourceManager() <br/>    fake_file_handle = io.StringIO() <br/>    converter = TextConverter(resource_manager, fake_file_handle)     <br/>    page_interpreter = PDFPageInterpreter(resource_manager, <br/>                                          converter) <br/>    with open(pdf_doc, 'rb') as fh: <br/>        for page in PDFPage.get_pages(fh,  <br/>                            caching=True,check_extractable=True):   <br/>            page_interpreter.process_page(page)  <br/>            text = fake_file_handle.getvalue()  <br/>    # close open handles <br/>    converter.close() <br/>    fake_file_handle.close() </span><span id="52f0" class="jl jm hh kq b fi ky kv l kw kx">    if text: <br/>        return text</span></pre><p id="3ede" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">阅读word简历:</strong></p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="1dc3" class="jl jm hh kq b fi ku kv l kw kx">def read_word_resume(word_doc): <br/>    resume = docx2txt.process(word_doc) <br/>    resume = str(resume) <br/>    #print(resume) <br/>    text = ''.join(resume) <br/>    text = text.replace("\n", "") <br/>    if text: <br/>        return text</span></pre><h2 id="6786" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">用关键词创建单词云</h2><p id="981e" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">一个能显示职位描述中关键词的图形图像怎么样？我一直是单词云的忠实粉丝。如果你在浏览一份职位描述，你可能会错过一些该职位要求的技能。也许你在这些技能方面有一些经验，但却不记得把它们添加到你的简历中。因此，一个词云将闪现这些关键词以供快速查看。</p><p id="83d9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">清洁工作描述:</strong></p><p id="9474" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了创建一个单词云，我通常首先清理文本，以避免单词重复或标点符号或数字，因为这些在单词云中没有多大意义。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="7bf2" class="jl jm hh kq b fi ku kv l kw kx">def clean_job_decsription(jd): <br/>    ## Clean the Text <br/>    # Lower <br/>    clean_jd = jd.lower() <br/>    # remove punctuation <br/>    clean_jd = re.sub(r'[^\w\s]', '', clean_jd) <br/>    # remove trailing spaces <br/>    clean_jd = clean_jd.strip() <br/>    # remove numbers <br/>    clean_jd = re.sub('[0-9]+', '', clean_jd) <br/>    # tokenize clean_jd = word_tokenize(clean_jd) <br/>    # remove stop words <br/>    stop = stopwords.words('english') <br/>    clean_jd = [w for w in clean_jd if not w in stop]  <br/>    <br/>    return(clean_jd)</span></pre><p id="f1fe" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">造词云:</strong></p><p id="85ad" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，是时候创建图像了。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="636b" class="jl jm hh kq b fi ku kv l kw kx">def create_word_cloud(jd): <br/>    corpus = jd fdist = FreqDist(corpus)   <br/>    #print(fdist.most_common(100)) <br/>    words = ' '.join(corpus) <br/>    words = words.split() <br/>    # create a empty dictionary <br/>    data = dict() <br/>    <br/>    # Get frequency for each words where word is the key and the <br/>    #count is the value <br/>    for word in (words): <br/>        word = word.lower() <br/>        data[word] = data.get(word, 0) + 1 <br/>    <br/># Sort the dictionary in reverse order to print first the most used terms <br/>    dict(sorted(data.items(),<br/>                 key=operator.itemgetter(1),<br/>                 reverse=True)) <br/>    word_cloud = WordCloud(width = 800, height = 800,  <br/>                            background_color ='white',<br/>                            max_words = 500) <br/>    word_cloud.generate_from_frequencies(data) <br/>    # plot the WordCloud <br/>    image plt.figure(figsize = (10, 8), edgecolor = 'k')  <br/>    plt.imshow(word_cloud,interpolation = 'bilinear')   <br/>    plt.axis("off") plt.tight_layout(pad = 0) <br/>    plt.show()</span></pre><h2 id="7687" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">获取职位描述和简历匹配分数</h2><p id="45cb" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">现在，我们正处于项目的最后阶段。为了给简历与具体职位描述的匹配程度打分，我将使用一个<strong class="in hi"> <em class="jj">余弦相似度</em> </strong>指标。在数学上，它测量的是在多维空间中投影的两个向量之间的角度余弦。角度越小，余弦相似度越高。在这个上下文中，这两个向量是包含两个文档的单词的数组。</p><p id="ed3d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，一种常用的匹配相似文档的方法是基于计算文档之间的最大共同单词数。但是这种方法有一个问题。随着文档大小的增加，即使文档谈论不同的主题，常用词的数量也趋于增加。</p><p id="ad9e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">余弦相似性是有利的，因为即使两个相似的文档由于大小而相距欧几里德距离很远(例如，单词‘python’在一个文档中出现50次，在另一个文档中出现2次)，它们之间仍然可以有较小的角度。因此，角度越小，相似度越高。</p><p id="ffd9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">好，让我们创建一个函数来查找匹配分数！</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="6571" class="jl jm hh kq b fi ku kv l kw kx">def get_resume_score(text): <br/>    cv = CountVectorizer(stop_words='english') <br/>    count_matrix = cv.fit_transform(text) <br/>    #Print the similarity scores <br/>    print("\nSimilarity Scores:") <br/>    <br/>    #get the match percentage <br/>    matchPercentage = cosine_similarity(count_matrix)[0][1] * 100 <br/>    matchPercentage = round(matchPercentage, 2) # round off<br/>    <br/>    print("Your resume matches about "+ str(matchPercentage)+ "% of the job description.")</span></pre><h2 id="e2e2" class="jl jm hh bd jn jo jp jq jr js jt ju jv iw jw jx jy ja jz ka kb je kc kd ke kf bi translated">测试简历扫描仪:</h2><p id="f066" class="pw-post-body-paragraph il im hh in b io kg iq ir is kh iu iv iw ki iy iz ja kj jc jd je kk jg jh ji ha bi translated">终于到了拿分的时候了！我正在使用我的个人简历，并将它复制到同一个文件夹中，这样它就可以被这个程序读取。现在，让我从一个工作门户获取一份工作描述。我做了一份数据分析师的工作描述，让我们看看我的个人资料与这个特定角色有多匹配。</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="91f6" class="jl jm hh kq b fi ku kv l kw kx">What you'll do: <br/>The role involves partnering very closely with multiple PMs, Engineers, Test Managers and Business Partner to elevate the site experience for the verticals on Walmart. Analyze click stream data to understand how customers are interacting with the site. Uncover user pain points and help in building inspirational experiences. Provide and supports the implementation of product solutions Provide data driven insights and deliver recommendations that address opportunities for product improvements Provide analytical support to Product Managers Ensure accuracy of data capture strategy A/B Test: Test variations on messaging or features. Display dashboards: Visualize data with templated or custom reports. Create effective reporting and dashboards. Measure: Measure engagement by feature A self-starter: Can drive projects with minimal guidance Strong communicator: You effectively synthesize, visualize, and communicate your ideas to others </span><span id="03f5" class="jl jm hh kq b fi ky kv l kw kx"><strong class="kq hi"><br/>You'll sweep us off our feet if...</strong> <br/>You're able to use metrics to improve performance <br/>You're excited about solving complex challenges <br/>You're customer-centric in spirit and in execution <br/>You're comfortable influencing others, leading teams, managing stakeholders, and communicating clearly <br/>You have a test and learn mentality and an agile way of working to improve your product</span></pre><p id="c2cb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们运行上面创建的所有函数，并得到一个分数！</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="935e" class="jl jm hh kq b fi ku kv l kw kx">if <strong class="kq hi">name</strong> == '<strong class="kq hi">main</strong>': <br/>    extn = input("Enter File Extension: ") <br/>    #print(extn) <br/>    if extn == "pdf": <br/>        resume = read_pdf_resume('Resume_OindrilaSen.pdf') <br/>    else: <br/>        resume = read_word_resume('test_resume.docx') </span><span id="23c6" class="jl jm hh kq b fi ky kv l kw kx">    job_description = input("\nEnter the Job Description: ") <br/>    <br/>    ## Get a Keywords Cloud <br/>    clean_jd = clean_job_decsription(job_description) <br/>    create_word_cloud(clean_jd) <br/>    text = [resume, job_description] </span><span id="c089" class="jl jm hh kq b fi ky kv l kw kx">    ## Get a Match score <br/>    get_resume_score(text)</span></pre><p id="312e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我的天啊！</p><pre class="kl km kn ko fd kp kq kr ks aw kt bi"><span id="fd61" class="jl jm hh kq b fi ku kv l kw kx">Similarity Scores: Your resume matches about 26.82% of the job description.</span></pre><p id="a1e0" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">今天，我所有的猜测都有了答案。所以，今天的要点是，如果一份工作描述看起来很合适，我需要运行这个程序，检查我的简历。因此，简历扫描仪可以告诉你一个故事——一个真实的故事！</p><p id="c394" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我已经在我的<a class="ae jk" href="https://github.com/Oindrila-Sen/Python-Projects/tree/master/Resume_Scanner" rel="noopener ugc nofollow" target="_blank"> Github </a>中上传了我的Jupyter笔记本用于简历扫描程序。</p><p id="907e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">此外，如果你正在寻找一些其他项目的想法，看看我下面的项目:</p><p id="5497" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jk" href="https://oindrilasen.com/2021/02/generate-text-keras-lstm/" rel="noopener ugc nofollow" target="_blank">使用Keras LSTM生成文本的深度学习模型</a></p><p id="de84" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jk" href="https://oindrilasen.com/2020/12/multi-page-heroku-application/" rel="noopener ugc nofollow" target="_blank">在Heroku上构建和部署一个多页面Flask应用程序</a></p><p id="d60e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae jk" href="https://oindrilasen.com/2020/04/text-analytics-on-twitter-trends-using-tweepy/" rel="noopener ugc nofollow" target="_blank">使用Python对Twitter上的#冠状病毒趋势进行文本分析</a></p><p id="ea24" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">感谢您阅读这篇文章。希望对大家有帮助！如果你喜欢这篇文章，并发现它很有帮助，请留下一些掌声，以示感谢。</p><p id="4e52" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">谢谢大家！</p></div><div class="ab cl kz la go lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ha hb hc hd he"><p id="5c22" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="jj">原载于2021年5月26日https://oindrilasen.com</em><em class="jj"/><a class="ae jk" href="https://oindrilasen.com/2021/05/build-resume-scanner-using-python-nlp/" rel="noopener ugc nofollow" target="_blank"><em class="jj">。</em></a></p></div></div>    
</body>
</html>