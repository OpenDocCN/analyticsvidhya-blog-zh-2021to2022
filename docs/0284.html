<html>
<head>
<title>How to Improve Logistic Regression?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提高Logistic回归？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-improve-logistic-regression-b956e72f4492?source=collection_archive---------3-----------------------#2021-01-11">https://medium.com/analytics-vidhya/how-to-improve-logistic-regression-b956e72f4492?source=collection_archive---------3-----------------------#2021-01-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><h2 id="765a" class="hg hh hi bd b fp hj hk hl hm hn ho dx hp translated" aria-label="kicker paragraph">逻辑回归指南</h2><div class=""/><div class=""><h2 id="1d72" class="pw-subtitle-paragraph io hr hi bd b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf dx translated">第3节:用Python调优模型</h2></div><p id="0e22" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="kc">参考</em> <a class="ae kd" href="https://kopaljain95.medium.com/how-to-implement-logistic-regression-6f27ce4c45fd" rel="noopener"> <strong class="ji hs"> <em class="kc">如何实现Logistic回归？第2节:在继续… </em>之前，用Python  </strong> </a> <em class="kc">构建模型</em></p><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es ke"><img src="../Images/7a68943d4b894be225d243dca5dcb702.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAKh-ifQ4drGv0kD03_baA.png"/></div></div></figure><blockquote class="kq kr ks"><p id="b467" class="jg jh kc ji b jj jk is jl jm jn iv jo kt jq jr js ku ju jv jw kv jy jz ka kb hb bi translated"><strong class="ji hs"><em class="hi">【10】定义网格搜索参数</em> </strong></p></blockquote><pre class="kf kg kh ki fd kw kx ky kz aw la bi"><span id="ea1c" class="lb lc hi kx b fi ld le l lf lg">param_grid_lr = {<br/>    'max_iter': [20, 50, 100, 200, 500, 1000],                      <br/>    'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'],   <br/>    'class_weight': ['balanced']                                    <br/>}</span></pre><ul class=""><li id="96a1" class="lh li hi ji b jj jk jm jn jp lj jt lk jx ll kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">max_iter</code>为迭代次数。</li><li id="5a3e" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">solver</code>是用于优化的算法。</li><li id="61b9" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">class_weight</code>是排除不平衡数据采样的故障。</li></ul><p id="9c25" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> W </span> hy这一步:设置所选择的参数用来寻找最佳组合。通过引用<a class="ae kd" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html" rel="noopener ugc nofollow" target="_blank"> sklearn.linear_model。在LogisticRegression </a>文档中，您可以找到一个完整的参数列表，其中包含可用于网格搜索功能的描述。</p><blockquote class="kq kr ks"><p id="6de3" class="jg jh kc ji b jj jk is jl jm jn iv jo kt jq jr js ku ju jv jw kv jy jz ka kb hb bi translated"><strong class="ji hs"><em class="hi">【11】超参数调整使用训练数据</em> </strong></p></blockquote><pre class="kf kg kh ki fd kw kx ky kz aw la bi"><span id="2dd0" class="lb lc hi kx b fi ld le l lf lg">from sklearn.linear_model import LogisticRegression<br/>from sklearn.model_selection import GridSearchCV</span><span id="fd3d" class="lb lc hi kx b fi mh le l lf lg">logModel_grid = GridSearchCV(estimator=LogisticRegression(random_state=1234), param_grid=param_grid_lr, verbose=1, cv=10, n_jobs=-1)</span><span id="a05e" class="lb lc hi kx b fi mh le l lf lg">logModel_grid.fit(X_train, y_train)</span><span id="5bbd" class="lb lc hi kx b fi mh le l lf lg">print(logModel_grid.best_estimator_)</span><span id="86ea" class="lb lc hi kx b fi mh le l lf lg">...</span><span id="90e9" class="lb lc hi kx b fi mh le l lf lg"><em class="kc">Fitting 10 folds for each of 30 candidates, totalling 300 fits</em></span><span id="bd06" class="lb lc hi kx b fi mh le l lf lg"><em class="kc">LogisticRegression(C=1.0, class_weight='balanced', dual=False, fit_intercept=True, intercept_scaling=1, l1_ratio=None, max_iter=20, multi_class='warn', n_jobs=None, penalty='l2', random_state=1234, solver='newton-cg', tol=0.0001, verbose=0, warm_start=False)</em></span></pre><p id="adeb" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">注:由于<code class="du lq lr ls kx b">cv</code>被定义为10，有30个候选值，因此总拟合数为300(<code class="du lq lr ls kx b">max_iter</code>有6个定义参数，<code class="du lq lr ls kx b">solver</code>有5个定义参数，<code class="du lq lr ls kx b">class_weight</code>有1个定义参数)。因此，拟合总数的计算→ 10 x [6 x 5 x 1] = 300。</p><ul class=""><li id="7d5f" class="lh li hi ji b jj jk jm jn jp lj jt lk jx ll kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">estimator</code>是感兴趣的机器学习模型，假设该模型具有评分功能；在这种情况下，分配的模型是LogisticRegression()。</li><li id="12b0" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">random_state</code>是混洗数据时使用的伪随机数生成器的种子。为了避免模型数值评估输出中的差异，将种子设置为模型间比较的一致数字；在这种情况下，该数字设置为1234。</li><li id="3347" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">param_grid</code>是一个字典，以参数名(字符串)作为关键字，以参数设置列表作为值进行尝试；这使得能够搜索任何参数设置序列。</li><li id="9d47" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">verbose</code>是详细度:越高，消息越多；在这种情况下，它被设置为1。</li><li id="8329" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">cv</code>是交叉验证生成器还是iterable，本例中有10重交叉验证。</li><li id="a767" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><code class="du lq lr ls kx b">n_jobs</code>是并发运行的工人的最大数量；在这种情况下，它被设置为-1，这意味着使用了所有的CPU。</li></ul><p id="6fc5" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> W </span>为什么这一步:找到一个<strong class="ji hs">超参数</strong>的最佳组合，该组合最小化一个预定义的损失函数以给出更好的结果。</p><blockquote class="kq kr ks"><p id="9fca" class="jg jh kc ji b jj jk is jl jm jn iv jo kt jq jr js ku ju jv jw kv jy jz ka kb hb bi translated"><strong class="ji hs"><em class="hi">【12】对测试数据进行预测</em> </strong></p></blockquote><pre class="kf kg kh ki fd kw kx ky kz aw la bi"><span id="94d0" class="lb lc hi kx b fi ld le l lf lg">y_pred = logModel_grid.predict(X_test)</span><span id="5a49" class="lb lc hi kx b fi mh le l lf lg">print(y_pred)</span><span id="da21" class="lb lc hi kx b fi mh le l lf lg">...</span><span id="38ab" class="lb lc hi kx b fi mh le l lf lg"><em class="kc">[1 1 0 0 0 0 0 1 1 1 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 1 1 1 1 0 1 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 1 1 1 0 0 0 1 0 1 0 1 0 1 1 0 0 1 0 0 1 1 1 0 1 0 0 0 1 1 1 0 0 1 1 1 0 0 1 1 0 1 0 1 1 1 0 0 1 0 1 1 0 1 1 1 0 1 0 1 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 1 1 1 1 0 0 1 1 0 1 0 1 0 1 0 0 0 1 0 0 1 1 0 0 0 0 0 0 0 0 1 1 1 0 0 1 1 1 1 1 1 0 1 0 1 0 1 1 1 1 1 0 1 1 1 1 1 0 0 1 0 1 1 0 1 1 1 1 1 1 1 0 1 0 1 0]</em></span></pre><p id="0d1d" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> W </span>通过这一步:获得对测试数据的模型预测，以评估模型的准确性和效率。</p><blockquote class="kq kr ks"><p id="f935" class="jg jh kc ji b jj jk is jl jm jn iv jo kt jq jr js ku ju jv jw kv jy jz ka kb hb bi translated"><strong class="ji hs"><em class="hi">【13】数值分析</em> </strong></p></blockquote><pre class="kf kg kh ki fd kw kx ky kz aw la bi"><span id="5092" class="lb lc hi kx b fi ld le l lf lg">from sklearn.metrics import confusion_matrix<br/>print(confusion_matrix(y_test, y_pred), ": is the confusion matrix \n")</span><span id="7439" class="lb lc hi kx b fi mh le l lf lg">from sklearn.metrics import accuracy_score<br/>print(accuracy_score(y_test, y_pred), ": is the accuracy score")</span><span id="5d52" class="lb lc hi kx b fi mh le l lf lg">from sklearn.metrics import precision_score<br/>print(precision_score(y_test, y_pred), ": is the precision score")</span><span id="81c8" class="lb lc hi kx b fi mh le l lf lg">from sklearn.metrics import recall_score<br/>print(recall_score(y_test, y_pred), ": is the recall score")</span><span id="c39d" class="lb lc hi kx b fi mh le l lf lg">from sklearn.metrics import f1_score<br/>print(f1_score(y_test, y_pred), ": is the f1 score")</span><span id="a757" class="lb lc hi kx b fi mh le l lf lg">...</span><span id="1181" class="lb lc hi kx b fi mh le l lf lg"><em class="kc">[[85 21]<br/>[12 90]] : is the confusion matrix <br/><br/>0.8413461538461539 : is the accuracy score<br/>0.8108108108108109 : is the precision score<br/>0.8823529411764706 : is the recall score<br/>0.8450704225352113 : is the f1 score</em></span></pre><p id="11f2" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated">注意:使用混淆矩阵，可以提取真阳性、假阳性、假阴性和真阴性值，这将有助于计算准确度分数、精确度分数、回忆分数和f1分数:</p><ul class=""><li id="e2e9" class="lh li hi ji b jj jk jm jn jp lj jt lk jx ll kb lm ln lo lp bi translated"><strong class="ji hs">真阳性</strong> = 85</li><li id="3402" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><strong class="ji hs">假阳性</strong> = 21</li><li id="44da" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><strong class="ji hs">假阴性</strong> = 12</li><li id="38b8" class="lh li hi ji b jj lt jm lu jp lv jt lw jx lx kb lm ln lo lp bi translated"><strong class="ji hs">真阴性</strong> = 90</li></ul><figure class="kf kg kh ki fd kj er es paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="er es mi"><img src="../Images/26e4f1261eb17819c55ee2fbef5092cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rB5CecD6UPllcQhtdIx6Q.png"/></div></div><figcaption class="mj mk et er es ml mm bd b be z dx translated">准确度、精确度、召回率和F1的方程式。</figcaption></figure><p id="411e" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi ly translated"><span class="l lz ma mb bm mc md me mf mg di"> W </span>通过这一步:评估调优分类模型的性能。正如您所看到的，通过调整在<a class="ae kd" href="https://kopaljain95.medium.com/how-to-implement-logistic-regression-6f27ce4c45fd" rel="noopener">第2节</a>中创建的基本逻辑回归模型，准确度、精确度、召回率和F1分数都有所提高。</p></div><div class="ab cl mn mo gp mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hb hc hd he hf"><div class="kf kg kh ki fd mu"><a href="https://github.com/kopaljain95/import-data.science-classification/blob/main/LogisticRegression%5B1%5D/LogisticRegression.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab dw"><div class="mw ab mx cl cj my"><h2 class="bd hs fi z dy mz ea eb na ed ef hr bi translated">kopaljain 95/import-data . science-分类</h2><div class="nb l"><h3 class="bd b fi z dy mz ea eb na ed ef dx translated">在GitHub上创建一个帐户，为kopaljain 95/import-data . science-classification的开发做出贡献。</h3></div><div class="nc l"><p class="bd b fp z dy mz ea eb na ed ef dx translated">github.com</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni ko mu"/></div></div></a></div><p id="7cf3" class="pw-post-body-paragraph jg jh hi ji b jj jk is jl jm jn iv jo jp jq jr js jt ju jv jw jx jy jz ka kb hb bi translated"><em class="kc">接下来— </em> <a class="ae kd" href="https://kopaljain95.medium.com/why-use-logistic-regression-6cd17e09e6d0" rel="noopener"> <em class="kc">为什么要用逻辑回归？第4部分:评估模型权衡</em> </a> <em class="kc"> … </em></p></div></div>    
</body>
</html>