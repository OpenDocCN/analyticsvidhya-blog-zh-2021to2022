<html>
<head>
<title>Adding an auto-populating created_at column to a PostgreSQL table in Flask.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Flask中的PostgreSQL表添加自动填充的created_at列。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/adding-an-auto-populating-created-at-column-to-a-postgresql-table-in-flask-95848ecebe7a?source=collection_archive---------7-----------------------#2021-03-02">https://medium.com/analytics-vidhya/adding-an-auto-populating-created-at-column-to-a-postgresql-table-in-flask-95848ecebe7a?source=collection_archive---------7-----------------------#2021-03-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6470" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我最近接受了一个任务，向PostgreSQL数据库中的一个表添加一个<code class="du if ig ih ii b">created_at</code>列，这是一个用非常流行的Python语言Flask构建的项目。从后端的角度来看，在模型中包含时间戳是非常标准的，但是您可能没有意识到，在测试/播种的时候，自动填充列可能会受到限制。事实证明，以允许覆盖的函数方式实现可能有点棘手。</p><p id="087b" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">首先我们需要在模型文件的顶部导入<code class="du if ig ih ii b">datetime</code>:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jh"><img src="../Images/83364dabe0bf9c99b79c7a563f53726a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0qx5AsFWJdGnHNv_EUZuZg.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">从日期时间导入日期时间</figcaption></figure><p id="5aaa" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">接下来，我们将<code class="du if ig ih ii b">created_at</code>属性定义为类中的一列，并告诉它接受<code class="du if ig ih ii b">DateTime</code>作为数据类型。我们还将其设置为默认值<code class="du if ig ih ii b">datetime.utcnow</code>，这将是该方法被调用的当前时间:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jx"><img src="../Images/52a52a090d55186549e43f075190f272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wA39nqIkNmY1WNjQBsmmig.png"/></div></div></figure><p id="e3d3" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">这太棒了，在创建时，我们的对象现在将保存到数据库中，并带有一个自动填充的<code class="du if ig ih ii b">created_at</code>列，其中包含请求发出时的给定日期和时间！但是有一个问题，如果我们需要创建一个在过去或未来带有特定时间戳的对象来进行测试或播种，该怎么办呢？为了解决这个问题，我们可以添加<code class="du if ig ih ii b">created_at</code>作为类方法的可接受参数，<code class="du if ig ih ii b">__init__</code>(类的初始化方法，它将传入的参数连接到适当的属性)，并在方法内将属性设置为等于传入的参数，就像我们对所有其他属性所做的那样。</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jy"><img src="../Images/8b7742450f976b18fecccafb44530ace.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmyLJwfwcdwt9wKZ3qI9QA.png"/></div></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">别担心，无论如何最后都不会是<code class="du if ig ih ii b">None</code>:)</figcaption></figure><p id="4e12" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">现在我们可以手动设置<code class="du if ig ih ii b">created_at</code>值为我们想要的任何值！但是现在有一个新的问题，如果我们这样做，我们会失去我们首先需要的自动填充功能。不仅如此，现在当在参数中没有<code class="du if ig ih ii b">created_at</code>键/值对的情况下调用该方法时，该方法会完全中断，这并不理想。为了使它成为一个可选参数，我们在定义中将它设置为等于<code class="du if ig ih ii b">None</code>，就像我们对<code class="du if ig ih ii b">report_id</code>所做的那样，这允许我们使用或不使用该参数的键/值对进行初始化。在该方法中实现的条件检查我们是否传递了一个<code class="du if ig ih ii b">created_at</code>键/值对，如果是，则用传递的内容覆盖默认值:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es jz"><img src="../Images/35ad72df79febbe68bd417794b2e391e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RKLVr2kaUusPraF8H-ooCA.png"/></div></div></figure><p id="0abb" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我们最终得到的是用当时的日期时间自动填充<code class="du if ig ih ii b">created_at</code>的原始功能，以及为了测试或播种目的而传递特定日期时间的能力(如果我们愿意的话):</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es ka"><img src="../Images/c2bb7ffd4f4d2f3c81d7833c6dc1dec7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zzqOA7a0EmHK3hm5m8iARg.png"/></div></div></figure><p id="2685" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">我们可以看到两个种子(上面定义的)都成功地保存到了我们的数据库中(如下面的Postico所示)，第一个具有指定的<code class="du if ig ih ii b">created_at</code>值，另一个具有自动填充的<code class="du if ig ih ii b">created_at</code>值:</p><figure class="ji jj jk jl fd jm er es paragraph-image"><div role="button" tabindex="0" class="jn jo di jp bf jq"><div class="er es kb"><img src="../Images/cedad1b8df1d0003a6059837ffe04eee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kUFNMAl4ifeJN69-cccM_g.png"/></div></div></figure><p id="c76e" class="pw-post-body-paragraph ij ik hi il b im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg hb bi translated">* * *附录:对于<code class="du if ig ih ii b">updated_at</code>列，可以遵循相同的实现方式！</p></div></div>    
</body>
</html>