<html>
<head>
<title>How to Write Simple Tests for Data Science Programs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何为数据科学程序编写简单的测试</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/write-simple-tests-for-data-science-programs-632517abf192?source=collection_archive---------24-----------------------#2021-03-14">https://medium.com/analytics-vidhya/write-simple-tests-for-data-science-programs-632517abf192?source=collection_archive---------24-----------------------#2021-03-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/5da943bc9529ac72ae0da6163e1d97d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YQSDI7RuYpzinRvRmPSHw.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">照片由<a class="ae it" href="https://unsplash.com/@chrisliverani?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">克里斯·利维拉尼</a>在<a class="ae it" rel="noopener ugc nofollow" target="_blank" href="/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText"> Unsplash </a>上拍摄</figcaption></figure><h2 id="0f32" class="iu iv hh bd iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr bi translated">写测试很无聊</h2><p id="a04e" class="pw-post-body-paragraph js jt hh ju b jv jw jx jy jz ka kb kc jf kd ke kf jj kg kh ki jn kj kk kl km ha bi translated">或者看起来是这样，直到你掌握了窍门！在大量复杂的调试和复杂的建模之后，这通常是你最不想做的事情。</p><p id="04d2" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">快速搜索谷歌会告诉你，从长远来看，为你的代码编写测试真的会节省你的时间。嘿，理想情况下，你甚至会习惯于在编写程序时编写它们，并强迫自己创建更多的模块化代码。</p><p id="69fa" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">但是，如果你像我一样，当你试图为数据科学代码实际实现这些理论时，你经常会遇到绊脚石。所有的例子都是关于如何为一个数的平方函数编写代码，这与你的程序抓取一个网站、解析数据、预处理文本、构建一个稀疏矩阵、加载一个预先训练好的分类器等等相差甚远。等等。等等。</p><p id="7985" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">如果你一直在纠结这些问题，那么这篇文章就是为你准备的:</p><ul class=""><li id="1014" class="ks kt hh ju b jv kn jz ko jf ku jj kv jn kw km kx ky kz la bi translated">如果每次发送请求时网站都不一样，你应该如何测试抓取网站的功能？</li><li id="efc2" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">你应该如何测试一个在处理完数据后写入文件的函数——你不希望它覆盖你已经完成的工作吧！</li><li id="b2bd" class="ks kt hh ju b jv lb jz lc jf ld jj le jn lf km kx ky kz la bi translated">你应该如何测试一个因为速率限制而永远运行的API调用呢？</li></ul><p id="b8ab" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">Pytest是你的朋友</p><p id="f170" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">所以，从<code class="du lg lh li lj b">pip install pytest</code>开始吧。有很多方法可以用测试来设计应用程序，但是我发现一个简单的方法是这样的:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="d9fa" class="iu iv hh lj b fi ls lt l lu lv">project_name/<br/>│<br/>├── app/<br/>│   ├── __init__.py<br/>│   ├── program_file.py<br/>│<br/>├── tests/<br/>│   ├── tests.py<br/>│<br/>├── conftest.py</span></pre><p id="2c7f" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这样，在您的tests.py中，您可以通过放置像<code class="du lg lh li lj b">from app.program_file import my_function</code>这样的代码来导入您需要的所有文件，这使得事情变得相当简单。</p><p id="36ee" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">如果您将一个空的conftest.py文件放在主项目目录中，那么pytest就很容易找到测试文件的位置。要运行测试，你可以点击主项目目录中的<code class="du lg lh li lj b">python -m pytest tests/</code>，pytest将运行目录中的所有测试，不会问任何问题。</p><p id="5fc6" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">像这样构建您的项目也是非常可伸缩的——您可以在测试目录中添加额外的测试，如test_one.py或test_two.py，pytest将测试它们。您还将您的测试与主应用程序代码分离开来，这保持了整洁。</p><p id="abb6" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">嘲讽请求</strong></p><p id="b3ce" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">所以，你想测试一个从网站抓取数据的功能。这个其实挺简单的——<code class="du lg lh li lj b">pip install requests-mock</code>。然后你可以这样做:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="5418" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">如果你想要更多的上下文，这里的原始源代码是<a class="ae it" href="https://github.com/osintalex/alerts" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="bf13" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">但是通过将requests_mock传递给test_get_listing函数，您可以有效地防止该函数实际发出请求并提供您想要的输出。</p><p id="cbeb" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这里我指定requests.get返回的response.content对象将是<code class="du lg lh li lj b">b"data</code>，但是我也可以说通过在第15行添加<code class="du lg lh li lj b">text='test_data'</code>使response.text对象等于‘test _ data’。</p><p id="fde4" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">然后在assert中，我测试的函数返回response.content对象，所以我只是检查它等于什么。但是，如果您有一个解析响应数据的函数，您可以在这里将预期输出设置为等于函数实际返回的内容。</p><p id="559c" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这里的要点是，通过模仿requests.get方法，您可以完全控制它返回的数据，如果您将get请求发送到一个不断更新的网站，您就不会这样做。</p><p id="92e3" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">防止测试覆盖文件</strong></p><p id="bb39" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">假设您进行了多次api调用，每次获得数据后，您都将其作为json转储。作为一个题外话，这实际上非常有帮助，因为如果你试图为多个api调用调用<code class="du lg lh li lj b">json.dump</code>并不能很好地工作。</p><p id="db91" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">总之，一旦你完成了，你就可以把所有的json文件读入一个大熊猫数据帧，并把它写成csv或类似的格式。</p><p id="8b2b" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">好吧，如果你这样做，你可能不希望测试覆盖你的数据！因此，您可以通过将<code class="du lg lh li lj b">tmp_path</code>传递给测试函数来解决这个问题，如下例所示。</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="6fc1" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这可以防止您编写的测试函数接触您的主代码中的文件——在上面的示例中，在project_name/app/目录中。它实际上在tests目录中创建了一个临时目录，在那里它完成了所有这些工作。</p><p id="92b9" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">对于上下文，在我测试的方法中—alerts _ testing . check _ for _ updates()—有相当多的代码是这样做的:</p><pre class="lk ll lm ln fd lo lj lp lq aw lr bi"><span id="3e03" class="iu iv hh lj b fi ls lt l lu lv">with open('file_path', 'w') as f:<br/>    f.write(response_info)<br/>with open('old_file_path', 'r') as f:<br/>    if not response_info == old_info:<br/>        return response_info</span></pre><p id="8f09" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">所以我需要检查这个函数中的代码是否工作正常，但是我想在不写入文件的情况下保存应用程序源目录中的内容，这使得传递<code class="du lg lh li lj b">tmp_path</code>成为一个简单的修复！</p><p id="2633" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated"><strong class="ju hi">测试慢速API</strong></p><p id="fbdb" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这里有一篇关于如何做到这一点的很好的文章<a class="ae it" href="https://changhsinlee.com/pytest-mock/" rel="noopener ugc nofollow" target="_blank"/>会更深入一点，但是现在我将用这个非常简单的例子来结束。</p><p id="29d3" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">假设我在其他示例中使用的alerts程序进行了一次缓慢的API调用，我必须让函数每隔10m休眠一次，以避免用完我的配额。</p><p id="97bf" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">但是我想测试这个函数在完成所有调用后是否正确地解析了来自API的数据——这是我在以后调整代码时不想破坏的一点。</p><p id="652e" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">你可以通过这样的测试达到这样的效果:</p><figure class="lk ll lm ln fd ii"><div class="bz dy l di"><div class="lw lx l"/></div></figure><p id="c609" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">这有点复杂……这里发生的事情是，Alerts类中有一个方法— <code class="du lg lh li lj b">make_api_call()</code>,在这个测试文件中被实例化为<code class="du lg lh li lj b">alerts_testing</code>——它进行多个api调用，需要一段时间来运行。</p><p id="c4d0" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">为了进行这些调用，它调用Alerts类中的另一个方法<code class="du lg lh li lj b">api()</code>，然后解析返回的数据。</p><p id="c20f" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">因此，我们基本上想检查它是否解析了数据，而不需要进行api调用。为此，我们只需告诉pytest为<code class="du lg lh li lj b">api()</code>方法“打补丁”,使其返回我们想要的任何内容，在本例中，字典包含第4–7行的天气信息。</p><p id="14c9" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">现在测试不会进行API调用，我们可以指定这个<code class="du lg lh li lj b">api()</code>方法返回的数据，这意味着我们确切地知道如果正确解析数据的话<code class="du lg lh li lj b">make_api_call()</code>方法应该返回什么。因此，我们将其设置为expected，并检查它是否与该方法使用assert语句实际返回的内容相匹配。</p><p id="7d4a" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">我希望这有意义！如果没有，我建议您尝试一下，运行一个测试，看看pytest会给出什么样的错误。</p><p id="014c" class="pw-post-body-paragraph js jt hh ju b jv kn jx jy jz ko kb kc jf kp ke kf jj kq kh ki jn kr kk kl km ha bi translated">作为一个离别的想法，我经常发现仅仅写一个测试用例并看看它做什么要容易得多。即使它失败了，一旦它完全从你的头脑中消失了，你通常会更直接地知道下一步该做什么。</p></div></div>    
</body>
</html>