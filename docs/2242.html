<html>
<head>
<title>How to distinguish between gibberish and valid English text</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何区分乱码和有效的英文文本</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-distinguish-between-gibberish-and-valid-english-text-4975078c5688?source=collection_archive---------4-----------------------#2021-04-14">https://medium.com/analytics-vidhya/how-to-distinguish-between-gibberish-and-valid-english-text-4975078c5688?source=collection_archive---------4-----------------------#2021-04-14</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="e167" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">文本适配函数的世界</strong></p><p id="8ca6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在黑客电影的流行比喻中，有时需要解密一个加密的文本来挽救局面。主角在他们的电脑上做一些快速的恶作剧，然后弹出解密的文本；在最后一刻，及时拯救了世界。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es jd"><img src="../Images/e22db6ce7fe7359d3dec10f26b74fbcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*Nsb5M4gNYuwLRiSY.png"/></div></figure><p id="f8c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">认真对待这些想法是不明智的，因为电影和电视剧中展示的技术往往离题太远，可笑地不可行，而且过于戏剧化——但这将是另一个话题。</p><p id="5533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，如果你要写一个程序来解密一段加密的文本，你肯定需要知道你什么时候完成。更确切地说，计算机需要知道这一点！作为人类，我们可以从胡言乱语中自动解析合法的文本，但你如何将这些辨别能力转移给一个高速的低能儿(你的计算机)？</p><p id="3b0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我在YouTube上的Computerphile频道偶然发现这个优秀的视频时，这是一个多年来萦绕在我脑海中的疑问，它将我引入了文本健身功能的世界。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="jl jm l"/></div></figure><p id="e843" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据维基百科，适应度函数是一种特定类型的目标函数，作为一个单一的品质因数，用于总结给定设计解决方案与实现既定目标的接近程度。</p><p id="f236" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">具体地说，当应用于文本时，它总结了一段特定文本的统计特性与所考虑的语言中的相似文本的接近程度。这是一个完整的领域，但我想做的是向你们介绍我用Python复制的两个适应函数。</p><h1 id="7858" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">共现指数</h1><p id="47bc" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">来自<a class="ae kq" href="https://en.wikipedia.org/wiki/Index_of_coincidence" rel="noopener ugc nofollow" target="_blank">维基百科</a>:</p><blockquote class="kr ks kt"><p id="3a7c" class="if ig ku ih b ii ij ik il im in io ip kv ir is it kw iv iw ix kx iz ja jb jc hb bi translated">重合指数提供了通过从给定文本中随机选择两个字母来绘制两个匹配字母的可能性的度量。在文本中画出给定字母的几率是(该字母出现的次数/文本的长度)。再次绘制相同字母(没有替换)的机会是(外观-1/文本长度-1)。这两个值的乘积给了你连续画两次那个字母的机会。人们可以找到文本中出现的每个字母的乘积，然后将这些乘积相加，就有机会抽中两个相同的。这个概率可以通过乘以某个系数来标准化，在英语中通常是26。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ky"><img src="../Images/3e10fc2ed8f39e4ba028e7ad776df90b.png" data-original-src="https://miro.medium.com/v2/resize:fit:308/format:webp/1*mFH266TpBtEKjr2wI-G-qQ.png"/></div></figure><blockquote class="kr ks kt"><p id="b819" class="if ig ku ih b ii ij ik il im in io ip kv ir is it kw iv iw ix kx iz ja jb jc hb bi translated">其中N是文本的长度，n1到nc是字母表中c个字母的频率(作为整数)(对于单字符英语，c = 26)。ni的和必然是n。</p></blockquote><p id="f596" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">重点是英文文本的IoC是接近1.7 的<strong class="ih hj">，而随机文本的IoC应该是接近<strong class="ih hj"> 1 </strong>。</strong></p><p id="5b3a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第一步是获得一个随机文本和一些有效文本。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es kz"><img src="../Images/d05f942689f7db1160c76dc2f5f5b7c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rswFK_6Idaf9qGDZp2gBxQ.png"/></div></div></figure><p id="7bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">需要为分析准备文本。准备是指去掉所有标点符号、空格和特殊字符；并将所有内容设置为统一的大小写(这里选择小写)。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="72ad" class="lj jo hi lf b fi lk ll l lm ln"><strong class="lf hj">def</strong> prep_str(iptext):<br/>    iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>lower()<br/>    iptext<strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace(".","")<br/>    <strong class="lf hj">import</strong> string<br/><br/>    <strong class="lf hj">for</strong> punc <strong class="lf hj">in</strong> string<strong class="lf hj">.</strong>punctuation:<br/>        iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace(punc,"")<br/><br/>    iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace("’","")<br/>    iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace(" ","")<br/>    iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace("\n", "")<br/>    iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace("…","")<br/><br/>    <strong class="lf hj">for</strong> i <strong class="lf hj">in</strong> range(10):<br/>        iptext <strong class="lf hj">=</strong> iptext<strong class="lf hj">.</strong>replace(str(i), "")<br/>    <br/>    <strong class="lf hj">return</strong> iptext<br/></span></pre><p id="76a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了计算IoC，应使用上述帮助函数。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="3a44" class="lj jo hi lf b fi lk ll l lm ln">def calc_ioc(iptext):<br/>  ’’<a class="ae kq" href="https://en.wikipedia.org/wiki/Index_of_coincidence'''" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Index_of_coincidence'''</a><br/>  iptext = prep_str(iptext)<br/>  cnt = Counter(iptext)<br/>  sum = 0<br/>  N = len(iptext)<br/>  for x in cnt:<br/>    #print(f”{N} {cnt[x]}”)<br/>    sum = sum + cnt[x]*(cnt[x]-1)</span><span id="1b6e" class="lj jo hi lf b fi lo ll l lm ln"> return sum*26/(N*(N-1)), cnt</span></pre><p id="8ff5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">结果出来了，而且很有希望:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="22b9" class="lj jo hi lf b fi lk ll l lm ln">print(calc_ioc(randomtext)[0])<br/>print(calc_ioc(teststring)[0])</span><span id="49fd" class="lj jo hi lf b fi lo ll l lm ln"><strong class="lf hj">1.0002113411341134<br/>1.7642129827559332</strong></span></pre><p id="9d42" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这段代码可以清楚地区分乱码和英文文本。</p><h1 id="3921" class="jn jo hi bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated"><strong class="ak">四元图适应度计算</strong></h1><p id="ccfa" class="pw-post-body-paragraph if ig hi ih b ii kl ik il im km io ip iq kn is it iu ko iw ix iy kp ja jb jc hb bi translated">基于Google books在许可的情况下发布的n-Gram数据，我们可以计算任何n长字母序列的相对频率(以及概率)。如果n=4，则n元图称为四元图。</p><p id="ec7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">引用此<a class="ae kq" href="https://planetcalc.com/7959/" rel="noopener ugc nofollow" target="_blank">链接</a>:</p><blockquote class="kr ks kt"><p id="27d0" class="if ig ku ih b ii ij ik il im in io ip kv ir is it kw iv iw ix kx iz ja jb jc hb bi translated">有了这些频率，从技术上来说，我们可以估计在整个文本语料库中找到给定文本的概率(这是适合性度量的一个很好的候选)。比如让我们的文字是“提”字。它由以下四元图组成:MENT —实体— NTIO —实体。所以，</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lp"><img src="../Images/28a0df93a6a71ff1aa829ab75fa16c69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*Db8X7Ck9hQ0WZPjjbgl0Sw.png"/></div></figure><blockquote class="kr ks kt"><p id="b2ae" class="if ig ku ih b ii ij ik il im in io ip kv ir is it kw iv iw ix kx iz ja jb jc hb bi translated">然而，这里真正的问题是，概率非常小，所以这些的乘法运算很快就变成了更小的值，引入了舍入误差，并且不太有用。解决方案是已知的——应用对数函数。</p></blockquote><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lq"><img src="../Images/5c70ff4a5d4d53f2f10bcf8ff34294b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1266/format:webp/1*qtkhdGz9h0XQ4l3SrpNawg.png"/></div></figure><p id="86da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我在Github上找到一个数据文件，里面已经包含了四元图的log10概率，我把它读了进去。</p><p id="fe27" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">以下是该文件的内容:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lr"><img src="../Images/dace151383f2d0fded9d8834f2d5566e.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*4EVpHQxwigHWW1yELEQf_w.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">啊哦！这些是大写字母，需要处理...</figcaption></figure><p id="596e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，对数概率都是负的，因为概率总是在0和1之间，它的log10将是负的。</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="258a" class="lj jo hi lf b fi lk ll l lm ln"><strong class="lf hj">def</strong> quadgram_fitness(iptext):<br/>    a <strong class="lf hj">=</strong> prep_str(iptext)<br/>    quadtext <strong class="lf hj">=</strong> [a[idx:idx<strong class="lf hj">+</strong>4] <strong class="lf hj">for</strong> idx <strong class="lf hj">in</strong> range(len(a)<strong class="lf hj">-</strong>3)]<br/>    quaddict<strong class="lf hj">=</strong>{}<br/>    <strong class="lf hj">with</strong> open("quadgrams.txt") <strong class="lf hj">as</strong> f:<br/>        <strong class="lf hj">for</strong> line <strong class="lf hj">in</strong> f:<br/>            quaddict[line<strong class="lf hj">.</strong>split(",")[0]]<strong class="lf hj">=</strong> float(line<strong class="lf hj">.</strong>split(",")[1])<br/><br/>    sum <strong class="lf hj">=</strong> 0<br/>    <strong class="lf hj">for</strong> quad <strong class="lf hj">in</strong> quadtext:<br/>        sum <strong class="lf hj">+=</strong> (quaddict<strong class="lf hj">.</strong>get(quad<strong class="lf hj">.</strong>upper(),0))<br/>    <strong class="lf hj">return</strong> abs(sum)<strong class="lf hj">/</strong>len(quadtext)</span></pre><p id="5969" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的两个字符串上运行，我们得到:</p><pre class="je jf jg jh fd le lf lg lh aw li bi"><span id="7393" class="lj jo hi lf b fi lk ll l lm ln">print(quadgram_fitness(randomtext))<br/>print(quadgram_fitness(teststring)) <em class="ku">#larger the better, as this is the absolute value of the sum of the log likelihood</em></span><span id="012b" class="lj jo hi lf b fi lo ll l lm ln"><strong class="lf hj"><br/>0.5542850898467538<br/>3.7183183502414807</strong></span></pre><p id="e31f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">答对了。</p><p id="e6a1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不用说，还有更多的文本健身功能，你可以实现和发挥。根据使用案例，您还可以考虑对适应度函数进行适当加权，以使您的预测更加可信。</p><p id="69dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上述实验的代码是完全独立的，可从以下网址获得:</p><div class="lw lx ez fb ly lz"><a href="https://github.com/vaibhavgarg1982/MiscPythonTools/blob/main/text_fitness.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">vaibhavgarg 1982/MiscPythonTools</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在GitHub上创建一个帐户，为vaibhavgarg 1982/MiscPythonTools的开发做出贡献。</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">github.com</p></div></div><div class="mi l"><div class="mj l mk ml mm mi mn jj lz"/></div></div></a></div><p id="4abf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">四元图数据文件可从以下网址获得:</p><div class="lw lx ez fb ly lz"><a href="https://github.com/vaibhavgarg1982/MiscPythonTools/blob/main/quadgrams.txt" rel="noopener  ugc nofollow" target="_blank"><div class="ma ab dw"><div class="mb ab mc cl cj md"><h2 class="bd hj fi z dy me ea eb mf ed ef hh bi translated">vaibhavgarg 1982/MiscPythonTools</h2><div class="mg l"><h3 class="bd b fi z dy me ea eb mf ed ef dx translated">在GitHub上创建一个帐户，为vaibhavgarg 1982/MiscPythonTools的开发做出贡献。</h3></div><div class="mh l"><p class="bd b fp z dy me ea eb mf ed ef dx translated">github.com</p></div></div><div class="mi l"><div class="mo l mk ml mm mi mn jj lz"/></div></div></a></div></div></div>    
</body>
</html>