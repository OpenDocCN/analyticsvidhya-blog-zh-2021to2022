<html>
<head>
<title>Spark Bucketing is not as simple as it looks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">火花桶并不像看起来那么简单</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spark-bucketing-is-not-as-simple-as-it-looks-c74f105f4af0?source=collection_archive---------1-----------------------#2021-07-18">https://medium.com/analytics-vidhya/spark-bucketing-is-not-as-simple-as-it-looks-c74f105f4af0?source=collection_archive---------1-----------------------#2021-07-18</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5460c3412847e4ecb062db323f3e5489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B4jtsNvHzsm8GohF"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/@shawnanggg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> @shawnanggg </a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="3fdc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">分区和分桶是我们在Hive和Spark中最常用的优化技术。</p><p id="0fe2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客中，我将特别谈论木桶理论以及如何使用它。</p><p id="28e8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">仅当满足给定的情况时，分桶才起作用。我们将讨论这些以及如何最大限度地利用木桶理论。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0abd" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">什么是bucketing？</h1><p id="989e" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">在Spark和Hive中，桶是一种优化技术。我们提供了需要对数据进行分区的列。</p><p id="f710" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们需要确保满足分桶条件，以获得最大收益。当它被恰当地应用时，它将通过避免洗牌来改善连接，洗牌是Spark中的一个痛点。</p><h1 id="7f17" class="ka kb hi bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">Spark中bucket Tables的优势</h1><p id="f0ca" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">以下是Spark中存储(集群)的一些优点:</p><ul class=""><li id="00bd" class="li lj hi ix b iy iz jc jd jg lk jk ll jo lm js ln lo lp lq bi translated">我们可以根据给定的列对数据进行分区</li><li id="5e44" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">使用预混存储桶表时的优化连接。</li><li id="1d50" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">数据的均匀分布。</li><li id="3c32" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js ln lo lp lq bi translated">最佳访问和查询改进。</li></ul><h1 id="db70" class="ka kb hi bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">火花桶和蜂巢桶有什么不同</h1><p id="ead8" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">配置单元存储与火花存储不兼容。</p><p id="60a5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">Hive使用Hive散列函数创建桶，而Spark使用Murmur3。因此，当我们将Hive桶形表与Spark桶形表连接时，这里会有一个额外的交换和排序。</p><p id="2a66" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Hive中，它需要减少要创建的文件数量。</p><p id="1dd4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是在Spark bucketing中，我们没有缩减器，所以它最终会根据任务的数量创建N个文件。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lw"><img src="../Images/a83d2cd092d988bc2e419546bc44e411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b5qmzjxI5-JKhxiE115rpQ.png"/></div></div></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="d93e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们倾向于认为，当我们将存储桶的数量定义为1024时，文件的数量应该是1024。</p><p id="61b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但Spark却不是这样。</p><p id="ded6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在Spark中，向表中插入数据时关联的每个任务将乘以1024个桶。</p><p id="2156" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如在我们的例子中，</p><p id="ae8a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们有4个任务正在运行。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mb"><img src="../Images/d4e25b10cdcba7f7a9849b1414c020df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvQnkI_RhVGywK_uzbysbg.png"/></div></div></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mc"><img src="../Images/9f17a55602ad5332c7c7f8792b170423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vy59yzYeX4E8j_PtC_Fjyg.png"/></div></div></figure><p id="648c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">So 4(任务)* 1024(时段数)= 4099</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es md"><img src="../Images/6fac05e4b7ccc6a8947f2ef613973931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sfc9G2ciWDeAq7N9EpzQ2g.png"/></div></div></figure><p id="54ea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据上面的计算，它创建的文件数量是:~4096</p><p id="e8b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在spark中使用bucketing时，我们需要非常小心。</p><p id="a8a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果任务数量呈指数增长，最终可能会创建数百万个文件。</p><h1 id="5dc6" class="ka kb hi bd kc kd ld kf kg kh le kj kk kl lf kn ko kp lg kr ks kt lh kv kw kx bi translated">火花放电的限制</h1><p id="1cda" class="pw-post-body-paragraph iv iw hi ix b iy ky ja jb jc kz je jf jg la ji jj jk lb jm jn jo lc jq jr js hb bi translated">Spark分桶有其自身的局限性，当我们创建分桶表并将它们连接在一起时，我们需要非常小心。</p><p id="c4c4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为了优化连接并利用Spark中的分桶，我们需要确保以下几点:</p><ol class=""><li id="f1e4" class="li lj hi ix b iy iz jc jd jg lk jk ll jo lm js me lo lp lq bi translated"><strong class="ix hj">两张桌子都装了相同数量的桶。</strong>如果连接表中的桶号不同，则不会应用预洗牌。</li><li id="8778" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js me lo lp lq bi translated">为了连接，两个表被存储在同一列上。由于数据是基于给定的分桶列进行分区的，如果我们不使用相同的列进行连接，您就没有利用分桶，这会影响性能。</li></ol></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="5f72" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用分桶表和非分桶表的各种条件运行一些测试，看看Spark将如何表现和应用交换/洗牌的查询计划。</p><p id="0ae7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的目标是减少洗牌/交换，并使用预洗牌来加入牌桌。</p><p id="264d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试1:连接两个表，其中一个表被存储，另一个没有</strong></p><p id="9e7b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">薪水:<em class="mf">在ID上分桶</em>有1024个桶</p><p id="fcda" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default . salary _ temp:<em class="mf">非分桶</em>表</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/5e08a42d3a5e15239261bdeaefd8d6c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HuMdR4koiELSZREG9trs9A.png"/></div></div></figure><p id="e4e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们看一下查询计划。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mh"><img src="../Images/1a7468ab9ae3d454b056b40585f3c7b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jl2MoCipVhu4aCyo9Gojyw.png"/></div></div></figure><p id="d419" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可以清楚地看到，表中有一个未分桶的交换。现在，由于表的大小很小，它得到了广播。</p><p id="52a6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以确认Spark必须运行交换操作来连接分桶表和非分桶表。</p><p id="9073" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试2:用相同数量的桶连接bucked列上的两个bucked表</strong></p><p id="486f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_1:在Id列上分桶，有1024个桶</p><p id="6ab7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_2:在Id列上分时段，有1024个时段</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mi"><img src="../Images/5bf274b8f437ffadb04b7592cc7dbd2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GDSl_q5RgOF0a90uDOAblg.png"/></div></div></figure><p id="579d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里可以清楚地看到，没有交换，它应用了SortMergeJoin。在准备物理规划时，catalyst optimiser意识到这两个表都已经分区，不需要对数据进行混排。</p><p id="39cc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是最好的情况，也是我们的目标。</p><p id="5b6b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试3:在非分桶列上连接2个分桶表</strong></p><p id="339d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_1:按Id分桶，有1024个桶</p><p id="126d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_2:按Id分桶，有1024个桶</p><p id="bc02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mf">但是我们将把表与列</em><strong class="ix hj"><em class="mf">EmployeeName</em></strong><em class="mf">连接起来。</em></p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mj"><img src="../Images/8c8b5ca33fc602faae8bf8aa2f208013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64A93H-oO5ZIaSsbHTHVUw.png"/></div></div></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mk"><img src="../Images/98cb38010e1955144a28e9ccaa01b96c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-XT_0wFROY8c4jNm9qiTig.png"/></div></div></figure><p id="1731" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们可以清楚地看到，在表上应用了交换和广播散列连接。</p><p id="4e96" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管这些表在同一列上存储了相同数量的存储桶，但还是出现了混乱。因为连接列不同。</p><p id="a7b7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试4:连接具有不同桶数的两个表</strong></p><p id="9370" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_1:按Id分桶，有1024个桶</p><p id="f4fe" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries _ 3:按Id分时段，有1500个时段</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/886338632aa9d9dc1eb0e2863cdfbe37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*miQ3Udd6rBoFc8k00Th0eA.png"/></div></div></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/955f8a62093003ae616f5eabcf63cc02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mIy4taojNnvzHgY-RSWAHw.png"/></div></div></figure><p id="42a4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管这两个表是分桶的，并且在同一列上，但是还是有数据交换。</p><p id="d911" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当存储桶编号不同时，需要对其中一个存储桶表进行交换。</p><p id="bcf4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">测试5:联合分桶表，然后连接</strong></p><p id="2451" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_1:按Id分桶，有1024个桶</p><p id="158c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">default.salaries_2:按Id分桶，有1024个桶</p><p id="5b44" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这两个表都在Id列上分桶，并且具有相同的桶数。</p><p id="a579" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这里，我们将在加入之前运行UNION。</p><p id="a6d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">将薪金_1与薪金_2结合，然后与薪金_1结合。</p><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mn"><img src="../Images/610e2a2baec53d39710c1b6b97765f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4bXyb1JLCJXvLJ8HCRxv9Q.png"/></div></div></figure><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mo"><img src="../Images/8f39e5b175e90d62cf66a0dd226f1ff9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkcllBplKIKQGoFw2RoRFg.png"/></div></div></figure><p id="e104" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在应用union时，outputPartitioning和OutputOrdering将被设置为unknown，因为spark将在UNION之后和join之前引入交换。</p><p id="e65e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">尽管本例中涉及的表使用相同数量的桶存储在同一列上，但是Spark必须引入shuffle操作，因为存在UNION。</p><p id="fe69" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">经验教训:</strong></p><p id="7700" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">充分利用分桶表。</p><ol class=""><li id="6f4d" class="li lj hi ix b iy iz jc jd jg lk jk ll jo lm js me lo lp lq bi translated">让两张桌子都成桶形。</li><li id="57d9" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js me lo lp lq bi translated">两个表中的桶数应该相同。</li><li id="c0eb" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js me lo lp lq bi translated">两个表中的分桶列应该匹配。</li><li id="32ef" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js me lo lp lq bi translated">Spark存储桶与Hive存储桶不兼容，它会引入额外的排序。</li><li id="e4cf" class="li lj hi ix b iy lr jc ls jg lt jk lu jo lv js me lo lp lq bi translated">注意任务的数量，因为这会影响spark bucketing中创建的文件数量。</li></ol><p id="4e3b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇博客对你有所帮助，帮助你理解火花桶以及它是如何在引擎盖下工作的。同时如何有效地利用火花放电。</p><p id="a718" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在我的GitHub repo中找到上述代码的DBC文件:</p><div class="mp mq ez fb mr ms"><a href="https://github.com/ajithshetty/SparkBucketing" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hj fi z dy mx ea eb my ed ef hh bi translated">ajithshetty/SparkBucketing</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">在GitHub上创建一个帐户，为ajithshetty/SparkBucketing的发展做出贡献。</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng io ms"/></div></div></a></div><figure class="lx ly lz ma fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/cafaa16e6e5fedfff694b856271cb3c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OBh8wghv-73UXEZF.png"/></div></div></figure><p id="e2a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">阿吉特·库玛尔·谢蒂</strong></p><p id="e03b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">大数据工程师—热爱大数据、分析、云和基础设施。</p><p id="5f1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://ajithshetty28.medium.com/subscribe" rel="noopener">订阅</a> ✉️ || <a class="ae iu" href="https://ajithshetty28.medium.com/" rel="noopener">更多博客</a>📝|| <a class="ae iu" href="https://www.linkedin.com/in/ajshetty28" rel="noopener ugc nofollow" target="_blank">链接在</a>📊|| <a class="ae iu" href="https://ajithshetty.github.io/" rel="noopener ugc nofollow" target="_blank">个人资料页面</a>📚|| <a class="ae iu" href="https://github.com/ajithshetty/" rel="noopener ugc nofollow" target="_blank"> Git回购</a>👓</p><p id="8ea4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">订阅我的:</strong> <a class="ae iu" href="https://justenoughdata.substack.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">每周简讯刚好够数据</strong> </a></p></div></div>    
</body>
</html>