<html>
<head>
<title>Logistic Regression: Geometric Interpretation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归:几何解释</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-geometric-interpretation-80942d0286b6?source=collection_archive---------5-----------------------#2021-07-13">https://medium.com/analytics-vidhya/logistic-regression-geometric-interpretation-80942d0286b6?source=collection_archive---------5-----------------------#2021-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="60b8" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">一个强大模型的简单解释</h2></div><p id="9637" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">逻辑回归(LR) </strong>是用于解决分类问题的最流行的机器学习算法之一。我们可以通过<strong class="iy hi">基于几何、概率和损失函数的解释</strong>来理解逻辑回归。这三者将为我们提供相同的逻辑回归解决方案。本文将使用几何解释来理解逻辑回归，因为我相信它更直观、更容易理解。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/5eb2cdaf360ec4f4b8b7604b32559eb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1VByeJEtrpMyKxaDq7f2hA.jpeg"/></div></div></figure><p id="8422" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">逻辑回归只是一种分类技术，其任务是找到一个<strong class="iy hi">超平面(n维)或线(2维)</strong>来最好地分离类别。LR中的平面或超平面被称为决策面，因为它将类别分开。想象一下，给我们一组如下图所示的两个类，正点分别用‘x’表示，负点用‘o’表示。因此，任务是找到最好的线或平面，最好地将积极点与消极点分开。LR基于一个<strong class="iy hi">假设</strong>即类是完全或几乎完全线性可分的。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/f36024c94c145dd49aeb58893bc65658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fwGbBux0dQdC3Losb3TqLg.jpeg"/></div></div></figure><p id="101e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">y(类别标签)= +1:正点数，-1:负点数</p><p id="eefe" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">xᵢ ∈ Rᵈ</p><p id="f2b5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从平面的任何一点到xi的距离(𝜋): di=wTxi/||w||</p><p id="6130" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在整篇文章中，为了简单起见，我们假设w是一个单位向量||w|| =1。</p><p id="ed1d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，di= wTxi</p><p id="b11e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">当w和xi同向时，即wTxi &gt; 0，</strong></p><p id="5dee" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">那么y= +1 </strong></p><p id="6bb1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">同样，当w和xj指向相反方向时，即wTxj &lt; 0 </strong></p><p id="0b17" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">那么y = -1 </strong></p><p id="0df9" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">再次查看上面的图表，看是否有任何混淆</p><blockquote class="ke kf kg"><p id="a26b" class="iw ix kh iy b iz ja ii jb jc jd il je ki jg jh ji kj jk jl jm kk jo jp jq jr ha bi translated"><strong class="iy hi">基本上，与w同方向的每一点都是正点，反方向的每一点都是负点。这就是分类器的工作原理。</strong></p></blockquote><p id="22bc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">正如我们上面所讨论的，LR的任务是找到一个能最好地分离这两个类别的平面。但是你可能会问，我们如何找到那架飞机？</p><p id="66d8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为此，让我们先看一些案例:</p><h2 id="aa49" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">案例1: </strong></h2><p id="204c" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们被赋予真正的类标签yi=+1，即正的点</p><p id="9497" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">并且wTxi&gt;0，即分类器指示它是一个正点</p><p id="136b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后<strong class="iy hi"> yiwTxi &gt; 0 </strong>表示该平面正在正确分类该点。</p><h2 id="7279" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">案例二:</strong></h2><p id="b1b2" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们被给予真实的类标签yi=-1，即负的点</p><p id="0961" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">wTxi &lt;0 i.e. classifier indicating its a negative point</p><p id="acff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Then <strong class="iy hi"> yiwTxi &gt; 0 </strong>表示该平面正在正确分类该点。</p><h2 id="f9b0" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">案例三:</strong></h2><p id="5f39" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们被赋予真正的类标签yi=+1，即正的点</p><p id="1229" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">并且wTxi&lt;0，即分类器指示它是一个负点</p><p id="212a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后<strong class="iy hi"> yiwTxi &lt; 0 </strong>表示该平面没有正确分类该点。</p><h2 id="201e" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">案例四:</strong></h2><p id="f83f" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们被给予真实的类标签yi=-1，即负的点</p><p id="bc37" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">并且wTxi&gt;0，即分类器指示它是一个正点</p><p id="d34b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后<strong class="iy hi"> yiwTxi &lt; 0 </strong>这意味着飞机没有正确分类该点。</p><p id="7d3f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">查看这些案例，我们可以发现，当<strong class="iy hi"> yiwTxi &gt; 0，</strong>时，我们对点进行了正确分类，而当<strong class="iy hi"> yiwTxi &lt; 0 </strong>时，我们对点进行了错误分类。</p><p id="429c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了使分类器表现良好，我们需要最大化正确分类的点，最小化错误分类的点。简而言之，我们需要拥有尽可能多的点数才能拥有<strong class="iy hi"> yiwTxi &gt; 0。</strong></p><p id="17c3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这就是我们需要实现的，为了做到这一点，我们需要找到最优的w，这将解决这个最大化问题，因为y和x都是固定的。所以这是一个我们已经解决的数学问题，我们称之为<strong class="iy hi">‘最优化问题’。</strong></p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ll"><img src="../Images/4c2dda0437c96ee3189e78260eb13dc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*N9qn6RTOvd1D_Vo-afIV-w.jpeg"/></div></figure><p id="92f6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有几个超平面，对于每个平面，都有一个唯一的‘w’。因此，我们需要找到最佳的w，即最大值，w会给我们最好的平面，这就是我们的决策面。</p><h2 id="80d2" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated">此功能的问题</h2><p id="6b1c" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">到目前为止，我们所看到的是基本的优化问题，这将为我们找到最佳的w，即有助于分离正负点的最佳超平面。现在让我们看看与之相关的问题。</p><p id="3536" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们再来看看术语:<strong class="iy hi"> yiwTxi/||w||。</strong>该术语被称为<strong class="iy hi">符号距离。</strong>再次使用我们上面的假设，即<strong class="iy hi"> ||w|| =1，</strong>所以我们将只考虑<strong class="iy hi"> yiwTxi。</strong>我们知道<strong class="iy hi"> wTxi </strong>是从到平面的距离，yi不是+1就是-1。最大化带符号距离的总和不容易出现异常值，并且会受到异常值的影响。在某些情况下，即使是一个孤立点也会产生很大的影响，导致模型表现不佳。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/936406a217f726a70efa422f309f22ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lxspyoN3q6nzePvZ0wK6SA.jpeg"/></div></div></figure><p id="f168" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的示例中，我们看到对于π₁，我们有10个正确分类的点和一个错误分类的点，但是带符号距离的总和也是-80。(+1(*5) +1(*5)- 88(-1) ).谈到π₂，我们可以看到，它只正确地分类了6个点，但给出的带符号距离之和为1(1+1+2+3+4-1–2–3–4)。尽管π₁由于一个极端的异常值给出了更多正确分类的点，我们的优化问题说π₂更好。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es lm"><img src="../Images/a218abf6e04e98a198de20666ee52ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*CvdS37VVdMINFHHS5-nw_Q.jpeg"/></div></figure><p id="42b8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了处理这个问题，我们需要通过应用一种叫做<strong class="iy hi">挤压</strong>的技术来修改优化方程。挤压背后的想法是，如果一个点到平面的距离很小，那么我们就按原样使用它，但是如果距离很大，那么就把它转换成一个小值。</p><p id="fa28" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将通过对方程应用sigmoid函数来实现这一点，这将有助于我们处理异常值问题。它会将任意范围(-无穷大，+无穷大)内的有符号距离转换为[0，1]</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ln"><img src="../Images/24229e6f5945fa605e99075534f9a3ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VzACpsD1gZ_XpUzSBQGfNw.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图片来源:中</figcaption></figure><p id="f14d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">应用sigmoid函数后，我们的等式将如下所示:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ls"><img src="../Images/70d82a69dd8272de7509aafd55e9b296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cqXP1jGvwaZbUcAAlCx7cw.jpeg"/></div></div></figure><h2 id="3439" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated">但你一定想知道为什么sigmoid函数？原因是:</h2><ul class=""><li id="f3f4" class="lt lu hh iy b iz lg jc lh jf lv jj lw jn lx jr ly lz ma mb bi translated">它很容易微分。</li><li id="d7ca" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">它提供了一种概率解释。</li><li id="b965" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">当xi值较小时，它提供线性行为，而当xi值较大时，它提供锥形行为。</li></ul><p id="1782" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一点和第二点有助于解决优化问题。</p><p id="3787" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一个阈值为0.5的分类器</p><p id="462c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果sigmoid(wT.x)&gt;0.5，那么在这种情况下，类标签= 1。<br/>如果sigmoid(wT.x) &lt; 0.5，那么在这种情况下class label = 0。</p><p id="a920" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">点是否被正确分类取决于y*(wT.x) <br/>的符号如果y*(wT.x) = +ve，则该点被正确分类。<br/>若y*(wT.x) = -ve，则该点分类错误。</p><h2 id="a272" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">优化方程的进一步变换:</strong></h2><p id="e339" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们可以通过使用Log和其他一些数学性质来转换这个方程，以得到一个更简化的版本来解决优化问题。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mh"><img src="../Images/b9b379389cea23f5d0ccd960e8d614c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbxGXVK_R3QcAX_qXh4VgA.jpeg"/></div></div></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mi"><img src="../Images/cbd40688054a0cde36c5f34e419df8cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d_Rn3HZBg-br-fhBbzUGOA.jpeg"/></div></div></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mj"><img src="../Images/41bd6e9c1ecca9d517ae6f5f070f5bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cT9s5mk8KHbXu0-CWUrHvA.jpeg"/></div></div></figure><h2 id="9453" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated">问题又来了，<strong class="ak">为什么要日志？</strong></h2><ul class=""><li id="9cc9" class="lt lu hh iy b iz lg jc lh jf lv jj lw jn lx jr ly lz ma mb bi translated">Log函数是apt函数，因为它在控制有符号值的突然爆发时从0变化到无穷大。</li><li id="e01d" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">它还处理出现的数值计算问题，而不会实际影响优化的目标。</li><li id="cbe0" class="lt lu hh iy b iz mc jc md jf me jj mf jn mg jr ly lz ma mb bi translated">最后，我们将使用几何学获得的目标函数转换成与使用概率和损失最小化方法推导逻辑回归获得的相同的格式</li></ul><h2 id="32d2" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated">了解w</h2><p id="0291" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">我们试图通过最优化问题找到的最优w被称为‘权向量’。权重向量是一个d维向量，就像xi的一样。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mk"><img src="../Images/7dad117b90e248eed58d9dcb579a8ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:524/format:webp/1*b4JSdD6JpUmuYSK6Iro8sQ.png"/></div></figure><p id="c9d5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设我们有d个特征，我们有一个与之相关的权重。这就是为什么它被称为权重向量。让我们举一个例子，给我们一个特征‘I ’,它的权重为wi。</p><h2 id="0d72" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">情况1:wi为+ve时:</strong></h2><p id="3d03" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">wi乘以xqi(给定数据点)wi*xqi</p><p id="bed2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">所以当xqi增加时(这里xqi增加意味着远离超平面)</p><p id="d215" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">wi.xqi增加，σwi . xqi(LR中的决策表面)</p><p id="40e5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">σ(wi.xqi)增加</p><p id="5cd7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">P(yq = +1)增加</p><h2 id="474f" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated"><strong class="ak">情况二:</strong>当wi为-ve时:</h2><p id="555f" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">所以当xqi增加且wi为-ve时，</p><p id="077e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">wi.xqi减小，σwi . xqi也减小</p><p id="b6ea" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">σ(wi.xqi)降低</p><p id="804e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">P(yq = +1)下降</p><p id="c4f3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">P(yq = -1)增加</p><h2 id="43d9" class="kl km hh bd kn ko kp kq kr ks kt ku kv jf kw kx ky jj kz la lb jn lc ld le lf bi translated">这个优化问题的问题——过拟合和欠拟合，这引入了正则化</h2><p id="cd10" class="pw-post-body-paragraph iw ix hh iy b iz lg ii jb jc lh il je jf li jh ji jj lj jl jm jn lk jp jq jr ha bi translated">让我们再次看看我们得到的最终优化问题:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es ml"><img src="../Images/0a0c41bba6d158b15a87f4be2a079daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*xNQGdBOIOliab14PHKF7Lg.png"/></div></figure><p id="f60a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让zᵢ = yᵢ wᵀ xᵢ</p><p id="f499" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">exp(-zi)将始终为正，因为exp(-xi)始终为正，如下所示:</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mm"><img src="../Images/8bab98f3b52f2e8e8189cdbd416ac9a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bAHub1PO_sZ6oEZENnwzmQ.jpeg"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图片来源:谷歌</figcaption></figure><p id="3519" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">σlog(1+exp(-zᵢ))≥0</p><p id="9b01" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，当zi为所有I的+无穷大时，σlog(1+exp(-zᵢ)的最小值将为0。当zi = + <strong class="iy hi"> ∞ </strong>，exp(-zi) = 0时</p><p id="4b6a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">同样，当zi = + <strong class="iy hi"> ∞ </strong>时，所有点将被正确分类为zᵢ = yᵢ wᵀ xᵢ，而当yᵢ wᵀ xᵢ &gt;为0时，该点被正确分类。</p><p id="91ff" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">看上面的等式，为了得到这个，我们需要以这样的方式最小化w，使得zi是+无穷大，并且所有的点都被正确分类。这将是我们最好的w。</p><p id="2427" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">但是有一个问题，如果我们以一种方式</strong>选择w，使得zi是+无穷大，并且所有的点都被正确分类，这将导致<strong class="iy hi">过拟合</strong>。过度拟合基本上是在训练数据上做得很好，但在测试数据上却没有。让我们通过一幅图像来看看过度拟合、欠拟合和最佳拟合(在现实世界中很难看到):</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es mn"><img src="../Images/1df7a0f7c3b6875a099e0050cf6cfc0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cdvfzvpkJkUudDEryFtCnA.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图片来源:<a class="ae mo" href="https://machinelearningmedium.com/2017/09/08/overfitting-and-regularization/" rel="noopener ugc nofollow">https://machine learning medium . com/2017/09/08/over fitting-and-regulatory/</a></figcaption></figure><p id="2fcc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">解决这个问题的方法来了，即<strong class="iy hi">正则化</strong>，这将有助于防止过拟合和欠拟合。我们将使用它来修改优化问题，并找到最佳的w。有不同类型的正则化，他们都有相同的目标，但让我们看看L2正则化在这里。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mp"><img src="../Images/a2e0b8f98deee2d7e49fed9712e4f1c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*bu8vvfJOOy5pQxgdlbLLgA.png"/></div></figure><p id="e830" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">arg min(w)(σI = 1到n log(1 + exp(-yiwTxi)))是损失项</p><p id="7808" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">λ W^T W是正则化项</p><p id="3203" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这被称为l2正则化，因为我们使用W的L2范数来正则化</p><p id="3c8e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里λ是一个超参数，我们可以修改它。</p><p id="b2d4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，基本上我们的目标是找到最佳的λ和W，使损失更少，但不是非常接近于零，因为如果它等于零，那么，我们的模型可能会过拟合。同样，如果λ非常高，那么我们的模型会欠拟合。这就是<strong class="iy hi">偏差-方差权衡。</strong></p><p id="8275" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简而言之，正则项是避免w为+无穷大或-无穷大。</p><blockquote class="ke kf kg"><p id="c71e" class="iw ix kh iy b iz ja ii jb jc jd il je ki jg jh ji kj jk jl jm kk jo jp jq jr ha bi translated"><strong class="iy hi">平衡至关重要:无论是机器学习还是生活</strong></p></blockquote><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es mq"><img src="../Images/c580caa1b2f46166961932d8fec165b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*ZYzjMt8vTN7npc_4PWkerA.jpeg"/></div><figcaption class="lo lp et er es lq lr bd b be z dx translated">图片来源:<a class="ae mo" href="https://realwealth.com/work-life-balance-quotes/" rel="noopener ugc nofollow" target="_blank">https://realwealth.com/work-life-balance-quotes/</a></figcaption></figure><p id="0f43" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">损失项&amp;正则化之间发生<strong class="iy hi">拔河</strong>避免zi走向正负无穷大。最终，它们会遇到一个损失项和正则项都很小的最佳点。</p><blockquote class="ke kf kg"><p id="7709" class="iw ix kh iy b iz ja ii jb jc jd il je ki jg jh ji kj jk jl jm kk jo jp jq jr ha bi translated">在一天结束的时候<strong class="iy hi">机器学习都是关于最小化损失函数+调整</strong></p></blockquote><p id="2eb4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">恭喜你，现在你已经用几何解释理解了逻辑回归的概念。</p></div></div>    
</body>
</html>