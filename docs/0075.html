<html>
<head>
<title>Find a Celebrity Doppelganger Using Dlib</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Dlib查找名人重身幽灵</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/find-a-celebrity-doppelganger-using-dlib-fad59bab6431?source=collection_archive---------18-----------------------#2021-01-03">https://medium.com/analytics-vidhya/find-a-celebrity-doppelganger-using-dlib-fad59bab6431?source=collection_archive---------18-----------------------#2021-01-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/e69d993823dfe228491d5dccb6e28530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oBivPFeuY_ba81iGek4HDA.png"/></div></div></figure><p id="3347" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个项目中，我们将研究一种识别名人二重身的方法。如果你是一个受欢迎的博客作者，并且你想为你的最新博客列出一个喜欢其他名人的名人列表，那么在谷歌中搜索每一张图片来填满一个列表可能会非常乏味。在这个应用程序的帮助下，你不仅可以快速列出名人的名单，还可以评估每个人与另一个人的匹配度。</p><p id="c4c2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">基本概念:</strong></p><p id="c5f1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个项目中，我们不会训练一个新的模型，而是使用Dlib的基于RESNET的人脸识别模型来注册新的名人图像。该模型将把新图像转换成128*1的向量。然后，我们将对测试图像进行类似的处理，并将其转换为128*1矢量。最后，我们将计算登记图像和测试图像的向量之间的欧几里德范数。当测试和注册图像之间的距离小于预设阈值时，我们将认为它是匹配的！</p><p id="756c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">映射文件中的地图标签与文件夹中的对应图像:</strong></p><p id="81c8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">由于已经提供了一个celeb_mapping.npy文件，我们只需浏览该文件，并将名人姓名与训练数据集中的相应文件夹进行映射。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es jn"><img src="../Images/9134003148c9f9acf0a55753fa5282bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tu2DVmn0-crqtwneZj3iDQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">从标签到文件夹名称的映射</figcaption></figure><p id="12e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">该操作的代码片段如下</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="0013" class="kb kc hh jx b fi kd ke l kf kg"># In this step we create list of sub folders and store a dictionary with labels and respective<br/># image folders mapped to it</span><span id="348f" class="kb kc hh jx b fi kh ke l kf kg">subfolders = []<br/>imagePaths = []<br/>labels = []<br/>nameLabelMap = {}</span><span id="dfdb" class="kb kc hh jx b fi kh ke l kf kg">for item in labelMap: # For each subfolder in labelMap<br/>    celeb_folder_path = os.path.join(faceDatasetFolder, item) </span><span id="4879" class="kb kc hh jx b fi kh ke l kf kg">    if os.path.isdir(celeb_folder_path): # allow for valid folder</span><span id="062f" class="kb kc hh jx b fi kh ke l kf kg">        for img in os.listdir(celeb_folder_path): <br/>           if (img.endswith('JPEG') or img.endswith('jpg')):<br/>                img_path = os.path.join(celeb_folder_path,img)</span><span id="3846" class="kb kc hh jx b fi kh ke l kf kg">                imagePaths.append(img_path) # attaching image paths</span><span id="0d41" class="kb kc hh jx b fi kh ke l kf kg">                labels.append(labelMap[item]) # inserting labels</span><span id="4400" class="kb kc hh jx b fi kh ke l kf kg">                nameLabelMap[img_path] = labelMap[item] </span></pre><p id="68bc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注册图像:</strong></p><p id="4554" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这一步中，我们将名人图像注册到dlib人脸识别模型中。我们必须遍历包含5张图像的每个文件夹，并执行地标检测，然后进行人脸识别。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="6297" class="kb kc hh jx b fi kd ke l kf kg"># facial landmarks detection<br/>shape = shapePredictor(cv2.cvtColor(temp_img, cv2.COLOR_BGR2RGB), face)</span><span id="db5f" class="kb kc hh jx b fi kh ke l kf kg"># convert Dlib's format to list of (x, y) points<br/>landmark_points = [(p.x, p.y) for p in shape.parts()]</span><span id="660b" class="kb kc hh jx b fi kh ke l kf kg"># NN based face descriptor from Dlib<br/>faceDescriptorPts = faceRecognizer.compute_face_descriptor(temp_img, shape)</span></pre><p id="c0cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后，我们从Dlib格式转换为list，然后转换为大小为128*1的numpy数组。对所有图像都这样做。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="4a80" class="kb kc hh jx b fi kd ke l kf kg"># Convert to a NumPy array<br/>faceDescriptorList = [x for x in faceDescriptorPts]</span><span id="3ec8" class="kb kc hh jx b fi kh ke l kf kg">faceDescriptorNdarray = np.asarray(faceDescriptorList, dtype=np.float64)</span><span id="2cdb" class="kb kc hh jx b fi kh ke l kf kg">faceDescriptorNdarray = faceDescriptorNdarray[np.newaxis, :]</span><span id="7e26" class="kb kc hh jx b fi kh ke l kf kg"># 1x128D Vectors <br/>if faceDescriptorsArray is None:<br/>   faceDescriptorsArray = faceDescriptorNdarray<br/>else:<br/>   faceDescriptorsArray = np.concatenate((faceDescriptorsArray, faceDescriptorNdarray), axis=0)</span></pre><p id="fd77" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后，我们必须将每个图像的标签及其相应的索引保存在一个单独的列表中，该列表将在测试阶段使用</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="5b49" class="kb kc hh jx b fi kd ke l kf kg">index[i] = valueLabelMap[imagePath]<br/>i += 1</span></pre><p id="e3c5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">保存面部描述符和索引内容</strong></p><p id="eb0f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用numpy保存和pickle函数保存faceDescriptor列表和索引列表，供以后重用。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="2636" class="kb kc hh jx b fi kd ke l kf kg">np.save('descriptors.npy', faceDescriptors)<br/>with open('index.pkl', 'wb') as f:<br/>  cPickle.dump(index, f)</span></pre><p id="8434" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">测试模型:</strong></p><p id="9959" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们重新加载索引和描述符列表，并设置阈值。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="2359" class="kb kc hh jx b fi kd ke l kf kg">THRESHOLD = 0.57# load descriptors and indices file <br/>index = np.load('index.pkl', allow_pickle=True)<br/>faceDescriptorsEnrolled = np.load('descriptors.npy')</span></pre><p id="66d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将阈值设置为0.57，这是通过实验确定的最佳结果。</p><p id="ecf4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们加载测试图像，并执行面部标志检测和后续面部识别的类似操作。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="bc63" class="kb kc hh jx b fi kd ke l kf kg">for face in faces:<br/>  shape = shapePredictor(cv2.cvtColor(im, cv2.COLOR_BGR2RGB), face)</span><span id="aed4" class="kb kc hh jx b fi kh ke l kf kg">  faceDescriptor = faceRecognizer.compute_face_descriptor(im, shape)</span><span id="dc8b" class="kb kc hh jx b fi kh ke l kf kg">  faceDescriptorList = [m for m in faceDescriptor]</span><span id="db0f" class="kb kc hh jx b fi kh ke l kf kg">  faceDescriptorNdarray = np.asarray(faceDescriptorList, dtype=np.float64)</span><span id="baf3" class="kb kc hh jx b fi kh ke l kf kg">  faceDescriptorNdarray = faceDescriptorNdarray[np.newaxis, :]</span></pre><p id="fc21" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">之后，我们计算所有注册图像的面部描述符列表和测试图像之间的欧几里德范数，并找到最小距离。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="4537" class="kb kc hh jx b fi kd ke l kf kg">distances = np.linalg.norm(faceDescriptorsEnrolled - faceDescriptorNdarray, axis=1)</span><span id="cc09" class="kb kc hh jx b fi kh ke l kf kg">argmin = np.argmin(distances)  # index<br/>minDistance = distances[argmin]  # minimum distance</span></pre><p id="0108" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">然后我们检查最小图像是否低于阈值。如果通过，我们从索引列表中读取相应的索引，并将其分配给名人图像。</p><pre class="jo jp jq jr fd jw jx jy jz aw ka bi"><span id="bad8" class="kb kc hh jx b fi kd ke l kf kg">if minDistance &lt;= THRESHOLD:<br/>  label = index[argmin]<br/>  print("Identified label :{} ".format(label))<br/>else:<br/>  label = 'unknown'</span></pre><p id="d04c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">结果:</strong></p><p id="02ea" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用该算法获得了以下结果。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ki"><img src="../Images/0687ec935f3bbdd3b635dd0ab1de3654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIoYMnnmjtNLbpflVfEsDg.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">阿米特巴·巴强长相酷似</figcaption></figure><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kj"><img src="../Images/7571551d83cef8b0327d4c72cfeb6483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CuM65GZSIMm2nXD2EC344w.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">安吉丽娜·朱莉长相酷似</figcaption></figure><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es kk"><img src="../Images/7f1b28d9c5557267341d9045f5949381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*I20C1nuzbam-5CFocpMrVg.png"/></div><figcaption class="js jt et er es ju jv bd b be z dx translated">赛琳娜·戈麦斯长相酷似</figcaption></figure><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kl"><img src="../Images/92e6a25124812473b2bc418f117ff33e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iUkVFDSo4vSsSl06Phm-mQ.png"/></div></div><figcaption class="js jt et er es ju jv bd b be z dx translated">鲍勃·萨吉特长相酷似</figcaption></figure></div></div>    
</body>
</html>