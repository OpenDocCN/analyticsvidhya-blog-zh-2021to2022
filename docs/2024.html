<html>
<head>
<title>Apache Sqoop - One smart tool for Big Data World.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Apache Sqoop -大数据世界的智能工具。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/apache-sqoop-one-smart-tool-for-big-data-world-3dd0f029da77?source=collection_archive---------7-----------------------#2021-04-01">https://medium.com/analytics-vidhya/apache-sqoop-one-smart-tool-for-big-data-world-3dd0f029da77?source=collection_archive---------7-----------------------#2021-04-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7dd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di"> W </span>当我们谈论大数据世界时，总会涉及三个方面，它们是存储、处理&amp;可扩展性。在这里，我们总是喜欢存储大量的数据，在给定的时间内高效地处理它&amp;高于所有高度可扩展的设计系统。数据摄取是任何大数据项目的初始阶段，也是最有趣的阶段。在这种快速变化的大数据工具技术中，我仍然喜欢并考虑Apache Sqoop，因为它非常适合结构化数据的数据摄取。因此，让我们开始看看它是什么，并花一天时间使用这个工具。</p><p id="4264" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1。什么是Apache Sqoop？</strong></p><p id="eae8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Apache -sqoop是一个工具，用于将大量数据从关系数据库(RDBMS)导入到HDFS，并将数据从HDFS导出到RDBMS。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es jl"><img src="../Images/1265c6c50161d5ce9962967b13a06754.png" data-original-src="https://miro.medium.com/v2/resize:fit:1324/format:webp/1*QMr3-iE3mSoBihPisrObQA.jpeg"/></div></figure><p id="63b6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将主要关注以下内容。</p><ul class=""><li id="327f" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">满载</li><li id="40ab" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">增量负载</li><li id="2eca" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">边界查询，拆分依据</li><li id="f267" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">压缩</li><li id="256b" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">安全集成</li></ul><p id="22e4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2。一些基本的Sqoop命令。</strong></p><p id="aa55" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在开始任何事情之前，让我们试着理解一下Sqoop中的一些基本命令。</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="9167" class="km kn hh ki b fi ko kp l kq kr">sqoop-list-databases \<br/>--connect "jdbc:mysql://localhost:3306" \<br/>--username root \<br/>--password cloudera</span></pre><p id="3ca8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面将列出特定MySQL用户的所有数据库，即这里的<code class="du ks kt ku ki b">root</code>。<br/>这里的<code class="du ks kt ku ki b">3306</code>是我为我的MySQL数据库提供服务的端口，<code class="du ks kt ku ki b">root</code>是带有密码的用户名<code class="du ks kt ku ki b">cloudera</code>。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/3e54a540da5f5ecba4bb792a814298f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o8RkoD2laxz7P2KeXVPvFw.png"/></div></div></figure><p id="8652" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们尝试列出特定数据库的所有表。</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="a698" class="km kn hh ki b fi ko kp l kq kr">sqoop-list-tables \<br/>--connect "jdbc:mysql://localhost:3306/retail_db" \<br/>--username root \<br/>--password cloudera</span></pre><p id="2259" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我先展示一下输出再解释。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es la"><img src="../Images/bb8ca63b7c6f2890fcf0fa1c01667cc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IPhTJKbx7hFtw0TxnsypBg.png"/></div></div></figure><p id="ee60" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它为用户<code class="du ks kt ku ki b">root</code>列出了<code class="du ks kt ku ki b">retail_db</code>数据库中的所有表。</p><p id="988f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还可以使用以下命令运行一些简单的SQL查询。</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="800b" class="km kn hh ki b fi ko kp l kq kr">sqoop eval \<br/>--connect "jdbc:mysql://localhost:3306/retail_db" \<br/>--username root \<br/>--password cloudera \<br/>--query "select * from customers limit 5"</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lb"><img src="../Images/2b1b3b9fd2ed56240b694b1f07da9ee2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uow2uhroYh0bpUxB8K3nWw.png"/></div></div></figure><p id="c058" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果您仔细观察，这三个简单的sqoop命令展示了其语法和用法的要点。让我们试着把它变得简单一些。</p><p id="2247" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们打开一个shell，现在尝试将一个表从MySQL导入到HDFS。</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="c42f" class="km kn hh ki b fi ko kp l kq kr">sqoop import \<br/>--connect "jdbc:mysql://localhost:3306/retail_db" \<br/>--username root \<br/>--password cloudera \<br/>--table customers \<br/>--target-dir /user/cloudera/sqoop/data</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es lc"><img src="../Images/b8b4a14e7b496040fa018eb008807670.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mcHue9thvjiy5CpWTEzm1g.png"/></div></div></figure><p id="dc7e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们试着理解这个导入命令。在这里，我们试图将<code class="du ks kt ku ki b">retail_db</code>数据库从MySQL数据库导入到HDFS目录，即<code class="du ks kt ku ki b">/user/cloudera/sqoop/data</code>。</p><p id="50dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该目录有5个文件，第一个文件<code class="du ks kt ku ki b">_SUCCESS</code>将为空，它的存在表明我们已经成功地将数据导入HDFS。目前，我们有四个包含导入数据的文件。现在你可能会问，为什么只有四个文件？我来详细说明一下。</p><p id="53e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Apache-Sqoop执行一种特殊类型的MapReduce作业，默认情况下，4个mappers运行0个reducers，我们不需要任何聚合。</p><p id="0744" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，如果不想要默认的映射器数量，即4个，可以通过使用<code class="du ks kt ku ki b">-m</code>或<code class="du ks kt ku ki b">--num-mapper</code>来指定映射器的数量。</p><p id="d4ad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们试着从数据库中导入所有的表。</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="a2df" class="km kn hh ki b fi ko kp l kq kr">sqoop-import-all-tables \<br/>--connect "jdbc:mysql://localhost:3306/retail_db" \<br/>--username root \<br/>--password cloudera \<br/>-m 8 \<br/>--as-textfile \<br/>--warehouse-dir /user/cloudera/sqoop/data</span></pre><p id="e383" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的命令有<code class="du ks kt ku ki b">--warehouse-dir</code>而不是<code class="du ks kt ku ki b">--target-dir</code>,让我们简单地通过查看HDFS目录来理解这一点。</p><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ld"><img src="../Images/44eba00f4fc1f0dfec6ef687ec294fa6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yh-4zpj8q56EpKpThNfO5w.png"/></div></div></figure><p id="895e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，它将根据HDFS目录中的表名自动创建文件夹。在这里，我们将看到我们有8个文件包含导入的数据，而不是4个文件，因为我们通过<code class="du ks kt ku ki b">-m 8</code>命令传递了8个映射器。</p><p id="3f10" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">默认情况下，sqoop将数据导入到<code class="du ks kt ku ki b">textfile</code>格式，但sqoop支持其他文件格式，如<code class="du ks kt ku ki b">parquet</code>、<code class="du ks kt ku ki b">avro</code>、<code class="du ks kt ku ki b">sequence</code>等。&amp;可以用<br/> <code class="du ks kt ku ki b">--as-&lt;file_format&gt;</code>来指定。</p><p id="7494" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3。分裂智慧和边界查询</strong></p><p id="87e3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们现在所知，Sqoop在后台运行MapReduce作业，并并行运行多个mappers来从RDBMS导入数据。现在，我们应该关心的是，在并行导入数据时，它如何划分数据？</p><p id="01ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当数据库表中有一些主键(pk)并且pk的值按顺序分布时，Sqoop实际上可以很好地工作。如果数据库中没有主键，导入时将只运行一个映射器(如果指定)。让我们通过一个简单的例子来理解这些概念。</p><p id="7e63" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设我们在<code class="du ks kt ku ki b">retail_db</code>数据库中有<code class="du ks kt ku ki b">customers</code>表，该表将<code class="du ks kt ku ki b">id</code>列作为主列，其值在<code class="du ks kt ku ki b">1-10001</code>的范围内，如果我们使用默认数量的映射器，即Sqoop中的4，那么Sqoop将通过以下方式计算<code class="du ks kt ku ki b">split_size</code></p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="ec6d" class="km kn hh ki b fi ko kp l kq kr">split_size = (max(pk) - min(pk)) / num_of_mappers </span></pre><p id="0c46" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以这里的<code class="du ks kt ku ki b">spilt_size</code>将是2500，Sqoop将创建<code class="du ks kt ku ki b">boundary_query</code></p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="f764" class="km kn hh ki b fi ko kp l kq kr">1-2500 --&gt; mapper 1<br/>2501-5000 --&gt; mapper 2<br/>5001-7500 --&gt; mapper 3<br/>7501-10001 --&gt; mapper 4</span></pre><p id="66c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，sqoop导入工作是基于主键划分的，它在内部查找主键的最小值和最大值。基于可用映射器的数量，它将创建<code class="du ks kt ku ki b">split_size</code>并执行<code class="du ks kt ku ki b">boundary_queries</code></p><p id="4004" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果没有主键，那么可以使用<code class="du ks kt ku ki b">--autoreset-to-one-mapper</code>将映射器的编号自动重置为1，或者可以使用<code class="du ks kt ku ki b">split_by</code>，我们将进一步讨论。</p><p id="8755" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果数据中有异常值，也可以在导入时提供硬编码的边界值。现在假设我们有主键<code class="du ks kt ku ki b">column</code>值<code class="du ks kt ku ki b">1-10000, 35001</code>。我们可以看到<code class="du ks kt ku ki b">35001</code>在这里是一个异常值，当Sqoop尝试创建<code class="du ks kt ku ki b">split_size</code>时，它将是<code class="du ks kt ku ki b">8750</code>，它将尝试创建类似于<code class="du ks kt ku ki b">1-8750, 8751-17500, 17501-26250, 26250-35001</code>的东西，我们可以清楚地看到，4个映射器中的大部分工作将由第一个映射器完成，其他三个映射器的处理量很少，这对性能不利。通过指定<code class="du ks kt ku ki b">pk</code>的最大值和最小值，可以智能地对边界查询进行硬编码。比如<code class="du ks kt ku ki b">--boundary-query "select 1, 10000"</code>。这里我们刚刚丢弃了离群值。</p><p id="94f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4。Sqoop的一些重要概念。</strong></p><ul class=""><li id="0e7b" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><strong class="ig hi">由<br/>分割</strong>当表格中没有<code class="du ks kt ku ki b">pk </code>或者<code class="du ks kt ku ki b">pk</code>有很多离群值时，应该使用<code class="du ks kt ku ki b">split_by</code>。如果可以的话，应该尝试在索引数字列上应用split by。对于文本列也可以这样做，但是在生产环境中不鼓励这样做。</li><li id="27f4" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">增量/增量加载<br/> </strong> Sqoop提供了一种增量导入模式，可用于<br/>仅检索比之前导入的一组<br/>行更新的行。<br/> -不支持check-col(col)char<br/>-incremental(mode)append，last modified<br/>-last-value(value)<br/>Sqoop支持两种类型的增量导入:<code class="du ks kt ku ki b">append</code>和<code class="du ks kt ku ki b">lastmodified</code>。您可以使用<code class="du ks kt ku ki b">— incremental</code>参数来指定<br/>要执行的增量导入的类型。在导入一个表时，应该指定append模式，在这个表中，新行随着行id值的增加而不断增加。一个用<code class="du ks kt ku ki b">--check-column</code>指定包含行id的列。Sqoop导入校验列的值大于用<code class="du ks kt ku ki b">--last-value</code>指定的值的行。<br/>sq OOP支持的另一种表更新策略称为<code class="du ks kt ku ki b">lastmodified</code>模式。当源<br/>表的行可能被更新时，应该使用这个，并且每个这样的更新将把<br/>最后修改的列的值设置为当前时间戳。在<br/>检查列中保存了比用<code class="du ks kt ku ki b">--last-value</code>指定的时间戳<br/>更新的时间戳的行被导入。</li><li id="9996" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">压缩<br/>如果有人想使用另一种压缩算法，那就使用<code class="du ks kt ku ki b">--compression-codec &lt;name_of_alogorithm&gt;</code>。</strong></li><li id="f838" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">列选择<br/> </strong>导入时使用<strong class="ig hi"> </strong> <code class="du ks kt ku ki b"><strong class="ig hi">--columns</strong></code> <strong class="ig hi"> </strong>到<strong class="ig hi"> </strong>选择列。</li><li id="5bf6" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi"> Where子句<br/> </strong>使用<strong class="ig hi"> </strong> <code class="du ks kt ku ki b"><strong class="ig hi">--where</strong></code> <strong class="ig hi"> </strong>参数根据条件过滤数据。这就像使用<code class="du ks kt ku ki b">where</code> SQL语句一样。</li><li id="099c" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">详细<br/> </strong>运行sqoop命令时，使用<code class="du ks kt ku ki b"><strong class="ig hi">--verbose</strong></code> <strong class="ig hi"> </strong>获取更多详细日志。</li><li id="33e0" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">删除目标目录</strong> <br/>如果导入时存在，使用<code class="du ks kt ku ki b"><strong class="ig hi">--delete-target-dir</strong></code>。</li><li id="96d0" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">导入数据时处理空值<br/> </strong>使用<strong class="ig hi"/><strong class="ig hi"/>替换非字符串空值，使用<strong class="ig hi"> </strong> <code class="du ks kt ku ki b"><strong class="ig hi">--null-string ..</strong></code> <strong class="ig hi"> </strong>替换字符串空值</li><li id="1ef7" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><strong class="ig hi">导入时验证<br/> </strong>可以使用<strong class="ig hi"> </strong> <code class="du ks kt ku ki b"><strong class="ig hi">--validate</strong></code>验证导入到HDFS的行数和MySQL中存在的行数</li></ul><p id="bbc6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 5。安全集成</strong></p><p id="7f27" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Sqoop中主要有四种提供密码的方式，它们是</p><ul class=""><li id="f967" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><code class="du ks kt ku ki b">--password &lt;raw_text&gt;</code>作为原始文本</li><li id="4838" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><code class="du ks kt ku ki b">--p</code>在控制台中输入</li><li id="4526" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><code class="du ks kt ku ki b">--password-file &lt;file-path&gt;</code>密码文件的路径</li><li id="0264" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><code class="du ks kt ku ki b">--password-alias &lt;name&gt;</code>加密文件的名称</li></ul><p id="3d14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们在这里讨论最重要的一个<code class="du ks kt ku ki b">--password-alias</code>它在安全性方面确实很好。它使用带有<code class="du ks kt ku ki b">jceks</code> ( java cryptography加密密钥库)的加密密码文件。</p><p id="e613" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以使用以下命令创建它</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="7f52" class="km kn hh ki b fi ko kp l kq kr">hadoop credential create &lt;name-of-encrypted-file&gt;<br/>-provider jceks://hdfs/user/cloudera/&lt;file-location&gt;</span></pre><p id="180f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看一个使用它的例子</p><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="f1cf" class="km kn hh ki b fi ko kp l kq kr">sqoop eval \<br/>-Dhadoop.security.credential.provider.path=jceks://hdfs/&lt;file-path&gt;\<br/>--connect jdbc:mysql://quickstart.cloudera:3306/retail_db \<br/>--username root \<br/>--password-alias &lt;name-of-encrypted-file&gt; \<br/>--query "select count(*) from customers"</span></pre><p id="a9d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 6。Sqoop Job:自动化事物</strong></p><ul class=""><li id="4b66" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated"><em class="le">为什么选择Sqoop工作？<br/> </em>保存的作业记住了用于指定作业的参数，因此<br/>它们可以通过调用作业重新执行。<br/>如果保存的作业被配置为执行增量导入，则在<br/>保存的作业中更新关于最近导入的行的<br/>状态，以允许作业仅继续导入最新的<br/>行。</li><li id="cd33" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><em class="le">难点是什么？<br/> </em>当我们在上面的例子中进行增量导入时，我们必须手动跟踪最后一个值，然后在下一次运行时提供该值。这是一个手动过程&amp;是一个很大的难点。这个问题的解决方案是创建一个Sqoop作业。</li><li id="88c5" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated"><em class="le">创建一个Sqoop作业(用于增量导入)</em></li></ul><pre class="jm jn jo jp fd kh ki kj kk aw kl bi"><span id="c5cf" class="km kn hh ki b fi ko kp l kq kr">sqoop job \<br/>-Dhadoop.security.credential.provider.path=jceks://hdfs/&lt;file-path&gt;--create job_orders \<br/>-- import \<br/>--connect jdbc:mysql://quickstart.cloudera:3306/retail_db \<br/>--username root \<br/>--password-alias &lt;name-of-encrypted-file&gt; \<br/>--table orders \<br/>--warehouse-dir /user/cloudera/data \<br/>--incremental append \<br/>--check-column order_id \<br/>--last-value 0</span></pre><p id="73ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注:请注意，此处<code class="du ks kt ku ki b">import</code>前有一个空格。</p><ul class=""><li id="a941" class="jt ju hh ig b ih ii il im ip jv it jw ix jx jb jy jz ka kb bi translated">列出所有sqoop作业-&gt; <code class="du ks kt ku ki b">sqoop job --list</code></li><li id="0cfb" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">执行sqoop作业-&gt; <code class="du ks kt ku ki b">sqoop job --exec &lt;job-name&gt;</code></li><li id="df9e" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">检查sqoop作业的状态-&gt; <code class="du ks kt ku ki b">sqoop job --show &lt;job-name&gt;</code></li><li id="5abb" class="jt ju hh ig b ih kc il kd ip ke it kf ix kg jb jy jz ka kb bi translated">删除一个sqoop作业-&gt; <code class="du ks kt ku ki b">sqoop job --delete &lt;job-name&gt;</code></li></ul><p id="0fa9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 7。结论</strong></p><p id="0613" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我知道这篇文章已经很长了，但是主要目标是涵盖sqoop的所有重要主题。希望你在阅读时觉得有用并喜欢。快乐学习。</p></div></div>    
</body>
</html>