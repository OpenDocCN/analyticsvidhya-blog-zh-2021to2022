<html>
<head>
<title>REAL TIME DISTANCE CALCULATION USING ARUCO MARKERS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用ARUCO标记进行实时距离计算</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/real-time-distance-calculation-using-aruco-markers-b469d5f9791d?source=collection_archive---------3-----------------------#2021-05-27">https://medium.com/analytics-vidhya/real-time-distance-calculation-using-aruco-markers-b469d5f9791d?source=collection_archive---------3-----------------------#2021-05-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4a52774bb224fe221c303cf0fb4b6ee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RJpqVYUOMNqngFLS.jpg"/></div></div></figure><p id="6633" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本周我遇到了一个非常热门的话题——增强现实，但在理解之前，我们需要对ArUco标记背后有一种直觉。</p><h2 id="35d7" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated"><strong class="ak">阿鲁科标记..它们是什么？</strong></h2><p id="1e66" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">ArUco标记类似于QR码，区别因素是QR码比ArUco标记存储更多的信息，因此很难用于我们将要做的事情。<br/>它是一个由黑色边框组成的二进制矩阵，它是一个合成标记，用于在图像或视频中立即定位它。<br/>这是阿鲁科标记的样子-</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es kn"><img src="../Images/5c70ea3f2f03045b2b0a9f00a94d286d.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ztBoF0wRtFe_qViMk0akBA.jpeg"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">阿鲁科标记</figcaption></figure><p id="71f5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，由于它是二进制的并且包含某种信息，我们需要有一些变化，所以这些标记有两个独特的属性——ID和类型</p><p id="1ea8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在标记的id取决于它是什么类型，让我们了解这是一些细节:<br/>在上面的标记中，如果你会看到，在所有的边上都有一个1框填充，并且在标记中你可以看到，在一行中(去除填充后)你可以安装6个白盒，所以这是一个6X6的标记，现在标记的类型你不能猜测(你不应该！).因此，类型是预定义的，这里有点小问题，cv2中总共有25种类型(或字典)的标记，每个字典包含相同数量的位或块以及固定数量的标记(50、100、250或1000)。<br/>上图标记器是DICT _ 6X6 _ 250的id 23。<br/>所以，这里的类型是DICT_6X6_250，id是23。(注意，这里的id不能超过250，因为字典中只有250个可用的标记)。</p><h2 id="7968" class="jn jo hh bd jp jq jr js jt ju jv jw jx ja jy jz ka je kb kc kd ji ke kf kg kh bi translated">工业用途:</h2><p id="b7f4" class="pw-post-body-paragraph ip iq hh ir b is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji km jk jl jm ha bi translated">姿势估计，机器人自动化，2D投影，增强现实等等！当然，今天我们将学习如何使用它们来计算距离。</p><p id="4c2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在使用它们之前，让我们看看它们是如何生成的- <br/>在Python中，你可以借助cv2.aruco.drawMarker()函数来生成它们，让我们看看它是如何运行的！</p><p id="cf8f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所需的软件包包括:</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="dbf3" class="jn jo hh kx b fi lb lc l ld le">import cv2<br/>import numpy as np<br/>import argparse<br/>import sys<br/>import os</span></pre><p id="4221" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，你需要标记的id和类型，所以让我们把它们作为参数-</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="daa5" class="jn jo hh kx b fi lb lc l ld le">ap.add_argument("-i", "--id", type=int, required=True,<br/>                help="id of the aruco marker to be generated")<br/>ap.add_argument("-t", "--type", type=str,<br/>                default="DICT_ARUCO_ORIGINAL", help="type of ARUCO marker")</span></pre><p id="e9ec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，为了生成这些标记，我们正在制作一个ArUco字典的字典。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="eafe" class="jn jo hh kx b fi lb lc l ld le">ARUCO_DICT = {<br/>    "DICT_4X4_50": cv2.aruco.DICT_4X4_50,<br/>    "DICT_4X4_100": cv2.aruco.DICT_4X4_100,<br/>    "DICT_4X4_250": cv2.aruco.DICT_4X4_250,<br/>    "DICT_4X4_1000": cv2.aruco.DICT_4X4_1000,<br/>    "DICT_5X5_50": cv2.aruco.DICT_5X5_50,<br/>    "DICT_5X5_100": cv2.aruco.DICT_5X5_100,<br/>    "DICT_5X5_250": cv2.aruco.DICT_5X5_250,<br/>    "DICT_5X5_1000": cv2.aruco.DICT_5X5_1000,<br/>    "DICT_6X6_50": cv2.aruco.DICT_6X6_50,<br/>    "DICT_6X6_100": cv2.aruco.DICT_6X6_100,<br/>    "DICT_6X6_250": cv2.aruco.DICT_6X6_250,<br/>    "DICT_6X6_1000": cv2.aruco.DICT_6X6_1000,<br/>    "DICT_7X7_50": cv2.aruco.DICT_7X7_50,<br/>    "DICT_7X7_100": cv2.aruco.DICT_7X7_100,<br/>    "DICT_7X7_250": cv2.aruco.DICT_7X7_250,<br/>    "DICT_7X7_1000": cv2.aruco.DICT_7X7_1000,<br/>    "DICT_ARUCO_ORIGINAL": cv2.aruco.DICT_ARUCO_ORIGINAL,<br/>    "DICT_APRILTAG_16h5": cv2.aruco.DICT_APRILTAG_16h5,<br/>    "DICT_APRILTAG_25h9": cv2.aruco.DICT_APRILTAG_25h9,<br/>    "DICT_APRILTAG_36h10": cv2.aruco.DICT_APRILTAG_36h10,<br/>    "DICT_APRILTAG_36h11": cv2.aruco.DICT_APRILTAG_36h11<br/>}</span></pre><p id="515a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在使用给定的类型，我们将得到cv2中的marker字典，</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="da95" class="jn jo hh kx b fi lb lc l ld le">arucoDict = cv2.aruco.Dictionary_get(ARUCO_DICT[args['type']])</span><span id="7c4e" class="jn jo hh kx b fi lf lc l ld le">tag = np.zeros((300, 300, 1), dtype="uint8")<br/>cv2.aruco.drawMarker(arucoDict, args["id"], 300, tag, 1)</span></pre><p id="9ce6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，使用ArUco字典，我们使用<em class="lg"> cv2.drawMarker()，</em>这个函数中的参数是:arucoDict-要生成的标记的字典，args[' id ']-字典中标记的id，300-标记的大小，tag-标记的画布，padding-标记周围的填充</p><p id="ff65" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在使用cv2.imshow()，我们将可视化标记</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="3a78" class="jn jo hh kx b fi lb lc l ld le">cv2.imwrite('output_marker.jpg',tag)<br/>cv2.imshow("marker", tag)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="8374" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">运行，使用命令</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="fcc9" class="jn jo hh kx b fi lb lc l ld le">python .\aruco_marker_generation.py --id 50 --type DICT_6X6_250</span></pre><p id="c967" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的标记生成并保存到磁盘。</p><p id="2edf" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将尝试检测图像中的标记，我们需要的参数是:</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="704d" class="jn jo hh kx b fi lb lc l ld le">ap.add_argument("-i", "--image", required=True, help="path to the image")<br/>ap.add_argument("-t", "--type", required=True,<br/>                help="tag of the marker to b detected")</span></pre><p id="5390" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，正如您所看到的，我们实际上需要检测标记的类型，因此在处理未知标记时这是一个问题。然而，我们将在下一篇文章中解决这个问题，现在让我们在给定的图像中检测一个标记，</p><figure class="ko kp kq kr fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/59d3a7208c1148097f25532fbd0045cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*5-LU345Nu_eWrHDIXOLrhw.png"/></div></figure><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="e5f9" class="jn jo hh kx b fi lb lc l ld le">image = cv2.imread(args['image'])</span><span id="3f58" class="jn jo hh kx b fi lf lc l ld le">ARUCO_DICT = {<br/>    "DICT_4X4_50": cv2.aruco.DICT_4X4_50,<br/>    "DICT_4X4_100": cv2.aruco.DICT_4X4_100,<br/>    "DICT_4X4_250": cv2.aruco.DICT_4X4_250,<br/>    "DICT_4X4_1000": cv2.aruco.DICT_4X4_1000,<br/>    "DICT_5X5_50": cv2.aruco.DICT_5X5_50,<br/>    "DICT_5X5_100": cv2.aruco.DICT_5X5_100,<br/>    "DICT_5X5_250": cv2.aruco.DICT_5X5_250,<br/>    "DICT_5X5_1000": cv2.aruco.DICT_5X5_1000,<br/>    "DICT_6X6_50": cv2.aruco.DICT_6X6_50,<br/>    "DICT_6X6_100": cv2.aruco.DICT_6X6_100,<br/>    "DICT_6X6_250": cv2.aruco.DICT_6X6_250,<br/>    "DICT_6X6_1000": cv2.aruco.DICT_6X6_1000,<br/>    "DICT_7X7_50": cv2.aruco.DICT_7X7_50,<br/>    "DICT_7X7_100": cv2.aruco.DICT_7X7_100,<br/>    "DICT_7X7_250": cv2.aruco.DICT_7X7_250,<br/>    "DICT_7X7_1000": cv2.aruco.DICT_7X7_1000,<br/>    "DICT_ARUCO_ORIGINAL": cv2.aruco.DICT_ARUCO_ORIGINAL,<br/>    "DICT_APRILTAG_16h5": cv2.aruco.DICT_APRILTAG_16h5,<br/>    "DICT_APRILTAG_25h9": cv2.aruco.DICT_APRILTAG_25h9,<br/>    "DICT_APRILTAG_36h10": cv2.aruco.DICT_APRILTAG_36h10,<br/>    "DICT_APRILTAG_36h11": cv2.aruco.DICT_APRILTAG_36h11<br/>}</span></pre><p id="8ef4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，为了检测我们的标记，我们将使用<em class="lg">cv2 . aruco . detect markers()</em>，我们需要标记的类型——即aruco标记字典，以及我们需要传递包含标记的图像的图像，现在还有一个参数，即我们正在使用的检测器的参数，我们将使用<em class="lg">cv2 . aruco . Detector parameters _ create()初始化它。</em></p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="efc2" class="jn jo hh kx b fi lb lc l ld le">arucoDict = cv2.aruco.Dictionary_get(ARUCO_DICT[args['type']])<br/>arucoParams = cv2.aruco.DetectorParameters_create()<br/>(corners, ids, rejected) = cv2.aruco.detectMarkers(<br/>    image, arucoDict, parameters=arucoParams)</span></pre><p id="bcc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这样，cv2.aruco.detectMarkers()返回一个三元组，其中角是检测到的每个标记的所有4个点，ids是我们正在检测的标记类型的检测id，被拒绝的是被分类为非标记的点。</p><p id="b492" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将使用下面的代码片段一个接一个地可视化这些标记。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="55de" class="jn jo hh kx b fi lb lc l ld le">if len(corners) &gt; 0:<br/>    ids = ids.flatten()<br/>    for (markerCorner, markerId) in zip(corners, ids):</span><span id="dfe9" class="jn jo hh kx b fi lf lc l ld le">         corners_abcd = markerCorner.reshape((4, 2))<br/>        (topLeft, topRight, bottomRight, bottomLeft) = corners_abcd</span><span id="1eeb" class="jn jo hh kx b fi lf lc l ld le">         topRightPoint = (int(topRight[0]), int(topRight[1]))<br/>         topLeftPoint = (int(topLeft[0]), int(topLeft[1]))<br/>         bottomRightPoint = (int(bottomRight[0]),      int(bottomRight[1]))<br/>         bottomLeftPoint = (int(bottomLeft[0]), int(bottomLeft[1]))</span><span id="79d1" class="jn jo hh kx b fi lf lc l ld le">        cv2.line(image, topLeftPoint, topRightPoint, (0, 255, 0), 2)<br/>        cv2.line(image, topRightPoint, bottomRightPoint, (0, 255, 0), 2)<br/>        cv2.line(image, bottomRightPoint, bottomLeftPoint, (0, 255, 0), 2)<br/>        cv2.line(image, bottomLeftPoint, topLeftPoint, (0, 255, 0), 2)</span><span id="922a" class="jn jo hh kx b fi lf lc l ld le">        cX = int((topLeft[0] + bottomRight[0])//2)<br/>        cY = int((topLeft[1] + bottomRight[1])//2)<br/>        cv2.circle(image, (cX, cY), 4, (255, 0, 0), -1)</span><span id="a347" class="jn jo hh kx b fi lf lc l ld le">        cv2.putText(image, str(<br/>            int(markerId)), (int(topLeft[0]-10),   int(topLeft[1]-10)), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 0, 255))</span><span id="dfc1" class="jn jo hh kx b fi lf lc l ld le">        # print(arucoDict)<br/>        cv2.imshow("[INFO] marker detected", image)<br/>        cv2.waitKey(0)</span><span id="fa1b" class="jn jo hh kx b fi lf lc l ld le">else:<br/>    # print("[INFO] No marker Detected")<br/>    pass</span><span id="88bf" class="jn jo hh kx b fi lf lc l ld le">cv2.destroyAllWindows()</span></pre><p id="7a1f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">每个角有四个点，每个点由两个坐标(x，y)，<br/>组成，从左上角开始按顺时针顺序排列。</p><p id="5eb2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">利用这一点，我们可以检测论点中提到的标记类型。<br/>现在，我们将使用这些技术来实际计算两个标记之间的实时距离，现在我们将使用一点数学知识来进行计算，但这里需要注意的一点是——您需要将标记打印出来，并知道它的实际尺寸，单位为厘米或英寸或米。<br/>现在，我打印出两个DICT_ARUCO_ORIGINAL类型的记号笔，每个记号笔每边的尺寸为7.5厘米。现在使用下面的代码，我们实际上可以可视化两个标记之间的距离。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="75dc" class="jn jo hh kx b fi lb lc l ld le">import cv2<br/>import imutils<br/>import sys<br/>import os<br/>import numpy as np<br/>import argparse<br/>import time<br/>from imutils.video import VideoStream</span></pre><p id="c032" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用实时视频流来计算距离。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="9468" class="jn jo hh kx b fi lb lc l ld le">ap = argparse.ArgumentParser()<br/><br/>ap.add_argument(“-t”, “ — type”, required=True,<br/> help=”tag of the marker to b detected”)<br/>args = vars(ap.parse_args())</span></pre><p id="a07c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们只需要检测标记的类型。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="d666" class="jn jo hh kx b fi lb lc l ld le">vs = VideoStream(src=0).start()<br/>time.sleep(2.0)</span><span id="2720" class="jn jo hh kx b fi lf lc l ld le">ARUCO_DICT = {<br/>    "DICT_4X4_50": cv2.aruco.DICT_4X4_50,<br/>    "DICT_4X4_100": cv2.aruco.DICT_4X4_100,<br/>    "DICT_4X4_250": cv2.aruco.DICT_4X4_250,<br/>    "DICT_4X4_1000": cv2.aruco.DICT_4X4_1000,<br/>    "DICT_5X5_50": cv2.aruco.DICT_5X5_50,<br/>    "DICT_5X5_100": cv2.aruco.DICT_5X5_100,<br/>    "DICT_5X5_250": cv2.aruco.DICT_5X5_250,<br/>    "DICT_5X5_1000": cv2.aruco.DICT_5X5_1000,<br/>    "DICT_6X6_50": cv2.aruco.DICT_6X6_50,<br/>    "DICT_6X6_100": cv2.aruco.DICT_6X6_100,<br/>    "DICT_6X6_250": cv2.aruco.DICT_6X6_250,<br/>    "DICT_6X6_1000": cv2.aruco.DICT_6X6_1000,<br/>    "DICT_7X7_50": cv2.aruco.DICT_7X7_50,<br/>    "DICT_7X7_100": cv2.aruco.DICT_7X7_100,<br/>    "DICT_7X7_250": cv2.aruco.DICT_7X7_250,<br/>    "DICT_7X7_1000": cv2.aruco.DICT_7X7_1000,<br/>    "DICT_ARUCO_ORIGINAL": cv2.aruco.DICT_ARUCO_ORIGINAL,<br/>    "DICT_APRILTAG_16h5": cv2.aruco.DICT_APRILTAG_16h5,<br/>    "DICT_APRILTAG_25h9": cv2.aruco.DICT_APRILTAG_25h9,<br/>    "DICT_APRILTAG_36h10": cv2.aruco.DICT_APRILTAG_36h10,<br/>    "DICT_APRILTAG_36h11": cv2.aruco.DICT_APRILTAG_36h11<br/>}</span><span id="a52f" class="jn jo hh kx b fi lf lc l ld le">arucoDict = cv2.aruco.Dictionary_get(ARUCO_DICT[args['type']])<br/>arucoParams = cv2.aruco.DetectorParameters_create()</span></pre><p id="adfb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在将使用与之前相同的代码来检测标记，但这次是在实时视频流中。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="3bd0" class="jn jo hh kx b fi lb lc l ld le">CACHED_PTS = None<br/>CACHED_IDS = None<br/>Line_Pts = None<br/>measure = None<br/>while True:<br/>    Dist = []<br/>    image = vs.read()<br/>    image = imutils.resize(image, width=800)<br/>    (corners, ids, rejected) = cv2.aruco.detectMarkers(<br/>        image, arucoDict, parameters=arucoParams)</span><span id="5820" class="jn jo hh kx b fi lf lc l ld le">     if len(corners) &lt;= 0:<br/>        if CACHED_PTS is not None:<br/>            corners = CACHED_PTS</span><span id="677a" class="jn jo hh kx b fi lf lc l ld le">     if len(corners) &gt; 0:<br/>        CACHED_PTS = corners</span><span id="4f67" class="jn jo hh kx b fi lf lc l ld le">        if ids is not None:<br/>           ids = ids.flatten()<br/>           CACHED_IDS = ids<br/>        else:<br/>           if CACHED_IDS is not None:<br/>              ids = CACHED_IDS<br/>        if len(corners) &lt; 2:<br/>           if len(CACHED_PTS) &gt;= 2:<br/>              corners = CACHED_PTS<br/>        for (markerCorner, markerId) in zip(corners, ids):<br/>            print("[INFO] Marker detected")<br/>            corners_abcd = markerCorner.reshape((4, 2))<br/>            (topLeft, topRight, bottomRight, bottomLeft) = corners_abcd</span><span id="6270" class="jn jo hh kx b fi lf lc l ld le">            topRightPoint = (int(topRight[0]), int(topRight[1]))<br/>            topLeftPoint = (int(topLeft[0]), int(topLeft[1]))<br/>            bottomRightPoint = (int(bottomRight[0]), int(bottomRight[1]))<br/>            bottomLeftPoint = (int(bottomLeft[0]), int(bottomLeft[1]))</span><span id="bbb6" class="jn jo hh kx b fi lf lc l ld le">            cv2.line(image, topLeftPoint, topRightPoint, (0, 255, 0), 2)<br/>            cv2.line(image, topRightPoint, bottomRightPoint, (0, 255, 0), 2)<br/>            cv2.line(image, bottomRightPoint, bottomLeftPoint, (0, 255, 0), 2)<br/>            cv2.line(image, bottomLeftPoint, topLeftPoint, (0, 255, 0), 2)</span><span id="a5a8" class="jn jo hh kx b fi lf lc l ld le">            cX = int((topLeft[0] + bottomRight[0])//2)<br/>            cY = int((topLeft[1] + bottomRight[1])//2)</span></pre><p id="7579" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">到目前为止，代码大致相同，但现在我们将进行一些更改，我们将获取像素与厘米的比率，因为现在我们知道了左上角和右上角，我们可以计算它们之间的欧几里德距离，并将它们与实际距离(在这种情况下为7.5厘米)进行比较，之后我们将知道比率，通过使用两个不同标记上的两个点，我们实际上可以使用欧几里德公式进行计算。</p><p id="2fa9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在代码中，我将中心点和左上角点作为参考点，比率是在假设它们在一条线上的情况下计算的，您可以使用欧几里德距离作为参考来更改该比率。</p><pre class="ko kp kq kr fd kw kx ky kz aw la bi"><span id="13ac" class="jn jo hh kx b fi lb lc l ld le">measure = abs(3.5/(topLeft[0]-cX))<br/>            cv2.circle(image, (cX, cY), 4, (255, 0, 0), -1)<br/>            cv2.putText(image, str(<br/>                int(markerId)), (int(topLeft[0]-10), int(topLeft[1]-10)), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 0, 255))<br/>            Dist.append((cX, cY))<br/>            # print(arucoDict)<br/>           if len(Dist) == 0:<br/>             if Line_Pts is not None:<br/>                 Dist = Line_Pts<br/>           if len(Dist) == 2:<br/>             Line_Pts = Dist<br/>           if len(Dist) == 2:<br/>             cv2.line(image, Dist[0], Dist[1], (255, 0, 255), 2)<br/>             ed = ((Dist[0][0] - Dist[1][0])**2 +<br/>              ((Dist[0][1] - Dist[1][1])**2))**(0.5)<br/>             cv2.putText(image, str(int(measure*(ed))) + "cm", (int(300), int(<br/>            300)), cv2.FONT_HERSHEY_COMPLEX, 1, (0, 0, 255))<br/>          cv2.imshow("[INFO] marker detected", image)<br/>          key = cv2.waitKey(1) &amp; 0xFF<br/>          if key == ord('q'):<br/>             break<br/>cv2.destroyAllWindows()<br/>vs.stop()</span></pre><p id="aade" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">瞧啊。你实际上可以计算两个标记之间的实时距离。</p><p id="6bff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将看到一篇关于增强现实的短文。</p><p id="fcb3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">参考:</p><p id="bbc0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><a class="ae li" href="https://www.pyimagesearch.com" rel="noopener ugc nofollow" target="_blank">PyimageSearch</a><br/>T12】OpenCV</p></div></div>    
</body>
</html>