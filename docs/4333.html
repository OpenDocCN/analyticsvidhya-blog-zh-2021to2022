<html>
<head>
<title>Handling Missing Values — Data Science</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">处理缺失值—数据科学</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/handling-missing-values-data-science-d4202c7b953d?source=collection_archive---------5-----------------------#2021-09-23">https://medium.com/analytics-vidhya/handling-missing-values-data-science-d4202c7b953d?source=collection_archive---------5-----------------------#2021-09-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/3e0b67ae5a7a9d915e8284ff009a4f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Cj8ON4Eol2NvLD9AO3_eiw.png"/></div></figure><p id="2e9b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">可怕的NaN值，当我开始我的数据科学之旅时，我曾经讨厌处理缺失值。但是一旦你开始在处理NaN的各种方法背后建立直觉，你就开始理解选择正确方法的重要性。在这篇博文中，我将讨论处理数据中缺失值的各种方法。我将讨论的方法有:</p><blockquote class="jj"><p id="d24f" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">1.删除列或行</p><p id="d8c2" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">2.均值/中位数插补</p><p id="ecf6" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">3.最常见的归罪</p><p id="be47" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">4.未知值插补</p><p id="cb24" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">5.缺失值的预测</p><p id="f88e" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">6.使用对缺失值稳健的算法</p><p id="996f" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">7.杂项方式</p></blockquote><p id="c8a5" class="pw-post-body-paragraph il im hh in b io jt iq ir is ju iu iv iw jv iy iz ja jw jc jd je jx jg jh ji ha bi translated">首先，让我们使用真实世界的情况，用简单的术语来理解上述缺失值的原因。假设你正在进行一项调查，从你的客户那里收集数据，你问了四个问题——名、姓、工资和年龄。有些客户可能没有姓氏，有些人可能不愿意透露薪水等敏感信息，还有一些人不愿意透露自己的年龄。</p><p id="c593" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我不会在这篇博客中讨论实现这些方法的代码，如果你想了解这些方法的实现，请查看我的知识库<a class="ae jy" href="https://github.com/Data-csc/missing_values" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><h1 id="5c6c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">1.删除列或行</h1><blockquote class="jj"><p id="fe92" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">data.dropna(axis=1，in place = True)#删除列</p><p id="b9c1" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">data.dropna(axis=0，inplace=True) #drop row</p></blockquote><p id="844f" class="pw-post-body-paragraph il im hh in b io jt iq ir is ju iu iv iw jv iy iz ja jw jc jd je jx jg jh ji ha bi translated">啊！！这种简单的方法，我的意思是你会爱上它！！如果我们可以在所有数据集上使用这种方法，生活就会变得如此简单。这种方法导致了一个准确和稳健的模型，这是因为我们没有使用任何插补技术来“猜测”缺失值。我不建议在您的项目中使用这种方法，因为它们会导致“有价值”数据的丢失。下面介绍了几种可以考虑使用这种方法的情况:</p><p id="e1e3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">a.当有一列或一行没有相关信息时。</p><p id="808a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">b.当你有几十亿行的时候，删除几行不会有太大的不同。</p><p id="9e5f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">c.当有一列缺少大部分数据时。</p><h1 id="93b2" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">2.均值/中位数插补</h1><p id="ff53" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">这种方法很容易计算，广泛用于替换数据集中缺失的值。当数据完全随机缺失(MCAR)时，即任何观测值缺失的概率相等时，最好使用这种方法。中位数插补对于异常值是稳健的，然而，平均数插补却不是。在下图中，您可以看到当我们用平均值或中值替换缺失值时，KDE图中的差异。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/1ec3f43027e5594ac7a43e61e319c4b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:972/format:webp/1*uZC-lmExBBgAEPcDFBQzcw.png"/></div></figure><p id="c305" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">优点:易于实现，适用于小数据集。</p><p id="82f4" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">缺点:原始方差的改变，这种方法增加了偏差和方差，只对数值型数据有效。</p><h1 id="9f6c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">3.最常见的归罪</h1><p id="22f2" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">这种方法用于填充分类列中缺失的值。实际上很简单，只需用一列中最频繁出现的值替换缺失的值。这种方法与均值/中值插补具有相同的优点和缺点。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/3c3d2d19cedc7bb761840d7b75a764fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*rH43k-2X8LoJtCf0NQTIIg.png"/></div></figure><p id="73c7" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">根据上面的计数图，已装载列中的任何缺失值都可以用“S”类别替换。</p><h1 id="cf5c" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">4.未知值插补</h1><p id="9b2b" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">在这种方法中，我们用一个独特的类别填充缺失值，让我们用“U”表示未知。这种方法在有限的情况下效果很好。让我们假设你在泰坦尼克号沉没后从不同的受害者那里收集数据，你想要分析——是否有任何特殊的原因导致这些乘客幸存。您的数据集中有一列会告诉您冰山撞击时船上乘客的位置。不幸的是，您无法收集所有未能幸免于难的乘客的数据。在这种情况下，创建一个独特的类别可能有助于深入了解数据。也许在位置“U”的乘客生还的机会很小。</p><p id="01ba" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然而，在大多数情况下，在我们执行一次性编码后，我们的数据集中会有一个新的特征，这可能会导致我们的模型精度下降。当数据由于完全随机的原因而在数据集中丢失时，就会出现这种情况。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/c7066d27bed8c44e94aada0bc3d2e480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mt5CB68NwmCsmP33FMRp7g.png"/></div></div></figure><p id="0492" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在上面的照片中，你可以看到客舱列有许多独特的价值，也南。从最初的分析中，我们知道客舱列有<strong class="in hi"> 687 </strong>缺失值。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es ln"><img src="../Images/c1881c9fe4d5886249e82626b0c2490f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s40bUQ5BTWkZ_FEz-b3s0A.png"/></div></div></figure><p id="4ae3" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">将已知值替换为“K”并将未知值替换为“U”后，我们可以看到，更多未能幸存的人拥有未知的客舱类型。</p><h1 id="e708" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">5.缺失值的预测</h1><p id="e36d" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">注意:在回归的情况下，确保没有多重共线性，在继续此方法之前检查VIF(方差膨胀因子)和容差。</p><p id="3098" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这种方法中，我们预测缺失值。以下步骤对此进行了说明:</p><p id="de4d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">a) X训练数据=除了自变量(我们希望避免数据泄漏)之外的所有列，这些列的行为nan</p><p id="0d97" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">b) y定型数据=要预测其缺失值的列，只有不含nan的行</p><p id="2221" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">c) X预测数据=要预测其缺失值的列，其中只有带有nan的行</p><p id="40cf" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">d)在X_train和y_train上训练模型</p><p id="fbc9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">e)对X_pred进行预测</p><p id="bebd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">f)用步骤-(e)替换原始数据集中所有具有nan的行(仅针对您正在输入其缺失值的列)</p><p id="b9f5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是原始数据和用预测值替换缺失值后的数据的年龄柱的KDE图。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/13e153939b936865bec009b49443710b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1192/format:webp/1*xh4uK3fZtFO3-2FJDo7Nlw.png"/></div></figure><h1 id="9d64" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">6.使用对缺失值稳健的算法</h1><p id="daef" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">有许多算法可以自己处理缺失值，其中一些算法(如RandomForest和K近邻算法)是众所周知的，而其他算法(如CatBoost算法)则不太为人所知。我建议浏览一下CatBoost的文档:<a class="ae jy" href="https://catboost.ai/." rel="noopener ugc nofollow" target="_blank">https://catboost.ai/.</a></p><h1 id="c756" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">7.杂项方式</h1><h2 id="fbb4" class="lp ka hh bd kb lq lr ls kf lt lu lv kj iw lw lx kn ja ly lz kr je ma mb kv mc bi translated">- Datawig库</h2><p id="b503" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">这是<a class="ae jy" href="https://github.com/awslabs/datawig" rel="noopener ugc nofollow" target="_blank"> DataWig </a>的文档，这是一个学习模型的框架，用于估算表中的缺失值。</p><h2 id="bea9" class="lp ka hh bd kb lq lr ls kf lt lu lv kj iw lw lx kn ja ly lz kr je ma mb kv mc bi translated">-上次意见结转(LOCF)</h2><p id="473a" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">在这种方法中，最后一个已知值被带入缺失值，并且可以使用pandas轻松实现。</p><blockquote class="jj"><p id="c5c2" class="jk jl hh bd jm jn jo jp jq jr js ji dx translated">data.fillna(method='ffill ')</p></blockquote><p id="5e41" class="pw-post-body-paragraph il im hh in b io jt iq ir is ju iu iv iw jv iy iz ja jw jc jd je jx jg jh ji ha bi translated">其他可用的方法有:“回填”、“b填充”、“填充”、“f填充”</p><p id="7eb8" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">填充/填充:将最后一个有效观测向前传播到下一个有效观测，回填/填充:使用下一个有效观测来填充间隙。</p><h2 id="66df" class="lp ka hh bd kb lq lr ls kf lt lu lv kj iw lw lx kn ja ly lz kr je ma mb kv mc bi translated">-插值</h2><p id="c3ed" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">插值是一种数学方法，它根据数据调整函数，并使用该函数来外推缺失的数据。最简单的插值类型是线性插值，即在丢失数据之前的值和丢失数据之后的值之间取平均值。</p><figure class="ld le lf lg fd ii er es paragraph-image"><div class="er es md"><img src="../Images/e1ce8345aacc206e23aed7e5f2911177.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*T89BkXN0jjXL5j0AGlyjyg.png"/></div></figure><h1 id="5508" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">结论</h1><p id="c4fb" class="pw-post-body-paragraph il im hh in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">你不可能事先真正知道处理缺失数据的正确方法，你需要实现其中的一些方法，并比较它们的结果。对数据和问题陈述有一些了解可以给你一些提示，告诉你哪种方法可能更合适。我希望这篇博客是有用的，我会推荐在泰坦尼克号数据集上练习这些方法<a class="ae jy" href="https://www.kaggle.com/c/titanic/overview" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div></div>    
</body>
</html>