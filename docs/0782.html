<html>
<head>
<title>Python Code on ARIMA Forecasting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于ARIMA预测的Python代码</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-code-on-arima-forecasting-d6e2fd90697c?source=collection_archive---------3-----------------------#2021-01-31">https://medium.com/analytics-vidhya/python-code-on-arima-forecasting-d6e2fd90697c?source=collection_archive---------3-----------------------#2021-01-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="8692" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">去拿你的咖啡，我们要去编码了。</p><p id="8ec0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">ARIMA是一种预测技术，它使用一个序列的过去值来预测未来值。通过阅读下面提到的我在ARIMA探索的第一部分中写的博客文章，可以对该算法有一个基本的直觉</p><div class="jc jd ez fb je jf"><a href="https://etqadkhan23.medium.com/understanding-arima-forecasting-140dc5ceda06" rel="noopener follow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">了解ARIMA预测</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">说到预测，ARIMA算法通常是首选算法。让我们试着简单地理解什么…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">etqadkhan23.medium.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><p id="422c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我正在使用的系列可以从这里下载:<a class="ae kc" href="https://drive.google.com/file/d/1W8K92lQ00Zt6J7qJnLKH4yp7MddIVBsR/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">https://drive . Google . com/file/d/1 w8 k 92 LQ 00 ZT 6j 7 qjnlk H4 yp 7 mddivbsr/view？usp =共享</a></p><p id="89cf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一件事是检查数据的平稳性。平稳性将通过增强的Dicky Fuller测试来检查。该检验的无效假设是时间序列是非平稳的。因此，如果p值小于0.05，我们将拒绝零假设，并认为该序列是平稳的。</p><p id="a121" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从导入库模块开始。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="260c" class="km kn hh ki b fi ko kp l kq kr">import pandas as pd<br/>from statsmodels.tsa.stattools import adfuller<br/>import matplotlib.pyplot as plt</span></pre><p id="1c9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">阅读csv，然后绘制它，看看趋势是什么样的。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="fc20" class="km kn hh ki b fi ko kp l kq kr">df = pd.read_csv(r'''shampoo_dataset.csv''')</span><span id="6048" class="km kn hh ki b fi ks kp l kq kr">plt.plot(df.Month, df.Sales)<br/>plt.xticks(rotation=90)</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es kt"><img src="../Images/2f2b9581dcda117416ff888376de57e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1NXRpgB0XiEuYrnCqATsA.png"/></div></div></figure><p id="9dad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看ADF测试的结果，以了解平稳性。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="6b9c" class="km kn hh ki b fi ko kp l kq kr">result = adfuller(df.Sales.dropna())<br/>print('ADF Statistic: %f' % result[0])<br/>print('p-value: %f' % result[1])</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div class="er es la"><img src="../Images/6c1c297e56d99bdb3da87169e1f31488.png" data-original-src="https://miro.medium.com/v2/resize:fit:904/format:webp/1*L8GZMPmZ1Xtpoym8YJ64wQ.png"/></div></figure><p id="71bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，由于该值非常高，我们将对该系列进行差分，以获得Statonarity。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h2 id="f9fa" class="km kn hh bd lb lc ld le lf lg lh li lj ip lk ll lm it ln lo lp ix lq lr ls lt bi translated">寻找差序</h2><p id="65ef" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">我们将绘制自相关图来了解趋势。如果ACF图显示大量滞后为正值，则意味着该系列需要进一步差分。另一方面，如果它从第一个滞后本身变成负值，我们可能会过度差分它。所以，让我们画出差分序列的ACF图。ACF是当前时间步长和先前时间步长的观测值之间的相关性。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="420f" class="km kn hh ki b fi ko kp l kq kr">from statsmodels.graphics.tsaplots import plot_acf, plot_pacf</span><span id="8db4" class="km kn hh ki b fi ks kp l kq kr">fig, axes = plt.subplots(3, 2, sharex=True)<br/>axes[0, 0].plot(df.Sales); axes[0, 0].set_title('Original Series')<br/>plot_acf(df.Sales, ax=axes[0, 1])</span><span id="3680" class="km kn hh ki b fi ks kp l kq kr"># 1st Differencing<br/>axes[1, 0].plot(df.Sales.diff()); axes[1, 0].set_title('1st Order Differencing')<br/>plot_acf(df.Sales.diff().dropna(), ax=axes[1, 1])</span><span id="25e5" class="km kn hh ki b fi ks kp l kq kr"># 2nd Differencing<br/>axes[2, 0].plot(df.Sales.diff().diff()); axes[2, 0].set_title('2nd Order Differencing')<br/>plot_acf(df.Sales.diff().diff().dropna(), ax=axes[2, 1])</span><span id="903c" class="km kn hh ki b fi ks kp l kq kr">plt.show()</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es lz"><img src="../Images/98bbfe7911d38927af74480c4e422279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GdMTO4hLX-CQUbFv9Dy-lQ.png"/></div></div></figure><p id="7528" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到，阶1的差分帮助我们使序列平稳，所以让我们选择<strong class="ig hi"> d = 1 </strong>。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h2 id="70fc" class="km kn hh bd lb lc ld le lf lg lh li lj ip lk ll lm it ln lo lp ix lq lr ls lt bi translated">查找AR术语</h2><p id="72e3" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">我们将通过部分自相关图来理解AR术语。序列中两个时间步长之间的相关性，使得它们与其他时间步长相关。比如今天的天气取决于昨天，昨天的天气取决于后天。所以，昨天的PACF将是今天和昨天之间的相关性，在去除了前天的影响之后。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="7601" class="km kn hh ki b fi ko kp l kq kr">fig, axes = plt.subplots(1, 2, sharex=True)<br/>axes[0].plot(df.Sales.diff()); axes[0].set_title('1st Differencing')<br/>axes[1].set(ylim=(0,5))<br/>plot_pacf(df.Sales.diff().dropna(), ax=axes[1])</span><span id="52e1" class="km kn hh ki b fi ks kp l kq kr">plt.show()</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ma"><img src="../Images/82c9c62e8f50392c180ad53d4cd781f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iX-YBgcCqwRoA2FFPXHIdw.png"/></div></div></figure><p id="0727" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所看到的，滞后在滞后中立即低于显著限值，因此为了简单起见，让我们继续将<strong class="ig hi"> p = 1 </strong>。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h2 id="8938" class="km kn hh bd lb lc ld le lf lg lh li lj ip lk ll lm it ln lo lp ix lq lr ls lt bi translated">查找MA术语</h2><p id="5210" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">我们将重新讨论ACF术语以找到MA术语。MA项的值告诉我们需要什么值来消除序列中的任何自相关。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b981" class="km kn hh ki b fi ko kp l kq kr">fig<strong class="ki hi">,</strong> axes <strong class="ki hi">=</strong> plt<strong class="ki hi">.</strong>subplots<strong class="ki hi">(1,</strong> <strong class="ki hi">2,</strong> sharex<strong class="ki hi">=True)</strong><br/>axes<strong class="ki hi">[0].</strong>plot<strong class="ki hi">(</strong>df<strong class="ki hi">.</strong>Sales<strong class="ki hi">.</strong>diff<strong class="ki hi">());</strong> axes<strong class="ki hi">[0].</strong>set_title<strong class="ki hi">('1st Differencing')</strong><br/>axes<strong class="ki hi">[1].</strong>set<strong class="ki hi">(</strong>ylim<strong class="ki hi">=(0,1.2))</strong><br/>plot_acf<strong class="ki hi">(</strong>df<strong class="ki hi">.</strong>Sales<strong class="ki hi">.</strong>diff<strong class="ki hi">().</strong>dropna<strong class="ki hi">(),</strong> ax<strong class="ki hi">=</strong>axes<strong class="ki hi">[1])</strong><br/><br/>plt<strong class="ki hi">.</strong>show<strong class="ki hi">()</strong></span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mb"><img src="../Images/c2670e05d71cb3eafe501c4c2b8409af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hM3r-gWnZ9JdSpYztc3t9A.png"/></div></div></figure><p id="4f34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">滞后阶数1高于显著限值，但对于滞后阶数2，则没有问题。让我们选择MA项，并将<strong class="ig hi"> q = 2 </strong>。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><h2 id="6980" class="km kn hh bd lb lc ld le lf lg lh li lj ip lk ll lm it ln lo lp ix lq lr ls lt bi translated">模型结构</h2><p id="a9bc" class="pw-post-body-paragraph ie if hh ig b ih lu ij ik il lv in io ip lw ir is it lx iv iw ix ly iz ja jb ha bi translated">让我们建立一个模型，并分析如何将价值观转化为模型。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="739d" class="km kn hh ki b fi ko kp l kq kr">from statsmodels.tsa.arima_model import ARIMA<br/># ARIMA order (p,d,q)<br/>model = ARIMA(df.Sales, order=(1,1,2))<br/>model_fit = model.fit(disp=0)<br/>print(model_fit.summary())</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es mc"><img src="../Images/63d0d6d74869e80f19666ddf7d8f515a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c_8NmlEV83t3t_yY10EBSQ.png"/></div></div></figure><p id="8e84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型可以进一步改进，可以对其进行大量调整，但需要注意的一点是该系列的规模较小，因此限制了准确的结果。</p><p id="e460" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们预测并寻求准确性，</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="be25" class="km kn hh ki b fi ko kp l kq kr">model_fit.plot_predict(dynamic=False)<br/>plt.show()</span></pre><figure class="kd ke kf kg fd ku er es paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="er es ma"><img src="../Images/d22e9936c11951d1b4bd5c243a722331.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_TDt9GBxxYYNFM4WxQyN5w.png"/></div></div></figure><p id="7257" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果并不令人满意，但了解一下ARIMA是如何工作的还是有好处的。让我们对此进行一个快速的准确性度量检查，看看该模型对未来值的预测有多好。</p><pre class="kd ke kf kg fd kh ki kj kk aw kl bi"><span id="b521" class="km kn hh ki b fi ko kp l kq kr">import numpy as np</span><span id="f347" class="km kn hh ki b fi ks kp l kq kr">model = ARIMA(train, order=(1, 1, 2))  <br/>fitted = model.fit(disp=-1)</span><span id="f5ad" class="km kn hh ki b fi ks kp l kq kr"># Forecast<br/>fc, se, conf = fitted.forecast(6, alpha=0.05)</span><span id="3059" class="km kn hh ki b fi ks kp l kq kr">mape = np.mean(np.abs(fc - test)/np.abs(test))  # MAPE</span></pre><p id="9dde" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MAPE为17.99，这意味着模型的准确率为82.11%。</p></div><div class="ab cl jv jw go jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ha hb hc hd he"><p id="bc5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇教程能给你一些关于如何使用ARIMA的想法。我们可以使用这里给出的代码进入算法。下次我会选择更好的数据集。感谢阅读，非常感谢！</p></div></div>    
</body>
</html>