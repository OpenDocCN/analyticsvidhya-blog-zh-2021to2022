<html>
<head>
<title>How to Build a Multiclass Image Classification Model without CNNs in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Python中建立一个没有CNN的多类图像分类模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-build-a-multi-class-image-classification-model-without-cnns-in-python-660f0f411764?source=collection_archive---------16-----------------------#2021-01-30">https://medium.com/analytics-vidhya/how-to-build-a-multi-class-image-classification-model-without-cnns-in-python-660f0f411764?source=collection_archive---------16-----------------------#2021-01-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0d7c" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">初学者指南建立一个简单的人工神经网络模型</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/67ea6110794dfff64b7b414a4b79c049.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zQdXQFloB2Mi41Fb"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">照片由<a class="ae jm" href="https://unsplash.com/@marius?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马里乌斯·马萨拉尔</a>在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄</figcaption></figure><p id="0e4b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">卷积神经网络(CNN)可以说是计算机视觉任务中最好的机器学习模型，但在我们开始学习CNN之前，最好先从一个更简单的模型开始。</p><p id="199a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在本文中，我们将使用反向传播作为人工神经网络算法来分类MNIST手写数字，我们将使用TensorFlow作为我们的机器学习库。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="6d80" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">关于数据</h1><p id="b337" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">我认为MNIST手写数字是最受欢迎的深度学习实验数据。正如Yann LeCun的网站所写:</p><blockquote class="ln"><p id="5a93" class="lo lp hh bd lq lr ls lt lu lv lw ki dx translated">对于那些想在真实世界的数据上尝试学习技术和模式识别方法，同时花费最少的精力进行预处理和格式化的人来说，这是一个很好的数据库。</p></blockquote><p id="6270" class="pw-post-body-paragraph jn jo hh jp b jq lx ii js jt ly il jv jw lz jy jz ka ma kc kd ke mb kg kh ki ha bi translated">该数据包含60，000幅训练图像和10，000幅测试图像。它是灰度格式，尺寸为28 x 28像素。</p><h1 id="e43d" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">加载数据</h1><p id="b81f" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">MNIST手写数字数据集已经作为TensorFlow库的一部分可用，因此我们可以通过调用函数<code class="du mh mi mj mk b">load_data()</code>轻松加载它。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="c696" class="mp kr hh mk b fi mq mr l ms mt">import tensorflow as tf<br/><br/>mnist = tf.keras.datasets.mnist<br/>(x_train, y_train),(x_val, y_val) = mnist.load_data()</span></pre><p id="749b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">数据加载后，首先我们要验证数据加载是否正确。我们可以通过绘制样本图像来验证它们。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="cba3" class="mp kr hh mk b fi mq mr l ms mt">import matplotlib.pyplot as plt</span><span id="9f26" class="mp kr hh mk b fi mu mr l ms mt">plt.imshow(x_train[0], cmap="gray")<br/>plt.show()<br/>print("Label : ", y_train[0])</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mv"><img src="../Images/d4e24843526d9e289d2c1b37506b6037.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*m5F1WsPkCotgGFQb0Q8Pzg.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">MNIST手写数字图像</figcaption></figure><h1 id="c5ce" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">数据标准化</h1><p id="a7ee" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">图像数据的值在0到255的范围内，0代表黑色，255代表白色，灰色介于两者之间。我们希望将这些图像数据值归一化到从0到1的范围内。由于我们将在输出层中使用softmax激活，因此数据标签被编码为一个热码格式。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="79ae" class="mp kr hh mk b fi mq mr l ms mt">train_norm = x_train.astype('float32')<br/>val_norm = x_val.astype('float32')</span><span id="3692" class="mp kr hh mk b fi mu mr l ms mt">x_train = train_norm / 255.0<br/>x_val = val_norm / 255.0</span><span id="6065" class="mp kr hh mk b fi mu mr l ms mt"># convert label to one-hot encoded<br/>y_train_enc = tf.keras.utils.to_categorical(y_train)<br/>y_val_enc = tf.keras.utils.to_categorical(y_val)</span></pre><h1 id="a74e" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">建立模型</h1><p id="68b0" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">这是我们构建模型的部分。这是我们将使用的模型架构:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mw"><img src="../Images/8b2aa49d5abeefcb07acb69757b35110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*cRoQ4DVxI_juMqYaKd1Bsw.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">反向传播模型</figcaption></figure><p id="c421" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">它只有三层，在网络中间有一个隐藏层。这里没有卷积或特征提取。如果有必要，我们可以添加更多的隐藏层。</p><p id="adaf" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们有784个输入神经元。这个数字对应于我们图像的像素数量。我们将所有784个像素输入到输入层。输入层的10个神经元对应于类的数量。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="ece7" class="mp kr hh mk b fi mq mr l ms mt">model = tf.keras.models.Sequential()<br/>model.add(tf.keras.layers.Flatten())</span><span id="ad4c" class="mp kr hh mk b fi mu mr l ms mt">model.add(tf.keras.layers.Dense(128, input_shape=(784,), activation=tf.nn.relu))<br/>model.add(tf.keras.layers.Dense(10, activation=tf.nn.softmax))</span></pre><h1 id="929a" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">训练模型</h1><p id="b1a5" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">在训练模型之前，需要定义一些超参数。它们是优化器、学习率、损失函数和纪元。优化器是一种改变模型参数值以达到最小损失的算法。学习率将决定每次迭代中值的变化程度。因为我们有一个多类问题，所以我们使用分类交叉熵作为损失函数。epochs就是迭代的次数。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="653e" class="mp kr hh mk b fi mq mr l ms mt">sgd = tf.keras.optimizers.SGD(learning_rate=0.004)</span><span id="44ff" class="mp kr hh mk b fi mu mr l ms mt">model.compile(optimizer=sgd, loss="categorical_crossentropy", metrics=["accuracy"])</span><span id="cf38" class="mp kr hh mk b fi mu mr l ms mt">EP = 25<br/>history = model.fit(x=x_train, y=y_train_enc, epochs=EP, validation_data=(x_val, y_val_enc))</span></pre><p id="55b8" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">训练过程不到两分钟。在这里，我们可以对训练过程进行可视化，以检查我们的模型的性能。</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="b204" class="mp kr hh mk b fi mq mr l ms mt">import numpy as np</span><span id="271f" class="mp kr hh mk b fi mu mr l ms mt">plt.style.use("ggplot")<br/>plt.figure()</span><span id="341d" class="mp kr hh mk b fi mu mr l ms mt">plt.plot(np.arange(0, EP), history.history["loss"], label="train_loss")</span><span id="4d1f" class="mp kr hh mk b fi mu mr l ms mt">plt.plot(np.arange(0, EP), history.history["val_loss"], label="val_loss")</span><span id="5cad" class="mp kr hh mk b fi mu mr l ms mt">plt.plot(np.arange(0, EP), history.history["accuracy"], label="train_acc")</span><span id="b4a5" class="mp kr hh mk b fi mu mr l ms mt">plt.plot(np.arange(0, EP), history.history["val_accuracy"], label="val_acc")</span><span id="9480" class="mp kr hh mk b fi mu mr l ms mt">plt.title("Training Loss and Accuracy")<br/>plt.xlabel("Epoch #")<br/>plt.ylabel("Loss/Accuracy")<br/>plt.legend(loc="lower left")</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mx"><img src="../Images/ea180b3c6a2682593e701d153d549358.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*0eW7gOT6RpX4eiIf2CkJZg.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">培训过程的可视化</figcaption></figure><p id="31c2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">正如我们所看到的，我们的模型做得很好。损耗越来越接近最小值，精度逐渐提高。</p><h1 id="7496" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">评估和预测</h1><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="cc43" class="mp kr hh mk b fi mq mr l ms mt">val_loss, val_acc = model.evaluate(x=x_val, y=y_val_enc)</span></pre><blockquote class="my mz na"><p id="bdc4" class="jn jo nb jp b jq jr ii js jt ju il jv nc jx jy jz nd kb kc kd ne kf kg kh ki ha bi translated">313/313[= = = = = =]—1秒2毫秒/步—损耗:0.1642 —精度:0.9530</p></blockquote><p id="a0b2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这个模型在验证数据上可以得到0.9529的准确率。这意味着我们的模型能够以95%的准确率识别出它在训练过程中从未见过的手写数字。对于一个简单的神经网络来说相当令人印象深刻。</p><p id="d3ff" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这里我们可以展示一些预测结果的例子:</p><pre class="ix iy iz ja fd ml mk mm mn aw mo bi"><span id="067b" class="mp kr hh mk b fi mq mr l ms mt">predictions = model.predict(x_val)</span><span id="8bee" class="mp kr hh mk b fi mu mr l ms mt">x_val__ = x_val.reshape(x_val.shape[0], 28, 28)</span><span id="3f47" class="mp kr hh mk b fi mu mr l ms mt">fig, axis = plt.subplots(2, 5, figsize=(12, 6))</span><span id="e457" class="mp kr hh mk b fi mu mr l ms mt">for i, ax in enumerate(axis.flat):</span><span id="4397" class="mp kr hh mk b fi mu mr l ms mt">    ax.imshow(x_test__[i], cmap='gray')</span><span id="94c4" class="mp kr hh mk b fi mu mr l ms mt">    ax.set(title = f"Label : {y_val[i]}\nPrediction :  {predictions[i].argmax()}")</span></pre><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es nf"><img src="../Images/ef469a520dc3a3420a4c15486fc2405e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvBC0her3Rvp7nvCRkEJeQ.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">验证数据的预测</figcaption></figure><p id="2d26" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">该模型能够识别整体手写数字，但仍然无法识别糟糕的书写。正如我们所看到的，它无法识别标签5，因为手写数字不是很清楚。实际上是五个，但看起来也像六个。</p></div><div class="ab cl kj kk go kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ha hb hc hd he"><h1 id="a9bd" class="kq kr hh bd ks kt ku kv kw kx ky kz la in lb io lc iq ld ir le it lf iu lg lh bi translated">结论</h1><p id="82f5" class="pw-post-body-paragraph jn jo hh jp b jq li ii js jt lj il jv jw lk jy jz ka ll kc kd ke lm kg kh ki ha bi translated">我们建立的简单模型能够在不到两分钟的时间内达到95%的准确率。它简单快速，也不需要图形处理器。适合想学习神经网络的初学者。然而，该模型不适用于复杂的图像数据。</p><h1 id="db5e" class="kq kr hh bd ks kt mc kv kw kx md kz la in me io lc iq mf ir le it mg iu lg lh bi translated">下一步是什么？</h1><ul class=""><li id="32d1" class="ng nh hh jp b jq li jt lj jw ni ka nj ke nk ki nl nm nn no bi translated">尝试使用超参数。添加更多的隐藏层，改变学习率，时期，隐藏神经元的数量等，看看它如何影响精度和性能。</li><li id="fd76" class="ng nh hh jp b jq np jt nq jw nr ka ns ke nt ki nl nm nn no bi translated">挑战模型识别外部看不见的手写数字数据。</li><li id="3c15" class="ng nh hh jp b jq np jt nq jw nr ka ns ke nt ki nl nm nn no bi translated">尽量使用特征提取。</li><li id="f093" class="ng nh hh jp b jq np jt nq jw nr ka ns ke nt ki nl nm nn no bi translated">在其他数据集上尝试该模型。</li></ul></div></div>    
</body>
</html>