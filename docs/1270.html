<html>
<head>
<title>Sequence Alignment and the Needleman-Wunsch Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">序列比对和Needleman-Wunsch算法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/sequence-alignment-and-the-needleman-wunsch-algorithm-710c7b1a23a4?source=collection_archive---------4-----------------------#2021-02-22">https://medium.com/analytics-vidhya/sequence-alignment-and-the-needleman-wunsch-algorithm-710c7b1a23a4?source=collection_archive---------4-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/adec847916be25c1e8618bcf47e05c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ylCmXbbUC6QZCHgO.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.americangene.com/blog/the-gene-therapy-market-is-going-to-produce-a-microsoft-2/" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="316b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你知道人类的DNA和黑猩猩的DNA<strong class="ix hj">98.8%</strong>是一样的吗？虽然这个数字可能听起来很小，但当我们进入我们的DNA时，人类和黑猩猩是非常不同的。在构成我们遗传密码的大约30亿个碱基对中，其中的1.2%相当于超过3500万个遗传差异<strong class="ix hj">。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/7c2d17798608b3b573590dfb40d25468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*GqcEBIGyUp0WoJX5.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在染色体水平上，我们和黑猩猩有惊人的相似之处。(<a class="ae iu" href="https://www.mun.ca/biology/scarr/Human_Ape_chromosomes.htm" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><p id="51a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，从基因组学的角度模拟黑猩猩如何进化成人类是一个巨大的壮举，因为突变可能有许多不同的可能性。突变可以包括<strong class="ix hj">插入</strong>(碱基对的添加)<strong class="ix hj">缺失</strong>(碱基对的去除)，以及<strong class="ix hj">改变</strong>(碱基对的改变)。当扩展到我们拥有的数十亿个碱基对时，这个数字对于可能将黑猩猩DNA改变为人类DNA的排列数目来说就成了天文数字。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jy"><img src="../Images/63a337d176c2824cd023de2936a9326b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Khc8G3qcamqWuPZj.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">三种最常见的突变。(<a class="ae iu" href="https://www.singerinstruments.com/resource/what-are-genetic-mutation/" rel="noopener ugc nofollow" target="_blank">图像源</a>)</figcaption></figure><p id="bed1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">序列比对</strong>解决了这个问题，它允许我们比较两条基因链，并找到导致一条链到另一条链的突变序列。序列比对的目标是找到基因组中的同源/相似序列，然后根据这些序列之间出现的缺口进行碱基突变。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jz"><img src="../Images/f4e58d1dc3cc7005cb5bfe5929662afc.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*r_fPoz7mGydNBmbp.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">序列比对的简单表示。(<a class="ae iu" href="https://towardsdatascience.com/pairwise-sequence-alignment-using-biopython-d1a9d0ba861f" rel="noopener" target="_blank">图像来源</a>)</figcaption></figure><p id="fbd2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">由于可能发生的不同进化事件的数量，常见的序列比对算法试图<strong class="ix hj">最小化事件</strong>的数量来解释两个基因序列之间的差异。此外，他们使用了改变比插入和删除更常见的启发。</p><h2 id="8d09" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">术语</h2><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/2baddb351a0807c7f0321f2009c96535.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/0*ZlzQHtKYE-gSDk0J.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">直系同源物对旁系同源物对同源物(<a class="ae iu" href="https://bitesizebio.com/26762/homology-terminology-never-say-wrong-word/" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><ul class=""><li id="acc0" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">序列比对:</strong>比较两条核苷酸链以发现一系列突变的过程，这些突变将一条链与另一条链区分开来</li><li id="91d9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">直向同源:</strong>导致两个生物体具有相同基因副本的事件(可用于追溯生物体的进化根源)</li><li id="fb28" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">旁系同源:</strong>一个物种内的复制事件(同一物种的两个成员具有相似的基因)</li><li id="7208" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">全局比对:</strong>基因链中每个元素的比对</li><li id="54b3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">局部比对:</strong>包含相似序列的区域的比对</li><li id="7722" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj"> NBAs(非钻孔比对)</strong>:缺口总是与核苷酸配对的比对(例如，两个序列中都没有缺口)</li><li id="b0a2" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">空位罚分:</strong>在一个核苷酸序列中产生空位的罚分</li><li id="58b9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">子串:</strong>字符串中连续的字符序列</li><li id="ef71" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">子序列:</strong>通过删除一些元素而不改变其余元素的顺序，可以从序列中导出的序列</li></ul><h1 id="27bc" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">考虑</h1><h2 id="2751" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">最小化成本</h2><p id="8f6b" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">在下面的过程中，我们需要最小化“成本”以及事件的数量。如上所述，增加成本的事情是使用插入(因为改变比插入更常见)或用嘌呤代替嘧啶(因为嘌呤更有可能被相应的嘌呤替换)。</p><p id="192d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，我们的目标是找到<strong class="ix hj">成本最低、操作最少的序列</strong>，将初始序列转换为最终序列。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mg"><img src="../Images/604867e0a950fd4dc9d71dd7347fa37e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/0*b9Z2wnvo6v6WRnx6.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">碱基对改变的成本矩阵。(<a class="ae iu" href="https://www.semanticscholar.org/paper/2-.-3-Formulation-1-%3A-Longest-Common-Substring-Fujiwara-Kruskall/1b6f2a01a8ed330c8fb7ec277a50924528df8fa0/figure/1" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><h2 id="95e4" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">差距惩罚模型</h2><p id="dac1" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">除了考虑突变之外，还必须对缺口进行额外的考虑。例如，从生物学角度来看，制造一个缺口的成本要比扩大一个已经形成的缺口的成本高得多。目前有几种不同的差距处罚:</p><ul class=""><li id="f249" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">线性缺口罚分:</strong>对所有缺口使用固定成本，而不考虑其当前延伸的缺口长度。</li><li id="bcd6" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">仿射空位罚分:</strong>这为打开空位强加了大的初始成本，但随后为每个空位延伸强加了小的增量成本。</li><li id="a9f5" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">一般缺口罚分:</strong>这使用各种不同的多项式和线性函数来查看哪一个提供了最佳的序列比对。注意这可能会极大地影响运行时间。</li><li id="0aed" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">帧感知间隙惩罚:</strong>这定制了成本函数以考虑编码帧中的中断；例如，某种氨基酸的变化会导致表型的改变。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/ee656fc5c4749b387d58587da4761f09.png" data-original-src="https://miro.medium.com/v2/resize:fit:880/format:webp/0*eAJjS4yWVmywTM9Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">间隙长度上不同间隙罚分的图表。(<a class="ae iu" href="https://www.wikiwand.com/en/Gap_penalty" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="2c68" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们用数学方法来表示缺口惩罚。如果我们让<strong class="ix hj"> w(k) </strong>作为<em class="mi"> k </em>缺口的缺口罚分，我们可以看到下面的情况出现:</p><ul class=""><li id="4cae" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">线性间隙损失:w(k) = p</li><li id="9b85" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">仿射间隙惩罚:w(k) = p + qk</li><li id="00a9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">一般缺口惩罚:w(k) = p + qk或w(k) = p + qk + rk</li></ul><h1 id="f764" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">最长公共子串(二次)</h1><p id="698e" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">寻找两个基因序列之间突变数量的最简单方法是使用两个序列之间最长的公共子串。然后，您可以将子串并排放在两个序列中，并解释因插入/改变而偏移的其他核苷酸。然而，这显然<strong class="ix hj">不是最佳解决方案</strong>，而且它运行起来也非常<strong class="ix hj">慢</strong>，因为你必须枚举所有可能的对齐。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mj"><img src="../Images/98e67152876156feb1d5efeb817cd23f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*7hzOZxZvFi9354getRQ-Sg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">工作中最长的公共子串的例子。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像源</a>)</figcaption></figure><p id="181a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的例子中可以看出，在S1和S2之间发现了6个突变，尽管这显然不是最佳解决方案，也没有减少两个序列之间的步骤数。</p><h1 id="fcac" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">最长公共子序列(指数)</h1><p id="71b8" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">一种最小化步骤的方法是<strong class="ix hj">允许子序列</strong>之间有间隔，而不仅仅局限于子串。然后，可以将这些子串部分排列在一起，并在缺口中找到突变。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mk"><img src="../Images/06bbcccd2363580b2d13e4f103d19809.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*Ci0VaCMviiOLOU4M3-8LJQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">工作中最长公共子序列的例子。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><p id="12c3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从上面的例子可以看出，突变已经从6个减少到4个，这意味着我们的算法越来越好。但是时间复杂度大大增加，从二次到<strong class="ix hj">指数</strong>。</p><p id="c6ed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果考虑NBAs(其中缺口总是与核苷酸配对)，以及长度为n和m的序列，其中n &gt; m，比对的数目为(n+m)选择m，这大约是2^n比对。</p><h1 id="0889" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">动态规划</h1><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ml"><img src="../Images/b5637d0aeee705e37162486e7e786a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XZBOkj0v2hFtMY2w.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">动态编程的基本组件。(<a class="ae iu" href="https://www.geeksforgeeks.org/dynamic-programming-vs-divide-and-conquer/" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><p id="041d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们如何在保持同等精度的同时，再次将运行时间从指数级减少到二次级？答案就在<strong class="ix hj">动态规划</strong>中，它允许我们利用重叠的子问题来高效地解决问题。对于动态编程问题，需要检查两个主要方面:</p><ul class=""><li id="0837" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">最优子结构:</strong>一个问题的最优解包含该问题子问题的最优解。</li><li id="dbc8" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">重叠子问题:</strong>子问题会重复很多次，所以存储这些子问题的答案会降低运行模型时的计算复杂度。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mm"><img src="../Images/9e7a4093e94fc301507594fd49744a7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2kJd5RpMC0E204mc.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">用动态规划将递归树转化为矩阵。(<a class="ae iu" href="https://itnext.io/dynamic-programming-vs-divide-and-conquer-2fea680becbe?gi=cf98e9f00d45" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><p id="fe02" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于动态编程，需要五个主要步骤:</p><ul class=""><li id="264e" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">找到问题的一个<strong class="ix hj">参数化</strong>，确定模型迭代时变化的变量个数。</li><li id="a6df" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">确保子问题空间具有多项式时间复杂性，并且有大量子程序<strong class="ix hj">可重用</strong>。</li><li id="0e41" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">确定一个有效的方法来遍历这些变量。</li><li id="2f92" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">确定一个<strong class="ix hj">递归公式</strong>。这建立了上面提到的子结构，其中最优解依赖于子问题的最优解。</li><li id="bba8" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">记住子问题的最优解，并用多项式表示它。</li></ul><h2 id="1df1" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">序列比对中的动态规划</h2><p id="0d70" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">动态编程可以通过创建矩阵用于序列比对，其中列/行是两个序列。算法，简单来说，就是系统地填表，找到最优分数，然后从最优分数回溯，找到最优解。</p><h1 id="b5bd" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">Needleman-Wunsch算法</h1><h2 id="e9ea" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">设置</h2><p id="08a7" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">我们现在回到两个序列之间的最长公共子序列的问题，以及如何将时间复杂度从指数降低到线性。在做之前，这几个变量需要定义:</p><ul class=""><li id="5e44" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj"> S = {S1，S2，…，Sm} </strong>和<strong class="ix hj"> T = {T1，T2，… Tn} </strong>:两个序列</li><li id="a4bd" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj"> d </strong>:差距惩罚成本(如上所述)</li><li id="cb78" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">s(x；y) </strong>:从S对齐一个碱基x和从T对齐一个碱基y的得分</li><li id="f964" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj"> F </strong>:矩阵，其中F (x，y)指S中的第x位，T中的第y位</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mn"><img src="../Images/decc0187b87667ceb4e4f620f868350f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1058/0*daaOOSeg8q5785CT.gif"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">矩阵F如何寻找S = ACTG，T = ACTG ( <a class="ae iu" href="https://www2.seas.gwu.edu/~simhaweb/cs151/lectures/module12/align.html" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><p id="447e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该算法试图使用动态规划的一个关键部分:您可以跟踪优化的子问题，以解决寻找最佳子序列的问题。如果存在从F(0，0)到F(m，n)的最优对齐(或者跨两个子串的最优对齐)，那么这意味着对于[0，m]中的任何I和[0，n]中的j，在F(0，0)到F(i，j)和F(i+1，j+1)和F(m，n)之间存在最优对齐。这表明最优路径中的每个子路径也必须是最优的。</p><p id="aafa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">此外，它还告诉我们,( m + 1) * (n + 1)空间矩阵是必要的，因为F(i，j)存储该位置的最佳比对的分数。</p><h2 id="1d82" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">填充矩阵</h2><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mo"><img src="../Images/ede3f101f58037fab8f0f93a7b8ad39b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*x9FhuHbopwjkwbT11RJo6g.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">运行Needleman-Wunsch时矩阵F的实例化值。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="4b05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">第一步是<strong class="ix hj">初始化</strong>一些行和列，以便算法可以系统地将数据填充到矩阵中的其他单元。F(0，0)用0初始化，因为还没有进行对齐。F(i，0) = F(i-1，0)-d，因为从F(i-1，0)到F(i，0)的状态变化意味着序列T有一个缺口，这造成了缺口误差损失。类似地，F(0，j) = F(0，j-1)-d，因为从F(0，j-1)到F(0，j)的状态变化意味着序列S有一个间隙。</p><p id="d913" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下一步是<strong class="ix hj">用最优分数填充矩阵F </strong>。在每个点F(i，j ),有四种可能性需要考虑:</p><ul class=""><li id="4c91" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">序列S在当前比对处有一个缺口:<strong class="ix hj"> F(i，j-1) </strong></li><li id="22c9" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">序列T在当前比对处有一个缺口:<strong class="ix hj"> F(i-1，j) </strong></li><li id="5f87" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">当前位置有一个核苷酸替换:<strong class="ix hj"> F (i-1，j-1) </strong></li><li id="b185" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">当前位置有匹配:<strong class="ix hj"> F(i-1，j-1) </strong></li></ul><p id="b54b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这些场景中的每一个都提供了不同的分数。为了最大化我们的最终得分并降低我们的成本，我们必须从这些场景中取最大值<strong class="ix hj">。</strong></p><p id="678a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">最后一步是我们的<strong class="ix hj">终止</strong>序列，终止于右下角或F(m，n)。这是因为这是两个序列的结尾，所以没有进一步的更改。</p><p id="1401" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mi">注意:在填写此矩阵时，请记住您是如何完成的(例如，哪个单元格给了您最高分)，这一点很重要。因此，除了存储矩阵F之外，还需要存储指示哪些单元格指向哪些单元格的指针。</em></p><h2 id="a8f7" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">追溯</h2><p id="237f" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">初始化完矩阵后，最后一步是<strong class="ix hj">从右下角开始回溯矩阵，直到到达左上角的</strong>(或者从F(m，n)到F(0，0))。这将提供最佳的对齐，并且确定路径的含义将为您提供最长的公共子字符串。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mp"><img src="../Images/6fce91a2195500eb92fb4161acdca4f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*X2Q72Oil8tYPwt0q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">Needleman-Wunsch的实例。(<a class="ae iu" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FNeedleman%25E2%2580%2593Wunsch_algorithm&amp;psig=AOvVaw1fNy7w1sIYwWG7Yh9UUR4a&amp;ust=1614036936081000&amp;source=images&amp;cd=vfe&amp;ved=0CAIQjRxqFwoTCOCzgKSS_O4CFQAAAAAdAAAAABAl" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><h2 id="99ff" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">运行时间</h2><p id="81af" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">该算法的时间和空间复杂度均为O(mn) 。这是因为矩阵的实例化比回溯花费更长时间，但是由于单元的每个实例化花费O(1)时间，所以对于(m+1)*(n+1)个单元，它花费O(mn)时间。同样的逻辑可以应用于空间复杂性。</p><p id="6745" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mi">注:对于非线性间隙复杂性，运行时间可以扩展到</em><strong class="ix hj"><em class="mi">O(Mn(m+n))</em></strong><em class="mi">。</em></p><h1 id="14a7" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">最佳化</h1><h2 id="0deb" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">有界动态规划</h2><p id="dca4" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">考虑到基因组中数十亿个碱基对，即使时间复杂度为O(mn ),这个数字仍然很大。有没有办法让模型<strong class="ix hj">线性复杂度</strong>？</p><p id="5178" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可以实现的一种情况是，只有靠近对角线的正方形被用于追溯特征。这意味着不需要实例化矩阵中的其他数字。当然，可能有一些序列严重偏离对角线，但是该算法将可能捕获相对最佳的比对，同时忽略具有太多缺口的比对。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mq"><img src="../Images/36c5909d7c4d7b8742ed25155f84d8e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:886/format:webp/1*9wAaixj5kAw_fHPuofStXA.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">有界动态规划的图形表示。(<a class="ae iu" href="https://slideplayer.com/slide/14104507/" rel="noopener ugc nofollow" target="_blank">图像源</a>)</figcaption></figure><p id="72a2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数学上可以说我们把矩阵限制在距离W，这意味着只会有<strong class="ix hj"> O((m+n) * W) </strong>的时间和空间复杂度，也就是说现在有线性复杂度。然而，重要的是要记住，这将不再保证最佳对齐。</p><h2 id="cf06" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">线性空间对齐</h2><p id="c6c4" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">可以进行的另一个观察是，只需要最后更新的列来创建下一列，这仅花费O(m)。然而，即使更新是O(m ),我们怎样才能使回溯是线性的呢？</p><p id="f31a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这可以使用<strong class="ix hj">分而治之</strong>来完成，其中可以进行向前(从左上开始)和向后(从右下开始)传球，这些传球将在中间栏中汇聚。步骤如下:</p><ul class=""><li id="c550" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">通过<strong class="ix hj">将相邻列的两个比对分数</strong>相加，找到中间列的最佳分数。</li><li id="df1d" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">重复这个过程，取左右两列。</li><li id="6d7b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">使用前面的中间列作为指针来计算中间列的最高分数。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mr"><img src="../Images/591e73b8beda962c3d985c3197a71a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*yeN8OfLO7FqDqFEQKSTZTA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">步骤#1:将两个比对分数相加，找到最佳分数。(<a class="ae iu" href="https://slideplayer.com/slide/4837166/" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es ms"><img src="../Images/bd8a67d97c83fe427d977adf0fa27468.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*KCrBoVYEbrZ0PH6A2ZHwMQ.jpeg"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">递归地分而治之，同时迭代地重复步骤#1。(<a class="ae iu" href="https://slideplayer.com/slide/5148425/" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><p id="b7ec" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因为回溯需要更多的计算，所以总运行时间为O(Mn)+O(1/2mn)+O(1/4mn)+…= O(2mn)=<strong class="ix hj">O(Mn)</strong>。然而，与所提供的多项式简化相比，这个线性标量2就相形见绌了。</p><h1 id="2238" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">多重对齐</h1><h2 id="b186" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">三序列比对</h2><p id="f4dc" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">现在我们已经确定了两个序列的序列比对，让我们看看是否可以将相同的逻辑扩展到一系列的<strong class="ix hj">三个序列S、T和U </strong>。对于这些，F的每次更新有七种不同的可能性:</p><ul class=""><li id="0b4b" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">对准中两个间隙的三种方式(3选2组合)</li><li id="5c22" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">对准中一个间隙的三种方式(3选1组合)</li><li id="b5fc" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">一种对齐方式没有间隙(3选0组合)</li></ul><p id="f9f0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，更新规则更改如下:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mt"><img src="../Images/0e961c478ab3093f0fc66dbf1c312e9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1022/format:webp/1*OPBZo3pDQkE4OdXaIfItxQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">修正了三序列比对的更新规则。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><p id="2cdf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，对于需要对齐的长度为n 的k个序列，时间和空间复杂度相应地扩展到<strong class="ix hj"> O(n^k。考虑使用上面讨论的各种优化算法来减少运行时间。</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mu"><img src="../Images/bf198f59a2e17997f39836a0a75c4600.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/format:webp/1*-FJAgCseCBSgHzILhsAlnw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">三序列比对的图示。(<a class="ae iu" href="http://www.mi.fu-berlin.de/wiki/pub/ABI/MultipleAlignmentWS13/multal1.pdf" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><h2 id="f254" class="ka kb hi bd kc kd ke kf kg kh ki kj kk jg kl km kn jk ko kp kq jo kr ks kt ku bi translated">渐进式多重比对</h2><p id="dfe6" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">查看三序列比对，我们可以看到，由于指数增长，比对多个序列将很快变得不可行。我们怎样才能把O(n^k的增长降低到类似于O(k*n^2的水平呢？</p><p id="f863" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们假设我们知道与我们的每个序列相关的进化树，并且我们的第一个两序列比对是与最密切相关的序列进行的(这个过程被称为<strong class="ix hj">种子比对</strong>)。接下来，继续将下一个最接近的序列与种子进行比对，每次新的比对都会替换种子。这个过程一直持续到产生最终的对准。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es jt"><img src="../Images/fd9a069c2bb0a118aa7f4f57e9c25931.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*kiREnzVJGSL_Jm1G.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">渐进序列比对的可视化表示。(<a class="ae iu" href="https://www.researchgate.net/figure/A-progressive-multiple-sequence-alignment-An-example-of-progressive-Multiple-Sequence_fig1_221865314" rel="noopener ugc nofollow" target="_blank">图像源</a>)</figcaption></figure><p id="378a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">需要注意的一点是，这个最终比对<strong class="ix hj">并不是最优的</strong>，但是产生的<strong class="ix hj">运行时间比上面提到的n序列比对算法</strong>要短得多。</p><h1 id="68d6" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">局部对齐</h1><p id="e48d" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">在这个算法中，我们考虑两个序列如何能有最长的公共子序列。这假设<strong class="ix hj">核苷酸分组不会在突变</strong>之间交换位置，这可能最终导致大量突变，而实际结果要小得多。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/519a8bd84c1ac66eb9b087ad0efd2750.png" data-original-src="https://miro.medium.com/v2/resize:fit:520/format:webp/1*sTy40ABE4P3d1W462rqWTQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用Needleman-Wunsch的局部比对示例。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像来源</a></figcaption></figure><p id="b8b4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如上所示，S和T中的核苷酸序列可以互换，即使这两个序列之间几乎没有突变。对此进行编码相对类似于用于全局比对的Needleman-Wunsch算法。初始化、迭代和终止过程略有改变:</p><ul class=""><li id="ad31" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">初始化:</strong>而不是说F(i，0) = F(i-1，0)-d，F(i，0) = 0因为注意局部比对说明在S或t的任何一点核苷酸序列都可以有一个开关，这适用于F(j，0)，它也初始化为0。</li><li id="d8cd" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">终止:</strong>终止现在可以在任何地方发生，如上图所示。</li><li id="acdb" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">迭代:</strong>因为终止现在可以在任何地方发生，所以我们希望对负的分数进行重罚。因此，我们现在添加一个新的约束，其中如果最大值是负的，那么我们使F(i，j) = 0。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mw"><img src="../Images/48c0fdfe7b46b5f8f843ad7a26d114f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*9JyMNReB3qF4S1khbPrtpQ.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于局部对齐的矩阵F的实例化值。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图片来源</a>)</figcaption></figure><h1 id="3436" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">半全局比对</h1><p id="561b" class="pw-post-body-paragraph iv iw hi ix b iy mb ja jb jc mc je jf jg md ji jj jk me jm jn jo mf jq jr js hb bi translated">半全局查找序列S的子串S与序列t的子串t的<strong class="ix hj">对齐</strong></p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/be562440828e46b9357f839b7051933c.png" data-original-src="https://miro.medium.com/v2/resize:fit:408/format:webp/1*ul79g5qzO13ae7DnifhH_A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">使用Needleman-Wunsch的局部比对示例。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像源</a>)</figcaption></figure><p id="5522" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与局部比对相似，Needleman-Wunsch算法中的代码稍有变化，允许这种半全局比对:</p><ul class=""><li id="c2a5" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated"><strong class="ix hj">初始化:</strong>与本地对准相同</li><li id="5bd3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated"><strong class="ix hj">终止:</strong>终止可以发生在底行或右列的任何地方。这是因为这些是序列S或T停止的地方。由于我们正在寻找半全局比对，一旦序列停止，就没有办法再进一步，类似于全局比对。</li></ul><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kv"><img src="../Images/d1a5885c19dc00a5e8bd10797e36306c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*2zcuuq8m4LdYa6DbcuK9qA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">用于半全局比对的矩阵F的实例化值。(<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">图像来源</a>)</figcaption></figure><h1 id="0a4e" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">TL；速度三角形定位法(dead reckoning)</h1><ul class=""><li id="c23e" class="kw kx hi ix b iy mb jc mc jg my jk mz jo na js lb lc ld le bi translated">序列比对使我们能够比较两条遗传链，并确定是什么突变导致了这两条遗传链。</li><li id="4f68" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">在序列比对过程中，必须为缺口大小和不同的核苷酸改变付出一定的代价，以便序列比对在概率和生物学上更有意义。</li><li id="8739" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">最简单的序列比对算法，最常见的子串，准确性最低，但运行时间最快(二次)。最常见的子序列具有较高的精度，但运行时间极慢(指数级)。</li><li id="d3be" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">动态规划允许我们使用重复的最优子序列来减少模型的计算时间。Needleman-Wunsch算法为每个子比对创建一个分数矩阵，并通过回溯最大分数找到最佳比对。该算法的时间和空间复杂度是二次的。</li><li id="2e55" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">优化，如有界空间编程和线性空间对齐，是为了使运行时线性。</li><li id="978a" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">Needleman-Wunsch算法可以扩展到多个序列的序列比对。</li><li id="3b62" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">不是将整个序列匹配在一起，而是将序列的某些部分匹配在一起，以增加模型的准确性，并提供两个序列之间的进化途径的更好视图。</li></ul><h1 id="9e98" class="lk kb hi bd kc ll lm ln kg lo lp lq kk lr ls lt kn lu lv lw kq lx ly lz kt ma bi translated">额外资源</h1><ul class=""><li id="0f09" class="kw kx hi ix b iy mb jc mc jg my jk mz jo na js lb lc ld le bi translated">书籍:<a class="ae iu" href="https://ocw.mit.edu/ans7870/6/6.047/f15/MIT6_047F15_Compiled.pdf" rel="noopener ugc nofollow" target="_blank">计算生物学——基因组、网络、进化</a></li><li id="b8d3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">视频:<a class="ae iu" href="https://www.youtube.com/watch?v=AuXp5IZNq70" rel="noopener ugc nofollow" target="_blank">使用动态编程的序列比对</a></li><li id="ddce" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">视频:<a class="ae iu" href="https://www.youtube.com/watch?v=pO3GCbmfUKQ" rel="noopener ugc nofollow" target="_blank">局部比对，哈希，BLAST算法</a></li><li id="fde6" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">Page: <a class="ae iu" href="https://en.wikipedia.org/wiki/Needleman%E2%80%93Wunsch_algorithm" rel="noopener ugc nofollow" target="_blank"> Needleman-Wunsch算法</a></li><li id="c1ad" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">工具:<a class="ae iu" href="https://www.ebi.ac.uk/Tools/psa/" rel="noopener ugc nofollow" target="_blank">成对序列比对</a></li></ul><p id="357a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="mi">如果你想多聊聊，安排一个会议:</em> <a class="ae iu" href="https://calendly.com/adityamittal307" rel="noopener ugc nofollow" target="_blank"> <em class="mi">日历</em> </a> <em class="mi">！关于我目前正在做的项目的信息，可以考虑订阅我的</em> <a class="ae iu" href="https://preview.mailerlite.com/v5x5i6" rel="noopener ugc nofollow" target="_blank"> <em class="mi">简讯</em> </a> <em class="mi">！下面是</em> <a class="ae iu" href="https://forms.gle/pLWuNuBuJQokMk3N8" rel="noopener ugc nofollow" target="_blank"> <em class="mi">订阅</em> </a> <em class="mi">的链接。有兴趣连线的话，关注我上</em><a class="ae iu" href="https://www.linkedin.com/in/adityamittal-/" rel="noopener ugc nofollow" target="_blank"><em class="mi">Linkedin</em></a><em class="mi"/><a class="ae iu" href="https://github.com/adityamittal13" rel="noopener ugc nofollow" target="_blank"><em class="mi">Github</em></a><em class="mi"/><a class="ae iu" rel="noopener" href="/@adityamittal307"><em class="mi">中</em> </a> <em class="mi">。</em></p></div></div>    
</body>
</html>