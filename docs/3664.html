<html>
<head>
<title>Logistic Regression</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">逻辑回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/ml-algorithms-from-scratch-2-2c1aea2bff3b?source=collection_archive---------7-----------------------#2021-07-16">https://medium.com/analytics-vidhya/ml-algorithms-from-scratch-2-2c1aea2bff3b?source=collection_archive---------7-----------------------#2021-07-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="24cd" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">从零开始的机器学习算法</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/a187582c515849f6b94dcad1905803d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-L_j7sEgJ8_xzNSdKhxAg.png"/></div></div></figure><blockquote class="ji jj jk"><p id="58a9" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">"我相信我们不知道什么是肯定的，但一切都是可能的."<br/> ― <strong class="jo hi">克里斯蒂安·惠更斯，作品完成</strong></p></blockquote><p id="cda7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">我们已经学习了回归算法的一个基础，现在是时候看看我们是否能在分类算法中占有一席之地了。分类算法有助于将数据集分为不同的类别。举个例子，我们把垃圾分为湿垃圾和干垃圾，这是分类问题的一个典型例子。</p><p id="99d7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">任何分类算法的主要任务都是预测哪个数据集属于哪个类别，(在我们的例子中，哪个垃圾去了哪里)。市场上有成吨的分类算法，让我们从一个基本的开始，逻辑回归。逻辑回归是一个二元分类器，即它以0和1的形式陈述预测，即真或假。它是在特征变量的帮助下计算目标变量的概率。它在基础中使用了概率，正如你所猜测的，这是从概率中借用的许多主题之一。</p><p id="560c" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">闲聊太多，让我们来刨根问底吧！</p><h1 id="8205" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated"><strong class="ak">什么是Logistic回归？</strong></h1><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es ld"><img src="../Images/c87fa95c3d50d18bfa9b28eae4b02868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/0*I6ZTpAbKduSDlB7u.jpg"/></div></figure><p id="b444" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">逻辑回归也称为Logit回归。它通常用于估计一个实例属于某个特定案例的概率。让我们举一个例子来更好地理解这一点，如果你的收件箱中有10封电子邮件，邮件系统将如何将这些邮件分类为垃圾邮件或非垃圾邮件。它将首先扫描邮件并检测垃圾邮件中使用的常用词，然后将这十封邮件分类为垃圾邮件和非垃圾邮件文件夹，可能邮件系统正在使用逻辑回归。该算法的基本工作是，如果估计的概率大于阈值，比如60%，那么它将预测该实例属于特定类别(比如正类别，标记为1)，否则它将该实例分类为另一个类别(比如负类别，标记为0)。我们可以说，逻辑回归也是一种二元分类器，因为它将数据集分类为0和1。通常，逻辑回归用于两类值。</p><p id="edb6" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">逻辑回归使用sigmoid函数来预测特定类别的概率。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es le"><img src="../Images/6a51a52d62068e35ad6fa362f612f18f.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*81yAvtwvlOMoL_X2677Rpg.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">Sigmoid函数</figcaption></figure><p id="83a5" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">由于逻辑回归借用了概率，因此sigmoid函数返回0到1范围内的值。通常使用的阈值是，如果该值大于或等于0.5，则为阳性，否则为阴性。你现在可能会发现所有这些乱七八糟的东西，让我们动手操作一下，这样我们就能更仔细更好地了解算法。</p><h1 id="7495" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">履行</h1><p id="a1b3" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju ki ll jx jy kj lm kb kc kk ln kf kg kh ha bi translated">我们将通过导入所需的库来开始我们的项目，这里我们使用:</p><ul class=""><li id="f9a0" class="lo lp hh jo b jp jq js jt ki lq kj lr kk ls kh lt lu lv lw bi translated"><a class="ae lx" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank">熊猫</a>:用于数据处理和操作</li><li id="9d94" class="lo lp hh jo b jp ly js lz ki ma kj mb kk mc kh lt lu lv lw bi translated"><a class="ae lx" href="https://numpy.org/" rel="noopener ugc nofollow" target="_blank"> Numpy </a>:用于数学运算</li><li id="7ec9" class="lo lp hh jo b jp ly js lz ki ma kj mb kk mc kh lt lu lv lw bi translated"><a class="ae lx" href="https://matplotlib.org/" rel="noopener ugc nofollow" target="_blank"> Matplotlib </a>:用于数据可视化</li><li id="17cd" class="lo lp hh jo b jp ly js lz ki ma kj mb kk mc kh lt lu lv lw bi translated"><a class="ae lx" href="https://scikit-learn.org/stable/modules/generated/sklearn.datasets.load_iris.html" rel="noopener ugc nofollow" target="_blank"> load_iris </a>:我们将从这里使用预先存在的数据集。</li><li id="af84" class="lo lp hh jo b jp ly js lz ki ma kj mb kk mc kh lt lu lv lw bi translated"><a class="ae lx" href="https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html" rel="noopener ugc nofollow" target="_blank"> train_test_split </a>:用于将数据拆分为训练集和测试集。</li></ul><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="bd51" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">导入数据后，我们将看到我们的数据实际上是什么样子，因为我们是从sklearn导入数据的，我们不需要格式化数据，这已经是一种理想的方式了。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mf"><img src="../Images/d7db58ac90fce77622a5410f8569a85c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d825XzktbMdr5lXOnXyATw.png"/></div></div></figure><p id="8cf1" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">但是，由于我们要用逻辑回归来训练数据，逻辑回归是一个二元分类器，所以我们将以目标变量是二元的方式来创建数据。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="96e7" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">有四个特性名称可供我们使用，但是我们将只使用数据中的两个名称，<code class="du mg mh mi mj b">Petal Length</code>和<code class="du mg mh mi mj b">Petal Width</code>，也正如我们在将目标变量转换为二进制数据之前所讲的那样。</p><p id="05d1" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">因此，我们要预测一朵鸢尾花是否属于北美鸢尾。</p><p id="0faa" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">然后，我们将把我们的原始数据转换成一个数据帧，有3列，花瓣长度，花瓣宽度和Virginica。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="893a" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">有了数据框后，我们将使用train_test_split函数将数据分成训练集和测试集，在此之前，我们将把数据分成特征和目标变量。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="8d90" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">所以现在我们的数据已经准备好接受逻辑回归训练了。在继续之前，让我们看看实际上将要发生什么。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es mk"><img src="../Images/48d80004701723e590b4e48360cdf3c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:756/format:webp/1*98q9TTmvzamc2xuaLgBLxA.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">Sigmoid函数</figcaption></figure><p id="f16f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">我们已经讨论过我们的sigmoid函数，我们看过这个图形，这是这个函数在数字形式下的样子，我们不能直接使用这个方程，所以我们要稍微修改一下这个方程。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ml"><img src="../Images/82c97cdb115c3741212b3c5c8c289bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c9vtE-tFHgtwLiU8mq70uA.png"/></div></div><figcaption class="lf lg et er es lh li bd b be z dx translated">逻辑回归预测</figcaption></figure><p id="7359" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">我们将使用上面的等式来进行预测，等式几乎是相同的，我们只是添加我们的权重(b0，b1，b2)。这些重量会帮助我们做出准确的预测。这些权重将首先在某个点被初始化(假设所有都等于0)，然后使用另一个等式来更新这些权重的值。</p><p id="c6f2" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">首先，我们有一个预测，因为我们已经将所有权重初始化为0，无论数据是什么，预测结果都是0.5。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="ec0e" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">所以现在，是时候改善了。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mm"><img src="../Images/f6dea8409ab164f5b724dc30dacf0b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dF-yjgdala8_l96ZqyP2Kw.png"/></div></div></figure><p id="bfbc" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">在提高权值的同时，我们要指定学习率，我选了0.3。然后，我们将插入其他值，从而在更新值的同时更新我们的值。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="d487" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">现在我们知道了如何更新权重，以及如何进行预测，让我们把所有这些东西放在一起，创建一个相同的函数。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="11b5" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">上面的函数首先将数据转换为NumPy数组，然后循环给定数量的epoch，在该循环中，我们还有另一个循环，它循环数据，进行预测并不断更新数据，为了方便起见，我为权重创建了一个空列表，我们可以在其中查看稍后给出的权重值。</p><p id="b6ba" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">在找到各代的权重值后，我们现在需要进行预测，以了解这些值有多理想。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="645b" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">上面的函数将创建一个列表<code class="du mg mh mi mj b">pred_list</code>，其中包含使用权重进行的预测。</p><p id="002f" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">sigmoid函数所做的预测将介于0和1之间，但我们需要的值要么是0，要么是1。因此，我们将有另一个清晰的函数，将值转换成我们需要的格式。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="7bdd" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">如果该值大于或等于0.5，则它将是正类，否则它将是负类。</p><p id="3fd9" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">现在我们的预测已经准备好了，现在我们必须将预测与真实值进行比较，以便了解模型的表现如何。为此，我们有另一个函数。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="md me l"/></div></figure><p id="63b9" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">这个函数将计算我们的模型的准确率。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mn"><img src="../Images/9c79258dd82f7900a7fcc23baba9f516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8cb2RtGjmOwlUCXJYtWVoA.png"/></div></div></figure><p id="aba0" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">如果我们一个接一个地运行这些函数。(在这种情况下，我选择了35个纪元。)我们会得到我们的预测分数。</p><p id="c112" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">呜哇！！我们以82%的准确率预测了花的种类。这是一件了不起的事情！</p><h1 id="f944" class="kl km hh bd kn ko kp kq kr ks kt ku kv in kw io kx iq ky ir kz it la iu lb lc bi translated">结论</h1><p id="30b8" class="pw-post-body-paragraph jl jm hh jo b jp lj ii jr js lk il ju ki ll jx jy kj lm kb kc kk ln kf kg kh ha bi translated"><em class="jn">耶！我们做到了，</em>我们使用逻辑回归方法的随机梯度下降来使用花瓣长度和宽度预测鸢尾花的种类。总而言之，我们将数据分为训练集和测试集，然后使用sigmoid函数来计算预测，然后更新权重，直到获得更好的预测。</p><p id="48ba" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated">你也可以看看包含我在博客中使用的代码和数据的<a class="ae lx" href="https://github.com/rithurajnambiar17/iris-flower-classification" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>。</p><p id="fa9a" class="pw-post-body-paragraph jl jm hh jo b jp jq ii jr js jt il ju ki jw jx jy kj ka kb kc kk ke kf kg kh ha bi translated"><em class="jn">非常感谢阅读到最后！</em></p><blockquote class="ji jj jk"><p id="c08d" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">如果你需要任何进一步的信息，请不要犹豫与我联系。</p><p id="8ee2" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">作品集:<a class="ae lx" href="http://rithurajnambiar17.github.io/" rel="noopener ugc nofollow" target="_blank">rithurajnambiar 17 . github . io</a></p><p id="5fd5" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">领英:<a class="ae lx" href="https://www.linkedin.com/in/rithuraj-nambiar/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/rithuraj-nambiar/</a></p><p id="1a26" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">GitHub:<a class="ae lx" href="https://www.github.com/rithurajnambiar17/" rel="noopener ugc nofollow" target="_blank">https://www.github.com/rithurajnambiar17/</a></p><p id="feea" class="jl jm jn jo b jp jq ii jr js jt il ju jv jw jx jy jz ka kb kc kd ke kf kg kh ha bi translated">电子邮件:<a class="ae lx" href="mailto:rithurajnambiar17@gmail.com" rel="noopener ugc nofollow" target="_blank">rithurajnambiar17@gmail.com</a></p></blockquote></div></div>    
</body>
</html>