# 冒泡排序算法

> 原文：<https://medium.com/analytics-vidhya/bubble-sort-668652120c02?source=collection_archive---------4----------------------->

冒泡排序是数据结构中的一种简单算法。该算法用于对数组进行排序，首先根据元素的值逐一比较所有元素。它通过比较第一个元素和第二个元素来对元素进行排序，如果第一个元素大于第二个元素，那么值将被交换，然后第二个和第三个元素将继续相同的过程，依此类推。

注意:如果数组有 n 个元素，那么我们需要重复这个过程 n-1 次。

还有一点需要注意的是，在一次完整的迭代之后，最大的元素被放在最后一个位置或最高的索引处。

# **实现冒泡排序算法的步骤:-**

1.我们将从第一个元素开始，将它的值与数组的下一个元素进行比较。

2.如果第一个元素大于下一个元素，那么我们将交换它们的值，否则我们将移动到下一个元素，并重复相同的过程，将其与下一个连续的元素进行比较。

让我们用一个例子来理解这个算法

*   假设数组是{18，15，11，16，12，14}
*   首先，我们将比较元素 18 和 15，即索引 0 和索引 1 处的元素。因为 18>15，所以我们将交换这两个值，数组现在看起来像这样:- {15，18，11，16，12，14}。
*   然后，我们将对第二个和第三个索引元素做同样的操作。因为，第二个索引元素是 18，第三个索引元素是 11。和 18>11，所以我们将交换这两个值。数组现在看起来像这样:- {15，11，18，16，12，14}。
*   然后，我们将对第三和第四个索引元素做同样的操作。因为，第 3 个索引元素是 18，第 4 个索引元素是 16。和 18>16，所以我们将交换这两个值。数组现在看起来像这样:- {15，11，16，18，12，14}。
*   然后，我们将对第 4 个索引和第 5 个索引元素做同样的操作。因为，第 4 个索引元素是 18，第 5 个索引元素是 12。和 18>12，所以我们将交换这两个值。数组现在看起来像这样:- {15，11，16，12，18，14}。
*   现在，我们将对第 5 个索引和第 6 个索引元素做同样的操作。因为第 5 个索引元素是 18，第 6 个索引元素是 14。和 18>14，所以我们将交换这两个值。数组现在看起来像这样:- {15，11，16，12，14，18}。

第一次迭代后的数组如下:- {15，11，16，12，14，18}。最大的元素放在最后一个索引处。

为了对一个完全由 n 个元素组成的数组进行排序，我们需要重复这个过程 n-1 次。

# **我们可以用 C 程序来理解同样的过程。**

```
**#include<stdio.h>****void bubsort(int arr[], int n)****{****int t;****for (int i=0;i<n;i++)****{****for(int j = 0;j<n-i-1;j++)****{****if(arr[j]>arr[j+1])        //Swapping values of arr[j] & arr[j+1].****{****t = arr[j];****arr[j] = arr[j+1];****arr[j+1] = t;****}****}****}****printf(“Sorted array is :- “);****for(i=0;i<n;i++)****{****printf(“%d”,arr[i]);****}****}****int main()****{****int arr[100], n, temp, step;****printf(“Enter the number of elements of the array ”);****scanf(“%d”,&n);****printf(“Enter the elements of the array ”);****for(int i=0;i<n;i++)****{****scanf(“%d”,&arr[i]);****}****bubsort(arr,n);****return 0;****}**
```

冒泡排序的最佳时间复杂度为 O(n)。

最坏情况下的时间复杂度是 O(n)。

平均案例时间复杂度为 O(n)。

# 结束语:

在这篇文章中，我讨论了冒泡排序算法。如果你有任何疑问，请在下面的评论区告诉我，我很乐意帮助你。

非常感谢您阅读这篇文章。