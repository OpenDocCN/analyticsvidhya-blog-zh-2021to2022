<html>
<head>
<title>Build &amp; Deploy a Natural Language Processing(NLP) App with Spacy, Streamlit and Heroku</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Spacy、Streamlit和Heroku构建和部署自然语言处理(NLP)应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/build-deploy-a-natural-language-processing-nlp-app-with-spacy-streamlit-and-heroku-54e78468fad0?source=collection_archive---------1-----------------------#2021-08-03">https://medium.com/analytics-vidhya/build-deploy-a-natural-language-processing-nlp-app-with-spacy-streamlit-and-heroku-54e78468fad0?source=collection_archive---------1-----------------------#2021-08-03</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="2257" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated"><span class="l ix iy iz bm ja jb jc jd je di"> P </span>艺术一:如何用Streamlit、Spacy、TextBlob、Gensim、Sumy构建自然语言处理应用</h2></div><p id="dd12" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi kb translated"><span class="l ix iy iz bm ja jb jc jd je di"> T </span>这是关于如何构建和部署自然语言处理(NLP)应用的2部分教程的第一部分。在本教程中，我们将构建一个对基本自然语言处理任务有用的应用程序，如标记化、词条化、命名实体识别(NER)、情感分析器和文本摘要。</p><p id="422a" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">对于标记化和命名实体识别，我们将依赖于神奇的空间库。TextBlob是一个简单而强大的情感分析包，提供情感的极性和主观性，将用于我们的情感分析。此外，对于文本摘要，我们将使用Gensim和Sumy。最后，我们将使用Streamlit为我们的NLP应用程序增添一些光彩。让我们开始派对吧！</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/df764d506bc571bce44ad5ae8e6f4a82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pAWc12YoxTCtp-Aw-94ppg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">NLP应用程序</figcaption></figure><p id="03bd" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">术语、概念和包装的定义</strong></p><p id="c6c0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们从我们将在本教程中使用的重要术语、概念和包的简洁定义开始。</p><p id="d876" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">自然语言处理(NLP): 使用自然语言处理(NLP)可以增强计算机解释人类语言的能力。在人工智能的这个分支中，机器和人通过自然语言进行交互。语言阅读、解码、理解和解释是自然语言处理的最终目标。为了从人类语言中提取意义，大多数NLP技术依赖于机器学习。</p><p id="4fa6" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">标记化:</strong>标记化是将短语、句子、段落或整个文本文档分解成更小部分的过程，例如单个单词或短语。令牌是这些较小单元的名称。<br/>单词、数字或标点符号都可以用作记号。标记化通过定位单词边界来创建更小的单元。单词边界是一个单词的结束和下一个单词的开始。这些记号被认为是词干化和词元化的初步步骤。</p><p id="6f89" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">词干化&amp;词干化:</strong> <strong class="jh hj">词干化</strong>是一种原始的启发式程序，它切断单词的结尾，希望在大多数情况下成功地将一个单词简化为常见的基本形式，它经常包括去除派生词缀。<strong class="jh hj">词汇化</strong>通常是指通过使用词汇和单词的形态学分析来正确地做事情，目标是只删除屈折词尾，返回单词的基本形式或词典形式，这就是所谓的词汇。当遇到标记saw时，词干化可能只返回s，而词汇化可能返回see或saw，这取决于该标记是用作动词还是名词。</p><p id="a5ba" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">命名实体识别:</strong>命名实体识别是一种自然语言处理技术，可以自动扫描全文，提取文本中的一些基本元素并进行分类。通俗地说，命名实体识别就是从文本中提取命名实体的过程，比如人名、地名、公司名等等。</p><p id="e07b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj">情感分析:</strong>情感分析(也称为观点挖掘)是一种自然语言处理技术，用于确定输入是积极的、消极的还是中性的。它基本上包括分析和确定一篇文章、演讲或任何其他形式的交流背后的情感或意图。</p><p id="ef67" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> TextBlob: </strong>这是一个用于处理文本数据的Python (2和3)库。它提供了一个简单的API，用于深入研究常见的自然语言处理(NLP)任务，如词性标注、名词短语提取、<strong class="jh hj">情感分析</strong>、分类、翻译等等。更多内容请访问<a class="ae ks" href="https://textblob.readthedocs.io/en/dev/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">官方文档网站</em> </a></p><p id="91e0" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> SpaCy </strong> : spaCy是一个用于高级自然语言处理(NLP)的Python库。它是免费和开源的。更多内容请访问<a class="ae ks" href="https://spacy.io/usage/spacy-101" rel="noopener ugc nofollow" target="_blank"> <em class="kt">官方文档网站</em> </a></p><p id="5f24" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Sumy :一个简单的库和命令行工具，用于从HTML页面或纯文本中提取摘要信息。此外，该计划包括一个简单的文本摘要评估框架。更多<a class="ae ks" href="https://pypi.org/project/sumy/" rel="noopener ugc nofollow" target="_blank">阅读<em class="kt">这里</em>这里</a></p><p id="ff6e" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">Gensim :这是一个用于大型语料库主题建模、文档索引和相似性检索的Python库。目标受众是自然语言处理(NLP)和信息检索(IR)社区。在这里阅读更多<a class="ae ks" href="https://pypi.org/project/gensim/" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a></p><p id="c342" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated"><strong class="jh hj"> Streamlit </strong> : Streamlit是一个开源的Python工具包，用于为机器学习和数据研究创建和共享漂亮、独特的web应用。您可以在几分钟内创建和部署复杂的数据应用程序。在这里阅读更多<a class="ae ks" href="https://streamlit.io/" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a></p><p id="d28b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">唷！那是一篇很长的✍️作品</p><p id="9a92" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们进入技术层面，从第0行开始构建我们的NLP应用程序😎</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="250d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">软件包的安装</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lb"><img src="../Images/88789698cc34e0efdb84f3ec0710e7fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p9-TLt-b-SjDnOtkd9FqnA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">重要的包裹。在终端上运行每一行</figcaption></figure><p id="3b01" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经安装了所有重要的包，让我们创建一个包含所有应用程序代码的<em class="kt"> app.py </em>文件。要查看app.py的内容输出，我们将在终端中运行<strong class="jh hj"><em class="kt">streamlit run app . py</em></strong>。👨‍💻</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lc"><img src="../Images/ba9476a2036f26ac09aca19014da6335.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SW1DnNW3Lj_DvXXt4GJvfA.png"/></div></div></figure><p id="7bbc" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">让我们导入所有需要的包。您可以在文本编辑器中键入代码片段中的所有代码。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ld"><img src="../Images/37a6e3e00de23f375c2898f1b41581e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EutPczTzr-sl0_RNKJLXOw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">导入所需的包</figcaption></figure><p id="701d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们已经导入了包，让我们继续定义将在streamlit的main()函数中使用的函数。</p><p id="5d43" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将定义的第一个函数是文本摘要函数<em class="kt"> sumy_summarizer() </em>。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es le"><img src="../Images/d7e03e87fd4dbd9fcd1f767c4a45417a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YgVkM9LHWMcs2dvmmhUysw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">使用Sumy库进行总结</figcaption></figure><p id="a77d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来，让我们定义一个函数<em class="kt"> text_analyzer() </em>，它将被调用来分析文本输入并返回词条和标记。我们将在这个函数中利用Spacy库的能力。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lf"><img src="../Images/9c80034002124bf68d9f83b18ba549ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FoSTAHHeldLbXxPE4FoVpw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">记号和引理的函数</figcaption></figure><p id="f13d" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">注意<strong class="jh hj">line 2 @ ST . cache</strong>-Streamlit有一种缓存技术，可以确保您的应用程序即使在从web加载数据、处理海量数据集或进行昂贵的计算时也能保持高性能。这是通过使用<a class="ae ks" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank"> @st </a>完成的。缓存装饰器。当你使用<a class="ae ks" href="http://twitter.com/st" rel="noopener ugc nofollow" target="_blank"> @st </a>时。函数上的cache decorator，它通知Streamlit无论何时调用该函数，它都需要验证某些事情:</p><ol class=""><li id="6b4c" class="lg lh hi jh b ji jj jl jm jo li js lj jw lk ka ll lm ln lo bi translated">用来调用函数的输入参数</li><li id="a6e4" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">函数值中使用的任何外部变量</li><li id="269a" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">函数的主体</li><li id="4383" class="lg lh hi jh b ji lp jl lq jo lr js ls jw lt ka ll lm ln lo bi translated">在缓存函数中使用的任何函数的主体。</li></ol><p id="ecb7" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">如果这是Streamlit第一次以这种精确的组合和顺序看到这四个组件的确切值，它将执行该函数并将结果保存在本地缓存中。如果下次调用缓存的函数时这些组件都没有改变，Streamlit将简单地避免执行该函数，而是返回以前保存在缓存中的输出。在这里阅读更多<a class="ae ks" href="https://docs.streamlit.io/en/stable/caching.html" rel="noopener ugc nofollow" target="_blank"><em class="kt"/></a></p><p id="b0b9" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们的NLP应用程序的另一个功能是命名实体识别。让我们定义一个函数<em class="kt"> entity_analyzer() </em>来帮助提取文本数据中的实体。同样，我们将在这个函数中利用SpaCy的强大功能。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lu"><img src="../Images/766a4991cff258c2d16201e634cfdc7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cAart1Ukc3U23I17ibtwrg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">NER的功能</figcaption></figure><p id="6f12" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">太好了！我们已经定义了所有重要的函数。现在，让我们定义一个<em class="kt"> main() </em>函数，在这里我们将放置所有的逻辑并调用这些函数。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lv"><img src="../Images/3b893357b3deb8464433dc92bb27cce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfZiA6VR9SJD01JZkHRQcw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">main()函数</figcaption></figure><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lw"><img src="../Images/e9ed560801003f8bddff2acaabb670ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mhrpjnZ0U_8AAdD9PXpVoA.png"/></div></div></figure><p id="94d2" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在上面的代码片段中，我们使用streamlit库的title、subheader和markdown方法来声明应用程序的标题、subheader和markdown。这几行代码产生了下面的内容👇</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lx"><img src="../Images/aa1ca3789eae02f087d05fff55e81dc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YmvpaIWNGgiXl_AFFCPGnQ.png"/></div></div></figure><p id="e881" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们为summarizer特性编写代码。这将为Sumy summerizer调用我们的<em class="kt"> sumy_summarizer() </em>函数，并为gensim summerizer调用我们从Gensim导入的<em class="kt">summarize()</em>函数。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ly"><img src="../Images/2f581a984e582ecd9b406b539dd3517b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DFYevfoiDAyqDGA1ZyArFQ.png"/></div></div></figure><p id="9fa5" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">接下来是我们的情感分析器。这是我们将利用TextBlob的力量的部分。参见⬇️下面的片段</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lz"><img src="../Images/73cfef83ab516e5d7f8afcd8a1b4a148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XtF5RGv2o_zEcGB0D7D0bQ.png"/></div></div></figure><p id="dc9b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">越来越有意思了吧？我打赌是！😎Streamlit非常直观，易于使用。请务必查看<a class="ae ks" href="https://docs.streamlit.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank">官方文档</a>，了解更多关于这个强大工具的信息。</p><p id="30e4" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">好了，让我们为命名实体识别位编写代码。这是我们将调用我们的实体<em class="kt"> _analyzer() </em>函数的部分。这个函数接受一个文本，并返回一个包含单词及其命名实体的响应。参见片段👇</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ca"><img src="../Images/723b66c6c62a87d2c0dc088503bf670d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*629hh7afe1bTZMCrPV7qJA.png"/></div></div></figure><p id="ed33" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在，让我们为记号赋予器写代码。这部分我们将调用我们的<em class="kt"> text_analyzer() </em>函数。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ma"><img src="../Images/732b68a1a151e42b47ce26f00c6e8b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6MjBpQBAjMdy0tffHS5Gdw.png"/></div></div></figure><p id="e9b5" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">这还不是全部，让我们通过添加侧边栏来美化我们的web应用程序。在streamlit中实现侧边栏功能非常容易。参见下面的代码片段👇</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lw"><img src="../Images/aafe40f8abd61133032b56d0def110be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u0nKHz6jh8piEu8jIFq9DA.png"/></div></div></figure><p id="aaea" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">仅此而已！继续运行app.py，在浏览器中查看功能强大的应用程序。</p></div><div class="ab cl ku kv gp kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="hb hc hd he hf"><p id="0442" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">在本教程的第二部分，我将指导您使用Github和Heroku将第一个NLP应用程序部署到云的端到端过程。请注意第2部分！</p><p id="3e52" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">你可以在我的<a class="ae ks" href="https://github.com/lekanakin" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>上访问本教程使用的所有代码。</p><p id="e45b" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">您可以通过此链接与实时应用程序进行交互:<a class="ae ks" href="https://nlpapps.herokuapp.com" rel="noopener ugc nofollow" target="_blank">https://nlpapps.herokuapp.com</a></p><p id="8611" class="pw-post-body-paragraph jf jg hi jh b ji jj ij jk jl jm im jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">感谢阅读！</p></div></div>    
</body>
</html>