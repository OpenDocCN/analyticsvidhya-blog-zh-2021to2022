<html>
<head>
<title>Parsing PGN Chess Games With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python解析PGN象棋游戏</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/parsing-pgn-chess-games-with-python-68a2c199665c?source=collection_archive---------5-----------------------#2021-02-01">https://medium.com/analytics-vidhya/parsing-pgn-chess-games-with-python-68a2c199665c?source=collection_archive---------5-----------------------#2021-02-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="84ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我脑子里有几个分析国际象棋比赛位置的项目。它们都需要将大量的棋局收集成结构化的数据。<a class="ae jc" href="https://theweekinchess.com/twic" rel="noopener ugc nofollow" target="_blank">本周国际象棋</a>每周提供数千场比赛的记录。每周由一个文件组成，该文件采用<a class="ae jc" href="https://en.wikipedia.org/wiki/Portable_Game_Notation" rel="noopener ugc nofollow" target="_blank">便携式游戏符号</a> (PGN)，一种记录国际象棋游戏的纯文本格式。</p><p id="2d2f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我想分析成千上万的游戏，所以第一步是收集纯文本文件，并使用PGN文件的语法解析它们。</p><p id="6773" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你只是想让代码解析PGN，你可以跳到GitHub repo 。否则，请继续阅读。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/b5cbcad2bc3c9e4c16efaaa570102cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Su8IdymoOKrLVTRGnT9EBg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">照片由Sarah Pflug拍摄，用于CC0</figcaption></figure><h2 id="6433" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">PGN文件的语法</h2><p id="fd60" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">包括PGN在内的许多文本数据都遵循一种“语法”。PGN的语法包括成对的标签和字符串、游戏的移动和结果。重要的是，文本的外观是有规则的。例如，2021年芒努斯·卡尔森和乔丹·范·福雷斯特之间的比赛:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="5250" class="jt ju hh ku b fi ky kz l la lb">[Event "83rd Tata Steel Masters"]<br/>[Site "Wijk aan Zee NED"]<br/>[Date "2021.01.19"]<br/>[Round "4.1"]<br/>[White "Van Foreest,Jorden"]<br/>[Black "Carlsen,M"]<br/>[Result "1/2-1/2"]<br/>[WhiteTitle "GM"]<br/>[BlackTitle "GM"]<br/>[WhiteElo "2671"]<br/>[BlackElo "2862"]<br/>[ECO "C78"]<br/>[Opening "Ruy Lopez"]<br/>[Variation "Archangelsk (counterthrust) variation"]<br/>[WhiteFideId "1039784"]<br/>[BlackFideId "1503014"]<br/>[EventDate "2021.01.16"]</span><span id="16ed" class="jt ju hh ku b fi lc kz l la lb">1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O b5 6. Bb3 Bb7 7. d3 Be7 8. Nc3 O-O 9. a3 Nd4 10. Nxd4 exd4 11. Ne2 c5 12. Bg5 d5 13. Bxf6 Bxf6 14. Bxd5 Bxd5 15. exd5 Qxd5 16. Ng3 c4 17. Re1 Rae8 18. a4 Rxe1+ 19. Qxe1 cxd3 20. cxd3 bxa4 21. Qd1 Qb5 22. Ne4 Be7 23. Qc2 Rb8 24. Rxa4 Qxb2 25. Qxb2 Rxb2 26. g4 Rb6 27. Rxd4 Kf8 28. Rd7 Rg6 29. Kf1 Rxg4 30. Ra7 f5 31. Ng3 g6 32. Rxa6 Rh4 33. Kg2 Rd4 34. Ne2 Rxd3 35. Ng1 Rd7 36. Nf3 Kg7 37. h3 Bf6 38. Kg3 Rb7 39. Kg2 Re7 40. Ra5 Rc7 41. Rd5 Ra7 42. Rb5 Be7 43. Nd4 Rd7 44. Nf3 Rd6 45. Rb7 Kf6 46. Ra7 h6 47. Nh4 Bd8 48. Rh7 Rd2 49. Rxh6 Kg7 50. Rxg6+ Kh7 51. Nf3 Rxf2+ 52. Kxf2 Kxg6 53. Kg2 Kh5 54. Nd4 f4 55. Ne6 Bg5 56. Nxg5 Kxg5 57. Kf3 Kh4 58. Kxf4 Kxh3 1/2-1/2</span></pre><p id="02b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注释出现在括号中，以标记开始，后跟带引号的字符串。在注释之后，棋步按棋步编号列出，后面是白棋步，然后是黑棋步(代数符号中的<a class="ae jc" href="https://en.wikipedia.org/wiki/Algebraic_notation_(chess)" rel="noopener ugc nofollow" target="_blank">)。最后一个文本宣布结果，<code class="du ld le lf ku b">1-0</code>为白棋获胜，<code class="du ld le lf ku b">0-1</code>为黑棋，<code class="du ld le lf ku b">1/2-1/2</code>为平手。</a></p><p id="1a9c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将获取一个PGN条目的文件并解析它们。在计算机科学中，解析器组合子是一个高阶函数，它接受多个解析器并返回一个解析器。<a class="ae jc" href="https://en.wikipedia.org/wiki/Parser_combinator" rel="noopener ugc nofollow" target="_blank">这个主题很深奥</a>，但是要点是解析器组合子允许我们写出一个语法的解析树，并通过组合简单的解析器迭代地构建复杂的解析器。对于这个项目，我使用了由我的一个同事编写的用于解析的开源python库。</p><p id="4992" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从上面的文件中写出解析树非常简单。文件中的“条目”由两个块组成:“注释”块和“游戏”块。注释块是序列<code class="du ld le lf ku b">[</code>、<code class="du ld le lf ku b">TAG</code>、<code class="du ld le lf ku b">"</code>、<code class="du ld le lf ku b">STRING</code>、<code class="du ld le lf ku b">"</code>、<code class="du ld le lf ku b">]</code>的新行分隔列表。游戏是一个<code class="du ld le lf ku b">NUMBER.</code>、<code class="du ld le lf ku b">MOVE</code>、<code class="du ld le lf ku b">MOVE</code>的列表，后面跟着一个<code class="du ld le lf ku b">OUTCOME</code>。最后一步棋有些棘手，因为白棋可能比黑棋多走一步，但我们稍后会处理这个问题。最好把我们的语法想象成一棵树:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lg"><img src="../Images/ffbea9ad1e868ad141926ef9d5ffc7ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*jei4nFtMsddEww94J_i4Gw.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">PGN解析树(作者图片)</figcaption></figure><h2 id="5d3b" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">解析简单文本</h2><p id="7034" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">现在我们已经了解了语法，让我们试着解析底层的一个节点。我们将从注释开始，因为它们更简单。我们的目标是获取注释列表，并将它们转换成Python字典。</p><p id="9fae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将遍历这段代码的每一行:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="bcad" class="jt ju hh ku b fi ky kz l la lb"># Parse the " token<br/>quote = lit(r'"')</span><span id="f147" class="jt ju hh ku b fi lc kz l la lb"># Parse a sequence of unicode characters excluding spaces<br/>tag = reg(r'[\u0021-\u0021\u0023-\u005A\u005E-\u007E]+')</span><span id="4f11" class="jt ju hh ku b fi lc kz l la lb"># parse a sequence of unicode characters including spaces<br/>string = reg(r'[\u0020-\u0021\u0023-\u005A\u005E-\U0010FFFF]+')</span><span id="dc27" class="jt ju hh ku b fi lc kz l la lb"># An annotation is combines a tag, and a quoted string delimited<br/># by other characters. We only care about the tag and string.<br/>annotation = '[' &gt;&gt; tag &lt;&lt; ' ' &amp; (quote &gt;&gt; string &lt;&lt; quote) &lt;&lt; ']'</span><span id="e5e1" class="jt ju hh ku b fi lc kz l la lb"># Function to take a list of parsed annotations and convert to a<br/># dictionary<br/>def formatannotations(annotations):<br/>    return {ant[0]: ant[1] for ant in annotations}</span><span id="e86d" class="jt ju hh ku b fi lc kz l la lb"># The annotation block is a list of 0 or more annotations.<br/>annotations = repsep(annotation, '\n') &gt; formatannotations</span></pre><p id="16d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Parsita使用文字解析器和正则表达式解析器来完成繁重的工作。最简单的解析操作是匹配单个字符，即文字。我展示了两种方法:<code class="du ld le lf ku b">lit(r'"')</code>匹配一个引用；或者，parsita将接受一个Python字符串到解析器中，并将其作为文字处理。使用第二种技术解析括号。</p><p id="93c0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">parsita的强大功能来自我们在上面使用的五个解析器:</p><ul class=""><li id="0983" class="lh li hh ig b ih ii il im ip lj it lk ix ll jb lm ln lo lp bi translated"><code class="du ld le lf ku b">A &amp; B</code>:顺序解析器。匹配<code class="du ld le lf ku b">A</code>的解析器和<code class="du ld le lf ku b">B</code>的解析器。在列表中返回两者。</li><li id="ac0f" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><code class="du ld le lf ku b">A &gt;&gt; B</code>:丢弃左侧解析器。匹配同<code class="du ld le lf ku b">&amp;</code>。仅返回<code class="du ld le lf ku b">B</code>。</li><li id="c95a" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><code class="du ld le lf ku b">A &lt;&lt; B</code>:丢弃右解析器。反之亦然。</li><li id="2faa" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><code class="du ld le lf ku b">A &gt; function</code>:转换解析器。匹配解析器，然后将结果传递给函数。</li><li id="c8e6" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><code class="du ld le lf ku b">repsep(A)</code>:重复解析器。从0到N次匹配<code class="du ld le lf ku b">A</code>并返回匹配列表。</li></ul><p id="15ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，扩展定义注释的行:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="65cd" class="jt ju hh ku b fi ky kz l la lb">annotation = '[' &gt;&gt; tag &lt;&lt; ' ' &amp; (quote &gt;&gt; string &lt;&lt; quote) &lt;&lt; ']'</span></pre><p id="c179" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">注释按顺序排列:</p><ul class=""><li id="92c4" class="lh li hh ig b ih ii il im ip lj it lk ix ll jb lm ln lo lp bi translated">一个支架(丢弃)，</li><li id="ab1f" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">没有空格的字符串，</li><li id="a9ef" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">一个空格(丢弃)，</li><li id="6274" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">一个报价(丢弃)，</li><li id="f048" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">一根绳子，</li><li id="59e1" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">一个报价(丢弃)，</li><li id="e87e" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated">一个括号(丢弃)。</li></ul><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="4a51" class="jt ju hh ku b fi ky kz l la lb"># Call the parser --&gt; results in Success or Failure.<br/># .or_die() either gives the value of the success or raises an error</span><span id="7dce" class="jt ju hh ku b fi lc kz l la lb">print(annotation.parse('[parsing "is cool"]').or_die())<br/>&gt; ['parsing', 'is cool']</span><span id="5229" class="jt ju hh ku b fi lc kz l la lb"># Annotations block converts the text to a dict<br/>text = '''[parsing "is cool"]<br/>[second "line"]'''</span><span id="d6d0" class="jt ju hh ku b fi lc kz l la lb">print(annotations.parse(text).or_die())<br/>&gt; {'parsing': 'is cool', 'second': 'line'}</span></pre><h2 id="fa38" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">解析更复杂的文本</h2><p id="9e72" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">游戏形式比较复杂。它重用了注释解析的思想，但是需要两个额外的解析器:</p><ul class=""><li id="a4f0" class="lh li hh ig b ih ii il im ip lj it lk ix ll jb lm ln lo lp bi translated"><code class="du ld le lf ku b">A|B</code>:备选解析器。尝试匹配解析器<code class="du ld le lf ku b">A</code>，如果失败，则尝试解析器<code class="du ld le lf ku b">B</code>。</li><li id="87fc" class="lh li hh ig b ih lq il lr ip ls it lt ix lu jb lm ln lo lp bi translated"><code class="du ld le lf ku b">opt(A)</code>:可选解析器。尝试匹配解析器<code class="du ld le lf ku b">A</code>，如果成功，返回长度为一的列表中<code class="du ld le lf ku b">A</code>的值。如果失败，返回一个空列表。</li></ul><p id="99a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用另一种解析器来简化移动的定义:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="1522" class="jt ju hh ku b fi ky kz l la lb">nullmove = lit('--') # Illegal move rarely used in annotations<br/>longcastle = reg(r'O-O-O[+#]?')<br/>castle = reg(r'O-O[+#]?')<br/>regularmove = reg(r'[a-h1-8NBRQKx\+#=]+') # Matches more than just chess moves<br/>move = regularmove | longcastle | castle | nullmove</span></pre><p id="b59d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们用正则表达式解析器匹配“正则”移动。移动的代数符号引用1或2个方块，a-h是它们的文件，1-8是它们的等级。每件作品都有一个字母名称。对于捕获(<code class="du ld le lf ku b">x</code>)、检查(<code class="du ld le lf ku b">+</code>)、将死(<code class="du ld le lf ku b">#</code>)和提升(<code class="du ld le lf ku b">=</code>)还有额外的符号。其他的，非常规的移动是长城堡，城堡，和无效移动(很少遇到，但由于各种原因出现)。</p><p id="f258" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以，一个移动尝试匹配常规移动，如果失败，尝试匹配长城堡，然后城堡，最后无效移动。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="5e3a" class="jt ju hh ku b fi ky kz l la lb">def handleoptional(optionalmove):<br/>    if len(optionalmove) &gt; 0:<br/>        return optionalmove[0]<br/>    else:<br/>        return None</span><span id="5d0b" class="jt ju hh ku b fi lc kz l la lb">def formatgame(game):<br/>    return {<br/>        'moves': game[0],<br/>        'outcome': game[1]<br/>    }</span><span id="b86b" class="jt ju hh ku b fi lc kz l la lb">whitespace = lit(' ') | lit('\n')</span><span id="0b54" class="jt ju hh ku b fi lc kz l la lb">movenumber = (reg(r'[0-9]+') &lt;&lt; '.' &lt;&lt; whitespace) &gt; int</span><span id="b291" class="jt ju hh ku b fi lc kz l la lb">turn = movenumber &amp; (move &lt;&lt; whitespace) &amp; (opt(move &lt;&lt; whitespace) &gt; handleoptional)</span><span id="2e70" class="jt ju hh ku b fi lc kz l la lb"># Potential game outcomes<br/>draw = lit('1/2-1/2')<br/>white = lit('1-0')<br/>black = lit('0-1')<br/>outcome = draw | white | black</span><span id="ad65" class="jt ju hh ku b fi lc kz l la lb">game = (rep(turn) &amp; outcome) &gt; formatgame</span></pre><p id="6990" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要可选的解析器，因为游戏可能会在白棋移动后终止。当这种情况发生时，在PGN，文件有一个最终的移动号码，然后列出一个单一的移动。所以，我们语法的最后一个“转折”是可选的。如果返回的可选列表不为空，我们将它解析成对Python更有用的形式，否则返回<code class="du ld le lf ku b">None</code>。</p><h2 id="c052" class="jt ju hh bd jv jw jx jy jz ka kb kc kd ip ke kf kg it kh ki kj ix kk kl km kn bi translated">把所有的放在一起</h2><p id="bade" class="pw-post-body-paragraph ie if hh ig b ih ko ij ik il kp in io ip kq ir is it kr iv iw ix ks iz ja jb ha bi translated">剩下的工作就是下载一个PGN文件，并使用上述代码解析它。</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="bc9f" class="jt ju hh ku b fi ky kz l la lb">from parsita import *<br/>from parsita.util import constant<br/>import json</span><span id="7b8a" class="jt ju hh ku b fi lc kz l la lb"># Conversion functions<br/>def formatannotations(annotations):<br/>    return {ant[0]: ant[1] for ant in annotations}</span><span id="e8da" class="jt ju hh ku b fi lc kz l la lb">def formatgame(game):<br/>    return {<br/>        'moves': game[0],<br/>        'outcome': game[1]<br/>    }</span><span id="5146" class="jt ju hh ku b fi lc kz l la lb">def formatentry(entry):<br/>    return {'annotations': entry[0], 'game': entry[1]}</span><span id="d128" class="jt ju hh ku b fi lc kz l la lb">def handleoptional(optionalmove):<br/>    if len(optionalmove) &gt; 0:<br/>        return optionalmove[0]<br/>    else:<br/>        return None</span><span id="62f4" class="jt ju hh ku b fi lc kz l la lb"># PGN Grammar<br/>quote = lit(r'"')<br/>tag = reg(r'[\u0021-\u0021\u0023-\u005A\u005E-\u007E]+')<br/>string = reg(r'[\u0020-\u0021\u0023-\u005A\u005E-\U0010FFFF]+')</span><span id="2e2e" class="jt ju hh ku b fi lc kz l la lb">whitespace = lit(' ') | lit('\n')</span><span id="9667" class="jt ju hh ku b fi lc kz l la lb">annotation = '[' &gt;&gt; (tag) &lt;&lt; ' ' &amp; (quote &gt;&gt; string &lt;&lt; quote) &lt;&lt; ']'<br/>annotations = repsep(annotation, '\n') &gt; formatannotations</span><span id="becc" class="jt ju hh ku b fi lc kz l la lb">nullmove = lit('--') # Illegal move rarely used in annotations<br/>longcastle = reg(r'O-O-O[+#]?')<br/>castle = reg(r'O-O[+#]?')<br/>regularmove = reg(r'[a-h1-8NBRQKx\+#=]+') # Matches more than just chess moves<br/>move = regularmove | longcastle | castle | nullmove</span><span id="3ebb" class="jt ju hh ku b fi lc kz l la lb">movenumber = (reg(r'[0-9]+') &lt;&lt; '.' &lt;&lt; whitespace) &gt; int<br/>turn = movenumber &amp; (move &lt;&lt; whitespace) &amp; (opt(move &lt;&lt; whitespace) &gt; handleoptional)</span><span id="4955" class="jt ju hh ku b fi lc kz l la lb">draw = lit('1/2-1/2')<br/>white = lit('1-0')<br/>black = lit('0-1')<br/>outcome = draw | white | black</span><span id="5915" class="jt ju hh ku b fi lc kz l la lb">game = (rep(turn) &amp; outcome) &gt; formatgame</span><span id="273c" class="jt ju hh ku b fi lc kz l la lb">entry = ((annotations &lt;&lt; rep(whitespace)) &amp; (game &lt;&lt; rep(whitespace))) &gt; formatentry</span><span id="04eb" class="jt ju hh ku b fi lc kz l la lb">file = rep(entry)</span><span id="e09e" class="jt ju hh ku b fi lc kz l la lb"># Parse the file<br/>with open('twic1368.pgn', 'r') as f:<br/>    parsedoutput = file.parse(f.read()).or_die()</span></pre><p id="cca6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">解析后的输出是一个游戏列表。每个游戏的结构都是一样的:</p><pre class="je jf jg jh fd kt ku kv kw aw kx bi"><span id="b009" class="jt ju hh ku b fi ky kz l la lb">{<br/>  'annotations': {<br/>    'Event': 'Lozovatsky Mem A 2021',<br/>    'Site': 'Chelyabinsk RUS',<br/>    'Date': '2021.01.18',<br/>    'Round': '5.18',<br/>    'White': 'Mischuk,D',<br/>    'Black': 'Bryakin,M',<br/>    'Result': '1-0',<br/>    ...<br/>  },<br/> 'game': {<br/>   'moves': [<br/>      [1, 'd4', 'd5'],<br/>      [2, 'c4', 'c6'],<br/>      [3, 'Nc3', 'Nf6'],<br/>      ...<br/>   ],<br/>   'outcome': '1-0'<br/>  }<br/>}</span></pre><p id="22b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我要去寻找数以千计的象棋游戏的乐趣。</p></div></div>    
</body>
</html>