<html>
<head>
<title>Image Processing with Python: Applications in Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python图像处理:在机器学习中的应用</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-processing-with-python-applications-in-machine-learning-17d7aac6bc97?source=collection_archive---------3-----------------------#2021-01-30">https://medium.com/analytics-vidhya/image-processing-with-python-applications-in-machine-learning-17d7aac6bc97?source=collection_archive---------3-----------------------#2021-01-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="e740" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何使用图像处理技术为机器学习算法准备数据？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/8243eb3d98a74e36d6e4fc57b9f818d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k5_5dp-l2N7vQQbb"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">照片由<a class="ae jn" href="https://unsplash.com/@ashishjha?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Avinash Kumar </a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="fc87" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在这篇文章中，我们将逐步学习如何预处理和准备图像数据集，以提取可用于机器学习算法的可量化特征。</p><p id="362f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们开始吧。</p><p id="413f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">像往常一样，我们导入诸如<code class="du kk kl km kn b">numpy</code>、<code class="du kk kl km kn b">pandas</code>和<code class="du kk kl km kn b">matplotlib</code>之类的库。此外，我们从<code class="du kk kl km kn b">skimage</code>和<code class="du kk kl km kn b">sklearn</code>库中导入特定的函数。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="79ce" class="ks kt hi kn b fi ku kv l kw kx">import matplotlib.pyplot as plt<br/>import numpy as np<br/>import pandas as pd<br/>from glob import glob<br/>from skimage.io import imread, imshow<br/>from skimage.color import rgb2gray<br/>from skimage.measure import label, regionprops, regionprops_table<br/>from skimage.filters import threshold_otsu<br/>from skimage.morphology import area_closing, area_opening<br/>from sklearn.model_selection import train_test_split<br/>from sklearn.ensemble import RandomForestClassifier</span></pre><p id="e005" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">我们的目标是从每个样本中提取信息，用于我们的机器学习算法。让我们一步一步地解决这个问题吧！</p><h1 id="b10e" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤1:执行探索性数据分析(EDA) </strong></h1><p id="0d59" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">在构建机器学习算法时，EDA始终是必不可少的一部分。首先，您应该能够熟悉数据——它的结构、格式和细微差别。这对于确保您将概念化的项目方法适合手头的数据集是至关重要的。</p><p id="5502" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">对于这个项目，我们将使用的数据集是一组白色背景的干燥植物叶片标本<em class="lu">(图像使用许可由Gino Borja，AIM授予)</em>。该数据集中有三类植物叶子，例如plantA、plantB和plantC。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="ac74" class="ks kt hi kn b fi ku kv l kw kx">filepaths = glob('dataset/*.jpg')<br/>fig, axis = plt.subplots(1,len(filepaths), figsize=(16,8))<br/>for x, ax in zip(filepaths, axis.flatten()):<br/>    ax.imshow(imread(x))<br/>    ax.set_title(x.split('\\')[1])<br/>print("The shape of the image is:", imread(filepaths[0]).shape)</span><span id="fc9a" class="ks kt hi kn b fi lv kv l kw kx">&gt;&gt; The shape of the image is: (876, 637, 3)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lw"><img src="../Images/3784ffadbfe91b25adeccaf7815ceb4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rH-mpyCyRG4B5yLkCTJLdQ.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(原图由<em class="lx"> Gino Borja，AIM </em>提供)</figcaption></figure><p id="a6e0" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">请注意，每一类叶子都有其独特的特征。PlantA的特征是其叶体上的卷曲，PlantB的特征是其叶的粗糙边缘，PlantC的特征是其叶的圆形。</p><p id="027c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，请注意，即使数据是灰度的，图像仍然包含三个通道。然而，进一步检查，我们可以注意到，这三个渠道仅仅是彼此的副本。因此，我们可以通过分割数组或使用<code class="du kk kl km kn b">rgb2gray</code>函数来删除其他通道。</p><h1 id="cb60" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤2:应用图像二值化</strong></h1><p id="c235" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">根据EDA的发现，我们现在可以利用<code class="du kk kl km kn b">rgb2gray</code>函数将图像的三个通道转换为一个通道。之后，我们可以执行图像阈值处理来提取图像中的必要信息——在本例中是树叶。由于图像数据集是背景-前景图像的典型例子，我们可以利用Otsu的方法对图像进行阈值处理。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="07f4" class="ks kt hi kn b fi ku kv l kw kx">leaf = imread(filepaths[0])<br/>gray_leaf = rgb2gray(leaf)</span><span id="bb9b" class="ks kt hi kn b fi lv kv l kw kx">thresh = threshold_otsu(gray_leaf)<br/>binarized = gray_leaf &lt; thresh<br/>imshow(binarized)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/51440ce86828cf7d4ba3d611fd8decef.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*hBUgWO2A65jBT6Lg9__U9g.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(原图由<em class="lx"> Gino Borja，AIM </em>)</figcaption></figure><h1 id="ad9f" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤3:应用形态学运算</strong></h1><p id="f616" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">现在，你可能会问，如果图像看起来是干净的，为什么我们需要应用形态学操作？仍然执行形态学操作来去除图像中的噪声是一个很好的做法，尤其是在具有大量像素的图像中。请记住，单个像素噪声可能无法用肉眼看到，但它会影响您的图像分析！</p><p id="51ca" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">为了最小化物体形状的失真，我们将使用<code class="du kk kl km kn b">area_closing</code>和<code class="du kk kl km kn b">area_opening</code>形态学操作。我们应用<code class="du kk kl km kn b">area_closing</code>函数来填充感兴趣对象区域内的任何孔洞。在此数据集中，如果叶区域有损伤、卷曲或纤维，且其像素强度与叶身不同，<code class="du kk kl km kn b">area_closing</code>可能特别有用。之后，我们应用了<code class="du kk kl km kn b">area_opening</code>功能来去除图像背景中的噪声。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="3103" class="ks kt hi kn b fi ku kv l kw kx">closed = area_closing(binarized)<br/>opened = area_opening(closed)<br/>imshow(opened)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/32f74296e148c92ec2d5e75ef075151d.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*1b-ZJcAfZ4TYpVTb5E1fkg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(原图由<em class="lx"> Gino Borja拍摄，AIM </em>)</figcaption></figure><h1 id="c26f" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">第四步:使用连通分量标记每个区域</strong></h1><p id="b2d4" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">清洗数据集后，我们将利用连通分量的<code class="du kk kl km kn b">label</code>函数来识别图像的所有区域。然后，我们可以使用<code class="du kk kl km kn b">regionprops</code>函数从图像中的每个区域提取属性。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="8692" class="ks kt hi kn b fi ku kv l kw kx">label_im = label(opened)<br/>regions = regionprops(label_im)<br/>imshow(label_im)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ly"><img src="../Images/3068ce3248ef12817fcdb0c2bdf8906f.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*a4rIVR2o9ClwdzDYLsQrrg.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(原图由<em class="lx"> Gino Borja，AIM </em>提供)</figcaption></figure><p id="8657" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">注意每个区域有不同的颜色。每种颜色代表图像中的一个区域。这些区域分组的编号是从左到右，然后从上到下。此外，我们应该记住，label函数的结果数组中的第零个区域总是图像的背景。最后，在过滤区域时，我们将使用if-else语句。if-else语句中的两个条件是:不包括背景区域和面积可忽略的区域。</p><p id="5dcc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，让我们试着分别看看这些区域！</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="a00e" class="ks kt hi kn b fi ku kv l kw kx">masks = []<br/>bbox = []<br/>for num, x in enumerate(regions):<br/>    area = x.area<br/>    convex_area = x.convex_area<br/>    if num!=0 and x.area &gt;= 100: <br/>        masks.append(regions[num].convex_image)<br/>        bbox.append(regions[num].bbox)    <br/>count = len(masks)</span><span id="234a" class="ks kt hi kn b fi lv kv l kw kx">fig, axis = plt.subplots(4, int(count/4), figsize=(15,6))<br/>for ax, box, mask in zip(axis.flatten(), bbox, masks):<br/>    image  =  gray_leaf[box[0]:box[2], box[1]:box[3]] * mask<br/>    ax.imshow(image)<br/>    ax.axis('off')</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lz"><img src="../Images/af22bb08273046399d2139903abd38f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KfUkjjWa3_qaAS0gfS-Cg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(原图由<em class="lx"> Gino Borja拍摄，AIM </em>)</figcaption></figure><h1 id="093d" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">第五步:获取每个区域的属性</strong></h1><p id="bfcf" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">现在，可视化区域对于反检查图像处理步骤是否有效非常有用。然而，我们的目标是从这些区域中提取关键特征和属性！我们可以使用<code class="du kk kl km kn b">regionprops_table</code>函数轻松做到这一点，其中我们可以指定从区域中提取的属性。在这个数据集中，我们将使用以下可量化的属性:<br/> 1。<code class="du kk kl km kn b">area </code> —该区域的像素数。<br/> 2。<code class="du kk kl km kn b">convex_area </code> —凸包图像的像素数，它是包围该区域的最小凸多边形。<br/> 3。<code class="du kk kl km kn b">bbox_area </code> —包围盒的像素数。<br/> 4。<code class="du kk kl km kn b">major_axis_length </code>-椭圆长轴的长度与区域具有相同的归一化第二中心矩。<br/> 5。<code class="du kk kl km kn b">minor_axis_length </code> —椭圆短轴的长度与区域具有相同的归一化第二中心矩。<br/> 6。<code class="du kk kl km kn b">perimeter </code> —对象的周长，使用4-连接将轮廓近似为通过边界像素中心的线。<br/> 7。<code class="du kk kl km kn b">equivalent_diameter </code> —与区域面积相同的圆的直径。<br/> 8。<code class="du kk kl km kn b">mean_intensity </code>-该区域的平均强度值。9。<code class="du kk kl km kn b">solidity </code> —区域像素与凸包图像像素的比率。<br/> 10。<code class="du kk kl km kn b">eccentricity </code> —与区域具有相同二阶矩的椭圆的偏心率</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="7ab4" class="ks kt hi kn b fi ku kv l kw kx">properties = ['area','convex_area','bbox_area',<br/>              'major_axis_length', 'minor_axis_length', <br/>              'perimeter', 'equivalent_diameter',<br/>              'mean_intensity', 'solidity', 'eccentricity']<br/>pd.DataFrame(regionprops_table(label_im, gray_leaf, <br/>                               properties=properties)).head(10)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ma"><img src="../Images/640d6d21020bf89f55693f8c2afd8448.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xUHBNPL-Vo75GCU34sZQHA.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><h1 id="88ca" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">第六步:将所有步骤合并成一个功能</strong></h1><p id="9cf6" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">既然我们已经建立了步骤，并且检查了提取的数据是好的，我们现在可以将所有之前的步骤自动化到一个功能中。这对于快速提取机器学习算法中需要的特征特别有用。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="19f1" class="ks kt hi kn b fi ku kv l kw kx">def get_properties(name):<br/>    filepaths = glob('dataset/{}*.jpg'.format(name))<br/>    properties = ['area','convex_area',<br/>                 'bbox_area','major_axis_length', <br/>                 'minor_axis_length', 'perimeter',  <br/>                 'equivalent_diameter', 'mean_intensity',  <br/>                 'solidity', 'eccentricity']<br/>    dataframe = pd.DataFrame(columns=properties)<br/>    for file in filepaths:<br/>        grayscale = rgb2gray(imread(file))<br/>        threshold = threshold_otsu(grayscale)<br/>        binarized = grayscale &lt; threshold         <br/>        closed = area_closing(binarized, 1000)<br/>        opened = area_opening(closed, 1000)<br/>        labeled = label(opened)<br/>        regions = regionprops(labeled)<br/>        data = pd.DataFrame(regionprops_table(labeled, grayscale,<br/>                            properties=properties))<br/>        data = data[(data.index!=0) &amp; (data.area&gt;100)]<br/>        dataframe = pd.concat([dataframe, data])<br/>    return dataframe</span></pre><h1 id="3da1" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">第七步:收集特征数据框</strong></h1><p id="3efc" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">使用创建的<code class="du kk kl km kn b">get_properties</code>函数，我们现在可以收集图像中每个区域的特征和属性！一旦收集了属性，不要忘记输入这些属性的标签分类-这将作为机器学习算法的基础事实。</p><p id="a485" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">让我们提取plantA的数据帧。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="890f" class="ks kt hi kn b fi ku kv l kw kx">plantA = get_properties('plantA')<br/>plantA['type'] = 'plantA'<br/>print("The shape of the dataframe is: ", plantA.shape)<br/>plantA.head()</span><span id="d109" class="ks kt hi kn b fi lv kv l kw kx">&gt;&gt; The shape of the dataframe is:  (50, 11)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mb"><img src="../Images/860465930ff8f7f560986b39cc5d436e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vomb1xirBCulCc0msA3isg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><p id="6f94" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在，对于plantB。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="1367" class="ks kt hi kn b fi ku kv l kw kx">plantB = get_properties('plantB')<br/>plantB['type'] = 'plantB'<br/>print("The shape of the dataframe is: ", plantB.shape)<br/>plantB.head()</span><span id="b980" class="ks kt hi kn b fi lv kv l kw kx">&gt;&gt; The shape of the dataframe is:  (55, 11)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es mc"><img src="../Images/9c6672bd63724ef2afd8934846d38101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-4BVu-DPRq4CzNu8AgSRg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><p id="f7fc" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">最后，对于plantC。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="6bcf" class="ks kt hi kn b fi ku kv l kw kx">plantC = get_properties('plantC')<br/>plantC['type'] = 'plantC'<br/>print("The shape of the dataframe is: ", plantC.shape)<br/>plantC.head()</span><span id="2954" class="ks kt hi kn b fi lv kv l kw kx">&gt;&gt; The shape of the dataframe is:  (53, 11)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es md"><img src="../Images/6ab98f6820ccb540051a5b83a6c2e751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xg2IrBFjwWQb3ptPZNr52w.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><p id="d4ad" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们已经收集了数据集中每个对象的属性，让我们将这些信息合并到一个数据帧中！</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="1997" class="ks kt hi kn b fi ku kv l kw kx">df = pd.concat([plantA, plantB, plantC])</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es me"><img src="../Images/d4f45c5bbf1a738b800c74c366267ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjnakPx1xx6d0_nd0bDMXg.png"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><h1 id="2f61" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤8:应用特征工程</strong></h1><p id="cb2d" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">从提取的特征中，我们可以通过导出新的特征来进一步扩展特征。这可以通过将提取的特征的比率放在一起很容易地完成。让我们试试这个！</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="2a1f" class="ks kt hi kn b fi ku kv l kw kx">df['ratio_length'] = (df['major_axis_length'] / <br/>                      df['minor_axis_length'])<br/>df['perimeter_ratio_major'] = (df['perimeter'] /  <br/>                               df['major_axis_length'])<br/>df['perimeter_ratio_minor'] = (df['perimeter'] /<br/>                               df['minor_axis_length'])<br/>df['area_ratio_convex'] = df['area'] / df['convex_area']<br/>df['area_ratio_bbox'] = df['area'] / df['bbox_area']<br/>df['peri_over_dia'] = df['perimeter'] / df['equivalent_diameter']</span><span id="68d2" class="ks kt hi kn b fi lv kv l kw kx">final_df = df[df.drop('type', axis=1).columns].astype(float)<br/>final_df = final_df.replace(np.inf, 0)<br/>final_df['type'] = df['type']</span></pre><p id="aed8" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">通过这样做，我们能够将我们的数据框架扩展到17个特性！</p><h1 id="8eb4" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤9:拆分训练和测试集</strong></h1><p id="2acb" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">下一步是从图像数据上提取和导出的特征的数据帧中分割数据。这对于确保机器学习模型将具有一组“看不见的”数据以确保训练不会过拟合或欠拟合是至关重要的。我们使用<code class="du kk kl km kn b">sklearn.model_selection</code>库中的<code class="du kk kl km kn b">train_test_split</code>函数来完成这项工作。此外，我们也不会使用任何数据不平衡处理技术，因为每个类的实例数量彼此大致相等。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="f897" class="ks kt hi kn b fi ku kv l kw kx">X = final_df.drop('type', axis=1)<br/>y = final_df['type']</span><span id="2a55" class="ks kt hi kn b fi lv kv l kw kx">X_train, X_test, y_train, y_test = train_test_split(X, y, <br/>                                         test_size=0.25, <br/>                                         stratify = y, <br/>                                         random_state=1337)</span></pre><h1 id="aab3" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">步骤10:训练随机森林分类器模型</strong></h1><p id="38cc" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">使用训练数据集，我们现在可以训练机器学习分类器模型。我们将使用随机森林分类器，因为众所周知，尽管它的算法很简单，但它可以产生很高的准确性。请注意，由于随机森林模型是基于树的模型，我们不需要缩放数据集。但是，如果您将使用其他机器学习模型，则必须缩放数据集的要素。</p><pre class="iy iz ja jb fd ko kn kp kq aw kr bi"><span id="a841" class="ks kt hi kn b fi ku kv l kw kx">RF = RandomForestClassifier(max_depth=6, n_estimators=100)<br/>RF.fit(X_train, y_train)<br/>y_pred_RF= RF.predict(X_test)</span><span id="daac" class="ks kt hi kn b fi lv kv l kw kx">df = pd.DataFrame()</span><span id="4c14" class="ks kt hi kn b fi lv kv l kw kx">cols = ['Machine Learning Classification Method',<br/>        'Train Accuracy', <br/>        'Test Accuracy', <br/>        "Top 1 Feature Predictor",<br/>        "Top 2 Feature Predictor",<br/>        "Top 3 Feature Predictor",<br/>        "Top 4 Feature Predictor",<br/>        "Top 5 Feature Predictor"]</span><span id="f139" class="ks kt hi kn b fi lv kv l kw kx">df.loc['Machine Learning Classification Method', <br/>       'Details'] = 'Random Forest Classifier'<br/>df.loc['Train Accuracy', 'Details'] = RF.score(X_train, y_train) <br/>df.loc['Test Accuracy', 'Details'] = RF.score(X_test, y_test)</span><span id="9261" class="ks kt hi kn b fi lv kv l kw kx">importances = (X.columns[np.argsort(RF.feature_importances_)][-5:])<br/>df.loc['Top 1 Feature Predictor', 'Details'] = importances[4]<br/>df.loc['Top 2 Feature Predictor', 'Details'] = importances[3]<br/>df.loc['Top 3 Feature Predictor', 'Details'] = importances[2]<br/>df.loc['Top 4 Feature Predictor', 'Details'] = importances[1]<br/>df.loc['Top 5 Feature Predictor', 'Details'] = importances[0]</span><span id="47f1" class="ks kt hi kn b fi lv kv l kw kx">display(df)</span></pre><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es mf"><img src="../Images/845e809ee3d42187db4f139120e9efca.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*i_LZ6941BK88n2P-KErvJQ.png"/></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">(图片由作者提供)</figcaption></figure><p id="ead2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">随机森林分类器产生的<strong class="jq hj">测试准确率为90.00% </strong>。对不同叶子进行分类的主要特征是它们的<code class="du kk kl km kn b">mean_intensity</code>、<code class="du kk kl km kn b">area_ratio_convex</code>、<code class="du kk kl km kn b">solidity</code>、<code class="du kk kl km kn b">perimeter_ratio_major</code>和<code class="du kk kl km kn b">peri_over_dia</code>。</p><p id="5cbe" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">回到我们在EDA中的最初发现，我们可以解释为什么<code class="du kk kl km kn b">mean_intensity</code>是第一大预测因子，因为我们之前已经发现植物可以通过其叶子的卷曲来识别。抖动很容易反映在物体的像素强度上。</p><p id="720d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">此外，面积和凸起面积之间的比率是前2个预测因素，因为我们已经确定plantB具有粗糙的边缘，而plantC具有圆形的边缘。因此，plantB自然会有一个较低的数字，而plantC会有一个大约等于1的<code class="du kk kl km kn b">area_ratio_convex</code>。</p><p id="7a6c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">太棒了，对吧？一个既准确又可解释的模型！至此，我希望您能够认识到图像处理技术对于实现更具解释性的机器学习算法的重要性！</p><h1 id="d0ef" class="ky kt hi bd kz la lb lc ld le lf lg lh io li ip lj ir lk is ll iu lm iv ln lo bi translated"><strong class="ak">总之</strong></h1><p id="b380" class="pw-post-body-paragraph jo jp hi jq b jr lp ij jt ju lq im jw jx lr jz ka kb ls kd ke kf lt kh ki kj hb bi translated">我们已经探索了如何使用图像处理技术来准备和预处理图像数据集，以实现机器学习算法。使用<code class="du kk kl km kn b">regionprops_table</code>功能，我们能够从图像中提取有价值的和可量化的特征。最后，我们开发了一个分类器模型，实现了高精度，同时也是可解释的。</p><p id="2e48" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><em class="lu">想了解更多？在此</em> <a class="ae jn" href="https://github.com/jephraim-manansala/iip-machine-learning" rel="noopener ugc nofollow" target="_blank"> <em class="lu">链接</em> </a> <em class="lu">查看我的GitHub库！</em></p></div></div>    
</body>
</html>