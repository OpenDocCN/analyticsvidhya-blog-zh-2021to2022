<html>
<head>
<title>Recursion: to the end of the stack, and back-</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归:到堆栈的末尾，然后返回-</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-to-the-end-of-the-stack-and-back-8bed3692e397?source=collection_archive---------17-----------------------#2021-02-22">https://medium.com/analytics-vidhya/recursion-to-the-end-of-the-stack-and-back-8bed3692e397?source=collection_archive---------17-----------------------#2021-02-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div class="er es if"><img src="../Images/b7248fb8c3b16ca72ab30ff9bd59bef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*dOQ6mFgFvt4AQCW2WgjZAA.jpeg"/></div></figure><p id="fae4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">作为一名程序员，你可以拥有的最关键的属性之一就是优化。在编程中，这可以通过各种各样的方式付诸实践，你结合得越多，你就越能成为一名优秀的程序员。</p><p id="62cd" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">一些推荐的优化实践包括能够用尽可能少的词语解释算法并使其通过，尽可能清晰并有教育意义的白板，以及防止过度使用系统内存的高效编码。对于小程序来说，总运行时间可能不是问题，但是对于大程序来说，如果代码使系统变大并且运行缓慢，这可能会成为一个麻烦——也就是说不是最佳的。</p><p id="98ea" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有效的编码包括许多实践，但是一个非常值得注意的是不要滥用循环。一些嵌套循环是可以的，但是当有一个太多的时候，那么优化雷达可能会滴答作响。你能用什么来代替循环呢？你猜对了，用<strong class="io hj">递归</strong>。</p><p id="3f5a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就这样，亲爱的读者们，让我们直接进入让我们来到这个博客的主题。</p><h1 id="2e46" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">递归</h1><p id="b48b" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">由<a class="ae ko" href="https://www.google.com/search?client=ms-android-samsung-gs-rev1&amp;sxsrf=ALeKk00W_Ch9bA0obZ2b3DBOwLpwTabv4w%3A1613924119539&amp;ei=F4cyYM6rIP6_5OUP7662wA4&amp;q=define+recursion&amp;oq=define+recursion&amp;gs_lcp=ChNtb2JpbGUtZ3dzLXdpei1zZXJwEAMyBAgjECcyBQgAEMsBMgUIABDLATIFCAAQywEyBQgAEMsBMgUIABDLATIFCAAQywEyBQgAEMsBOgQIABBHUKUPWJoVYKRJaABwAXgAgAHLB4gBlg-SAQM2LTKYAQCgAQHIAQjAAQE&amp;sclient=mobile-gws-wiz-serp" rel="noopener ugc nofollow" target="_blank">定义</a>，递归是:</p><blockquote class="kp kq kr"><p id="f57e" class="im in jk io b ip iq ir is it iu iv iw ks iy iz ja kt jc jd je ku jg jh ji jj hb bi translated">递归过程或定义的重复应用。</p></blockquote><p id="abfe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">有趣的是，在它自己的定义中，递归使用了递归这个词。这本身就是概念本身的定义，并使其不言自明。因为换句话说，把它与编程联系起来，递归指的是调用自身的函数或过程。</p><p id="64a4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">它的工作方式是一个函数，在这个函数内部，这个函数被再次调用。</p><p id="3973" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">递归函数<strong class="io hj">必须至少有两个条件才能正常工作:</strong></p><ul class=""><li id="8579" class="kv kw hi io b ip iq it iu ix kx jb ky jf kz jj la lb lc ld bi translated">基本情况</li><li id="2050" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">互动/增加/减少</li></ul><h1 id="6de0" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">基础案例:</h1><p id="30d9" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">与循环一样，递归函数需要一个基本情况，也称为退出条件，以防止无限循环。付诸实践，这意味着该函数将被调用，直到达到该条件。然后它会开始递归，我们一会儿会讲到。</p><h1 id="3350" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">迭代:</h1><p id="4c2d" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">与循环一样，每次调用递归函数时，至少有一个参与变量必须发生变化，以便更接近基本情况。如果没有变化，那么就会实现无限循环。</p><p id="ffbe" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">要进一步解释这个概念，没有比付诸实践更好的方法了。看一下下面的代码:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="dd3f" class="ls jm hi lo b fi lt lu l lv lw">float _pow_recursion(float x, float y)<br/>{<br/>      if (y == 0)<br/>           return (1);<br/>      if (y &lt; 0)<br/>           return (_pow_recursion(x, y + 1) / x);<br/>      return (_pow_recursion(x, y - 1) * x);<br/>}</span></pre><p id="cc61" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">乍一看，它看起来像一个普通的短函数，但是仔细看，我们可以看到在函数内部，同样的函数被再次调用。</p><p id="eddf" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是一个递归函数的例子。这个函数接收两个浮点数，<code class="du lx ly lz lo b">x</code>和<code class="du lx ly lz lo b">y</code>，并计算<code class="du lx ly lz lo b">x</code>的结果到<code class="du lx ly lz lo b">y</code>的幂。</p><p id="9f32" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">对于循环，这可以通过以下方式解决:</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="9bfc" class="ls jm hi lo b fi lt lu l lv lw">int pow(x, y)<br/>{<br/>     int i, result = x;<br/>     for (i = 0; i &lt;= y; i++)<br/>     {<br/>         result  * = 2<br/>     }<br/>     return (result)<br/>}</span></pre><p id="a14a" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这是正确的，并且仅适用于正数，除非添加了边缘情况。然后，应该添加另一个循环，以防数字为负。首先，我们已经有两个循环来计算一个数的另一个幂。似乎有点多，是吧？</p><p id="b7b6" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">顶部的解决方案比T4更有效，因此更可取。由于递归是一个复杂的概念，尽管它看起来很复杂，但也很重要，我们将把它分解成几个步骤，并解释后台发生的事情，以进一步理解解决方案，并可能更容易将其付诸实践。</p><h1 id="7409" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">堆起来</h1><p id="2509" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">为了充分理解递归是如何工作的，我们必须理解堆栈。</p><p id="4b17" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">堆栈是指有序、有组织的“一堆”东西。想象一堆乐高积木。</p><p id="b269" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">在一个系统中，堆栈指的是一种数据结构，在这种结构中，数据项以有序的方式放置，并且由于它们存储的方式是有组织的，所以在任何时候内存中的地址都是已知的。这个系统堆栈是在堆之外使用的，它暂时存储正在执行的子程序的信息，直到轮到它们被执行。存储每个子程序的“乐高”块被称为<strong class="io hj">堆栈框架</strong>。项目被“推入”堆栈中，就像您将一堆乐高积木“推入”堆栈一样，并以同样的方式“弹出”。顺序是后进先出。这意味着要堆叠的第一个项目是最后一个要移除的项目。同样，最后添加的是第一个删除的。</p><p id="ae30" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">这可以在下面的GIF中说明:</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/53a4f591f235f5b05cdac20342a7520c.png" data-original-src="https://miro.medium.com/v2/resize:fit:684/1*KEgz_E0IqKXEIWaX0ss08g.gif"/></div></figure><p id="cb3b" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">黑色的边界不能被侵入，这意味着物品只能通过顶部的开口进出。考虑到这一点，我们可以进一步理解这个系统是如何工作的，这对理解将要发生的事情是极其重要的。</p><h1 id="fb37" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">这和递归有什么关系？</h1><p id="72a7" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">嗯，一切！我们之前说过递归是一个调用自身的函数。从系统角度来说，这意味着调用了该函数的另一个实例，而第一个实例仍在运行，这意味着第一个实例没有完成执行。函数将在彼此内部被反复调用，直到到达出口情况。当这种情况发生时，会有大量“开放”的功能等待完成。这些实例或子例程中的每一个都将暂时存储在一个堆栈框架中。一旦轮到他们完成执行，他们将离开堆栈，然后轮到下面的实例被执行，这样继续下去，直到堆栈中不再有子程序，因此程序结束。</p><h1 id="54a5" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">让我们再来看看这个例子:</h1><p id="e9da" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">在查看了示例并理解了堆栈如何处理递归之后，我们现在可以一步一步地分解示例并理解它。</p><pre class="lj lk ll lm fd ln lo lp lq aw lr bi"><span id="7b99" class="ls jm hi lo b fi lt lu l lv lw">float _pow_recursion(float x, float y)<br/>{<br/>      if (y == 0)<br/>           return (1);<br/>      if (y &lt; 0)<br/>           return (_pow_recursion(x, y + 1) / x);<br/>      return (_pow_recursion(x, y - 1) * x);<br/>}</span></pre><p id="a10f" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">所以，我们知道的是:</p><ul class=""><li id="1d31" class="kv kw hi io b ip iq it iu ix kx jb ky jf kz jj la lb lc ld bi translated">这是一个返回<code class="du lx ly lz lo b">float</code>的函数，它被称为<code class="du lx ly lz lo b">_pow_recursion</code>(提示它将做什么)，它接收两个浮点，<code class="du lx ly lz lo b">x</code>和<code class="du lx ly lz lo b">y</code>。</li><li id="938e" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">如果<code class="du lx ly lz lo b">y</code>等于0，那么函数返回1。</li><li id="42f8" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">如果<code class="du lx ly lz lo b">y</code>小于零，该函数使用相同的<code class="du lx ly lz lo b">x</code>再次调用自身，并将<code class="du lx ly lz lo b">y</code>加1。它将继续这样做，直到<code class="du lx ly lz lo b">y = 0</code>的退出情况，然后返回到每个子程序并除以<code class="du lx ly lz lo b">x</code>。</li><li id="4006" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">如果<code class="du lx ly lz lo b">y</code>大于0，那么该函数将再次使用相同的<code class="du lx ly lz lo b">x</code>调用自身，并从<code class="du lx ly lz lo b">y</code>减去1，直到到达<code class="du lx ly lz lo b">y = 0</code>的退出情况，然后对于保存在堆栈上的每个子例程中的每个返回值，通过乘以<code class="du lx ly lz lo b">x</code>返回。</li><li id="1b65" class="kv kw hi io b ip le it lf ix lg jb lh jf li jj la lb lc ld bi translated">最终返回值将是<code class="du lx ly lz lo b">x</code>对<code class="du lx ly lz lo b">y</code>的幂的结果。</li></ul><p id="9c29" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">让我们关注于<code class="du lx ly lz lo b">x</code>和<code class="du lx ly lz lo b">y</code>都有两个正值的情况。还有什么比用另一张GIF更好的方式来说明这个功能呢？</p><figure class="lj lk ll lm fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/9b021e9ad3e78046e5f3b44015c6ab29.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*dWze93zL6Yp0hKnWWK__1A.gif"/></div></figure><p id="db70" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">需要看多少遍就看多少遍，解释完后再回头参考。<br/>我们将从值<code class="du lx ly lz lo b">x = 2</code>和<code class="du lx ly lz lo b">y = 6</code>开始，因此这个函数将计算<code class="du lx ly lz lo b">2</code>的值到<code class="du lx ly lz lo b">6</code>的幂。</p><p id="4cc9" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">首先在右边你会看到代码，值进入函数的部分会用不同的颜色突出显示。每种颜色代表一个不同的堆栈框架，它将显示在GIF的左侧，以相应的颜色和顺序存储每个函数调用的值。一旦到达exit case，回调就开始，每个回调都用自己的颜色计算返回值，直到遍历完每个堆栈帧，程序以最终结果结束。</p><p id="ad28" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">如前所述，函数以值<code class="du lx ly lz lo b">x = 2</code>和<code class="du lx ly lz lo b">y = 6</code>进入。<code class="du lx ly lz lo b">y</code>不为0，也不小于0，所以函数直接进入最后一个<code class="du lx ly lz lo b">return</code>。在返回之前，再次调用函数，因此我们的第一个子例程存储在第一个堆栈帧中。<code class="du lx ly lz lo b">* x</code>仍然是待定的，但是因为函数被调用了，所以剩余的乘法留给函数的回调。</p><p id="4ed4" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">就这样继续下去，<code class="du lx ly lz lo b">y = 5</code>、<code class="du lx ly lz lo b">y = 4</code>、<code class="du lx ly lz lo b">y = 3</code>、<code class="du lx ly lz lo b">y = 2</code>和<code class="du lx ly lz lo b">y = 1</code>，每次调用函数时，在每个堆栈帧中保存一个函数调用。最后，当<code class="du lx ly lz lo b">y = 0</code>时，功能不会转到第二个<code class="du lx ly lz lo b">return</code>，而是到达出口箱和<code class="du lx ly lz lo b">return 1</code>。这是回调开始的时候，按照我们之前看到的后进先出顺序。</p><p id="4204" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">1被返回到先前的回调，并且<code class="du lx ly lz lo b">* x</code>仍然被该函数调用挂起。因为<code class="du lx ly lz lo b">x = 2</code>，返回值将被乘以2，以完成函数的挂起部分。因此，在乘法运算之后，函数调用将<code class="du lx ly lz lo b">return 2</code>到先前的回调。并且对于每一步都将如此继续，总是乘以2，因为它是<code class="du lx ly lz lo b">x</code>的值，并且它从不改变。因此<code class="du lx ly lz lo b">2 * 2 = 4</code>、<code class="du lx ly lz lo b">4 * 2 = 8</code>、<code class="du lx ly lz lo b">8 * 2 = 16</code>、<code class="du lx ly lz lo b">16 * 2= 32</code>、<code class="du lx ly lz lo b">32 * 2 = 64</code>，并且由于这最后一个是堆栈的最后一帧，因此也是最后一个等待完成递归的子例程，因此将返回值<code class="du lx ly lz lo b">64</code>，并且程序将被完成。</p><h1 id="9fd4" class="jl jm hi bd jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki bi translated">还有那个*戏剧性的停顿*…。递归…*拍手鞠躬*</h1><p id="9878" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">乍一看，这似乎很难理解，但是就像生活中的所有事情一样，熟能生巧，只有将它付诸实践，程序员才能完善这种方法，并更好地应用它。</p><p id="928c" class="pw-post-body-paragraph im in hi io b ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj hb bi translated">我希望这篇文章和动画能让你更容易理解。递归无疑是编程中最有趣和最有用的特性之一，它不仅高效，而且几乎可以代替任何循环。尝试在一个函数中至少应用一次递归，然后在同一个函数中可能不止一次…？*神魂颠倒*</p></div><div class="ab cl mc md gp me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="hb hc hd he hf"><h1 id="e2b5" class="jl jm hi bd jn jo mj jq jr js mk ju jv jw ml jy jz ka mm kc kd ke mn kg kh ki bi translated">附赠曲目</h1><p id="f673" class="pw-post-body-paragraph im in hi io b ip kj ir is it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj hb bi translated">你知道递归不仅仅是编程的专利吗？在我们的日常生活和自然界中，有许多递归的例子。如果你想出了任何例子，请在下面留下评论！<br/>递归狩猎快乐！:)</p></div></div>    
</body>
</html>