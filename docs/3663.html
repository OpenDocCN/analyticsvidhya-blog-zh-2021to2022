<html>
<head>
<title>Image Input Pipeline Using Tensorflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用张量流的图像输入管道</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-input-pipeline-using-tensorflow-c9f729ead09f?source=collection_archive---------6-----------------------#2021-07-16">https://medium.com/analytics-vidhya/image-input-pipeline-using-tensorflow-c9f729ead09f?source=collection_archive---------6-----------------------#2021-07-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/ee6a94a8d8398db32378356017fb4c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D3bKDJ4BTz6YcbUP2M11Nw.png"/></div></div></figure><p id="6b0e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">关于如何使用tf.data API为图像数据集创建输入管道的简单方法</p><h1 id="6995" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">介绍</h1><p id="edc7" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">嘿大家好，</p><p id="43d7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是我上一篇文章的延伸，也是将获得的知识应用于图像数据集的动手实践指南(理论部分)。</p><p id="e735" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们使用的数据集是一个简单的数据集，最常用于演示目的——狗和猫的数据集(参考链接)。然而，在这里您也可以使用一个非常好的扩展来为您创建数据集。</p><h1 id="bf55" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">创建数据集</h1><p id="1097" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">因此，我已经形成的数据集可以使用名为“<a class="ae kq" href="https://chrome.google.com/webstore/detail/fatkun-batch-download-ima/nnjjahlikiabnchcpehcpkdeckfgnohf?hl=en" rel="noopener ugc nofollow" target="_blank"> Fatkun批量下载图像</a>”的扩展来创建。要使用，请遵循以下步骤:</p><p id="9adc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">-&gt; install the application</strong></code></p><p id="0117" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">-&gt; open the images page</strong></code></p><p id="7a17" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">-&gt; Start the application</strong></code></p><p id="609d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">-&gt; Hit Current Tab &amp; Hit the download button</strong></code>。</p><p id="712a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="kv">确保将图像下载到单独的文件夹中，如果没有，建议将它们分别放入文件夹中:</em></p><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es kw"><img src="../Images/e92b9395f42cff2b87de231cb0e09590.png" data-original-src="https://miro.medium.com/v2/resize:fit:360/format:webp/1*WRCZjpV_ZUdhfu6tZyhL-Q.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">单独的文件夹</figcaption></figure><h1 id="7c93" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">正在加载数据集</h1><p id="23b8" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">现在在输入管道中，我们有了<code class="du kr ks kt ku b"> <strong class="ir hi">tf.data.Dataset.list_files(filepath)</strong></code>，它将帮助我们<em class="kv">从目录中加载文件路径</em>。</p><p id="f5ed" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因此，我们可以将数据加载为:</p><p id="759c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">&gt;我们从<strong class="ir hi"> GitHub </strong>加载数据</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="e4c2" class="lj jo hh ku b fi lk ll l lm ln"># loading from github<br/>!git clone ‘https://github.com/DevloperHS/Dockship---Utility.git'</span></pre><p id="527f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">注意:我一直在使用collab并从GitHub导入我的文件，所以路径可能会改变，但整体结构将保持不变:)</strong></p><p id="c25e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">&gt;导入模块</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="139a" class="lj jo hh ku b fi lk ll l lm ln"># importing modules</span><span id="be9e" class="lj jo hh ku b fi lo ll l lm ln">import tensorflow as tf<br/>import numpy</span></pre><p id="1b0c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">&gt;加载文件</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="dcd6" class="lj jo hh ku b fi lk ll l lm ln">image_ds = tf.data.Dataset.list_files('/content/Dockship---Utility/Tf Input Pipeline/images/*/*', shuffle = 'False')</span><span id="6648" class="lj jo hh ku b fi lo ll l lm ln"># view the files<br/>for i in image_ds.take(5):<br/>print(i.numpy())</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lp"><img src="../Images/828ea5d16e6fab61fad0e68b34bf0745.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5mwNvzFDB212SWFOS2IuDw.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">仅包括文件路径</figcaption></figure><p id="f34b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可以看出，现在<code class="du kr ks kt ku b"><strong class="ir hi">image_ds</strong></code>只包含文件路径，不包含实际文件。但是过一会儿，我们将看到如何加载实际的图像。</p><h1 id="1348" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">预处理</h1><p id="bedd" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">任何图像分析的一般步骤都是将原始数据预处理成可以理解的东西，在这一节中，我们将了解如何对数据集应用一些预处理步骤。</p><h2 id="6032" class="lj jo hh bd jp lq lr ls jt lt lu lv jx ja lw lx kb je ly lz kf ji ma mb kj mc bi translated">洗牌</h2><p id="dc81" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">一般来说，为了保持我们的数据集中没有偏见，我们对数据集进行混洗。这可以通过使用<code class="du kr ks kt ku b"><em class="kv">shuffle()</em></code>方法实现，如下所示:</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="404c" class="lj jo hh ku b fi lk ll l lm ln">image_ds = image_ds.shuffle(200)</span><span id="8ee4" class="lj jo hh ku b fi lo ll l lm ln">#view files<br/>for i in image_ds.take(5):<br/>    print(i.numpy())</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/2444f3ba34100b2cbf5c8d1e7b3772c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SV_MLj04jnsyIal1QWflVg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">混洗数据集</figcaption></figure><h2 id="1906" class="lj jo hh bd jp lq lr ls jt lt lu lv jx ja lw lx kb je ly lz kf ji ma mb kj mc bi translated">剧烈的</h2><p id="91ed" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">为了创建模型所需的数据，我们需要将数据集分为训练和测试两部分。通常，我们使用<code class="du kr ks kt ku b">train_test_split</code>，但是当我们在<code class="du kr ks kt ku b">tensorflow</code>中工作时，它提供了一个简单的解决方法，如下所述</p><p id="0faa" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们可以得到数据集的<code class="du kr ks kt ku b">len</code>，我们想要保留用于训练的<code class="du kr ks kt ku b"><strong class="ir hi">multiply the percentange of data by that length</strong></code>，并使用<code class="du kr ks kt ku b">take()</code>和<code class="du kr ks kt ku b">skip()</code>方法来执行到<code class="du kr ks kt ku b">train_ds</code>和<code class="du kr ks kt ku b"> test_ds</code>的拆分，如下所示:</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="89cb" class="lj jo hh ku b fi lk ll l lm ln">'''<br/>- use `take` to keep that much of data</span><span id="bf90" class="lj jo hh ku b fi lo ll l lm ln">- use `skip` to pass the take ammount of data</span><span id="87b4" class="lj jo hh ku b fi lo ll l lm ln">'''</span><span id="0d74" class="lj jo hh ku b fi lo ll l lm ln"># get length of iamge dataset in img_cout<br/>img_count = len(image_ds)<br/>img_count</span><span id="e7f3" class="lj jo hh ku b fi lo ll l lm ln"># define train size<br/>train_size = int (img_count*0.8)  # 80% of data <br/>train_size</span><span id="e1fb" class="lj jo hh ku b fi lo ll l lm ln"># perform the split<br/>train_ds = image_ds.take(train_size)<br/>test_ds = image_ds.skip(train_size)</span><span id="8210" class="lj jo hh ku b fi lo ll l lm ln">print(len(train_ds))<br/>print(len(test_ds))</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es me"><img src="../Images/cc184419bcdca7798af2b62fd8ff40a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:112/format:webp/1*4-z1Tme-uzSRei1d7viMrg.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">训练集的长度</figcaption></figure><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es mf"><img src="../Images/bb8b902c2adac66745eea0b8927893d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:50/format:webp/1*N6zsJHO6qA1oJ-dVhEbqUQ.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">测试集的长度</figcaption></figure><h2 id="438f" class="lj jo hh bd jp lq lr ls jt lt lu lv jx ja lw lx kb je ly lz kf ji ma mb kj mc bi translated">绘图</h2><p id="11ce" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated">映射是指一次性在整个数据集上应用一些过程或自定义函数。可以使用<code class="du kr ks kt ku b">map()</code>方法使用。</p><p id="6eb0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里我们将编写几个函数，这些函数将从数据集中加载标签、整个图像，并对它们进行缩放 。每个功能的详细信息如下:</p><p id="951f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">load_labels(file_path)</strong></code> -该函数将接受<code class="du kr ks kt ku b"><em class="kv">file_path</em></code>并通过使用<code class="du kr ks kt ku b">tf.strings.split(file_path, separator)[n]</code>返回标签，其中分隔符将是<code class="du kr ks kt ku b">os.path.sep</code>:-将文件路径分隔成其组件。</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="5acf" class="lj jo hh ku b fi lk ll l lm ln">#get labels fn</span><span id="dadc" class="lj jo hh ku b fi lo ll l lm ln">def get_labels(file_path):<br/>    import os <br/>    return tf.strings.split(file_path , os.path.sep)[-2]</span></pre><blockquote class="mg mh mi"><p id="ffbd" class="ip iq kv ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated"><em class="hh">注意:我们没有使用</em> <code class="du kr ks kt ku b"><em class="hh">split("/")[n]</em></code> <em class="hh">作为tf.data.dataset是一个张量对象，而不是一个列表或字符串，所以我们需要小心处理，请记住使用传统方法会导致错误</em> <strong class="ir hi">。</strong></p></blockquote><p id="b7ca" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">process_image(file_path</strong>)</code> -负责的主要功能:</p><ul class=""><li id="9814" class="mm mn hh ir b is it iw ix ja mo je mp ji mq jm mr ms mt mu bi translated"><strong class="ir hi">使用<code class="du kr ks kt ku b">tf.io.read_file(file_path)</code>加载数据</strong></li><li id="3233" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated"><strong class="ir hi">加载标签</strong>使用<code class="du kr ks kt ku b"> get_labels()</code>我们之前定义的函数，</li><li id="ae80" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated"><strong class="ir hi">使用<code class="du kr ks kt ku b">tf.image.decode_img_type(img) # optional</code>解码图像</strong>，</li><li id="360f" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated"><strong class="ir hi">使用<code class="du kr ks kt ku b"> tf.image.resize(file , [dimension])</code>调整</strong>的大小</li><li id="d28a" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated">返回<strong class="ir hi"> <em class="kv">图像和标签</em> </strong>。</li></ul><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="76d0" class="lj jo hh ku b fi lk ll l lm ln">def process_img(file_path):<br/>    label = get_labels(file_path)<br/>    img = tf.io.read_file(file_path)<br/>    img = tf.image.decode_jpeg(img)<br/>    img = tf.image.resize(img, [224,224])<br/>    return img , label</span></pre><p id="2053" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du kr ks kt ku b"><strong class="ir hi">re_scale(img, labels)</strong></code>:该函数确保图像数组的所有值在(0-1)和标签之间按原样缩放。</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="1679" class="lj jo hh ku b fi lk ll l lm ln">def re_scale(img, labels):<br/>    return img/255 , labels</span></pre><p id="6e68" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">最后，将<strong class="ir hi">图<em class="kv">图</em>图</strong>应用到每个功能可以这样完成:</p><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="6c41" class="lj jo hh ku b fi lk ll l lm ln"># processing image using fn<br/>train_ds = train_ds.map(process_img)<br/>test_ds = test_ds.map(process_img)</span><span id="8b83" class="lj jo hh ku b fi lo ll l lm ln"># viewing files <br/>for img, label in train_ds.take(3): # only 3 elementd <br/>    print('*** Image', img.numpy()[0][0])  # 1st row<br/>    print('*** Label', label.numpy())</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es na"><img src="../Images/3608ca3675e35b290a3b193ea2b2d215.png" data-original-src="https://miro.medium.com/v2/resize:fit:866/format:webp/1*ffT3DY8lvdb2YU-O6JvH4Q.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">已处理数据集-未缩放</figcaption></figure><pre class="kx ky kz la fd lf ku lg lh aw li bi"><span id="3040" class="lj jo hh ku b fi lk ll l lm ln"># here our file_path is train_ds itself as it hols all the file paths for training set train_ds = train_ds.map(scale)</span><span id="2942" class="lj jo hh ku b fi lo ll l lm ln"># viewing files<br/>for img, label in train_ds.take(3):<br/>    print('img: ', img.numpy()[0][0])<br/>    print('labels', label.numpy())</span></pre><figure class="kx ky kz la fd ii er es paragraph-image"><div class="er es nb"><img src="../Images/534b57ceab9d115e6146c6d360b3dcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:956/format:webp/1*wOjJmrHuAVAlAKhlyEbV-Q.png"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">已处理数据集-缩放</figcaption></figure><blockquote class="mg mh mi"><p id="546e" class="ip iq kv ir b is it iu iv iw ix iy iz mj jb jc jd mk jf jg jh ml jj jk jl jm ha bi translated">因为这篇文章只是为了演示和目的，所以我不包括整个列车&amp;部署管道。此外，这个API可以做许多预处理，但不包括我为常见情况演示的那些。</p></blockquote><h2 id="b8b3" class="lj jo hh bd jp lq lr ls jt lt lu lv jx ja lw lx kb je ly lz kf ji ma mb kj mc bi translated">最后的话</h2><p id="83f2" class="pw-post-body-paragraph ip iq hh ir b is kl iu iv iw km iy iz ja kn jc jd je ko jg jh ji kp jk jl jm ha bi translated"><em class="kv">说到这里，我们的文章就到此为止了。我建议你练习编码部分，因为它会很有趣，还会增加你的知识基础。这里使用的所有材料都在参考资料部分提供。如果您对任何代码有任何疑问，请在下面留下</em> <strong class="ir hi"> <em class="kv">评论</em> </strong> <em class="kv">，如果您喜欢，也请务必分享</em><strong class="ir hi"><em class="kv"/></strong><em class="kv">。</em></p><h1 id="0df9" class="jn jo hh bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">参考</h1><ul class=""><li id="edd8" class="mm mn hh ir b is kl iw km ja nc je nd ji ne jm mr ms mt mu bi translated">有关输入管道的更多信息，请访问<a class="ae kq" href="https://www.tensorflow.org/api_docs/python/tf/data/Dataset" rel="noopener ugc nofollow" target="_blank">https://www.tensorflow.org/api_docs/python/tf/data/Dataset</a></li><li id="6981" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated">代码笔记本:<a class="ae kq" href="https://colab.research.google.com/drive/1mZWO8YRQV1t39bEJeTgnslj8ms3IdTzo?usp=sharing" rel="noopener ugc nofollow" target="_blank">笔记本</a></li><li id="5c6b" class="mm mn hh ir b is mv iw mw ja mx je my ji mz jm mr ms mt mu bi translated">参考视频:<a class="ae kq" href="https://youtu.be/VFEOskzhhbc" rel="noopener ugc nofollow" target="_blank">代码基础</a></li></ul></div></div>    
</body>
</html>