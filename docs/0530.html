<html>
<head>
<title>Non Max Suppression (NMS)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">非最大抑制(NMS)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/non-max-suppression-nms-6623e6572536?source=collection_archive---------0-----------------------#2021-01-20">https://medium.com/analytics-vidhya/non-max-suppression-nms-6623e6572536?source=collection_archive---------0-----------------------#2021-01-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cef4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">什么是非最大抑制，为什么要使用它？</p><p id="bb36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">非最大值抑制是一种主要用于对象检测的技术，旨在从一组重叠的框中选择最佳的边界框。在下图中，非最大值抑制的目的是移除黄色和蓝色框，这样我们只剩下绿色框。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/6f8b1bea62faebc84e1c6183ca16c534.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*kwS8PeZKfVyf5Vv55u_MBg.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图1:同一对象的多个重叠框</figcaption></figure><p id="01ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">计算NMS的步骤:</strong></p><p id="be5d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了对什么是边界框，以及IOU意味着什么有一个大概的了解，我已经就此发表了两篇文章。(<a class="ae jo" href="https://vineeth2309.medium.com/basics-of-bounding-boxes-94e583b5e16c" rel="noopener">边框</a>，以及<a class="ae jo" href="https://vineeth2309.medium.com/iou-intersection-over-union-705a39e7acef" rel="noopener"> IOU </a>)。两篇文章中描述的术语和参数在本文中继续使用。我将首先描述这个特殊例子的NMS过程，然后解释一个更一般化的算法，将它扩展到不同的类。</p><p id="21e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">解释使用的术语:</strong></p><ul class=""><li id="46b3" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">我们将使用的每个边界框的格式如下:<br/> bbox = [x1，y1，x2，y2，class，confidence]。</li><li id="4634" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">让我们假设对于这个特定的图像，我们有一个列表3个边界框；即bbox _ list =[蓝色_box，黄色_box，绿色_box]。</li><li id="3a7a" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">green_box = [x1，y1，x2，y2，"猫"，0.9] <br/> yellow_box = [x5，y5，x6，y6，"猫"，0.75] <br/> blue_box = [x3，y3，x4，y4，"猫"，0.85]</li></ul><p id="e132" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一阶段(最初移除箱子):</strong></p><ul class=""><li id="56f9" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">作为NMS的第一步，我们按信任度降序排列盒子。这给了我们:<br/> bbox_list = [green_box，blue_box，yellow_box]</li><li id="3d36" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">然后，我们定义一个置信度阈值。任何置信度低于该阈值的盒子都将被移除。对于这个例子，让我们假设置信度阈值为<strong class="ig hi"> 0.8 </strong>。使用这个阈值，我们将删除黄色框，因为它的置信度是&lt; 0.8。这给我们留下:<br/> bbox_list = [green_box，blue_box]</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/f21bb38910d545adcbe9149cc310cc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*4SYXQozCdfWcEXDFMIMovQ.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图2:卸下黄色盒子</figcaption></figure><p id="b987" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第二阶段(箱子的IOU比较):</strong></p><ul class=""><li id="13b6" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">因为这些框是按照置信度降序排列的，所以我们知道列表中的第一个框具有最高的置信度。我们从列表中删除第一个框，并将其添加到新列表中。在我们的例子中，我们将删除绿框，并把它放到一个新的列表中，比如bbox_list_new。</li><li id="69ee" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">在这个阶段，我们为IOU定义一个额外的阈值。该阈值用于移除具有高重叠的框。其背后的推理如下:如果两个盒子有大量的重叠，并且它们也属于同一个类，那么这两个盒子很可能覆盖同一个对象(我们可以从图2中验证这一点)。因为我们的目标是每个对象有一个盒子，所以我们试着去掉可信度较低的盒子。</li><li id="3f11" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">对于我们的例子，假设我们的IOU阈值是<strong class="ig hi"> 0.5 </strong></li><li id="fd8c" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">我们现在开始计算绿色盒子的IOU，bbox_list中的每个剩余盒子也具有相同的类。在我们的例子中，我们只用蓝框来计算绿框的IOU。</li><li id="6002" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">如果绿框和蓝框的IOU大于我们定义的阈值0.5，我们将移除蓝框，因为它的置信度较低，并且也有明显的重叠。</li><li id="f078" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">对图像中的每个盒子重复这个过程，最终只得到具有高置信度的唯一盒子。</li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/563806de35c61a8ef520f56b22dabee3.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*vLVo-ZKPUbbcNBndQYIFWQ.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图3:非最大抑制的结果</figcaption></figure><p id="38c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">算法:</strong></p><ol class=""><li id="f9d1" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb kd jv jw jx bi translated">定义Confidence_Threshold和IOU_Threshold的值。</li><li id="621d" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">按照置信度的降序对边界框进行排序。</li><li id="6539" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">移除具有置信度的盒子&lt; Confidence_Threshold</li><li id="03c3" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">Loop over all the remaining boxes, starting first with the box that has highest confidence.</li><li id="4cd3" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">Calculate the IOU of the current box, with every remaining box that belongs to the same class.</li><li id="7342" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">If the IOU of the 2 boxes &gt; IOU_Threshold，从我们的盒子列表中移除具有较低置信度的盒子。</li><li id="38a5" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb kd jv jw jx bi translated">重复这个操作，直到我们检查完列表中的所有方框。</li></ol><p id="0553" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">代码:</strong></p><p id="85d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面的代码是执行非最大值抑制的基本函数。以下代码片段中使用的IOU函数与上一篇文章中使用的函数相同(代码可在此处找到:<a class="ae jo" href="https://github.com/vineeth2309/IOU" rel="noopener ugc nofollow" target="_blank"/>)。下面计算NMS的代码可以优化以提高性能。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es ke"><img src="../Images/d67ef51050b571c4526bdcb04a17825f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1224/format:webp/1*MP2HevFHS6mwhlU5xwKaRw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图4:执行非最大抑制的功能</figcaption></figure><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="960a" class="kk kl hh kg b fi km kn l ko kp">def nms(boxes, conf_threshold=0.7, iou_threshold=0.4):</span></pre><ul class=""><li id="d1af" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">该函数将特定图像的框列表、置信度阈值和iou阈值作为输入。(我将它们的默认值分别设置为0.7和0.4)</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="afba" class="kk kl hh kg b fi km kn l ko kp">bbox_list_thresholded = []<br/>bbox_list_new = []</span></pre><ul class=""><li id="6416" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">我们创建了两个名为<strong class="ig hi"> bbox_list_thresholded </strong>和<strong class="ig hi"> bbox_list_new </strong>的列表。<br/><strong class="ig hi">bbox _ list _ thresholded:</strong>包含过滤低置信度框后的新框列表<br/> <strong class="ig hi"> bbox_list_new </strong>:包含执行NMS后的最终框列表</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="aa49" class="kk kl hh kg b fi km kn l ko kp">boxes_sorted = sorted(boxes, reverse=True, key = lambda x : x[5])</span></pre><ul class=""><li id="0617" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">我们开始阶段1，按照置信度的降序对盒子列表进行排序，并将新列表存储在变量<strong class="ig hi">box _ sorted</strong>中。名为<strong class="ig hi">的内置python函数sorted </strong>遍历我们的框列表，并根据我们指定的关键字对其进行排序。在我们的例子中，我们指定一个关键字<strong class="ig hi"> reverse </strong> =True来对列表进行降序排序。第二个关键字<strong class="ig hi"> key </strong>指定了我们想要用于排序的约束。我们使用的lambda函数提供了一个映射，它返回每个边界框的第5个元素(置信度)。在遍历每个盒子时，排序函数将查看lambda函数，该函数将返回盒子的第5个元素(置信度),这将以相反的顺序排序。</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="d8f4" class="kk kl hh kg b fi km kn l ko kp"><em class="kq">for</em> box in boxes_sorted:<br/>    <em class="kq">if</em> box[5] &gt; conf_threshold:<br/>        bbox_list_thresholded.append(box)<br/>    <em class="kq">else</em>:<br/>        <em class="kq">pass</em></span></pre><ul class=""><li id="a152" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">我们迭代所有排序的盒子，并移除置信度低于我们设置的阈值(<strong class="ig hi"> conf_threshold </strong> =0.7)的盒子</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="087d" class="kk kl hh kg b fi km kn l ko kp"><em class="kq">while</em> len(bbox_list_thresholded) &gt; 0:<br/>    current_box = bbox_list_thresholded.pop(0)<br/>    bbox_list_new.append(current_box)</span></pre><ul class=""><li id="179d" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">在阶段2中，我们一个接一个地循环阈值化盒子列表(<strong class="ig hi"> bbox_list_thresholded </strong>)中的所有盒子，直到列表被清空。<br/>我们首先从这个列表(current_box)中移除(<strong class="ig hi"> pop </strong>)第一个盒子，因为它具有最高的置信度，并将其附加到我们的最终列表(<strong class="ig hi"> bbox_list_new </strong>)。</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="b32c" class="kk kl hh kg b fi km kn l ko kp"><em class="kq">    for</em> box in bbox_list_thresholded:<br/>        <em class="kq">if</em> current_box[4] == box[4]:<br/>            iou = IOU(current_box[:4], box[:4])<br/>            <em class="kq">if</em> iou &gt; iou_threshold:<br/>                bbox_list_thresholded.remove(box)</span></pre><ul class=""><li id="9c6f" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">然后，我们迭代列表<strong class="ig hi">中所有剩余的盒子，并检查它们是否属于与当前盒子相同的类。(方框[4]对应于该类别)</strong></li><li id="31ed" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">如果两个盒子属于同一类，我们计算这些盒子之间的IOU(我们将<strong class="ig hi"> box[:4] </strong>传递给IOU函数，因为它对应于(x1，y1，x2，y2)的值，因为我们的IOU函数不需要类和置信度)。</li><li id="214d" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">如果IOU &gt; <strong class="ig hi"> iou_threshold，</strong>我们从列表<strong class="ig hi">bbox _ list _ threshold，</strong>中移除该框，因为该框是具有较低置信度的框。</li></ul><pre class="jd je jf jg fd kf kg kh ki aw kj bi"><span id="c0de" class="kk kl hh kg b fi km kn l ko kp"><em class="kq">return</em> bbox_list_new</span></pre><ul class=""><li id="00ff" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">在非最大压缩之后，我们返回更新的盒子列表。</li></ul><p id="1447" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">最终点数:</strong></p><ul class=""><li id="cd0d" class="jp jq hh ig b ih ii il im ip jr it js ix jt jb ju jv jw jx bi translated">非最大抑制的程序可以根据应用进行修改。例如，YOLOV3模型使用两组置信度作为阈值测量。该算法的另一个改进被称为软NMS，我将在以后的文章中解释。</li><li id="5d05" class="jp jq hh ig b ih jy il jz ip ka it kb ix kc jb ju jv jw jx bi translated">我已经创建了一个<strong class="ig hi">代码</strong>，它通过两个不同类别的图像的NMS阈值的整个过程。我将在下面附上它的结果。完整的代码可以在这里找到<a class="ae jo" href="https://github.com/vineeth2309/Non-Max-Suppression" rel="noopener ugc nofollow" target="_blank">。</a></li></ul><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/675713cd9849796569e43add5e20d655.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y4IozBOkUb64AMalU-nL6A.jpeg"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">图5:代码中NMS的结果</figcaption></figure></div></div>    
</body>
</html>