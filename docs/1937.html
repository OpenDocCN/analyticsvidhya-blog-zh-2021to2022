<html>
<head>
<title>Quantum states — Representation and Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">量子态——表示和编程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/quantum-states-representation-and-programming-e562e44799d4?source=collection_archive---------7-----------------------#2021-03-27">https://medium.com/analytics-vidhya/quantum-states-representation-and-programming-e562e44799d4?source=collection_archive---------7-----------------------#2021-03-27</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/5eb940533d3c7090c8a59a0da8e5eecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tbf0ffJTwD0hA7so.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片提供:<br/> <a class="ae iu" href="https://qoqms.phys.strath.ac.uk/research_qc.html" rel="noopener ugc nofollow" target="_blank">安德鲁·戴利的——斯特拉斯克莱德大学</a></figcaption></figure><p id="565e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">之前关于<a class="ae iu" href="https://navaneethsdk.medium.com/linear-algebra-for-quantum-computing-part-1-8ac7c8e63483" rel="noopener">线性代数</a>的文章可能对你们中的一些人来说有点无聊，尤其是因为它涵盖了量子力学和计算的各个部分。是时候把这一切变成一种最终有意义的形式了。对于所有程序员来说，好消息是，我们将最终在本文中讨论代码。让我们开始派对吧。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="139c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还记得我们在线性代数第一部分中介绍过的两个量子位态，|0⟩和|1⟩吗？对于健忘的人来说，它们是作为基(单数基)引入的，更具体地说，是作为<strong class="ix hj">正交</strong>基。在数学上，它们可以表示为:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/e793cd3da828b00f9f58eeb9a1b86175.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/1*escA2eyafomp_tGKHGP83Q.gif"/></div></div></figure><p id="fe57" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是等等！“标准正交”这个术语是从哪里突然出现的？</p><p id="b3ba" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">别担心，我们一会儿会讲到的。显然，|0⟩和|1⟩是基，这意味着它们形成了跨越希尔伯特空间的线性独立的生成集。这意味着它们是标准化的，即，</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/e1c25c92cef5e2cbb653475a9ab1e385.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/1*2YoKap4sWKeVZrwwjZLcQA.gif"/></div></figure><p id="2217" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所谓正交性，我们的意思是这些向量不仅是归一化的，而且是相互正交的。</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kf"><img src="../Images/9e4ff82dd462ff295daeb0aea4f756ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/1*b0pkiHStQ1dNwypkTsXYqA.gif"/></div></figure><p id="7937" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">直观地说，就像我们可以用相互垂直的x轴和y轴来表示笛卡尔平面上的任何直线一样，我们也可以通过矢量加法和标量乘法，用|0⟩和|1⟩基来表示二维空间中的任何量子态。</p><div class="kb kc kd ke fd ab cb"><figure class="kg ij kh ki kj kk kl paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/65d21b953caaa8c07abeea8d6fee03d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*q3BeKcs1UhOLAYk4EGqtXw.png"/></div></figure><figure class="kg ij km ki kj kk kl paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><img src="../Images/d5d6179e54cf04fa1705fa528a9a4052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*UhKP26uOPMG38uJH6CrKzA.png"/></div><figcaption class="iq ir et er es is it bd b be z dx kn di ko kp translated">和n _ bimage礼貌:Qiskit教科书</figcaption></figure></div><p id="96d5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让q₀是一个量子位，它的状态向量表示为</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kq"><img src="../Images/ff9f1f757f810fbac8ebf25bd8b0290b.png" data-original-src="https://miro.medium.com/v2/resize:fit:270/1*y5JmDP2YAK9FHy7Ul2X8ww.gif"/></div></figure><p id="925a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样的线性组合在量子力学中有个花哨的名字叫叠加态。我们可以说，这样一个重叠的国家既不完全是|0⟩，也不完全是|1⟩.这里，振幅α和β与在任何量子位状态下测量状态|q₀⟩的概率直接相关。这种关系是由量子力学中的一个关键假设给出的，称为<strong class="ix hj">玻恩法则</strong>。</p><p id="2c19" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">根据玻恩规则，在任何量子位状态|x⟩中测量一个状态|ψ⟩的概率由下式给出</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kr"><img src="../Images/9e8d12b60fd2f2b7f71b23c59ca2c40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/1*QW0htrKNGPTy91SGy_LSBw.gif"/></div></figure><p id="5874" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">因此，对于|q₀⟩给出的状态</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es ks"><img src="../Images/abb09b92cec79887d719dce4bcdbb872.png" data-original-src="https://miro.medium.com/v2/resize:fit:310/1*O7-qs51YUSGCijzsN77_FQ.gif"/></div></figure><p id="da2b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">它在测量中坍缩成|1⟩的概率可以用玻恩法则计算如下</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es kt"><img src="../Images/aef91e5ef56092175b16b5f7a363217d.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/1*mI3587FvZ2D4PV9KO8VsAw.gif"/></div></figure><p id="635a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们在线性代数文章中讨论的规范化条件是这个规则的直接应用。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><p id="3ce6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，理论到此为止。让我们从一些编程开始。我们将使用名为qiskit的开源SDK进行编码。要安装qiskit，你可以按照<a class="ae iu" href="https://qiskit.org/documentation/install.html" rel="noopener ugc nofollow" target="_blank">这个</a>教程。</p><p id="a2a7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，让我们探索一下我们上面讨论过的状态是如何在qiskit编程中表示的。为了达到这个目的，我们将建造一个量子电路。量子电路有三个部分:</p><ol class=""><li id="770c" class="ku kv hi ix b iy iz jc jd jg kw jk kx jo ky js kz la lb lc bi translated">编码输入</li><li id="f9f4" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">执行计算，以及</li><li id="8270" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">提取输出。</li></ol><p id="c1da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们以一个简单的非门为例来理解这是如何实现的。“非”门的真值表如下</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es li"><img src="../Images/fa25c56b0117d48dffe4cff49b313c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*xLjDWmwlfsztDwYJ.png"/></div></figure><p id="20bb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，无论输入是什么，输出都是输入的翻转版本。但是，需要注意的是，这是一个经典的非门。非门的量子模拟被称为泡利X门或简称为X门(我们将在另一篇文章中介绍更多关于门的内容)。</p><h2 id="78bf" class="lj lk hi bd ll lm ln lo lp lq lr ls lt jg lu lv lw jk lx ly lz jo ma mb mc md bi translated">编码输入</h2><p id="a94c" class="pw-post-body-paragraph iv iw hi ix b iy me ja jb jc mf je jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">X门就像非门一样，接受1个输入，给出1个输出。因此，为了对输入进行编码，我们需要的<strong class="ix hj">量子位</strong>的数量是1。术语“量子位”在前面的陈述中被强调，因为我们基本上提供了一个量子位状态，像|0⟩或|1⟩，作为电路的输入，而不是像0或1这样的单个位。现在，让我们导入必要的模块。</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="c64c" class="lj lk hi mk b fi mo mp l mq mr">from qiskit import QuantumCircuit, assemble, Aer<br/>from qiskit.visualization import plot_histogram</span></pre><p id="da34" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将使用qiskit的“QuantumCircuit”来构建我们的电路。“汇编”和“Aer”将用于汇编代码和设置我们的量子模拟器。“plot_histogram”将用于查看结果。我们将在编码时详细解释它们。</p><p id="3e40" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">前面，我们看到我们必须给量子电路一个输入来实现X门。具有一个输入的量子电路可以如下创建</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="62be" class="lj lk hi mk b fi mo mp l mq mr">n_q = 1<br/>n_b = 1<br/>qc = QuantumCircuit(n_q,n_b)</span></pre><p id="cff1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">数字<code class="du ms mt mu mk b">n_q</code>定义了电路中量子位的数量。通过<code class="du ms mt mu mk b">n_b</code>，我们定义了最终将从电路中提取的输出位数。对于X门，<code class="du ms mt mu mk b">n_q</code>和<code class="du ms mt mu mk b">n_b</code>都是1。</p><p id="e788" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们的量子电路中，量子位总是从|0⟩.态开始但是，我们可以使用initialize()方法将它转换成任何状态。一旦我们建成了电路，我们就能看到它是如何实现的。</p><h2 id="a2d7" class="lj lk hi bd ll lm ln lo lp lq lr ls lt jg lu lv lw jk lx ly lz jo ma mb mc md bi translated">执行计算</h2><p id="da84" class="pw-post-body-paragraph iv iw hi ix b iy me ja jb jc mf je jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">这里要执行的计算是量子位状态的翻转，即，如果输入状态是|0⟩，那么输出状态将是|1⟩，反之亦然。为了在电路中的唯一量子位上应用位翻转门或X门，我们使用方法X()。</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="8fc4" class="lj lk hi mk b fi mo mp l mq mr">qc.x(0)</span></pre><p id="2eed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述命令将在量子电路中的第0个量子位上应用X门。现在你知道我们为什么把0传递给x()方法了。如果在我们的电路中有2个量子位，我们必须对第2个量子位执行Pauli X gate操作，我们会将1传递给X()方法，因为量子位从0开始编号。</p><p id="7df9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但到目前为止，这条赛道看起来怎么样？让我们看看下面的命令。</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="83ad" class="lj lk hi mk b fi mo mp l mq mr">qc.draw(output='mpl')</span></pre><p id="a4c0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该命令的输出将是</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/c4a55317b17aa631682e1f40ed076ad3.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*c9f7PGtHw1ngFd5Tnn77lw.png"/></div></figure><h2 id="eba8" class="lj lk hi bd ll lm ln lo lp lq lr ls lt jg lu lv lw jk lx ly lz jo ma mb mc md bi translated">提取输出</h2><p id="90aa" class="pw-post-body-paragraph iv iw hi ix b iy me ja jb jc mf je jf jg mg ji jj jk mh jm jn jo mi jq jr js hb bi translated">最后的任务是提取和可视化输出。这个提取是通过一个叫做<em class="mw"> measure的操作来完成的。</em>每次测量告诉一个特定的量子位给一个特定的输出位一个输出。让我们把测量操作加到电路中的量子位上。</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="e95f" class="lj lk hi mk b fi mo mp l mq mr">qc<strong class="mk hj">.</strong>measure(0,0)</span></pre><p id="c76a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这将第0个量子位的输出提取到第0位。如果我们此时调用draw()方法，我们的电路如下所示:</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mx"><img src="../Images/db5b3e1a8a715aec1b9dce72a4325cd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:320/format:webp/1*QBP2Z1ZR0jvGmTnelKK9Hg.png"/></div></figure><p id="5284" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">该看输出了！我们执行这组命令来查看结果:</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="3525" class="lj lk hi mk b fi mo mp l mq mr"># this is the simulator we'll use<br/>sim = Aer.get_backend('qasm_simulator')  </span><span id="dd30" class="lj lk hi mk b fi my mp l mq mr"># this turns the circuit into an object our backend can run<br/>qobj = assemble(qc) </span><span id="62e1" class="lj lk hi mk b fi my mp l mq mr"># we run the experiment and get the result from that experiment<br/># from the results, we get a dictionary containing the number of <br/># times (counts) each result appeared<br/>result = sim.run(qobj).result()  <br/>counts = result.get_counts()</span><span id="38cf" class="lj lk hi mk b fi my mp l mq mr"># and display it on a histogram<br/>plot_histogram(counts)</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/e8065946e0177654ba4be004329e253b.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*7Ki-diJAChVTqDTOAtc2fw.png"/></div></figure><p id="3be9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">请注意，输出1的概率等于1。这与我们从|0⟩转向|1 ⟩.后所了解到的一致但是为什么是概率呢？它可以直接产生输出1，对吗？这是因为量子计算机的结果可能有一定的随机性。因此，它们会运行多次，结果会显示为直方图。还要注意，这个结果来自量子模拟器，它是一台计算理想量子计算机会做什么的标准计算机。</p><p id="1dea" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，我们已经尝试了输入|0⟩，让我们尝试输入|1⟩.我们知道，</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es na"><img src="../Images/c18bc10889d2d83ae7a3e906033eb189.png" data-original-src="https://miro.medium.com/v2/resize:fit:158/1*bKgR96lIuUeugIZPNIobCA.gif"/></div></figure><p id="53de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">要将起始状态初始化为|1⟩，我们需要执行以下操作:</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="6c2f" class="lj lk hi mk b fi mo mp l mq mr">qc <strong class="mk hj">=</strong> QuantumCircuit(1,1)  <em class="mw"># Create a quantum circuit with one qubit</em></span><span id="b309" class="lj lk hi mk b fi my mp l mq mr">initial_state <strong class="mk hj">=</strong> [0,1]   <em class="mw"># Define initial_state as |1&gt;</em></span><span id="ed22" class="lj lk hi mk b fi my mp l mq mr">qc<strong class="mk hj">.</strong>initialize(initial_state, 0) <em class="mw"># Apply initialisation operation to the 0th qubit</em></span><span id="4be8" class="lj lk hi mk b fi my mp l mq mr">qc<strong class="mk hj">.</strong>draw()  <em class="mw"># Let's view our circuit</em></span></pre><p id="300c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">相应的输出将是</p><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mv"><img src="../Images/214a7aef6dcaaf42dd2d6e9574b392f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:230/format:webp/1*DJNpNaUQg-x9LgMO5z4rtg.png"/></div></figure><p id="f143" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用X门并按照我们对上一个电路所做的相同方式进行操作，会得到以下结果:</p><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="f26b" class="lj lk hi mk b fi mo mp l mq mr">qc.x(0)<br/>qc.measure(0,0)<br/>qc.draw(output='mpl')</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es nb"><img src="../Images/0404681f5efb500f5d4112364e2436ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:412/format:webp/1*2sm4fdB0q-I5YbSrrW_cTA.png"/></div></figure><pre class="kb kc kd ke fd mj mk ml mm aw mn bi"><span id="b8d9" class="lj lk hi mk b fi mo mp l mq mr">sim = Aer.get_backend('qasm_simulator')  <br/>qobj = assemble(qc) <br/>result = sim.run(qobj).result()  <br/>counts = result.get_counts()<br/>plot_histogram(counts)</span></pre><figure class="kb kc kd ke fd ij er es paragraph-image"><div class="er es mz"><img src="../Images/b2810d2352ec690d538c4086981d98aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*WbdNS-3cFOJiXCuL3Ie1-Q.png"/></div></figure><p id="07b3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意，这里输出0的概率等于1。这反过来验证了我们之前的讨论，因为量子位state|1⟩是翻转的to|0⟩.</p><p id="a3e5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是一个非常简单的例子。一旦我们对量子门有了更多的了解，我们将会建造更复杂的电路。所以在那之前，保持饥饿保持愚蠢！！！</p><h2 id="2577" class="lj lk hi bd ll lm ln lo lp lq lr ls lt jg lu lv lw jk lx ly lz jo ma mb mc md bi translated">参考:</h2><ol class=""><li id="d408" class="ku kv hi ix b iy me jc mf jg nc jk nd jo ne js kz la lb lc bi translated">Qiskit教科书—<a class="ae iu" href="https://qiskit.org/textbook/ch-states/atoms-computation.html" rel="noopener ugc nofollow" target="_blank">https://qiskit . org/textbook/ch-States/atoms-computation . html</a></li><li id="6709" class="ku kv hi ix b iy ld jc le jg lf jk lg jo lh js kz la lb lc bi translated">Qiskit教科书—<a class="ae iu" href="https://qiskit.org/textbook/ch-states/representing-qubit-states.html" rel="noopener ugc nofollow" target="_blank">https://qiskit . org/textbook/ch-States/representating-qubit-States . html</a></li></ol></div></div>    
</body>
</html>