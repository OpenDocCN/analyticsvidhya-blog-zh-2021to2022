<html>
<head>
<title>Machine Learning for the Stock Market: Use Python to Find Companies that Behave Similarly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">股票市场的机器学习:使用Python寻找行为相似的公司</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/machine-learning-for-the-stock-market-use-python-to-find-companies-that-behave-similarly-81eceee04f2c?source=collection_archive---------4-----------------------#2021-02-27">https://medium.com/analytics-vidhya/machine-learning-for-the-stock-market-use-python-to-find-companies-that-behave-similarly-81eceee04f2c?source=collection_archive---------4-----------------------#2021-02-27</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="d4e3" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="ca74" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">下面的文章将指导您开发一个机器学习模型，该模型能够根据股票价格走势的相似程度，对股票市场上表现相似的公司进行分组。</p><p id="d24f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">用于构建该模型的过程和数据建立在Datacamp的Python无监督学习课程的材料之上。</p></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="dba7" class="ie if hh bd ig ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb bi translated"><strong class="ak">型号</strong></h1><p id="6001" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将制作的模型是t-SNE或t-分布式随机邻居嵌入(别担心，代码实现没有名字那么复杂)，这是一种无监督学习(不需要预期结果的显式标签的模型)技术，它将多维样本(具有许多列的数据)映射到二维或三维，从而使它们可视化。在这种情况下，失真是不可避免的，但SNE霸王龙在保持数据点的接近性方面做得很好。</p><p id="378d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">下面是一个SNE霸王龙形象化的例子:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es kr"><img src="../Images/52fd207895e79249314289acc281880e.png" data-original-src="https://miro.medium.com/v2/resize:fit:746/format:webp/1*AC4x4HchYNjiHPR-VeCpOw.png"/></div></figure><p id="9edd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">上面的示例是应用于Iris数据集的t-SNE(一个非常受欢迎的花卉数据集，广泛用于测试机器学习算法，测量三种不同花卉的不同示例)。iris数据集具有4维样本(4列测量值+识别每朵花及其物种所需的列)。</p><p id="770d" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">SNE霸王龙将虹膜样本映射到2D空间，它不知道有三个不同的物种，但绘制SNE霸王龙的结果并按物种着色，我们可以看到SNE霸王龙可以很好地将数据集分成三个物种。</p><p id="44bd" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">t-SNE图的轴没有可解释的意义它们实际上在每次应用t-SNE时都是不同的，如果你多次运行产生t-SNE可视化的代码，你会注意到图似乎每次都不同，但是组或簇是守恒的，只是似乎在图的不同版本之间旋转。</p></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><h1 id="c7f3" class="ie if hh bd ig ih km ij ik il kn in io ip ko ir is it kp iv iw ix kq iz ja jb bi translated">数据</h1><p id="4e0c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">我们将用来建立这个模型的数据集包含每日股票价格变动(每个交易日收盘价和开盘价之间的差异)，可以在我的<a class="ae kz" href="https://www.kaggle.com/giordan/company-stock-movements-2010-2015" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>或<a class="ae kz" href="https://assets.datacamp.com/production/repositories/655/datasets/1304e66b1f9799e1a5eac046ef75cf57bb1dd630/company-stock-movements-2010-2015-incl.csv" rel="noopener ugc nofollow" target="_blank"> Datacamp的网站</a>上下载。以下是它的外观示例:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es la"><img src="../Images/8d3cfee2f84a3382323a01044148fbd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*Ht0QhsQwBxbfkejjVdeBCQ.png"/></div></figure><h1 id="3686" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">代码</h1><p id="7604" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">首先，我们需要导入我们将使用的库和模块:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="f983" class="lg if hh lc b fi lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from sklearn.preprocessing import normalize<br/>from sklearn.manifold import TSNE</span></pre><p id="0d08" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Numpy将用于从数据集中的值(股票价格变动)和索引(公司名称)创建数组。</p><p id="14d0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Matplotlib.pyplot将用于显示t-SNE的输出。</p><p id="9e22" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Pandas将用于读取数据帧，并且是我们的基本数据操作库。</p><p id="6854" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们将使用sklearn(最流行的机器学习库之一)中的两个模块:. preprocessing.normalize将所有股票价格变动值调整到相同的比例，以避免对股票价格较高的公司给予更多的重视，这些公司的变动将代表更大的金额，以及. manifold. TSNE作为我们模型的基础。</p></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="4339" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">我们将使用熊猫。read_csv()方法来读取我们的dataframe，表明第一列将是index_col = 0参数的索引。</p><p id="9e99" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">那我们就用numpy的。价值观和。指数方法创建两个数组:运动和公司。</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="7218" class="lg if hh lc b fi lh li l lj lk">stocks = pd.read_csv('company-stock-movements-2010-2015-incl.csv', index_col = 0)<br/>movements = stocks.values<br/>companies = stocks.index</span></pre></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="074b" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">接下来，我们将使用sklearn的normalize及其默认设置，将股票走势的所有单个值转换为相同的比例(例如，如果整个比例从-1变为+1，所有值都可以转换为它们的等效值)，并将该规范化数组命名为“normalized_movements”</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="bdbf" class="lg if hh lc b fi lh li l lj lk">normalized_movements = normalize(movements)</span></pre></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="1f58" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">在此之后，我们将启动sklearn的TSNE()的实例，学习率为50，称为“模型”，不同的学习率必须在不同的数据集上进行测试，您可以判断它何时不是一个好值，因为它将散点图中的所有样本分组在一起。尝试50到200之间的值是正常的。</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="65f1" class="lg if hh lc b fi lh li l lj lk">model = TSNE(learning_rate = 50)</span></pre></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="3427" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">现在，我们将把这个模型应用到我们通过。fit_transform()方法，我们将根据生成的要素创建数组，这些要素将构成散点图的X和Y坐标。</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="d6de" class="lg if hh lc b fi lh li l lj lk">tsne_features = model.fit_transform(normalized_movements)</span><span id="c065" class="lg if hh lc b fi ll li l lj lk">xs = tsne_features[:,0]<br/>ys = tsne_features[:,1]</span></pre></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="d22f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">然后，我们将使用在前面步骤中创建的数据来创建散点图，我们还将使用我们之前创建的数组中的公司名称来标记散点图中的每个公司。最后，我们将使用tight_layout方法来调整绘图的填充，我们将使用。show()方法来显示绘图。</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="35a2" class="lg if hh lc b fi lh li l lj lk">fig, ax = plt.subplots(figsize = [15, 10])<br/>plt.scatter(xs, ys, alpha = 0.5)</span><span id="5958" class="lg if hh lc b fi ll li l lj lk">for x, y, company in zip(xs, ys, companies):<br/>    plt.annotate(company, (x, y), fontsize=9, alpha=0.75)</span><span id="f3ad" class="lg if hh lc b fi ll li l lj lk">plt.tight_layout<br/>plt.show()</span></pre></div><div class="ab cl kf kg go kh" role="separator"><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk kl"/><span class="ki bw bk kj kk"/></div><div class="ha hb hc hd he"><p id="1bf3" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">完整的算法如下所示:</p><pre class="ks kt ku kv fd lb lc ld le aw lf bi"><span id="03f7" class="lg if hh lc b fi lh li l lj lk">import numpy as np<br/>import matplotlib.pyplot as plt<br/>import pandas as pd<br/>from sklearn.preprocessing import normalize<br/>from sklearn.manifold import TSNE</span><span id="1eb0" class="lg if hh lc b fi ll li l lj lk">stocks = pd.read_csv('company-stock-movements-2010-2015-incl.csv', index_col = 0)<br/>movements = stocks.values<br/>companies = stocks.index</span><span id="5369" class="lg if hh lc b fi ll li l lj lk">normalized_movements = normalize(movements)</span><span id="824c" class="lg if hh lc b fi ll li l lj lk">model = TSNE(learning_rate = 50)</span><span id="6132" class="lg if hh lc b fi ll li l lj lk">tsne_features = model.fit_transform(normalized_movements)</span><span id="444f" class="lg if hh lc b fi ll li l lj lk">xs = tsne_features[:,0]<br/>ys = tsne_features[:,1]</span><span id="8f95" class="lg if hh lc b fi ll li l lj lk">fig, ax = plt.subplots(figsize = [15, 10])<br/>plt.scatter(xs, ys, alpha = 0.5)</span><span id="30eb" class="lg if hh lc b fi ll li l lj lk">for x, y, company in zip(xs, ys, companies):<br/>    plt.annotate(company, (x, y), fontsize=9, alpha=0.75)</span><span id="3393" class="lg if hh lc b fi ll li l lj lk">plt.tight_layout<br/>plt.show()</span></pre><h1 id="010d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated"><strong class="ak">输出</strong></h1><figure class="ks kt ku kv fd kw er es paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="er es lm"><img src="../Images/557dbe73dc814afcebfe6a26f5e0c928.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pv7Au1mTqCcZkN4WRTrhtg.png"/></div></div></figure><p id="b60a" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">请注意该算法如何将相似行业的公司分组:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lr"><img src="../Images/ac185ecaafd2ae1a9dcbda37f4b79954.png" data-original-src="https://miro.medium.com/v2/resize:fit:406/format:webp/1*ht5iC1e1C6Qu6iiG4nwqwQ.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">放大1</figcaption></figure><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lw"><img src="../Images/fec2511e7ec8f3d06f0d7d8bb9526f20.png" data-original-src="https://miro.medium.com/v2/resize:fit:618/format:webp/1*JGz-cyyOkq-70AcqFiW7dQ.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">放大2</figcaption></figure><p id="287f" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">同时也不产生完全基于部门或行业的集群:</p><figure class="ks kt ku kv fd kw er es paragraph-image"><div class="er es lx"><img src="../Images/be17612f8d3d9de5f4b54b2eebf19029.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*YoINF2rQuoLUMlKIMuorkA.png"/></div><figcaption class="ls lt et er es lu lv bd b be z dx translated">放大3</figcaption></figure><h1 id="aa73" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论</h1><p id="d688" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">所提出的算法被设计成基于公司的股票价格运动来对公司进行分组，并使所述分组可视化。它有可能让不了解所有行业的人了解哪些公司属于同一类型的企业，或者也可以让专业人士了解哪些公司非常相似，哪些公司不独立，取决于它们是否属于同一行业。最后，它可以手动使用，也可以与其他算法结合使用，根据与可视化中的公司之一相关的数据或新闻来预测股票价格的变动。</p></div></div>    
</body>
</html>