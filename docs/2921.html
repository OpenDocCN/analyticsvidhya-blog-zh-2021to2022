<html>
<head>
<title>No Jargon: Behind the Scenes of Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">没有行话:Python的幕后</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/no-jargon-behind-the-scenes-of-python-852eb6949b90?source=collection_archive---------4-----------------------#2021-05-25">https://medium.com/analytics-vidhya/no-jargon-behind-the-scenes-of-python-852eb6949b90?source=collection_archive---------4-----------------------#2021-05-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/8fa4a6a60783476ff974a174fa25ec2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/1*GhcBkj7ceIqt5dETElKtZQ.gif"/></div></div></figure><p id="7036" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">众所周知，Python 易于编写，但是如果没有上下文，很难知道后台发生了什么。Python是众多以面向对象编程<a class="ae jn" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> (OOP) </a>为特色的语言之一，这意味着数据和函数可以被分组到称为<strong class="ir hi">对象</strong>的有用类别中但是令人惊讶的是，尤其是对初学者来说，Python中的一切都已经是一个对象了，<strong class="ir hi">不仅仅是程序员创建的</strong><strong class="ir hi"/><a class="ae jn" href="https://www.tutorialspoint.com/python/python_classes_objects.htm" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">实例</strong></a><a class="ae jn" href="https://www.tutorialspoint.com/python/python_classes_objects.htm" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a>类。</p><p id="6fb2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Python不能让你编写特别接近金属的代码，因为它被解释成C语言，然后被编译。Python的创造者吉多·范·罗苏姆说过:</p><blockquote class="jo jp jq"><p id="925e" class="ip iq jr ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated">Python的所有对象都基于通用的C数据结构，这种结构在解释器中随处可见。变量、列表、函数和其他所有东西都使用了这种数据结构的变体——不管这种结构是表示一个简单的对象，比如一个整数，还是表示一个更复杂的对象，比如一个类。</p></blockquote><p id="f521" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这使得Python在相对较短的程序中有了很大的提升力(尤其是与C相比)，但这也意味着在幕后有一些神奇的事情发生。让我们在窗帘后面偷看一下。</p><h1 id="4887" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">id，类型，isinstance</h1><p id="aae3" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated"><a class="ae jn" href="https://docs.python.org/3.3/library/functions.html?highlight=id%20function#id" rel="noopener ugc nofollow" target="_blank"> id </a>是Python中的一个函数，允许你返回一个对象的“身份”，其写法是这样的:id(object)。id将为它传递的任何内容返回一个唯一的整数。它的输出看起来会像这样(为了清楚起见进行了编辑，不是真正的代码):</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="6ca0" class="lh jw hh ld b fi li lj l lk ll">id(6) = 10914528<br/>id(x) = 10914496<br/>id(y) = 10914496</span></pre><p id="c366" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">其中输出中的数字根据您的系统而变化。如果你用许多不同的数据类型测试id，你会发现一些令人惊讶的事情。例如，具有不同名称的空元组将返回相同的输出，因为它们被Python“拘留”或<strong class="ir hi">预先分配</strong>以方便使用。小整数也是预先分配的，20个字符以下的字符串也是如此。这有助于Python运行得更快一些。做一些调查，看看是否有其他类型的数据会发生这种情况。</p><p id="56e5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要做到这一点，您可能需要了解一些关于<a class="ae jn" href="https://www.geeksforgeeks.org/python-type-function/" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi"/></a>类型的函数。Type将返回对象的类型。比如你写a = 100，运行type(a)，type会返回<strong class="ir hi"> &lt; class 'int' &gt; </strong>，因为100是一个整数。</p><p id="05f6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类型不会给你更多的信息。还有另一个有用的函数叫做<a class="ae jn" href="https://www.guru99.com/type-isinstance-python.html#3" rel="noopener ugc nofollow" target="_blank"><strong class="ir hi">is instance</strong></a><strong class="ir hi"/>，它也会告诉你一个对象是否是用户定义的类的成员。例如，以下代码将产生“<strong class="ir hi">真</strong>”输出:</p><pre class="ky kz la lb fd lc ld le lf aw lg bi"><span id="c0d0" class="lh jw hh ld b fi li lj l lk ll">class MyClass:<br/>    _message = "Hello World"<br/><br/>_class = MyClass()<br/><br/>print("_class is a instance of MyClass() : ", isinstance(_class,MyClass))</span></pre><p id="32f4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> isinstance </strong>也可以处理不属于某个类的数据，因为它有更广泛的可能性，所以经常被用来代替type。使用上面的例子，isinstance(_message，str)也会有一个<strong class="ir hi"> True </strong>输出。</p><p id="0c2c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在使用这些函数时，您会发现一些在屏幕上看起来相同的数据会产生不同的id，并且一些输出会令人惊讶。这是为什么呢？它归结为可变和不可变数据(以及我们已经讨论过的预分配)。</p><h1 id="c201" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">可变和不可变数据</h1><p id="bf5b" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">下面是Python中不可变和可变数据类型的表格:</p><figure class="ky kz la lb fd ii er es paragraph-image"><div class="er es lm"><img src="../Images/758ee4a959d0b969559e7c6e25cb2bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/format:webp/1*mlY6TNtXby36WGuMVPLp6w.png"/></div></figure><p id="5d7c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">使用id，我们可以对这个概念做一个简单的说明:</p><blockquote class="jo jp jq"><p id="ddd3" class="ip iq jr ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated">a = 4<br/>b = 4<br/>id(a)# 10105184<br/>id(b)# 10105184<br/>a = 5<br/>id(a)# 43777957</p></blockquote><p id="82bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">整数是“不可变的”,这意味着它们不能被改变。因此，虽然变量名的值都是4，4是一个整数(如上所述，它是预先分配的)，但无论使用什么名称来引用它，都有一个静态id。如果你熟悉C编程，把变量名想象成C中的指针会很有用，因为它们引用内存中的某个位置。然而，在Python中，我们理解a和b指向同一个<strong class="ir hi">对象</strong> <em class="jr">，</em>即<em class="jr"> int(4) </em>。Python中的一切都是对象。</p><p id="ab84" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当给定一个<strong class="ir hi">可变对象</strong>时，即使有相同的值，Python也会吐出类似这样的东西，一个使用列表的例子:</p><blockquote class="jo jp jq"><p id="6893" class="ip iq jr ir b is it iu iv iw ix iy iz js jb jc jd jt jf jg jh ju jj jk jl jm ha bi translated">a = [1，2，3] <br/> b = [1，2，3]<br/>id(a)= 4380236680<br/>id(b)= 4380237448</p></blockquote><p id="43a8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为<strong class="ir hi">列表</strong>是可变的，它们不能引用内存中的同一个位置而不引起一些严重的混乱。因此，您将会看到，尽管列表具有相同的值，但它们的id是不同的。这意味着，如果你操作a，或者b，甚至两者都操作，Python永远不会丢失哪个是哪个的线索。这对于其他可变的数据类型特别有用，比如<strong class="ir hi">字典</strong>，其中可能有多个非常相似的条目用于非常不同的数据类型。例如，如果你有一个学生字典，有多个17岁的丽贝卡，但其中只有一个注册了戏剧。在这种情况下，使用不同的标识符非常有用。否则，每个丽贝卡都会把他们的分数弄混！呀！</p><h1 id="1f50" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">好吧，为什么这很重要？</h1><p id="0a6f" class="pw-post-body-paragraph ip iq hh ir b is kt iu iv iw ku iy iz ja kv jc jd je kw jg jh ji kx jk jl jm ha bi translated">就计算能力而言，传递对同一对象的引用(如int(4))成本更低，这对于Python这样的解释型语言非常有用，因为在Python中，数据只是占用更多的空间。作为参考，在C语言中，一个整数占用4个字节的内存，与Python的28个字节形成鲜明对比。这意味着Python通过使用这些对对象的引用，运行速度比其他方式要快。</p><p id="2c12" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它还暗示了数据如何通过函数传递。使用可变类型的数据意味着，即使在程序运行过程中对数据进行了操作，您也总能找出哪个列表被操作了，即使是在大量相似的列表中。这对于故障排除来说意义重大，也意味着大量数据可以在一个程序中处理而不会丢失。</p><p id="b55a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">类似地，如果我们在函数中使用不可变的数据类型作为参数，我们可以放心，没有什么会被扭曲。熟悉C的程序员会记得有一次他们在一个程序中两次使用<strong class="ir hi"> i </strong>作为变量，得到了一些非常<em class="jr">非常</em>意想不到的结果。在Python中，如果你两次使用一个变量名，但是它引用了同一个数字，比如说零，你的程序仍然可以工作。</p><p id="b494" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这确实意味着你可以写一些计算机能理解的非常潦草的代码，但是人类不能。这是Python的学习曲线之一——一定要写出可读的代码，尤其是在幕后发生如此多事情的语言中。这就是为什么，像一个负责任的程序员，你应该(而且是！在这篇文章中已经讲到了这一点)，花点时间了解一下拥有一个面向对象的程序意味着什么，以及Python是如何用这么少的几行代码完成所有这些繁重的工作的。</p><p id="2411" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要了解Python的更多功能，请花时间浏览一下它的<a class="ae jn" href="https://docs.python.org/3/" rel="noopener ugc nofollow" target="_blank">文档</a>。记住，再多的阅读(即使很少或没有行话)也不能代替自己做一些优秀的老式编程。</p></div></div>    
</body>
</html>