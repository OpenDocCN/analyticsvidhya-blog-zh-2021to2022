<html>
<head>
<title>MNIST database: Handwritten Digit Recognition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MNIST数据库:手写数字识别</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mnist-database-handwritten-digit-recognition-9ee9c917bf59?source=collection_archive---------5-----------------------#2021-03-25">https://medium.com/analytics-vidhya/mnist-database-handwritten-digit-recognition-9ee9c917bf59?source=collection_archive---------5-----------------------#2021-03-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="dcd5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">在这篇文章中，我将解释一个机器学习模型，它能够尽可能简单地识别手写数字。</h2></div><p id="ce8a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我会尽可能简单地解释一切。我将展示这个项目的部分代码，但我只是想让你明白这个项目的基本原则是如何工作的。</p><p id="a68e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们要建立一个能够识别手写数字的机器学习模型！此外，我还链接了一个应用程序，你可以下载它来玩机器学习模型。你可以在这里下载应用<a class="ae js" href="https://drive.google.com/file/d/1a0VpMwz1r2FX1_myQv1S5srQoIN_CuDs/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="90ba" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了训练机器学习模型，我们需要大量数据。幸运的是，有一个数据库叫做“MNIST数据库”。这为我们提供了60000张用于训练模型的图片和10000张用于测试模型的图片。“模型”是我们的程序。它使我们能够输入图像并得到预测。它使用输入来生成输出。这是可能的，因为有一个叫做“训练”的过程，在这个过程中，我们向模型输入大量数据。通过这个，它学会了在什么场景下如何表现。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="a927" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">理解数据</h2><p id="f686" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">让我们先来看看MNIST数据库中的数据:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es la"><img src="../Images/f02b306617138ac4e2070c01e3f796b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P-bTlIUe0BR5i-2cpApAhA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">MNIST数据库的5个示例图像。</figcaption></figure><p id="4161" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里你可以看到MNIST数据库中的另一张图片:</p><div class="lb lc ld le fd ab cb"><figure class="lq lf lr ls lt lu lv paragraph-image"><img src="../Images/753c574633e7e28fb221c4eb046e7164.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*gDNyxs3mV50neuk63J8sgQ.png"/></figure><figure class="lq lf lw ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/81402ab5744e8df6a664105d24601936.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*Y4R12_p7egHaRKBVdUQHCQ.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx lx di ly lz translated">MNIST数据库中一个条目的图像(左)，该图像的数值(右)</figcaption></figure></div><p id="e774" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我使用一个名为“matplotlib”的库创建了左边的图像(库是预制代码/软件的集合。我们可以在项目中实现库，从而加快开发速度)。Matplotlib是Python(一种经常用于机器学习的编程语言)最流行的库之一。Matplotlib用于可视化数据。在右边，我们可以看到存储在MNIST数据库条目中的普通数值。“5”仍然可以辨认，但不像左边的图像那样清晰。Matplotlib能够将数值转换成图像。MNIST数据库只是为每幅图像存储这些数值。数字从0到255。现在，我们对正在处理的数据有了基本的了解，让我们继续看一下代码。</p><h2 id="2e9d" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">导入库</h2><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">导入必要的库</figcaption></figure><p id="dc93" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们从导入必要的库开始。我们主要用<a class="ae js" href="http://www.tensorflow.org" rel="noopener ugc nofollow" target="_blank"> TensorFlow </a>。您不必太担心这部分代码，只需记住我们在项目中实现了几个预制的软件部分。例如，TensorFlow为我们处理了机器学习背后的所有数学问题。</p><h2 id="d6e8" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">加载和准备数据</h2><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">加载和准备数据</figcaption></figure><p id="4d63" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们加载数据。MNIST数据库包含在TensorFlow中，因为它是一个非常受欢迎的机器学习项目。我们继续重塑和规范化数据。你不需要明白这里到底发生了什么。请记住，我们不再将单个值更改为0到255之间的值，而是0到1之间的值。</p><h2 id="b1e6" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">创建模型</h2><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">定义模型</figcaption></figure><p id="2a22" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们已经准备好了数据，我们终于可以开始创建我们的模型了！呜呜呜。！我们的模型是一个神经网络。我们指定了一个所谓的“顺序”模型，用于在彼此之上堆叠多个层。层基本上是基于给定输入确定输出的函数。在我们的模型中，这个过程将如下进行。之后我会解释每一层的功能。</p><ol class=""><li id="446f" class="mc md hh iy b iz ja jc jd jf me jj mf jn mg jr mh mi mj mk bi translated">数据被传递到神经网络的第一层。</li><li id="5ca0" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi translated">第一层(“Conv2D”)更改数据并将其传递给下一层。</li><li id="f468" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi translated">第二层(“MaxPooling2D”)再次更改数据并传递它。</li><li id="a064" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr mh mi mj mk bi">….</li></ol><p id="04d7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这个改变数据和传递数据的过程一直持续到我们到达最后一层。这最后一层现在生成一个输出。它“标记”输入。在这个项目中，我们有10个可能的标签(数字0-9)。现在我将解释每一层。</p><h2 id="c4d1" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">Conv2D</h2><p id="5bf5" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">第一层“Conv2D”将滤镜分配给输入图像。参数“input_shape”定义输入图像的宽度和高度(28，28)。“28，28”后面的“1”代表通道尺寸。因为我们使用灰度图像作为输入，所以我们使用“1”。如果我们有一个RGB图像，我们必须使用“3”。最终，这整个概念导致了“28，28，1”的输入形状。</p><h2 id="a3db" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">池化(MaxPooling2D)</h2><p id="d2c3" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">第二层“MaxPooling2D”减少了我们的图像大小，但保留了，有时甚至突出了最重要的信息。合用是一个非常酷的概念。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mq"><img src="../Images/4f24421f6c53f31ef75a97032878e527.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bc5LiQFdisOdA0iG79niCA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">直观地表示池。(via <a class="ae js" href="https://youtu.be/PCgLmzkRM38" rel="noopener ugc nofollow" target="_blank">机器学习基础第三集</a>)。</figcaption></figure><p id="4fbd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在左边，我们可以看到图像的一大块像素。在这个例子中，每个像素由灰色背景上的数字表示。我们可以将这些像素分成四个2×2的像素部分。现在开始汇集。池化从每个2乘2部分中获取最高价值。这在上面的图像中直观地呈现出来。我们可以看到中间2乘2的部分。每个部分的箭头指向每个部分的最高值。这4个最高值现在形成了新的2×2像素部分。使用这种技术，我们能够大规模减少图像的大小，但仍然保持我们的图像最重要的信息。这有助于我们的机器学习模型找到模式，然后识别数字。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es mq"><img src="../Images/e6d17166ff0da329abc73c6ea55ef40c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FnzhKurJTTLPaDbKao6NAA.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">行动中的汇集。(via <a class="ae js" href="https://youtu.be/PCgLmzkRM38" rel="noopener ugc nofollow" target="_blank">机器学习基础第三集</a>)</figcaption></figure><p id="2512" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面的图片中，我们可以看到汇集的作用。一个用于突出垂直线的滤镜被附加到左边的图像上。在右边，我们看到合并后完全相同的图像。图像的重要部分更加清晰。</p><h2 id="facc" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">变平</h2><p id="9b98" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">“展平”层展平输入。理解这个模型如何工作并不一定需要背后的确切逻辑。</p><h2 id="06f8" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">稠密的</h2><p id="fed9" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">“密集”层只是实现了我们神经网络的一个等式。对于理解模型如何工作，没有必要对这一层进行更深入的解释。</p><h2 id="4455" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">激活功能</h2><p id="d69e" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">也许你已经注意到了我们一些层的定义里面的参数“激活”。激活函数只是帮助我们的神经网络判断一个神经元是否应该激活。你现在不需要从总体上理解人工神经元或者神经网络。我将只介绍这个项目中使用的两个激活函数(ReLU和softmax)，更深入的解释将超出本文的目的。</p><h2 id="429a" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">热卢</h2><p id="301c" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">ReLU函数是最流行的激活函数之一。它代表“校正线性单元”。数学上，该函数定义为:</p><pre class="lb lc ld le fd mr ms mt mu aw mv bi"><span id="1bb4" class="ka kb hh ms b fi mw mx l my mz">y = max(0,x)</span></pre><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es na"><img src="../Images/3ba42dfd4c25ca34028ca1070c43e4a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rJfsrIIiiTSTKXHuD88mrQ.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">ReLU函数的可视化。</figcaption></figure><p id="b58e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果输入为负，ReLU函数返回“0 ”,如果输入为正，则返回线性。你可以在上面的图像中看到这一点。</p><h2 id="590e" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">Softmax</h2><p id="99c7" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">softmax功能是另一个激活功能。它将输入值转换为从0到1的值。正因为如此，我们在神经网络的最后一层使用softmax激活函数:神经网络生成从0到1的值作为输出。我们可以将这些值视为不同标签(0–9)的概率。使用这种技术，我们能够从模型中获得有用的输出。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="5114" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们现在已经完成了模型的创建，并且理解了它最重要的组成部分。现在我们开始训练。</p><h2 id="f6fd" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">培养</h2><p id="6e57" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">在训练模型之前，我们首先需要为训练过程配置我们的模型。这是使用compile方法完成的。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">编译模型</figcaption></figure><p id="aac7" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我不打算在这里解释“优化器”和“损失”是什么意思。这再次超出了本文的目的。</p><p id="d9f1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在我们可以真正开始训练模型了。对于训练，我们使用fit方法。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">训练模型</figcaption></figure><p id="2691" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这部分代码中，我们对模型进行训练！我们为模型提供训练所需的图像和标签。我们训练模型10个时期。一个历元是整个数据集的一次通过。这意味着模型在整个数据集上运行它的函数。我们重复这个过程，遍历整个数据集10次。我们将通过训练生成的数据存储在一个名为“历史”的变量中。通过这个，我们可以访问每个时期的关键数据，比如模型的准确性。当我们试图改进我们的模型时，这变得非常重要。</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es nb"><img src="../Images/e8a4948405d0c66a563986a66235239a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MHCKYGcPyH1gWgm1bzkO5Q.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">这是在训练我们的模型时打印出来的。</figcaption></figure><p id="428f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上图中，我们可以看到每个时期的一些数据。我们可以看到一个东西叫“失”，一个东西叫“准”。稍后我会解释这一点。</p><p id="3982" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">训练后，我们可以测试我们新训练的模型。我们为此使用evaluate方法。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">评估我们的模型</figcaption></figure><p id="544f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将测试图像和测试标签提供给evaluate方法。这将生成以下输出:</p><figure class="lb lc ld le fd lf er es paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="er es nc"><img src="../Images/08acdaaabc6526eb1bf546ff671ace08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0a0DJhCRlTm2KUAH_nHPbg.png"/></div></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">评估方法的输出</figcaption></figure><p id="286e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以在测试模式下看到模型的损耗和精度输出。在“从未见过的数据”上，该模型的准确率为98.58%。那很酷，不是吗？！</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="8ca5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经基本完成了最复杂和最重要的步骤！呜哇！</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="nd mb l"/></div></figure></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h2 id="9a48" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">准确性和损失</h2><p id="e452" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">让我们来看看我们的模型的损失和准确性。</p><div class="lb lc ld le fd ab cb"><figure class="lq lf ne ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/c6bdc5a35b783971a343f2e94309270a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*CDJKFhcBFCv3jsgmUixW7Q.png"/></div></figure><figure class="lq lf nf ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><img src="../Images/14d4bf6f9fb0b9e663b0a5a4fb4574f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:994/format:webp/1*fjFIxcbWzF99a-JBC21bLg.png"/></div><figcaption class="lm ln et er es lo lp bd b be z dx ng di nh lz translated">模型精度(左)和损失(右)</figcaption></figure></div><p id="17bb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在左图中，我们可以看到代表模型精确度的图表。在右图中，图表显示了模型的损耗。我们可以看到，在整个时代，我们的模型精度增加，我们的模型损失减少！这很好，因为我们的模型通过预测获得了信心。</p><h2 id="4fbf" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">手写数字识别应用程序</h2><p id="84b2" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">哇！投入太多了，不是吗？我希望你通过这篇文章学到了一些新东西。这是一种非常理论化的方法，试图教你机器学习的基础知识。我更喜欢变得实际，所以我用我们训练过的模型开发了一个应用程序。你可以亲自试用这个应用程序，它是一个. apk文件，所以你可以直接在你的android设备上下载。该应用程序是使用Flutter构建的，我观看的将我们的模型实际实现到应用程序中的教程链接在下面的“参考和资源”部分。</p><p id="f20a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">虽然它不能正确预测所有的事情，但是玩一会儿这个应用程序还是很有趣的。尽情享受吧！</p><p id="d5fa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里可以下载app <a class="ae js" href="https://drive.google.com/file/d/1a0VpMwz1r2FX1_myQv1S5srQoIN_CuDs/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="b7d3" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">保存和转换我们的模型</h2><p id="0589" class="pw-post-body-paragraph iw ix hh iy b iz kv ii jb jc kw il je jf kx jh ji jj ky jl jm jn kz jp jq jr ha bi translated">在本文的这一部分，我将快速向您展示让模型在智能手机上运行所必需的东西。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">保存模型</figcaption></figure><p id="aef8" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们需要保存我们训练好的模型。在括号中，我们只是定义了保存模型的路径。</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ma mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">转换模型</figcaption></figure><p id="9af2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下一步是将模型转换为“tflite”。这只是代表TensorFlow Lite。它类似于普通的张量流，但针对移动或嵌入式设备进行了优化。对于转换，我们加载保存的模型，然后使用TensorFlow提供的convert方法。然后我们可以下载。文件，并在我们的应用程序中使用它。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><p id="c428" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们完了！耶！</p><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="ni mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">派对！！</figcaption></figure><p id="f935" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">非常感谢您阅读这篇文章！我希望你喜欢它，反馈和掌声非常感谢！如果有任何问题，请在评论中留下，我会尽力帮助你的！你也可以通过社交媒体联系我。</p><h2 id="6d02" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">参考资料和资源</h2><ul class=""><li id="bf5f" class="mc md hh iy b iz kv jc kw jf nj jj nk jn nl jr nm mi mj mk bi translated"><a class="ae js" rel="noopener" href="/@danqing/a-practical-guide-to-relu-b83ca804f1f7#:~:text=ReLU%20stands%20for%20rectified%20linear,max(0%2C%20x).&amp;text=ReLU%20is%20the%20most%20commonly,usually%20a%20good%20first%20choice">刘丹青关于热路功能的惊人文章</a></li><li id="f03e" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr nm mi mj mk bi translated"><a class="ae js" href="https://youtu.be/SRbxEQ89IBs" rel="noopener ugc nofollow" target="_blank">在Flutter应用中实现Tflite的教程</a></li><li id="ace3" class="mc md hh iy b iz ml jc mm jf mn jj mo jn mp jr nm mi mj mk bi translated"><a class="ae js" href="https://drive.google.com/file/d/1a0VpMwz1r2FX1_myQv1S5srQoIN_CuDs/view?usp=sharing" rel="noopener ugc nofollow" target="_blank">手写数字识别app </a></li></ul><figure class="lb lc ld le fd lf"><div class="bz dy l di"><div class="nn mb l"/></div><figcaption class="lm ln et er es lo lp bd b be z dx translated">谷歌开发人员的“机器学习基础”对计算机视觉和机器学习等主题提供了很好的解释。</figcaption></figure><h2 id="6975" class="ka kb hh bd kc kd ke kf kg kh ki kj kk jf kl km kn jj ko kp kq jn kr ks kt ku bi translated">源代码</h2><ul class=""><li id="6921" class="mc md hh iy b iz kv jc kw jf nj jj nk jn nl jr nm mi mj mk bi translated"><a class="ae js" href="https://colab.research.google.com/drive/1EI1Rbn6M9AU7HEOuvwLMuEwIa-zLPcrJ?usp=sharing" rel="noopener ugc nofollow" target="_blank">谷歌Colab笔记本</a></li></ul></div></div>    
</body>
</html>