<html>
<head>
<title>Pytorch Classification model using Azure Machine learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Azure机器学习的Pytorch分类模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/pytorch-classfification-model-using-azure-machine-learning-9313442a6db9?source=collection_archive---------14-----------------------#2021-04-01">https://medium.com/analytics-vidhya/pytorch-classfification-model-using-azure-machine-learning-9313442a6db9?source=collection_archive---------14-----------------------#2021-04-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="b8e6" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">使用pytorch和Azure ML运行分类</h1><h1 id="0341" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">先决条件</h1><ul class=""><li id="f019" class="jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">Azure帐户</li><li id="bf0b" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">资源组</li><li id="2754" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">Azure机器学习</li><li id="40f7" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">Azure存储blob</li><li id="061c" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">明斯特模型</li></ul><h1 id="3cbf" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">Azure机器学习</h1><ul class=""><li id="cc13" class="jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">首先创建一个数据集</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="af17" class="ki if hh ke b fi kj kk l kl km"># importing the libraries<br/>import numpy as np<br/>import torch<br/>import torchvision<br/>import matplotlib.pyplot as plt<br/>from time import time<br/>from torchvision import datasets, transforms<br/>from torch import nn, optim</span></pre><ul class=""><li id="6a81" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">印刷版本</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="3f94" class="ki if hh ke b fi kj kk l kl km">print(torch.__version__)</span><span id="e30e" class="ki if hh ke b fi ks kk l kl km"># transformations to be applied on images<br/>transform = transforms.Compose([transforms.ToTensor(),<br/>                              transforms.Normalize((0.5,), (0.5,)),<br/>                              ])</span></pre><ul class=""><li id="54b0" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">下载数据</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="014e" class="ki if hh ke b fi kj kk l kl km"># defining the training and testing set<br/>trainset = datasets.MNIST('./data', download=True, train=True, transform=transform)<br/>testset = datasets.MNIST('./test', download=True, train=False, transform=transform)</span><span id="0444" class="ki if hh ke b fi ks kk l kl km"># defining trainloader and testloader<br/>trainloader = torch.utils.data.DataLoader(trainset, batch_size=64, shuffle=True)<br/>testloader = torch.utils.data.DataLoader(testset, batch_size=64, shuffle=True)</span><span id="1d89" class="ki if hh ke b fi ks kk l kl km"># shape of training data<br/>dataiter = iter(trainloader)<br/>images, labels = dataiter.next()<br/><br/>print(images.shape)<br/>print(labels.shape)</span></pre><ul class=""><li id="2349" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">显示数据</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="24e2" class="ki if hh ke b fi kj kk l kl km"># visualizing the training images<br/>plt.imshow(images[0].numpy().squeeze(), cmap='gray')</span></pre><p id="aaba" class="pw-post-body-paragraph kt ku hh je b jf kn kv kw jh ko kx ky jj kz la lb jl lc ld le jn lf lg lh jp ha bi translated">打印形状</p><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="02ef" class="ki if hh ke b fi kj kk l kl km"># shape of validation data<br/>dataiter = iter(testloader)<br/>images, labels = dataiter.next()<br/><br/>print(images.shape)<br/>print(labels.shape)</span></pre><ul class=""><li id="04a0" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">定义模型</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="a662" class="ki if hh ke b fi kj kk l kl km"># defining the model architecture<br/>class Net(nn.Module):   <br/>  def __init__(self):<br/>      super(Net, self).__init__()<br/><br/>      self.cnn_layers = nn.Sequential(<br/>          # Defining a 2D convolution layer<br/>          nn.Conv2d(1, 4, kernel_size=3, stride=1, padding=1),<br/>          nn.BatchNorm2d(4),<br/>          nn.ReLU(inplace=True),<br/>          nn.MaxPool2d(kernel_size=2, stride=2),<br/>          # Defining another 2D convolution layer<br/>          nn.Conv2d(4, 4, kernel_size=3, stride=1, padding=1),<br/>          nn.BatchNorm2d(4),<br/>          nn.ReLU(inplace=True),<br/>          nn.MaxPool2d(kernel_size=2, stride=2),<br/>      )<br/><br/>      self.linear_layers = nn.Sequential(<br/>          nn.Linear(4 * 7 * 7, 10)<br/>      )<br/><br/>  # Defining the forward pass    <br/>  def forward(self, x):<br/>      x = self.cnn_layers(x)<br/>      x = x.view(x.size(0), -1)<br/>      x = self.linear_layers(x)<br/>      return x</span></pre><ul class=""><li id="8b05" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">配置模型</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="f888" class="ki if hh ke b fi kj kk l kl km"># defining the model<br/>model = Net()<br/># defining the optimizer<br/>optimizer = optim.Adam(model.parameters(), lr=0.01)<br/># defining the loss function<br/>criterion = nn.CrossEntropyLoss()<br/># checking if GPU is available<br/>if torch.cuda.is_available():<br/>    model = model.cuda()<br/>    criterion = criterion.cuda()<br/>    <br/>print(model)</span></pre><ul class=""><li id="e5b8" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">亏损</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="0337" class="ki if hh ke b fi kj kk l kl km">for i in range(10):<br/>    running_loss = 0<br/>    for images, labels in trainloader:<br/><br/>        if torch.cuda.is_available():<br/>          images = images.cuda()<br/>          labels = labels.cuda()<br/><br/>        # Training pass<br/>        optimizer.zero_grad()<br/>        <br/>        output = model(images)<br/>        loss = criterion(output, labels)<br/>        <br/>        #This is where the model learns by backpropagating<br/>        loss.backward()<br/>        <br/>        #And optimizes its weights here<br/>        optimizer.step()<br/>        <br/>        running_loss += loss.item()<br/>    else:<br/>        print("Epoch {} - Training loss: {}".format(i+1, running_loss/len(trainloader)))</span></pre><ul class=""><li id="c352" class="jc jd hh je b jf kn jh ko jj kp jl kq jn kr jp jq jr js jt bi translated">通过测试和报告性能进行预测</li></ul><pre class="jz ka kb kc fd kd ke kf kg aw kh bi"><span id="c66c" class="ki if hh ke b fi kj kk l kl km"># getting predictions on test set and measuring the performance<br/>correct_count, all_count = 0, 0<br/>for images,labels in testloader:<br/>  for i in range(len(labels)):<br/>    if torch.cuda.is_available():<br/>        images = images.cuda()<br/>        labels = labels.cuda()<br/>    img = images[i].view(1, 1, 28, 28)<br/>    with torch.no_grad():<br/>        logps = model(img)<br/><br/>    <br/>    ps = torch.exp(logps)<br/>    probab = list(ps.cpu()[0])<br/>    pred_label = probab.index(max(probab))<br/>    true_label = labels.cpu()[i]<br/>    if(true_label == pred_label):<br/>      correct_count += 1<br/>    all_count += 1<br/><br/>print("Number Of Images Tested =", all_count)<br/>print("\nModel Accuracy =", (correct_count/all_count))</span></pre><p id="97e8" class="pw-post-body-paragraph kt ku hh je b jf kn kv kw jh ko kx ky jj kz la lb jl lc ld le jn lf lg lh jp ha bi translated"><a class="ae li" href="https://github.com/balakreshnan/Samples2021/blob/main/ML/pytorchminst.md" rel="noopener ugc nofollow" target="_blank">位于主巴拉克列什南的samples 2021/pytorchminst . MD/samples 2021(github.com)</a></p></div></div>    
</body>
</html>