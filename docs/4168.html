<html>
<head>
<title>Fundamentals of MLOps — Part 4 | Tracking with MLFlow &amp; Deployment with FastAPI</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">MLOps基础知识—第4部分|使用MLFlow进行跟踪以及使用FastAPI进行部署</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fundamentals-of-mlops-part-4-tracking-with-mlflow-deployment-with-fastapi-61614115436?source=collection_archive---------2-----------------------#2021-09-05">https://medium.com/analytics-vidhya/fundamentals-of-mlops-part-4-tracking-with-mlflow-deployment-with-fastapi-61614115436?source=collection_archive---------2-----------------------#2021-09-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/3371534f888fd13341ab337a08d307dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JDUxuw3TFCExPssOgwhXNw.png"/></div></div></figure><p id="0451" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的3篇文章中，我们对如何轻松复杂地版本化ML工件和构建ML管道有了一个明确的理解。到目前为止，您应该对使用DVC跟踪数据相当熟悉了&amp;通过利用PyCaret中众多的预处理、特征工程和微调技术，尝试各种ML模型进行回归和分类任务。</p><p id="c0b2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在本系列的最后一篇博客中，我们将讨论有效记录实验结果、部署ML模型以及最终将它们作为API端点供用户与模型进行实际交互以获得期望的预测等主题。所以，让我们开始吧！</p><h1 id="7ef0" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">内容</h1><ul class=""><li id="6e1f" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated">实验跟踪:为什么重要？</li><li id="228c" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">用于跟踪PyCaret实验的MLFlow</li><li id="b419" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">模型部署:它是什么？</li><li id="abd4" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">将PyCaret模型部署到云</li><li id="3adc" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">使用FastAPI进行实时服务</li><li id="93e3" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在线托管模型服务器</li><li id="b9fd" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">结束语</li></ul><h1 id="d88f" class="jo jp hi bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">实验跟踪:为什么重要？</h1><p id="92d4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">我们已经看到，为任何系统开发ML模型都是一个高度迭代的过程，涉及到大量的实验。这些实验通常在以下方面有所不同:</p><ul class=""><li id="5747" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">应用于数据的预处理步骤</li><li id="0ed2" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">不同模型算法的使用</li><li id="6e68" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">不同超参数集的使用</li><li id="90f7" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">培训和/或评估集</li></ul><p id="da8c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这些实验中的每一个都需要用适当的度量标准来评估，以得出某些结论，这有助于我们设计进一步的实验或做出明确的推断。因此，最重要的是我们要保持一份记录，或者仔细地跟踪我们的实验。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lj"><img src="../Images/ded358feed59e754218d4cef0364eec6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CNkJ71_x-T14d8fc"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated"><strong class="bd jq"> <em class="ls">图片来源:</em> </strong> <em class="ls"> </em> <a class="ae lt" href="https://neptune.ai/blog/machine-learning-model-management" rel="noopener ugc nofollow" target="_blank"> <em class="ls">机器学习模型管理</em> </a></figcaption></figure><p id="8cd1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实验跟踪是MLOps的一部分，指的是在设计ML管道时，保存每个实验的所有实验相关信息(元数据，有助于得出有意义的结论)。</strong></p><p id="8131" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">实验跟踪有助于我们实现以下目标:</p><ul class=""><li id="8d5f" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated"><strong class="is hj">跨实验比较结果:</strong>记录跨实验的模型的超参数&amp;性能度量，以及用一些一致的标签对它们进行标记，可以在尝试对实验进行比较分析时保持事情非常有条理</li><li id="61bb" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><strong class="is hj">管理分布式训练:</strong>在分布式系统上训练模型的同时，维护不同机器上的各种运行的记录可以在以后帮助聚合&amp;更有效地可视化结果</li><li id="fd25" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><strong class="is hj">通过报告管理团队协作:</strong>团队中的几个成员采用不同的方法来解决问题，定期构建关于当前方法及其性能的报告&amp;接下来可以尝试的潜在变化对团队内的有效协作至关重要</li><li id="075a" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><strong class="is hj">维护模型的记录:</strong>随着越来越多的模型被部署到生产中，记录开发的每个模型(以及元数据)变得势在必行，以便下游任务中的任何失败可以很容易地追溯到源头&amp;很快纠正</li></ul></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="fa49" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">用于跟踪PyCaret实验的MLFlow</h1><p id="f041" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">有几个工具和平台有助于ML实验跟踪。其中包括<a class="ae lt" href="https://www.mlflow.org/docs/latest/tracking.html" rel="noopener ugc nofollow" target="_blank"> MLFlow </a>、<a class="ae lt" href="https://wandb.ai/site" rel="noopener ugc nofollow" target="_blank">权重&amp;偏差</a>、<a class="ae lt" href="https://neptune.ai/" rel="noopener ugc nofollow" target="_blank">海王星</a>、<a class="ae lt" href="https://www.tensorflow.org/tensorboard" rel="noopener ugc nofollow" target="_blank">张量板</a>等。我们将尝试触及其中一个的表面——ml flow跟踪<em class="li">(通常是因为它在跟踪实验中提供了很大的灵活性&amp;也与PyCaret集成)</em></p><h2 id="30f2" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">MLFlow基础知识</h2><p id="ea06" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">MLFlow是一款独立于库的开源工具，提供各种解决方案来管理端到端的ML工作流:</p><ul class=""><li id="7e84" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated"><a class="ae lt" href="https://www.mlflow.org/docs/latest/tracking.html" rel="noopener ugc nofollow" target="_blank"> MLFlow跟踪</a> <em class="li">(跟踪实验&amp;比较它们的结果)</em></li><li id="9716" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://www.mlflow.org/docs/latest/projects.html" rel="noopener ugc nofollow" target="_blank"> MLFlow项目</a></li><li id="45e8" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://www.mlflow.org/docs/latest/models.html" rel="noopener ugc nofollow" target="_blank"> MLFlow模型</a> <em class="li">(将各种ML库中的模型部署到各种服务平台)</em></li><li id="35a0" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://www.mlflow.org/docs/latest/model-registry.html" rel="noopener ugc nofollow" target="_blank">ml flow Model Registry</a><em class="li">(一个执行模型版本控制的中央存储库&amp;管理模型生命周期)</em></li></ul><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mu"><img src="../Images/42afc5be552645408f8e9387b64df26f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3x1zEOzhinjbPrDe.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated"><strong class="bd jq"> <em class="ls">图片来源:</em></strong><em class="ls"/><a class="ae lt" href="https://www.datanami.com/2018/06/05/databricks-launches-mlflow-to-simplify-machine-learning-lifecycle/" rel="noopener ugc nofollow" target="_blank"><em class="ls">data bricks开源MLflow简化机器学习生命周期</em> </a></figcaption></figure><p id="f21b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">本帖我们就来看看</em> <strong class="is hj"> <em class="li"> MLFlow跟踪</em> </strong> <em class="li">。您可以自由探索&amp;使用其他认为必要的组件。</em></p><p id="e611" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">MLflow跟踪组件提供了一个API和UI，用于记录参数、代码版本、指标和输出文件，同时在实验过程中执行ML代码并查看结果。</p><h2 id="599d" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">为PyCaret实验设置MLFlow跟踪</h2><p id="4ecd" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用MLFlow跟踪实验的功能已经嵌入PyCaret 2.0中(安装<code class="du mv mw mx my b">pycaret</code>时会自动安装<code class="du mv mw mx my b">mlflow</code>包)&amp;可以通过几个简单的步骤进行设置:</p><p id="3689" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">第一步:</strong>通过导入<code class="du mv mw mx my b">mlflow</code> &amp;调用<code class="du mv mw mx my b">set_tracking_uri(...)</code>函数设置跟踪服务器(本地或远程位置，日志&amp;跟踪的数据将存储于此)，跟踪服务器的地址如下:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="afca" class="mg jp hi my b fi nd ne l nf ng">import mlflow<br/><br/># To use a local folder to store the logs, prefic the full path with 'file:/' &amp; use it<br/>mlflow.set_tracking_uri('file:/&lt;full-path-to-local-folder&gt;')<br/><br/># To use a remote storage location, provide the HTTP URI, for example:<br/>mlflow.set_tracking_uri('&lt;https://my-tracking-server:5000&gt;')</span></pre><p id="06ba" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果没有显式设置，将在当前目录下创建一个名为<code class="du mv mw mx my b">mlruns</code>的文件夹&amp;日志将存储在那里。</p><p id="68a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">步骤2: </strong>调用<code class="du mv mw mx my b">setup(...)</code>函数时，使用以下附加参数开始记录实验:</p><ul class=""><li id="2ee9" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated"><code class="du mv mw mx my b">log experiment = True</code> <em class="li">(允许记录MLFlow服务器上的所有参数&amp;指标)</em></li><li id="0ef0" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><code class="du mv mw mx my b">experiment_name = &lt;name_of_experiment&gt;</code> <em class="li">(设置要记录的实验名称；如果没有设置，</em> <code class="du mv mw mx my b"><em class="li">'clf'</em></code> <em class="li">是默认名称)</em></li><li id="75b6" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><code class="du mv mw mx my b">log_plots = True</code> <em class="li">(可选:允许将特定图记录为</em> <code class="du mv mw mx my b"><em class="li">.png</em></code> <em class="li">文件)</em></li><li id="9560" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><code class="du mv mw mx my b">log_data = True</code> <em class="li">(可选:允许记录实验中使用的训练&amp;测试数据集)</em></li></ul><p id="4ef9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以像往常一样使用PyCaret来选择和训练我们想要的模型，调整超参数并通过度量和绘图来评估它们。所有与实验相关的元数据将自动记录到我们的跟踪服务器上，稍后可以使用MLFlow UI查看。</p><h2 id="7e8a" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">在MLFlow用户界面中导航</h2><p id="1c6e" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">完成实验后，我们可以继续在MLFlow UI中查看日志。这个UI支持可视化、搜索和实验之间的比较，并提供下载各种ML工件(模型、数据和元数据)以供进一步分析。</p><ul class=""><li id="c5fd" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">如果跟踪服务器是本地文件夹，则可以通过转到该文件夹并运行<code class="du mv mw mx my b">mlflow ui</code> <em class="li">(从终端)</em>或<code class="du mv mw mx my b">!mlflow ui</code> <em class="li">(从笔记本)来启动UI。</em>如果没有明确设置跟踪服务器，日志记录在当前目录下的<code class="du mv mw mx my b">mlruns/</code>文件夹中。因此，命令<code class="du mv mw mx my b">mlflow ui</code>可以从当前目录运行。进入<code class="du mv mw mx my b"><a class="ae lt" href="http://localhost:5000." rel="noopener ugc nofollow" target="_blank">http://localhost:5000</a></code> <a class="ae lt" href="http://localhost:5000." rel="noopener ugc nofollow" target="_blank">可以查看界面。</a></li><li id="ccd8" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">如果使用远程跟踪服务器，只需转到<code class="du mv mw mx my b"><a class="ae lt" href="http://ip-address-of-tracking-server:5000." rel="noopener ugc nofollow" target="_blank">http://ip-address-of-tracking-server:5000</a></code> <a class="ae lt" href="http://ip-address-of-tracking-server:5000." rel="noopener ugc nofollow" target="_blank">即可查看UI。</a></li></ul><p id="bdde" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以下是使用MLFlow跟踪的PyCaret实验的UI截图。正如您所看到的，在工作流的每一步中，每个模型的执行都被记录为一次运行，带有度量的细节、运行执行时间、度量&amp;还有源函数。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nh"><img src="../Images/941af34eaff279842e97e8e7c43bb0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3wQ39SMLa_qMFJsG"/></div></div></figure><p id="a8dc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">除了正在使用的最终模型<em class="li">(此处为Light GBM)</em>，您还可以找到在<code class="du mv mw mx my b">compare_models()</code>函数调用期间创建的所有其他模型的可点击链接。点击相应的模型会将您带到显示模型所有细节的页面，包括参数、指标、标签&amp;以及图表&amp;其他可下载的工件(如果在实验过程中创建的话)。它还包含代码片段，可用于使用<code class="du mv mw mx my b">mlflow</code> &amp;进行预测来加载保存的模型。如果需要，您还可以将您的模型“注册”到<em class="li"> MLFlow模型注册表</em>。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ni"><img src="../Images/44c169edd7d6e1fb5b545b0ebbef6d49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PNqxfFhhBWQ0UQGu"/></div></div></figure><p id="f1ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用MLFlow进行跟踪的一个有趣方面是，它允许您下载并使用那些在实验过程中未被考虑的模型(如运行<code class="du mv mw mx my b">compare_models()</code>后未被选择的模型)，因为它们对其他相关分析也很有用。</p><h2 id="7644" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">MLFlow(超出PyCaret)</h2><p id="6dfd" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如我们在上面看到的，MLFlow跟踪已经嵌入到PyCaret中&amp;只需几个简单的步骤就可以设置好。然而，MLFlow也提供了更多的灵活性&amp;可以很容易地集成到其他几个ML &amp; DL框架中，包括Scikit-Learn、Tensorflow、Keras、PyTorch、FastAI等，用于自动日志记录。你可以参考<a class="ae lt" href="https://www.mlflow.org/docs/latest/tracking.html#automatic-logging" rel="noopener ugc nofollow" target="_blank">文档</a>来理解它如何与这些框架一起使用。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="ac8d" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">模型部署:它是什么？</h1><p id="1566" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">理解了有效地试验我们的ML模型的各个方面之后，我们现在进入管道的最后阶段——将我们训练过的模型部署到生产中并使用它们进行推理。</p><p id="b7c3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">模型部署可以被认为是在生产环境中展示一个经过训练的ML模型的过程，以供世界上的其他人进行推理。</strong></p><p id="5315" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了最大限度地利用ML模型，它们必须被顺利地部署到生产中，以便企业可以开始在实践中使用它们。</p><p id="e67d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">有多种方法可以将ML模型部署和服务到生产环境中，其优势取决于具体的用例:</p><p id="aa33" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">离线预测</strong></p><ul class=""><li id="683a" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">当预测是针对单个事件时，通常在本地机器上完成&amp;直接从python代码生成</li><li id="3d58" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><em class="li">例如:在黑客马拉松(或通常的课程作业)中对测试数据集的预测</em></li></ul><p id="3cce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">批量预测</strong></p><ul class=""><li id="fe31" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">从文件/数据存储中定期输入的一组预测</li><li id="f466" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><em class="li">例如:基于用户在电子商务网站上的活动模式，用于预测通过每周电子邮件向用户推荐的一组产品的模型</em></li></ul><p id="2ed6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实时服务</strong></p><ul class=""><li id="d835" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">通常通过对云中服务的模型的HTTP调用进行按需预测(期望低延迟)</li><li id="d970" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><em class="li">例如:在用户上传图像的网站上提供的对象检测模型&amp;将其提交给服务器以检测图像中的对象。模型的结果几乎会立即返回到网站上。</em></li></ul><p id="f5f7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">流媒体</strong></p><ul class=""><li id="46fc" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">类似于批处理或实时，但有一个额外的队列来处理传入预测请求的高容量和可变性，以处理速率而不是到达速率提供服务</li><li id="a43b" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><em class="li">例如:在线欺诈检测模型，交易排队&amp;异步处理以验证事件是否为欺诈</em></li></ul><p id="d1c6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">不同的工具迎合了每一种方法。在这篇文章中，我们将探讨如何将我们的ML模型部署到云中&amp;用于进行实时预测。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="3ecb" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">将PyCaret模型部署到云</h1><p id="fedf" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在之前的博客中，我们使用PyCaret开发了一个完整的ML管道。我们开始熟悉使用<code class="du mv mw mx my b">save_model(...)</code>、<code class="du mv mw mx my b">load_model(...)</code>、&amp;、<code class="du mv mw mx my b">predict_model(...)</code>。现在，我们将看到最终部署我们经过训练的&amp;微调模型的步骤，以便&amp;稍后可以使用它进行推理。</p><p id="4c76" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个练习，我假设你已经完成了本系列第3部分的<a class="ae lt" href="https://nbviewer.jupyter.org/gist/tezansahu/f034faf9a86856f8d8859556a5ecf12c" rel="noopener ugc nofollow" target="_blank">教程</a> &amp;有了预测超导材料临界温度的混合模型。</p><h2 id="b41e" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">模型最终确定</h2><p id="d36f" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在PyCaret中设置实验时，我们将整个训练数据集分成训练和验证集。在管道中，我们在这个训练集上训练我们的模型，然后在保留的验证集上评估它，以验证我们的性能指标。但是一旦验证了我们选择的模型在保留的验证集上如预期的那样执行，我们可能想要在整个数据集上最后一次训练我们的模型(训练+验证)。这可以通过使用<code class="du mv mw mx my b">finalize_model(...)</code>来完成。</p><p id="2a31" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">要使用它，您必须运行</em> <strong class="is hj"> <em class="li">中级PyCaret </em> </strong> <em class="li">部分的</em> <code class="du mv mw mx my b"><em class="li">setup(...)</em></code> <em class="li">函数，使用</em> <code class="du mv mw mx my b"><em class="li">blended_model = load_model("blended_expt2")</em></code> <em class="li"> &amp;加载您保存的混合模型，然后使用</em> <code class="du mv mw mx my b"><em class="li">final_blended = finalize_model(blended_model)</em></code>在整个训练集上训练它</p><p id="8215" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成这一步后，我们现在可以继续将我们的模型部署到云中。</p><h2 id="d713" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">AWS上的模型部署</h2><p id="4fcc" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">虽然可以使用我们在上一篇文章中看到的<code class="du mv mw mx my b">save_model(...)</code>函数将一个经过训练的模型作为一个<code class="du mv mw mx my b">.pkl</code>文件部署到本地，但是我们也可以将我们的模型部署到云中。PyCaret允许用户将其模型部署到各种云平台，如AWS、Azure &amp; GCP。在这篇博客中，我们将看到如何将我们训练过的模型部署到AWS，因为我们已经创建了我们的自由层AWS帐户&amp;并且在学习使用DVC时已经在<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4">第2部分</a>中设置了我们的S3存储桶。</p><p id="d973" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">虽然必要的库，即</em> <code class="du mv mw mx my b"><em class="li">boto3</em></code> <em class="li">会在您安装第2部分中的</em> <code class="du mv mw mx my b"><em class="li">dvc[s3]</em></code> <em class="li">时自动安装，但是如果没有安装，您现在可以使用</em> <code class="du mv mw mx my b"><em class="li">pip install boto3</em></code> <em class="li">安装。还应该配置必要的环境变量</em> <code class="du mv mw mx my b"><em class="li">AWS_ACCESS_KEY_ID</em></code> <em class="li">、</em><code class="du mv mw mx my b"><em class="li">AWS_SECRET_ACCESS_KEY</em></code><em class="li">&amp;</em><code class="du mv mw mx my b"><em class="li">AWS_DEFAULT_REGION</em></code><em class="li">(如果已经完成，则忽略，同时遵循</em> <a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4"> <em class="li">第2部分</em> </a> <em class="li">)。</em></p><p id="f4f2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们可以简单地将模型部署到我们的S3存储桶，使用:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="244f" class="mg jp hi my b fi nd ne l nf ng"># Deploy model<br/>deploy_model(<br/>    model = final_blended, <br/>    model_name = 'lightgbm_deploy_1', <br/>    platform = 'aws', <br/>    authentication = {'bucket' : 'mlopsdvc170100035'}<br/>)</span><span id="486e" class="mg jp hi my b fi nj ne l nf ng"># Enter your respective bucket name in place of 'mlopsdvc170100035'</span></pre><h2 id="80f4" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">使用部署的模型进行推理</h2><p id="7da2" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">现在，正如我们使用<code class="du mv mw mx my b">load_model(...)</code> &amp; <code class="du mv mw mx my b">predict_model(...)</code>来使用本地保存的模型进行推断一样(参见第3部分)，我们可以使用这个组合来使用部署在AWS上的模型进行推断:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="4784" class="mg jp hi my b fi nd ne l nf ng">loaded_model = load_model(<br/>    'lightgbm_deploy_1', <br/>    platform = 'aws', <br/>    authentication = { 'bucket' : 'mlopsdvc170100035' }<br/>)</span><span id="2f50" class="mg jp hi my b fi nj ne l nf ng">predictions = predict_model(loaded_model, data=data_unseen)</span><span id="15c4" class="mg jp hi my b fi nj ne l nf ng">predictions.head()    # View some of the predictions</span></pre><p id="04b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们知道可以在应用程序中的任何地方使用上面的代码片段来加载部署的模型，并使用它进行批量预测。我们将在下一节中看到这一点，届时我们将使用我们的模型进行推理。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="4b42" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">使用<a class="ae lt" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI </a>进行实时服务</h1><p id="3529" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">一旦我们的模型被部署(本地或云上)，我们可以使用它来进行离线/批量预测，如前所述。但是，我们也可以为它提供一些平台，通过HTTP请求进行实时预测。为此，我们需要通过API(应用程序接口)向外界公开我们的模型。这是我们将在当前部分解决的问题。</p><h2 id="0bef" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">通过RESTful APIs服务模型</h2><p id="5560" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">对于那些不熟悉API或RESTful API的人，强烈建议您参考<strong class="is hj">附加资源</strong>部分中的<strong class="is hj">RESTful API简介</strong>，以便更好地理解它。然而，作为一个快速的概述，REST API将被请求资源的状态传递给客户机。在我们的场景中，所请求的资源将是从我们的ML模型中推断出来的。因此，我们的服务器将向客户端发送预测，客户端可以是任何东西——从web应用程序到移动设备。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nk"><img src="../Images/ac3ead860123675662c2c655bac11bbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5-IEh2n_LghcoJuc.png"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated"><a class="ae lt" href="https://phpenthusiast.com/blog/what-is-rest-api" rel="noopener ugc nofollow" target="_blank">什么是REST API？</a></figcaption></figure><p id="113a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用RESTful APIs来服务ML模型的一些优势是:</p><ul class=""><li id="d1ec" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">要增加客户端的数量，可以即时提供预测服务</li><li id="1daa" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">分离模型环境和面向客户的层，以促进团队相互独立地工作</li><li id="e511" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在不同的API端点组合几个模型是可能的</li><li id="cb65" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">通过在<a class="ae lt" rel="noopener" href="/@itIsMadhavan/what-is-load-balancer-and-how-it-works-f7796a230034">负载平衡器</a>后放置额外的实例，轻松扩展应用程序</li></ul><p id="dbe8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Python中有几个工具和框架(如FastAPI、Flask、Django等。)可用于创建一个后端服务器来加载和服务我们的模型以进行预测。我们将为这个博客继续使用FastAPI，因为它非常强大，但使用起来非常简单，并且有很好的文档。</p><h2 id="5496" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">FastAPI简介</h2><p id="96e8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">正如在其<a class="ae lt" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank">网站</a>、<em class="li">上提到的，“FastAPI是一个现代、快速(高性能)的web框架，用于基于标准Python类型提示用Python 3.6+构建API。”</em></p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nl"><img src="../Images/85bfa3f269d73ff39e2b86dcef44fde6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3FzJo8jfrRETclUZ"/></div></div><figcaption class="lo lp et er es lq lr bd b be z dx translated"><strong class="bd jq"> <em class="ls">图片来源:</em></strong><em class="ls"/><a class="ae lt" href="https://github.com/tiangolo/fastapi" rel="noopener ugc nofollow" target="_blank"><em class="ls">FastAPI—GitHub</em></a></figcaption></figure><p id="f366" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">自从最近开始以来，它已经得到了广泛的认可和采用(包括像优步和网飞这样的公司)。它提供了几个很酷的特性，包括使用<a class="ae lt" href="https://github.com/OAI/OpenAPI-Specification" rel="noopener ugc nofollow" target="_blank"> OpenAPI规范</a>，为API创建自动&amp;交互文档，使用各种方案的安全&amp;认证，编辑器支持(在VSCode &amp; PyCharm) &amp;众多“插件”。</p><p id="0c27" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多信息，请随意浏览<a class="ae lt" href="https://fastapi.tiangolo.com/" rel="noopener ugc nofollow" target="_blank"> FastAPI文档</a>。</p><h2 id="16c4" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">装置</h2><p id="8f87" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">使用<code class="du mv mw mx my b">pip install fastapi[all]</code>可以轻松安装FastAPI。与<code class="du mv mw mx my b">fastapi</code>一起，它安装了<code class="du mv mw mx my b">starlette</code> &amp; <code class="du mv mw mx my b">pydantic</code>库，这些库构成了<code class="du mv mw mx my b">fastapi</code>的主干。此外，它还会自动安装<code class="du mv mw mx my b">uvicorn</code>，作为运行<code class="du mv mw mx my b">fastapi</code>代码的服务器。</p><p id="3810" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><code class="du mv mw mx my b"><em class="li">uvicorn</em></code> <em class="li">是一个轻量级的ASGI服务器，&amp;也可以使用</em> <code class="du mv mw mx my b"><em class="li">pip install uvicorn[standard]</em></code> <em class="li">独立安装。涵盖ASGI服务器超出了本文的范围，但是你可以在</em> <strong class="is hj"> <em class="li">附加参考文献</em> </strong> <em class="li">一节中阅读。</em></p><h2 id="0240" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">为ML模型创建一个FastAPI服务器</h2><p id="38b8" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">有了关于FastAPI的背景知识，我们就可以编写代码来加载我们部署的模型&amp;使用FastAPI将它作为API端点。基本上，我们将启动一个服务器&amp;为用户提供API端点<code class="du mv mw mx my b">/predict</code>,上传任何包含数据的CSV文件以进行预测。以下是我们将努力完成的工作的大致轮廓:</p><ol class=""><li id="45eb" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn nm ku kv kw bi translated">设置FastAPI应用程序</li><li id="a910" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn nm ku kv kw bi translated">将部署的模型加载到应用程序中</li><li id="99a2" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn nm ku kv kw bi translated">创建一个POST端点<code class="du mv mw mx my b">/predict</code>来接受一个输入的CSV文件&amp;并将其转换成一个<code class="du mv mw mx my b">pandas</code>数据帧</li><li id="ff60" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn nm ku kv kw bi translated">使用模型对数据框架进行预测，并将结果返回给用户</li></ol><p id="fa7d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">所有这些只用了不到50行代码！<em class="li">(不包括文件中的注释)</em></p><p id="3f20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在深入研究代码之前，我们只需要安装几个包:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="cc7d" class="mg jp hi my b fi nd ne l nf ng"># To receive uploaded files (uploaded files are sent as "form data")<br/>$ pip install python-multipart   <br/> <br/># To load environment variables from .env file into the application<br/>$ pip install python-dotenv</span></pre><p id="0680" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在您希望存放服务器的文件夹中，创建一个<code class="du mv mw mx my b">.env</code>文件，如下所示:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="2c12" class="mg jp hi my b fi nd ne l nf ng">AWS_ACCESS_KEY_ID={your-access-key}<br/>AWS_SECRET_ACCESS_KEY={your-secret-access-key}<br/>AWS_DEFAULT_REGION=ap-south-1</span></pre><p id="a589" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="li">注意:</em> </strong> <em class="li">千万不要把你的</em> <code class="du mv mw mx my b"><em class="li">.env</em></code> <em class="li">文件上传到GitHub。始终将其添加到</em> <code class="du mv mw mx my b"><em class="li">.gitignore</em></code> <em class="li"> &amp;创建一个仅包含变量名(而非变量值)的备选</em> <code class="du mv mw mx my b"><em class="li">.env.example</em></code> <em class="li">文件，以便使用代码的人知道应用程序需要什么环境变量。</em></p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="0f84" class="mg jp hi my b fi nd ne l nf ng"><em class="li"># Import Uvicorn &amp; the necessary modules from FastAPI</em><br/>import uvicorn<br/>from fastapi import FastAPI, File, UploadFile, HTTPException</span><span id="6718" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Import the PyCaret Regression module</em><br/>import pycaret.regression as pycr</span><span id="2168" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Import other necessary packages</em><br/>from dotenv import load_dotenv<br/>import pandas as pd<br/>import os</span><span id="fc77" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Load the environment variables from the .env file into the application</em><br/>load_dotenv() </span><span id="a4d4" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Initialize the FastAPI application</em><br/>app = FastAPI()</span><span id="c9db" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Create a class to store the deployed model &amp; use it for prediction</em><br/>class Model:<br/>    def __init__(self, modelname, bucketname):<br/>        <em class="li">"""<br/>        To initalize the model<br/>        modelname: Name of the model stored in the S3 bucket<br/>        bucketname: Name of the S3 bucket<br/>        """</em><br/>        <em class="li"># Load the deployed model from Amazon S3</em><br/>        self.model = pycr.load_model(<br/>            modelname, <br/>            platform = 'aws', <br/>            authentication = { 'bucket' : bucketname }<br/>        )<br/>    <br/>    def predict(self, data):<br/>        <em class="li">"""<br/>        To use the loaded model to make predictions on the data<br/>        data: Pandas DataFrame to perform predictions<br/>        """</em><br/>        <em class="li"># Return the column containing the predictions  <br/>        # </em><em class="li">(i.e. 'Label') after converting it to a list</em><br/>        predictions = pycr.predict_model(self.model, data=data).Label.to_list()<br/>        return predictions</span><span id="db06" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Load the model that you had deployed earlier on S3. <br/># Enter your respective bucket name in place of 'mlopsdvc170100035'</em><br/>model = Model("lightgbm_deploy_1", "mlopsdvc170100035")</span><span id="eb0c" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Create the POST endpoint with path '/predict'</em><br/>@app.post("/predict")<br/>async def create_upload_file(file: UploadFile = File(...)):<br/>    <em class="li"># Handle the file only if it is a CSV</em><br/>    if file.filename.endswith(".csv"):<br/>        <em class="li"># Create a temporary file with the same name as the uploaded <br/>        # CSV file to load the data into a pandas Dataframe</em><br/>        with open(file.filename, "wb")as f:<br/>            f.write(file.file.read())<br/>        data = pd.read_csv(file.filename)<br/>        os.remove(file.filename)</span><span id="0791" class="mg jp hi my b fi nj ne l nf ng">        <em class="li"># Return a JSON object containing the model predictions</em><br/>        return {<br/>            "Labels": model.predict(data)<br/>        }    <br/>    else:<br/>        <em class="li"># Raise a HTTP 400 Exception, indicating Bad Request <br/>        # (you can learn more about HTTP response status codes </em><a class="ae lt" href="https://restfulapi.net/http-status-codes/" rel="noopener ugc nofollow" target="_blank"><em class="li">here</em></a><em class="li">)</em><br/>        raise HTTPException(status_code=400, detail="Invalid file format. Only CSV Files accepted.")</span><span id="02db" class="mg jp hi my b fi nj ne l nf ng"><em class="li"># Check if the environment variables for AWS access are available. <br/># If not, exit the program</em><br/>if os.getenv("AWS_ACCESS_KEY_ID") == None or os.getenv("AWS_SECRET_ACCESS_KEY") == None:<br/>    exit(1)</span></pre><p id="bb5b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们只需运行<code class="du mv mw mx my b">uvicorn main:app --host=0.0.0.0 --port=8000</code> &amp;就可以看到我们的服务器已经启动&amp;并在<code class="du mv mw mx my b">http://0.0.0.0:8000</code>上运行。0.0.0.0表示可以通过环回地址127.0.0.1以及机器的IP地址访问它</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es nn"><img src="../Images/3706bba3da2904f8666b2c3b361da932.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gOLWQTmkKbK-y6Xc"/></div></div></figure><p id="5987" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了测试我们的端点，我们可以在<code class="du mv mw mx my b">http://127.0.0.1:8000/docs</code>找到自动交互文档。您会看到POST <code class="du mv mw mx my b">/predict</code>端点已经创建，可以通过单击“立即尝试”来展开部分&amp;进行测试。您可以上传任何CSV文件(与训练数据具有相同的列)&amp;将其发送到服务器以返回实时预测:</p><p id="52e7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><em class="li">您可以通过从</em> <code class="du mv mw mx my b"><em class="li">material_superconductivity.csv</em></code> <em class="li">文件&amp;中抽取一些行来创建一个测试数据集，并将其保存为一个单独的文件。</em></p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es no"><img src="../Images/185e6b5cc2f60471bc8e9e7a999c2b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ht1ZEnforWIfVwlK"/></div></div></figure><p id="0741" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">您还可以使用上面文档中提到的<code class="du mv mw mx my b">curl</code>命令，用您想要的CSV文件以编程方式查询<code class="du mv mw mx my b">http://127.0.0.1:8000/predict</code>端点，以获得作为响应的预测。</p><p id="5db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这样，我们可以看到我们是如何轻松地部署和服务我们训练有素的ML模型，让用户通过RESTful API访问它。</p><h2 id="d925" class="mg jp hi bd jq mh mi mj ju mk ml mm jy jb mn mo kc jf mp mq kg jj mr ms kk mt bi translated">为ML/DL模型提供服务的通用模板</h2><p id="ad34" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">上面我们已经看到了如何使用FastAPI为部署在AWS上的PyCaret模型提供服务。这个概念可以扩展到任何ML/DL模型，使用FastAPI部署在本地或云上，以便用户可以通过API端点使用它。这样做的通用模板如下:</p><pre class="lk ll lm ln fd mz my na nb aw nc bi"><span id="b69e" class="mg jp hi my b fi nd ne l nf ng">1. Set up the FastAPI application<br/>2. Load the model(s) into the application<br/>3. Create required API endpoint(s) for users to submit data:<br/>   - These could be CSV file(s), image(s), JSON object(s), etc.<br/>   - Handle incoming data appropriately<br/>4. Use the indended model to predict the result(s) on the data submitted<br/>5. If successful, return the predictions, else raise an error</span></pre><p id="8192" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用这个通用模板，可以部署和服务使用任何框架(scikit-learn、PyTorch、TensorFlow等)构建的模型。)提供给用户(尽管其他框架也可能提供专用工具来服务于使用它们构建的模型)。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="f942" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">在线托管模型服务器</h1><p id="330d" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">在上面的例子中，我们在本地启动了FastAPI服务器并执行了预测。我们也可以使用几个选项在线托管这个API服务器:</p><ul class=""><li id="a228" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated"><a class="ae lt" href="https://towardsdatascience.com/autodeploy-fastapi-app-to-heroku-via-git-in-these-5-easy-steps-8c7958ef5d41" rel="noopener" target="_blank"> Heroku </a></li><li id="6320" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://fastapi.tiangolo.com/deployment/deta/" rel="noopener ugc nofollow" target="_blank">德塔</a></li><li id="5f78" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://fastapi.tiangolo.com/deployment/docker/" rel="noopener ugc nofollow" target="_blank">码头工人</a></li></ul><p id="ac88" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们鼓励感兴趣的人尝试一下这些选项。</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="c2a2" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">结束语</h1><p id="b0d4" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">恭喜你！您已经完成了这个关于MLOps基础知识的4篇博客系列的结尾部分。反思我们在这4篇文章中的学习，我们获得了一些使用工具的实践经验，这些工具可以自动化ML工作流程的每个阶段，并使其更加高效:</p><ul class=""><li id="2323" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated">我们通过尝试理解MLOps 的关键<strong class="is hj">原则&amp;实践，开始了第<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8">部分1 </a></strong></li><li id="2481" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4">第2部分</a>中，我们首先学习了<strong class="is hj">对ML项目</strong> &amp;的版本控制，然后使用<strong class="is hj"> DVC </strong>对<strong class="is hj">亚马逊S3 </strong>中的&amp;维护ML工件进行版本控制</li><li id="4173" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">在第3部分的<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-3-ml-experimentation-using-pycaret-747f14e4c28d">中，我们探讨了如何使用一个名为<strong class="is hj"> PyCaret </strong>的低代码ML框架高效地开发<strong class="is hj">端到端ML管道</strong></a></li><li id="3999" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated">我们通过学习使用<strong class="is hj"> MLFlow </strong> &amp;的<strong class="is hj">模型跟踪</strong>完成了这个最后的第4部分，也看到了如何<strong class="is hj">部署</strong>我们的模型到<strong class="is hj"/>&amp;<strong class="is hj">使用<strong class="is hj"> FastAPI </strong>服务</strong>它们</li></ul><p id="2636" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">完成了这4个部分的内容后，现在我们可以重温在<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8">第1部分</a> &amp;中介绍的MLOps堆栈模板，使用我们在这4篇博客系列文章中学习使用的工具&amp;框架来填充它。现在，我们的MLOps堆栈应该如下所示。</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es np"><img src="../Images/886cac75d1c5be08ae09e813cc4c7bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5fKh9lyqlWgel6Jl"/></div></div></figure><p id="aba6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当然，在每一步都有很多其他工具可以使用(正如在<a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8">第一部分</a>中提到的)。不过本系列介绍的框架也是配套的&amp;可以帮助你开始你的MLOps之旅！</p><p id="fedc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望你觉得这个MLOps系列的基础很有趣和有用。以下是本系列的其他博客:</p><ul class=""><li id="303b" class="km kn hi is b it iu ix iy jb lf jf lg jj lh jn kt ku kv kw bi translated"><a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-1-a-gentle-introduction-to-mlops-1b184d2c32a8"> <strong class="is hj">第1部分:</strong>MLOps简介</a></li><li id="6251" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-2-data-model-management-with-dvc-6be2ad284ec4"> <strong class="is hj">第二部分:</strong>数据&amp;模型管理同DVC </a></li><li id="fcb1" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" rel="noopener" href="/@tezansahu/fundamentals-of-mlops-part-3-ml-experimentation-using-pycaret-747f14e4c28d"> <strong class="is hj">第3部分:</strong>使用PyCaret的ML实验</a></li></ul><p id="ee2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">谢谢&amp;快乐编码！</p></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="4ed9" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">附加参考</h1><ul class=""><li id="f759" class="km kn hi is b it ko ix kp jb kq jf kr jj ks jn kt ku kv kw bi translated"><a class="ae lt" href="https://neptune.ai/blog/best-ml-experiment-tracking-tools" rel="noopener ugc nofollow" target="_blank">跟踪机器学习实验的15个最佳工具</a></li><li id="b3f6" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://searchapparchitecture.techtarget.com/definition/RESTful-API" rel="noopener ugc nofollow" target="_blank">RESTful API简介</a></li><li id="0294" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://dev.to/supanthapaul/getting-started-with-fastapi-create-apis-quickly-using-python-2a9f" rel="noopener ugc nofollow" target="_blank">快速API入门</a></li><li id="6142" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://towardsdatascience.com/tracking-ml-experiments-using-mlflow-7910197091bb" rel="noopener" target="_blank">使用MLFlow跟踪ML实验</a></li><li id="764f" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><code class="du mv mw mx my b"><a class="ae lt" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">uvicorn</a></code> <a class="ae lt" href="https://www.uvicorn.org/" rel="noopener ugc nofollow" target="_blank">文档</a></li><li id="74c3" class="km kn hi is b it kx ix ky jb kz jf la jj lb jn kt ku kv kw bi translated"><a class="ae lt" href="https://asgi.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank"> ASGI文档</a></li></ul></div><div class="ab cl lu lv gp lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hb hc hd he hf"><h1 id="02cf" class="jo jp hi bd jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh mf kj kk kl bi translated">关于作者</h1><p id="f10a" class="pw-post-body-paragraph iq ir hi is b it ko iv iw ix kp iz ja jb lc jd je jf ld jh ji jj le jl jm jn hb bi translated">嘿伙计们！我是Tezan Sahu，微软的数据和应用科学家。我在孟买的IIT大学获得了学士学位，主修机械工程，辅修计算机科学与工程。我对NLP、深度学习和区块链有浓厚的兴趣，喜欢使用前沿技术开发有趣的产品。</p><p id="3fd4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">网址:</strong> <a class="ae lt" href="https://tezansahu.github.io/" rel="noopener ugc nofollow" target="_blank">特赞萨胡|微软</a> <br/> <strong class="is hj"> LinkedIn: </strong> <a class="ae lt" href="https://www.linkedin.com/in/tezan-sahu/" rel="noopener ugc nofollow" target="_blank">特赞萨胡| LinkedIn </a> <br/> <strong class="is hj">邮箱ID:</strong><a class="ae lt" href="mailto:tezansahu@gmail.com" rel="noopener ugc nofollow" target="_blank">tezansahu@gmail.com</a></p></div></div>    
</body>
</html>