<html>
<head>
<title>Predicting the future using Machine Learning part V</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用机器学习预测未来第五部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-v-d8e9c54ef415?source=collection_archive---------24-----------------------#2021-01-12">https://medium.com/analytics-vidhya/predicting-the-future-using-machine-learning-part-v-d8e9c54ef415?source=collection_archive---------24-----------------------#2021-01-12</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="0c9e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">多元和全二元分布Python中的实现</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/6ced4e55e7a12e3f2e39b2dd4250eadb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7drc1Tki7CUClbYH"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">照片由<a class="ae jm" href="https://unsplash.com/@dlanor_s?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">德拉诺尔S </a>在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a></figcaption></figure><p id="be6a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><a class="ae jm" href="https://minasuntea.medium.com/predicting-the-future-using-machine-learning-part-iv-8747b319be5c" rel="noopener">本系列的第四部分</a>讨论了使用单变量模型的分类算法，但是在本文中，我们将更进一步，构建一个更好的分类算法。我将介绍多元分布，它适用于不止一个变量。因此，这些模型会产生更好的结果。</p><h2 id="45e1" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">多元分布</h2><p id="7ae1" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">我们仍将使用正态分布的概率密度函数，但现在我们需要多变量版本，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lj"><img src="../Images/6cb94b550991f71efbb3aa5ac2f923cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*3i3muou5bvnkvRNaXxJ_jA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">其中<strong class="bd kl"> <em class="lk"> x </em> </strong> <em class="lk">是用均值向量μ和协方差矩阵σ从正态分布中抽取的d维向量。</em></figcaption></figure><p id="68ed" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在可以使用来自<em class="ll"> Iris </em>数据集的所有4个变量，并计算每个类的均值向量和协方差矩阵。然后，这些可用于使用上述等式计算每个类别的概率密度函数。有了这些，还可以计算每个类别的后验概率，最后可以再次使用<a class="ae jm" href="https://minasuntea.medium.com/predicting-the-future-using-machine-learning-part-iv-8747b319be5c" rel="noopener">贝叶斯分类器</a>将数据点分类到最可能的类别中。</p><p id="09a1" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">但是，如果变量太多，协方差矩阵的参数数量可能会变得太大，无法完全适应数据量。因此，通常会对数据进行简化假设，以降低数据的复杂性。</p><h2 id="b38e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated"><strong class="ak">朴素二元分布</strong></h2><p id="90f4" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">一个众所周知的变体是<em class="ll">朴素贝叶斯</em>，其中假设所有变量都是独立的。这意味着只使用每个变量的方差，而不是协方差。这简化了协方差矩阵，使得它只在对角线上有元素。</p><p id="4b41" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">首先，我将讨论双变量(2个变量)分布，因为这将更容易绘制和推理。我使用花瓣数据(花瓣宽度和花瓣长度)作为2个变量，因为它们看起来会形成很好的簇。朴素贝叶斯模型的独立性假设大大简化了等式:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lm"><img src="../Images/1ef22491ccf7aff52022d5159154b7d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:752/format:webp/1*lP5v6CVIt_ec61jV0LEHbA.png"/></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">其中p(x₁|Cᵢ)是使用第一个变量的μ₁和σ₁的单变量分布，p(x₂|Cᵢ)是使用第二个变量的μ₂和σ₂的相同方程</figcaption></figure><p id="13e9" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在必须计算概率密度函数，就像我为<a class="ae jm" rel="noopener" href="/analytics-vidhya/predicting-the-future-using-machine-learning-part-iv-8747b319be5c">贝叶斯分类器</a>所做的一样，为此我编写了<em class="ll"> PDF_naive </em>函数。还需要检索花瓣宽度数据的平均值和标准偏差，如下所示:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ln"><img src="../Images/d1288b3613946628074c5ab9089168bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u331NwCi_QBFXvTYZ-HcAQ.png"/></div></div></figure><p id="8006" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">检索完所有需要的数据后，是时候绘制概率密度函数了。现在我们使用2个变量，这将是一个三维图。有几种方法可以在<em class="ll"> matplotlib </em>中制作3d图，但我选择了等高线图。首先，必须使用linspace为必须与meshgrid结合的每个维度创建X和Y值的网格。然后，可以计算每个类别的概率密度函数的Z值，这些值将成为等值线图:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lo"><img src="../Images/dc7284d68add00d904dcc0dd77322f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rTlfAahJJo47NzB8c0abVA.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lp"><img src="../Images/d9f25cbc6bc0a3c8c6fcebf54484ba93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qv2Iv-xZ4-DMT5-F9nzgfw.png"/></div></div></figure><p id="f633" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在剩下要做的就是计算后验概率、分类器和验证函数，以及生成花瓣宽度数据的平均值和标准偏差向量:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lq"><img src="../Images/abce082b656268a50ae7ce8b37de5608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*f7oWVBkTtMoRISl7OpxRDA.png"/></div></div></figure><p id="6ab2" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">使用<em class="ll"> validate_naive </em>函数，可以报告每个类别的正确预测百分比以及正确百分比的平均值:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lr"><img src="../Images/110f64fadba652b6dcceace02771062f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-Gw3foEJbxJ-rJFlIg3IQ.png"/></div></div></figure><p id="7b16" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这些会产生以下值:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ls"><img src="../Images/d3eb8e5fbf717fc88a833a4839d86485.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Wzyx4YqbGi9Xu9h1WU8pQ.png"/></div></div></figure><p id="7009" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">后验概率也可以用与概率密度函数相同的方式显示在图形中。这样，决策区域就用等高线图来表示了:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lt"><img src="../Images/ef5de9141613ef46e7f626dd3cd0ae31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AF3pQVB3-mat-77agk3_cw.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lu"><img src="../Images/ed8d73bf42020bd0521c430b5057ec07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lMqcbupNgnPG29FRDHOkVA.png"/></div></div></figure><h2 id="ce2e" class="kj kk hh bd kl km kn ko kp kq kr ks kt jw ku kv kw ka kx ky kz ke la lb lc ld bi translated">完全二元分布</h2><p id="f07f" class="pw-post-body-paragraph jn jo hh jp b jq le ii js jt lf il jv jw lg jy jz ka lh kc kd ke li kg kh ki ha bi translated">最后，我们将使用完整的协方差矩阵，将这个<em class="ll">简单的二元分布</em>与一个<em class="ll">完整的二元分布</em>进行比较。这可以通过使用<em class="ll"> SciPy </em> stats模块的内置函数<em class="ll">多元正态分布</em>轻松完成。这些函数在给定平均向量和协方差矩阵的情况下创建分布。这些可以通过使用来自<em class="ll"> Numpy </em>的<em class="ll">均值</em>和<em class="ll">协方差</em>函数来计算。</p><p id="7670" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">有了这个新函数，概率密度函数就可以像我们对<em class="ll">简单二元分布</em>所做的那样再次说明:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lv"><img src="../Images/9f3e95e6992e790ad4d67b4005e5a2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zC2Xitm9e0fbrDuA2kXCqg.png"/></div></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lw"><img src="../Images/ae99eece6f2af9e4e1e14c28adab2233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rk5ZenA0vqUuFNxuWsGjEw.png"/></div></div></figure><p id="b9e6" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">现在，用同样的方法，用<em class="ll">后验</em>、<em class="ll">分类</em>和<em class="ll">验证</em>功能，结果可以计算出来。对于这个模型，我构造了一些不同的函数，所以代码不会太多:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es lx"><img src="../Images/b6566611a0a66bcc837701c9780601f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uvImvOLTBL24eCUSeEFQfw.png"/></div></div></figure><p id="150c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">最后，结果可以计算和可视化:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es ly"><img src="../Images/76d79ad11558e8a76ccdfb7236a6ab70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ji5xc4OOBo_ohIfTHelYTQ.png"/></div></div></figure><p id="2719" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这些会产生以下值:</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es lz"><img src="../Images/608183ce94d674450d4224bf68a439b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:548/format:webp/1*GpSRZBjhBSmHh16nIhg-Fw.png"/></div></figure><p id="d654" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从上面显示的结果可以清楚地看出，使用的变量越多，分类就越好。有了这些模型，我已经到了这篇文章的结尾，也是讨论监督机器学习算法的结尾。在我的下一篇文章中，我将展示一个无监督机器学习算法的例子。</p></div></div>    
</body>
</html>