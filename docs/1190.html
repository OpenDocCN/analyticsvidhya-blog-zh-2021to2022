<html>
<head>
<title>4 Easy Tips for Working with Multi-CSV Datasets in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python处理多CSV数据集的4个简单技巧</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/4-easy-tips-for-working-with-multi-csv-datasets-in-python-dc362d390a01?source=collection_archive---------5-----------------------#2021-02-18">https://medium.com/analytics-vidhya/4-easy-tips-for-working-with-multi-csv-datasets-in-python-dc362d390a01?source=collection_archive---------5-----------------------#2021-02-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4e523c1bd816ccac47083287b44ea6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1YTnQnbV7XW8zM3otwDjeA.png"/></div></div></figure><p id="0392" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有人给过你一个被分割成几十个(甚至几百个)的数据集吗？csv文件？或者你可能想在你的第一次Kaggle比赛中一试身手，但是这个很酷的数据集来自一个无穷无尽的更小的数据集列表。更糟糕的是，当你设法一个接一个地阅读所有这些文件时，你的数据科学朋友已经转移到下一个热门竞争中，而你却被留在后面，沮丧而孤独，抓着你在Youtube上了解到的一个未使用的机器学习模型。</p><p id="746e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">是的，在你开始你的项目之前，第一次打开一个zip文件夹，你会发现很多。csv文件会让您有这样的感觉:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="91be" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不要害怕！拥有一个包含更多。csv文件比Dwight Schrute农场上的甜菜数量多(对于不喜欢《T2》和《办公室》的人来说，这是一个很大的数字)不一定会成为永久的障碍。只需几个对任何初学数据科学家来说都很容易实现的技巧，您就可以克服这些挑战，并学习将在您的整个数据科学职业生涯中为您服务的方法。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h2 id="59b3" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">为什么多CSV数据集具有挑战性(尤其是对于初学者)</h2><p id="df5c" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">当在Python中使用这种形式的数据集时，会带来一些实际挑战:</p><ol class=""><li id="e0e5" class="lb lc hh ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated"><strong class="ir hi">它们通常很大，所以内存限制可能是个问题。</strong></li><li id="3b27" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">阅读在100+。没有一些自动化的csv文件是耗时和低效的。</strong></li><li id="a99b" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">构建数千万行的数据框时出现不可预见的错误会浪费大量宝贵的时间。</strong></li><li id="a79b" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">当一切正常工作时，每次重启程序都要重新构建庞大的数据帧，这需要耗费时间和内存。</li></ol><p id="5103" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我的数据科学职业生涯之初，这些挑战是我开始前几个项目的真正障碍。<strong class="ir hi">使用Python处理大型多csv数据集的这4个简单技巧将帮助您应对这些挑战，因此您可以轻松构建和存储数据框，然后开始工作。</strong></p><p id="e07a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这个解释者，我将使用股票市场数据集<a class="ae lp" href="https://www.kaggle.com/hk7797/stock-market-india" rel="noopener ugc nofollow" target="_blank">，可以在Kaggle.com</a>下载。它由159个组成。csv文件，每个文件是从2017年1月1日开始的NSE上不同股票的一分钟一分钟的时间序列。数据集是干净的，并且有大量的文件要处理，这正是我们想要的。<a class="ae lp" href="https://github.com/JamieWinger/Stock-Market-India/blob/main/Stock%20Market%20India.ipynb" rel="noopener ugc nofollow" target="_blank">点击此处查看Jupyter笔记本的完整步骤。</a></p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h2 id="30fb" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated"><strong class="ak">提示1:将外置硬盘连接到Jupyter Lab(适用于Mac OS) </strong></h2><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/9f9588ce015bdc4e6e72b53a94c9efb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*3M15yjtcD9_vgbdZoNhm0w.png"/></div></figure><p id="9ca6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们假设，作为新的数据科学家，我们已经做出了明智的决定，购买一个外部硬盘驱动器，以避免不必要地将我们在整个传奇数据生涯中会遇到的所有有趣的大型数据集填满我们的本地硬盘驱动器。</p><p id="407b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">对于这个项目，我们已经将整个<a class="ae lp" href="https://www.kaggle.com/hk7797/stock-market-india" rel="noopener ugc nofollow" target="_blank">印度证券交易所Kaggle文件</a> (6.2 GB)下载到我们新的1 TB外置硬盘上，并准备在上面创造奇迹。在Jupyter实验室的笔记本里有csv文件。这是我们Juptyer实验室文件目录的截图:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/fd5fee579fd8656cada40026a517e880.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*m5XuKifKPToWhc7eLFbPxw.png"/></div></figure><p id="ffa3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">嗯…我们的外置硬盘在哪里？如果我们不能将外部硬盘连接到Jupyter实验室的文件目录，我们如何处理数据集？回车:终端外壳！</p><p id="007d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在Mac OS上，您可以通过单击Mac dock的launchpad图标并在搜索栏中键入terminal来访问您的终端:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es ls"><img src="../Images/ae0339e956ca7f8f5966b654cc7b1713.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*KVhZXf-UaXaIPthkKRV1Aw.png"/></div></figure><p id="1e45" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">单击终端图标，您将看到如下所示的终端外壳:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lt"><img src="../Images/22bcf723af100f484920f107c33fb8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jl71sCupXozrhJg33vw0bQ.png"/></div></div></figure><p id="7d02" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果您以前从未使用过终端shell，那么在本文范围之外这样做有很多好处。快速的谷歌搜索会产生大量的youtube选项，让你熟悉终端的技术和优势。<a class="ae lp" href="https://www.youtube.com/watch?v=oxuRxtrO2Ag&amp;t=17s" rel="noopener ugc nofollow" target="_blank">这只是我发现的一个例子。</a></p><p id="679e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经打开了终端外壳，我们就可以创建一个从外部硬盘到Jupyter实验室的直接连接。为了帮助形象化我们正在做的事情，请查看下面我的文件导航器的截图。实际上，我将告诉我的终端从“Backup Plus”位置打开Jupyter Lab(这是我的特定外部硬盘驱动器的名称，您的可能会不同)，而不是从默认位置打开，默认位置包含“Favorites”部分下可见的那些文件夹。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es lu"><img src="../Images/00aed48a078fe0dfa263448486882294.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*L9JFMIVg3Qeoos8TV2bxYg.png"/></div></figure><p id="acec" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好吧，是这样的:</p><ol class=""><li id="5aa6" class="lb lc hh ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated">首先，在终端中键入<code class="du lv lw lx ly b">cd /Volumes</code>,这将把您的操作目录移出默认卷。</li></ol><p id="e8c7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">2.接下来，键入<code class="du lv lw lx ly b">ls</code>,这将显示所有已挂载卷的名称。</p><p id="670f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在下面的截图中，你可以看到Macintosh HD，这是我们刚刚退出的默认卷。还可以看到Backup Plus，我的外置硬盘，这是我们要切换到的卷。快到了！</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lz"><img src="../Images/e2561c99d2e2d0d843dea589af8e5d2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gYwV79gYEaL9YcZOlcr6bQ.png"/></div></div></figure><p id="e719" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">要切换到Backup Plus，让我们再次使用更改目录命令，只需键入:<code class="du lv lw lx ly b">cd Backup\ Plus/</code></p><p id="d697" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi"> <em class="jn">注意:</em> </strong>确保正确键入目录路径的一个有用的快捷方式是使用终端shell中的“tab complete”功能。我实际上做的不是键入“Backup\ Plus/”并摸索斜线的正确方向，而是只键入我想要的驱动器的第一个字母“B ”,然后按“tab”按钮，它会自动以正确的格式填充目录路径的其余部分。</p><p id="5aa4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">当然，您的目录名和路径将与我的不同，但相同的快捷方式将在任何终端外壳上工作，并大大加快速度，尤其是在浏览目录中的几个文件夹时。</strong>然而，为了让事情变得简单，我将我的路径保持得非常短，这就是我们最终得到的结果:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/6e1625b5e4f2e1fc0eb368919a2df259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5pPijhw4xrr4lg59Rp5D2g.png"/></div></div></figure><p id="f844" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好了，现在我们在目标目录下操作。我们只需要打开朱庇特实验室。为此，只需在终端中键入<code class="du lv lw lx ly b">jupyter lab</code>。终端显示文本，Jupyter Lab自动在浏览器选项卡中打开。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/6d04f4de6ea6ce6e1b85341c1481b013.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6Aj5sI11tlZJt743b0yAg.png"/></div></div></figure><p id="5064" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们走吧！我们外部硬盘上的所有文件(包括包含我们数据集的印度证券交易所文件夹)现在都可以在Jupyter实验室的文件目录中看到。成功！</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es mc"><img src="../Images/cb3b973de223a5bae658148b506be530.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/1*MZnegeJMRscRh66iui77nQ.png"/></div></figure></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h2 id="1744" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">技巧2:使用Glob包创建要从数据集中读入的自定义文件列表。</h2><p id="cc40" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">既然Jupyter实验室可以与我们的外部硬盘和数据集对话，我们需要找出一种有效的方法将所有这些文件读入pandas数据框。让我们使用一些基本的目录导航命令来仔细看看我们的印度股票交易所文件。</p><p id="0752" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><code class="du lv lw lx ly b">pwd</code>显示您当前的目录，<code class="du lv lw lx ly b">cd</code>允许您切换到指定的新目录，就像在终端中一样。使用我们前面讨论过“制表符结束”特性来产生正确的目录名。它在Jupyter细胞中的工作方式与在终壳中完全相同。使用导航到该文件夹后。csv文件，键入<code class="du lv lw lx ly b">ls</code>列出所有。文件夹中的csv文件。</p><p id="fe8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这里有一个我的目录导航命令的截图作为例子。当然，根据文件组织和目录名的不同，确切的导航路径会有所不同:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es md"><img src="../Images/b470f703b63a7d12bcedb907755f620c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LwglJ6XUntBBBDSNK6FMFw.png"/></div></div></figure><p id="9a12" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">输出显示了一个很长的。csv文件，准确的说是159个。查看整个列表，这样我们就可以注意到文件命名约定中的模式，这对我们接下来的工作会很有用。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es me"><img src="../Images/7dcc7900e39bf21bd8f47e2730a1bd95.png" data-original-src="https://miro.medium.com/v2/resize:fit:642/format:webp/1*HMcCo9DfMYV-fvjrVzAhJQ.png"/></div></figure><p id="26d9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在我们继续下去之前，我们应该试着读一个。csv只是为了看一眼我们的数据并确认一切正常。让我们使用pandas快速读入我们数据集中的一个随机文件(同样，您的确切文件路径会有所不同)。</p><pre class="jo jp jq jr fd mf ly mg mh aw mi bi"><span id="cf78" class="kb kc hh ly b fi mj mk l ml mm">import pandas as pd</span><span id="1774" class="kb kc hh ly b fi mn mk l ml mm">df = pd.read_csv('/Volumes/Backup Plus/India Stock Exchange/FullDataCsv/NIFTY_100__EQ__INDICES__NSE__MINUTE.csv')<br/>df</span></pre><p id="7fad" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是我们的输出:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es mo"><img src="../Images/a245386ec6bb0fba6ed49fe184ab4434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*44PwzmAcSFxY6rQBMAJuDQ.png"/></div></figure><p id="b6ff" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一切看起来都很好，但是如果我们想要将我们的<em class="jn">整个</em>数据集加载到pandas数据框中，我们将需要一个更有效的方法来读取所有这些文件。幸运的是，我们可以使用来自<code class="du lv lw lx ly b">glob</code>库的<code class="du lv lw lx ly b">glob</code>模块来创建一个定制的文件路径列表，以匹配我们指定的模式。</p><p id="fbd8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了测试这一点，让我们尝试从我们的数据中创建一个文件子集的glob。如果我们回过头来查看FullDataCsv文件夹中所有文件的列表，我们会注意到有一些。代表不同漂亮索引的csv文件。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div class="er es mp"><img src="../Images/30e4a79404da3dfc6b1f659bda2867b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*kCLKlOZXvZVZ0eaM-oFLpw.png"/></div></figure><p id="1bdc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们抓住那些。为此，我们可以使用星号(*)指定后跟通配符的路径名</p><p id="e696" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">本质上，我们告诉Python获取指定路径中文件名中包含字符串“NIFTY”的所有文件。</p><p id="b81a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">它是这样工作的:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="311d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们的输出是glob中9个漂亮文件的列表:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mq"><img src="../Images/f9e610a6f1be1ffd08e37fdcd655a6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iFySu_FJbuJAffM-65REA.png"/></div></div></figure><p id="d61e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将文件路径列表方便地存储在一个变量中，我们可以将该变量传递给一个简单的算法，该算法使用for循环读入每个文件，并在遍历路径名列表时将每个文件添加到pandas数据帧中。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="c80d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，在这个循环中，我还在每次迭代中取“文件名”，去掉路径名和“.”。csv”扩展名，这样我只剩下一个字符串，它代表每个单独文件所代表的股票或指数的名称。然后，我创建一个新列，由每个文件的去除名称填充。这样，当股票和指数在更大的数据框中被追加到一起时，它们的名称就会附加到相应的分钟时间序列上，从而保留数据集的分析值。如果所有的。例如，csv文件表示一只股票几年来的时间序列，您不需要执行这一步，因为您知道所有数据都来自一只股票。</p><p id="8046" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">下面是我们的输出(带有新的“股票或指数名称”列):</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mr"><img src="../Images/ddce9bec38049ff6689781b93944b482.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j306EjgUEIyO1DeBm8swdg.png"/></div></div></figure><p id="a2f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">太好了！使用glob，我们已经设法在9。csv文件，在几秒钟内创建了一个拥有近300万行的pandas数据框。我们可以使用相同的glob方法，使用与上面完全相同的算法来读取整个数据集。<em class="jn">我们应该使用那个精确的算法吗？跳转后的答案…</em></p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h2 id="f3d3" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">技巧3:当使用所有。csv文件，编写先采样、快速失败的算法，并在缩放之前使用打印语句和时间戳进行调试。</h2><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="a5cd" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">比方说，在我不知情的情况下，有人在我的文件夹里放了一个垃圾文件。csv文件。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ms"><img src="../Images/256de52fe81854e05fd1ceba9d69e416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*txuwZ_qaJtwWLLRjBD1CRg.png"/></div></div></figure><p id="703c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">实际上，这可能是数据集附带的不同格式的文件，可能是数据字典或一些其他补充信息。在一个150多个文件的列表中，这样一个东西很容易被忽略。虽然这只是一个玩具示例，但是我们上面使用的算法可能会遇到glob中某个文件的问题，原因有一百万种。很有必要快速演示一下。</p><p id="3c95" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">(如果你和我一起编码，请随意将你自己的EVIL_FILE放在印度证券交易所的FullDataCSV文件夹中。否则，请坐在一旁，见证这个问题文件导致的恐怖表演。)</p><p id="1371" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">假设我们不知道我们的EVIL_FILE存在，我们尝试使用我们用来构建漂亮的数据框架的相同算法，只是现在我们使用一个glob来抓取数据集文件夹中的所有文件。再次查看完整的文件列表，看起来所有的文件名都有一个双下划线。让我们用它来创造我们的星球。它的工作方式和以前完全一样，我们只是在通配符中使用了双下划线而不是NIFTY。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="52ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">酷，现在我们又有了全局变量。这一次，该变量存储所有160个文件的列表。让我们向前冲，读入所有文件，不要对算法做任何修改。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="7c72" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">呀！这是我们的输出:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mt"><img src="../Images/46c07543ca394404a8e399dd7ee7369b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SUOg2UE9RCF3appJyHQajA.png"/></div></div></figure><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mu"><img src="../Images/5904f2eab55c30c53e9558c11ff16c62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REPqVDlOcSlOIHo2G9G2RQ.png"/></div></div></figure><p id="269f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这种情况下，我们知道错误的来源是EVIL_FILE。然而，如果我们真的有一个我们<em class="jn">不知道的问题文件，从这个错误输出中可能不会立即清楚哪里出错了。从这个小弯路中最重要的收获是，我的代码在输出这个错误之前运行了一个多小时。对于我们这些忙碌的数据科学家来说，这是一个代价高昂的失败。</em>T9】</p><p id="4a91" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所以我们不会重复同样的错误，让我们对代码做一些简单的修改来强化这个算法。</p><p id="6665" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，让我们创建一个基本的定时器函数，这样我们就可以跟踪for循环的每次迭代需要多长时间。我们将使用来自<code class="du lv lw lx ly b">datetime</code>库中的<code class="du lv lw lx ly b">datetime</code>模块。这是监控我们算法的一个很好的工具，因此我们可以更好地理解代码运行时发生了什么。</p><pre class="jo jp jq jr fd mf ly mg mh aw mi bi"><span id="1059" class="kb kc hh ly b fi mj mk l ml mm"># Importing the module<br/>from datetime import datetime</span><span id="21a3" class="kb kc hh ly b fi mn mk l ml mm"># Defining our timer function which we will use below<br/>def time_elapsed(start_time):<br/>    return datetime.now() - start_time</span></pre><p id="3564" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们还将使用前面使用的带有双下划线通配符的glob，只是这次我们将把这个glob变量传递给一个新的、更健壮的算法。</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="044d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">请注意，这段代码与我们第一次尝试读取全部160时使用的算法几乎完全相同。csv文件，除了3个强大的补充:</p><ol class=""><li id="00e1" class="lb lc hh ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated"><strong class="ir hi">在我们代码的开始，我们定义了一个“start”时间变量，它与一个print语句和一个“file_count”变量成对出现在“all_files”全局变量中。</strong>这些变量对于跟踪我们的代码进度都很有用。</li><li id="6fb1" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated">我们在for循环中添加了与关键行相对应的print语句，这样我们就可以在每次for循环迭代时跟踪相同的4个操作。注意，我们已经用我们在for循环上面定义的“time_elapsed()”函数填充了打印语句。另外，请注意，在第二个print语句(第16行)中，我们插入了“filename”变量，这样我们就可以准确地知道每次迭代中我们正在读取什么文件。这将准确地告诉我们什么时候我们的代码碰到了我们的问题EVIL_FILE。</li><li id="ed9c" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">最后，我们在代码的“pd.read_csv()”部分激活了一个非常强大的参数:“nrows”参数(第17行)。</strong>我们已经将nrows参数设置为10，000，这意味着我们的算法只能从每个参数中读取10，000行。csv文件。回想一下第一次。我们读入的csv文件有超过370，000行。通过将行数限制为10，000，我们将大大加快算法读取160个文件的速度，这将有助于我们更快地发现我们的问题EVIL_FILE文件。</li></ol><p id="d776" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">好的，让我们试一试，看看我们的输出。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/002c2ef2be1814e93d31701337d4d6f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sHFpkRZHPBKL28UIG1Hv5w.png"/></div></div></figure><p id="735d" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看到那些漂亮的打印报表和时间戳了吗？它们允许我们看到错误发生的确切位置(我们看到你，EVIL_FILE)。此外，因为我们只从每个文件中采样了10，000行，所以我们的算法只花了34秒就失败了，而不是一个小时。<strong class="ir hi">通过对我们的代码进行一些简单的添加，我们已经将发现和诊断问题的时间减少了几个数量级。</strong>采样、打印报表和时间戳FTW！</p><p id="e265" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在现实生活中，根据问题文件的内容，我们可以简单地将文件移到目标文件夹之外，或者改变glob的格式以跳过该文件。让我们采取第二种方法。原来我们想要的所有数据集文件都有字符串MINUTE，所以让我们将它用于我们的glob通配符…</p><pre class="jo jp jq jr fd mf ly mg mh aw mi bi"><span id="5d5b" class="kb kc hh ly b fi mj mk l ml mm">all_correct_files = glob(pathname='/Volumes/Backup Plus/India Stock Exchange/FullDataCsv/*MINUTE*')</span></pre><p id="d0dc" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">…并将我们的新glob变量传递给我们修改后的算法。这一次，我们所做的唯一更改是停用nrows参数，因为我们确信我们已经解决了这个问题。(如果我们想要更勤奋，我们可以再次运行10，000行采样的代码，以确认一切正常。这将产生一个1，590，000行的样本数据框，这是我们对159个文件的预期，但我们现在将跳过这一步。)</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="b829" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">既然我们已经解决了问题，我们就可以运行我们的算法，在代码运行一个小时的时候自信地走开(也许是狂看几集我们最喜欢的以斯克兰顿为背景的职场喜剧)。如果我们感到好奇，我们可以随时停下来，看一眼我们的屏幕，检查我们的打印语句和代码的进展。</p><p id="3ba5" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">这是我们输出的结尾，看看我们完整的数据框:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mw"><img src="../Images/397bb21836aae4d031612f20b3f48994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cHY5NPQWZ5o99pOe6XkS4g.png"/></div></div></figure><p id="deac" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">哇！我们的代码执行无误，现在我们有了一个包含整个数据集的数据框，差不多有6000万行。我们现在可以随心所欲地操纵和分析我们的数据。</p></div><div class="ab cl ju jv go jw" role="separator"><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz ka"/><span class="jx bw bk jy jz"/></div><div class="ha hb hc hd he"><h2 id="5236" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">第4部分:将大数据帧保存在parquet文件中，以便快速方便地访问。</h2><p id="87bb" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">多好的旅程啊！毕竟，以某种方式保存我们的数据框不是很好吗？这样我们就可以快速轻松地访问它，而不必再花一个小时将它读入Python。将数据框保存到拼花文件中是一个很好的解决方案。它是这样工作的:</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="6b2a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当我们将拼花读回Python时，我们有完全相同的数据框架:</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mx"><img src="../Images/b16f3376f5d11f3d2ce3e2afb52e74c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uTfY1cLKK0QvAK36LbR3gg.png"/></div></div></figure><p id="0593" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">将大数据帧保存到拼花文件也是管理内存限制的好方法。让我们用完全相同的数据框制作一个. csv文件，并比较文件大小。</p><figure class="jo jp jq jr fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es my"><img src="../Images/485a5152d6ecea98e6d1daf8ceafda02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vAM8we6ItNoiA_kkw6qZ6w.png"/></div></div></figure><p id="a5f2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">注意，拼花文件是<strong class="ir hi"> <em class="jn">的四分之一不到</em> </strong>的大小。csv文件。当我们谈论大于10或20 GB的大型数据集时，使用parquets存储我们的数据帧可以节省大量成本！</p><figure class="jo jp jq jr fd ii"><div class="bz dy l di"><div class="mz jt l"/></div></figure><h2 id="1f40" class="kb kc hh bd kd ke kf kg kh ki kj kk kl ja km kn ko je kp kq kr ji ks kt ku kv bi translated">结论</h2><p id="4ef4" class="pw-post-body-paragraph ip iq hh ir b is kw iu iv iw kx iy iz ja ky jc jd je kz jg jh ji la jk jl jm ha bi translated">迈克尔又开心起来，准备好接受这些挑战。csv文件！让我们快速回顾一下我们所讲的内容，以便高效地构建和存储我们的印度股市数据集，该数据集以159的形式提供给我们。csv文件:</p><ol class=""><li id="a027" class="lb lc hh ir b is it iw ix ja ld je le ji lf jm lg lh li lj bi translated"><strong class="ir hi">首先，我们使用终端shell直接从外部硬盘运行Jupyter实验室。</strong>这消除了在本地硬盘上存储数据集的内存限制。</li><li id="9608" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">接下来，我们使用glob包来定义一个变量，该变量存储了我们使用glob的通配符特性指定的文件列表。这允许自动读取我们的。csv文件转换成熊猫数据框。</strong></li><li id="8d5b" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">然后，我们讨论了用“nrows”参数增强读入算法的好处，以允许采样和添加打印语句和计时函数，帮助我们查看代码的进度、快速失败、诊断和在缩放之前调试。然后我们走开，让我们的代码构建一个包含所有159个印度股市文件的数据框架。</strong></li><li id="0303" class="lb lc hh ir b is lk iw ll ja lm je ln ji lo jm lg lh li lj bi translated"><strong class="ir hi">最后，我们使用parquets来保存和存储我们的数据框(比传统的使用更少的空间。现在，只要我们需要，我们可以在几分钟内读取整个印度股市数据集。</strong></li></ol><p id="e5f7" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">有了这些提示，您现在就可以探索和征服越来越大的新数据集了。冒险快乐！</p><p id="1088" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">点击<a class="ae lp" href="https://github.com/JamieWinger/Stock-Market-India/blob/main/Stock%20Market%20India.ipynb" rel="noopener ugc nofollow" target="_blank">查看完整的Jupyter笔记本</a>及所有代码。</p><p id="6ad2" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在LinkedIn 上打招呼<a class="ae lp" href="https://www.linkedin.com/in/tjamiewinger/" rel="noopener ugc nofollow" target="_blank">。</a></p></div></div>    
</body>
</html>