<html>
<head>
<title>Optimization Modelling in Python: Multiple Objectives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的优化建模:多目标</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/optimization-modelling-in-python-multiple-objectives-760b9f1f26ee?source=collection_archive---------0-----------------------#2021-05-30">https://medium.com/analytics-vidhya/optimization-modelling-in-python-multiple-objectives-760b9f1f26ee?source=collection_archive---------0-----------------------#2021-05-30</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="efab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在之前的两篇 <a class="ae jd" rel="noopener" href="/@igorshvab/optimization-modelling-in-python-metaheuristics-with-constraints-c22b08c487e8">文章</a>中，我描述了单目标优化问题的精确和近似解决方案。虽然人们在实践中可能遇到的大多数问题确实是单目标的，但多目标优化(<strong class="ih hj"> MOO </strong>)在制造业和汽车行业都有其应用领域。</p><p id="2193" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在本文中，我将展示单目标优化问题和多目标优化问题之间的区别，并将简要描述解决后者的两种最流行的技术- <strong class="ih hj"> ε约束</strong>和<strong class="ih hj"> NSGA-II </strong>算法。</p><p id="990d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x1，x2，xj … x_n —优化问题的坐标搜索空间。</p><p id="38aa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> x </strong> (x1，x2，xj … x_n) —候选解。搜索空间中的一点。</p><p id="7cd5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">Fi</strong>—<strong class="ih hj">x</strong>处的目标函数值。</p><p id="d14d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在单目标优化问题中，一个解决方案相对于其他解决方案的优越性很容易通过比较它们的目标函数值来确定。在多目标情况下，人们不能直接比较一个目标函数值与另一个目标函数值。在这种情况下，解决方案的优劣由<strong class="ih hj">优势</strong>决定。</p><p id="6634" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解<strong class="ih hj"> x1 </strong>支配<strong class="ih hj"> x2 </strong>如果:</p><ul class=""><li id="62f0" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc jj jk jl jm bi translated">解决方案<strong class="ih hj"> x1 </strong>在所有目标上都不比<strong class="ih hj"> x2 </strong>差</li><li id="28a8" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc jj jk jl jm bi translated">并且解决方案<strong class="ih hj"> x1 </strong>至少在一个目标上严格优于<strong class="ih hj"> x2 </strong></li></ul><p id="2c01" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据这个定义，任何一组解都可以分为支配子集和非支配子集。整个可行决策空间的非支配集称为<strong class="ih hj">帕累托最优</strong>或<strong class="ih hj">帕累托有效集</strong>。帕累托效率是这样一种情况，当一个人不能在不使<strong class="ih hj"> Fj </strong>变得更糟的情况下改善关于<strong class="ih hj"> Fi </strong>的解<strong class="ih hj"> x </strong>时，反之亦然。在这个集合中没有“最佳解决方案”，因此用户可以根据业务需求选择任何一个解决方案。通常帕累托最优解可以由线或面连接起来。这样的边界称为<strong class="ih hj">帕累托最优前沿</strong>。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es js"><img src="../Images/f1dd00717e6acafac28d611a9bb7979d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hu4PJinxqnv7TbUGem_5kw.png"/></div></div><figcaption class="ke kf et er es kg kh bd b be z dx translated">方案B和方案C都不占优，都是帕累托最优的。</figcaption></figure><p id="472a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">多目标优化的目标是找到尽可能接近帕累托前沿的一组解。在本文的剩余部分，我将展示两个解决MOO问题的实际实现。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="44d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">ε-约束</strong>是一种经典技术，属于MOO问题的标量化方法。本质上，标量化方法试图以某种方式将MOO重新表述为单目标问题。例如，在最简单的方法中，多个目标被线性组合成一个具有任意权重的总体目标函数。这种方法的缺点是，为了选择合适的权重，必须事先知道每个目标函数。在<strong class="ih hj">ε-约束</strong>方法中，我们仅优化一个目标函数，同时将其他函数限制在用户特定的值内，基本上将它们视为约束。让我们考虑下面这个超级简单的线性例子:</p><p id="6c17" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最大化</strong> F1 = x1</p><p id="f587" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">最大化</strong> F2 = 3x1 + 4x2</p><p id="6a6e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">约束</strong> : x1 &lt; = 20</p><p id="18fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">x2 &lt;= 40</p><p id="4d93" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5x1 + 4x2 &lt;= 200</p><p id="5679" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">We are going to solve this problem using open-source <strong class="ih hj"> Pyomo </strong>优化模块。代码片段如下。</p><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="kp kq l"/></div></figure><p id="ef7d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">简而言之:</p><ol class=""><li id="4fca" class="je jf hi ih b ii ij im in iq jg iu jh iy ji jc kr jk jl jm bi translated">首先我们分别优化<strong class="ih hj"> F1 </strong>和<strong class="ih hj"> F2 </strong>，只是为了了解<strong class="ih hj"> F2 </strong>在<strong class="ih hj"> F1 </strong>优化过程中的取值范围。</li><li id="1137" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kr jk jl jm bi translated">然后我们把<strong class="ih hj"> F2 </strong>函数重写为约束:<strong class="ih hj"> F2 - slack_variable == ε </strong>。其中<strong class="ih hj"> ε </strong>是用户定义的值，可选的松弛变量只是帮助优化器更好地探索整个决策空间。此时，整个问题只有一个目标函数<strong class="ih hj"> F1 </strong>和一个附加约束。</li><li id="7847" class="je jf hi ih b ii jn im jo iq jp iu jq iy jr jc kr jk jl jm bi translated">最后在<strong class="ih hj"> F2 </strong>值范围内迭代所有可能的<strong class="ih hj"> ε </strong>值，并在每一步优化新制定的问题。</li></ol><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ks"><img src="../Images/0107fe0ca0c7f55db681afc3a1724939.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wp1GA8q5AT8t9zbK9UodpA.png"/></div></div></figure><p id="57e4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">上图显示了这个简单的线性多目标优化问题的帕累托前沿。值得指出的是，大多数情况下解决方案的分布非常不均匀。例如，对于这个特殊的问题，许多解决方案都集中在右下角。在下一个例子中，我将展示如何对帕累托最优解进行采样，以产生不同的解集。</p></div><div class="ab cl ki kj gp kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="hb hc hd he hf"><p id="c906" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在现实世界的应用中，当目标函数是非线性的或具有不连续的变量空间时，上述经典方法可能不能有效地工作。启发式方法如遗传算法(GA)被证明是经典方法的优秀替代品。在本节中，我们将应用最流行的启发式方法之一— <strong class="ih hj"> NSGA-II </strong>(非支配排序遗传算法)来解决非线性MOO问题。具体来说，我们将在测试函数上测试NSGA-II。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kt"><img src="../Images/c2bb8cc3b296c10780d8dce978441a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:856/format:webp/1*cgegvVtGdK2YK_HELe9Edg.png"/></div></figure><p id="613e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在深入研究代码之前，值得指出的是，传统的GA处理二进制向量，即由0和1组成的向量。在给定示例中，解向量由小数<strong class="ih hj"> x </strong> (x1，x2，x3)组成。虽然总是可以将十进制转换为二进制形式，但我们仍然可以将相同的GA逻辑应用于常见的向量。</p><p id="f173" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在进化算法术语中，解向量被称为<strong class="ih hj">染色体</strong>，它们的坐标被称为<strong class="ih hj">基因</strong>，目标函数值被称为<strong class="ih hj">适应度</strong>。页面底部给出了详细注释的python代码。以下是简单的算法描述和目标函数值图。</p><figure class="jt ju jv jw fd jx er es paragraph-image"><div role="button" tabindex="0" class="jy jz di ka bf kb"><div class="er es ku"><img src="../Images/064ca1acff4295351c86f1015612f6e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pXoMEd3OnM514gGHBnpYIQ.png"/></div></div></figure><figure class="jt ju jv jw fd jx er es paragraph-image"><div class="er es kv"><img src="../Images/be6759c9aded50e4bb4e54cc1e31d4c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*7biArW_ZhKTl773_1dFR9g.png"/></div></figure><figure class="jt ju jv jw fd jx"><div class="bz dy l di"><div class="kp kq l"/></div></figure></div></div>    
</body>
</html>