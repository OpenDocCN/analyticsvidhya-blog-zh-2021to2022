<html>
<head>
<title>Author Identification using Naive Bayes Algorithm — Deployment with Flask &amp; Dockers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用朴素贝叶斯算法识别作者——使用Flask &amp; Dockers部署</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/author-identification-using-naive-bayes-algorithm-deployment-with-flask-dockers-1a1484f4fd07?source=collection_archive---------10-----------------------#2021-01-05">https://medium.com/analytics-vidhya/author-identification-using-naive-bayes-algorithm-deployment-with-flask-dockers-1a1484f4fd07?source=collection_archive---------10-----------------------#2021-01-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="11aa" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">托马斯·贝叶斯能区分史蒂夫·罗杰斯和托尼·斯塔克吗？</h2></div><p id="4f53" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是演示构建简单ML模型并将其部署到API端点的过程的三部分系列文章中的最后一篇。之前，我们已经看到了如何从网络上抓取数据来构建由两个角色美国队长和钢铁侠讲述的对话数据集。随后，我们看到了朴素贝叶斯算法的说明性概述，并建立了一个模型(条件概率字典)来识别给定对话的作者。你可以参考<a class="ae js" rel="noopener" href="/swlh/author-identification-with-naive-bayes-algorithm-2-8b43854c1429">这篇文章</a>来了解模型构建阶段的概况。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/d187ba3186117cf2bc8d2de019877b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zVpOnAdROiLlXSpC"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">照片由<a class="ae js" href="https://unsplash.com/@ryan_yoo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Ryan Yoo </a>在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="6f94" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为一名ML从业者，有能力将你的工作部署为API或web应用程序是至关重要的，这样人们就可以使用你的模型进行推理。在这篇文章中，我们将使用Flask &amp; Flasgger将我们的模型部署到一个API端点，使用Docker将其容器化，并将这个应用程序部署到Heroku。让我们开始吧。</p><p id="7845" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先你必须安装两个库，即Flask和Flasgger。这可以在pip包管理器的帮助下简单地完成，如下所示</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="017a" class="ko kp hh kk b fi kq kr l ks kt">pip install Flask<br/>pip install Flasgger</span></pre><p id="5e04" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Flask是一个用python编写的微型web框架，而Flasgger是一个flask扩展，它可以从我们的API中注册的所有flask视图中提取openAPI规范。使用这两个库，我们可以构建一个全功能的用户友好的UI，向用户公开我们的模型。让我们看看如何在下面代码的帮助下达到同样的效果</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ku kv l"/></div></figure><p id="7a30" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">首先，我们导入所有必要的库，如Flask、Flasgger、pickle和utils模块，该模块包含帮助函数来预测给定对话的作者。接下来，我们通过从保存的pickled文件中取出在上一篇文章中创建的朴素贝叶斯模型来加载它。</p><p id="3fc0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在Flask中，我们使用<code class="du kw kx ky kk b">@app.route</code> decorator为端点编写代码，其中我们指定了路由的名称。在这个应用程序中，我们将有两条路线；一个是默认主页，另一个是predict_dialogue路由，它将加载我们的API来识别作者。</p><p id="5b23" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">home route什么也不做，只是简单地显示这个应用程序可以做什么的提示。它返回一个简单的HTML字符串，一旦应用程序启动并运行，该字符串就会呈现在主页上，如下面的代码片段所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kz"><img src="../Images/9dce656aa9c66b566ab0db9b8b724858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Xl9r0ESGthxxusY_ulK-A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="1efd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这方面的代码在附加到<code class="du kw kx ky kk b">@app.route(/)</code>装饰器的home函数中定义。接下来，我们将看看应用程序的核心部分，即predict_dialogue端点。</p><p id="1ba3" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的代码中，在我们为predict_dialogue定义函数之前，我们已经为端点编写了大量的文档，包括它能做什么、它期望什么作为输入、它输出什么等等。这就是Flasgger所看到的，当我们转到localhost中的apidocs子域时，我们会看到一个漂亮的UI，如下所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kz"><img src="../Images/318680fd05ab04c5a70d5182c598faa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HOGmCV6Gll2U77BUldT6oQ.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="f9af" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因为我们只有一个只接受POST请求的端点，所以我们把这个视图作为交互的选项之一。请注意，端点的名称是从装饰器中选取的，描述来自该端点的函数描述的第一行。接下来，如果我们单击POST请求的选项，我们会看到这个端点需要的不同参数</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es la"><img src="../Images/c3d11d302c994e0aad61ef7a5fcaede8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ry8a4Dzd0jkIofa47rFXhA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="64cc" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的例子中，我们只需要一个对话文本的参数。我们在函数定义中指定了端点需要这个参数，它是一个以红色显示的必填字段，它的名称是文本，它是一个查询参数，它的数据类型应该是字符串，所有这些都以蓝色圆圈显示。</p><p id="1e18" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">此外，在底部我们可以看到这个端点可能返回的不同响应；这一个简单地描述了当对话成功地用讲述者标记时，返回状态代码200。这也是从predict_dialogue函数的定义中选取的；定义中的“响应:”部分提到了所有这些代码并对它们进行了描述。</p><p id="c0ba" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">右上角的“试用”按钮可用于查询该API，如下所示:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es lb"><img src="../Images/2c5738a373b6a17ed4aa5152e58b4509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a70TdsUOdgMcvuk6N_om5A.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="5b9a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">单击“尝试”按钮后，您可以输入API所需的不同参数，然后单击“执行”按钮，该按钮将运行predict_dialogue函数，并返回使用朴素贝叶斯算法计算的概率预测的作者。这可以在回复正文部分看到，也可以随时下载。</p></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><p id="519d" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经启动并运行了端点，我们可以专注于如何使用docker将其容器化，但在此之前，让我们首先理解为什么我们应该使用docker。</p><h1 id="1ad7" class="lj kp hh bd lk ll lm ln lo lp lq lr ls in lt io lu iq lv ir lw it lx iu ly lz bi translated">为什么是码头工人？</h1><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ma"><img src="../Images/19d5d46f68a884ac4d8ad45e737b7a02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OYJC6LNjJ5n5w5jo"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">安德烈斯·洛佩斯·马尔多纳多在<a class="ae js" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="a030" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">考虑这样一个场景，作为一名开发人员，您正在本地系统上工作，构建一个端到端的web应用程序或任何相关的应用程序。一旦你完成了构建和测试，你把它交给QA团队，让他们测试这个应用程序，但是情况变得很糟糕，QA团队给你发了一大堆罚单，说什么都没用，你遇到过这种情况吗？</p><p id="6e8c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这是一种非常常见的情况，大多数情况下是由于操作系统、硬件、依赖关系等原因造成的。对开发者的环境和对QA的环境是不一样的。Dockers有助于解决这个问题，并且还提供了一些非常有用的可能性。这些措施如下</p><ol class=""><li id="4a56" class="mb mc hh iy b iz ja jc jd jf md jj me jn mf jr mg mh mi mj bi translated"><strong class="iy hi">环境标准化:</strong> Docker容器帮助将与运行特定应用程序相关的一切捆绑在一起，包括文件系统、网络功能、硬盘空间和RAM。这避免了开发者应用程序的用户像开发者一样设置环境的麻烦，这可能是一个艰苦的过程。</li><li id="257d" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><strong class="iy hi">隔离:</strong>这意味着每个docker容器作为一个进程是独立的，拥有自己的内存、网络能力和计算能力。与虚拟机不同的是，如果一个容器被停止，这些资源就会被释放，并可以被其他已经在运行的容器实例所利用。</li><li id="0dfe" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><strong class="iy hi">可移植性:</strong>一旦您构建了docker映像，您就可以将它分发给任何系统上的任何人，并且可以确信，如果它在您的系统上运行，它将在任何其他地方运行，也就是说，您只需要构建一次并将其部署到任何地方，它就一定会运行。</li></ol><p id="2359" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要构建docker，您需要首先在您的系统上安装并运行docker。您可以在此参考<a class="ae js" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank">官方文档页面</a>进行安装。我正在开发Ubuntu 18.04版本，可以很容易地按照这里的步骤在我的系统上安装docker。</p><p id="ddb4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们需要构建一个docker文件，其中包含构建docker映像的说明。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="ku kv l"/></div></figure><ol class=""><li id="c99b" class="mb mc hh iy b iz ja jc jd jf md jj me jn mf jr mg mh mi mj bi translated">我们将首先从Dockerhub获得一个基础映像，这里我们选择了anaconda基础映像，它包含许多已经安装了基础python的默认python包。我们选择了预装python3.x的anaconda3。我们使用FROM命令来实现这一点。</li><li id="b389" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated">接下来，我们将在<code class="du kw kx ky kk b">usr</code>目录中创建一个文件夹<code class="du kw kx ky kk b">app</code>,我们将在其中复制所有的应用程序文件。我们用复制命令来做这件事。</li><li id="9d31" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated">因为我们必须托管一个端点，所以我们需要提供一个用于通信的端口，我们使用EXPOSE命令并使用端口5000来实现这一点，我们可以选择8000、8888或任何其他可用端口。</li><li id="4c1c" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated">接下来，我们使用WORKDIR命令将工作目录设置为复制所有应用程序文件的位置。</li><li id="9ad9" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated">完成后，我们将下载应用程序运行所需的所有依赖项，如Flask、Flasgger、BeautifulSoup等。requirements.txt文件中提到了这一点</li><li id="82d5" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated">最后，我们将使用CMD命令运行命令来启动应用程序脚本。</li></ol><p id="5b2e" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们将把这个docker文件保存在与我们的应用程序文件相同的文件夹中，否则我们将不得不更改COPY命令中的代码，以便正确地将文件从我们的本地系统传输到docker容器中。一旦构建了这个docker文件，我们需要构建docker，这可以使用下面的命令来完成</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="80e3" class="ko kp hh kk b fi kq kr l ks kt">docker build -t rogers_stark_api .</span></pre><p id="c9c1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里rogers_stark_api是我希望与我的docker映像相关联的名称，我希望从与docker文件相同的路径构建它，因此有了<code class="du kw kx ky kk b">.</code>一旦您执行此命令，它将从Dockerhub提取anaconda基本映像，将文件从当前目录复制到usr/app，使用pip安装所有需求，并将端点暴露到端口5000(指定端口)。要确保docker映像构建成功，请键入</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="2034" class="ko kp hh kk b fi kq kr l ks kt">docker images</span></pre><p id="3ac5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在您的命令提示符/终端/ powershell下，您应该看到有一个名为rogers_stark_api的映像在您的系统上运行，如下所示。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mp"><img src="../Images/525f3b3f5d389be7cdb5b23d8dbb3cce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhvNNfDqfvVwn3TPa84sMg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="b414" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">一旦构建了映像，我们就可以使用命令运行它</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="e61a" class="ko kp hh kk b fi kq kr l ks kt">docker run rogers_stark_api</span></pre><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mq"><img src="../Images/f0ef43488594c097a2b0f01b76c5f79a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plAh_z7igk3nIEjVSpVNaw.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="2bd4" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们的应用程序将被托管，我们可以使用它。但还不完全是；因为托管我们的应用程序的IP地址实际上不是我们在inference.py文件中指定的地址，而是docker映像的地址。我们需要首先找出这一点，这可以通过下面的命令来完成</p><pre class="ju jv jw jx fd kj kk kl km aw kn bi"><span id="fb5a" class="ko kp hh kk b fi kq kr l ks kt">docker ps<br/>docker inspect CONTAINER_ID | grep '"IPAddress"' | head -n 1</span></pre><p id="d6f2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一个命令<code class="du kw kx ky kk b">docker ps</code>将显示api映像的容器id，然后下面的命令将显示该特定容器的IP地址。内容如下</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mr"><img src="../Images/3de4af56f2aa13f598466e980f268b72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ew2HZROGE8KAzTDw0ZmPA.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="1860" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在您已经有了IP地址，您可以转到地址172.17.0.2:8000/apidocs，然后您可以在浏览器中看到下面的api启动并运行。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es ms"><img src="../Images/250ff0f81852ce7ae1cd1f66179b60f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ayZnuys0dJSS15HG3uXPDg.png"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图片由Vinayak提供</figcaption></figure><p id="c5d2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这标志着这一系列文章的结束。希望你从这个系列中学习和理解的乐趣和我写它的乐趣一样多:)</p></div><div class="ab cl lc ld go le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ha hb hc hd he"><h1 id="0b99" class="lj kp hh bd lk ll mt ln lo lp mu lr ls in mv io lu iq mw ir lw it mx iu ly lz bi translated">参考</h1><ol class=""><li id="4fe0" class="mb mc hh iy b iz my jc mz jf na jj nb jn nc jr mg mh mi mj bi translated"><a class="ae js" href="https://docs.docker.com/engine/install/ubuntu/" rel="noopener ugc nofollow" target="_blank"> Docker安装指南</a></li><li id="54ee" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><a class="ae js" href="https://www.youtube.com/playlist?list=PLZoTAELRMXVNKtpy0U_Mx9N26w8n0hIbs" rel="noopener ugc nofollow" target="_blank"> Docker学习播放列表由</a> <a class="nd ne ge" href="https://medium.com/u/d67809141db2?source=post_page-----1a1484f4fd07--------------------------------" rel="noopener" target="_blank">克里斯·纳伊克</a></li><li id="aab5" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><a class="ae js" rel="noopener" href="/swlh/author-identification-using-naive-bayes-algorithm-1-abeeb88eb862">使用朴素贝叶斯的作者识别—数据收集</a></li><li id="356f" class="mb mc hh iy b iz mk jc ml jf mm jj mn jn mo jr mg mh mi mj bi translated"><a class="ae js" rel="noopener" href="/swlh/author-identification-with-naive-bayes-algorithm-2-8b43854c1429">利用朴素贝叶斯进行作者识别——建模</a></li></ol></div></div>    
</body>
</html>