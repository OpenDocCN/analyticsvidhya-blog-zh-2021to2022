<html>
<head>
<title>Write your own Custom Data Generator for TensorFlow Keras</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为TensorFlow Keras编写您自己的自定义数据生成器</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/write-your-own-custom-data-generator-for-tensorflow-keras-1252b64e41c3?source=collection_archive---------0-----------------------#2021-03-25">https://medium.com/analytics-vidhya/write-your-own-custom-data-generator-for-tensorflow-keras-1252b64e41c3?source=collection_archive---------0-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="11b9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">本教程处于中级水平，希望读者了解Python、TensorFlow和Keras的基本概念。</p><p id="4602" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，您希望使用一个定制的数据生成器来向模型提供值。有意思。为什么需要数据生成器？为什么是发电机？这个“发电机”是什么？数据生成器与机器学习有什么关系？</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/3baf8ae7fe24edc7b270efadf628899e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EjFvGZfb3FVBtWlR"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">弗兰基·查马基在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h1 id="646a" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是发电机？</h1><p id="0b86" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">如<a class="ae jt" href="https://www.python.org/dev/peps/pep-0255/" rel="noopener ugc nofollow" target="_blank"> PEP文件</a>所述:</p><blockquote class="kx ky kz"><p id="8a0a" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">当一个生产者函数有足够困难的工作需要维护所产生的值之间的状态时，大多数编程语言除了向生产者的参数列表中添加一个回调函数，用所产生的每个值来调用它之外，没有提供令人愉快和有效的解决方案。</p></blockquote><p id="9326" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，基本上发生的事情是，它不是把困难的(计算密集型或内存密集型)工作作为一个整体来做，而是把它分成几个批次，然后作为一个批次来处理。这样，调用子函数的父函数不必等到父函数完成处理，而是可以随时工作。我们在日常代码中使用的生成器函数是<code class="du le lf lg lh b">range</code>函数。当你用<code class="du le lf lg lh b">range(start, end, step)</code>写一个<code class="du le lf lg lh b">for</code>循环时，它不会创建一个包含从<code class="du le lf lg lh b">start</code>到<code class="du le lf lg lh b">end</code>的所有元素的列表，而是创建一个生成器，它可以生成从<code class="du le lf lg lh b">start</code>到<code class="du le lf lg lh b">end</code>的值，然后它会在运行中创建值。</p><h1 id="6fc2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">什么是数据生成器？</h1><p id="af2c" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">您是否遇到过这样的问题:数据集太大，无法一次加载到内存中，导致内存不足？例如，在训练一个图像分类器时，我们不能在训练前将所有这些图像加载到内存中。即使对于小数据集是可行的，对于大数据集也是不可行的。我们应该能够充分利用现有数据的潜力。</p><p id="8015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，如果我们创建一个数据生成器，我们就可以在移动中读取将用于训练的图像。因为我们在移动中读取图像，所以我们节省了内存，甚至8GB RAM的系统也可以用于100GB的数据集。</p><h1 id="eb85" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">标准Keras数据生成器</h1><p id="fa3f" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">Keras为图像数据集提供了一个数据生成器。这在<code class="du le lf lg lh b">tf.keras.preprocessing.image</code>中作为<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator" rel="noopener ugc nofollow" target="_blank"> ImageDataGenerator </a>类提供。使用<code class="du le lf lg lh b">ImageDataGenerator</code>的好处是它将生成带有增强的批量数据。<code class="du le lf lg lh b">ImageDataGenerator</code>用法如下</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><p id="7302" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du le lf lg lh b">train_generator</code>将是一个可以在<code class="du le lf lg lh b">model.fit</code>中使用的生成器对象。<code class="du le lf lg lh b">train_datagen</code>对象有三种方式提供数据:<code class="du le lf lg lh b"><a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow" rel="noopener ugc nofollow" target="_blank">flow</a></code>、<code class="du le lf lg lh b"><a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow_from_dataframe" rel="noopener ugc nofollow" target="_blank">flow_from_dataframe</a></code>和<code class="du le lf lg lh b"><a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator#flow_from_directory" rel="noopener ugc nofollow" target="_blank">flow_from_directory</a></code>。在本例中，使用了<code class="du le lf lg lh b">flow_from_directory</code>，这意味着根据目录结构加载数据。如果你有一个带有图像路径和标签的数据帧，它可以和<code class="du le lf lg lh b">flow_from_dataframe</code>方法一起使用。请参考本<a class="ae jt" href="https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d" rel="noopener ugc nofollow" target="_blank">要点</a>和<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/ImageDataGenerator" rel="noopener ugc nofollow" target="_blank">图像数据生成器</a>文档了解更多信息。</p><h2 id="465b" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">为什么我需要自定义数据生成器？</h2><p id="9f76" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">标准的Keras生成器功能有限。例如，如果您的网络有多个输出节点，您将无法使用标准数据生成器。它也不支持表格数据。因此，如果您有一个大的表格数据集，您将需要编写一个定制的生成器。最重要的是，为Keras实现一个数据生成器非常容易，而且非常强大和灵活。在将数据作为模型的输入之前，我们可以对数据执行复杂的功能和预处理。</p><h1 id="8383" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">如何编写自定义数据生成器</h1><p id="e6b0" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要理解定制数据生成器，您应该熟悉模型开发的基本方式以及如何在<code class="du le lf lg lh b">tf.keras</code>中使用<code class="du le lf lg lh b">ImageDataGenerator</code>。如果你做到了，那就很容易了。</p><p id="1dc9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">编写自定义数据生成器的一种方法是编写一个简单的生成器本身。这个<a class="ae jt" href="https://towardsdatascience.com/writing-custom-keras-generators-fe815d992c5a" rel="noopener" target="_blank">帖</a>中给出了这样一个生成器。这也适用于<code class="du le lf lg lh b">model.fit</code>，但建议使用<code class="du le lf lg lh b">tf.keras.utils.Sequence</code>为Tensorflow Keras创建数据生成器。在<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/Sequence" rel="noopener ugc nofollow" target="_blank">文件</a>中解释为:</p><blockquote class="kx ky kz"><p id="df88" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated"><code class="du le lf lg lh b"><em class="hi">Sequence</em></code>是一种更安全的多处理方式。这种结构保证了网络在每个时期的每个样本上只训练一次，这与发电机的情况不同</p></blockquote><h2 id="924d" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">使用序列的数据生成器</h2><p id="8415" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">要创建自定义数据生成器，需要创建一个从<code class="du le lf lg lh b">tf.keras.utils.Sequence</code>继承的类。如<a class="ae jt" href="https://www.tensorflow.org/api_docs/python/tf/keras/utils/Sequence" rel="noopener ugc nofollow" target="_blank">文档</a>中所述:</p><blockquote class="kx ky kz"><p id="95e7" class="if ig la ih b ii ij ik il im in io ip lb ir is it lc iv iw ix ld iz ja jb jc hb bi translated">每个<code class="du le lf lg lh b">Sequence</code>都必须实现<code class="du le lf lg lh b">__getitem__</code>和<code class="du le lf lg lh b">__len__</code>方法。如果你想在不同时期之间修改你的数据集，你可以实现<code class="du le lf lg lh b">on_epoch_end</code>。方法<code class="du le lf lg lh b">__getitem__</code>应该返回一个完整的批处理。</p></blockquote><p id="b1d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就这么简单。我们可以用我们想要的任何方式实现<code class="du le lf lg lh b">__getitem__</code>和<code class="du le lf lg lh b">__len__</code>方法。唯一的要求是<code class="du le lf lg lh b">__getitem__</code>方法应该返回<code class="du le lf lg lh b">(X, y)</code>值对，其中<code class="du le lf lg lh b">X</code>表示输入，<code class="du le lf lg lh b">y</code>表示输出。内部带有<code class="du le lf lg lh b">[batch_size, ...]</code>的输入和输出可以采用任何形状。</p><h1 id="d935" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">让我们进入代码</h1><p id="39f1" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">正如文档中提到的，我们需要实现两个方法。但是我也会实现一些我们在真实场景中使用的助手函数。</p><p id="3ded" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的目标是读取包含一些元数据的csv文件，并训练一个图像分类模型。我掌握的数据是物体探测数据。因此，一个单独的图像将包含多个对象，我需要从图像中裁剪出这些对象用于图像分类训练。还有，我的网络有两个输出节点，一个用于分类<code class="du le lf lg lh b">name</code>，另一个用于<code class="du le lf lg lh b">type</code>。使用标准的Keras <code class="du le lf lg lh b">ImageDataGenerator</code>类，并不是不可能的。</p><h2 id="e30e" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">数据</h2><p id="fc45" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">数据将是一个CSV文件，它将包含列</p><ol class=""><li id="d91d" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc md me mf mg bi translated"><code class="du le lf lg lh b">filename</code> / <code class="du le lf lg lh b">filepath</code> —图像在驱动器中的位置</li><li id="2202" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><code class="du le lf lg lh b">name</code> —将包含第一个标签“名称”的类别</li><li id="1560" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><code class="du le lf lg lh b">type</code> —将包含第二个标签“类型”的类别</li><li id="e708" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc md me mf mg bi translated"><code class="du le lf lg lh b">region_shape_attribues</code> —图像中感兴趣的区域</li></ol><p id="6229" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我的数据看起来像这样:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mm"><img src="../Images/0c5b088845a5aaeb1befcd00cad66075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*J_r7zr0LOUfjgyvV6gNjbA.png"/></div></figure><p id="0533" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">—模型的输入将是形状为<code class="du le lf lg lh b">(None, input_height, input_width, input_channel)</code>的图像，其中<code class="du le lf lg lh b">None</code>代表<code class="du le lf lg lh b">batch_size</code>。</p><p id="1a61" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">—模型的输出将是包含两个数组<code class="du le lf lg lh b">([None, n_name], [None, n_type])</code>的元组，其中<code class="du le lf lg lh b">None</code>表示<code class="du le lf lg lh b">batch_size</code>，<code class="du le lf lg lh b">n_name</code>是标签“名称”的类的数量，<code class="du le lf lg lh b">n_type</code>是标签“类型”的类的数量。</p><h2 id="cd77" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">入门指南</h2><p id="20bc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">数据生成器的输入将是数据帧以及要使用的列。另外，声明文档<code class="du le lf lg lh b">__getitem__</code>、<code class="du le lf lg lh b">__len__</code>和<code class="du le lf lg lh b">on_epoch_end</code>中提到的三种方法。让我们暂时将<code class="du le lf lg lh b">__getitem__</code>和<code class="du le lf lg lh b">on_epoch_end</code>留空。<code class="du le lf lg lh b">__len__</code>将返回生成器可以生产的批次数量，将为<code class="du le lf lg lh b">floor(number_of_samples // batch_size)</code>。我们还将计算“名称”和“类型”中唯一值的数量。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div></figure><h2 id="385f" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">__getitem__方法</h2><p id="9535" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated"><code class="du le lf lg lh b">__getitem__</code>方法的作用是生成一批数据。在这种情况下，一批数据将是<code class="du le lf lg lh b">(X, y)</code>值对，其中<code class="du le lf lg lh b">X</code>代表输入，<code class="du le lf lg lh b">y</code>代表输出。</p><ul class=""><li id="54c2" class="ly lz hi ih b ii ij im in iq ma iu mb iy mc jc mn me mf mg bi translated"><code class="du le lf lg lh b">X</code>将是一个形状为<code class="du le lf lg lh b">[batch_size, input_height, input_width, input_channel]</code>的NumPy数组。应该从磁盘中读取图像，从图像中裁剪出感兴趣的区域，并且必须根据数据帧进行预处理(如果有的话)。</li><li id="1784" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mn me mf mg bi translated"><code class="du le lf lg lh b">y</code>将是一个元组，包含两个形状为<code class="du le lf lg lh b">[batch_size, n_name]</code>和<code class="du le lf lg lh b"> [batch_size, n_type])</code>的NumPy数组。这些将是标签的一个热编码值。</li></ul><p id="18d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将定义两个助手函数，一个用于输入，另一个用于输出。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">输出的帮助函数</figcaption></figure><p id="cd5c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数接受一个图像的路径、作为字典的边界框和图像的目标尺寸。该函数将返回形状为<code class="du le lf lg lh b">[target_height, target_width, 3]</code>的NumPy数组。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">输出的帮助函数</figcaption></figure><p id="45c0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">该函数获取类的值和数量，并返回一个形状为<code class="du le lf lg lh b">[num_classes,]</code>的独热编码NumPy数组</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">生成包含批量样本的数据</figcaption></figure><p id="0f89" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个函数将接受一批数据，X_col作为一个字符串，y_col作为一个字典。它将迭代批处理并调用助手函数，聚合它们，并相应地返回一个元组<code class="du le lf lg lh b">(X, y)</code>。</p><p id="1cf5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du le lf lg lh b">__getitem__</code>函数使用索引从数据帧中取出一批数据，并将其传递给<code class="du le lf lg lh b">__get_data</code>函数，以获得用于训练的<code class="du le lf lg lh b">X</code>和<code class="du le lf lg lh b">y</code>。传入函数的<code class="du le lf lg lh b">index</code>将在训练时由<code class="du le lf lg lh b">fit</code>函数完成。使用该索引选择正确的数据批次。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">__getitem__方法使用一个批处理数据调用__getdata方法</figcaption></figure><h2 id="e789" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">在_纪元_结束时</h2><p id="a9fc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">该函数将在每个时期结束时由<code class="du le lf lg lh b">fit</code>方法调用。因此，在该函数中可以实现对历元之间的数据集的任何修改。我们将在这个函数中打乱数据集，以产生一些随机性。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">在每个时期后洗牌</figcaption></figure><h1 id="826e" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">CustomDataGen</h1><p id="76b4" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">合在一起，发电机看起来会像这样</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">CustomDataGen类作为一个整体</figcaption></figure><p id="4d0a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们只需要创建这个类的一个对象，并像这样把它传递给fit函数</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="li lj l"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">创建实例并拟合模型</figcaption></figure><h1 id="aab2" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">结论</h1><p id="e3dc" class="pw-post-body-paragraph if ig hi ih b ii ks ik il im kt io ip iq ku is it iu kv iw ix iy kw ja jb jc hb bi translated">现在，您可以通过更改<code class="du le lf lg lh b">__get_input</code>、<code class="du le lf lg lh b">__get_output</code>和<code class="du le lf lg lh b">__get_data</code>功能，根据Keras模型的任何输入和输出进行更改。由于我们的CustomDataGen是从<code class="du le lf lg lh b">Sequence</code>模块继承而来，所以整个操作将是线程化的，数据由CPU并行生成，然后直接馈送到GPU。</p><h2 id="45b9" class="lk jv hi bd jw ll lm ln ka lo lp lq ke iq lr ls ki iu lt lu km iy lv lw kq lx bi translated">一些常见错误以及如何避免它们</h2><ul class=""><li id="4208" class="ly lz hi ih b ii ks im kt iq mo iu mp iy mq jc mn me mf mg bi translated">定制数据生成器时最常见的错误是使用列表而不是NumPy数组。Tensorflow将抛出一个与此无关的错误，您可能会搜索几个小时才意识到这是一个问题。所以要经常检查你的数据和标签是否都是NumPy数组</li><li id="827a" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mn me mf mg bi translated">另一个常见错误是，当有多个输入/输出节点时，输入/输出的形状是错误的。永远记住要有一个带<code class="du le lf lg lh b">([batch_size, ...], [batch_size, ...], ...)</code>而不是<code class="du le lf lg lh b">([...], [...], ... [(batch_size — 1)nth item])</code>的批处理项元组。每个元组项目的大小必须是<code class="du le lf lg lh b">[batch_size, ...])</code>。</li><li id="c016" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mn me mf mg bi translated">确保<code class="du le lf lg lh b">__len__</code>的输出为<code class="du le lf lg lh b">int</code>类型。如果是任何其他类型的训练都会抛出错误，甚至<code class="du le lf lg lh b">np.int</code>。</li><li id="2281" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mn me mf mg bi translated">尝试从生成器中获得一个项目:<code class="du le lf lg lh b">X, y= traingen[0]</code>，这将有助于确保您从生成器中获得的输出是您所期望的</li><li id="fc94" class="ly lz hi ih b ii mh im mi iq mj iu mk iy ml jc mn me mf mg bi translated">由于<code class="du le lf lg lh b">to_categorical</code>需要整数输入，请务必在数据帧中对所有输入进行编码。如果没有，在生成器类中实现一个系统来处理它。</li></ul><p id="5fb8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您有任何疑问，请随时通过<a class="ae jt" href="mailto:arjun.06muraleedharan@gmail.com" rel="noopener ugc nofollow" target="_blank">arjun.06muraleedharan@gmail.com</a>联系我</p></div></div>    
</body>
</html>