<html>
<head>
<title>Linear Algebra In Machine Learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">机器学习中的线性代数</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/linear-algebra-in-machine-learning-dc60ad71a696?source=collection_archive---------18-----------------------#2021-01-06">https://medium.com/analytics-vidhya/linear-algebra-in-machine-learning-dc60ad71a696?source=collection_archive---------18-----------------------#2021-01-06</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><blockquote class="ie if ig"><p id="d217" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">我们将使用numpy线性代数模块</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jg"><img src="../Images/82c37c27aad0878f2ba2f03b6c4e02fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/0*nzx5x81XzjUO0kYn.jpeg"/></div></figure><p id="e216" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">线性代数是数学的一个分支，广泛应用于科学和工程领域。我们需要对线性代数有很好的理解，以理解许多机器学习算法的工作。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es jr"><img src="../Images/66977456b728110d88ecd26700ff4e6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/0*hCfEtJnXqBhQJJ_M.png"/></div></figure><p id="a8c6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">线性代数是机器学习的核心支柱。但是为什么呢？</p><blockquote class="ie if ig"><p id="9de7" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">机器学习算法描述在书籍，论文和网站上使用向量和矩阵符号。</p></blockquote><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es js"><img src="../Images/75e5d21699a2e4c272f22f94a5e5436d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8LdoCWZ4PNasEfUc"/></div></div></figure><p id="021a" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">线性代数是数据的数学，它的符号允许你用特定的运算符精确地描述对数据的运算。</p><p id="452e" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">numpy参考—<a class="ae jx" href="https://aditrisriv.medium.com/numpy-cheatsheet-7f67b2eee5ab" rel="noopener">https://aditrisriv.medium.com/numpy-cheatsheet-7f67b2eee5ab</a></p><p id="9002" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">要安装scipy，请运行以下语句——</p><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="dd06" class="kd ke hh jz b fi kf kg l kh ki">pip install scipy</span></pre><p id="a456" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">让我们导入两个库-</p><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="02f5" class="kd ke hh jz b fi kf kg l kh ki">import scipy.linalg as la<br/>import numpy as np</span></pre><p id="8192" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">创建向量、矩阵并对其进行整形</p><p id="fc3c" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi kj translated"><span class="l kk kl km bm kn ko kp kq kr di"> V </span>向量——向量是一组数字。这些数字是按顺序排列的。我们可以根据每个数字在这个顺序中的索引来识别它。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es ks"><img src="../Images/6a9d78f35a30f2b8f016138cda614c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*5l2RErGEKr02qUnOmmcopw.png"/></div></figure><p id="9bd1" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi kj translated"><span class="l kk kl km bm kn ko kp kq kr di">M</span><strong class="ik hi">A矩阵</strong>——矩阵是一个二维数组，所以每个元素都由两个索引来标识，而不仅仅是一个。</p><p id="a166" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi kj translated"><span class="l kk kl km bm kn ko kp kq kr di"> T </span>传感器——在某些情况下，我们需要一个具有两个以上轴的阵列。在一般情况下，排列在具有可变轴数的规则网格上的数字阵列被称为张量。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es kt"><img src="../Images/34849a3feebde2a5a1e200030237af7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*2zTkU8ecHvABlUBPKpoMVg.png"/></div></figure><p id="8308" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">我们这里有3个轴，所以让我们尝试通过一些修改来绘制。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es ku"><img src="../Images/63ac8399cf4b0aae473d003e7494cfda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icEjl63zoaiJHzE1JIcbrg.png"/></div></div></figure><p id="37fe" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">改变第零个颜色通道给我们红色，而第一个给黄色。</p><h2 id="be78" class="kd ke hh bd kv kw kx ky kz la lb lc ld jo le lf lg jp lh li lj jq lk ll lm ln bi translated">矩阵的转置</h2><p id="331f" class="pw-post-body-paragraph ih ii hh ik b il lo in io ip lp ir is jo lq iv iw jp lr iz ja jq ls jd je jf ha bi translated">使用python库和numpy。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es lt"><img src="../Images/02010df61af39715a9608286cf0db54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*NxdK7s8ZB-W9sEjVbcTCzQ.png"/></div></figure><h1 id="07a3" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated">元素乘法</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es ml"><img src="../Images/09cef854cd3ad04bf251cf3b37a1d8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CRxz6KD6wxlOgFuh64hoEg.png"/></div></div></figure><p id="34c6" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">但是如果我们从numpy创建矩阵，那么' * '运算符只执行矩阵乘法，而不执行元素乘法。</p><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es mm"><img src="../Images/4930f5c17aeaea380f151262d87bcd65.png" data-original-src="https://miro.medium.com/v2/resize:fit:688/format:webp/1*-ndTQb5_HVhoaB5U3zI9dw.png"/></div></figure><h1 id="0bcd" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated"><span class="l kk kl km bm kn ko kp kq kr di">至</span>获取身份矩阵</h1><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="9a45" class="kd ke hh jz b fi kf kg l kh ki">np.eye(3)</span><span id="523d" class="kd ke hh jz b fi mn kg l kh ki"><strong class="jz hi">OUTPUT</strong></span><span id="547d" class="kd ke hh jz b fi mn kg l kh ki">array([[1., 0., 0.],<br/>       [0., 1., 0.],<br/>       [0., 0., 1.]])</span></pre><h1 id="88a6" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated">让我们解一个方程组</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="er es mo"><img src="../Images/3aa9b5317b78805fc6d14ba0e61187b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XF-PUbN_GrF2A0QImdyh1A.png"/></div></div></figure><p id="739f" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">第一种方法:</p><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="416e" class="kd ke hh jz b fi kf kg l kh ki">A = np.array([[2,4,6],[1,-3,-9],[8,5,-7]])<br/>B = np.array([4,-11,1]) <br/>print(la.solve(A,B))</span><span id="0e49" class="kd ke hh jz b fi mn kg l kh ki">Output<br/><br/>[-8.52173913  9.69565217 -2.95652174]</span></pre><p id="e0a2" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">第二种方法:</p><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="7fbb" class="kd ke hh jz b fi kf kg l kh ki">Ainve = la.inv(A)<br/>np.dot(Ainve,B)</span><span id="90b4" class="kd ke hh jz b fi mn kg l kh ki">Output<br/>array([-8.52173913,  9.69565217, -2.95652174])</span></pre><h1 id="d491" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated">寻找特征值和特征向量</h1><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="c1ad" class="kd ke hh jz b fi kf kg l kh ki">A = np.array([[1,2,3],[0,4,5],[1,0,6]])<br/>eignvals , eignvector = np.linalg.eig(A)<br/>print(eignvals)<br/>print(eignvector)</span><span id="96c2" class="kd ke hh jz b fi mn kg l kh ki">Output :<br/><br/>[7.04096459 1.08849669 2.87053872] <br/>[[ 0.47577536  0.92699459 -0.56767265]  <br/>[ 0.75149246  0.3241272  -0.80302126]  <br/>[ 0.45705239 -0.18873948  0.18139628]</span></pre><h1 id="5ef1" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated">凯里-汉密尔顿定理</h1><div class="mp mq ez fb mr ms"><a href="https://en.wikipedia.org/wiki/Cayley%E2%80%93Hamilton_theorem#2%C3%972_matrices" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab dw"><div class="mu ab mv cl cj mw"><h2 class="bd hi fi z dy mx ea eb my ed ef hg bi translated">凯莱-汉密尔顿定理</h2><div class="mz l"><h3 class="bd b fi z dy mx ea eb my ed ef dx translated">在线性代数中，凯莱-汉密尔顿定理(以数学家亚瑟·凯莱和威廉·罗文的名字命名…</h3></div><div class="na l"><p class="bd b fp z dy mx ea eb my ed ef dx translated">en.wikipedia.org</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jm ms"/></div></div></a></div><pre class="jh ji jj jk fd jy jz ka kb aw kc bi"><span id="d47d" class="kd ke hh jz b fi kf kg l kh ki">A = np.array([[1,2],[3,4]])<br/>trace_A = np.trace(A)<br/>detA = la.det(A)<br/>I = np.eye(2)</span><span id="181f" class="kd ke hh jz b fi mn kg l kh ki">A@A -trace_A*A+detA*I</span><span id="226e" class="kd ke hh jz b fi mn kg l kh ki">Output :</span><span id="7eee" class="kd ke hh jz b fi mn kg l kh ki">array([[0., 0.],<br/>       [0., 0.]])</span></pre><h1 id="fa1c" class="lu ke hh bd kv lv lw lx kz ly lz ma ld mb mc md lg me mf mg lj mh mi mj lm mk bi translated">矩阵的逆</h1><figure class="jh ji jj jk fd jl er es paragraph-image"><div class="er es nh"><img src="../Images/e2ba648f123cb1351623056cf158afe7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*9fBNECm58NZKlKT94o5L6g.png"/></div></figure><blockquote class="ie if ig"><p id="829f" class="ih ii ij ik b il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf ha bi translated">给出了矩阵的伪逆。当矩阵的行列式为零时，这很有帮助，因为它仍然会给我们一些值，而不会像np.linalg.inv()那样抛出错误。</p></blockquote><p id="83fd" class="pw-post-body-paragraph ih ii hh ik b il im in io ip iq ir is jo iu iv iw jp iy iz ja jq jc jd je jf ha bi translated">谢谢你的阅读！！</p></div></div>    
</body>
</html>