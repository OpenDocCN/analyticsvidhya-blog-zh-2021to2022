<html>
<head>
<title>Generate basic boolean calculation models with Pytorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pytorch生成基本布尔计算模型</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/generate-basic-boolean-calculation-models-with-pytorch-5b7b880e7ef8?source=collection_archive---------8-----------------------#2021-07-01">https://medium.com/analytics-vidhya/generate-basic-boolean-calculation-models-with-pytorch-5b7b880e7ef8?source=collection_archive---------8-----------------------#2021-07-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9380" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开发人员还没有被机器人取代。但是如果我们不注意，不整合这些新技术，我们可能会有一些不好的意外。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/0ed3a27757527f34bd41b5089bf2ca65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xTcU74Gqaqi-KTxv5up7uw.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated"><a class="ae js" href="https://unsplash.com/@possessedphotography?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">附身摄影</a>在<a class="ae js" href="https://unsplash.com/s/photos/intelligence?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍照</figcaption></figure><p id="39bf" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有许多神经网络被用来做非常复杂的事情的例子，比如对图像或文本进行分类，在国际象棋中击败大师。</p><p id="8e20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但这不是我日常生活中经常做的事情。</p><p id="a23a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的日常生活就是编写代码<strong class="ig hi"> if </strong> <strong class="ig hi"> else </strong>，<strong class="ig hi"> for </strong>，将方形形状推入圆形管道，希望输入足够稳定，使我的算法<strong class="ig hi">不会崩溃</strong>。</p><p id="2dd5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为什么不直接告诉机器，如果我给它<strong class="ig hi">这个</strong>，它必须返回<strong class="ig hi">那个</strong>？不用发明任何东西，只要一点点<strong class="ig hi">逻辑</strong>，抽象到足以知道一辆自行车被<strong class="ig hi">当作一辆自行车一样对待</strong>。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="38f6" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">告诉我不</h1><p id="1070" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">让我们从一个非布尔计算开始。</p><p id="15bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我会用Pytorch来写我的机器学习算法。Pytorch是最后的神经网络框架之一，具有动态计算图形能力，这意味着你可以编写数学函数，就像你实际在做一样，Pytorch将能够从中生成图形。</p><p id="8a8f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这比传统的静态层更容易理解。</p><p id="1837" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我的数据:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="d92f" class="li kb hh le b fi lj lk l ll lm">import torch<br/><br/>x = torch.tensor([[0.], [1.]])<br/>y = torch.tensor([[1.], [0.]])<br/>train = torch.utils.data.TensorDataset(x, y)<br/>train_loader = torch.utils.data.DataLoader(train)</span></pre><p id="ba44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着如果它收到0，它必须返回1，如果它收到1，它必须返回0。</p><p id="dcce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以做到这一点的最简单的模型是一个线性函数y = weight * x + bias。代码如下:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="d8d4" class="li kb hh le b fi lj lk l ll lm">class NeuralN(torch.nn.Module):<br/><br/>    def __init__(self):<br/>        super(NeuralN, self).__init__()<br/>        self.linear = torch.nn.Linear(1, 1)<br/>        # force parameters to bias = 0 and weight = 1 for demonstration<br/>        self.linear.weight.data.fill_(1)<br/>        self.linear.bias.data.fill_(0)<br/><br/>    def forward(self, x):<br/>        return self.linear(x)<br/><br/>model = NeuralN()</span></pre><p id="046c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们训练它，并展示经典2D情节中的每一步:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="498f" class="li kb hh le b fi lj lk l ll lm">loss_fn = torch.nn.MSELoss()</span><span id="afff" class="li kb hh le b fi ln lk l ll lm">x = np.linspace(0, 1, 20)<br/>predicted_arr = []<br/>for i in x:<br/>    predicted = model(torch.tensor([i], dtype=torch.float32)).item()<br/>    predicted_arr.append(predicted)<br/>plt.plot(x, np.array(predicted_arr))<br/><br/>learning_rate = 0.3<br/>for t in range(20):<br/>    for i, (x_batch, y_batch) in enumerate(train_loader):<br/>        y_pred = model(x_batch)<br/>        loss = loss_fn(y_pred, y_batch)<br/>        model.zero_grad()<br/>        loss.backward()<br/>        with torch.no_grad():<br/>            for param in model.parameters():<br/>                variation = learning_rate * param.grad<br/>                param -= variation<br/>        predicted_arr = []<br/>        for i in x:<br/>            predicted = model(torch.tensor([i], dtype=torch.float32)).item()<br/>            predicted_arr.append(predicted)<br/>        plt.plot(x, np.array(predicted_arr))<br/><br/>plt.show()</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es lo"><img src="../Images/7a8054fb0cde2ae321fdd7da954171a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*HfNSU0KVTOZMdpYNwmJMHw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">预测结果，逐步训练</figcaption></figure><p id="7cc3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一条曲线是蓝色的，故意将<strong class="ig hi">强制</strong>为y = x。</p><p id="bd64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">需要的2个衍生产品是:</p><ul class=""><li id="2956" class="lp lq hh ig b ih ii il im ip lr it ls ix lt jb lu lv lw lx bi translated">相对于<strong class="ig hi">偏差</strong>的导数:2 * (y' -y)</li><li id="4704" class="lp lq hh ig b ih ly il lz ip ma it mb ix mc jb lu lv lw lx bi translated">相对于<strong class="ig hi">重量</strong>的导数:2 * (y' -y) * x</li></ul><p id="4683" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在第一步，x = 0，因此相对于重量的导数等于0，并且<strong class="ig hi">仅偏差被修改</strong>为以下值:</p><p id="e001" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2 *(y '-y)* learning _ rate = 2 *(0-1)* 0.3 =-0.6</p><p id="6c6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该偏差是从<strong class="ig hi">减去</strong>得到的。那是橙色曲线，对应于</p><p id="c8e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">y = 0.6 + x。</p><p id="ba34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来的步骤可以用同样的方法计算。几步就找到了所需的NOT函数:y = 1 -x。</p></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="e564" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">不要告诉我(异或)</h1><p id="3317" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">让我们来处理一个更难的布尔运算。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es md"><img src="../Images/f2c1c9de04aad4473725cebbeb4f36ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*IuZlYc6dojaG_IFGqB__Vw.png"/></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">这并不困难</figcaption></figure><p id="59a0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">单层感知器不能对异或问题建模。但是更进一步，用<strong class="ig hi">两层</strong>和<strong class="ig hi">乙状窦激活</strong>功能，你会看到它可以完成这项工作。</p><p id="576d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面是数据:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="8f25" class="li kb hh le b fi lj lk l ll lm">x = torch.tensor([[0., 0.], [1., 1.], [0., 1.], [1., 0.]])<br/>y = torch.tensor([[1.], [1.], [0.], [0.]])<br/>train = torch.utils.data.TensorDataset(x, y)<br/>train_loader = torch.utils.data.DataLoader(train)</span></pre><p id="fb67" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以如果我们输入0和0或者1和1，我们想要标签1。其他输入返回0。那是一个<strong class="ig hi">非(XOR)。</strong></p><p id="e014" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是我们建议的模型:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="5f25" class="li kb hh le b fi lj lk l ll lm">class NeuralN(torch.nn.Module):<br/>    def __init__(self):<br/>        super(NeuralN, self).__init__()<br/>        self.linear1 = torch.nn.Linear(2, 2)<br/>        self.sigmoid1 = torch.nn.Sigmoid()<br/>        self.linear2 = torch.nn.Linear(2, 1)<br/>        self.sigmoid2 = torch.nn.Sigmoid()<br/>    def forward(self, x):<br/>        x2 = self.linear1(x)<br/>        x2 = self.sigmoid1(x2)<br/>        x3 = self.linear2(x2)<br/>        return self.sigmoid2(x3)</span></pre><p id="1274" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们训练我们的模型(代码可以更简洁，但是这个允许<strong class="ig hi">一步一步地跟随训练</strong>):</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="6f2d" class="li kb hh le b fi lj lk l ll lm">model = NeuralN()<br/>loss_fn = torch.nn.MSELoss()<br/>learning_rate = 1<br/>for t in range(1000):<br/>    for i, (x_batch, y_batch) in enumerate(train_loader):<br/>        y_pred = model(x_batch)<br/>        loss = loss_fn(y_pred, y_batch)<br/>        model.zero_grad()<br/>        loss.backward()<br/>        with torch.no_grad():<br/>            for param in model.parameters():<br/>                variation = learning_rate * param.grad<br/>                param -= variation</span></pre><p id="df4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">并用一个<strong class="ig hi">表面</strong> matplotlib图形显示结果。我们将从创建一个由0和1之间的点组成的<strong class="ig hi"> 2D网格</strong>开始:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="247d" class="li kb hh le b fi lj lk l ll lm">xdata = np.linspace(0,1,10)<br/>ydata = np.linspace(0,1,10)<br/>X,Y = np.meshgrid(xdata, ydata)</span></pre><p id="2581" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">创建一个<em class="me">矢量化</em>函数，将模型应用于输入(x，y)并生成表面图:</p><pre class="jd je jf jg fd ld le lf lg aw lh bi"><span id="fcc1" class="li kb hh le b fi lj lk l ll lm">@np.vectorize<br/>def predict(x,y):<br/>    predicted = model(torch.tensor([x, y], dtype=torch.float32)).item()<br/>    return predicted<br/><br/><br/>Z = predict(X, Y)<br/>ax = plt.axes(projection='3d')<br/>ax.plot_surface(X, Y, Z, cmap='plasma')</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mf"><img src="../Images/f762315ef6c698c49246132607b7584d.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*oHGUj_sGVrSKwCqvIGi-rA.png"/></div></figure><p id="8b98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是你的！我们的小代码生成了一个模型，它可以回答1到input (0，0)和input (1，1)和0到other。你可以在图上看到，这里生成的函数相当于<strong class="ig hi">等于</strong>。</p><p id="8b7f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是第二次训练可以给出非常不同的东西，并且仍然是正确的:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es mf"><img src="../Images/339b914b2af0b81f25f64888e30fc673.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*BKoJFMx5mfX2krDeHRqUKA.png"/></div></figure></div><div class="ab cl jt ju go jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="ha hb hc hd he"><h1 id="a472" class="ka kb hh bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">是否矫枉过正？</h1><p id="621a" class="pw-post-body-paragraph ie if hh ig b ih ky ij ik il kz in io ip la ir is it lb iv iw ix lc iz ja jb ha bi translated">当然可以！但是这里我们<strong class="ig hi">知道了</strong>我们想要生成的布尔运算。想象一个用<strong class="ig hi">被遗忘的</strong>语言编写的40行算法，有10个布尔输入参数，你还想为了理解它而阅读所有代码吗？</p><p id="062a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种类型的<strong class="ig hi">算法生成</strong>可以为目前新兴的<strong class="ig hi">零代码</strong>工具提供新的工具。</p></div></div>    
</body>
</html>