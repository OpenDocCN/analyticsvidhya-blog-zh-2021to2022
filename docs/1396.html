<html>
<head>
<title>Python Telegram Bot with Scheduled Tasks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有预定任务的Python电报机器人</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-telegram-bot-with-scheduled-tasks-932edd61c534?source=collection_archive---------0-----------------------#2021-02-28">https://medium.com/analytics-vidhya/python-telegram-bot-with-scheduled-tasks-932edd61c534?source=collection_archive---------0-----------------------#2021-02-28</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/9a2af5804bfe50d46293fbbf69023d3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*B1XxqXxkoQk5kCP2"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">图片来源:<a class="ae iu" href="https://github.com/python-telegram-bot/python-telegram-bot" rel="noopener ugc nofollow" target="_blank">此处</a></figcaption></figure><p id="d5cd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你好。在本教程中，我们将学习如何用python创建一个简单的echo bot，其中包含一些预定的任务。我们开始吧！</p><h1 id="15db" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">依赖性和第一步:</h1><p id="7e0f" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">以下是本教程中您应该拥有的所有依赖项的列表:</p><ol class=""><li id="3c1a" class="kw kx hi ix b iy iz jc jd jg ky jk kz jo la js lb lc ld le bi translated">计算机编程语言</li><li id="07e3" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">电报帐户</li><li id="992b" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">python-telegram-bot模块</li></ol><p id="f293" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">可能，您已经有了前两个依赖项，所以让我们从模块的安装开始。打开终端并键入以下命令:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="72fc" class="lt ju hi lp b fi lu lv l lw lx">pip install python-telegram-bot</span></pre><p id="2ac9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后我们必须创建我们的机器人，并从Telegram获取令牌。打开电报，搜索“僵尸父亲”(“@僵尸父亲”)。选择经过验证的。键入start来查看所有可能的命令，机器人应该像这样响应您:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es ly"><img src="../Images/c4ff4c01467aceeda1c489d2a36d8d0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/1*LhR0R4I9Z5yfJXQfwP17Ag.png"/></div></figure><p id="0177" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">键入<strong class="ix hj"> <em class="lz"> /newbot </em> </strong>创建一个新的bot。这将是BotFather接下来的回应。为您的机器人选择名称和唯一的用户名:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es ma"><img src="../Images/0ae154babe2491d775d79c37dc198c49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*BMjJ5yvbf27ruF7nabTzNg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">在这个案例中，我选择了<strong class="bd jv">机器人和</strong>机器人作为用户名</figcaption></figure><p id="2ddb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果一切正常，BotFather将向您发送如下图所示的带有令牌和凭据的响应。不要与任何人分享你的令牌，它就像Django中的<strong class="ix hj"> <em class="lz">密钥</em> </strong>。教程结束后，我将删除该机器人，因此我将向您展示我的凭据:</p><figure class="lk ll lm ln fd ij er es paragraph-image"><div class="er es mb"><img src="../Images/747c61eae6d6c66a0bd78d0fd7553149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*QJgJnk_hYuVKz0Ugsb1HJg.png"/></div></figure><p id="97c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们创建了我们的机器人，我们可以通过链接或在电报中搜索来找到它。现在，您可以向您的机器人添加个人资料图片、描述等。你可以随意做，但现在我们专注于编写我们的机器人。我们继续。</p><h1 id="2890" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">发展</h1><p id="76da" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">打开任意编辑器，让我们开始吧！</p><p id="6655" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们要从<strong class="ix hj"><em class="lz">python-telegram-bot</em></strong>导入一些模块:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="72a8" class="lt ju hi lp b fi lu lv l lw lx"><em class="lz">from</em> telegram.ext <em class="lz">import</em> Updater, CommandHandler<br/><em class="lz">import</em> logging</span></pre><p id="67a1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lz">更新者</em> </strong>将获得我们的机器人发生的所有更新(消息等等)。我们使用<strong class="ix hj"> <em class="lz">日志</em> </strong>来显示错误，使用<strong class="ix hj"> <em class="lz">命令处理程序</em> </strong>来处理我们将要创建的所有命令。让我们创建我们的<strong class="ix hj"> <em class="lz">更新器</em> </strong>:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3e95" class="lt ju hi lp b fi lu lv l lw lx">updater = Updater(token='1605329753:AAGy9Hukl7Nc8CzUJ0tcfndxR_tctvKDCRI', use_context=True)</span><span id="7a2b" class="lt ju hi lp b fi mc lv l lw lx">dispatcher = updater.dispatcher</span><span id="1b71" class="lt ju hi lp b fi mc lv l lw lx">logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)</span></pre><p id="3b42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们为机器人编写第一个命令。显然，它会/ <strong class="ix hj"> <em class="lz">启动</em> </strong>命令。</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="85df" class="lt ju hi lp b fi lu lv l lw lx"># writting functionality of the command<br/>def start(update, context):<br/>    message = 'Welcome to the bot'<br/>    context.bot.send_message(chat_id=update.effective_chat.id, text=message)</span><span id="9ab7" class="lt ju hi lp b fi mc lv l lw lx"># give a name to the command and add it to the dispaatcher<br/>start_handler = CommandHandler('start', start)<br/>dispatcher.add_handler(start_handler)</span><span id="27a6" class="lt ju hi lp b fi mc lv l lw lx">updater.start_polling() // enable bot to get updates</span></pre><p id="277d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在运行脚本并检查电报中的命令。</p><p id="afad" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如你所见，我们使用<strong class="ix hj"><em class="lz">update . effective _ chat . id</em></strong>向特定用户发送消息。但是如果我们想给所有用户发送一条消息呢？不幸的是，这个API没有提供类似的功能，所以我们将所有用户存储在我们的数据库中。您可以使用任何数据库，我将使用远程Redis数据库。你也可以从<a class="ae iu" href="https://heroku.com" rel="noopener ugc nofollow" target="_blank"> Heroku </a>获得免费的Redis数据库。</p><p id="be67" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我假设您获得了Redis数据库的URL。要使用它，我们必须在我们的机器上安装Redis:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5c0e" class="lt ju hi lp b fi lu lv l lw lx">pip install redis</span></pre><p id="e641" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将如何储存它？最有效的方法是，当用户键入/ <strong class="ix hj"> <em class="lz">开始</em> </strong>命令时，存储用户的用户名和id。首先，将这些行添加到脚本中:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="5974" class="lt ju hi lp b fi lu lv l lw lx"><em class="lz">from</em> telegram.ext <em class="lz">import</em> Updater, CommandHandler<br/><em class="lz">import</em> logging<br/>import redis</span><span id="f635" class="lt ju hi lp b fi mc lv l lw lx">r = redis.from_url('your_redis_db_url') # connection to the databse<br/>db_keys = r.keys(pattern='*')   # allows us to fetch data</span></pre><p id="9a8f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然后将<strong class="ix hj">的<em class="lz">开始</em>的</strong>函数重写为这样:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="e3f5" class="lt ju hi lp b fi lu lv l lw lx">def start(update, context):<br/>    user_id = update.message.from_user.id<br/>    user_name = update.message.from_user.name<br/>    r.set(user_name, user_id)</span><span id="e717" class="lt ju hi lp b fi mc lv l lw lx">message = 'Welcome to the bot'<br/>    context.bot.send_message(chat_id=update.effective_chat.id, text=message)</span></pre><p id="887e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以随时查看订户名单。创建新脚本<strong class="ix hj"> <em class="lz"> users.py: </em> </strong></p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="3a89" class="lt ju hi lp b fi lu lv l lw lx"><em class="lz">import</em> redis<br/>r = redis.from_url('your_redis_db_url')<br/>db_keys = r.keys(pattern="*")<br/>print((len(db_keys)))</span><span id="8d4b" class="lt ju hi lp b fi mc lv l lw lx"><em class="lz">for</em> single <em class="lz">in</em> db_keys:</span><span id="7304" class="lt ju hi lp b fi mc lv l lw lx">    chat_id = r.get(single).decode("UTF-8")<br/>    print(single.decode("UTF-8"), ": ", chat_id)</span></pre><p id="52da" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在让我们编写一个<strong class="ix hj"> <em class="lz"> echo </em> </strong>函数，允许机器人向用户发送他/她发送给机器人的相同消息。导入过滤器和MessageHandler以处理来自<strong class="ix hj"> <em class="lz"> telegram.ext </em> </strong>的消息，并编写如下函数:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="831f" class="lt ju hi lp b fi lu lv l lw lx">def echo(update, context):<br/>    context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text)</span><span id="f03d" class="lt ju hi lp b fi mc lv l lw lx">from telegram.ext import MessageHandler, Filters<br/>echo_handler = MessageHandler(Filters.text &amp; (~Filters.command), echo)<br/>dispatcher.add_handler(echo_handler)</span></pre><blockquote class="md me mf"><p id="2bb1" class="iv iw lz ix b iy iz ja jb jc jd je jf mg jh ji jj mh jl jm jn mi jp jq jr js hb bi translated">注意:这不是一个命令，您不能通过键入/ <strong class="ix hj"> <em class="hi"> echo </em> </strong>来访问它。这是一个自动处理程序，它会在用户的文本消息后回复用户(借助于<strong class="ix hj"> <em class="hi">过滤器。text </em> </strong></p></blockquote><h1 id="f342" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">计划的作业/任务:</h1><p id="fc0a" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">为了使用调度任务，我们使用<strong class="ix hj"> <em class="lz"> job_queue </em> </strong>。它有<strong class="ix hj"> <em class="lz"> run_once </em> </strong>，<strong class="ix hj"> <em class="lz"> run_daily </em> </strong>等几种方法。在这种情况下，我们将使用这两种方法。</p><p id="f773" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们要在 <strong class="ix hj"> <em class="lz">更新器中添加<strong class="ix hj"><em class="lz">job _ queue</em></strong><em class="lz">。</em> </em></strong> <em class="lz">我们在这里也会用到</em><strong class="ix hj"><em class="lz">callback context</em></strong><em class="lz">，所以从</em><strong class="ix hj"><em class="lz">telegram . ext</em></strong>中导入它</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="9e20" class="lt ju hi lp b fi lu lv l lw lx">j = updater.job_queue</span></pre><p id="ea00" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">从方法的名字来看，<strong class="ix hj"> <em class="lz"> run_once </em> </strong>只运行命令一次。我们决定的时间和命令将由<strong class="ix hj"> <em class="lz"> run_once </em> </strong>自动运行。</p><p id="2616" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们编写只执行一次的函数:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="01a6" class="lt ju hi lp b fi lu lv l lw lx">def once(context: CallbackContext):</span><span id="d5ea" class="lt ju hi lp b fi mc lv l lw lx">    message = "Hello, this message will be sent only once"<br/>    <br/>    # send message to all users<br/>    <em class="lz">for</em> keys <em class="lz">in</em> db_keys:<br/>        id = r.get(keys).decode("UTF-8")<br/>        context.bot.send_message(chat_id=id, text=message)</span></pre><p id="79ac" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在将该函数添加到<strong class="ix hj"> <em class="lz"> run_once </em> </strong>并给出时间:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="4626" class="lt ju hi lp b fi lu lv l lw lx"><em class="lz">j.run_once(once, 30)</em></span></pre><p id="56a0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lz"> run_once </em> </strong>带两个属性，我们要执行的函数和时间。30表示该功能将在部署30秒后执行</p><p id="67f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们转到<strong class="ix hj"> run_daily。</strong>把早晨的函数写成这样:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="11da" class="lt ju hi lp b fi lu lv l lw lx">def morning(context: CallbackContext):</span><span id="1be4" class="lt ju hi lp b fi mc lv l lw lx">    message = "Good Morning! Have a nice day!"<br/>    <br/>    # send message to all users<br/>    <em class="lz">for</em> keys <em class="lz">in</em> db_keys:<br/>        id = r.get(keys).decode("UTF-8")<br/>        context.bot.send_message(chat_id=id, text=message)</span></pre><p id="73b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在将该功能添加到<strong class="ix hj"> <em class="lz"> run_daily </em> </strong>并进行配置:</p><pre class="lk ll lm ln fd lo lp lq lr aw ls bi"><span id="a4e0" class="lt ju hi lp b fi lu lv l lw lx">job_daily = j.run_daily(daily_suggestion, days=(0, 1, 2, 3, 4, 5, 6), time=datetime.time(hour=10, minute=00, second=00))</span></pre><p id="6f47" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj"> <em class="lz"> run_daily </em> </strong>带几个属性:我们要执行的函数、天数(应该是元组)、时间(导入<strong class="ix hj"> <em class="lz"> datetime </em> </strong>)。该功能将在每天10:00执行，用户将收到一条“早安”消息。</p><h1 id="c4d1" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">最后:</h1><ol class=""><li id="b418" class="kw kx hi ix b iy kr jc ks jg mj jk mk jo ml js lb lc ld le bi translated">你可以从python-telegram-bot的官方博客上获得更多关于所有可能的命令和方法的详细信息。点击<a class="ae iu" href="https://python-telegram-bot.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank">这里</a></li><li id="124f" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">你可以加入他们的电报群，找到你问题的答案。点击<a class="ae iu" href="https://web.telegram.org/#/im?p=@pythontelegrambotgroup" rel="noopener ugc nofollow" target="_blank">这里</a></li><li id="2a1c" class="kw kx hi ix b iy lf jc lg jg lh jk li jo lj js lb lc ld le bi translated">如果你想部署这个脚本(比如在Heroku上)，你可以在<a class="ae iu" href="https://thesaintraphael.medium.com/hosting-python-script-on-heroku-b5eb4dc28606" rel="noopener">这里</a>阅读我的文章。</li></ol><blockquote class="md me mf"><p id="0327" class="iv iw lz ix b iy iz ja jb jc jd je jf mg jh ji jj mh jl jm jn mi jp jq jr js hb bi translated">如果你有问题，请写在下面。感谢阅读！</p></blockquote></div></div>    
</body>
</html>