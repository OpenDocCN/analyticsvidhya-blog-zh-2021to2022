<html>
<head>
<title>DB Size increase in Postgres: Autovacuum</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Postgres中的数据库大小增加:自动清空</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/database-size-increase-in-postgres-9a91134db56?source=collection_archive---------2-----------------------#2021-09-06">https://medium.com/analytics-vidhya/database-size-increase-in-postgres-9a91134db56?source=collection_archive---------2-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ea1e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://www.postgresql.org/about/" rel="noopener ugc nofollow" target="_blank"> PostgreSQL </a>，也称为Postgres，是一个强调可扩展性和SQL合规性的免费开源关系数据库管理系统。它是最受欢迎的开源数据库之一，因其性能和可靠性而被广泛使用，是Oracle MySQL服务的替代产品。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div class="er es je"><img src="../Images/cbcb2bb103189dbb6c23f84465f9049d.png" data-original-src="https://miro.medium.com/v2/resize:fit:240/format:webp/0*NeNPXmt073x1hsJY.png"/></div></figure><p id="de53" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了提高性能，它使用了某些机制，这些机制最终可能会给一些极端用户带来问题。一个这样的例子是增加数据库的大小。</p><h1 id="70c7" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">数据库大小增加</h1><p id="dd9a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">让我们试着想象一个案例。在过去的6个月中，您的应用程序在一个数据库大小为100 GB的Postgres服务器上运行良好。突然，您被警告数据库的大小在一夜之间翻了一番…而且还在增加。</p><p id="d431" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在检查数据库时，表的大小没有增加。行数也没有增加。就好像有什么东西在你不知情的情况下拿走了你的数据库。您的磁盘大小有限，在超出磁盘大小之前，您只有几个小时的时间来解决这个问题。</p><p id="99a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，您已经理解了问题陈述及其重要性。因此，最好在为时已晚之前解决这个问题。</p><p id="a394" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Postgres服务器上占用你空间的恶意特性叫做TOAST。相反，它是一个好心人，试图提高您的数据库的性能，但如果您的数据库过于频繁地删除/更新toast条目，可能会带来麻烦。</p><h1 id="bf3e" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">烤</h1><p id="05a6" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated"><a class="ae jd" href="https://www.postgresql.org/docs/current/static/storage-toast.html" rel="noopener ugc nofollow" target="_blank"> TOAST </a>是PostgreSQL用来防止物理数据行超过数据块大小(通常为8KB)的一种机制。Postgres不支持跨越块边界的物理行，因此块大小是行大小的硬性上限。为了允许用户表具有比这更宽的行，TOAST机制将宽字段值分解成更小的片段，这些片段存储在与用户表相关联的TOAST表中。</p><p id="9119" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您创建的每个表都有自己的关联(唯一的)TOAST表，根据您插入的行的大小，这些表最终可能会被使用，也可能不会被使用。所有这些对用户来说都是透明的，默认情况下是启用的。</p><p id="49dd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当要存储的行“太宽”时(默认情况下阈值为2KB)，TOAST机制首先尝试压缩任何宽字段值。如果这还不足以获得2KB以下的行，它会将宽字段值分成块，存储在相关的TOAST表中。每个原始字段值都被一个小指针代替，该指针显示在TOAST表中何处可以找到这些“不符合规定”的数据。TOAST将尝试以这种方式将用户表行压缩到2KB，但是只要它能低于8KB，就足够好了，并且该行可以被成功存储。</p><h1 id="8520" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">是什么让您的数据库遭受损失</h1><p id="982b" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">数据库发出过多的更新或删除请求是问题的根本原因。如果您在大尺寸的行上进行这些操作，它就像催化剂一样使事情变得更糟。</p><p id="071c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在PostgreSQL中，每当删除表中的行时，现有的行或元组被标记为死的(不会被物理删除)，并且在更新期间，它将相应的现有元组标记为死的，并插入新的元组。所以更新操作=删除+插入。这些死元组消耗了不必要的存储，最终导致PostgreSQL数据库膨胀。这种存储可以通过<a class="ae jd" href="https://www.postgresql.org/docs/current/sql-vacuum.html" rel="noopener ugc nofollow" target="_blank">真空</a>回收。</p><p id="2b94" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">VACUUM回收的存储空间永远不会归还给驻留的操作系统，而是在同一个数据库页面中进行碎片整理，以便将来数据插入到同一个表中时重新使用。要完全回收底层操作系统的空间，需要执行真空满操作，这比较慢，并且需要对表进行独占锁定，不允许任何其他读/写操作。</p><p id="7dec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">膨胀严重影响了PostgreSQL的查询性能，在PostgreSQL中，表和索引是作为一个固定大小的页面数组存储的(通常大小为8KB)。每当查询请求行时，PostgreSQL实例将这些页面加载到内存中，死行会在数据加载期间导致昂贵的磁盘I/O。所以非常需要定期运行真空。</p><p id="2d69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，<a class="ae jd" href="https://www.postgresql.org/docs/13/runtime-config-autovacuum.html" rel="noopener ugc nofollow" target="_blank"> AUTOVACUUM </a>守护进程是一个可选特性，它自动清空数据库，这样您就不必手动运行<a class="ae jd" href="https://www.postgresql.org/docs/11/sql-vacuum.html" rel="noopener ugc nofollow" target="_blank"> VACUUM语句</a>。默认配置中启用了自动真空后台程序。守护程序由多个进程组成，这些进程通过从数据库中删除过时的数据或元组来回收存储。它检查具有大量插入、更新或删除记录的表，并根据配置设置清空这些表。</p><h1 id="f774" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">自动吸尘的任务</h1><p id="cf32" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">有各种自动真空配置参数，这使得调整变得复杂。主要原因是autovacuum有许多不同的任务。</p><ul class=""><li id="0fb4" class="kp kq hi ih b ii ij im in iq kr iu ks iy kt jc ku kv kw kx bi translated">清除更新或删除操作后留下的“死元组”</li><li id="ce2a" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">更新跟踪表块中空闲空间的<em class="ld">空闲空间映射</em></li><li id="9933" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">更新<em class="ld">仅索引扫描</em>所需的<em class="ld">可见性图</em></li><li id="fc49" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">“冻结”表行，以便事务ID计数器可以安全地回绕</li><li id="fd48" class="kp kq hi ih b ii ky im kz iq la iu lb iy lc jc ku kv kw kx bi translated">安排定期分析运行，以保持表统计信息的更新</li></ul><p id="da00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些是自动真空的所有配置参数</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="c7a5" class="lj jn hi lf b fi lk ll l lm ln">#------------------------------------------------------------------------------<br/># AUTOVACUUM PARAMETERS<br/>#------------------------------------------------------------------------------</span><span id="8fde" class="lj jn hi lf b fi lo ll l lm ln">autovacuum = on                        # Enable autovacuum subprocess?  'on' requires track_counts to also be on.</span><span id="3ae2" class="lj jn hi lf b fi lo ll l lm ln">log_autovacuum_min_duration = -1       # -1 disables, 0 logs all actions and their durations, &gt; 0 logs only actions running at least this number of milliseconds.</span><span id="e951" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_max_workers = 3             # max number of autovacuum subprocesses (change requires restart)</span><span id="f787" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_naptime = 1min              # time between autovacuum runs</span><span id="da3e" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_vacuum_threshold = 50       # min number of row updates before vacuum</span><span id="5848" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_analyze_threshold = 50      # min number of row updates before analyze</span><span id="d4e8" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_vacuum_scale_factor = 0.2   # fraction of table size before vacuum</span><span id="b4ff" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_analyze_scale_factor = 0.1  # fraction of table size before analyze</span><span id="a3c8" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_freeze_max_age = 200000000  # maximum XID age before forced vacuum(change requires restart)</span><span id="411c" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_multixact_freeze_max_age = 400000000   # maximum multixact age before forced vacuum(change requires restart)</span><span id="76ae" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_vacuum_cost_delay = 20ms    # default vacuum cost delay for autovacuum, in milliseconds -1 means use vacuum_cost_delay</span><span id="8389" class="lj jn hi lf b fi lo ll l lm ln">autovacuum_vacuum_cost_limit = -1      # default vacuum cost limit for autovacuum, -1 means use vacuum_cost_limit</span></pre><p id="1abd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这些参数可以根据数据库级别或表级别的数据库个人需求进行调整。对于死元组清除，我们不需要重新配置所有的自动真空参数。</p><h1 id="9185" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">为死元组清理调整自动真空</h1><p id="d98a" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">长时间运行或空闲的事务会导致VACUUM等待持有表上的共享更新独占锁。除非此类查询得到解决，否则调整AUTOVACUUM将毫无用处。</p><p id="edf4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您无法从根本上解决问题，您可以使用配置参数<strong class="ih hj">idle _ in _ transaction _ session _ time out</strong>让PostgreSQL终止“在事务中空闲”时间过长的会话。这在客户端会导致错误，但是如果您没有其他方法来保持数据库运行，这可能是合理的。类似地，为了对抗长时间运行的查询，可以使用<strong class="ih hj">语句_超时</strong>。</p><h1 id="bb6f" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">调整自动真空运行速度</h1><p id="07e2" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">如果autovacuum跟不上清理死元组的速度，解决方案就是让它工作得更快<em class="ld"/>。</p><p id="fbf9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住，更快并不意味着更频繁地运行vacuum或更频繁地运行它。VACUUM是一项资源密集型操作，因此默认情况下，autovacuum会故意缓慢运行。目标是让它在后台工作，而不影响正常的数据库操作。但是，如果您的应用程序创建了大量的死元组，您必须使它更积极。</p><p id="6134" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">auto vacuum _ vacuum _ threshold</strong>=真空启动的最小死元组数(默认值= 50)</p><p id="f851" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">auto vacuum _ vacuum _ scale _ factor</strong>=定义表w.r.t与其行数的最小死元组数的比例因子(默认值= 0.2)</p><p id="a848" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这两个参数有助于在关系表上控制真空的触发。由于真空是一个消耗资源的过程，因此只应在必要时运行。利用这些参数，计算表级最小死元组计数，其充当真空触发的阈值。</p><p id="3240" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">autovacuum_vacuum_threshold确保vacuum不会对小表过于频繁地运行。</p><p id="81a8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">autovacuum_vacuum_scale_factor确保为大型桌子及时运行真空。</p><pre class="jf jg jh ji fd le lf lg lh aw li bi"><span id="2219" class="lj jn hi lf b fi lk ll l lm ln">Min Number of of dead tuples required = autovacuum_vacuum_threshold  +  No. of Rows in table * autovacuum_vacuum_scale_factor</span></pre><p id="26d8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">autovacuum _ vacuum _ cost _ limit</strong>:auto vacuum可以达到的总成本限制(由所有auto vacuum作业合并)。(默认为真空成本限制= 200)</p><p id="d847" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">autovacuum _ vacuum _ cost _ delay</strong>:当达到autovacuum_vacuum_cost_limit成本的清理完成时，auto vacuum将休眠这么多毫秒。(默认值= 20毫秒)</p><p id="8739" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">auto vacuum _ max _ workers:</strong>auto vacuum为执行任务而产生的最大工作线程数。</p><p id="ea10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这三个参数负责定义真空的清除速度和时间。Autovacuum守护进程休眠<strong class="ih hj">auto vacuum _ vacuum _ cost _ delay</strong>作为一次完成的每一个<strong class="ih hj">auto vacuum _ vacuum _ cost _ limit</strong>工作的节流。</p><p id="c6d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">autovacuum可以启动多达<strong class="ih hj">个autovacuum_max_workers </strong>进程，这些进程实际执行不同数据库/表的清理。这很有用，因为在单个大表清理完成之前，您不想停止清理小表(由于节流，这可能需要相当长的时间)。请记住，增加工作进程会使自动清空变慢，因为所有自动清空工作进程会共享成本值。每个工人进程只得到总成本限制的<strong class="ih hj"> 1/autovacuum_max_workers </strong>，所以增加工人数量只会让他们走得更慢。</p><p id="5015" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">默认值设置是非常基本的，因为autovaccum在默认情况下是启用的，所以要记住低资源系统。</p><h1 id="14bd" class="jm jn hi bd jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj bi translated">最后一个音符</h1><p id="5bdf" class="pw-post-body-paragraph if ig hi ih b ii kk ik il im kl io ip iq km is it iu kn iw ix iy ko ja jb jc hb bi translated">对于不同的系统要求，真空配置可以不同。最好首先了解您的应用程序数据库需求，它会发出多少数据库请求，然后做出相应的决定。</p><p id="9817" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">还有，不要直接得出真空不足就是原因的结论。根本原因可能是其他原因导致vacuum等待，比如另一个数据库查询持有所需表/行的锁。所以最好先排除这种情况。</p></div></div>    
</body>
</html>