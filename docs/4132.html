<html>
<head>
<title>Oh, the Things You Can Do with Clustering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哦，你可以用集群做的事情</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/oh-the-things-you-can-do-with-clustering-5dd2eed9460b?source=collection_archive---------6-----------------------#2021-08-30">https://medium.com/analytics-vidhya/oh-the-things-you-can-do-with-clustering-5dd2eed9460b?source=collection_archive---------6-----------------------#2021-08-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="cf12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你能用集群做些什么？很多。首先，分类、检测重复和寻找相似之处只是几个例子。</p><h1 id="06eb" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">目录</h1><p id="42ab" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">K表示聚类是如何工作的？ <br/> <a class="ae kf" href="#743c" rel="noopener ugc nofollow">样本图像</a> <br/> <a class="ae kf" href="#eb5c" rel="noopener ugc nofollow">像素作为特征</a> <br/> <a class="ae kf" href="#bd5f" rel="noopener ugc nofollow">特征图</a> <br/> <a class="ae kf" href="#e0be" rel="noopener ugc nofollow">距离函数</a> <br/> ∘ <a class="ae kf" href="#4609" rel="noopener ugc nofollow">欧氏距离</a> <br/> ∘ <a class="ae kf" href="#2791" rel="noopener ugc nofollow">余弦距离</a> <br/> <a class="ae kf" href="#8def" rel="noopener ugc nofollow">相似性</a> <br/> <a class="ae kf" href="#2e04" rel="noopener ugc nofollow">结论</a> <br/> <a class="ae kf" href="#f7b5" rel="noopener ugc nofollow">参考文献</a></p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es kg"><img src="../Images/458f96125c4fd45c0db7cf5861666c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qKFjMANS73tcr8_7"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">照片由<a class="ae kf" href="https://unsplash.com/@terras?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Terra Slaybaugh </a>在<a class="ae kf" href="https://unsplash.com/s/photos/cluster?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="786f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚类是一种无监督学习算法，广泛用于机器学习。简而言之，它以这样一种方式对数据进行分组，即同一集群中的对象共享相似的功能。然而，聚类是预处理数据时可以使用的最有用的技术之一。在本文中，我将使用非结构化图像数据作为例子，但是同样的技术也适用于结构化数据。整个源代码共享在<a class="ae kf" href="https://github.com/changsin/ClassifyImages/blob/main/notebooks/cluster_images.ipynb" rel="noopener ugc nofollow" target="_blank"> Colab笔记本</a>中。</p><h1 id="d21b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">K均值聚类是如何工作的？</h1><p id="3c99" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">K-Means聚类是一种迭代算法，它根据已定义特征的相对距离对相似项目进行分组。算法是:</p><ol class=""><li id="af02" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated">选取两个随机点作为初始质心(质心是簇的中心点)。</li><li id="d4e4" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">根据每个数据点到质心的距离将每个数据点放到一个聚类中。换句话说，数据点将被放入质心更近的聚类中。</li><li id="af2c" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">聚类后，计算每个聚类的真实质心。</li><li id="c075" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">使用新的质心对数据进行重新聚类。</li><li id="6c55" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated">检查簇或质心是否有任何变化。如果没有变化，我们就完了。否则，重复3–5。</li></ol><p id="5c20" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我的另一篇文章更详细地介绍了上述算法。要实现该算法，您必须定义两件事:即特征和相似性度量:</p><ol class=""><li id="78e1" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated"><strong class="ig hi">特性:</strong>根据数据类型和用途决定特性。不管数据类型和特性如何，它们都需要用向量来表示。</li><li id="bf48" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><strong class="ig hi">距离函数:</strong>一旦确定了特征并转换成向量形式，你就要决定你要用哪个距离函数来度量两个特征向量之间的距离。流行的距离函数有欧几里德、余弦、曼哈顿和汉明。</li></ol><p id="e4ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，数据类型是图像，所以我们可以在图像中使用像素值或结构。对于距离函数，我们将尝试欧几里德和余弦函数来计算相似性。</p><h1 id="743c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">样本图像</h1><p id="5925" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">有了聚类算法，让我们将它应用于视觉任务领域。我准备了三个样本数据集:高速公路的昼夜图像、来自高速公路监控摄像头的图像和车辆图像。</p><ul class=""><li id="0cf8" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lk lc ld le bi translated"><strong class="ig hi">高速公路的白天和夜晚图像:</strong>期望这些图像应该形成两个自然集群:白天和夜晚图像。这应该是最简单的，除了像黎明和黄昏图像、隧道、阴天等边界情况。</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ll"><img src="../Images/a81f34e74cb204840e9c09a22ae5e4c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yFpR-N6lPNQvnWDo48-wcg.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">高速公路的日夜图像</figcaption></figure><ul class=""><li id="ba2f" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lk lc ld le bi translated"><strong class="ig hi">高速公路监控摄像头图像:</strong>这些图像都是在白天拍摄的，但采用了两种不同的变焦设置:缩小和放大。前两个图像被缩小，其余的是放大的图像。</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lm"><img src="../Images/86a00e605c8ca92445797aea49c7d323.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IYt1yJbMVWIkqxUjxmt9WQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">高速公路监控摄像头图像</figcaption></figure><ul class=""><li id="4fbc" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lk lc ld le bi translated"><strong class="ig hi">车辆图片:</strong>4辆大众微型车和4辆大众甲壳虫的图片。尽管这两个图像集对于人类观察者来说形成了两个自然的聚类，但是将它们聚类成两个组将是非常具有挑战性的，因为背景、位置、车辆的位置等。都是复杂多样的。</li></ul><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es ln"><img src="../Images/8ef7a27fba4561d899f90be6853b6b87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UmmgEUohD62G7_EKNhGVSQ.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">大众微型车图片</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es lo"><img src="../Images/cfe4c6596c6f910c009400526b3e2e41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uhFK5hh1b2_3x1LTG2vNgw.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">大众甲壳虫图片</figcaption></figure><h1 id="eb5c" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">像素作为特征</h1><p id="673e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">聚类图像最简单的方法是使用像素值作为特征。对于彩色图像，每个像素包含RGB或RGBA值。因此，如果使用320x320分辨率的三个通道(RGB ),则图像将被转换为320x320x3多维数组。使用OpenCV，将图像文件加载到数组形式只需要一行代码:</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="a882" class="lu jd hh lq b fi lv lw l lx ly">import cv2</span><span id="f3ad" class="lu jd hh lq b fi lz lw l lx ly">image = cv2.imread(file_path)</span></pre><p id="ccd7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦加载了图像列表，我们就可以使用sklearn库的KMeans聚类算法来获得聚类。K的值应该是多少这个问题需要另一种讨论。在我们的例子中，我们知道应该有两个集群，所以让我们设置K=2并运行算法。</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="cf7b" class="lu jd hh lq b fi lv lw l lx ly">from sklearn.cluster import KMeans</span><span id="22e5" class="lu jd hh lq b fi lz lw l lx ly">K = 2</span><span id="355a" class="lu jd hh lq b fi lz lw l lx ly">images_flattend = images.reshape(images.shape[0], -1)</span><span id="d168" class="lu jd hh lq b fi lz lw l lx ly">kmeans = KMeans(n_clusters=K, random_state=0)<br/>clusters = kmeans.fit(images_flattend)</span></pre><p id="5f21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">KMeans fit方法期望输入是2D数组，因此图像数组需要“展平”例如，加载十个图像将产生一个(10，320，320，3)多维数组，该数组在展平后变成(10，307200)。在展平数组并初始化KMeans之后，可以调用fit()和predict()或fit_predict()来获得预测(即聚类)。结果是一个索引列表。对于K=2，索引指的是图像数据所属的簇0或1。</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="1cfc" class="lu jd hh lq b fi lv lw l lx ly">array([0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], dtype=int32)</span></pre><p id="2fb5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了可视化聚类，我们需要将维度降低到2D，这可以通过PCA(主成分分析)来实现。事实上，由于它降低了维数，我们也可以使用主成分分析的结果来进行聚类。组合后的代码如下所示:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="7cee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PCA.fit_transform将维数减少到K。在我们的例子中，因为K=2，所以我们有一个2D阵列，我们可以在潜在空间中将它与K均值聚类边界一起绘制成图形。两个白色标记是簇的质心(中心点)。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mc"><img src="../Images/70b5cc75c84022ff48dbe619beb26d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*yh9YJ05mrcnYc4MHosaZHA.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">白天和夜晚图像的集群</figcaption></figure><p id="8501" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于白天和夜晚的图像，聚类是:</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="cdc7" class="lu jd hh lq b fi lv lw l lx ly">{0: array([0, 1, 2, 3, 4]), 1: array([5, 6, 7, 8, 9])}</span></pre><p id="e74a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它们完美地对应了白天和夜间两组图像。</p><p id="e3dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于高速公路闭路电视图像，他们也符合我们的期望。</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="c3bd" class="lu jd hh lq b fi lv lw l lx ly">{0: array([2, 3, 4]), 1: array([0, 1])}</span></pre><p id="95da" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，对于车辆图像，我们就没那么幸运了。这些组是:</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="2aef" class="lu jd hh lq b fi lv lw l lx ly">{0: array([ 1,  2,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15]),<br/> 1: array([0, 3, 4])}</span></pre><p id="72ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然第二个聚类(索引1)包含所有的微型巴士图像，但是第一个聚类是5个微型巴士和8个甲壳虫图像的混合包。</p><p id="ff3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">聚类图还显示了在潜在空间中随机分布的数据点:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es md"><img src="../Images/231cd93124849995d26e22cc712c90a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/1*NrXichWRLvuC7NRDqMbzvg.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">汽车图像聚类图</figcaption></figure><p id="333a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们希望看到一些自然的集群。原因应该是显而易见的。在白天和夜晚的图像中，我们很幸运，因为单个像素值的大小充当了旋转标准。就汽车而言，它们都是在白天复杂的背景下拍摄的。虽然我们作为人类可以识别不同的汽车模型类型，但对于计算机来说，它们只是随机的像素值，因此没有自然的聚类组出现。</p><p id="c58e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要的是一种让机器识别图像中固有结构的方法。为此，我们求助于CNN(卷积神经网络)。</p><h1 id="bd5f" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">特征地图</h1><p id="7d4c" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">CNN被广泛用于分析图像。一幅图像通过一系列的卷积，这些卷积作为过滤器来提取“特征图”这些特征地图被用作模型中后续层的输入，以执行更高级别的认知任务，例如对象检测。这是VGG-16的图表，它是最早的CNN模型之一。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es me"><img src="../Images/1fc046e4c15341d0c89482411a73afd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*r7SD8TEtp5bTq7JW.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated"><a class="ae kf" href="https://neurohive.io/en/popular-networks/vgg16/" rel="noopener ugc nofollow" target="_blank">https://neurohive.io/en/popular-networks/vgg16/</a></figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mf"><img src="../Images/daef84043bdfb2825c2c91eebe28f86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gRMFdgMnrEpeQEXB.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">https://neurohive.io/en/popular-networks/vgg16/<a class="ae kf" href="https://neurohive.io/en/popular-networks/vgg16/" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="22c6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了最后三层，卷积层包括VGG-16层的大部分。来看看卷积的效果。让我们截取一个卷积输出，并将其可视化。下面是截取CNN输出的方法。您可以指定要从中提取CNN输出的层数。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="ma mb l"/></div></figure><p id="9ea8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一卷积层返回shape (224，224，64)的输出向量。我们可以将输出向量想象成一个由(224，224)个灰度图像组成的8×8网格，每个网格代表一个特定卷积的结果。让我们来看看第一个CNN图层输出中的几个。有些输出不太容易被人类识别，但这里有一些对人类来说似乎是有意义的。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="er es mg"><img src="../Images/ee48bf539ac767a5919515f581058e2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*08Fu8Mdy6PRm_xOpw1kB5Q.png"/></div></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">CNN中间输出</figcaption></figure><p id="385f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然我们不能总是理解卷积结果，但我们可以看到每个卷积运算都提取了输入图像的一个特定方面。这些卷积结果然后在最后三个完全连接的层之前一直被馈送到随后的卷积层。出于我们的目的，我们将把卷积层的最后输出作为聚类的特征图。以下是汽车图像的聚类结果:</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="a531" class="lu jd hh lq b fi lv lw l lx ly">0: array([ 0,  1,  2,  3,  4,  5,  6,  7, 11, 13]),<br/>1: array([ 8,  9, 10, 12, 14, 15])</span></pre><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mh"><img src="../Images/8023b0091db7539be4ca55c8cd0c817a.png" data-original-src="https://miro.medium.com/v2/resize:fit:860/format:webp/1*Ub3ggW2umfVcqxHOWML9Ig.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">使用特征地图的聚类结果(白色标记是质心)</figcaption></figure><p id="f553" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">虽然使用特征图的聚类结果仍然没有显示整齐的两组数据点，但它们显示了改进:聚类0具有全部8只微型巴士和2只甲虫，而聚类1只有6只甲虫。</p><p id="4522" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对车辆类型和型号进行分类实际上是一个相当具有挑战性的问题。它通常需要一个完整的神经网络模型来准确可靠地完成。单独的聚类不足以完成这项工作，这就是为什么它被用作训练成熟的神经网络模型的预处理步骤。</p><h1 id="e0be" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">距离函数</h1><p id="d807" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">让我们简单地转到距离函数这个话题。</p><h2 id="4609" class="lu jd hh bd je mi mj mk ji ml mm mn jm ip mo mp jq it mq mr ju ix ms mt jy mu bi translated">欧几里得距离</h2><p id="07b6" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">欧几里德距离函数的公式是:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mv"><img src="../Images/1b82ba1176c1bb0b47485d4ba652d230.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*TBGhVooPmgNn3_vHC6ykWw.png"/></div></figure><ul class=""><li id="733b" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lk lc ld le bi translated">p1和p2是向量空间中的两个数据点</li><li id="958c" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lk lc ld le bi translated">n是维度。</li></ul><p id="5b64" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是我们到目前为止使用的默认距离函数。</p><h2 id="2791" class="lu jd hh bd je mi mj mk ji ml mm mn jm ip mo mp jq it mq mr ju ix ms mt jy mu bi translated">余弦距离</h2><p id="7594" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">另一方面，余弦距离测量两个归一化向量之间的角度差。</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mw"><img src="../Images/099ee2a919895711e3d9436d17fa1de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*_JzD91AQCur4ofex7oRCmA.png"/></div></figure><p id="63d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑余弦距离的一个简单方法是，所有向量都归一化为长度为1的单位向量，唯一的区别是角度。因此，当矢量的大小无关紧要时，就使用余弦距离。为了规范化，我们可以使用sklearn的preprocessing.normalize()方法:</p><pre class="kh ki kj kk fd lp lq lr ls aw lt bi"><span id="6560" class="lu jd hh lq b fi lv lw l lx ly">from sklearn import preprocessing</span><span id="3f54" class="lu jd hh lq b fi lz lw l lx ly">X_fm = preprocessing.normalize(X_fm.reshape(len(X_fm), -1))</span></pre><p id="fe3a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在我们的例子中，距离函数之间没有太大的区别。在其他情况下，例如，文本相似性，一般的智慧是使用余弦距离。</p><h1 id="8def" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">类似</h1><p id="bb7e" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">距离函数用于基于相似性度量来寻找聚类。使用相同的距离函数，我们可以很容易地找到相似的图像或重复的图像。下面是潜在空间中最接近的两个数据点，以及根据欧几里德距离对应的汽车图像:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="ab fe cl mx"><img src="../Images/e2b5fa5b7268511f896a742954c689ad.png" data-original-src="https://miro.medium.com/v2/format:webp/1*rMUuPa9Dgl3gOYwHbh1Itg.png"/></div></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es my"><img src="../Images/b9e6dc34beb2aec8254dd248b8d73ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*gqxk_MOPhGVSdAEgNKN0fA.png"/></div></figure><p id="cd90" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">使用余弦距离，它们是:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mz"><img src="../Images/3d890a5503dbc4b1b01c8c89d06a7dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*kYk7v4Dz8I_yP2RTVmMzZA.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">使用余弦距离的两幅最相似的图像</figcaption></figure><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es na"><img src="../Images/8c8e9f48fa1412f14363c2fecd608272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*eI-yOrgztPHR6miY6oYDxA.png"/></div></figure><p id="b6b3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们观察到的是，这两张甲虫图像在大小上有很大不同，但是根据余弦距离函数，它们仍然被计算为最相似的。</p><p id="3454" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于两个最不相似的图像，欧几里德函数和余弦函数都认为这两个图像彼此最不相同:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es na"><img src="../Images/2d6f80bc98f7a8d79cbf8d6837fcc965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*CpFiF0kamQooLTydo3oJyw.png"/></div><figcaption class="ks kt et er es ku kv bd b be z dx translated">汽车图像数据集中最不相似的图像</figcaption></figure><h1 id="2e04" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">结论</h1><p id="60fe" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">作为数据科学家或机器学习工程师，聚类是非常有用的工具。在本文中，我们探索了一些可以用集群做的事情:即分类、检测重复项、查找相似项。然而，我们也看到，并不是所有的数据集都可以像白天和黑夜的图像一样整齐地聚集在一起。根据您的目的，您需要选择不同的特征，例如使用特征地图而不是像素值，或者使用余弦距离函数而不是欧氏距离函数。您可以探索更多的东西，但这应该是一个很好的起点。</p><h1 id="f7b5" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">参考</h1><ul class=""><li id="1c0b" class="kw kx hh ig b ih ka il kb ip nb it nc ix nd jb lk lc ld le bi translated"><a class="ae kf" href="https://changsin.medium.com/understanding-k-means-clustering-graphically-5b90beafc900" rel="noopener">理解K意味着图形化聚类</a></li></ul></div></div>    
</body>
</html>