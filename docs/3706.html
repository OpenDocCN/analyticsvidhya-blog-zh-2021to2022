<html>
<head>
<title>Fraud Detection : Credit Card</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欺诈检测:信用卡</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/fraud-detection-credit-card-ec529cb2aeff?source=collection_archive---------22-----------------------#2021-07-18">https://medium.com/analytics-vidhya/fraud-detection-credit-card-ec529cb2aeff?source=collection_archive---------22-----------------------#2021-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b9a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">新冠肺炎·疫情影响了很多事情。其中一个领域是网上交易，这是大规模增加。这自动使信用卡交易的使用发生了巨大的变化。信用卡交易中的欺诈活动并不是一个新问题，但不可否认的是，欺诈活动比以前增加了很多。</p><p id="5d4c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们从建模技术的角度来看，欺诈检测没有什么明显的挑战。其中一些列举如下:</p><ol class=""><li id="9beb" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">数据不平衡(有偏差的类数据)</li><li id="81ec" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">数据可用性</li><li id="e043" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">ML模型的可解释性</li></ol><p id="df35" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">还有其他挑战。在这篇博客中，我们将讨论用于检测欺诈案件的<strong class="ig hi">预测模型</strong>。数据集可以在<a class="ae jq" href="https://www.kaggle.com/mlg-ulb/creditcardfraud" rel="noopener ugc nofollow" target="_blank">这里</a>找到。在解决这个案例研究时，很少有人会面临挑战。下面列出了其中的一些:</p><p id="e400" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">处理数据不平衡问题的技巧:</strong></p><ol class=""><li id="9425" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">在大多数sklearn分类器建模库中使用属性“<strong class="ig hi"> class_weight </strong>”。例如:</li></ol><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="9e9f" class="ka kb hh jw b fi kc kd l ke kf">xgb_model = XGBClassifier(class_weight='balanced')</span></pre><p id="f8c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">除了<strong class="ig hi">平衡的</strong>之外，一个<strong class="ig hi"> </strong>可以传递包含两个类(在我们的例子中是0/1)权重的字典。默认情况下，其值为<strong class="ig hi">无</strong>。</p><p id="f3cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更准确地说，我们可以按照下面的公式来理解类权重的计算:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="b784" class="ka kb hh jw b fi kc kd l ke kf">w_1 = number_of_samples/(number_of_classes * number_of_samples_in_class_1)</span></pre><p id="3751" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望这对于很好的理解班级分布有所帮助。通常“平衡”给出更好的结果。如果有极端的情况，那么尝试手动给出重量。我们还有另一种技术，即击打。</p><p id="82ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.<strong class="ig hi"> SMOTE </strong> : <strong class="ig hi">合成少数过采样技术</strong></p><p id="8079" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如它的名字一样，它传达了为少数类生成合成数据的技术。它的工作方式是从少数类中随机选取一个点，并计算该点的k-最近邻。如果是你头上的锣，请参考下图:</p><figure class="jr js jt ju fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kg"><img src="../Images/3a3c303a0f71fc4492a5be30a7241924.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V92hCDbUQotshIUPqNa_Hg.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">SMOTE技术</figcaption></figure><p id="a7e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">合成点被添加到所选点及其相邻点之间。请参考下面的代码片段来实现:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="bec9" class="ka kb hh jw b fi kc kd l ke kf"><em class="ks"># import libraries<br/></em>import imblearn<br/>from imblearn.over_sampling import SMOTE<br/><br/>smote = SMOTE()</span><span id="612f" class="ka kb hh jw b fi kt kd l ke kf"><em class="ks"># Fit the predictor and target variable</em><br/>X_smote, y_smote = smote.fit_resample(X, y)</span></pre><p id="6f02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">利用X_smote和y_smote进行进一步的建模活动。如果没有安装“imblearn ”,请参考下面的代码片段:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="f145" class="ka kb hh jw b fi kc kd l ke kf">sudo pip install imbalanced-learn</span></pre><p id="8844" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这将解决我们建模的一个主要问题。</p><p id="cf38" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">信用卡交易中的欺诈行为问题是一个典型的分类问题。其中我们必须预测特定案例是<strong class="ig hi">欺诈</strong>还是<strong class="ig hi">非欺诈</strong>。</p><p id="3a84" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了解决这个问题，我尝试了3种不同的建模技术，并尝试了这三种技术的优化版本。在对任何技术建模之前，确保数据是可伸缩的。否则，这可能导致对模型特征重要性的错误解释。</p><ol class=""><li id="a1b4" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated"><strong class="ig hi">逻辑回归</strong></li></ol><ul class=""><li id="df10" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb ku ji jj jk bi translated">确保数据彼此不相关。在相关数据的情况下，必须在建模前移除相关变量。</li></ul><p id="ba39" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参考下面的代码片段:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="0e6e" class="ka kb hh jw b fi kc kd l ke kf"># LR Model<br/>log_reg = LogisticRegression(class_weight='balanced')<br/>reg_model = log_reg.fit(X_train, y_train)</span></pre><p id="50c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">2.<strong class="ig hi">决策树</strong></p><p id="f4ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参考下面的代码片段:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="57e4" class="ka kb hh jw b fi kc kd l ke kf"># Decision Tree Classifier Model<br/>dt = DecisionTreeClassifier(max_depth=3, class_weight='balanced')<br/>dt.fit(X_train, y_train)</span><span id="ac0a" class="ka kb hh jw b fi kt kd l ke kf"># Tuned model <br/>dt_final = DecisionTreeClassifier(max_depth=3, <br/>                                  class_weight='balanced', <br/>                                  min_samples_leaf=100,<br/>                                  criterion='gini')<br/>dt_final.fit(X_train, y_train)</span></pre><p id="bc4a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">3.<strong class="ig hi"> XGBoost </strong></p><p id="af7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请参考下面的代码片段:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="2926" class="ka kb hh jw b fi kc kd l ke kf"># XGBoost model<br/>xgb_model = XGBClassifier(class_weight='balanced')<br/>xgb_model.fit(X_train, y_train)</span><span id="9fe3" class="ka kb hh jw b fi kt kd l ke kf"># Hyper parameter tuned model<br/>xgb_final = XGBClassifier(class_weight='balanced',<br/>                                learning_rate=0.2,<br/>                                max_depth=4,<br/>                                min_child_weight=11,<br/>                                n_estimators=100)</span><span id="3db6" class="ka kb hh jw b fi kt kd l ke kf">xgb_final.fit(X_train, y_train)</span></pre><p id="a2af" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">车型汇总:</strong></p><p id="9836" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以看到下面的模型摘要:</p><figure class="jr js jt ju fd kh er es paragraph-image"><div class="er es kv"><img src="../Images/3154ba58d46ad911753d755eb7165d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*yt-TdRe8zPp-RZYyHFt2qA.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">所有3种模型的总结</figcaption></figure><p id="21eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论:</strong></p><p id="4218" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">很难选择更好的模型，因为大多数模型都有很好的精度。准确性将无法对此用例做出好的解释。由于我们有一个有偏见/不平衡的类，所以最好使用精度和召回来评估模型。更准确地说，我们应该关注<strong class="ig hi">回忆分数</strong>。</p><p id="3a74" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据我们的评估矩阵，我们可以选择XGBoost。我们还可以通过对超参数调整和SMOTE技术进行更多的探索来提高这个分数，这是我没有使用过的。</p><p id="fb48" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里找到完整的代码。</p></div></div>    
</body>
</html>