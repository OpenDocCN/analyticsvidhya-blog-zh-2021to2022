<html>
<head>
<title>Undersampling and oversampling: An old and a new approach</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">欠采样和过采样:新旧方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/undersampling-and-oversampling-an-old-and-a-new-approach-4f984a0e8392?source=collection_archive---------1-----------------------#2021-02-21">https://medium.com/analytics-vidhya/undersampling-and-oversampling-an-old-and-a-new-approach-4f984a0e8392?source=collection_archive---------1-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/7e978182c4ae99fb2a0863d004b7bc13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7xf9e1EaoK5n05izIFBouA.png"/></div></div></figure><p id="c22a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">内容:<br/> </strong> 1。简介<br/> 2。欠采样<br/> 3。过采样<br/> 4。动态欠采样和过采样</p><p id="30be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">简介:<br/> </strong>人们可以很容易地找到所有的数据集、语料库等等，而且即使不是全部，它们中的大部分都将处于原始和完美的状态。没有空值，平衡的类，大量的数据，每个数据科学家的完美数据集版本。唉，这或多或少是罕见的，几乎可以说是埃及人所说的“第四个不可能”。欠采样和过采样是用于解决数据集中不平衡类问题的技术。我们有时这样做是为了避免以牺牲其他类(不管是一个类还是多个类)为代价，用多数类来过度拟合数据。因此，在这篇文章中，我试图展示欠采样是如何工作的，过采样是如何工作的，最后我写了一个小惊喜，你可以在方便的时候使用。</p><p id="ff8f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">欠采样:<br/> </strong>实现这一点的一种方法或多或少是在名称上。欠采样意味着将所有类的数量与少数类或行数最少的类的数量相同。举个例子:我们有一个100行的数据集，有三个独立的列和一个依赖的特性，也称为类列。class列有三个标签:1、2和3。标签1有39个实例，标签2有32个实例，标签3有29个实例。为了对上述数据集应用欠采样，我们必须将标签1和标签2减少到与标签3相同的实例数量。因此，在这个特定的例子中，每个标签有29个实例。让我们继续尝试这样做。</p><p id="a295" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">首先，让我们导入所需的库。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="bc60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">然后，我们接下来要做的是创建一个随机填充的三列100行的数据集。这些值的范围从0到100。我们将这些列称为“f1”、“f2”和“f3”。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="44f9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这个数据集应该是这样的。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ju"><img src="../Images/8f0ba94a61acee3cfb867010452fc1e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nJEp1gBw2sWZCtMPj_rwmg.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图01</figcaption></figure><p id="fe55" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在,“df”数据帧中的这些列构成了特征。接下来，我们将创建标签类，命名为“l1”。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="a3b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">数据帧应该看起来像这样。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/c3de3f6d0e71e3b9bce4b72ef5226f27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yUAmhdbMV4D7FLHIZxSrwA.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图02</figcaption></figure><p id="d33e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看新的随机创建的类的构成，然后我们将标签DataFrame添加到原始DataFrame。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/343be76a200227189fd251dd2502cc2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NgvezO5wABXuWCekwdRN0Q.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图03</figcaption></figure><p id="d753" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">合并后，我们应该能够看到新的数据帧。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kb"><img src="../Images/6a8c4d10d98ba8326c622b8ae335926f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Va_1hrhlz-iAjtChkwBFPw.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图04</figcaption></figure><p id="fdf9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此时，数据框架已经完成，其中三列作为特征，一列作为类列。我们接下来要做的是改变所述数据帧，以拉平所有类的计数。我们将分配新的变量，每个变量都有每个类的计数。然后我们将创建新的数据帧，每个类一个。如果对我们为什么需要两者感到困惑，请允许我解释两者之间的区别。</p><p id="dd2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">第一行中的变量是数据类型为<em class="kc"> int </em>的，将被用来告诉我们需要多少样本。虽然第2行和第4行之间的数据类型是DataFrame，但每一行都是DataFrame的一部分，只包含一种类型的类。最后，在第5行和第6行，我们将把数据帧重新分配给新的数据帧，但是我们将对其应用示例函数，并向其传递最小类的int值，在本例中是<em class="kc"> class_1 </em>。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="77bf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">最后，我们将连接最后两个新的数据帧以及一个包含少数类标签的原始数据帧。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="e140" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们看看现在的班级作文是什么样的。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/987e4cb7eb333a401ffe0ecd37f2a2fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kYhCJdvc77FtScx-mx9M0Q.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图05</figcaption></figure><p id="27bc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">根据图03，这些检查出来。</p><p id="4ddd" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">过采样:<br/> </strong>与本文的前一节相反，这一次我们将尝试复制其他类的行，使其等于多数类的行。现在，除了几个关键的例外，所有的步骤都差不多，但是步骤和逻辑都是一样的。</p><p id="7deb" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在大多数情况下，我们将做同样的事情，直到我们将其他类抽样到一个特定的类。这一次我们将对多数阶级而不是少数阶级进行抽样。当然，我们将在示例函数中添加参数<em class="kc"> replace=True </em>，以便复制数据，增加传入的类的计数。所以在这种情况下，我们有了其他两个阶级，和多数阶级一样的立足点。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="4f26" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，我们将这两个数据帧与原始多数数据帧连接起来。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="0459" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看这些类的组成。</p><figure class="jo jp jq jr fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ke"><img src="../Images/c4bff25371c0cac8a45264dc7565fbfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nDFVkJ8TCbL4FKLskEZlFQ.png"/></div></div><figcaption class="jv jw et er es jx jy bd b be z dx translated">图07</figcaption></figure><p id="fa02" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">没多大区别。</p><p id="50c4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">动态欠采样和过采样:<br/> </strong>至此，大家应该能够理解什么是欠采样和过采样，以及如何实现它们。好吧，到目前为止，这很好，但几乎使穷人的运动。因此，我更进一步，决定做更多的事情。出于这个练习的目的，我编写了两个函数，一个用于欠采样，一个用于过采样，来动态地改变数据帧的类，而不管类的数量。这两个函数是孪生的，但是对于类似于我们在前面部分中所做的差别的小计算。</p><p id="4d62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们一行一行地剖析这个函数，看看从中能得到什么。我知道从表面上看它可能有点令人生畏，但是如果你理解了前两节，这个函数和下面的应该很容易理解。现在让我们继续吧。</p><p id="41cf" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从第2行开始，我们将获得数据集的类组成(如第1行所示，在函数中作为参数传递)，并将它转换成python字典。现在，为了知道哪个类的记录最少，我们对字典的值应用了<em class="kc"> min() </em>函数。接下来，对于第4行到第6行，我们创建了一个名为<em class="kc"> classes_list </em>的列表，我们将在其中存储具有单一类类型的数据帧。所以在这一点上，<em class="kc">的classes_list </em>应该已经存储了所有的数据帧。</p><p id="3835" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于第7行到第9行，我们创建了另一个名为<em class="kc"> classes_sample </em>的列表，我们将在其中存储采样的类。让我借用一下你的注意力，在第8行。除了最后一个元素，我们在list <em class="kc"> classes_list </em>的范围内循环。这样做的原因是我们希望在<em class="kc"> classes_sample </em>中存储除minority类之外的所有内容，minority类总是存储在字典的最后一个元素中，因此逻辑上也存储在<em class="kc"> classes_list中。</em></p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="3bea" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在，在这个函数的最后一部分，我们创建一个临时的排序数据帧来连接其中的列表<em class="kc"> classes_sample </em>。然后我们创建最终的数据帧(令人惊讶地命名为<em class="kc"> final_df </em>)，在这里我们连接占位符数据帧以及存储在列表<em class="kc"> classes_list的最后一个元素中的少数类，</em>只要确保设置<em class="kc"> axis=0。</em>最后，我们重置了指数。</p><p id="d691" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在谈谈过采样动态函数，坦率地说，差异很小，所以我只指出差异及其原因。</p><p id="9559" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两个区别出现在第8行和第11行:第8行的循环基本上将范围从第一个元素移动到倒数第二个元素，因为在字典中，最大的类存储在第一个键中，在列表<em class="kc"> classes_list中也是如此。</em>因此，在第11行，出于同样的原因，我们添加了<em class="kc"> classes_list </em>中的第一个元素，而不是最后一个。</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="js jt l"/></div></figure><p id="490e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这两个功能是一个很好的挑战，我希望你可以使用它们，从中学习，甚至升级/改变它们。这是动态功能的第二个版本，我相信还有改进的空间。如果你确实改进了它们，请让我知道。</p></div></div>    
</body>
</html>