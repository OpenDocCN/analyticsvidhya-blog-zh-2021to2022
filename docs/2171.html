<html>
<head>
<title>Simple Data(base) Versioning For ML with Disdat</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Disdat的ML的简单数据(基础)版本控制</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/simple-database-versioning-for-ml-with-disdat-aa5e42af1ab9?source=collection_archive---------6-----------------------#2021-04-09">https://medium.com/analytics-vidhya/simple-database-versioning-for-ml-with-disdat-aa5e42af1ab9?source=collection_archive---------6-----------------------#2021-04-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div class="er es hf"><img src="../Images/525d98c23ff39fc83bd56ac1eae9e9b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:564/format:webp/1*d_cwzLWov5-nkb5_5AoTCw.jpeg"/></div></figure><div class=""/><p id="24a7" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本文描述了如何构建对数据库工件进行版本控制的ML管道。数据科学家和ML工程师在模型开发期间创建数据工件，包括清理的数据、特征、训练数据和模型评估结果。随着数据科学家探索特征、模型类型和超参数，这一过程会不断重复。与此同时，上游数据不断变化，导致数据工件(文件和表格)激增，这些数据工件通常使用手动的特别方法进行管理。</p><p id="5977" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">例如，考虑一个数据科学团队与存储点击流、事实表和下游分析师表的数据库进行交互。通常每个团队都以定制的方式为每个项目管理这种复杂性。派生表在对象存储和数据库中有它们自己的特定于项目的命名法，比如<code class="du jj jk jl jm b">logins_v41_fix8_4_1_2020</code>。</p><p id="5d71" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这导致:</p><ul class=""><li id="6467" class="jn jo ho in b io ip is it iw jp ja jq je jr ji js jt ju jv bi translated">维护定制逻辑以编码系统如何产生数据，例如上游数据源、参数和表名中的修正。</li><li id="2879" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">数据共享困难。查找、共享和理解数据需要下游团队和系统坚持每个项目的命名选择。</li><li id="6831" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">悬空数据。很难在整个数据湖或数据库中确定可删除的数据，以降低成本或适应数据隐私法规。</li></ul><p id="8eae" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">本文向您展示了如何使用<a class="ae kb" href="https://disdat.gitbook.io" rel="noopener ugc nofollow" target="_blank"> Disdat </a> ML管道来:</p><ul class=""><li id="8be0" class="jn jo ho in b io ip is it iw jp ja jq je jr ji js jt ju jv bi translated">使用名称间接的版本数据库表，允许消费者通过搜索像<code class="du jj jk jl jm b">logins</code>这样的逻辑实体来找到最新的表。</li><li id="4548" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">自动使用和生成版本化的表，而不必担心破坏先前的结果或踩到已部署的数据工件。</li><li id="1680" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">启用简单的数据保留策略。</li></ul><h2 id="66a4" class="kc kd ho bd ke kf kg kh ki kj kk kl km iw kn ko kp ja kq kr ks je kt ku kv kw bi translated"><strong class="ak">分离和间接命名</strong></h2><p id="e4ce" class="pw-post-body-paragraph il im ho in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">Disdat是一个<a class="ae kb" href="https://github.com/kyocum/disdat" rel="noopener ugc nofollow" target="_blank">开源数据版本控制系统</a>，有三个关键组件:一个用于管理和版本控制数据的Python API、Spotify的Luigi管道系统和一个CLI。Disdat以<em class="lc">包、</em>命名的用户数据集合的粒度发布数据。束元数据捕获代码如何创建每个束(代码+参数+输入数据)。Disdat管理<em class="lc">数据上下文</em>中的包，这些包可能是本地的，也可能附加到S3的远程设备上。Disdat为执行版本化数据科学提供了许多工具；更多关于Disdat的细节可以在<a class="ae kb" href="https://disdat.gitbook.io" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><p id="68b2" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在ML管道中，每个任务可以消耗和产生数据表。通常，任务将确定每个表的名称，例如<code class="du jj jk jl jm b">logins</code>。但是，如果我们重新运行相同的任务，我们有三个选择:a .)更新现有的表，b .)用相同的名称重新创建一个表，或者c .)创建一个新表。本文关注于<em class="lc">批处理，</em>非追加转换，(尽管我们将在下面对选项A进行评论)，所以我们只能选择选项B或c。如果我们选择B，那么先前的版本将会丢失。如果我们选择C，那么我们必须有一个命名方案、一种交流名称的方式和一种清理旧表的方法。</p><p id="9f4b" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Disdat的<em class="lc">命名间接</em>使用户既能保留他们数据的先前版本，又能很容易地找到最新的表。我们先来看一个直接命名的例子。</p><figure class="le lf lg lh fd hj er es paragraph-image"><div class="er es ld"><img src="../Images/c41bbc7828ccb0666bc1b4bf2f6ca53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*shSxBOii5ypJcczNNgzBVw.jpeg"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">通过直接命名，数据科学家/ ML工程师在ML管道中为表指定自定义名称。</figcaption></figure><p id="c786" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这里，用户使用自定义名称创建和读取表格。每个新版本都需要一个新的物理表名，每个下游消费者都必须知道新版本何时存在以及名称如何演变。</p><figure class="le lf lg lh fd hj er es paragraph-image"><div class="er es lm"><img src="../Images/29964c1a51169b19ef578246bffd6e1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*X5DWrU8aWnmFfflhSbp0Ow.jpeg"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">使用间接方式，ML管道为每个新版本注册一个逻辑名。</figcaption></figure><p id="b20c" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">通过允许使用<em class="lc">逻辑</em>名称，间接命名简化了创建者(ML管道)和消费者(其他管道或用户)的过程。版本化实体只有一个逻辑名称，并且目录服务(即Disdat)维护逻辑名称和uuid之间的关联。<br/>现在创造和消费变成了:</p><pre class="le lf lg lh fd ln jm lo lp aw lq bi"><span id="4bf0" class="kc kd ho jm b fi lr ls l lt lu">create table `register(“logins”)`<br/>select * from `get("logins")`</span></pre><p id="5b92" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">表编写器向命名目录服务(即Disdat)注册人类可读的名称“logins ”,后者返回一个惟一的ID (uuid)。然后，表读取器查询目录以发现最新版本的“登录”注意，这种方法也适用于文件和流。</p><h2 id="3223" class="kc kd ho bd ke kf kg kh ki kj kk kl km iw kn ko kp ja kq kr ks je kt ku kv kw bi translated"><strong class="ak">示例:一个简单的基于SQL的ML管道</strong></h2><p id="e663" class="pw-post-body-paragraph il im ho in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">下面是双任务管道的伪代码，其中每个任务创建一个表。第一个任务在现有的表中查询<code class="du jj jk jl jm b">date</code>之后的用户。第二个将该表与点击流数据中的登录事件关联起来。</p><figure class="le lf lg lh fd hj er es paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="er es lv"><img src="../Images/0330fa4e694f29965063c6d10d72917d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1126/format:webp/1*V9U2ffPZhhC6TozOLR_kyw.jpeg"/></div></div></figure><p id="e77d" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了避免作为方法调用序列重新运行所有任务，我们可以使用许多可用的工作流/流水线系统中的一个(例如Luigi、Airflow、Kubeflow等)在DAG中编码依赖性。).但是仍然存在许多问题:</p><ul class=""><li id="c932" class="jn jo ho in b io ip is it iw jp ja jq je jr ji js jt ju jv bi translated">多个开发人员必须通过调整表名来隔离他们的工作，以避免冲突。</li><li id="4edb" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">类似地，部署的管道必须使用新的表名，以避免与dev或test冲突。</li><li id="06d5" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">没有办法知道是哪个版本的代码创建了这些表。</li><li id="1a64" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">如果我们从这些表中训练ML模型，就不可能“回滚”到先前的训练数据(或特征)，也不可能判断当前的表是否用于训练被检查的模型。</li></ul></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="67e4" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">为了解决这些问题，我们使用Disdat-Luigi编写了简单的管道。一般模式是:</p><ul class=""><li id="7a3a" class="jn jo ho in b io ip is it iw jp ja jq je jr ji js jt ju jv bi translated">每个Disdat-Luigi任务都生成一个带有物理名称表，并返回物理名称作为输出。</li><li id="d012" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">Disdat-Luigi在每个任务运行后创建一个包，用这个物理名称作为它的数据。</li><li id="6801" class="jn jo ho in b io jw is jx iw jy ja jz je ka ji js jt ju jv bi translated">后续任务使用上游任务的包来获取物理表名，以参数化SQL语句。</li></ul><figure class="le lf lg lh fd hj er es paragraph-image"><div class="er es mh"><img src="../Images/2de8ce896541a81ffd3668dbf22b9f31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*10y-uYACJpdjuP9zCuXPyQ.jpeg"/></div><figcaption class="li lj et er es lk ll bd b be z dx translated">利用Disdat进行名称间接寻址的两个任务的伪代码。注意，Disdat-Luigi在任务完成时自动创建灰色Disdat包，并自动读取上游包以找到下游任务的输入。</figcaption></figure><h2 id="8b9d" class="kc kd ho bd ke kf kg kh ki kj kk kl km iw kn ko kp ja kq kr ks je kt ku kv kw bi translated">示例:转换为管道任务</h2><p id="3de5" class="pw-post-body-paragraph il im ho in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">我们将上面的伪代码翻译成下面的实际Disdat-Luigi PipeTasks。</p><pre class="le lf lg lh fd ln jm lo lp aw lq bi"><span id="6f2c" class="kc kd ho jm b fi lr ls l lt lu"><strong class="jm hp">class UsersTask(disdat.PipeTask):<br/>  </strong>sql_string = “create table {dst} as select * from users where users.date &gt;= {date}”<br/>  date = luigi.DateParameter()<br/>  <br/>  <strong class="jm hp">def pipe_run(self):</strong><br/>    dst = f”users_{self.get_hframe_uuid()}”<br/>    run_sql(self.sql_string.format(dst=dst, date=self.date))<br/>    return dst</span></pre></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><pre class="ln jm lo lp aw lq bi"><span id="3cbb" class="kc kd ho jm b fi mi mj mk ml mm ls l lt lu"><strong class="jm hp">class LoginsTask(disdat.PipeTask):<br/>  </strong>sql_string = “create table {dst} as select * from {src} join cstream on {src}.id = cstream.id where cstream.event='login'”<br/>  date = luigi.DateParameter()</span><span id="f0a4" class="kc kd ho jm b fi mn ls l lt lu"><strong class="jm hp">  def pipe_requires(self):</strong><br/>    self.set_bundle_name("logins")<br/>    self.add_dependency(‘phys_table’, UsersTask, params={‘date’: self.date})<br/>  <br/>  <strong class="jm hp">def pipe_run(self, phys_table):</strong><br/>    dst = f”logins_{self.get_hframe_uuid()}”<br/>    run_sql(self.sql_string.format(src=phys_table, dst=dst))<br/>    return dst</span></pre><p id="bcda" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们仅通过<code class="du jj jk jl jm b">date</code>参数来参数化第一个任务。它通过<code class="du jj jk jl jm b">self.get_hframe_uuid()</code>调用创建物理输出表名，在SQL调用中使用它，然后将其作为输出返回。第二个任务使用<code class="du jj jk jl jm b">pipe_requires()</code>方法中的<code class="du jj jk jl jm b">self.add_dependency</code>语句将第一个任务添加为上游依赖项。当Disdat-Luigi运行<strong class="in hp"> LoginsTask </strong>时，它从Disdat中找到前一个任务的输出包，并将其数据放入<code class="du jj jk jl jm b">phys_table</code>参数中。现在，任务可以使用物理表名参数化它们的SQL语句，瞧！您有一个通过数据库生成版本化数据的ML管道。</p><p id="9f06" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，每次管道运行时(注意<code class="du jj jk jl jm b">date</code>参数)，它将根据需要创建每个表的新版本。我们利用了每个Disdat-Luigi任务为每个任务执行创建一个单一的、惟一的、不可变的包的事实。我们只是重复使用该包的UUID来命名任务的物理表。如果一个任务希望增量添加到现有的表中，它可以使用UUID来标记每个新行，保持表名不变。下面是我们如何从CLI运行它(假设模块sql_tasks.py包含上述代码):</p><pre class="le lf lg lh fd ln jm lo lp aw lq bi"><span id="a977" class="kc kd ho jm b fi lr ls l lt lu">$dsdt apply sql_tasks.LoginsTask --date 2020-12-4</span></pre><p id="2f2a" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在幕后，Disdat-Luigi添加元数据，包括git存储库、文件、提交、日期和执行时间。并且使用Disdat的Python API可以轻松获取最新的<code class="du jj jk jl jm b">logins</code>表:</p><pre class="le lf lg lh fd ln jm lo lp aw lq bi"><span id="077e" class="kc kd ho jm b fi lr ls l lt lu">import disdat.api as api</span><span id="d6c8" class="kc kd ho jm b fi mn ls l lt lu">api.pull("sql-data-context")<br/>b = api.get("logins")<br/>print(f"The most recent table is located here: {b.data}")</span></pre><h2 id="a5de" class="kc kd ho bd ke kf kg kh ki kj kk kl km iw kn ko kp ja kq kr ks je kt ku kv kw bi translated"><strong class="ak">清理</strong></h2><p id="25f0" class="pw-post-body-paragraph il im ho in b io kx iq ir is ky iu iv iw kz iy iz ja la jc jd je lb jg jh ji ha bi translated">最后，虽然存储很便宜，但限制版本的蔓延也很重要。为此，我们使用Disdat的元数据来查找可删除的表。我们可以将此编码为另一个Disdat-Luig任务，如果有多于<code class="du jj jk jl jm b">last_m_copies</code>且早于<code class="du jj jk jl jm b">threshold_n_days</code>的表，则丢弃这些表。由于这也是一个Disdat-Luigi任务，因此可以将其添加到原始管道的末尾，或者单独运行。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="ea82" class="pw-post-body-paragraph il im ho in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果你已经走到这一步，恭喜你！Disdat还有许多其他功能来支持版本化数据科学。这篇文章介绍了Disdat稍微高级一点的用法(使用UUID包对非文件数据进行版本控制)。我很快会发布更多的“介绍”故事。代码可以在<a class="ae kb" href="https://github.com/kyocum/disdat" rel="noopener ugc nofollow" target="_blank"> github </a>上获得，包括一些<a class="ae kb" href="https://github.com/seanr15/disdat-examples" rel="noopener ugc nofollow" target="_blank">的例子</a>。文档，包括那些例子和与其他数据版本系统的比较，可以作为<a class="ae kb" href="https://disdat.gitbook.io" rel="noopener ugc nofollow" target="_blank"> gitbook </a>获得。</p></div></div>    
</body>
</html>