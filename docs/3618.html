<html>
<head>
<title>Car Price Prediction in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的汽车价格预测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/car-price-prediction-in-python-b8451bcb4ba3?source=collection_archive---------8-----------------------#2021-07-13">https://medium.com/analytics-vidhya/car-price-prediction-in-python-b8451bcb4ba3?source=collection_archive---------8-----------------------#2021-07-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9ff1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上周，我们对一个汽车数据集做了一些<a class="ae jc" rel="noopener" href="/@AnderRV/exploratory-data-analysis-in-python-ab5ef8d6460">探索性数据分析。在使用数据集并收集了许多见解后，我们今天将重点关注价格预测。</a></p><p id="53f0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://www.zenrows.com/datasets/germany-cars?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=car_price_prediction" rel="noopener ugc nofollow" target="_blank">该数据集包括在德国销售的汽车</a>，注册年份为2011年至2021年。所以我们可以假设它是当今市场价格的准确代表。</p><h1 id="6c4a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">先决条件</h1><p id="0f49" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了让代码工作，你需要安装<a class="ae jc" href="https://www.python.org/downloads/" rel="noopener ugc nofollow" target="_blank"> python3和</a>。有些系统已经预装了它。之后，通过运行<code class="du kg kh ki kj b">pip install</code>安装所有必要的库。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="8398" class="ks je hh kj b fi kt ku l kv kw"><em class="kx"># last weeks </em><br/>pip install pandas matplotlib squarify seaborn <br/><em class="kx"># new libs </em><br/>pip install scipy sklearn catboost statsmodels</span></pre><h1 id="324e" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">数据清理</h1><p id="b8d6" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">假设我们想根据属性预测汽车价格。为此，我们将训练一个模型。让我们从用年龄代替注册年份开始，去掉品牌和型号—我们不会用它们来进行预测。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="b6c2" class="ks je hh kj b fi kt ku l kv kw">cars['age'] = datetime.now().year - cars['year'] <br/>cars = cars.drop('year', 1) <br/>cars = cars.drop('make', 1) <br/>cars = cars.drop('model', 1)</span></pre><p id="eb98" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们上周讨论了离群值，现在是时候移除它们了。我们将删除价格、马力或里程的<a class="ae jc" href="https://en.wikipedia.org/wiki/Standard_score" rel="noopener ugc nofollow" target="_blank"> z得分</a>高于3的项目。简而言之，这意味着去掉偏离平均值超过三个标准差的值。</p><p id="ccda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在此之前，<code class="du kg kh ki kj b">dropna</code>将删除所有具有空值或null值的行。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="f5ff" class="ks je hh kj b fi kt ku l kv kw">from scipy import stats <br/> <br/>cars = cars.dropna() <br/>cars = cars[stats.zscore(cars.price) &lt; 3] <br/>cars = cars[stats.zscore(cars.hp) &lt; 3] <br/>cars = cars[stats.zscore(cars.mileage) &lt; 3]</span></pre><p id="eb7a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们将使用布尔标记替换类别值(优惠类型和齿轮)。实际上，这意味着为每个类别类型创建新列(即，对于<em class="kx">齿轮</em>，它将是自动、手动和半自动的)。</p><p id="7023" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">熊猫有一个功能可以做到这一点:<code class="du kg kh ki kj b">get_dummies</code>。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="e35b" class="ks je hh kj b fi kt ku l kv kw">offerTypeDummies = pd.get_dummies(cars.offerType) <br/>cars = cars.join(offerTypeDummies) <br/>cars = cars.drop('offerType', 1) <br/> <br/>gearDummies = pd.get_dummies(cars.gear) <br/>cars = cars.join(gearDummies) <br/>cars = cars.drop('gear', 1)</span></pre><figure class="kk kl km kn fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/13514af0f8401b6b81b3489d94b4a8e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E8XlZqRXiFpggUkI7dxFDg.jpeg"/></div></div></figure><h1 id="3f38" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">目视检查相关性</h1><p id="3d9c" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们将使用<code class="du kg kh ki kj b">seaborn heatmap</code>绘制变量相关性。它会用图表告诉我们哪些变量是正相关或负相关的。</p><p id="533f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最高的相关性显示年龄与里程数——听起来不错——以及价格与马力——也不是什么大新闻。看看负相关，价格与年龄——这也很自然。</p><p id="1cc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以忽略手动和自动之间的关系，因为很明显你只会有一个或另一个——几乎没有半自动。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="b004" class="ks je hh kj b fi kt ku l kv kw">import seaborn as sns <br/> <br/>sns.heatmap(cars.corr(), annot=True, cmap='coolwarm') <br/>plt.show()</span></pre><figure class="kk kl km kn fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/78d76d62f71f047d5ffc1b1902c544eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iTSZ34m-aA22qRsy.jpg"/></div></div></figure><p id="5682" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了仔细检查，我们将绘制马力和里程变量与价格的关系。我们将与<code class="du kg kh ki kj b">seaborn jointplot</code>合作。</p><p id="5a9e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它将绘制所有条目和一条回归线。为了简洁起见，只有一个代码片段。第二个将是相同的，用<em class="kx">里程</em>代替<em class="kx"> hp </em>。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="8ea2" class="ks je hh kj b fi kt ku l kv kw">sns.set_theme(style="darkgrid") <br/>sns.jointplot(x="hp", y="price", data=cars, <br/>	kind="reg", color="m", line_kws={'color': 'red'}) <br/>plt.show()</span></pre><figure class="kk kl km kn fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/b2564135d7a0599ac945702a2c3f9b26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*J-VMF3XvtwMuKeY1.jpg"/></div></div></figure><figure class="kk kl km kn fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/8a7f0daf8276ce8492ae076c95f71d8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y9aalkqBGFfm1qzq.jpg"/></div></div></figure><h1 id="f818" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">价格预测</h1><p id="8168" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我们就要到达关键部分了。我们将尝试<strong class="ig hi">三种不同的预测模型</strong>，看看哪一种表现更好。</p><p id="bd34" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们需要两个变量，Y和X，包含价格和所有剩余的列。我们也将在其他模型中使用这些新变量。然后，我们将用于训练和测试的数据分成70%-30%的分布。</p><p id="0b14" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">免责声明</strong>:我们对所有型号进行了多次测试，并为每个型号选择了最佳结果。不一样的var适用，会出现一些“神奇”的数字。我们主要通过反复试验来调整这些。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="0c8e" class="ks je hh kj b fi kt ku l kv kw">from sklearn.model_selection import train_test_split <br/> <br/>X = cars.drop('price', 1) <br/>Y = cars.price <br/>X_train, X_test, y_train, y_test = train_test_split( <br/>	X, Y, train_size=0.7, test_size=0.3, random_state=100)</span></pre><h1 id="eb40" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">来自sklearn的线性模型</h1><p id="2c64" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">为了训练第一个<code class="du kg kh ki kj b">LinearRegression</code>模型，我们将把训练数据传递给<em class="kx">拟合</em>方法，然后把测试数据传递给<em class="kx">预测</em>。</p><p id="bf2b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了检查结果，我们将对所有结果使用<em class="kx"> R平方</em>。在这种情况下，结果是<strong class="ig hi"> 0.81237 </strong>。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="70dc" class="ks je hh kj b fi kt ku l kv kw">from sklearn import linear_model <br/>from sklearn.metrics import r2_score <br/> <br/>lm = linear_model.LinearRegression() <br/>lm.fit(X_train, y_train) <br/>y_pred = lm.predict(X_test) <br/>print(r2_score(y_true=y_test, y_pred=y_pred)) <em class="kx"># 0.81237</em></span></pre><h1 id="afb8" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">来自CatBoost的回归量</h1><p id="197f" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">接下来，我们将使用来自<code class="du kg kh ki kj b">CatBoost</code>的<code class="du kg kh ki kj b">Regressor</code>。这个模型是用一些我们通过测试调整过的数字创建的。和上一个类似，用训练数据拟合模型，检查分数，结果<strong class="ig hi"> 0.92416 </strong>。</p><p id="bd1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一个很大的区别，因为这种方法慢得多，超过20秒。这可能是一个更接近的匹配，但如果它必须立即运行，这不是一个好的选择。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="0266" class="ks je hh kj b fi kt ku l kv kw">from catboost import CatBoostRegressor <br/> <br/>model = CatBoostRegressor(iterations=6542, learning_rate=0.03) <br/>model.fit( <br/>	X_train, y_train, <br/>	eval_set=(X_test, y_test), <br/>) <br/>print(model.score(X, Y)) <em class="kx"># 0.92416</em></span></pre><h1 id="676a" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">来自statsmodels的OLS</h1><p id="904d" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">对于<code class="du kg kh ki kj b">statsmodels</code>，我们将改变X的值，只取里程、hp、年龄。与之前的值相比，差异几乎提高了10%。</p><p id="82d5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">r平方为<strong class="ig hi"> 0.91823 </strong>，运行时间不到两秒——算上数据加载。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="e51c" class="ks je hh kj b fi kt ku l kv kw">import statsmodels.api as sm <br/> <br/>X = cars[['mileage', 'hp', 'age']] <br/> <br/>model = sm.OLS(Y, X).fit() <br/>predictions = model.predict(X) <br/>print(model.rsquared) <em class="kx"># 0.91823</em></span></pre><h1 id="a491" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">额外球:最佳预测</h1><p id="9382" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">如果我们不放弃品牌和模式，会发生什么？其中两个型号的性能会更差，但不是<code class="du kg kh ki kj b">CatBoost</code>。这将花费更长的时间和更多的空间。我们会有700多个专栏。但是如果你追求准确性，这是值得的。</p><p id="cb5e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了简洁起见，我们不会重复我们以前做过的所有操作。不要放弃制作和模型，为它们创建假人，然后像以前一样继续。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="9fa2" class="ks je hh kj b fi kt ku l kv kw">makeDummies = pd.get_dummies(cars.make) <br/>cars = cars.join(makeDummies) <br/>cars = cars.drop('make', 1) <br/> <br/>modelDummies = pd.get_dummies(cars.model) <br/>cars = cars.join(modelDummies) <br/>cars = cars.drop('model', 1) <br/> <br/><em class="kx"># the rest of the features, just as before </em><br/><em class="kx"># split train and test data </em><br/> <br/>model = CatBoostRegressor(iterations=6542, learning_rate=0.03) <br/>model.fit( <br/>	X_train, y_train, <br/>	eval_set=(X_test, y_test), <br/>) <br/>print(model.score(X, Y)) <em class="kx"># 0.9664</em></span></pre><p id="d07b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">该模型公开了一种获取特征重要性的方法。我们可以使用条形图来检查哪些特征对预测影响最大。我们将它们限制在20个以内，但是正如你将看到的，其中两个——不包括价格本身——承担所有的重量。</p><p id="5946" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx">年龄不重要乍一看可能会让人怀疑。但是有道理。正如我们在相关图中看到的，年龄和里程是密切相关的。所以没必要让他们两个承担所有的重量。</em></p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="c879" class="ks je hh kj b fi kt ku l kv kw">sorted_feature_importance = model.get_feature_importance().argsort( <br/>	)[-20:] <br/>plt.barh( <br/>	cars.columns[sorted_feature_importance], <br/>	model.feature_importances_[sorted_feature_importance] <br/>) <br/>plt.xlabel("Feature Importance") <br/>plt.show()</span></pre><figure class="kk kl km kn fd kz er es paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="er es ky"><img src="../Images/cfea68e7f60dcd0ce1e1739e7bf304c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*AZxnYd20NUnrp-v_.jpg"/></div></div></figure><h1 id="9558" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">估计汽车价格</h1><p id="35ce" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">比方说，你想买或卖你的车。您收集我们提供的特征(里程、年份等)。如何使用预测模型呢？</p><p id="2940" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将再次选择<code class="du kg kh ki kj b">CatBoost</code>并使用他们的<code class="du kg kh ki kj b">predict</code>方法。我们需要用虚拟数据来转换所有数据，这样我们就可以总结了。这一过程将被提取出来，并对现实应用中的训练、测试或实际数据同等地执行。</p><p id="f3d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们还需要添加模型支持的所有空特性(即，所有其他makes)。</p><p id="f8c5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我们展示一个有三辆汽车出售的例子。我们手动输入所有的初始功能(包括价格)，所以我们可以比较输出。正如你将看到的，预测与实际价格相差不远。</p><pre class="kk kl km kn fd ko kj kp kq aw kr bi"><span id="1e44" class="ks je hh kj b fi kt ku l kv kw">realData = pd.DataFrame.from_records([ <br/>	{'mileage': 87000, 'make': 'Volkswagen', 'model': 'Gold', <br/>		'fuel': 'Gasoline', 'gear': 'Manual', 'offerType': 'Used', <br/>		'price': 12990, 'hp': 125, 'year': 2015}, <br/>	{'mileage': 230000, 'make': 'Opel', 'model': 'Zafira Tourer', <br/>		'fuel': 'CNG', 'gear': 'Manual', 'offerType': 'Used', <br/>		'price': 5200, 'hp': 150, 'year': 2012}, <br/>	{'mileage': 5, 'make': 'Mazda', 'model': '3', 'hp': 122, <br/>		'gear': 'Manual', 'offerType': 'Employee\'s car', <br/>		'fuel': 'Gasoline', 'price': 20900, 'year': 2020} <br/>]) <br/> <br/>realData = realData.drop('price', 1) <br/>realData['age'] = datetime.now().year - realData['year'] <br/>realData = realData.drop('year', 1) <br/> <br/><em class="kx"># all the other transformations and dummies go here </em><br/> <br/>fitModel = pd.DataFrame(columns=cars.columns) <br/>fitModel = fitModel.append(realData, ignore_index=True) <br/>fitModel = fitModel.fillna(0) <br/> <br/>preds = model.predict(fitModel) <br/>print(preds) <em class="kx"># [12213.35324984 5213.058479 20674.08838559]</em></span></pre><h1 id="6585" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结论</h1><p id="1431" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">在三款车型中，<code class="du kg kh ki kj b">sklearn</code>表现稍差。另外两个在结果上非常相似——如果排除品牌和型号的话——但在训练时间上不同。因此，这可能是在它们之间进行选择时要考虑的一个重要方面。</p><p id="8fb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你追求高精度，用所有可用的数据训练<code class="du kg kh ki kj b">CatBoost</code>模型。这可能需要一分钟，但它可以存储在一个文件中，并在需要时立即加载。</p><p id="972d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如您所见，将一个<a class="ae jc" href="https://www.zenrows.com/datasets?utm_source=medium&amp;utm_medium=blog&amp;utm_campaign=car_price_prediction" rel="noopener ugc nofollow" target="_blank"> ZenRows生成的数据集</a>加载到<code class="du kg kh ki kj b">pandas</code>非常简单。然后，需要执行一些步骤:描述、手动探索、查看值、检查是否为空。</p><p id="506e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些是首次测试数据集时的日常任务。从那里，标准的做法，如生成假人或删除离群值。然后是多汁的部分。在这种情况下，价格预测使用线性回归，但它可能是任何东西。</p></div></div>    
</body>
</html>