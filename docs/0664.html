<html>
<head>
<title>Beginner’s Guide to K-Nearest Neighbors &amp; Pipelines in Classification</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">K-最近邻和管道分类初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/beginners-guide-to-k-nearest-neighbors-pipelines-in-classification-704b87f534e2?source=collection_archive---------4-----------------------#2021-01-26">https://medium.com/analytics-vidhya/beginners-guide-to-k-nearest-neighbors-pipelines-in-classification-704b87f534e2?source=collection_archive---------4-----------------------#2021-01-26</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/f9f6b75e930b2f15ba5ad58edde32dc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*SbldjFAfYh39hcmwHYF98w.jpeg"/></div><figcaption class="il im et er es in io bd b be z dx translated">pixabay.com免费提供商业用途。</figcaption></figure><p id="6075" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir hi">K-最近邻(KNN) </strong>是一种基本的机器学习算法，用于分类和回归问题。KNN是机器学习的监督学习领域的一部分，它努力寻找模式，以根据已知的基本事实准确地将输入映射到输出。KNN是一种非参数算法，这意味着我们不对数据的分布做出假设。这种假设的一个例子，在线性回归算法中经常见到，是假设我们的数据的分布近似正态。继续，因为我今天已经达到了说“假设”这个词的限额。</p><p id="3e7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">K-最近邻算法使用距离度量来尝试分离空间中的观察聚类。这些独立的集群根据它们携带的特征被分类为不同的组。</p><p id="db19" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">KNN通常使用<strong class="ir hi">欧几里德</strong>或<strong class="ir hi">曼哈顿</strong>距离作为距离度量，但也使用其他距离度量(例如<strong class="ir hi">闵可夫斯基</strong>)。如果你还记得<strong class="ir hi">勾股定理</strong>，用来计算两点间距离的定理，这是实际用来计算欧几里德距离的方程！啊啊，高中几何来了个满圈。</p><p id="c578" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们将所有这些概念应用到一个实际的数据集possum.csv中。我从openintro.org的以下链接中获得了这个数据集:<a class="ae jn" href="https://www.openintro.org/data/index.php?data=possum." rel="noopener ugc nofollow" target="_blank">https://www.openintro.org/data/index.php?data=possum</a>。</p><p id="7acb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这个数据集中，我们给出了澳大利亚两个不同的山刷尾负鼠(<em class="jo"> Trichosurus cunninghami </em>)种群的7个特征。我要问你的问题是:我们能使用物理特征和K-最近邻算法准确地分类一只山刷尾负鼠是来自维多利亚种群还是新南威尔士/昆士兰种群吗？让我们来了解一下！</p><p id="33ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在阅读了。csv文件到我们的jupyter笔记本我们准备开始编码我们的KNN模型！这里是我们正在处理的数据的快速浏览。</p><figure class="jq jr js jt fd ii er es paragraph-image"><div class="er es jp"><img src="../Images/460d47fc03a9352eb551fcb44aa0a724.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*PmE-X08Ph2YcUoKWZPzSxw.png"/></div><figcaption class="il im et er es in io bd b be z dx translated">possum.csv数据帧的前两行</figcaption></figure><p id="f5bb" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如您所见，我们有几个栏目/功能:</p><ul class=""><li id="18ce" class="ju jv hh ir b is it iw ix ja jw je jx ji jy jm jz ka kb kc bi translated"><strong class="ir hi">地点</strong> —捕获负鼠的地点编号。</li><li id="99ca" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi"> pop </strong> —人口，维克(维多利亚)或其他(新南威尔士州或昆士兰州)。目标特征！</li><li id="61ba" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">性别</strong> —性别，m(男)或f(女)。</li><li id="23ff" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">年龄</strong> —年龄。包含2个空值。</li><li id="88e9" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">头部_l </strong> —头部长度，单位为毫米</li><li id="f8f2" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi"> skull_w </strong> —颅骨宽度，单位为毫米</li><li id="ae76" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi">总长度</strong> —总长度，单位为厘米。</li><li id="f234" class="ju jv hh ir b is kd iw ke ja kf je kg ji kh jm jz ka kb kc bi translated"><strong class="ir hi"> tail_l </strong> —尾部长度，单位为厘米。</li></ul><p id="79d3" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们想把我们的负鼠分为来自维多利亚种群或“其他”(新南威尔士或昆士兰)种群。因此，pop列将是我们的目标变量，而其他特征(除了站点)将是我们的预测变量。在这种情况下，由于我们试图仅根据形态差异对两个负鼠种群进行分类，我们不希望在模型中使用捕获负鼠的位置。因此，在设置X(预测变量)对象时，我们将删除site和pop列。y对象是我们的目标变量，它由pop列的两个类(Victoria和‘other’)组成。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="ae23" class="kn ko hh kj b fi kp kq l kr ks">#set up the X and y variables for modeling<br/>X = possum.drop(columns=['pop','site'])<br/>y = possum['pop']</span></pre><p id="706a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">设置好X和y变量后，我们将对数据进行训练/测试分割。训练/测试分割将为我们提供一个用于模型创建的训练集，以及一个用于对我们的模型进行评分的维持集或测试集。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="c867" class="kn ko hh kj b fi kp kq l kr ks">#by default 75% of the observations will be in the training set<br/>#by default 25% of the observations will be in the testing set<br/>X_train, X_test, y_train, y_test = train_test_split(X,y)</span></pre><p id="581c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们希望转换我们的训练数据，以便为建模做好准备。我们想要使用的转换器是<strong class="ir hi"> OneHotEncoding </strong>分类变量、<strong class="ir hi">simple inputing</strong>任何空值，以及<strong class="ir hi"> StandardScaling </strong>。使用K-最近邻算法时，对数据进行标准缩放非常重要，因为您正在使用距离度量进行建模。如果某个特征的比例比其他特征大，那么在建模时，它将决定该特征的重要性。因此，您希望所有预测要素都具有相同的数值比例。</p><p id="fb8a" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">因为我们想要对数据集中的列子集进行转换，所以我们将把特定dtypes的特性传递给<strong class="ir hi"> make_column_transformer </strong>函数。下面，我们抓取要传递给不同转换器的列。null_col变量获取possum数据中唯一包含空值的列——年龄列。我们将把null_col传递给<strong class="ir hi">简单估算器</strong>。cat_cols变量包含我们的数据中唯一的分类变量—负鼠的性别。我们将把cat_cols传递给<strong class="ir hi"> OneHotEncoder </strong>，因为我们只想把数值传递给KNN算法。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="23b1" class="kn ko hh kj b fi kp kq l kr ks">#grab columns of different dtypes for our different transformers<br/>null_col = ['age']<br/>cat_cols = ['sex']</span></pre><p id="9011" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们将把这些变量传递给<strong class="ir hi"> make_column_transformer。</strong>在使用<strong class="ir hi">make _ column _ transformer</strong>时，如果我们不指定参数<strong class="ir hi">remainder = ' pass through '</strong>，那么我们没有转换的所有列都将从输出中删除。显然，这并不理想。我们希望我们所有的预测器特性都在管道末端的KNN算法中使用。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="24de" class="kn ko hh kj b fi kp kq l kr ks">#column transformer with null_col and cat_cols passed as arguments</span><span id="54fa" class="kn ko hh kj b fi kt kq l kr ks">possum_col_transformer = make_column_transformer((OneHotEncoder(), cat_cols),(SimpleImputer(strategy='mean'), null_col), remainder='passthrough')</span></pre><p id="b5ae" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在这里，我们将创建我们的管道。流水线是一种自动化机器学习工作流的方式，它允许数据的预处理和估计器的实例化发生在一段代码中。我们可以使用sklearn的<strong class="ir hi"> make_pipeline </strong>函数在Python中轻松创建管道。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="e50a" class="kn ko hh kj b fi kp kq l kr ks">#pipeline with preprocessing transformers first &amp; estimator last<br/>possum_pipeline = make_pipeline(possum_col_transformer,<br/>                               StandardScaler(),<br/>                               KNeighborsClassifier())</span></pre><p id="6015" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">一旦构建了管道，我们将使我们的训练数据适合管道，以便训练我们的机器学习算法！在我们的possum_pipeline中，我们将使用我们的训练数据X_train和y_train来训练sklearn的<strong class="ir hi"> KNeighborsClassifier </strong>(一种用于分类问题的KNN算法)。为了训练KNN算法，我们将在管道上调用<strong class="ir hi">拟合</strong>方法。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="bfea" class="kn ko hh kj b fi kp kq l kr ks">#fit the pipeline to the training data<br/>possum_pipeline.fit(X_train,y_train)</span></pre><p id="2b9f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在训练数据适合算法之后，我们将得到一个机器学习模型作为输出！你们这些家伙！我们做了一件很酷的事！我们有自己的机器学习模型！</p><p id="acf4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">但真正的问题是:我们的KNN分类器会有多好的表现？我们的KNN模型能够准确区分维多利亚州的负鼠种群和新南威尔士/昆士兰州的负鼠种群吗？让我们来了解一下！</p><p id="f463" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了查看我们的模型的预测能力和准确性，我们将在它从未见过的数据上测试它—测试集— X_test和y_test。如果你还记得，我们在调用<strong class="ir hi"> train_test_split </strong>函数前几行代码时创建了X_test和y_test。</p><pre class="jq jr js jt fd ki kj kk kl aw km bi"><span id="1798" class="kn ko hh kj b fi kp kq l kr ks">#score the knn model on the testing data<br/>possum_pipeline.score(X_test,y_test)</span><span id="4402" class="kn ko hh kj b fi kt kq l kr ks">0.7307692307692307</span></pre><p id="a1ce" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">看看那个分数！我们默认的KNN模型仅使用形态特征就能以73%的准确率预测负鼠来自哪个种群！看看我们。学习并能够准确地对澳大利亚的负鼠种群进行分类。对第一个模特来说还不错吧。你认为我们能把模型做得更好吗？</p></div></div>    
</body>
</html>