<html>
<head>
<title>Is Pypolars the New Alternative to Pandas?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大熊猫是熊猫的新替代品吗？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/is-pypolars-the-new-alternative-to-pandas-916400f03fd7?source=collection_archive---------1-----------------------#2021-02-23">https://medium.com/analytics-vidhya/is-pypolars-the-new-alternative-to-pandas-916400f03fd7?source=collection_archive---------1-----------------------#2021-02-23</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="2d8f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">目标</h1><ul class=""><li id="3182" class="jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">当涉及到数据操作和分析时，Pandas是数据科学家最著名的库之一。</li><li id="43de" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">让我们看看我们有没有大熊猫的替代品。</li></ul><h1 id="155f" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="582b" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">Pandas是一个非常受欢迎的库，甚至非Python程序员和数据科学专业人士也听说过很多。如果你是一个经验丰富的Python程序员，那么你会非常熟悉Pandas库的灵活性。</p><p id="402d" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">Pandas是每个数据科学家都会遇到的基本库之一。这是一个超级强大，快速，易于使用的python库，用于数据分析和操作。从创建数据框到读取不同格式的文件，无论是文本文件、CSV、JSON，还是从分割数据到组合多个数据源，Pandas都是一站式解决方案。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es kt"><img src="../Images/5b5f9e0a14f0b837477368cc9943f51c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PnZM4-DxavqF4XOW.jpg"/></div></div></figure><p id="5549" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">如果我们知道镇上有一个新的图书馆，挑战熊猫在数据处理方面的垄断，会怎么样？是的，对我来说，深入一个叫做pypolars的新图书馆是令人兴奋的。</p><p id="d28f" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">在这篇文章中，我们将看到pypolars是如何运作的，以及它是如何与熊猫相比较的。</p><h1 id="a23a" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">目录</h1><ul class=""><li id="b48d" class="jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt bi translated">什么是pypolars</li><li id="c209" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">如何安装</li><li id="8108" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">急切而懒惰的API</li><li id="d39a" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">如何使用pypolars</li><li id="99d3" class="jc jd hh je b jf ju jh jv jj jw jl jx jn jy jp jq jr js jt bi translated">与熊猫的比较</li></ul><h1 id="57a5" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">pypolars是什么？</h1><p id="37f3" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">Polars是一个在Rust中实现的快速库。polars的记忆模型是基于Apache Arrow的。py-polars是绑定到polars的python，它支持polars所支持的数据类型和操作的一小部分。py-polars最好的一点是，它类似于熊猫，这使得用户更容易打开新的图书馆。</p><p id="f31f" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">让我们更深入地研究pypolars，看看它是如何工作的。</p><h1 id="f7b2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">如何安装</h1><p id="2d95" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">安装pypolars很简单，类似于使用pip的其他python库，并且已经完成。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="7c97" class="lk if hh lg b fi ll lm l ln lo">pip install py-polars</span></pre><h1 id="d4bf" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">急切而懒惰的API</h1><p id="1ff3" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">如果我们谈论API，Polar由两个API组成。一个好学，一个懒。Eager API类似于pandas，即执行将立即发生并产生结果。比如执行一些聚合、连接或分组，这样您就可以立即得到结果。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lp"><img src="../Images/2f6b55aa08d08a3513018dc5e4b92fee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1314/format:webp/0*WRhBujq31BNaEeX_.png"/></div></figure><p id="fbd1" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">另一方面，懒惰的API就像Spark一样。在这里，查询首先被转换成一个逻辑计划，然后该计划被优化和重组，以减少执行时间和内存使用。一旦请求了结果，polars就在可用的执行上分配任务，并在运行中并行化任务。因为所有的计划都是已知的和优化的，所以不需要花费太多时间来呈现输出。</p><h1 id="18b1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">如何使用py-polars？</h1><p id="d870" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">现在我们要看看py-polars是如何工作的，让我们看一些实现代码的例子。</p><h1 id="41fa" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">创建数据框架</h1><p id="d3ae" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">在py-polars中创建数据框类似于熊猫。使用pl.DataFrame</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="d56d" class="lk if hh lg b fi ll lm l ln lo">import pypolars as pl <br/>df= pl.DataFrame({'City':['A','B','C','D','E','F','G','H'],         'Temperature':[30.5,32,25,38,40,29.6,21.3,24.9],<br/> 'Rain':[103,125,90,75,130,200,155,127] })</span></pre><p id="88a9" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">首先，让我们检查创建的数据框的类型和存在的列。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lq"><img src="../Images/23c86daf9860619fa332d88451df4f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*URkBghzsCP77CwlH.png"/></div></div></figure><p id="bfe8" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，我想访问数据框的顶行。就像熊猫DataFrame对象一样，我们有head()函数。如果没有传递参数，它将显示前5行。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lr"><img src="../Images/0632d7f62247ba0fb9d66027d5b918f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:572/format:webp/0*IYRxtz5jChYIe1Kg.png"/></div></figure><h1 id="5981" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">子设置数据帧</h1><p id="b175" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">我们也可以根据熊猫的情况选择数据帧的子集。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="f694" class="lk if hh lg b fi ll lm l ln lo">df[df['Rain']&gt;120]</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ls"><img src="../Images/5103df6906934dc0a343bc7a766d80f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/0*7afmJi5ZgN71NKBE.png"/></div></figure><h1 id="c315" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">连接数据帧</h1><p id="cfad" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">很多时候我们需要组合多个数据框。polars提供了连接数据帧的功能。一个是水平堆叠的hstack，另一个是垂直堆叠的vstack。看看下面给出的例子。</p><p id="dc41" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">在下面的示例中，我首先创建了一个新的数据框，用随机值初始化列湿度。后来，我使用hstack水平合并了两个可用的数据帧。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="8145" class="lk if hh lg b fi ll lm l ln lo">import numpy as np <br/>df1= pl.DataFrame({'Humidity':np.random.rand(8)})<br/>df1</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lt"><img src="../Images/4dc2d3f88068cd2cbce04282a23a0828.png" data-original-src="https://miro.medium.com/v2/resize:fit:254/format:webp/0*Vn_Bk3Lh7GHSodcM.png"/></div></figure><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="bc15" class="lk if hh lg b fi ll lm l ln lo">df.hstack(df1.get_columns())</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lu"><img src="../Images/2e4315c6297e8bf62125349bc7cce52f.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/0*zGn3LOMweCpvMvfa.png"/></div></figure><p id="7cf6" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在，我们有了一个由两个数据帧的数据组成的新数据帧。我发现这个功能真的很有趣。</p><p id="dfa0" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">此外，我们将了解如何垂直组合这两个数据帧。这里我们需要两个具有相似列的数据框。在堆叠之前，我将创建另一个数据帧，它是使用另一个令人兴奋的功能(称为克隆)的df的副本。</p><p id="f31d" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">克隆创建给定系列或数据帧的副本。在polar中创建克隆是超堆，因为polar支持的底层内存是不可变的。这进一步提高了库的性能。</p><p id="a508" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">在创建了给定数据帧的副本之后，我使用vstack来连接这两个数据帧。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="40fc" class="lk if hh lg b fi ll lm l ln lo">df2= df.clone()<br/>df2.vstack(df)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lv"><img src="../Images/53cd7e953a57edb0ef696135695cff33.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/0*s8N73bLIwZoCFs5H.png"/></div></figure><h1 id="c950" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">读取CSV文件</h1><p id="c30a" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">与熊猫相似，polars提供了读取不同格式文件的功能。这里我使用一个CSV文件，并将数据放入一个名为“data”的数据框中。“数据”是pypolars数据框，因为我们可以看到对象的类型。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="c2cf" class="lk if hh lg b fi ll lm l ln lo">data = pl.read_csv('california_housing_train.csv') <br/>type(data)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lw"><img src="../Images/681f601f8215a02a7daa16ee7e711af1.png" data-original-src="https://miro.medium.com/v2/resize:fit:504/format:webp/0*3gALCy73OiPErFxh.png"/></div></figure><p id="4839" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">使用给出最后几行的tail函数检查数据框中的几行。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lx"><img src="../Images/f096ca117a76aaa528fac896eadfec50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Hcw0YcJ3_bZYINKZ.png"/></div></div></figure><p id="cbcf" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">虽然polar与pandas相似，并且支持大多数功能，但它仍然在努力，我们需要将polar数据框转换为pandas。Polars提供了一个简单的函数to_pandas()，允许用户将极坐标数据框转换为pandas。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="e41a" class="lk if hh lg b fi ll lm l ln lo">pandas_df=data.to_pandas()<br/>type(pandas_df)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ly"><img src="../Images/3dc3d8a25b6e28e032a70fc051de9da5.png" data-original-src="https://miro.medium.com/v2/resize:fit:606/format:webp/0*8Fx1LGNKCteEV25N.png"/></div></figure><p id="5cb0" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">现在我们将看到一个简单的例子，我们如何将我们的数据帧转换成一个惰性帧来优化我们的性能。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es lz"><img src="../Images/5294f0b067a2c560e5255c8db0f92cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ji5AG_enTbEU_pLnoDK3Sw.png"/></div></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ma"><img src="../Images/34736c7a3d39a1f22ffae9ae08adea54.png" data-original-src="https://miro.medium.com/v2/resize:fit:766/format:webp/0*_okTr6DsDcAfUJgj.png"/></div></figure><p id="43da" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">正如我们可以看到的，我们的数据框已成功转换为惰性数据框，但它没有显示数据。现在，我将使用过滤器对lazy_df进行子集化，然后通过collect()请求结果。</p><pre class="ku kv kw kx fd lf lg lh li aw lj bi"><span id="8d5c" class="lk if hh lg b fi ll lm l ln lo">lazy_df = lazy_df.filter(col("Rain") &gt; (lit(120))) <br/>lazy_df.collect()</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mb"><img src="../Images/ae1470d17f507ff05e98473d7ef22170.png" data-original-src="https://miro.medium.com/v2/resize:fit:532/format:webp/0*kBClr16onSSMgWj3.png"/></div></figure><h1 id="1908" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">为什么是Polars？</h1><p id="0822" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">这是pypolars的一个小介绍，我试图帮助您理解这个库及其功能。请注意，当涉及到eager API时，该库的工作方式与pandas非常相似。用户不需要付出额外的努力来学习，它很容易使用。</p><p id="e1ef" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">此外，Polars与NumPy的ufunc功能的交互成本为零。这意味着，如果它不被Polars支持，我们可以使用NumPy，没有任何开销。</p><p id="ce87" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">此外，Polars是一个内存高效的库，创建克隆或切片非常经济，因为Polars支持的底层内存是不可变的。</p><p id="1020" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">lazy API使得polars更令人兴奋，因为当它涉及到更大的数据集时，时间和空间复杂性很重要。由于优化和懒惰的执行polars成为一个高效和低成本的选择。<a class="ae mc" href="https://github.com/ritchie46/polars/blob/master/examples/lazy_py-polars.ipynb" rel="noopener ugc nofollow" target="_blank">这里</a>可以看到polars的性能对比。</p><p id="c8d5" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">如果你想了解更多细节，我建议你查看polars的<a class="ae mc" href="https://github.com/ritchie46/polars" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="a55e" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结束注释</h1><p id="7daa" class="pw-post-body-paragraph jz ka hh je b jf jg kb kc jh ji kd ke jj kf kg kh jl ki kj kk jn kl km kn jp ha bi translated">Polars相对较新，不支持数据科学家所需的其他库。但另一方面，熊猫是一个成熟的玩家，拥有庞大的社区基础和高效的生态系统。目前还很难说它能成为熊猫的替代品。但毫无疑问，这是一个有趣的选择。</p><p id="3d12" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">总之，Polars是执行数据操作和分析的一个有趣的选项。如果你的数据集对熊猫来说太大，对spark来说又太小。Polars是一个高效的解决方案，因为它利用机器中所有可用的内核进行并行执行。</p><p id="5ef4" class="pw-post-body-paragraph jz ka hh je b jf ko kb kc jh kp kd ke jj kq kg kh jl kr kj kk jn ks km kn jp ha bi translated">请在评论区告诉我你对此的看法。</p></div></div>    
</body>
</html>