<html>
<head>
<title>Introduction To Autoencoders</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自动编码器简介</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-gentle-introduction-to-autoencoders-b456f407a337?source=collection_archive---------12-----------------------#2021-02-02">https://medium.com/analytics-vidhya/a-gentle-introduction-to-autoencoders-b456f407a337?source=collection_archive---------12-----------------------#2021-02-02</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="4dff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">定义:Autoencoder是一种无监督学习方法，它使用神经网络来学习任务。</p><p id="43b2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但仍然质疑到底什么是自动编码器，神经网络是如何用于无监督学习的？让我们在这里解决问题。</p><p id="8c76" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自动编码器模型包括三个部分，即:</p><ol class=""><li id="9e7d" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">编码器</li><li id="89c0" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">代码层</li><li id="0f7a" class="jc jd hh ig b ih jl il jm ip jn it jo ix jp jb jh ji jj jk bi translated">解码器</li></ol><figure class="jr js jt ju fd jv er es paragraph-image"><div class="er es jq"><img src="../Images/1cdd32297acd9bcc7584b4b9849215d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/0*Nn7ktbijkDNx4ms7"/></div><figcaption class="jy jz et er es ka kb bd b be z dx translated">自动编码器</figcaption></figure><p id="571d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">编码器接收图像，将其降级并以编码层的编码格式存储，然后由解码器解码。想象一下这样一种情况，我们使用一个具有较高内存值的图像，在给定的有限带宽内进行传输，这可能需要很长时间。将其编码成图像被转换成相对较小的存储器大小的格式，那么在这种情况下，时间和资源将逐渐减少。</p><p id="1593" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于在网络训练期间使用神经网络的无监督学习方法，我们给出相同的输入和目标数据，并使用该模式训练编码器、代码层和解码器，该模式在测试数据上充当无监督模型，其中解码器给出作为原始图像的输入编码图像作为输出。</p><p id="ae16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们来理解它背后的数学概述:</p><figure class="jr js jt ju fd jv er es paragraph-image"><div role="button" tabindex="0" class="kd ke di kf bf kg"><div class="er es kc"><img src="../Images/14cc32ce4bae459c0d7823aaee795cbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qoFCUJvfzIsb459_"/></div></div></figure><p id="cb79" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让输入层表示为‘X’，代码层(编码层)表示为‘f(X)’,输出层表示为‘g(f(X))。输入层和输出层的尺寸是相同的。</p><p id="86cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了从输入层到达编码层，对其应用非线性和线性函数的组合。函数“f(X)”可以表示为:f(X) = σ(wX + b)，其中w是权重，b是偏差。</p><p id="cb9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">类似地，为了从编码层到达输出层，应用线性和非线性函数的组合。为了让网络学习，需要损失函数。为此，主要使用两个损失函数:</p><ol class=""><li id="397a" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">二元交叉熵；</li></ol><p id="5425" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">方程:Z =-[∑x ln(g(f(x)))+(1-x)ln(1-g(f(x)))]/m</p><ol class=""><li id="b871" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">MSE(均方差):</li></ol><p id="cba0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">等式:Z = ∑(x-g(f(x)))/2m</p></div></div>    
</body>
</html>