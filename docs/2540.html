<html>
<head>
<title>Convolutional Neural Networks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">卷积神经网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/convolutional-neural-networks-4d1582a39714?source=collection_archive---------12-----------------------#2021-04-30">https://medium.com/analytics-vidhya/convolutional-neural-networks-4d1582a39714?source=collection_archive---------12-----------------------#2021-04-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="223e" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">深度学习专业化课程4(第一周笔记)</h2></div><p id="ea5c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">更新:</strong>如果你还没有看过我之前在其他三个深度学习专业化课程笔记上的文章，那么请务必查看系列:<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-353c997af655">第一条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-df3938c3234c">第二条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-d517a9d8db56">第三条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-notes-3cb2734ea36e">第四条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-notes-138ecd5ad4ef">第五条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-20c115b77d0e">第六条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-fd18ee60394">第七条</a>、<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-3-2e245684ffd">第八条</a>和<a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-3-bc467e3dd085">第九条</a><a class="ae js" rel="noopener" href="/analytics-vidhya/deep-learning-specialization-course-3-bc467e3dd085"/></p><p id="43c6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如今，深度学习被证明在一些领域非常有用，如自动驾驶汽车、医疗保健、物体检测、图像识别等。在图像识别领域中，当图像的尺寸较小时，具有少量隐藏单元的神经网络表现良好，但是如果图像的尺寸例如是1000*1000像素，则一个图像的输入特征变成1000*1000*3，即3百万，其中3表示RGB颜色编码。如果神经网络具有1000个隐藏单元，则权重参数矩阵W的形状将是(1000，3M)。但是对于计算机视觉应用来说，你不希望只使用微小的图像。你想要使用大的图像。为此，我们需要更好地实现卷积运算，这是卷积神经网络的基本构建模块之一。</p><h2 id="0aa2" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated"><strong class="ak">卷积运算示例</strong></h2><p id="f0b1" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">正如我们所知，神经网络的早期层可能检测垂直和水平边缘，然后一些后期层可能检测对象的部分，然后甚至后期层可能检测完整对象的部分，如人脸。</p><p id="31eb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要了解卷积神经网络是如何工作的，我们先来了解卷积运算。<br/>考虑下图所示的6 x 6矩阵，为了检测边缘，创建一个看起来像1，1，1，0，0，0，-1，-1的3 x 3矩阵。后一个矩阵被称为滤波器或内核。滤波器矩阵中的第一列表示高像素，即较亮的区域，最后一行表示低像素，即较暗的区域。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es kt"><img src="../Images/ee77c043331d8b0a7ff56c911565b3e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*QbTX9lFZh6BnG7LP5M6Jzg.png"/></div></figure><p id="694c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">星号用于表示卷积运算。在程序设计语言中，它也用来表示乘法或逐元素乘法运算。这两个矩阵之间的卷积将产生一个4 x 4的矩阵。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lb"><img src="../Images/d6190f01c0d086941993c5e915f0f0aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RfEgypsr9CPiO7v9Qte6xQ.png"/></div></div></figure><p id="f3ab" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">作为第一步，我们将把滤波器矩阵与我们的目标矩阵相结合，并执行逐元素乘法。如下图所示，3 * 1+1 * 1+2 * 1+0 * 0+5 * 0+7 * 0+1 *-1+8 *-1+2 *-1 =-5，并将最终值放入结果矩阵中。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lg"><img src="../Images/c35cc739f48a57359ffb6e6f0e2f362d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1FmebocCs6Bsq4gKI1PCBQ.png"/></div></div></figure><p id="18ce" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然后，滤波器矩阵将逐渐在水平方向上移动，并执行类似的乘法。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lh"><img src="../Images/47336f0d68ee020f342260d4a23d8564.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MKAcCtOcEok2W0mTUhXaTA.png"/></div></div></figure><p id="b931" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">完整的卷积运算将生成4 x 4矩阵。得到的矩阵将代表图像中的边缘。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es li"><img src="../Images/bfab3b9e0090dc5adc59da449ee68534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQ6FcQvP2bGwgCk5N-RbyA.png"/></div></div></figure><p id="a4fd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于我们采用了6 X 6矩阵，因此得到的矩阵并不能提供任何清晰度，但是当图像或输入特征具有更高的矩阵(如1000维)时，它确实有助于定义边缘。</p><p id="f21f" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们在滤波器矩阵上方旋转90度，我们也将能够检测水平边缘。不同的过滤器可以让你找到垂直和水平的边缘。事实证明，我们使用的3×3垂直边缘检测滤波器只是一种可能的选择。从历史上看，在计算机视觉文献中，有相当多的关于什么是最好的一组数字的争论。你还可以用其他的，可能是1，2，1，0，0，0，-1，-2，-1。这被称为索贝尔过滤器。这样做的好处是，它让中间部分更重了一点。滤波器的另一个例子是3，10，3，0，0，0，-3，-10，-3，这称为Scharr滤波器。这也有其他稍微不同的特性。我们不需要计算机视觉研究人员为3×3过滤器精心挑选这些数字，我们可以将这九个数字视为参数，并通过反向传播来学习它们。</p><h2 id="3f00" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">填料</h2><p id="a5c1" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">当我们有一个由f x f滤波器卷积的N x N图像时，输出滤波器的维数为n-f+1。这种方法有两个缺点。</p><ol class=""><li id="2f90" class="lj lk hh iy b iz ja jc jd jf ll jj lm jn ln jr lo lp lq lr bi translated">每次应用卷积运算符时，图像都会缩小。因此，每当应用卷积运算符时，我们都不希望图像缩小。</li><li id="27be" class="lj lk hh iy b iz ls jc lt jf lu jj lv jn lw jr lo lp lq lr bi translated">图像边缘的像素比中间的像素用得少。因此，边缘附近的大量有用信息有可能被浪费掉。</li></ol><p id="6043" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">要解决上述两个问题，我们可以在应用卷积图像之前填充图像。例如，如果我们用一个像素填充6 X 6图像，使其成为8 X 8图像，并应用卷积运算，则得到的图像将是保留原始图像的6 X 6图像。如果p是我们增加填充的像素数，那么得到的矩阵的维数变成；n+2p-f+1 * n+2p-f+1。</p><p id="5e35" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">就垫多少而言，有两种选择；有效卷积和相同卷积。有效的卷积意味着没有填充，相同的卷积意味着当我们填充时，输出矩阵的大小与输入矩阵的大小相同。可以使用f-1/2公式来选择填充大小，其中f是奇数滤波器。</p><h2 id="459d" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">交错回旋</h2><p id="cc72" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">在跨步卷积中，如果我们选择stride =2，我们可以跳过两个模块，同时执行卷积运算，而不是通常的方式，如下所示。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es lx"><img src="../Images/76ab1b96283a3df20456f5fb462751e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:980/format:webp/1*MQ8oLOSsZSUZ4b-asDg43A.png"/></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ly"><img src="../Images/a184c896d9c4e766b246d6eae6030dd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*eU6hdoqM47T22K9WmMG2Lg.png"/></div></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es lz"><img src="../Images/96e3dcf68260edaff0fdf4505357ceef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KA9hAvj8oEVg5u-AvXY8WQ.png"/></div></div></figure><p id="1f46" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输入和输出尺寸可由以下公式控制。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es ma"><img src="../Images/216d6a896b15e93aa853366c0f4df178.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*MzsKQ9FdxxUiCTaQUPjToA.png"/></div></figure><p id="18d5" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果得到的数字不是一个整数，那么我们可以向下舍入这个数字。</p><h2 id="45d5" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">体积上的卷积</h2><p id="f495" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">我们看到了如何对2D图像执行卷积运算。现在，我们将了解如何对3D图像执行卷积运算。在这种情况下，我们将有一个第三维的图像，这将代表RGB颜色通道。需要记住的一点是，图像的第三个维度和滤镜是一样的。如果只使用一个滤波器，输出矩阵将是2D。</p><p id="1a74" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iy hi">3D卷积层的符号概要:</strong></p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es mb"><img src="../Images/2132670edcb43452ce60877941084dbe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmt2s3JN9-dYlOeZGvcsng.png"/></div></div></figure><h2 id="15e7" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">池层</h2><p id="df53" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">假设我们有4 * 4的输入，我们希望将最大池应用于我们的输入，如下图所示。我们可以将区域分成不同的颜色，并从每个区域中获取最大数量。因此，最大拉伸背后的直觉是，如果我们将每个区域视为一组要素，那么每个区域的每个要素都会保留在输出中。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mc"><img src="../Images/71e4020ef3d2124e4ab15a7eafee7091.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*N0Kiz2op_KAXUVb7vLky1Q.png"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">最大池化</figcaption></figure><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es mh"><img src="../Images/cb685734f41fbd5c08f11718fb0d28bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1068/format:webp/1*cE0JboMqi303Yg8w42iZSA.png"/></div><figcaption class="md me et er es mf mg bd b be z dx translated">平均池</figcaption></figure><h2 id="bd83" class="jt ju hh bd jv jw jx jy jz ka kb kc kd jf ke kf kg jj kh ki kj jn kk kl km kn bi translated">完整的卷积神经网络示例</h2><p id="048f" class="pw-post-body-paragraph iw ix hh iy b iz ko ii jb jc kp il je jf kq jh ji jj kr jl jm jn ks jp jq jr ha bi translated">在以下示例中，图像的输入尺寸为32 * 32 * 7。卷积和池层被视为一个层，因为池层没有自己的参数。在卷积和合并图层后，输入矢量被展平为(400，1)矢量。然后，按照softmax算法在最后一层应用完全连接的层。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="er es mi"><img src="../Images/b2d54bcd29b6cc64287e22c1b59209a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fobj5WDAAZjgNFtutUNyKg.png"/></div></div></figure><p id="9215" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在卷积神经网络的端到端示例中，我们来到了一周的末尾。敬请关注下周的笔记。</p><p id="ffbb" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">快乐学习:)</p></div></div>    
</body>
</html>