<html>
<head>
<title>Hybrid Recommendation System Web-Application Part 1: Exploratory Data Analysis with PostgreSQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">混合推荐系统Web应用第1部分:使用PostgreSQL的探索性数据分析</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/hybrid-recommendation-system-web-application-part-1-exploratory-data-analysis-with-postgresql-642ed890c06b?source=collection_archive---------4-----------------------#2021-05-24">https://medium.com/analytics-vidhya/hybrid-recommendation-system-web-application-part-1-exploratory-data-analysis-with-postgresql-642ed890c06b?source=collection_archive---------4-----------------------#2021-05-24</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="c803" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">本文是端到端机器学习项目系列的一部分，其中我将从头开始为基于回归的电影推荐系统构建一个web应用程序，该系统是基于内容和协作过滤算法的混合。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/cab86dca43e76eb75ee023c329a03ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*3AEl78SYVQ3K7P1C5O0EFw.jpeg"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">丹尼斯·简斯在<a class="ae jo" href="https://unsplash.com/s/photos/movies?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>拍摄的照片</figcaption></figure><h1 id="b067" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">介绍</h1><p id="a077" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在过去的二十年里，推荐系统已经成为最先进的算法，可以被视为谷歌、亚马逊和网飞等公司的成功因素。推荐系统的主要目的是向一组用户提供他们可能感兴趣的相关推荐。本文是端到端机器学习项目系列的一部分，其中我将从头开始为基于回归的电影推荐系统构建一个web应用程序，该系统是基于内容和协作过滤算法的混合。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/9f4bf8afbf37a1a7132cc4e3ffec7c5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUz4iEdPJVB6qtx5LG_izQ.jpeg"/></div></div></figure><p id="c341" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列的这一部分中，我将使用PostgreSQL执行探索性的数据分析。我在这个项目中使用PostgreSQL for EDA的唯一原因是，大多数申请任何数据角色的新手都应该有在口袋中使用SQL的经验，在EDA中使用SQL可以让您至少演示一下，使用PostgreSQL for EDA还可以让您了解关系数据库是如何工作的，数据是如何存储的，更重要的是如何从数据库中获取数据。SQL是一种非常灵活的声明性语言，可以用来提出一组丰富的查询，以从数据库中获取数据。我将使用SQL查询进行数据操作，用于当今几乎每一种图形EDA技术，以及一些主要用于可视化的其他python库。</p><p id="1fc9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你对这个项目感兴趣，我的<a class="ae jo" href="https://github.com/SyedMuhammadHamza/Hybrid-recommendation-system-web-application" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi"> Github </strong> </a> <strong class="ig hi"> </strong>上有关于这个项目的所有详细描述代码。</p><p id="6df8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">web应用程序部署在Heroku上，将在本系列的后半部分讨论，但是如果您想知道最终产品的外观，请随意浏览下面的链接。</p><div class="kx ky ez fb kz la"><a href="https://smhxrecommendersystemapp.herokuapp.com/" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hi fi z dy lf ea eb lg ed ef hg bi translated">电影推荐系统</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">赛义德·穆罕默德·哈姆扎双击此处获取说明说明1)请考虑对至少二十种不同的…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">smhxrecommendersystemapp.herokuapp.com</p></div></div></div></a></div><p id="f5cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">注意:</strong>熟悉SQL(连接、子查询、视图等。)是这部分系列的前提。如果您不熟悉SQL，可以完全跳过本文，从下一部分开始，因为这是本系列中唯一涉及EDA的SQL和PostgreSQL的部分，并且不是下一部分的先决条件。</p><h1 id="4358" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">带有ODBC的PostgreSQL数据库</h1><p id="74ec" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated"><strong class="ig hi"> PostgreSQL </strong>是一个强大的开源对象关系数据库系统，为了与我的PostgreSQL数据库服务器建立连接，我将使用ODBC(开放式数据库连接),这是一个标准，它规定如果你通过这个协议写入这个标准API，那么你就可以使用ODBC，它实现了DBMS的独立性。ODBC驱动程序可以被认为类似于打印机驱动程序或其他驱动程序，为应用程序提供一组标准的函数。所有主要的DBMS都有驱动程序，如Oracle、PostgreSQL、MySQL和Microsoft SQL Server，但是在python代码中使用它之前，您必须手动安装您选择的DBMS并配置其驱动程序。</p><p id="0194" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用ODBC设置和访问PostgreSQL】</strong></p><p id="adda" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第一步</strong>:从这里安装PostgreSQL</p><div class="kx ky ez fb kz la"><a href="https://www.postgresql.org/" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hi fi z dy lf ea eb lg ed ef hg bi translated">一种数据库系统</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">PostgreSQL是一个强大的开源对象关系数据库系统，经过30多年的积极开发…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">www.postgresql.org</p></div></div><div class="lj l"><div class="lk l ll lm ln lj lo ji la"/></div></div></a></div><p id="1ae2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">步骤2 </strong>:下一步是设置ODBC(开放式数据库连接),遵循以下链接中指定的步骤</p><p id="a54d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">[注意]:跳过(连接到PostgreSQL服务器[ <a class="ae jo" href="https://help.interfaceware.com/v6/connect-to-postgresql-from-windows-with-odbc#" rel="noopener ugc nofollow" target="_blank"> top </a> ])并从Setup ODBC [ <a class="ae jo" href="https://help.interfaceware.com/v6/connect-to-postgresql-from-windows-with-odbc#" rel="noopener ugc nofollow" target="_blank"> top </a> ]开始</p><div class="kx ky ez fb kz la"><a href="https://help.interfaceware.com/v6/connect-to-postgresql-from-windows-with-odbc" rel="noopener  ugc nofollow" target="_blank"><div class="lb ab dw"><div class="lc ab ld cl cj le"><h2 class="bd hi fi z dy lf ea eb lg ed ef hg bi translated">使用ODBC从Windows连接到PostgreSQL界面软件帮助中心</h2><div class="lh l"><h3 class="bd b fi z dy lf ea eb lg ed ef dx translated">本文解释了如何使用官方PostgreSQL ODBC驱动程序psqlodbc连接到PostgreSQL，当使用…</h3></div><div class="li l"><p class="bd b fp z dy lf ea eb lg ed ef dx translated">help.interfaceware.com</p></div></div><div class="lj l"><div class="lp l ll lm ln lj lo ji la"/></div></div></a></div><p id="4392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">第三步</strong>:打开第一步安装了PostgreSQL的SQL Shell，执行以下语句</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="05ec" class="lv jq hh lr b fi lw lx l ly lz">CREATE DATABASE DRecommenderSystem_db;</span></pre><p id="b3b1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我将在名为PostgreSQL_Database_wrapper.py的Python文件中为PostgreSQL定义一个名为PostgreSQLconnection的帮助器类，这将节省我大量的时间，因为我已经为每个模块包含了docstrings，<strong class="ig hi">请在继续之前阅读一下</strong>此处的。</p><h1 id="f36c" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">使用PostgreSQL进行探索性数据分析</h1><h2 id="d460" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated"><strong class="ak">数据集:</strong></h2><p id="ce59" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">数据集由<a class="ae jo" href="https://grouplens.org/about/what-is-grouplens/" rel="noopener ugc nofollow" target="_blank"> GroupLens </a>提供，可以从这里<a class="ae jo" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank">下载</a>它包含以下文件(links.csv、movies.csv、ratings.csv和tags.csv)</p><blockquote class="mn mo mp"><p id="8da4" class="ie if mq ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated"><em class="hh">“该数据集(ml-latest-small)描述了来自电影推荐服务MovieLens的五星评级和自由文本标记活动。它包含9742部电影的100836个评级和3683个标签应用。这些数据由610名用户在1996年3月29日至2018年9月24日之间创建。这个数据集是2018年9月26日生成的。”</em></p></blockquote><h2 id="349e" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">正在加载数据集</h2><p id="45c9" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">导入库</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="6b92" class="lv jq hh lr b fi lw lx l ly lz"><strong class="lr hi">import</strong> <strong class="lr hi">pandas</strong> <strong class="lr hi">as</strong> <strong class="lr hi">pd</strong><br/><strong class="lr hi">import</strong> <strong class="lr hi">numpy</strong> <strong class="lr hi">as</strong> <strong class="lr hi">np</strong><br/><strong class="lr hi">import</strong> <strong class="lr hi">seaborn</strong> <strong class="lr hi">as</strong> <strong class="lr hi">sns</strong><br/><strong class="lr hi">import</strong> <strong class="lr hi">matplotlib.pyplot</strong> <strong class="lr hi">as</strong> <strong class="lr hi">plt</strong></span><span id="702c" class="lv jq hh lr b fi mu lx l ly lz">#Loading data from csv files into pandas dataframes</span><span id="4002" class="lv jq hh lr b fi mu lx l ly lz"><strong class="lr hi">moviesData=pd.read_csv(r'ml-latest-small\movies.csv')<br/>ratingsData=pd.read_csv(r'ml-latest-small\ratings.csv')<br/>linksData=pd.read_csv(r'ml-latest-small\links.csv')<br/>tagsData=pd.read_csv(r'ml-latest-small\tags.csv')</strong></span><span id="cd05" class="lv jq hh lr b fi mu lx l ly lz"><em class="mq">'''<br/>I have one column named Timestamp in my RatingData dataframe I've to rename it to something else before inserting data into SQL tables because the timestamp is a data type in SQL<br/>'''</em></span><span id="ba69" class="lv jq hh lr b fi mu lx l ly lz"><strong class="lr hi">ratingsData['timestamp'] = pd.to_datetime(ratingsData['timestamp'], unit='s')<br/>ratingsData.columns = ['userId', 'movieId','rating' ,'timing']</strong></span></pre><h2 id="c492" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">在PostgreSQL中创建表</h2><p id="0b41" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我已经将我的四个CSV数据文件加载到pandas数据框中，下一步是建立到PostgreSQL数据库的连接，为每个数据框创建表，并将数据插入其中。</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="fcd2" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">'''<br/>importing PostgreSQLconnection class from my PostgreSQL_Database_wrapper file and creating an instance of it<br/>'''<br/></em><strong class="lr hi">from PostgreSQL_Database_wrapper import PostgreSQLconnection<br/>db=PostgreSQLconnection("DRecommenderSystem_db","postgres","*********","localhost")</strong></span></pre><p id="0a13" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MovieLens数据集由四个[。csv]文件，即(<code class="du mv mw mx lr b">links.csv</code>、<code class="du mv mw mx lr b">movies.csv</code>、<code class="du mv mw mx lr b">ratings.csv</code>和<code class="du mv mw mx lr b">tags.csv</code>)我已经将这些文件加载到熊猫的数据帧中。现在，我将使用SQL创建表，并通过调用PostgreSQL_Database_wrapper.py中定义的PostgreSQL connection . create _ table()并将SQL语句作为参数传递给它，从这些表中的这些数据帧加载数据。</p><p id="e352" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里我有四个表，都有<strong class="ig hi">主键约束</strong></p><blockquote class="mn mo mp"><p id="9a5e" class="ie if mq ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated">外键约束通过将包含外键的子表中的一列或一组列引用到父表中的主键列或一组列来标识数据库表之间的关系。</p></blockquote><p id="4e83" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">和外键约束。</strong></p><blockquote class="mn mo mp"><p id="85a0" class="ie if mq ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated">PRIMARY KEY约束唯一标识表中的每条记录。</p></blockquote><p id="a944" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最重要的是，在查看数据框中的数据后，我注意到我的数据不在<strong class="ig hi">第一范式(1NF) </strong>中</p><blockquote class="mn mo mp"><p id="a312" class="ie if mq ig b ih ii ij ik il im in io mr iq ir is ms iu iv iw mt iy iz ja jb ha bi translated">第一范式(1NF)是关系数据库中关系的属性。当且仅当每个属性的定义域只包含原子时，关系才是第一范式。</p></blockquote><p id="aba5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这意味着每个属性/字段/列应该只包含一个值，因此一个字段实例中的值列表违反了1NF格式，我有两个有问题的表。第一个是具有属性/字段/列的标记“tag ”,在一个字段的实例中包含多个值。类似地，在表“MovieData”的情况下，我有属性/字段/列“generes ”,在一个字段的实例中包含多个值。通常，当设计DBMS的模式时，您必须确保您的数据在1NF中，这将始终保持正确。如果您在概念设计中遵循标准的ER图，ER-model在字段/属性中实施原子性，在逻辑设计的下一阶段，您将ER-Model转换为数据模型(最有可能是关系模型现在回到我的问题，我将做一些愚蠢的事情，假设像“generes”和“tag”这样的字段中的值是一个很长的原子字符串，因为我不会创建任何关键的重要应用程序来使用这个数据库并强制执行要遵循的标准，如果是这样的话，我将首先为每个非原子字段进行一次热编码，这将扩展列/字段的数量。</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="7b45" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#sql statement to create table</em><br/>sqlstatement='''CREATE TABLE Movies(<br/>              movieId INT,<br/>              title text,<br/>              genres text,<br/>              PRIMARY KEY(movieId)<br/>              )'''<br/>db.create_table(sqlstatement, ' Movies')<br/><em class="mq">#sql statement to create table</em><br/>sqlstatement='''CREATE TABLE Rating(<br/>              userId INT,<br/>              movieId INT,<br/>              rating REAL,<br/>              timing TIMESTAMP,<br/>              PRIMARY KEY(movieId,userId),<br/>              FOREIGN KEY(movieId) <br/>                  REFERENCES Movies(movieId)<br/>              )'''<br/>db.create_table(sqlstatement, ' Ratings')<br/><em class="mq">#sql statement to create table</em><br/>sqlstatement='''CREATE TABLE Links(<br/>              movieId INT,<br/>              imdbId INT,<br/>              tmdbId REAL,<br/>              PRIMARY KEY(movieId)<br/>              )'''<br/>db.create_table(sqlstatement, ' Links')<br/><em class="mq">#sql statement to create table</em><br/>sqlstatement='''CREATE TABLE Tags(<br/>              userId INT,<br/>              movieId INT,<br/>              tag text,<br/>              PRIMARY KEY(movieId,userId),<br/>              FOREIGN KEY(movieId) <br/>                  REFERENCES Links(movieId)<br/>              )'''<br/>db.create_table(sqlstatement, ' Tags')</span></pre><p id="9f58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是作为上述代码电影，评级，链接和标签的结果，在数据库中创建的表格</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es my"><img src="../Images/5a62677a7a5e9649a5f85d2258b5d61b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgB4yLxXAwhDfJgzRS9ZGw.jpeg"/></div></div></figure><p id="1475" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从我的ER图中可以看出，我有四个实体，每个表一个，还有它们的主键和外键，为了演示关系，我使用了crowfoot符号。</p><h2 id="6468" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">将数据从数据帧加载到表中</h2><p id="5b32" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">创建表后，现在我必须将数据框中的数据加载到表中</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="3a04" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">'''</em><br/><em class="mq">Accessing cursor attribute of PostgreSQLconnection object that itself holds an object of the cursor then using it to insert data</em><br/><em class="mq">into my tables(it's a bad practice to access any attribute from outside of your class it violates encapsulation and information</em><br/><em class="mq">hiding, unfortunately, there is no way to enforce information hiding in python that's why hacks like this one will work but make</em><br/><em class="mq">sure whenever you define your classes they are as loosely coupled as possible always follow SOLID principles) tbh I forgot to </em><br/><em class="mq">implement insert_data method in PostgreSQLconnection class that's the reason I'm accessing it from outside </em></span><span id="5cdb" class="lv jq hh lr b fi mu lx l ly lz"><em class="mq">'''</em></span><span id="4d48" class="lv jq hh lr b fi mu lx l ly lz">cursor = db.cursor<br/><strong class="lr hi">for</strong> row <strong class="lr hi">in</strong> moviesData.itertuples():<br/>    cursor.execute('''<br/>                        INSERT INTO Movies(movieId,title,genres)<br/>                        VALUES (?,?,?)<br/>                        ''',<br/>                        row.movieId,<br/>                        row.title,<br/>                        row.genres<br/>                  )<br/>db.db_connection.commit()<br/>print("successfully inserted data from DataFrame into table")<br/><strong class="lr hi">for</strong> row <strong class="lr hi">in</strong> ratingsData.itertuples():<br/>    cursor.execute('''<br/>                        INSERT INTO Rating(userId,movieId,rating,timing)<br/>                        VALUES (?,?,?,?)<br/>                        ''',<br/>                        row.userId,<br/>                        row.movieId,<br/>                        row.rating,<br/>                        row.timing<br/>                  )<br/>db.db_connection.commit()<br/>print("successfully inserted data from DataFrame into table")<br/><strong class="lr hi">for</strong> row <strong class="lr hi">in</strong> linksData.itertuples():<br/>    cursor.execute('''<br/>                        INSERT INTO Links(movieId,imdbId,tmdbId)<br/>                        VALUES (?,?,?)<br/>                        ''',<br/>                        row.movieId,<br/>                        row.imdbId,<br/>                        row.tmdbId<br/>                  )<br/>db.db_connection.commit()<br/>print("successfully inserted data from DataFrame into table")<br/><strong class="lr hi">for</strong> row <strong class="lr hi">in</strong> tagsData.itertuples():<br/>    cursor.execute('''<br/>                        INSERT INTO Tags(userId,movieId,tag)<br/>                        VALUES (?,?,?)<br/>                        ''',<br/>                        row.userId,<br/>                        row.movieId,<br/>                        row.tag<br/>                  )<br/>db.db_connection.commit()<br/>print("successfully inserted data from DataFrame into table")</span></pre><p id="38be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我为EDA做好了一切准备。通过使用sql查询的EDA可以比在Pandas数据帧上更灵活，但要小心，它可能是一把双刃剑，因为它不是很有效这是我在这里使用PostgreSQL的唯一原因，因为大多数申请任何数据角色的新手都应该有一些关于SQL的经验，在EDA中使用SQL可以让你证明这一点，尽管如此，你可以在用于EDA的Postgresql数据库中提出灵活的查询是惊人的。</p><h2 id="7699" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">十大分级电影</h2><p id="3df2" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">在这里，我将分级和电影表连接起来，然后创建名为“MoviesWithRatings”的视图，并对该视图执行查询MoviesWithRating以提取排名前十的电影，然后绘制图表</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="fece" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#taking Join of tables(Rating and movies) then creating View(MoviesWithRatings) of result</em><br/>command ='''<br/>CREATE VIEW MoviesWithRatings AS<br/>    SELECT Rating.userId,Rating.movieId,Rating.rating,Movies.title<br/>    FROM Rating<br/>    LEFT JOIN Movies<br/>    ON Rating.movieId = Movies.movieId;<br/>'''<br/>db.run_command(command)</span><span id="44ea" class="lv jq hh lr b fi mu lx l ly lz"><em class="mq">#executing query over view </em><br/>query = '''<br/>SELECT title, count(movieid) AS movies_count<br/>FROM MoviesWithRatings<br/>GROUP BY title,movieid<br/>ORDER BY movies_count DESC<br/>LIMIT 10;<br/>'''<br/>query_result=db.run_query(query)</span><span id="8a54" class="lv jq hh lr b fi mu lx l ly lz">plt.figure(figsize=(15, 8)) barh = plt.barh(query_result['title'], query_result['movies_count'], color='blue') plt.title(' top ten most rated movies ') plt.xticks(np.arange(0, 400, 50)) plt.tight_layout()</span></pre><p id="bfe8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mz"><img src="../Images/6f4e177225bb3c98d4b27321c730765b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*38uiSQAuO601krpogpZcPg.png"/></div></div></figure><p id="21c2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>天哪！结果与你在腐烂的西红柿和IMDb上发现的非常相似。事实上，这些都是有史以来最伟大的电影，因为各种原因而经久不衰——它们提供了曲折的情节，给我们带来了我们爱上的角色，描绘了改变我们的经历，并以令人难以置信的电影制作工艺让我们兴奋不已，但最重要的是，这个结果验证了我从MovieLens获得的小数据集具有足够的代表性，可以用于培训。</p><h2 id="d609" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">导演中最受欢迎的类型</h2><p id="b808" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">现在，我对每种类型提出查询，以计算包含该类型的电影的数量，作为“generes”字段/属性/列中的子字符串，并将结果附加到一个列表中，供以后用于绘制它</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="a87b" class="lv jq hh lr b fi lw lx l ly lz"># extracting all unique genres from string field genres <br/>genres_unique = pd.DataFrame(moviesData.genres.str.split('|').tolist()).stack().unique()<br/>genres_list=genres_unique[:len(genres_unique)-1]<br/>genres_count=[]</span><span id="6611" class="lv jq hh lr b fi mu lx l ly lz">#QUERY<br/><strong class="lr hi">for</strong> genre <strong class="lr hi">in</strong> genres_list:<br/>    query = '''<br/>    SELECT count(Movies.movieId) <br/>    FROM  Movies<br/>    where Movies.genres LIKE '%'''+genre+'''%'<br/>    '''<br/>    query_result=db.run_query(query)<br/>    genres_count.append(query_result.iloc[0]['count'])</span><span id="4c19" class="lv jq hh lr b fi mu lx l ly lz">data=pd.DataFrame({'x': genres_list, 'y': genres_count})<br/>data=pd.DataFrame({'x': genres_list, 'y': genres_count})<br/>plt.subplots(figsize=(10,5))<br/>sns.barplot(x=data.x, y=data.y, palette="rocket")<br/>plt.xticks(rotation=-45)<br/>plt.title('Most popular genres among directors');</span></pre><p id="2010" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es na"><img src="../Images/66fe7f9ee622dc192c50adf5f2b1d31d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*x0ut3wWbZSHOmK7VPmrnjA.png"/></div></figure><p id="000b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>导演们似乎用“戏剧”这种类型来导演电影，这最有意义，因为所有其他类型都需要一个像样的预算，导演中接下来最受欢迎的两种类型是“喜剧”和“惊悚片”，同样的推理也适用于这两种类型，但鉴于<strong class="ig hi">相关性不是因果关系</strong></p><h2 id="9903" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">每年的评级数量</h2><p id="7b27" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">让我们继续，现在试着检查每年收视率的增长情况，我预计会呈指数增长，因为每天加入互联网的用户数量呈指数增长，在这种情况下<strong class="ig hi">相关性</strong>是<strong class="ig hi">因果关系</strong></p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="b89f" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#executing Nested query over table rating</em><br/>query = '''<br/>SELECT year,count(year)<br/>FROM( SELECT rating.movieId,EXTRACT(year FROM rating.timing) AS year<br/>      FROM rating) AS derivedTable<br/>GROUP BY year<br/>ORDER BY year DESC;<br/><br/>'''<br/>query_result=db.run_query(query)</span><span id="a300" class="lv jq hh lr b fi mu lx l ly lz">plt.subplots(figsize=(10,5))<br/>plt.plot(query_result)<br/><br/>plt.grid(<strong class="lr hi">True</strong>)<br/>plt.title('Number of ratings each year');</span></pre><p id="5685" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nb"><img src="../Images/9af53af5ed01993cc5c1e629ebc5b28f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1222/format:webp/1*rhBC-WL1RclSw_B9rKUquA.png"/></div></figure><p id="fbc7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>哼！鉴于每天全世界越来越多的人加入互联网，我期待收视率每年呈指数级增长！哪里出了问题？这个结果表明，这个小的MovieLens数据集是精选的，这就是为什么它不能充分反映真实数据，而且这个小数据集只有1 MB，这就是为什么我使用这个265 MB的<a class="ae jo" href="https://files.grouplens.org/datasets/movielens/ml-latest.zip" rel="noopener ugc nofollow" target="_blank">数据集</a>来训练部署的模型。</p><h2 id="78af" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">评级分布</h2><p id="2097" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">让我们探索一下</p><p id="83e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(1)用户如何基于流派对电影进行评级，数据集中有多少不同的流派，它们是如何分布的？</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="f656" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#executing query over rating table</em><br/>query = '''<br/>SELECT rating<br/>FROM Rating<br/>'''<br/>rating_result=db.run_query(query)<br/>rating_result.hist(bins=9, grid=<strong class="lr hi">False</strong>, edgecolor='w',density = <strong class="lr hi">True</strong>, label ='All genres', figsize=(10,5))<br/><em class="mq">#extracting out all genre from moviesData using pandas</em><br/>genres_unique = pd.DataFrame(moviesData.genres.str.split('|').tolist()).stack().unique()<br/>genres_list=genres_unique[:len(genres_unique)-1]<br/><em class="mq">#executing Nested queries within looping structure over table join of rating and movies and doing string comparision for each genre</em><br/><strong class="lr hi">for</strong> genre <strong class="lr hi">in</strong> genres_list:<br/>    query = '''<br/>    SELECT rating<br/>    FROM(SELECT Rating.userId, Rating.movieId, Rating.rating, Movies.genres<br/>         FROM Rating<br/>         LEFT JOIN Movies<br/>         ON Rating.movieId=Movies.movieId) AS derivedTable<br/>    WHERE genres LIKE '%'''+genre+'''%'<br/>    '''<br/>    query_result=db.run_query(query)<br/>    query_result.rating.plot(grid=<strong class="lr hi">False</strong>,  kind='kde', label=genre,figsize=(10,5))<br/>plt.legend(loc=(1.05,0), ncol=2)<br/>plt.xlim(0,5)<br/>plt.xlabel('Movie rating')<br/>plt.title('Movie rating histograms')<br/>plt.show()</span></pre><p id="ae3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es nc"><img src="../Images/c9f20549b6d16ba060994eb34489e0c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lp4bZm34p3gMhnlYQZp5uQ.png"/></div></div></figure><p id="1ff7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>查看每种类型的评分分布，似乎它们都有一个非常相似的分布，有点偏右，平均值约为3.5，这是正常的，因为3-5之间的评分是用户在给电影评分时的首选。</p><h2 id="7050" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">时间序列分析</h2><p id="9e64" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">我的数据中的时间戳类型允许使用时间序列分析进一步探索我的数据，时间序列分析是一种强大的技术，它可以通过将数据分解为不同的循环趋势来帮助我理解我的数据中的各种时间模式。</p><p id="c8a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑到过去发生的事情，时间序列分析还可以让我预测一个变量的水平在未来将如何变化。有时，时间序列分析也有助于在特征工程中提出一组更好的特征。</p><h2 id="ff57" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated"><strong class="ak">每周电影评分趋势</strong></h2><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="d26c" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#from pandas.tools.plotting import andrews_curves</em><br/>genres_list=genres_list[:5]<br/>plt.figure()<br/><em class="mq">#executing Nested queries within looping structure over table join of rating and movies and doing string comparision for each genre</em><br/><strong class="lr hi">for</strong> genre <strong class="lr hi">in</strong> genres_list:<br/>    query = '''<br/>    SELECT rating,timing<br/>    FROM(SELECT Rating.userId, Rating.movieId, Rating.rating, Movies.genres,Rating.timing<br/>         FROM Rating<br/>         LEFT JOIN Movies<br/>         ON Rating.movieId=Movies.movieId) AS derivedTable<br/>    WHERE genres LIKE '%'''+genre+'''%'<br/>    ORDER BY timing DESC<br/>    '''<br/>    query_result=db.run_query(query)<br/>    query_result['timing']=pd.to_datetime(query_result['timing'])<br/>    query_result.set_index('timing', inplace=<strong class="lr hi">True</strong>)<br/>    query_result.resample("W").mean().plot(marker="o", markersize=1,figsize=(20,5))<br/>    plt.title(genre+' Movie rating trends by week')</span></pre><p id="545f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><div class="jd je jf jg fd ab cb"><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/8a948a99b90db93d1fc6276d3bc0a946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*RkLvAtld-hF0yqcPRaOVlQ.png"/></div></figure><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/5c0d6ca0aba17987df7159bd1b5431c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*gab7csH9g-nfN-Uo5layHg.png"/></div></figure></div><div class="ab cb"><figure class="nd jh nj nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/07187c0913a0102e7ac10983f1d2e94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1006/format:webp/1*77q-sfKRo-bL-nlB9JZbnQ.png"/></div></figure><figure class="nd jh nk nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/eef62260ca08f635f261166495866329.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*Kk_vHJ0H-tNF2Mqm1QO4Eg.png"/></div></figure></div><p id="8b87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>当以周为基础重新取样时，电影分级中没有周趋势，它是每个流派的随机循环时间序列。</p><h2 id="52b7" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated">电影分级趋势(按年份)</h2><p id="52de" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">让我们重新取样，看看我的电影收视率是否有年度趋势</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="8b19" class="lv jq hh lr b fi lw lx l ly lz">genres_list=genres_list[:5]<br/>plt.figure()<br/><em class="mq">#executing Nested queries within looping structure over table join of rating and movies and doing string comparision for each genre</em><br/><strong class="lr hi">for</strong> genre <strong class="lr hi">in</strong> genres_list:<br/>    query = '''<br/>    SELECT rating,timing<br/>    FROM(SELECT Rating.userId, Rating.movieId, Rating.rating, Movies.genres,Rating.timing<br/>         FROM Rating<br/>         LEFT JOIN Movies<br/>         ON Rating.movieId=Movies.movieId) AS derivedTable<br/>    WHERE genres LIKE '%'''+genre+'''%'<br/>    ORDER BY timing DESC<br/>    '''<br/>    query_result=db.run_query(query)<br/>    query_result['timing']=pd.to_datetime(query_result['timing'])<br/>    query_result.set_index('timing', inplace=<strong class="lr hi">True</strong>)<br/>    query_result.resample("AS").mean().plot(marker="o", markersize=1,figsize=(20,5))<br/>    plt.title(genre+' Movie rating trends by yearly')</span></pre><p id="cf32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><div class="jd je jf jg fd ab cb"><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/6794f08865511fec6055f9cfa31bed40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*fTwLlUs1fykU6ce5_LEtrA.png"/></div></figure><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/b02c36e37d81850da6f0bfad9746fe58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*73A9Slq5zkbOPITIE-Nxtg.png"/></div></figure></div><div class="ab cb"><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/32774cc68ba0bb8402bc70a9f4e49685.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*7thJaCXrF6oyELbcCSdZIg.png"/></div></figure><figure class="nd jh ne nf ng nh ni paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/107b6cab5a96fab5222eff1fb17f304f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*aDL0Jycf6KoDSRVL8niOtw.png"/></div></figure></div><p id="0fe6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>这是一个有趣的现象，当每年重新取样时，电影收视率没有年度趋势，结果是一个随机循环的时间序列<strong class="ig hi">，但是</strong>如果你的目标是预测，你可以根据其他类型预测任何类型，因为它们都高度相关，可以一起建模。</p><h2 id="41bb" class="lv jq hh bd jr ma mb mc jv md me mf jz ip mg mh kd it mi mj kh ix mk ml kl mm bi translated"><strong class="ak">电影分级分布</strong></h2><p id="5747" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">最后，让我们快速浏览一下电影的收视率分布</p><pre class="jd je jf jg fd lq lr ls lt aw lu bi"><span id="06c1" class="lv jq hh lr b fi lw lx l ly lz"><em class="mq">#executing query over rating table</em><br/>query = '''<br/>SELECT rating, count(rating)<br/>FROM Rating<br/>GROUP BY rating<br/>ORDER BY rating<br/>'''<br/>rating_result=db.run_query(query)<br/>y = np.array(rating_result['count'])<br/>mylabels = rating_result['rating']<br/>explode =[0.3,0.1,0.1,0.1,0.1,0.1,0.2,0.1,0.1,0.1]<br/>textprops = {"fontsize":15} <em class="mq"># Font size of text in pie chart</em><br/>plt.pie(y, labels = mylabels,explode = explode,shadow = <strong class="lr hi">True</strong>,radius = 3,textprops =textprops)<br/>plt.legend(title = "Rating",loc="lower left")<br/>plt.title("Rating distribution for the Movies",fontsize=15)<br/>plt.show()</span></pre><p id="79f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出看起来像这样，</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es nl"><img src="../Images/b4296a3621c2d8d23afc5434cc9f620d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*3N_7o4XW7wZXIGIrmORsUQ.png"/></div></figure><p id="b65b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">观察:</strong>看看评分分布，很容易推断出人们很少给0.5-1.5窗口的电影评分，尽管在用户中给电影评分在3.0-4.0之间是非常普遍的</p><h1 id="1d75" class="jp jq hh bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km bi translated">结论</h1><p id="140c" class="pw-post-body-paragraph ie if hh ig b ih kn ij ik il ko in io ip kp ir is it kq iv iw ix kr iz ja jb ha bi translated">今天，在这个系列的这一部分中，我已经执行了EDA，这是ML管道中最关键的步骤之一。EDA帮助您在做出任何假设之前更好地理解您的数据，它让您调查明显的错误，并更好地理解数据中的模式。</p><p id="015d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本系列的下一部分中，我们将探索混合推荐算法，并将仅使用NumPy和pandas从头开始实现它，本系列的后续部分将进一步探索特征工程、模型训练、模型评估和部署。</p><p id="b825" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mq">如果您有任何问题或顾虑，请联系我</em> <a class="ae jo" href="https://syedmuhammadhamza.github.io/Hamza_Portfolio/" rel="noopener ugc nofollow" target="_blank"> <em class="mq">这里</em> </a></p><p id="b342" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="mq">下次见……</em></p></div></div>    
</body>
</html>