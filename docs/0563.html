<html>
<head>
<title>Under the Hood of Flask-SQLAlchemy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">烧瓶罩下-SQLAlchemy</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/under-the-hood-of-flask-sqlalchemy-793f7b3f11c3?source=collection_archive---------2-----------------------#2021-01-22">https://medium.com/analytics-vidhya/under-the-hood-of-flask-sqlalchemy-793f7b3f11c3?source=collection_archive---------2-----------------------#2021-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4135" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">学习如何用几行代码自己重新创建这个流行的Flask扩展</p><p id="3d78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你有没有想过Flask-SQLAlchemy扩展是如何工作的？自己建立SQLAlchemy会有多难？今天，我们将深入探讨如何设置SQLAlchemy ORM以用于Flask应用程序。最后，您将有自己的Flask-SQLAlchemy版本可供使用！</p><p id="deb0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQLAlchemy的目的是为您的Flask应用程序提供一种与数据库通信的方法。虽然Flask和SQLAlchemy文档确实让我晕头转向了几天，但希望我能够将它分解成小块，以便您轻松地消化。为了解释SQLAlchemy的各个部分是如何工作的，我将使用一个Flask应用程序在电话上与它的好朋友数据库交谈的类比…</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/c6b779526785c840b15e7f8872f31cab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dBomMPuCGqPsOA_9"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><a class="ae jt" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Icons8团队</a>在<a class="ae jt" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><ul class=""><li id="99ae" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/session_api.html%23sqlalchemy.orm.session.sessionmaker&amp;sa=D&amp;ust=1611325253268000&amp;usg=AOvVaw2pNTrdsOq6xYWLM1CC1xKR" rel="noopener ugc nofollow" target="_blank"> sessionmaker </a></li></ul><p id="033d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">SQLAlchemy的sessionmaker对象是Flask用来调用数据库的电话——如果你愿意的话，它是“调用工厂”。当你初始化sessionmaker时，你把你希望它进行调用的配置传递给它，这样每次sessionmaker进行调用时，它的外观和行为都是一样的。例如，您可以设置创建会话时使用的“绑定”。bind本质上是告诉sessionmaker，当Flask告诉它“开始呼叫”时，应该呼叫哪个电话联系人，并且它将总是只呼叫那个联系人。</p><ul class=""><li id="2a3b" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/core/connections.html?highlight%3Dengine%23sqlalchemy.engine.Engine&amp;sa=D&amp;ust=1611325310752000&amp;usg=AOvVaw38xcWYMwvq6cBYOtK2sw3Q" rel="noopener ugc nofollow" target="_blank">发动机</a></li></ul><p id="f154" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在你能告诉你的会话制造者“电话”打电话给哪个联系人之前，你必须在所说的电话中创建一个联系人。设置SQLAlchemy引擎就像创建这个新的联系人。当您运行<code class="du kd ke kf kg b">sqlalchemy.create_engine(‘database_location’)</code>时，您传递您希望您的应用程序与之对话的数据库的位置字符串。</p><p id="82c2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦创建了引擎，就可以将sessionmaker bind设置为等于您的引擎，它将始终调用该引擎。</p><ul class=""><li id="2e94" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jt" href="https://docs.sqlalchemy.org/en/13/orm/session_api.html#sqlalchemy.orm.session.Session" rel="noopener ugc nofollow" target="_blank">时段</a></li></ul><p id="75b6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在我们的电话呼叫示例中，SQLAlchemy会话对象是呼叫本身。Flask使用sessionmaker对象进行调用/会话，然后使用它来查询数据库、添加新行、更新行、删除行等。</p><ul class=""><li id="d4f5" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated"><a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/contextual.html%23sqlalchemy.orm.scoping.scoped_session&amp;sa=D&amp;ust=1611325376667000&amp;usg=AOvVaw1zqyHl2o_gk_LykGHkIXIh" rel="noopener ugc nofollow" target="_blank">作用域_会话</a></li></ul><p id="9d12" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想象你住在一个有几部固定电话的房子里。你正在厨房里打电话，突然你妈妈决定去卧室接电话。她的电话和你的电话连接在同一个电话上。一旦所有人都挂断电话，通话就结束了，必须有人开始新的通话。座机是SQLAlchemy的scoped_session对象。scoped_session对象确保家中的每部电话都可以访问同一个呼叫，并且当每个人都按下“结束呼叫”时，呼叫被断开。当手机再次尝试拨打电话时，它会创建一个新的呼叫，而不是继续之前的呼叫。</p><p id="bbd3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在固定电话的例子中，通话的持续时间取决于房子里的人何时按下“开始通话”和“结束通话”在web应用程序的世界中，这类似于web服务器向您的web应用程序发出请求。当请求开始时，scoped_session对象应该使用sessionmaker对象创建一个可由Flask web应用程序中的所有模块访问的会话。Flask应用程序使用该会话对数据库进行任何必要的查询或更新。然后请求结束，scoped_session对象移除当前会话。当一个新的请求到来时，它会创建一个新的会话来处理这个请求。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="814d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这个类比能让您对使用SQLAlchemy创建数据库连接时的工作原理有一个好的理解。现在让我们把它写成代码。</p><p id="81fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.首先，让我们创建一个名为“SQLAlchemy”的空类通过将SQLAlchemy连接设置为一个类，可以更容易地将各个部分导入到Flask应用程序的不同部分。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="71c5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.让我们创建__init__函数。这里我们唯一需要做的事情是告诉SQLAlchemy对象我们将如何定义数据库中的表。我们将使用声明性扩展，它允许我们一次性定义表和模型，类似于使用普通Flask-SQLAlchemy扩展时的做法。我们会将此任务分配给self。在建立数据库时传递到我们的表中。这里有更多关于声明性扩展的信息。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="9cca" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.现在让我们创建一个神奇的函数init _ app函数。这是我们将运行的连接flask应用程序的函数。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="7466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我试图在代码中添加注释来解释它在做什么，但是现在让我一行一行地深入解释。</p><ul class=""><li id="c668" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc jz ka kb kc bi translated">第4行:我们使用SQLAlchemy的create_engine函数初始化引擎，并传入数据库的位置(在应用程序的配置中的变量“database”下设置)。</li><li id="5346" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc jz ka kb kc bi translated">第6行:我们创建了sessionmaker，并设置了一些缺省设置，以便在生成会话时使用(比如在第9行设置bind=self.engine，以便所有会话都能访问正确的数据库)。</li><li id="96a5" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc jz ka kb kc bi translated">第13行:我们通过传入self.sessionmaker来初始化scoped_session注册表，以便注册表知道如何创建会话。最初注册表是空的，但是当我们的应用程序收到请求并调用self.session时，scoped_session注册表将创建并存储一个与请求相关联的会话。</li><li id="c77f" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc jz ka kb kc bi translated">第15行:我们将scoped_session的scopefunc设置为flask函数，该函数标识当前应用程序的调用堆栈。该应用程序在每个请求中设置和拆除调用堆栈，因此它是一个合适的对象来绑定我们的会话生命周期。<a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/contextual.html%23sqlalchemy.orm.scoping.scoped_session&amp;sa=D&amp;ust=1611277354468000&amp;usg=AOvVaw3fDGcaJ12IW-hlB5ZInrdC" rel="noopener ugc nofollow" target="_blank">了解更多关于scopefuncs </a>的信息。</li><li id="ac9b" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc jz ka kb kc bi translated">第18行:我们设定自我。Base.query到session.query_property()。如果你以前使用过Flask-SQLAlchemy，你知道你可以直接对一个表运行查询，而不是对db.session. IE，如果你有一个名为user的表，你可以运行User.query…而不是db.session.query(User)…</li><li id="e216" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc jz ka kb kc bi translated">第20行:这一行创建任何已定义的模型，如果它们还不存在，就在数据库中创建它们。稍后将详细介绍。</li></ul><p id="36e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.确保scoped_session对象在每次请求后删除当前会话。为此，我们将编写一个调用self.session.remove()的函数“remove_session”，并将其添加到我们的应用程序的<a class="ae jt" href="https://www.google.com/url?q=https://flask.palletsprojects.com/en/1.1.x/reqcontext/&amp;sa=D&amp;ust=1611269233322000&amp;usg=AOvVaw1dCVxvTbH91maP3NaHYwW5" rel="noopener ugc nofollow" target="_blank">拆卸请求函数列表</a>(在每个请求结束时运行的函数)。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="e42f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，我们在<code class="du kd ke kf kg b">init_app()</code>函数的末尾添加了<code class="du kd ke kf kg b">app.teardown_request(self.remove_session)</code>。</p><p id="4b10" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">10.现在让我们使用self来定义我们的数据库表。基本声明性扩展…下面是如何创建表的简短示例:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="cb1b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意我们是如何从your_application导入db的。这是假设您在应用程序的__init__中设置了db = SQLAlchemy()。py文件。一定要通过db。基到每个表类中，以便SQLAlchemy能够理解它们。您还需要从SQLAlchemy导入各种表结构(比如列、整数、字符串等)。</p><p id="8f0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">11.设置您的flask应用程序工厂并使用SQLAlchemy ORM！下面是一个简单的__init__的例子。我使用我们在本教程中创建的FLask_SQLAlchemy对象创建的py文件:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="511c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">注意，首先我定义了db = SQLAlchemy()，其次我从定义它们的模块中导入了我的表类，然后我运行了db.init_app(app)。您必须按照这个顺序做这些事情，否则您会发现您的数据库表没有正确创建。db=SQLAlchemy()创建db。我们需要定义表的基础。如果在导入表类之前执行db . init _ app(app ), SQLAlchemy不会知道它们，也不会在数据库中创建它们。</p><p id="c2bc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">就是这么做的！<a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/session_basics.html%23basics-of-using-a-session&amp;sa=D&amp;ust=1611277262431000&amp;usg=AOvVaw3u6I_MCMjtmpcueeFjhQwF" rel="noopener ugc nofollow" target="_blank">这里有一个关于如何使用SQLAlchemy session对象运行查询和向数据库添加内容的简要概述</a>。</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="fba1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我从来不喜欢在没有测试之前就创建一些东西，以确保它能正常工作…让我们创建一些测试来确保我们的Flask-SQLAlchemy对象能正常工作。SQLAlchemy文档指出，在web应用程序的上下文中，有两件事情需要实现:</p><ol class=""><li id="ec42" class="ju jv hi ih b ii ij im in iq jw iu jx iy jy jc kv ka kb kc bi translated">当web应用程序第一次启动时，创建一个scoped_session注册表，并确保该注册表可以跨应用程序访问。</li><li id="8ec4" class="ju jv hi ih b ii kq im kr iq ks iu kt iy ku jc kv ka kb kc bi translated">确保在每个请求结束后调用scoped_session.remove()。</li></ol><p id="712c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们确保我们的模块遵循这两条规则。如果你有兴趣跟随，为了测试，我创建了一个简单的Flask应用程序，它创建了一个将用户“注册”到数据库的应用程序。你可以在github 上找到完整的应用和测试<a class="ae jt" href="https://github.com/klfoulk16/recreate-flask-sqlalchemy-tutorial" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="399d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了便于测试，我将init_app函数中的从上面的示例<code class="du kd ke kf kg b">self.session = sqlalchemy.orm.scoped_session(self.sessionmaker, scopefunc=flask._app_ctx_stack.__ident_func__)</code>更改为<code class="du kd ke kf kg b">self.session = init_scoped_session()</code>，init_scoped_session是一个返回原始代码的函数(创建一个scoped_session对象)。这样，我可以将一个装饰器绑定到函数上，记录该函数被调用的次数。</p><p id="7a82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1a。当web应用程序首次启动时，创建一个单一的scoped_session注册表</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="ceab" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1b。确保这个scoped_session注册表可以跨应用程序访问</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="9210" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.确保在每个请求结束后调用scoped_session.remove()。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="c46d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">两次测试都以优异的成绩通过了！</p></div><div class="ab cl kh ki gp kj" role="separator"><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km kn"/><span class="kk bw bk kl km"/></div><div class="hb hc hd he hf"><p id="c7fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你像我一样，你可能仍然对一切是如何工作的感到有点困惑。在这里，我将回顾一下我脑海中的一些问题和我找到的答案。</p><p id="4ec6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">1.首先，为什么我们为每个请求创建一个新的会话，并在请求端删除它？为什么我们不在应用程序的生命周期内创建一个单独的会话呢？</p><p id="b559" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">对于web应用程序，将会话的生命周期与请求的生命周期联系起来是意料之中的事情。一个请求，意思是当你的应用程序的一个路径被调用时(例如一个对你的应用程序的“GET”或“POST”请求)。<a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/contextual.html%23using-thread-local-scope-with-web-applications&amp;sa=D&amp;ust=1611322882873000&amp;usg=AOvVaw1HxbLaDBASTsaOJBWph1rm" rel="noopener ugc nofollow" target="_blank">这个页面</a>有一个很好的图表，展示了遵循这个模式时SQLAlchemy绑定的流程应该如何工作。</p><p id="eb37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.SQLAlchemy文档指出，当调用scoped_session对象时，它将始终返回相同的会话，直到作用域结束并调用scoped_session.remove。这是如何工作的？</p><p id="b90d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我展示两个我运行来证明这种行为的测试:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="d01f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">请注意，您必须显式调用scoped_session对象(db.session)才能实现这一点。通过调用db.session()，您将会话对象本身传递给会话1和会话2。如果您只是运行session1 = db.session，那么您将会传递scoped_session对象本身，而第二个测试(断言session1和session2在不同的请求中是不同的)将会失败，因为scoped_session对象本身在不同的请求之间不会改变。</p><p id="1387" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这里有一个例子:</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="ko kp l"/></div></figure><p id="43d3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.用session = scoped _ Session(Session maker)，调用Session()和Session是一回事吗？例如，在您的代码示例中，为什么您可以调用db.session，而不是像SQLAlchemy文档中的这些示例那样必须调用db.session = db.session()。</p><p id="b47c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个可爱的东西，叫做隐式方法访问。我推荐在这里阅读<a class="ae jt" href="https://www.google.com/url?q=https://docs.sqlalchemy.org/en/13/orm/contextual.html%23implicit-method-access&amp;sa=D&amp;ust=1611322882875000&amp;usg=AOvVaw1xijPA4VNXAH3IzELJhkNa" rel="noopener ugc nofollow" target="_blank">。我在上面的问题中也解释了一下。</a></p><p id="2db9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">4.我需要在flask的g对象中存储什么吗？</p><p id="be75" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">不。如果你和我一样，你可能会先试着写一些像这样的代码:这是不必要的。你想多了。scoped_session对象处理所有这些。</p><p id="b44e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">5.你在PyPi上发表了你的项目吗？</p><p id="f76b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">是的，事实上我做到了。可以通过调用<code class="du kd ke kf kg b">pip install flask-sqlalchemy-bind</code>用pip安装。点击了解更多信息<a class="ae jt" href="https://pypi.org/project/flask-sqlalchemy-bind/1.0.0/" rel="noopener ugc nofollow" target="_blank">。我可能会发表一篇文章，讲述我是如何将它上传到PyPi的，以及我为此所经历的过程。但也许不是因为我在这篇文章后有点博客了。</a></p><p id="b1b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">希望这以半简洁的方式回答了你所有的问题。如果你还有其他问题(或者如果你在我的思维模式中发现了一些错误),请随时与我在klf16@my.fsu.edu联系。</p></div></div>    
</body>
</html>