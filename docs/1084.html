<html>
<head>
<title>Computer Vision and Deep Learning- Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">计算机视觉和深度学习-第二部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/computer-vision-and-deep-learning-part-2-586b6a0d3220?source=collection_archive---------12-----------------------#2021-02-13">https://medium.com/analytics-vidhya/computer-vision-and-deep-learning-part-2-586b6a0d3220?source=collection_archive---------12-----------------------#2021-02-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="6dd0" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">介绍</h1><p id="dcba" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">在前一篇文章中，我已经给出了一个关于图像的大致概念。一旦你理解了图像的基础，就该理解如何使用它了。</p><p id="49ba" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">对于人类来说，视觉在日常生活中起着重要的作用。同样，机器人也需要图像形式的环境信息。如果您已经阅读了本系列的前一篇文章，您可能会遇到一些彩色图像及其不同的图像格式。当我们简单地“处理”图像时，例如调整锐度、拉伸等参数，我们正在进行图像处理(更像是为进一步的应用准备图像)。而提取“什么是图像的主题”信息是计算机视觉的目标。我想首先向读者介绍我们可以使用OpenCV执行的与图像处理相关的基本操作。我在中间引入图像处理概念的原因是，当我们稍后处理更高级别的问题语句时，您需要将这些基本操作保持在手边。</p><h1 id="4b53" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">图像处理—基本操作</h1><p id="82c3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">提示:不要复制粘贴，尝试复制我将向您提供和解释的代码。在命令行上使用pip install OpenCV-python来安装OpenCV。</p><h2 id="c976" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">更改色彩空间:</h2><p id="421c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">正如我们所讨论的，改变色彩空间，即BGR到HSV，HSL或任何其他图像格式是应用相关的。对于现实应用中的颜色检测，我们通常将BGR转换为HSV，因为HSV对光照变化不敏感。在下面的代码中，我们的目标是根据物体的颜色来检测物体。请记住，检测和跟踪是两个不同的概念。在检测中，该算法将只检测颜色，而不跟踪时间。也就是说，它不会关心前一帧中的对象是否与当前帧对象相同。而跟踪器确保它在随后的帧中检测和跟踪相同的对象。</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div class="er es kt"><img src="../Images/000c49447c2bf028c26aacfdd027d286.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*2VO3lXyLzTd96AGq_OhIZw.jpeg"/></div><figcaption class="lb lc et er es ld le bd b be z dx translated">主图。观察反射如何改变颜色阴影。图片来源:<a class="ae lf" href="https://www.pinterest.com/pin/439523244855312201/" rel="noopener ugc nofollow" target="_blank">pinterest.com</a></figcaption></figure><pre class="ku kv kw kx fd lg lh li lj aw lk bi"><span id="a6d9" class="kf if hh lh b fi ll lm l ln lo">import cv2<br/>import numpy as np</span><span id="b220" class="kf if hh lh b fi lp lm l ln lo">cv_image =cv2.imread("/home/rupali/tutorials/blue_mug.jpg")<br/>#cv2.imread command is used to read an image by providing complete path to the image</span><span id="a08c" class="kf if hh lh b fi lp lm l ln lo">hsv = cv2.cvtColor(cv_image, cv2.COLOR_BGR2HSV)<br/>#cv2.cvtColor command converts image colorspace. Here we have provided the image to be converted and required color spcae conversion (from BGR to HSV)</span><span id="b5e0" class="kf if hh lh b fi lp lm l ln lo">lower_blue = np.array([100,50,50])<br/>upper_blue = np.array([140,255,255])<br/># In the above two lines we have provided range for H(110-130), S(50-255), V(50-255) for only blue color to be selected.</span><span id="9fdb" class="kf if hh lh b fi lp lm l ln lo">mask = cv2.inRange(hsv, lower_blue, upper_blue) <br/># Take hsv as input image and use these limits for extraction</span><span id="0a77" class="kf if hh lh b fi lp lm l ln lo">result = cv2.bitwise_and(cv_image, cv_image, mask= mask)<br/># here we have performed bitwise and operation with the cv_image(source 1) and the mask(white patch will appear in the desired color location). The another cv_image (source 2) is used  to bitwise_and that black and white image with the colored image.</span><span id="42f9" class="kf if hh lh b fi lp lm l ln lo">cv2.imshow('main_image',cv_image)<br/>cv2.imshow('Mask prepared',mask)<br/>cv2.imshow('Result',result)  <br/>cv2.waitKey(10000)</span></pre><div class="ku kv kw kx fd ab cb"><figure class="lq ky lr ls lt lu lv paragraph-image"><img src="../Images/160c766df0813fcb3a2af5ab1c9fa34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*SHu3v6sJ2ZQTTIBwJExbbA.jpeg"/></figure><figure class="lq ky lr ls lt lu lv paragraph-image"><img src="../Images/4579f5bea501913b1644b216d89f85a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/format:webp/1*9NlY7230PVT13L8T_SrHbg.jpeg"/><figcaption class="lb lc et er es ld le bd b be z dx lw di lx ly translated">左:蒙版图像右:最终输出。</figcaption></figure></div><h1 id="c560" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">调整图像大小和图像阈值:</h1><p id="8c63" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如上所述，基本图像处理操作的作用是为进一步使用准备图像。调整给定图像的大小和将彩色图像转换为二进制(黑色或白色)是一些常见的做法。与3通道图像相比，二进制图像更容易处理。</p><h2 id="fd5c" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">调整图像大小:</h2><pre class="ku kv kw kx fd lg lh li lj aw lk bi"><span id="ce82" class="kf if hh lh b fi ll lm l ln lo">import cv2<br/>import numpy as np</span><span id="9945" class="kf if hh lh b fi lp lm l ln lo">cv_image= cv2.imread('/home/rupali/tutorials/tiger.jpg')<br/>#read the image using cv2.imread by providing full path</span><span id="0962" class="kf if hh lh b fi lp lm l ln lo">resize_image = cv2.resize(cv_image,None, fx=0.5,fy=0.5,interpolation=cv2.INTER_CUBIC)<br/>#resize cv_image by scaling x by 0.5 and y by 0.5 , You can fix the output size by changing None to the desired dimesion(try (10,10)). Interpolation means sampling up or down technique to be used for expanding or shrinking the image</span><span id="b76f" class="kf if hh lh b fi lp lm l ln lo">cv2.imshow('original_image',cv_image)<br/>cv2.imshow('resize_image',resize_image)<br/>cv2.waitKey(10000)</span></pre><h2 id="f3c6" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">调整结果大小:</h2><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/3ea433d42e3f2e3eb06d62815ee96f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JpHT97lmbJ3npuAJGBszHg.png"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">将图像的高度和宽度分别调整0.5和0.5。原图像演职员表:【Pinterest.com T2】</figcaption></figure><h1 id="e04d" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">图像阈值:</h1><p id="220e" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">阈值的概念非常简单。阈值意味着一个极限，我们用一个例子来理解这个。假设在满分为100分的测试中，40分是门槛，即如果你的分数大于或等于40分，你就是“通过”。如果不到40，我们认为你“失败”。在图像处理中，“通过”(即高于阈值)不一定意味着固定的颜色。它可以是黑色的也可以是白色的，取决于我们对什么感兴趣。在OpenCV中，我们提供了许多技术来执行阈值处理。还有像cv2这样的基本滤镜。THRESH_BINARY以及cv2这样的复杂过滤器。OTSU谷。那么，简单的过滤器就能完成任务，为什么我们还需要复杂的过滤器呢？答案是噪声、可变光条件和正确阈值的选择。如果考试的试卷太难，得不到40分怎么办？学生发现很难跨越规定的门槛，那么将40定为门槛是明智的选择吗？复杂滤波器就是建立在这些基本思想之上的。在开始编写代码之前，我想先介绍一下直方图的概念。奇怪的一堆沙子！不是吗？</p><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es me"><img src="../Images/b90028add21abcde9792cc918e9c68b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Emsc0us8dRlJCBaDHV0z7A.jpeg"/></div></div></figure><p id="9357" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">让我们试着在同一个例子的帮助下阅读图表。获得50分的学生在人群中是最高的(这里是18分)。而得分低至15分或高达90分的学生数量很少(这里是每人1分)。如果我们将这一概念应用于一幅图像，我们将了解构成图像中大多数人口的像素数量(而不是学生数量)。上图是单峰曲线，即只有一个峰值的曲线。如果有两个峰值，我们称之为双峰图。</p><h2 id="301a" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">阈值代码:</h2><pre class="ku kv kw kx fd lg lh li lj aw lk bi"><span id="1f93" class="kf if hh lh b fi ll lm l ln lo">import cv2 <br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="1b46" class="kf if hh lh b fi lp lm l ln lo">cv_image = cv2.imread("/home/rupali/tutorials/tiger.jpg",0)<br/>#Read the main image, ) signifies in balck and white scale</span><span id="2425" class="kf if hh lh b fi lp lm l ln lo">ret, one = cv2.threshold(cv_image, 127, 255,cv2.THRESH_BINARY)<br/>#basic binary filter, provided lower and upper limit of assigning "pass"</span><span id="59c3" class="kf if hh lh b fi lp lm l ln lo">#concept of adaptive comes in light when remember exam question paper was too tough? What threshold value to select should depend on neighborhood pixel's intensity values</span><span id="bad2" class="kf if hh lh b fi lp lm l ln lo">two =cv2.adaptiveThreshold(cv_image, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY,11,2)<br/>#Syntax cv2.adaptiveThreshold(source_image, maximum value, adaptive method to be used, threshold type, blocksize, constant)<br/># maximum value- highest intensity value a pixel can contain, how threshold will be calculated depends on adaptive method used,<br/>#threshold value (for adap mean)= (mean of neighborhood(size given by block size)- constant)</span><span id="f362" class="kf if hh lh b fi lp lm l ln lo">three =cv2.adaptiveThreshold(cv_image, 255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)<br/>#Same syntax as above. threshold value(for gaussian) = weighted sum of neighborhood value - constant</span><span id="365e" class="kf if hh lh b fi lp lm l ln lo">labels = ['Original Image(In gray scale)', 'Global Thresholding','Adaptive Mean Thresholding','Adaptive Gaussian Thresholding']<br/>images = [cv_image, one, two, three]</span><span id="3612" class="kf if hh lh b fi lp lm l ln lo">for i in range(4):<br/>    plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')<br/>    plt.title(labels[i])<br/>    plt.xticks([]),plt.yticks([])<br/>    print(i)<br/>plt.show()</span><span id="89a0" class="kf if hh lh b fi lp lm l ln lo">cv2.waitKey(10000)</span></pre><h2 id="0f15" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">结果:</h2><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mf"><img src="../Images/2854e657729bc14bc5ee349166f91171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*idxUfDa7gVq_9VqaXmzXnw.jpeg"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">图像阈值结果。观察经典阈值和自适应阈值之间的差异。检查自适应阈值中保留的细节。</figcaption></figure><h2 id="c2c5" class="kf if hh bd ig kg kh ki ik kj kk kl io jn km kn is jr ko kp iw jv kq kr ja ks bi translated">阈值处理的复杂方法——Ostu阈值:</h2><p id="ef1f" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">如所讨论的，当图像是双峰(直方图中的两个峰值)时，阈值的选择变得困难。在这种情况下，cv2。THRESH_OSTU派上用场了。有关数学细节，请参考<a class="ae lf" href="https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html" rel="noopener ugc nofollow" target="_blank">奥斯特的阈值</a>。</p><p id="fac0" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated"><strong class="je hi">带直方图的输入图像:</strong></p><div class="ku kv kw kx fd ab cb"><figure class="lq ky mg ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><img src="../Images/ee2da1fdd651674ca92fc6127dd11d8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*tCUZ7ggMwrY-qsxeWq1bHQ.jpeg"/></div></figure><figure class="lq ky mh ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><img src="../Images/b22df1eeef2cd2d218e739c79979fcfb.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*d5PouwDyDksPAdpJj-1tJg.jpeg"/></div><figcaption class="lb lc et er es ld le bd b be z dx mi di mj ly translated">双峰图像。强度为18的像素形成最高峰值(数量为12047)，强度为207的像素形成最高峰值(数量为4289)。图片来源:<a class="ae lf" href="https://www.kisscc0.com/photo/crowd-light-majorelle-blue-yellow-purple-crowd-lig-jrziqe/" rel="noopener ugc nofollow" target="_blank"> kisscc0 </a></figcaption></figure></div><p id="ab60" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">直方图的代码:</p><pre class="ku kv kw kx fd lg lh li lj aw lk bi"><span id="c569" class="kf if hh lh b fi ll lm l ln lo">import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="619f" class="kf if hh lh b fi lp lm l ln lo">cv_image=cv2.imread("/home/rupali/tutorials/ostu5.jpg",0)</span><span id="b9cc" class="kf if hh lh b fi lp lm l ln lo">plt.hist(cv_image.ravel(),256,[0,256]); plt.show()</span></pre><p id="1995" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Ostu阈值代码:</p><pre class="ku kv kw kx fd lg lh li lj aw lk bi"><span id="2b28" class="kf if hh lh b fi ll lm l ln lo">import cv2<br/>import numpy as np<br/>from matplotlib import pyplot as plt</span><span id="b086" class="kf if hh lh b fi lp lm l ln lo">cv_image= cv2.imread("/home/rupali/tutorials/ostu5.jpg",0)</span><span id="c949" class="kf if hh lh b fi lp lm l ln lo">one =cv2.adaptiveThreshold(cv_image,255,cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY,11,2)<br/>ret2, two = cv2.threshold(cv_image,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)<br/>blur = cv2.GaussianBlur(cv_image,(5,5),0)<br/>ret3,three = cv2.threshold(blur, 0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><span id="5379" class="kf if hh lh b fi lp lm l ln lo">images = [cv_image, 0, one,<br/>          cv_image, 0, two,<br/>          blur, 0, three]</span><span id="bbac" class="kf if hh lh b fi lp lm l ln lo">titles = ['Original Image','Histogram','Adaptive Mean Thresholding',<br/>          'Original Image','Histogram',"Otsu's Thresholding",<br/>          'Gaussian filtered Image','Histogram',"Otsu's Thresholding of Gaussian Blur Image"]</span><span id="63dc" class="kf if hh lh b fi lp lm l ln lo">for i in xrange(3):<br/>    plt.subplot(3,3,i*3+1),plt.imshow(images[i*3],'gray')<br/>    plt.title(titles[i*3]), plt.xticks([]), plt.yticks([])<br/>    plt.subplot(3,3,i*3+2),plt.hist(images[i*3].ravel(),256)<br/>    plt.title(titles[i*3+1]), plt.xticks([]), plt.yticks([])<br/>    plt.subplot(3,3,i*3+3),plt.imshow(images[i*3+2],'gray')<br/>    plt.title(titles[i*3+2]), plt.xticks([]), plt.yticks([])<br/>plt.show()</span><span id="8488" class="kf if hh lh b fi lp lm l ln lo">cv2.waitKey(1000)</span></pre><figure class="ku kv kw kx fd ky er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es mf"><img src="../Images/0048332b4c6e89f5a8d02a2ef44a9858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a7hupxgHhRIFL5mLuKAf9g.jpeg"/></div></div><figcaption class="lb lc et er es ld le bd b be z dx translated">仔细观察最低的直方图。模糊有助于去除噪声(相邻像素强度的急剧变化)。如果输入图像只有两种灰度，您将得到两个尖锐的峰，而不是上面显示的谷。</figcaption></figure><p id="0cf2" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">仔细观察最低的直方图。模糊有助于去除噪声(相邻像素强度的急剧变化)。如果输入图像只有两种灰度，你会得到两个尖锐的峰，而不是上面显示的谷。</p><p id="eaa1" class="pw-post-body-paragraph jc jd hh je b jf ka jh ji jj kb jl jm jn kc jp jq jr kd jt ju jv ke jx jy jz ha bi translated">Ostu的threshold代码中的ret3变量是函数用来执行Threshold的阈值。在这种情况下，阈值是104。</p><h1 id="929c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论:</h1><p id="a9c4" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">因此，今天我们了解了如何执行遮罩(对于任何颜色)，调整图像大小，执行阈值即二进制阈值，自适应均值，自适应高斯，奥氏阈值和模糊图像的需要。我必须承认这对一个新手来说是很难理解的。我欣赏你的努力！在本系列的下一篇文章中，我将在我们攻击深度学习部分之前介绍几个更基本的图像处理概念。在那之前，继续学习！</p></div></div>    
</body>
</html>