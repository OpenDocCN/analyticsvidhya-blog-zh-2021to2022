<html>
<head>
<title>Create Your Own DeepArt Clone: Pytorch Neural Style Transfer Web App Using Streamlit (With Code and Colab Demo)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Streamlit创建您自己的DeepArt克隆:Pytorch神经风格转移Web应用程序(带代码和Colab演示)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/create-your-own-deepart-clone-pytorch-neural-style-transfer-web-app-using-streamlit-with-code-b12c0e41d4c7?source=collection_archive---------18-----------------------#2021-03-12">https://medium.com/analytics-vidhya/create-your-own-deepart-clone-pytorch-neural-style-transfer-web-app-using-streamlit-with-code-b12c0e41d4c7?source=collection_archive---------18-----------------------#2021-03-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/27296762a834993463a25ccbc11a6b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PnTfU4ARyAy9ivN5au9lKA.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">尼古拉·特斯拉的神经类型转移</figcaption></figure><p id="cc56" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><em class="js">在推特上关注我:</em> <a class="ae jt" href="https://twitter.com/GDurendal" rel="noopener ugc nofollow" target="_blank"> @GDurendal </a></p><p id="65c8" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">神经类型转移是现代机器学习中有趣但通常不切实际的领域之一。考虑到算法的相对复杂性，建立环境的后勤工作通常是不值得的。一旦你使用了控制台命令，创建图像的过程就没有想象中的有趣或简单了。当然，有像deepart这样的网站和大量关于这个主题的应用程序。但没有什么能让人工智能工程师插入他们自己的模型或自己部署前端。当使用它们时，还会增加应用程序/Web队列的延迟。如果我们能创造出自己的速度更快、可定制性更强的东西会怎么样？</p><p id="d57d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">有一天，我发现自己想要承担一个定制的Streamlit项目，以便更好地理解简单按钮和表格之外的框架。幸运的是，我也在同一时间看到了这个pytorch神经风格传输演示:<a class="ae jt" href="https://github.com/pytorch/examples/tree/master/fast_neural_style" rel="noopener ugc nofollow" target="_blank">https://github . com/py torch/examples/tree/master/fast _ neural _ style</a>。这个特殊的实现给出了非常好的结果(在我看来)。因此，我决定基于它创建自己的streamlit风格传输web应用程序。</p><h1 id="c56b" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">该应用程序</h1><p id="cc34" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">让我们来看看应用程序本身。当您第一次打开它时，您会看到以下内容:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es kx"><img src="../Images/025935ad81b7a3e3beff94c35b321253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*uruc2mEWCnh8T2KZCDvlSg.png"/></div></figure><p id="46e4" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">正如你所看到的，这是完全直观的。只要根据给定的画作选择一种风格，然后上传你的图片。让我们试试爱因斯坦的马赛克风格:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es lc"><img src="../Images/88551a35339135fbd7cd40ccf90c1385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*nB6Ml8HWnk3nebBPNgz35Q.png"/></div></figure><p id="3825" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在点击“创建风格转移图像”按钮运行算法！</p><figure class="ky kz la lb fd ij er es paragraph-image"><div class="er es ld"><img src="../Images/997684d0fb91e24f6de840c67e14376b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1286/format:webp/1*zoV9FVJjTg7tt9dSXUPgCw.png"/></div></figure><p id="6a96" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就是这样！超级容易！速度会因图像大小而异，但任何2MB以下的图像都应该在一分钟内完成，这取决于你的电脑性能/互联网速度(如果你使用的是colab)。对我来说，这一次只花了几秒钟，大多数人都是这样。肯定比任何公开的风格转换应用程序都要快。</p><p id="64b3" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">它很容易使用，以至于我有时间去玩它。你可以画你的狗:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es le"><img src="../Images/e99c6ecec30dab7249f9e7414bff6e5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiD7j8DsTTqYhvvlqx0hHA.png"/></div></div></figure><p id="8d0f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我特别喜欢旧图像上的结果。当然，有像<a class="ae jt" href="https://heartbeat.fritz.ai/using-deoldify-to-colorize-and-restore-grayscale-images-and-videos-c5f88b67cffb" rel="noopener ugc nofollow" target="_blank"> deoldify </a>这样的框架可以恢复旧照片，但是这一点也不好玩。看看这些结果:</p><figure class="ky kz la lb fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lf"><img src="../Images/6b288a95111c3c7bbfb8056ec31163f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kOrTOLQzo4_TmOqWZ88X5A.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">编辑这张拼贴画比运行人工智能花了我更多的时间。</figcaption></figure><p id="fc34" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我当然可以理解为什么人们会更喜欢把这样的画挂在房子里，而不是一幅普通的旧画。</p><p id="5b39" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">在代码方面，该算法将这些图像存储在images/output-images目录中，并根据所使用的样式对它们进行单独命名，以免阻塞目录。只需右键单击并执行“图像另存为”即可直接从streamlit应用程序中保存图像。但是如果你想把它们保存在文件夹中，在你再次使用相同的样式之前，一定要把它们复制下来。</p><h1 id="4160" class="ju jv hi bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr bi translated">代码</h1><p id="8952" class="pw-post-body-paragraph iu iv hi iw b ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn kw jp jq jr hb bi translated">所有相关代码都可以在我的github上找到:</p><div class="lg lh ez fb li lj"><a href="https://github.com/GeorgeDavila/PytorchNeuralStyleStreamlit" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">GeorgeDavila/pytorchneuralstylesteamlit</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">基于在https://github.com/pytorch/examples运行的fast_neural_style示例，在…中使用以下命令</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="lt l lu lv lw ls lx io lj"/></div></div></a></div><p id="86ac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">为了方便起见，包含了一个colab演示，但它在专用的虚拟环境中工作得最好。在安装了Python 3.7+的计算机上打开命令提示符并创建虚拟环境:</p><p id="b4c6" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated"><strong class="iw hj"> py -m venv流线型</strong></p><p id="b79f" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后导航到目录:<strong class="iw hj"> cd streamlitstyle </strong>并使用<strong class="iw hj">激活venv。\脚本\激活</strong></p><p id="c75b" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">然后简单地下载repo并使用我提供的requirements.txt安装需求:<strong class="iw hj">pip install-r requirements . txt</strong></p><p id="316a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">还需要下载pytorch 1.7.1。这可以很简单地按照<a class="ae jt" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/</a>上的说明来完成</p><p id="791a" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">一旦所有这些都完成了，你就可以运行程序了！只需使用<strong class="iw hj">streamlit run streamlit _ main . py</strong>，应用程序将在您的浏览器中打开，网址为<a class="ae jt" href="http://localhost:8501" rel="noopener ugc nofollow" target="_blank"> http://localhost:8501 </a></p><p id="deac" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">现在它只是一个简单的界面！</p><p id="dac2" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">这里有一个colab演示，方便那些没有必备硬件的人访问。</p><div class="lg lh ez fb li lj"><a href="https://github.com/GeorgeDavila/PytorchNeuralStyleStreamlit/blob/main/pytorchNeuralStyle.ipynb" rel="noopener  ugc nofollow" target="_blank"><div class="lk ab dw"><div class="ll ab lm cl cj ln"><h2 class="bd hj fi z dy lo ea eb lp ed ef hh bi translated">GeorgeDavila/pytorchneuralstylesteamlit</h2><div class="lq l"><h3 class="bd b fi z dy lo ea eb lp ed ef dx translated">Streamlit构建的UI上的Pytorch神经风格传递算法—GeorgeDavila/pytorchneuralstylesstreamlit</h3></div><div class="lr l"><p class="bd b fp z dy lo ea eb lp ed ef dx translated">github.com</p></div></div><div class="ls l"><div class="ly l lu lv lw ls lx io lj"/></div></div></a></div><p id="a61c" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">由于colab和IPython shells不支持本地托管，因此Colab演示要复杂得多。所以我们必须通过ngrok隧道应用程序，并使用相应的ngrok.io链接，按照我在colab笔记本上写的说明操作。这可能有点复杂，但按照这些说明，你应该能够得到一个活跃的隧道了。更活跃的使用将需要打开一个ngrok帐户，所以我建议使用一个本地虚拟环境，如果你想玩得更久的话。</p><p id="5f2d" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">我甚至找到了在colab内部编辑streamlit代码的方法。Streamlit通常只能使用streamlit run从控制台命令调用，因此您不能直接从IPython shell运行它，必须使用控制台命令调用它。所以我们简单地将streamlit代码作为文本写入python文件(参见文本变量my_st_code)。自己尝试一些基本的编辑(如果你知道basic streamlit)，你可以直接从那个笔记本编辑它。</p><p id="dc7e" class="pw-post-body-paragraph iu iv hi iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hb bi translated">就是这样！我们有一个漂亮易用的streamlit web应用程序！如果愿意的话，你甚至可以把它放在Heroku上(尽管这个特殊的算法会消耗很多计算能力)。尽情享受吧！</p></div></div>    
</body>
</html>