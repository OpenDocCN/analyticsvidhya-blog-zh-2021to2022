<html>
<head>
<title>Model-based Recommendation System with Matrix Factorization — ALS Model and The Math behind</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于模型的矩阵分解推荐系统——ALS模型及其数学基础</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/model-based-recommendation-system-with-matrix-factorization-als-model-and-the-math-behind-fdce8b2ffe6d?source=collection_archive---------3-----------------------#2021-05-16">https://medium.com/analytics-vidhya/model-based-recommendation-system-with-matrix-factorization-als-model-and-the-math-behind-fdce8b2ffe6d?source=collection_archive---------3-----------------------#2021-05-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="6c0b" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">矩阵分解在推荐系统中有着广泛的应用，我们将使用als模型进行构建，并解释其背后的数学原理</h2></div><p id="dcf2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">协同过滤是实现最多、最成熟的推荐系统。我们将使用pyspark提供的ALS模型来构建基于模型的推荐系统——矩阵分解。</p><p id="4c18" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">GitHub链接:<a class="ae js" href="https://github.com/chiang9/Recommendation_system_pyspark/blob/main/ALS_model/movielen%20ALS.ipynb" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Chiang 9/re commendation _ system _ py spark/blob/main/ALS _ model/movie len % 20 ALS . ipynb</a></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/23a2bf975adc5a97a58c378e96257b52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPN02TtKojmWOMYDcsmwbQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图一。效用矩阵</figcaption></figure><p id="eac1" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">稀疏矩阵<strong class="iy hi"> R </strong>可以基于用户-项目关系及其评级的数据来构建。分数可以从用户或用户行为中获得。协同过滤方法使用矩阵<strong class="iy hi"> R </strong>来产生推荐。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es kj"><img src="../Images/921bb40eef1f62bd24993ea37805daa1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK_Gd3JCPgQTJrO-9YwTgQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">图二。矩阵分解</figcaption></figure><p id="6b16" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">矩阵分解法的目标是将效用矩阵分解成<strong class="iy hi">用户潜在矩阵</strong>和<strong class="iy hi">产品潜在矩阵</strong>，这样</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es kk"><img src="../Images/4c28fd90b80af1d9ce94b3e29abcc27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:178/1*eYPPleEfgfm_BOgzHrtKWg.gif"/></div></figure><p id="64fd" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">效用矩阵的分解方法有很多，如奇异值分解、概率潜在语义分析等。在替代最小二乘法(ALS)中，优化因子分解模型是一个迭代过程。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="c4d7" class="ks kt hh bd ku kv kw kx ky kz la lb lc in ld io le iq lf ir lg it lh iu li lj bi translated">替代最小二乘法</h1><p id="45c3" class="pw-post-body-paragraph iw ix hh iy b iz lk ii jb jc ll il je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">ALS模型是协同过滤中最流行的方法之一。为了看到模型背后的数学，我们首先使用<strong class="iy hi"> <em class="lp">损失函数— RMSE来定义<strong class="iy hi"> <em class="lp">目标函数</em> </strong>。</em>T19】</strong></p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lq"><img src="../Images/ef4ed837b5f0b26ed55043a649d054cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:556/1*gq9m5J4TZ5hDm0fyc9rFfw.gif"/></div></figure><p id="b282" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中实数= R，预测等于U*P^T.</p><p id="c1e0" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">假设有<strong class="iy hi"> m个</strong>用户和<strong class="iy hi"> n个</strong>项，R = m * n，U = m * k，P = n * k，其中k为潜在因素。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lr"><img src="../Images/812ab7cbe2bce0d49dc5c4c4d4ee99a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/1*7wDrjurnuSRGz5NfLANlrA.gif"/></div></figure><p id="6ffa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">为了避免过度拟合，我们将l2范数添加到我们的目标函数中，使得</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es ls"><img src="../Images/88361583e8101db1ae335f8c10d89bd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/1*enKBJmhsPGl_QN8sH5inVw.gif"/></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">目标函数</figcaption></figure><p id="7a82" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们对U和p取偏导数。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lt"><img src="../Images/2902fd67cd4e5ce4a26553b185f2bb54.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/1*4WF0-UIOo3MRpNaqwWpwHw.gif"/></div></figure><p id="2eaa" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过应用类似的过程，我们可以找到关于p的损失微分。</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div class="er es lt"><img src="../Images/b08bc3d64b689d632e7c89e48afbea07.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/1*it8KhR-YNXkh6OFltGVLZQ.gif"/></div></figure><p id="f658" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，我们有U和p的两个方程，通过固定一个，我们可以优化另一个。迭代地交替潜在矩阵U和P，我们能够优化效用矩阵分解。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="c96d" class="ks kt hh bd ku kv kw kx ky kz la lb lc in ld io le iq lf ir lg it lh iu li lj bi translated">数据源</h1><p id="528f" class="pw-post-body-paragraph iw ix hh iy b iz lk ii jb jc ll il je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">在本例中，我们将使用movielens数据集(ml-100k)。</p><p id="127a" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">链接:<a class="ae js" href="https://grouplens.org/datasets/movielens/" rel="noopener ugc nofollow" target="_blank">https://grouplens.org/datasets/movielens/</a></p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="ea43" class="ks kt hh bd ku kv kw kx ky kz la lb lc in ld io le iq lf ir lg it lh iu li lj bi translated">我们开始吧</h1><p id="50cf" class="pw-post-body-paragraph iw ix hh iy b iz lk ii jb jc ll il je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">在这个例子中，我们将使用<strong class="iy hi"> pyspark </strong>和<strong class="iy hi"> movielens </strong>数据集。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="lu lv l"/></div></figure><pre class="ju jv jw jx fd lw lx ly lz aw ma bi"><span id="ce63" class="mb kt hh lx b fi mc md l me mf">[Row(userid=196.0, itemid=242.0, rating=3.0),<br/> Row(userid=186.0, itemid=302.0, rating=3.0)]</span></pre><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="02be" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们缓存了训练和测试数据集，以便进一步使用spark。</p><p id="972c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，我们使用<strong class="iy hi"> CrossValidator </strong>来调优超参数。在Spark ALS模型中，我们可以定义各种参数，<strong class="iy hi"> rank </strong>，<strong class="iy hi"> maxIter </strong>，<strong class="iy hi"> regParam </strong>，更多信息请访问<a class="ae js" href="https://spark.apache.org/docs/latest/api/python/reference/api/pyspark.ml.recommendation.ALS.html#pyspark.ml.recommendation.ALS" rel="noopener ugc nofollow" target="_blank">https://Spark . Apache . org/docs/latest/API/python/reference/API/py Spark . ml . recommendation . ALS . html # py Spark . ml . recommendation . ALS</a></p><p id="4f56" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">其中秩为<strong class="iy hi">潜在因子，k为</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="555c" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">经过训练后，我们可以从CrossValidator中提取出最佳模型及其参数。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="lu lv l"/></div></figure><pre class="ju jv jw jx fd lw lx ly lz aw ma bi"><span id="49ff" class="mb kt hh lx b fi mc md l me mf">Rank = 100 <br/>MaxIter = 10 <br/>RegParam = 0.1</span></pre><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="lu lv l"/></div></figure><pre class="ju jv jw jx fd lw lx ly lz aw ma bi"><span id="04fc" class="mb kt hh lx b fi mc md l me mf">RMSE = 0.9293164895244701<br/>+---+--------------------+<br/>| id|            features|<br/>+---+--------------------+<br/>| 10|[0.3314802, -0.07...|<br/>| 20|[0.3870823, 0.024...|<br/>| 30|[0.3141748, -0.09...|<br/>| 40|[0.26709092, -0.2...|<br/>| 50|[0.35146096, -0.0...|<br/>| 60|[0.36123818, -0.1...|<br/>| 70|[0.44221446, -0.0...|<br/>| 80|[0.4122668, -0.07...|<br/>| 90|[0.070995346, -0....|<br/>|100|[0.45245463, 0.05...|<br/>+---+--------------------+<br/>only showing top 10 rows</span><span id="6438" class="mb kt hh lx b fi mg md l me mf">+---+--------------------+<br/>| id|            features|<br/>+---+--------------------+<br/>| 10|[0.24241637, -0.2...|<br/>| 20|[0.21774949, -0.0...|<br/>| 30|[0.2805123, -0.04...|<br/>| 40|[0.08548905, -0.0...|<br/>| 50|[0.47504237, -0.2...|<br/>| 60|[0.046063706, -0....|<br/>| 70|[0.21902403, -0.1...|<br/>| 80|[0.33022547, -0.1...|<br/>| 90|[0.42008877, -0.0...|<br/>|100|[0.28412965, -0.1...|<br/>+---+--------------------+<br/>only showing top 10 rows</span></pre><p id="cdd6" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们可以使用以下方法找到对特定用户或可能对特定项目感兴趣的用户的项目推荐，<strong class="iy hi">推荐给用户</strong>，<strong class="iy hi">推荐给项目，推荐给用户子集</strong>，<strong class="iy hi">推荐给项目子集。</strong></p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="a973" class="ks kt hh bd ku kv kw kx ky kz la lb lc in ld io le iq lf ir lg it lh iu li lj bi translated">此外…</h1><p id="150a" class="pw-post-body-paragraph iw ix hh iy b iz lk ii jb jc ll il je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">Spark ML中有两个模块，<strong class="iy hi"> ml </strong>和<strong class="iy hi"> mllib。</strong></p><p id="8dc2" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">spark.ml模块使用<strong class="iy hi">数据帧</strong>，mllib使用<strong class="iy hi"> RDD，</strong>其中mllib慢慢被弃用。</p></div><div class="ab cl kl km go kn" role="separator"><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq kr"/><span class="ko bw bk kp kq"/></div><div class="ha hb hc hd he"><h1 id="bd9e" class="ks kt hh bd ku kv kw kx ky kz la lb lc in ld io le iq lf ir lg it lh iu li lj bi translated">结论</h1><p id="5c7b" class="pw-post-body-paragraph iw ix hh iy b iz lk ii jb jc ll il je jf lm jh ji jj ln jl jm jn lo jp jq jr ha bi translated">ALS模型是构建推荐系统的有力工具。Apache Spark提供了一个方便的API来建立模型，然而，大多数时候该模型在处理数据稀疏、冷启动等问题时不够好。我们需要结合一些策略和用户行为分析。</p><p id="4e1b" class="pw-post-body-paragraph iw ix hh iy b iz ja ii jb jc jd il je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读，祝您度过美好的一天。</p></div></div>    
</body>
</html>