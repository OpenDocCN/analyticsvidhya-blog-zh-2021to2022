<html>
<head>
<title>CNN based malware detection (python and TensorFlow)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于CNN的恶意软件检测(python和TensorFlow)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/cnn-based-malware-detection-python-and-tensorflow-717f8de84ee?source=collection_archive---------4-----------------------#2021-02-15">https://medium.com/analytics-vidhya/cnn-based-malware-detection-python-and-tensorflow-717f8de84ee?source=collection_archive---------4-----------------------#2021-02-15</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="cad9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络(CNN)专门处理图像等多维数据。CNN模型通常用于处理二维矩阵(图像)或音频频谱图。它们也经常用于三维数据(视频和体积图像)。CNN的体系结构由三种类型的层组成:卷积层、汇集层和分类层。</p><p id="1ba8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积网络(CNN)训练中最重要的运算是卷积[Goodfellow et al .，2016]。后者将滤波器应用于由矩阵表示的图像。应用滤镜会生成一组传递到池层的小图像。这个序列可以在整个网络中重复几次，直到它到达平坦层，在那里携带抽象特征的向量将传递到密集层。过滤器可以通过三种方式初始化:</p><ul class=""><li id="6110" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">手动:</strong>例如，为了识别脸部，我们使用眼睛过滤器、嘴巴过滤器……这些过滤器很容易手动初始化，因为脸部的形状是已知的。</li><li id="1a81" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">随机:</strong>当我们面对难以描述的抽象图像或物体时，我们会被迫使用随机初始化的滤镜。</li><li id="6cfe" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated"><strong class="ih hj">预训练:</strong>过滤器的预训练是在图像的一部分上完成的，例如，如果我们想要得到一个眼睛的过滤器，我们就建立一个在只包含眼睛的图像上学习的网络。</li></ul><h1 id="c0ce" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">EXE文件到图像</h1><p id="5c9c" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">已经有许多作品使用CNN模型来分析一个EXE文件并检测恶意软件。我们在之前的一篇文章(<a class="ae ku" rel="noopener" href="/analytics-vidhya/malware-detection-with-deep-learning-state-of-the-art-177c81aa83ea">https://medium . com/analytics-vid hya/malware-detection-with-deep-learning-state-of-art-177 c 81 aa 83 ea</a>)中强调了这些作品以及其他作品。</p><p id="0160" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我们将探索一个可执行文件的原始字节，以创建一个可执行文件的形象。可执行文件的字节流将被放置在一个数组中，然后将其转换为图像，如[Le et al .，2018]中所示。例如，字节序列:E4 C0 56 A3 D2 78 56 A3 FF，可以用下面的矩阵表示:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es kv"><img src="../Images/b6ed22d27099479742b54294389f40ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*PDadOa9B9yKkuVZ0y3OZng.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">字节序列的灰度图像</figcaption></figure><p id="c00f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">先前的矩阵将被转换成灰度图像，其中矩阵的每个方框将是图像中的一个像素(灰度等级在0和255之间)</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lh"><img src="../Images/f44310f21f771b762d8bb768653a6bc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*IURTL7zaTmM02WZjKd7OmA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">良性文件的图像128*128</figcaption></figure><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es li"><img src="../Images/33dc5dade0b165e850684c021d86cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:690/format:webp/1*tQ6wm2Zhx-UJM45a_545LA.png"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">恶意软件图像128*128</figcaption></figure><p id="2d8c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们做一些编码和实现这第一部分。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">这就是如何将一个EXE文件转换成一组大小为h*w的图像</figcaption></figure><h1 id="f88a" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">创建CNN</h1><p id="e113" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">现在我们来设计一个卷积神经网络来分析图像并预测文件的恶意性。当谈到CNN的设计时，有很多参数可以考虑:图像大小、内核大小、内核数量、层数…</p><h2 id="b72f" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">层数</h2><p id="d721" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们做了一个小实验，改变包括层数在内的所有参数，并预测每个层数的平均值。下面的图给出了由从1到5的特定层数的每个神经网络实现的最小学习误差。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es lz"><img src="../Images/c4639788340deb74b4f00d11f04e1625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OHl8z6qPgQd4XundZkMUtw.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">学习误差和泛化误差随隐含层数的变化</figcaption></figure><h2 id="0cd9" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">过滤器数量</h2><p id="edc9" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">我们做了与上一次类似的体验，结果显示在下图中。我们注意到，我们没有改变过滤器的尺寸，我们采用了通常使用的尺寸(5*5)和(3*3)，尽管这不是一个规则。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es me"><img src="../Images/0eef2bd07ee34c6b5056ce8a24fb53d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*klA4FngSiuiKz5WTUfr2jQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">每个数量的滤波器的学习误差和泛化误差的变化</figcaption></figure><h2 id="8529" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">图像尺寸</h2><p id="f788" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">图像的大小是另一个参数，虽然在实践中什么效果最好并不明显，但我们已经排除了一些选择。选择大的尺寸会使学习变得困难，因为CNN的输入层会很大，因此我们需要更多的隐藏层，这将导致内存短缺或长时间的计算。此外，选择大尺寸会导致小EXE的问题，甚至不能填充一个图像。另一方面，选择小尺寸将覆盖大多数EXE文件，但它会破坏EXE文件内的一些地方，因为我们将把一个EXE文件分解成多个单独的图像。总之，我们尝试了不同的维度，给你。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="er es me"><img src="../Images/61dee682499255f2aaaf26e5a27c0359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TAjPJ2aTMfRwgixqng8SpQ.png"/></div></div><figcaption class="ld le et er es lf lg bd b be z dx translated">按图像大小的误差(懒人标题对吗？)</figcaption></figure><h2 id="127c" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">CNN的体系结构</h2><p id="51ab" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">从前面的部分我们结合最佳参数来设计我们的CNN: 2个隐藏层，16个过滤器和64*64的图像。</p><p id="07bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">网络的架构将会是这样的。请注意，卷积层可以由多个conv2d层组成，后跟池层，也可能会被删除。在本例中，我们将多个conv2d层分为两个卷积层。展平图层用于将输出转换为一个长矢量，然后通过分类图层进行处理。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es mf"><img src="../Images/e27d6fd6068112a17fc7d41fae56e1cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*MIdA3NwEH8ktZeR27p8XLQ.png"/></div></figure><h2 id="971c" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">说够了，让我们做一些编码。</h2><p id="8ce0" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">首先，我们做一些整形，我们把图像转换成灰度，并导入必要的模块。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><p id="f736" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">之后，我们实施架构:</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div><figcaption class="ld le et er es lf lg bd b be z dx translated">cnn的代码</figcaption></figure><h1 id="c801" class="jr js hi bd jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko bi translated">最后</h1><p id="a761" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">如果您有一组来自两种类型(良性和恶意)的可执行文件，您可以尝试适应这个模型。你只需要准备一个恶意软件的图片列表和一个良性的图片列表，然后你就可以在这里建立模型了。</p><figure class="kw kx ky kz fd la"><div class="bz dy l di"><div class="lj lk l"/></div></figure><h2 id="d957" class="ll js hi bd jt lm ln lo jx lp lq lr kb iq ls lt kf iu lu lv kj iy lw lx kn ly bi translated">更新</h2><p id="29d7" class="pw-post-body-paragraph if ig hi ih b ii kp ik il im kq io ip iq kr is it iu ks iw ix iy kt ja jb jc hb bi translated">你可以在这个<a class="ae ku" href="https://github.com/islem-esi/DeepMalwareDetector" rel="noopener ugc nofollow" target="_blank">GitHub repo</a>:【https://github.com/islem-esi/DeepMalwareDetector T2】上找到训练好的模型和WebUI</p></div></div>    
</body>
</html>