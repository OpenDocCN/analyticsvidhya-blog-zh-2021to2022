<html>
<head>
<title>Python Object Oriented programming tips</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python面向对象编程技巧</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-object-oriented-programming-tips-db4b40c9e314?source=collection_archive---------11-----------------------#2021-04-11">https://medium.com/analytics-vidhya/python-object-oriented-programming-tips-db4b40c9e314?source=collection_archive---------11-----------------------#2021-04-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/6697b4bcfd870604b493dbbc8a414f2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*yi-k9JbAtixjEMb-hg8qkg.png"/></div></figure><p id="b59c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是我上一篇文章的延续，文章讲述了用Python编写库或框架时要做的事情，这将使代码更易于维护和扩展。</p><p id="11a2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果还没有，请看看我的第一篇文章。</p><div class="jj jk ez fb jl jm"><a href="https://vivek936ster.medium.com/ways-to-manage-instance-attributes-and-access-in-python-to-code-more-defensively-a95384298c33" rel="noopener follow" target="_blank"><div class="jn ab dw"><div class="jo ab jp cl cj jq"><h2 class="bd hi fi z dy jr ea eb js ed ef hg bi translated">中等</h2><div class="jt l"><h3 class="bd b fi z dy jr ea eb js ed ef dx translated">在Python中管理实例属性的提示/技巧</h3></div></div></div></a></div><p id="4ee6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">bat的权利，我们来看问题陈述。</p><ol class=""><li id="efa2" class="ju jv hh in b io ip is it iw jw ja jx je jy ji jz ka kb kc bi translated">如果我们在一个框架之上编写一个库或包装器，我们向它添加了更多的功能，但是我们还想利用它的底层特性，而不需要重新实现它，那该怎么办？</li><li id="b2bb" class="ju jv hh in b io kd is ke iw kf ja kg je kh ji jz ka kb kc bi translated">如何为一个类添加额外的功能而不修改它或从它继承？基本上，我们不想在类之间增加紧密耦合。</li></ol><p id="659f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">让我们逐一讨论如何解决这些问题。</p><h1 id="d7a9" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">拦截“.”调用实例方法时</h1><p id="893d" class="pw-post-body-paragraph il im hh in b io lg iq ir is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ha bi translated">对于第一个问题，想法是截取“.”当我们调用一个实例的方法将它转发给超类的实现时。考虑下面的例子。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="194e" class="lu kj hh lq b fi lv lw l lx ly">class Person(object):<br/>    def __init__(self, first_name, last_name, address):<br/>        self.first_name = first_name<br/>        self.last_name = last_name<br/>        self.address = address<br/><br/>    @classmethod<br/>    def create_using_full_name(cls, full_name, address):<br/>        name = full_name.split(' ')<br/>        return cls(name[0], name[1], address)<br/><br/>class Employees(object):<br/>    def __init__(self):<br/>        self.employees_list = []<br/><br/>    def __len__(self):<br/>        return len(self.employees_list)<br/><br/>    def __getitem__(self, item):<br/>        return self.employees_list[item]<br/><br/>    @classmethod<br/>    def add_employee_to_list(cls, list_of_emps=[]):<br/>        self = cls()<br/>        for emp in list_of_emps:<br/>            self.employees_list.append(emp)<br/>        return self<br/><br/>    def print_emp_name(self):<br/>        return [person.first_name + person.last_name for person in self.employees_list]<br/></span><span id="a070" class="lu kj hh lq b fi lz lw l lx ly">person1 = Person(“Henry”, “Thiery”, “France”)<br/>person2 = Person(“Xaxi”, “Hernandez”, “Spain”)<br/>person3 = Person(“Erling”, “Haaland”, “Sweden”)</span><span id="8c88" class="lu kj hh lq b fi lz lw l lx ly">employees = Employees.add_employee_to_list([person1, person2, person3])<br/>employees_list.print_emp_name()<br/>[‘HenryThiery’, ‘XaxiHernandez’, ‘ErlingHaaland’]</span></pre><p id="da77" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这里，employees是一个类似于对象的列表，但不是一个列表。假设我们想在Employees对象中使用列表对象的append方法，我们需要从列表对象继承，并在Employee类定义中覆盖append方法，如果我们想支持更多来自列表对象的方法，这是紧耦合的，很难维护。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e116" class="lu kj hh lq b fi lv lw l lx ly">employees = Employees.add_employee_to_list([person1, person2, person3])<br/>len(employees)<br/>3<br/>employees[1]<br/>&lt;__main__.Person object at 0x10fd987c0&gt;<br/>employees[1].first_name<br/>‘Xaxi’</span></pre><p id="0321" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">有一个解决方案，我们可以定义一个神奇的方法__getattr__来拦截“.”当我们调用一个实例方法时，我们可以使用getattr方法将它重定向到适当的类，就像我们在上一篇文章中看到的那样。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="11da" class="lu kj hh lq b fi lv lw l lx ly">class Employees(object):<br/>    def __init__(self):<br/>        self.employees_list = []<br/><br/>    def __len__(self):<br/>        return len(self.employees_list)<br/><br/>    def __getitem__(self, item):<br/>        return self.employees_list[item]<br/><br/>    def __getattr__(self, item):<br/>        return getattr(self.employees_list, item)<br/><br/>    @classmethod<br/>    def add_employee_to_list(cls, list_of_emps=[]):<br/>        self = cls()<br/>        for emp in list_of_emps:<br/>            self.employees_list.append(emp)<br/>        return self<br/>    <br/>    def print_emp_name(self):<br/>        return [person.first_name + person.last_name for person in self.employees_list]</span></pre><p id="3203" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在employee对象神奇地拥有了List对象的方法，它实际上被重定向到了main类，因为我们截获了“.”使用getattr。现在谈我们的第二个问题。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="74c5" class="lu kj hh lq b fi lv lw l lx ly">employees = Employees.add_employee_to_list([person1, person2, person3])<br/>employees.append<br/>&lt;built-in method append of list object at 0x10fd88200&gt;<br/>employees.sort<br/>&lt;built-in method sort of list object at 0x10fd88200&gt;<br/>employees.index(1)<br/>employees.index<br/>&lt;built-in method index of list object at 0x10fd88200&gt;</span></pre><h1 id="de13" class="ki kj hh bd kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated">使用混合来减少紧耦合</h1><p id="db26" class="pw-post-body-paragraph il im hh in b io lg iq ir is lh iu iv iw li iy iz ja lj jc jd je lk jg jh ji ha bi translated">我们使用mixins来解决下一个问题，这是一种多重继承。在像Django或Flask这样的框架中编码的人肯定会使用它，或者至少听说过它。</p><p id="a7c1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我在mixins上看到一个不错的stackoverflow回答。粘贴到这里，<br/>当你想给一个类提供可选的继承时，可以使用Mixins。<br/>比如你想在不同类型的类中重用某个特定的特性。<br/>我同意，在我们下面的例子中，我们将它用于上面提到的要点，作为副产品，我们正在减少紧密耦合，并且正在实现编写通用代码。<br/>让我们再次以这个Person类为例，</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="77b0" class="lu kj hh lq b fi lv lw l lx ly">class Person(object):<br/>    def __init__(self, name, age, sex, profession):<br/>        self.name = name<br/>        self.age = age<br/>        self.sex = sex<br/>        self.profession = profession</span></pre><p id="501b" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设我们希望通过选择实例中的字段，以表格格式打印类对象的内容。我们编写下面的函数来实现这一点。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e0c8" class="lu kj hh lq b fi lv lw l lx ly">def print_table(objects, attrs):<br/>    for attr_name in attrs:<br/>        print(attr_name, end='\t')<br/>    print()<br/>    for obj in objects:<br/>        for attr_name in attrs:<br/>            print(getattr(obj, attr_name), end="\t")<br/>        print()</span><span id="646e" class="lu kj hh lq b fi lz lw l lx ly">name age profession<br/>Thiery Henry 42 Footballer <br/>Hernandez Xaxi 35 Footballer <br/>Erling Haaland 21 Footballer</span></pre><p id="a6f1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">(暂时请原谅缩进)现在输出看起来还可以。但是如果想要有不同的类似文本的输出格式，比如csv，html等呢？<br/>更改print_table的代码以接受任何具有标题和内容打印方法的对象。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="e946" class="lu kj hh lq b fi lv lw l lx ly">def print_table(objects, attrs, format):<br/>    format.heading(attrs)<br/>    for obj in objects:<br/>        rows = [str(getattr(obj, attr_name)) for attr_name in attrs]<br/>        format.contents(rows)</span></pre><p id="6b95" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在让我们实现格式化程序代码，我们将把它作为参数传递给print_table方法。所以，这是一个基础类的蓝图。我们继承基类并实现蓝图。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="7981" class="lu kj hh lq b fi lv lw l lx ly">class Formatter(object):<br/>    def __init__(self, save_file=None):<br/>        if save_file:<br/>            self.save_file = save_file<br/><br/>    def heading(self, headers):<br/>        raise NotImplementedError<br/><br/>    def contents(self, rows):<br/>        raise NotImplementedError<br/><br/><br/>class TextFormatter(<br/>    Formatter):  # if i want to support width param or add a feature then I would need to init parent and create my var<br/><br/>    def __init__(self, save_file=None, width=20):<br/>        self.width = width<br/>        super().__init__(save_file=save_file)<br/><br/>    def heading(self, headers):<br/>        for header in headers:<br/>            print(header, end='\t')<br/>        print()<br/><br/>    def contents(self, rows):<br/>        print()<br/>        for row in rows:<br/>            print({}.format(row), end="\t")<br/><br/><br/>class CVSFormatter(Formatter):<br/>    def heading(self, headers):<br/>        for header in headers:<br/>            print(header, end=',')<br/>        print()<br/><br/>    def contents(self, rows):<br/>        for row in rows:<br/>            print('{}'.format(row), end=",")<br/>        print()<br/><br/><br/>class HTMLFormatter(Formatter):<br/>    def heading(self, headers):<br/>        for header in headers:<br/>            print('&lt;h&gt;{}&lt;/h&gt;'.format(header), end=' ')<br/>        print()<br/><br/>    def contents(self, rows):<br/>        for row in rows:<br/>            print('&lt;t&gt;{}&lt;/t&gt;'.format(row), end=" ")<br/>        print()</span><span id="ccc6" class="lu kj hh lq b fi lz lw l lx ly">persons = [person1, person2, person3]</span><span id="e706" class="lu kj hh lq b fi lz lw l lx ly"><strong class="lq hi"># Creating a formatter</strong><br/>formatter = CVSFormatter()<br/>print_table(persons, [‘name’, ‘age’, “profession”], format=formatter)</span><span id="ec64" class="lu kj hh lq b fi lz lw l lx ly"><strong class="lq hi"># Creating another formatter<br/></strong>formatter = HTMLFormatter()<br/>print_table(persons, [‘name’, ‘age’, “profession”], format=formatter)</span><span id="f549" class="lu kj hh lq b fi lz lw l lx ly"><strong class="lq hi"># output of each formatter</strong><br/>name,age,profession,<br/>Thiery Henry,42,Footballer,<br/>Hernandez Xaxi,35,Footballer,<br/>Erling Haaland,21,Footballer,</span><span id="5f8d" class="lu kj hh lq b fi lz lw l lx ly">&lt;h&gt;name&lt;/h&gt; &lt;h&gt;age&lt;/h&gt; &lt;h&gt;profession&lt;/h&gt; <br/>&lt;t&gt;Thiery Henry&lt;/t&gt; &lt;t&gt;42&lt;/t&gt; &lt;t&gt;Footballer&lt;/t&gt; <br/>&lt;t&gt;Hernandez Xaxi&lt;/t&gt; &lt;t&gt;35&lt;/t&gt; &lt;t&gt;Footballer&lt;/t&gt; <br/>&lt;t&gt;Erling Haaland&lt;/t&gt; &lt;t&gt;21&lt;/t&gt; &lt;t&gt;Footballer&lt;/t&gt;</span></pre><p id="3b7c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">看来我们的代码起作用了。但是也有一些问题。如果我们想添加一个向行中添加报价的功能会怎么样。无论是任何格式化文本，CSV或HTML。</p><p id="248c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">假设如果我们想要添加宽度参数的支持或者添加任何其他参数到TextFormatter，那么我们需要初始化父类，如果父类有一些参数需要用init初始化，而子类不关心它。这是紧耦合。</p><p id="fd60" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">然后，我们必须从父类到子类做这么多的更改，如果我们想把它作为参数添加到子类中，该怎么办呢？</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="b145" class="lu kj hh lq b fi lv lw l lx ly">class TextFormatter(Formatter):<br/>    def __init__(self, save_file=None, width=20):<br/>        self.width = width<br/>        super().__init__(output_type=None)</span></pre><p id="2765" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是紧耦合的另一个例子，我们从TextFormatter继承，我们不需要这样做。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="dad8" class="lu kj hh lq b fi lv lw l lx ly">class QuoterMixin(TextFormatter):<br/>    def contents(self, rows):<br/>    quoted = ['"{}"'.format(text) for text in rows]<br/>    super().contents(quoted)</span></pre><p id="08fd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">还记得为什么我们需要混音吗？这是原因之一。我们不希望紧耦合向我们的类添加功能，我们只是创建一个mixin类，它只是将功能添加到contents方法并调用超类的contents方法。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="5306" class="lu kj hh lq b fi lv lw l lx ly">class QuoterMixin(object):<br/>    def contents(self, rows):<br/>        quoted = ['"{}"'.format(text) for text in rows]<br/>        super().contents(quoted)</span></pre><p id="939f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在我们创建一个新的formatter对象，它继承了两个类。做我们需要它做的事情。</p><pre class="ll lm ln lo fd lp lq lr ls aw lt bi"><span id="2025" class="lu kj hh lq b fi lv lw l lx ly"><strong class="lq hi">class Formatter(QuoterMixin, CVSFormatter):<br/>    pass</strong><br/><br/>formatter = Formatter()</span><span id="4504" class="lu kj hh lq b fi lz lw l lx ly">person1 = Person(“Thiery Henry”, “42”, “M”, “Footballer”)<br/>person2 = Person(“Hernandez Xaxi”, “35”, “M”, “Footballer”)<br/>person3 = Person(“Erling Haaland”, “21”, “M”, “Footballer”)<br/><br/>persons = [person1, person2, person3]<br/>print_table(persons, [‘name’, ‘age’, “profession”], format=formatter)</span><span id="bd6a" class="lu kj hh lq b fi lz lw l lx ly">formatter = CVSFormatter()<br/>print_table(persons, [‘name’, ‘age’, “profession”], format=formatter)</span><span id="18ba" class="lu kj hh lq b fi lz lw l lx ly">formatter = HTMLFormatter()<br/>print_table(persons, [‘name’, ‘age’, “profession”], format=formatter)</span><span id="d4de" class="lu kj hh lq b fi lz lw l lx ly">name,age,profession,<br/><strong class="lq hi">“Thiery Henry”,”42",”Footballer”,<br/>“Hernandez Xaxi”,”35",”Footballer”,<br/>“Erling Haaland”,”21",”Footballer”</strong></span><span id="42ab" class="lu kj hh lq b fi lz lw l lx ly">&lt;h&gt;name&lt;/h&gt; &lt;h&gt;age&lt;/h&gt; &lt;h&gt;profession&lt;/h&gt; <br/><strong class="lq hi">&lt;t&gt;”Thiery Henry”&lt;/t&gt; &lt;t&gt;”42"&lt;/t&gt; &lt;t&gt;”Footballer”&lt;/t&gt; <br/>&lt;t&gt;”Hernandez Xaxi”&lt;/t&gt; &lt;t&gt;”35"&lt;/t&gt; &lt;t&gt;”Footballer”&lt;/t&gt; <br/>&lt;t&gt;”Erling Haaland”&lt;/t&gt; &lt;t&gt;”21"&lt;/t&gt; &lt;t&gt;”Footballer”&lt;/t&gt;</strong></span></pre><p id="146c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在双引号神奇地出现在我们想要的行中。我们已经成功地添加了一个特性，而且代码也不是紧密耦合的。<br/>本文到此结束。我希望当你用Python编码时，这些技巧能以某种方式帮助你。尤其是这些技巧帮助我们在Apache Spark的基础上为我们的用例创建了一个更干净的框架。感谢阅读我的文章。</p></div><div class="ab cl ma mb go mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ha hb hc hd he"><p id="4f45" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">[1]: Python食谱:掌握Python的食谱3第3版</p><p id="1a85" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><a class="ae mh" href="https://www.amazon.in/Python-Cookbook-Recipes-Mastering-ebook/dp/B00DQV4GGY" rel="noopener ugc nofollow" target="_blank">https://www . Amazon . in/Python-Cookbook-Recipes-Mastering-ebook/DP/b 00 dqv 4 ggy</a></p></div></div>    
</body>
</html>