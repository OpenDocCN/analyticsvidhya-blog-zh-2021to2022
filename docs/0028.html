<html>
<head>
<title>Exploring 9/11 Dataset</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索9/11数据集</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/exploring-9-11-dataset-bf443b55f4cb?source=collection_archive---------27-----------------------#2021-01-01">https://medium.com/analytics-vidhya/exploring-9-11-dataset-bf443b55f4cb?source=collection_archive---------27-----------------------#2021-01-01</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/0ab5b1a2d3b7e07b76d9fd1c894398fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*LuSnSTo9z7tm_cnE.jpg"/></div></figure><p id="733a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在这篇文章中，我们用Python查看了9/11数据集，看看我们能从中得出什么样的见解。</p><h2 id="ad81" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">获取数据集</h2><p id="302a" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">我们正在研究的数据集位于Kaggle。你可以在<a class="ae kj" href="https://www.kaggle.com/mchirico/montcoalert" rel="noopener ugc nofollow" target="_blank">紧急事件-911电话| Kaggle </a>找到这个数据集</p><p id="af91" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这是一个非常全面的数据集。它列出了包括位置、日期、呼叫类型、邮政编码、地址和描述在内的列。在这篇文章中，我们将探索数据集，不会应用任何机器学习算法。</p><p id="f045" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我没有提到代码的输出，因为我已经上传了完整的IPython内核，在<a class="ae kj" href="https://www.kaggle.com/prahauk/analysis-for-the-type-of-calls" rel="noopener ugc nofollow" target="_blank">分析调用类型| Kaggle </a></p><h2 id="edfb" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">导入库</h2><p id="bee0" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">首先，我们将导入所需的库。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="4f78" class="jj jk hh kp b fi kt ku l kv kw"># Imports import pandas as pd import numpy as np import matplotlib.pyplot as plt from plotly import __version__ from plotly.offline import download_plotlyjs, init_notebook_mode, plot, iplot import cufflinks as cf import plotly.graph_objects as go</span></pre><p id="0f57" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这些只是任何Python笔记本中用于机器学习的标准库。</p><h2 id="5b70" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">了解数据集</h2><p id="fbb5" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">现在，我们已经导入了库，是时候理解数据集了。</p><p id="2318" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这将显示数据集中涉及的列。我们有以下栏目:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="8017" class="jj jk hh kp b fi kt ku l kv kw">['lat', 'lng', 'desc', 'zip', 'title', 'timeStamp', 'twp', 'addr', 'e']</span></pre><p id="91e5" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">现在，如果查看数据集，我们可以看到我们的目的需要一些列。我们将使用以下代码删除这些列:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="89c8" class="jj jk hh kp b fi kt ku l kv kw">df = df[['lat', 'lng', 'title', 'timeStamp', 'twp', 'e']] df.head(3)</span></pre><h2 id="1844" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">清理数据集</h2><p id="edd6" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">首先，我们将看到空值，看看它们是否需要修复。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="8765" class="jj jk hh kp b fi kt ku l kv kw">print(df.isnull().sum()) print(len(df))</span></pre><p id="d9e2" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">当我们运行它时，我们看到twp列有<strong class="in hi"> 293 </strong>个空行。有663522行。如果我们删除twp为null的行，不会有太大的危害。毕竟，我无法获得这些行的数据。另一个选择是在这里引入<strong class="in hi">【未指定】</strong>城镇。</p><p id="d838" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">接下来，我们看到数据集的<strong class="in hi">标题</strong>列中的唯一值。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="1f77" class="jj jk hh kp b fi kt ku l kv kw">df['title'].unique()</span></pre><p id="b6be" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">运行上面的代码，返回如下内容:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="9778" class="jj jk hh kp b fi kt ku l kv kw">array(['EMS: BACK PAINS/INJURY', 'EMS: DIABETIC EMERGENCY', 'Fire: GAS-ODOR/LEAK', 'EMS: CARDIAC EMERGENCY', 'EMS: DIZZINESS', 'EMS: HEAD INJURY', 'EMS: NAUSEA/VOMITING', 'EMS: RESPIRATORY EMERGENCY', 'EMS: SYNCOPAL EPISODE', 'Traffic: VEHICLE ACCIDENT -', 'EMS: VEHICLE ACCIDENT', 'Traffic: DISABLED VEHICLE -', 'Fire: APPLIANCE FIRE',</span></pre><p id="1191" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">清晰的图案清晰可见。存在第一种类型，描述由冒号(:)分隔。我们用冒号分割数组项，以分离类型和描述。下面是实现这一点的代码:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="9af7" class="jj jk hh kp b fi kt ku l kv kw">df['type'] = df['title'].apply(lambda title: title.split(":")[0]) df['type explanation'] = df['title'].apply(lambda title: title.split(":")[1])</span></pre><h2 id="1d9d" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">处理日期列</h2><p id="33b9" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">最后，我们需要处理日期列。当我们看到日期列的类型时，我们看到它的<strong class="in hi"> str </strong>类型。因此，我们将采取以下措施:</p><ul class=""><li id="63a3" class="kx ky hh in b io ip is it iw kz ja la je lb ji lc ld le lf bi translated">将日期列从<strong class="in hi"> str </strong>类型转换为<strong class="in hi"> date </strong>类型。</li><li id="7a41" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">将数据集的索引设置为datetime列。</li><li id="28b1" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">我们将日期时间分为四个部分:早晨、下午、晚上、夜晚。</li></ul><p id="4b1f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">下面是要实现的代码:</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="7ad9" class="jj jk hh kp b fi kt ku l kv kw">df['Day of Week'] = df['timeStamp'].apply(lambda time: time.dayofweek) df['Day of Week'] = df['Day of Week'].map({0: 'Monday', 1: 'Tuesday', 2: 'Wednesday', 3: 'Thursday', 4: 'Friday', 5: 'Saturday', 6: 'Sunday'}) df['Month No'] = df['timeStamp'].apply(lambda time: time.month) df['Month'] = df['Month No'].map({1: 'January', 2: 'Febuary', 3: 'March', 4: 'April', 5: 'May', 6: 'June',7: 'July', 8: 'August', 9: 'September', 10: 'October', 11: 'November',12: 'December'}) df['Hour'] = df['timeStamp'].apply(lambda time: time.hour) df.loc[(df.Hour &gt;= 6) &amp; (df.Hour &lt; 12) , 'Time of Day'] = 'Morning' df.loc[(df.Hour &gt;= 12) &amp; (df.Hour &lt; 15) , 'Time of Day'] = 'Afternoon' df.loc[(df.Hour &gt;= 15) &amp; (df.Hour &lt; 18) , 'Time of Day'] = 'Evening' df.loc[(df.Hour &gt;= 18) | (df.Hour &lt; 6) , 'Time of Day'] = 'Night'</span></pre><h2 id="3ac3" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">绘制图表</h2><p id="a103" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">这里我没有粘贴图表。然而，我们将着眼于我们如何策划。首先，我们需要配置袖扣。</p><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="b65c" class="jj jk hh kp b fi kt ku l kv kw">init_notebook_mode(connected=True) cf.go_offline()</span></pre><p id="3c72" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">我们绘制了以下图表:</p><ul class=""><li id="218b" class="kx ky hh in b io ip is it iw kz ja la je lb ji lc ld le lf bi translated">用条形图绘制数值计数。</li><li id="b4f9" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">我们每天都看到打字的趋势。</li><li id="c763" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">每天的呼叫类型</li><li id="e5ce" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">每月类型和每小时类型</li><li id="5457" class="kx ky hh in b io lg is lh iw li ja lj je lk ji lc ld le lf bi translated">最后，我们绘制出地理日期和通话次数。</li></ul><pre class="kk kl km kn fd ko kp kq kr aw ks bi"><span id="1e17" class="jj jk hh kp b fi kt ku l kv kw">geo_data = df.groupby(['lat', 'lng']).size().reset_index().rename(columns={0: "no of calls"}) fig = go.Figure(data=go.Scattergeo( locationmode = 'USA-states', lon = geo_data['lng'], lat = geo_data['lat'], text = geo_data['no of calls'], mode = 'markers', marker = dict( size = 2, opacity = 0.8, reversescale = True, autocolorscale = False, line = dict( width=1, color='rgba(102, 102, 102)' ), colorscale = 'Blues', cmin = 0, color = geo_data['no of calls'], cmax = geo_data['no of calls'].max(), colorbar_title="Plot of the Calls" ))) fig.update_layout( title = 'Hover for County Name', geo = dict( scope='usa', projection_type='albers usa', showland = True, landcolor = "rgb(250, 250, 250)", subunitcolor = "rgb(217, 217, 217)", countrycolor = "rgb(217, 217, 217)", countrywidth = 0.5, subunitwidth = 0.5 ), ) fig.show()</span></pre><h2 id="273a" class="jj jk hh bd jl jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd bi translated">结论</h2><p id="b503" class="pw-post-body-paragraph il im hh in b io ke iq ir is kf iu iv iw kg iy iz ja kh jc jd je ki jg jh ji ha bi translated">这是一篇简单的文章，我们在其中对一个奇妙的数据集进行了一些分析。这样做，我们可以看到什么时候打电话，哪种类型的电话是在哪天打的，每月等等。</p><p id="f8eb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">你可以自由使用这段代码并分享文章。跟随我的 <a class="ae kj" href="https://github.com/umairk83" rel="noopener ugc nofollow" target="_blank"> <em class="ll"> Github </em> </a> <em class="ll">资源库找到完整代码。</em></p></div><div class="ab cl lm ln go lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ha hb hc hd he"><p id="ab8c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><em class="ll">最初发表于2021年1月1日https://buildwithuk.com</em><em class="ll">的</em> <a class="ae kj" href="https://buildwithuk.com/2021/01/02/exploring-9-11-dataset/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">。</em></a></p></div></div>    
</body>
</html>