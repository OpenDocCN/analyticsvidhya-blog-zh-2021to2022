<html>
<head>
<title>GETTING STARTED WITH KUBERNETES</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">KUBERNETES入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-kubernetes-f64471da5aa3?source=collection_archive---------14-----------------------#2021-05-21">https://medium.com/analytics-vidhya/getting-started-with-kubernetes-f64471da5aa3?source=collection_archive---------14-----------------------#2021-05-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/4b4b02aa5a202270d506ced825a6a475.png" data-original-src="https://miro.medium.com/v2/resize:fit:968/format:webp/1*HWZB3tU0qjzOoFrLQ0yUkg.png"/></div></figure><h2 id="7374" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">什么是KUBERNETES？</strong></h2><p id="f205" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">在我们进入Kubernetes及其有用性之前，有必要熟悉两个概念:不可变的基础设施和容器。</p><p id="76cc" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated"><strong class="jl hi">不可变的基础设施</strong>是一种实践，其中服务器一旦被部署，就永远不会被修改。如果需要更改，不要直接在服务器上进行。相反，您将从一个基本映像构建一个新的服务器，其中包含了您需要的所有更改。这样，我们可以简单地用新服务器替换旧服务器，而无需任何额外的修改。</p><p id="0415" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated"><strong class="jl hi">容器</strong>提供了一种打包代码、运行时、系统工具、系统库和配置的方法。这个版本是一个轻量级的独立可执行文件。这样，无论你的应用程序在哪里运行，它的行为都是一样的。).集装箱化并不是一个新概念，但随着微服务和Docker的兴起，它变得非常流行。</p><p id="ca7e" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">有了这些概念，我们现在就能够将<strong class="jl hi"> Kubernetes </strong>描述为协调计算、网络和存储基础设施工作负载的容器或微服务平台。您可以定义您的应用程序应该如何运行，以及它们应该与其他应用程序或外部世界交互的方式。您可以扩大或缩小您的服务，执行平滑的滚动更新，并在不同版本的应用程序之间切换流量，以测试功能或回滚有问题的部署。Kubernetes提供了接口和可组合平台原语，允许您以高度的灵活性、功能和可靠性来定义和管理您的应用程序。</p><h2 id="2725" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">目标</strong></h2><p id="34ff" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">前一段时间，我在Docker Swarm上工作，这是一个很棒的工具，它通过创建一个Docker主机集群，指数级地增加了Docker的功能。类似地，Kubernetes是Google创建的一个开源平台，用于容器部署操作、扩展和缩减，以及跨主机集群的自动化。</p><p id="8448" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">尽管这两个开源编排平台提供了许多相同的功能，但这两个平台的操作方式还是有一些基本的区别。</p><p id="eaea" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">因此，我在这里整合或讨论使用Kubernetes创建和部署服务的步骤，以方便像我一样的其他极客访问。你可以看看我的另一个博客，我在那里讨论过<a class="ae kj" rel="noopener" href="/analytics-vidhya/docker-swarm-creating-deploying-services-a0da071339d3"><em class="kk">Docker Swarm</em></a><em class="kk">。</em></p><h2 id="3965" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">步骤1:安装kubenetes </strong></h2><p id="54bd" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">安装Kubernetes的方法有很多。本练习中使用的Kubeadm 是安装Kubernetes的一般方法。它可以在各种公共云和私有云上使用。但是，它也可以在裸机上使用。<strong class="jl hi"> Minikube </strong>是一种安装Kubernetes的虚拟化方法。<strong class="jl hi"> Kops </strong>是在亚马逊网络服务上安装Kubernetes的工具。kops实用程序为Kubernetes实施了许多企业标准。比如处理器、实例大小。所以，我们不能利用kops的自由层。Kops也利用了其他AWS资源，Kubernetes用于Google云平台。因此，有一个在Google Cloud上安装Kubernetes的工具。</p><p id="48f9" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">在这篇博客中，我们将看看在Amazon Web Services上安装Kubernetes，而不是用Kops。因此，我们能够使用AWS自由层。在这些步骤中，可以在任何环境下工作，AWS、Azure、Google Cloud、裸机等等。</p><p id="4351" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">因此，我们将从AWS控制台开始，我们将启动实例。我们将创建两个实例，一个名为<em class="kk"> Kube-Master </em>和<em class="kk"> Kube-Worker </em>。我们将选择Ubuntu server 18.04 LTS，64位，并选择t2.micro实例，这实际上不在Kubernetes的要求范围内，但可以使用。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es kl"><img src="../Images/e583fc3d7590527b34dad995375fd704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*h29885qQLn6tVY916H2Vog.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">EC2实例</figcaption></figure><p id="fe35" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">如您所见，我们的实例现在已经就绪！</p><p id="f695" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">现在，当我们准备好连接时，我们将选择每个实例，单击“连接”，我们将有机会进行连接。</p><p id="a22a" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">有多种方法可以连接到实例。我们将使用Git Bash进行连接。因此，请查阅文档，但也有其他连接方式。我所做的是，我只是改变了主节点和工作节点的主机名。这样，我们可以很容易地将它们区分开来。</p><p id="a62d" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">/<em class="kk">etc</em>/<em class="kk">hostname</em>是存储节点名称的目录。使用，</p><blockquote class="ku kv kw"><p id="9438" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">vim /etc/hostname</p></blockquote><p id="2915" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">对目录进行更改。我们现在将安装kubeadm。</p><p id="d450" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">遵循这些命令并在主服务器和工作服务器上执行它们，如果您已经使用另一个用户登录，那么我们可以使用下面的命令切换到根用户:<em class="kk"> sudo su </em></p><blockquote class="ku kv kw"><p id="962a" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-get更新</p><p id="e151" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-get安装docker.io</p><p id="cb27" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-get install-y apt-transport-https ca-certificates curl</p><p id="9dfa" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo curl-fsSLo/usr/share/keyrings/kubernetes-archive-keyring . gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg</p><p id="cc81" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">echo " deb[signed-by =/usr/share/keyrings/kubernetes-archive-keyring . gpg]https://apt.kubernetes.io/·库伯内特-xenial main " | sudo tee/etc/apt/sources . list . d/kubernetes . list</p><p id="f2bd" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-get更新</p><p id="3c1c" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-get install-y kube let kube ADM kube CTL</p><p id="d8ff" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo apt-mark hold kube let kube ADM kube CTL</p></blockquote><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es la"><img src="../Images/d992e73d862918bf46208c42f62a550f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1218/format:webp/1*R5nLdPyLfr1-yfO5T6aYNg.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">在主节点和工作节点上安装kubeadm</figcaption></figure><h2 id="d398" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">步骤2:初始化集群</strong></h2><p id="f14b" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">现在，我们将初始化集群，然后我们将在主节点上运行大部分内容。</p><p id="3dcc" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">有一点很重要，我们必须回到控制台，获取主节点的私有IP地址。因此，我们将选择我们的主节点，并在描述下，我们将获得私有IP。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lb"><img src="../Images/b7ed68ca0f3b57a4f4b339498ff0fb42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*zOSAWEK2yKs9BGoHrO-cng.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">复制主节点的私有IPv4地址</figcaption></figure><p id="3373" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">下面是我们将用于初始化的命令:</p><blockquote class="ku kv kw"><p id="512b" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">kube ADM init—-API server-advertise-address =<private_instance_ip>—-pod-network-CIDR =<cidr_block/></private_instance_ip></p></blockquote><p id="06f6" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">你可以看到我们传入的参数。因为我们将要使用的网络插件，我们有一些特定的参数。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/ec2d3e4703ad0ce5ca83f80992aa9006.png" data-original-src="https://miro.medium.com/v2/resize:fit:1202/format:webp/1*4JUzW74gTGGATx7GpmgsUw.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">飞行前检查失败</figcaption></figure><p id="dd9a" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">由于我们使用的是自由层，我们将无法通过飞行前检查，即飞行前状态。因此，我们要做的是，抑制这些错误和警告。我们将传递这个标志来抑制CPU数量和内存限制错误，</p><blockquote class="ku kv kw"><p id="0794" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">--忽略-预检-错误= <parameters/></p></blockquote><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es ld"><img src="../Images/7aa6a64f63ee5c515a37c13ada5d1ec4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*JHRge46un9U2zRR7yL1QUg.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">通过飞行前检查</figcaption></figure><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es le"><img src="../Images/967cca52298f4584c1172380360c8496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*FtMP8bQVXF1dZUY6bvfZeQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">初始化完成</figcaption></figure><p id="724d" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">如果集群初始化成功，我们将看到一个集群加入命令。worker节点将使用这个命令来加入Kubernetes集群，因此复制这个命令并保存起来以供将来使用。要开始使用集群，我们必须在主节点上设置环境变量。</p><p id="d4d5" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">要在主节点上临时设置环境变量，请运行以下命令:</p><blockquote class="ku kv kw"><p id="2c71" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">mkdir -p $HOME/。库贝</p><p id="9239" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo CP-I/etc/kubernetes/admin . conf $ HOME/。kube/配置</p><p id="29ed" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">sudo chown $(id -u):$(id -g) $HOME/。kube/配置</p></blockquote><p id="c905" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">或者，如果您是root用户，您可以运行:</p><blockquote class="ku kv kw"><p id="be83" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">导出kube config =/etc/kubernetes/admin . conf</p></blockquote><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/11bde8551a22fb8a12fe725d2942f1d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*CP6TMUMLxHqoJh5_e55rJw.png"/></div></figure><h2 id="b33a" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">步骤3:将worker节点加入kubernetes集群</strong></h2><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lg"><img src="../Images/364c2b87942e9851230488bdd23d076a.png" data-original-src="https://miro.medium.com/v2/resize:fit:870/format:webp/1*wWcGm28hYONpAMg9cegOtA.png"/></div></figure><p id="2143" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">SSH进入Worker节点，并在该节点上运行kubeadm init生成的命令。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/14becd6b06e586beaf2be3daecb2cab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*EqIUGea_WSSs2C8Se-PbRQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">节点已加入群集</figcaption></figure><p id="c2d1" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">在创建集群并加入工作节点之后，我们必须确保一切都正常工作。要查看和验证集群状态，我们可以在主节点上使用kubectl命令</p><p id="8419" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated"><strong class="jl hi"><em class="kk">ku bectl get Nodes</em></strong><em class="kk"/>查看我们的节点(master和worker)的状态是否准备好。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="er es li"><img src="../Images/b8eb2bf02e6c875201309792407859e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*cxMnjpqFohME1tuAAA2jVg.png"/></div></div></figure><p id="192d" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们得到这个“未就绪”状态。我们得到这个未就绪状态的原因是因为我们还没有安装我们的网络插件。</p><p id="2bbe" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">可以部署多种网络接口。对于这个简单的例子，我使用了印花布。只需从您的一个节点应用这个清单。</p><blockquote class="ku kv kw"><p id="ea16" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated"><em class="hh">库贝克特尔应用-f https://docs.projectcalico.org/v3.9/manifests/calico.yaml</em></p></blockquote><p id="9e9d" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">再次运行kubectl get nodes。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es ln"><img src="../Images/827ad61ffa6a0510aa6e353daf2c3c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1088/format:webp/1*Bqh-5l3drEmowGNN9dQltg.png"/></div></figure><p id="f561" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">然后我们可以看到pod现在已经“就绪”。</p><h2 id="b9bc" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">步骤4:测试kubernetes集群</strong></h2><p id="cdba" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">现在我们已经有了一个集群，让我们看看Kubernetes提供的一些特性。</p><p id="aee5" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">让我们部署一个应用程序。Nginx 是Kubernetes的学习应用之一。对于这个练习来说，没问题。nginx是测试应用程序之一，它是一个web服务器。因此，我们要做的是为nginx创建一个部署。</p><p id="2331" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们将调用部署基础——nginx，使用</p><blockquote class="ku kv kw"><p id="9032" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">创建部署— —图片&lt;&gt;</p></blockquote><p id="9ea8" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">在本例中，映像名是nginx，我们的部署名是base-nginx。然后创建一个部署。</p><p id="3c2b" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">运行一个命令来获取pod:<strong class="jl hi"><em class="kk">ku bectl get pods</em></strong>，我们可以看到到目前为止我们有一个pod在运行。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lo"><img src="../Images/459960c2683fb8ccfc970e96c0d8a823.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*MSraDm3va3TNU57mOVriuw.png"/></div></figure><p id="ce71" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们还可以描述pod以列出详细信息，包括pod运行的节点。因此，当我们运行此命令时，我们将选择列出的一个单元。我们实际上可以看到pod正在工作节点上运行，因为我们将看到工作节点的私有IP地址。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lf"><img src="../Images/9e02f1b04856b8620b914f0217b2a767.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*9SsoR30IEEiWM-cJDIf5XA.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">在工作节点上运行的Pod</figcaption></figure><p id="1f08" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">为了访问应用程序，我们需要一个服务。服务是用户和运行端口之间的附加抽象层。因此，我们将使用服务来公开部署，在本例中，它的类型是<strong class="jl hi"> NodePort </strong>。所以，我们需要输入</p><blockquote class="ku kv kw"><p id="d1a3" class="jj jk kk jl b jm ke jo jp jq kf js jt kx kg jv jw ky kh jy jz kz ki kb kc kd ha bi translated">kubectl创建服务节点端口</p></blockquote><p id="370c" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这就是服务的类型。这是将您的服务公开为可在集群外部访问的最基本选项，在集群中每个节点上的特定端口(称为节点端口)上。</p><p id="27d6" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">让服务名称与您的部署名称相同是一个很好的做法，我们会说— TCP，公开端口，然后是执行端口，因为nginx有一个端口80，它也在端口80上运行。所以，我们想公开80，这个应用程序运行在端口80上。</p><p id="d813" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这里我们可以看到kubectl创建了NodePort类型的服务。服务名是base-nginx，我们在这里可以看到——TCP暴露端口和执行端口。您可以在这里看到，获得部署，我们看到部署名称，我们希望服务具有相同的名称，因此我们可以在这里看到我们在这里运行命令。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lh"><img src="../Images/bfe19122b0b5fd2877edf42303a3d54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*IDkafOEVww7XFJwHXq80SA.png"/></div></figure><p id="0a22" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">同样，我们想要做的是，我们还想要获取我们的应用程序映射到的端口。如果我们运行前面运行过的命令kubectl get services，我们可以找到我们的服务，并且可以查看我们的端口映射。</p><p id="50a4" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">现在，我们想建立一个网址。URL将是节点的公共IP地址或公共DNS名称、冒号和端口，即我们刚刚看到的服务端口，即映射端口。在本例中，端口是30462。</p><p id="819e" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们把网址放在浏览器中，我们可以看到nginx的主页。所以，这是我们的工人节点用完了。您可以对工作节点的公共DNS名称做同样的事情，我们可以在第页看到ngnix。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lp"><img src="../Images/54860aec932e51f9f3875992c81963b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*kWL3ewrXr3VgAGCXvbcCOw.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">使用公共DNS名称</figcaption></figure><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lq"><img src="../Images/f2211f623ff5390a625f99dfd7fd641a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*kAAEgv8KKmNW7xh6xkizGQ.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">使用公共IP</figcaption></figure><p id="0b3f" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">Kubernetes的一大好处是它可以自我修复或自我康复。如果我们删除一个pod或一个复制副本，将会模拟pod丢失或复制副本故障。所以，我们会运行命令，<strong class="jl hi">再次得到吊舱</strong>。然后，我们将<strong class="jl hi">运行kubectl delete pod </strong>并传递完整的pod名称。</p><figure class="km kn ko kp fd ii er es paragraph-image"><div class="er es lr"><img src="../Images/2ad06206d1e6d0c300613fc22400df64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/1*H86HXloTaTILKpw_JvFBBw.png"/></div><figcaption class="kq kr et er es ks kt bd b be z dx translated">自愈</figcaption></figure><p id="97b5" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">如果我们运行<em class="kk"> kubectl get pods </em>，我们将在这里看到清单，并注意到我们在那里有了一个新的pod名称。我们失去了一个分离舱，但现在我们有了一个新的复制品。它是自动提出来的。</p><h2 id="eaf1" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">结论</strong></h2><p id="0fb3" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">这样，我们成功地在AWS上的单一主Kubernetes集群上配置和部署了NGINX。我们还研究了kubernetes的一个主要特征，即自愈能力。</p><p id="885b" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">Kubeadm是一种替代方法，但在AWS上仍然推荐kops。Kubeadm建立了一个最小可行的集群，但是不能提供您的基础设施，这是与kops的主要区别之一。另一个不同之处是Kubeadm不仅可以用作安装程序，还可以用作构建块。</p><p id="ee65" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated"><em class="kk">为改进和提高的范围提供您的宝贵反馈。</em></p></div></div>    
</body>
</html>