<html>
<head>
<title>Checkers-Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">跳棋-Python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/checkers-python-eff2786b985b?source=collection_archive---------1-----------------------#2021-02-05">https://medium.com/analytics-vidhya/checkers-python-eff2786b985b?source=collection_archive---------1-----------------------#2021-02-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/0f2f4b2880a38abccb9cc3acb4bea522.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3hPas9kFr2-NkCUsU8K7xQ.png"/></div></div></figure><p id="ff6f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在过去的两天里，我花了几个小时在python上编写了一个简单的checkers。总的来说，这个项目确实教会了我很多关于组织变量和装饰器使用的经验，尽管它们都没有进入应用程序的最终代码。如果有人试图自己开发应用程序，我建议您使用网格代码，然后自己尝试实现代码。为了提高代码的效率，我还建议您不要使用单独的2d数组来执行所有的检查；相反，挑战你自己，在包含所有部分的网格阵列上运行所有的东西。源代码将包含在下面:</p><pre class="jo jp jq jr fd js jt ju jv aw jw bi"><span id="0078" class="jx jy hi jt b fi jz ka l kb kc">import pygame<br/>import random<br/>import sys<br/>from itertools import combinations<br/><br/><br/>WIDTH = 800<br/>ROWS = 8<br/><br/>RED= pygame.image.load('red.png')<br/>GREEN= pygame.image.load('green.png')<br/><br/>REDKING = pygame.image.load('redKing.png')<br/>GREENKING = pygame.image.load('greenKing.png')<br/><br/>WHITE = (255,255,255)<br/>BLACK = (0,0,0)<br/>ORANGE = (235, 168, 52)<br/>BLUE = (76, 252, 241)<br/><br/><br/>pygame.init()<br/>WIN = pygame.display.set_mode((WIDTH,WIDTH))<br/>pygame.display.set_caption('Checkers')<br/><br/>priorMoves=[]<br/>class Node:<br/>    def __init__(self, row, col, width):<br/>        self.row = row<br/>        self.col = col<br/>        self.x = int(row * width)<br/>        self.y = int(col * width)<br/>        self.colour = WHITE<br/>        self.piece = None<br/><br/>    def draw(self, WIN):<br/>        pygame.draw.rect(WIN, self.colour, (self.x, self.y, WIDTH / ROWS, WIDTH / ROWS))<br/>        if self.piece:<br/>            WIN.blit(self.piece.image, (self.x, self.y))<br/><br/><br/>def update_display(win, grid, rows, width):<br/>    for row in grid:<br/>        for spot in row:<br/>            spot.draw(win)<br/>    draw_grid(win, rows, width)<br/>    pygame.display.update()<br/><br/><br/>def make_grid(rows, width):<br/>    grid = []<br/>    gap = width// rows<br/>    count = 0<br/>    for i in range(rows):<br/>        grid.append([])<br/>        for j in range(rows):<br/>            node = Node(j,i, gap)<br/>            if abs(i-j) % 2 == 0:<br/>                node.colour=BLACK<br/>            if (abs(i+j)%2==0) and (i&lt;3):<br/>                node.piece = Piece('R')<br/>            elif(abs(i+j)%2==0) and i&gt;4:<br/>                node.piece=Piece('G')<br/>            count+=1<br/>            grid[i].append(node)<br/>    return grid<br/><br/><br/>def draw_grid(win, rows, width):<br/>    gap = width // ROWS<br/>    for i in range(rows):<br/>        pygame.draw.line(win, BLACK, (0, i * gap), (width, i * gap))<br/>        for j in range(rows):<br/>            pygame.draw.line(win, BLACK, (j * gap, 0), (j * gap, width))<br/><br/><br/>class Piece:<br/>    def __init__(self, team):<br/>        self.team=team<br/>        self.image= RED if self.team=='R' else GREEN<br/>        self.type=None<br/><br/>    def draw(self, x, y):<br/>        WIN.blit(self.image, (x,y))<br/><br/><br/>def getNode(grid, rows, width):<br/>    gap = width//rows<br/>    RowX,RowY = pygame.mouse.get_pos()<br/>    Row = RowX//gap<br/>    Col = RowY//gap<br/>    return (Col,Row)<br/><br/><br/>def resetColours(grid, node):<br/>    positions = generatePotentialMoves(node, grid)<br/>    positions.append(node)<br/><br/>    for colouredNodes in positions:<br/>        nodeX, nodeY = colouredNodes<br/>        grid[nodeX][nodeY].colour = BLACK if abs(nodeX - nodeY) % 2 == 0 else WHITE<br/><br/>def HighlightpotentialMoves(piecePosition, grid):<br/>    positions = generatePotentialMoves(piecePosition, grid)<br/>    for position in positions:<br/>        Column,Row = position<br/>        grid[Column][Row].colour=BLUE<br/><br/>def opposite(team):<br/>    return "R" if team=="G" else "G"<br/><br/>def generatePotentialMoves(nodePosition, grid):<br/>    checker = lambda x,y: x+y&gt;=0 and x+y&lt;8<br/>    positions= []<br/>    column, row = nodePosition<br/>    if grid[column][row].piece:<br/>        vectors = [[1, -1], [1, 1]] if grid[column][row].piece.team == "R" else [[-1, -1], [-1, 1]]<br/>        if grid[column][row].piece.type=='KING':<br/>            vectors = [[1, -1], [1, 1],[-1, -1], [-1, 1]]<br/>        for vector in vectors:<br/>            columnVector, rowVector = vector<br/>            if checker(columnVector,column) and checker(rowVector,row):<br/>                #grid[(column+columnVector)][(row+rowVector)].colour=ORANGE<br/>                if not grid[(column+columnVector)][(row+rowVector)].piece:<br/>                    positions.append((column + columnVector, row + rowVector))<br/>                elif grid[column+columnVector][row+rowVector].piece and\<br/>                        grid[column+columnVector][row+rowVector].piece.team==opposite(grid[column][row].piece.team):<br/><br/>                    if checker((2* columnVector), column) and checker((2* rowVector), row) \<br/>                            and not grid[(2* columnVector)+ column][(2* rowVector) + row].piece:<br/>                        positions.append((2* columnVector+ column,2* rowVector+ row ))<br/><br/>    return positions<br/><br/><br/>"""<br/>Error with locating opssible moves row col error<br/>"""<br/>def highlight(ClickedNode, Grid, OldHighlight):<br/>    Column,Row = ClickedNode<br/>    Grid[Column][Row].colour=ORANGE<br/>    if OldHighlight:<br/>        resetColours(Grid, OldHighlight)<br/>    HighlightpotentialMoves(ClickedNode, Grid)<br/>    return (Column,Row)<br/><br/>def move(grid, piecePosition, newPosition):<br/>    resetColours(grid, piecePosition)<br/>    newColumn, newRow = newPosition<br/>    oldColumn, oldRow = piecePosition<br/><br/>    piece = grid[oldColumn][oldRow].piece<br/>    grid[newColumn][newRow].piece=piece<br/>    grid[oldColumn][oldRow].piece = None<br/><br/>    if newColumn==7 and grid[newColumn][newRow].piece.team=='R':<br/>        grid[newColumn][newRow].piece.type='KING'<br/>        grid[newColumn][newRow].piece.image=REDKING<br/>    if newColumn==0 and grid[newColumn][newRow].piece.team=='G':<br/>        grid[newColumn][newRow].piece.type='KING'<br/>        grid[newColumn][newRow].piece.image=GREENKING<br/>    if abs(newColumn-oldColumn)==2 or abs(newRow-oldRow)==2:<br/>        grid[int((newColumn+oldColumn)/2)][int((newRow+oldRow)/2)].piece = None<br/>        return grid[newColumn][newRow].piece.team<br/>    return opposite(grid[newColumn][newRow].piece.team)<br/><br/><br/><br/><br/>def main(WIDTH, ROWS):<br/>    grid = make_grid(ROWS, WIDTH)<br/>    highlightedPiece = None<br/>    currMove = 'G'<br/><br/>    while True:<br/>        for event in pygame.event.get():<br/>            if event.type== pygame.QUIT:<br/>                print('EXIT SUCCESSFUL')<br/>                pygame.quit()<br/>                sys.exit()<br/><br/>            if event.type == pygame.MOUSEBUTTONDOWN:<br/>                clickedNode = getNode(grid, ROWS, WIDTH)<br/>                ClickedPositionColumn, ClickedPositionRow = clickedNode<br/>                if grid[ClickedPositionColumn][ClickedPositionRow].colour == BLUE:<br/>                    if highlightedPiece:<br/>                        pieceColumn, pieceRow = highlightedPiece<br/>                    if currMove == grid[pieceColumn][pieceRow].piece.team:<br/>                        resetColours(grid, highlightedPiece)<br/>                        currMove=move(grid, highlightedPiece, clickedNode)<br/>                elif highlightedPiece == clickedNode:<br/>                    pass<br/>                else:<br/>                    if grid[ClickedPositionColumn][ClickedPositionRow].piece:<br/>                        if currMove == grid[ClickedPositionColumn][ClickedPositionRow].piece.team:<br/>                            highlightedPiece = highlight(clickedNode, grid, highlightedPiece)<br/><br/><br/>        update_display(WIN, grid,ROWS,WIDTH)<br/><br/><br/>main(WIDTH, ROWS)</span></pre><p id="6fb2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">当涉及到游戏逻辑的编程时，没有什么是过于复杂的，这个游戏几乎是我以前制作的象棋游戏的简化，但是这个程序增加了特定的复杂性，如果玩家杀死一个棋子，我们需要给他们增加额外的移动，如果他们能够杀死一个棋子，我们需要改变一个棋子的潜在移动。我确实试图尽可能地将我的代码分割成函数，以使任何查看代码的人都能理解。</p><p id="3247" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用decorators，您可以添加检查玩家何时赢得游戏的功能。你可以用一个静态的方法来计算每一方移动后的棋子数量，如果数量为0，那么对方就赢了。如果你从未听说过装修工</p><figure class="jo jp jq jr fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="76a7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">本质上，装饰者所做的就是在你已经创建的函数上添加额外的功能。</p><p id="23ce" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">注意:如果你要复制我的源代码，你需要找到一些新的作品来展示在黑板上，并把它们命名为green.png、red.png等。还要注意的是，我在我的图像上使用了背景去除剂，你可以很容易地在网上找到，你可以通过绘画降低图像的尺寸。</p><p id="876c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果您对代码有任何问题，请留下您的评论，我会回复您可能需要的任何指导。我希望这篇文章有用！</p></div></div>    
</body>
</html>