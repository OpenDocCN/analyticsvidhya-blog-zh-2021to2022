<html>
<head>
<title>Logistic Regression With PyTorch — A Beginner Guide</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PyTorch逻辑回归—初学者指南</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/logistic-regression-with-pytorch-a-beginner-guide-33c2266ad129?source=collection_archive---------7-----------------------#2021-05-14">https://medium.com/analytics-vidhya/logistic-regression-with-pytorch-a-beginner-guide-33c2266ad129?source=collection_archive---------7-----------------------#2021-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="09e5" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">基于数据集——小麦种子种类预测</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/decb1d09a120255639e4852ba51f8f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UFP3R5b8C4hZJe4g"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">Evi Radauscher 在<a class="ae jm" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="8e94" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">如果您想开始使用PyTorch，但又不确定从哪个数据集开始，那么您来对地方了。我们看到PyTorch在经典机器学习到深度神经网络中的实现。我等不及要开始了，但是在我们开始之前，让我们先回答几个基本问题——</p><ol class=""><li id="f473" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated"><strong class="jp hi">py torch是什么？PyTorch是由脸书人工智能研究小组开发的开源、社区驱动的深度学习框架。PyTorch广泛用于一些深度学习应用，如自然语言处理、计算机视觉应用、图像分类、迁移学习等。</strong></li><li id="483b" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><strong class="jp hi">py torch中的张量是什么？<br/> </strong>张量是n维矩阵。张量是PyTorch库的核心，用于深度学习中的高效计算。零阶张量是一个数。一阶张量是一组数字，即一个向量。二阶张量是一组向量，或称矩阵。与NumPy数组不同，我们也可以在GPU上使用张量，这为我们带来了更快计算速度的优势。</li></ol><h1 id="ce59" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">关于数据集</h1><p id="4b5e" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">小麦种子数据集对于PyTorch基础知识的入门非常简单。<br/>小麦种子数据集涉及给定来自不同小麦品种的种子测量值的物种预测。</p><h1 id="0c49" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">目录</h1><ol class=""><li id="a353" class="kj kk hh jp b jq lq jt lr jw lv ka lw ke lx ki ko kp kq kr bi translated"><a class="ae jm" href="#4e59" rel="noopener ugc nofollow">简介</a></li><li id="ad0d" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#7050" rel="noopener ugc nofollow">数据预处理</a> <br/> 2.1 <a class="ae jm" href="#4c45" rel="noopener ugc nofollow">加载所需库</a> <br/> 2.2 <a class="ae jm" href="#e760" rel="noopener ugc nofollow">获取数据</a></li><li id="e4eb" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#e652" rel="noopener ugc nofollow">特征分析</a> <br/> 3.1 <a class="ae jm" href="#45d4" rel="noopener ugc nofollow">面积vs内核长度</a> <br/> 3.2 <a class="ae jm" href="#6064" rel="noopener ugc nofollow">面积vs内核宽度</a> <br/> 3.3 <a class="ae jm" href="#75c7" rel="noopener ugc nofollow">绘图槽vs周长</a> <br/> 3.4 <a class="ae jm" href="#646a" rel="noopener ugc nofollow">面积vs内核槽</a></li><li id="751d" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#65d5" rel="noopener ugc nofollow">建立PyTorch模型</a> <br/> 4.1 <a class="ae jm" href="#d2f5" rel="noopener ugc nofollow">预处理和创建数据加载器</a> <br/> 4.2 <a class="ae jm" href="#ae3e" rel="noopener ugc nofollow">模型创建</a> <br/> 4.3 <a class="ae jm" href="#c67b" rel="noopener ugc nofollow">训练模型</a> <br/> 4.4 <a class="ae jm" href="#94b3" rel="noopener ugc nofollow">绘制损耗和精度</a></li><li id="076d" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#2cbe" rel="noopener ugc nofollow">总结</a></li><li id="1ba1" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#d9a7" rel="noopener ugc nofollow">未来工作</a></li><li id="983d" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="#29ca" rel="noopener ugc nofollow">参考文献</a></li></ol><h1 id="4e59" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">介绍</h1><p id="d393" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">小麦种子种类的预测是一个分类问题。每一类的观察数量是平衡的。有199个观察值，7个输入变量和1个输出变量。变量名如下:</p><ol class=""><li id="c021" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">面积。</li><li id="9f2f" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">周界。</li><li id="b7c1" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">紧凑性。</li><li id="ab6e" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">内核长度。</li><li id="4050" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">内核的宽度。</li><li id="c5ad" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">不对称系数。</li><li id="7698" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">内核凹槽长度。</li><li id="a320" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">类(1，2，3)。</li></ol><h1 id="7050" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">数据预处理</h1><h2 id="4c45" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">加载所需的库</h2><p id="dbe5" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">让我们加载处理这个数据集时需要的标准库列表。我通常更喜欢一次性加载它们🆒</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="e760" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">检索数据</h2><p id="33fc" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">数据集可以从<a class="ae jm" href="https://raw.githubusercontent.com/hargurjeet/MachineLearning/Wheat-Seeds/seeds.csv" rel="noopener ugc nofollow" target="_blank"> GitHub </a>或<a class="ae jm" href="https://www.kaggle.com/jmcaro/wheat-seedsuci" rel="noopener ugc nofollow" target="_blank"> Kaggle </a>下载。我已经从GitHub下载了数据集。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h1 id="e652" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">特征分析</h1><p id="b2f4" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">现在数据集已经下载完毕，让我们来研究一下数据集，以获得对功能的深入了解。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es mo"><img src="../Images/c142110c1d955cbaacda3624f077d460.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqEVmg_yT7JxM8wxBgsPEA.png"/></div></div></figure><p id="7e7b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从上图来看，物种和特征之间的关系不是很清楚。因此，我运行下面的代码来理解特性之间的相关性。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4b6a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">以下是我的观察</p><ul class=""><li id="3512" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki mp kp kq kr bi translated">籽粒长度和宽度似乎与面积有很大关系。</li><li id="65cf" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki mp kp kq kr bi translated">内核的长度和宽度似乎与周长有很大的关系。</li><li id="f1c0" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki mp kp kq kr bi translated">面积和周长与凹槽密切相关。</li><li id="7662" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki mp kp kq kr bi translated">凹槽与类型非常接近于零(0.03)，因此确认没有线性关系。</li></ul><p id="f48a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我现在为每一种类型画出上述所有要点。每种类型的绘图面积和内核长度。</p><h2 id="45d4" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">面积与内核长度</h2><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="6064" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">面积与内核宽度</h2><p id="5f7c" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">每种类型的绘图面积和内核宽度。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6b81" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我观察到类型1和类型2之间的数据重叠，以及与类型3的最小重叠。因此，我得出结论，虽然类型1和类型2的种子可能在宽度上相似，但类型3的种子肯定在尺寸上更大。</p><h2 id="75c7" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">绘制凹槽与周长</h2><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="646a" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">面积与内核凹槽</h2><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="9a7c" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">类型1和类型2的内核凹槽长度似乎落在相同的范围内。而类型3似乎具有更长的凹槽长度。</p><h1 id="65d5" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">使用PyTorch构建模型</h1><p id="f265" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">因为这是一个分类问题。我在这里建立一个逻辑回归模型。需要注意的几个要点</p><ul class=""><li id="6eb1" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki mp kp kq kr bi translated">一个<strong class="jp hi">逻辑回归</strong>模型几乎等同于一个线性回归模型。它包含权重和偏差矩阵，使用简单的矩阵运算(<code class="du mq mr ms mt b">pred = x @ w.t() + b</code>)获得输出。</li><li id="6c85" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki mp kp kq kr bi translated">我们使用<code class="du mq mr ms mt b">nn.Linear</code>来创建模型。</li><li id="093a" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki mp kp kq kr bi translated">输出是大小为3的向量，每个元素表示特定目标标签的概率(即，0到2)。一个小麦品种的预测标签就是概率最高的那个。</li></ul><h2 id="d2f5" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">预处理和创建数据加载器</h2><p id="9dfe" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">首先，需要将数据转换成张量。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="7403" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">要设置自定义数据集，您需要使用数据加载器。torch库中提供了DataLoader方法。您可以按如下方式使用数据加载器。数据在测试和验证集中被分割</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="4476" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在建立模型之前，我们需要了解输入大小和输出大小。在当前数据集中，我们有7个特征(面积、周长、紧密度、内核。长度，内核。宽度，不对称。Coeff，内核。凹槽)。因此，输入大小将是7。在输出类别(即类型)中，我们有3种不同的分类。因此，我们的输出大小将是3</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="ae3e" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">模型创建</h2><p id="50f5" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">在我们建立模型之前，让我们先了解一下<strong class="jp hi">什么是逻辑回归</strong>？<br/>在统计学中，<strong class="jp hi">逻辑模型</strong>(或<strong class="jp hi">逻辑模型</strong>)用于模拟某一类或某一事件存在的概率，如通过/失败、赢/输、活着/死了或健康/生病。这可以扩展到建模几类事件，如确定图像是否包含猫、狗、狮子等。图像中被检测的每个对象将被分配0到1之间的概率，总和为1。</p><p id="d85d" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">这是模型的样子。坦率地说，您可能必须熟悉python的面向对象概念。你不必真的掌握它。基础知识将足以在构建PyTorch模型时一帆风顺。</p><p id="a0fc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">基本的前馈网络将会是这样的</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="aa36" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们在上面看到，模型接受7个输入，提供3个输出。基于最大概率，我们将从3个输出中选择1个输出。</p><p id="ee80" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在下一步中，我将包括培训和验证步骤以及损失和优化器。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="be52" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">此外，了解<strong class="jp hi">评估指标</strong>也很重要。</p><p id="419f" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><strong class="jp hi">评估指标<br/> </strong>我们需要一种方法来评估我们的模型表现如何。一种自然的方法是找出被正确预测的标签的百分比。我们通过下面的函数来计算</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="24c3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du mq mr ms mt b">==</code>操作符对两个形状相同的张量进行元素比较，并返回一个形状相同的张量，包含不相等元素的<code class="du mq mr ms mt b">True</code>和相等元素的<code class="du mq mr ms mt b">False</code>。将结果传递给<code class="du mq mr ms mt b">torch.sum</code>会返回正确预测的标签数量。最后，我们除以特征的总数来得到准确度。</p><p id="4c37" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">在我们训练该模型之前，让我们看看该模型在具有初始随机初始化权重和偏差集的验证集上的表现。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="c7e5" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">初始精度约为31%，这可能是随机初始化模型的预期值。(因为通过随机猜测，它有1/3的机会猜对一个标签)</p><h2 id="c67b" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">训练模型</h2><p id="9f3a" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">现在我们已经定义了数据加载器，模型，我们准备训练模型。<br/>这里是训练和验证阶段的伪代码。</p><pre class="ix iy iz ja fd mu mt mv mw aw mx bi"><span id="6a34" class="ly kz hh mt b fi my mz l na nb">for epoch in range(num_epochs):<br/>    # Training phase<br/>    for batch in train_loader:<br/>        # Generate predictions<br/>        # Calculate loss<br/>        # Compute gradients<br/>        # Update weights<br/>        # Reset gradients<br/>    <br/>    # Validation phase<br/>    for batch in val_loader:<br/>        # Generate predictions<br/>        # Calculate loss<br/>        # Calculate metrics (accuracy etc.)<br/>    # Calculate average validation loss &amp; metrics<br/>    <br/>    # Log epoch, loss &amp; metrics for inspection</span></pre><p id="2b59" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">训练循环的某些部分特定于我们正在解决的特定问题(例如，损失函数、指标等)。)而其他的是通用的，可以应用于任何深度学习问题。</p><p id="fea3" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们将在一个名为<code class="du mq mr ms mt b">fit</code>的函数中包含与问题无关的部分，该函数将用于训练模型。特定于问题的部分将通过向<code class="du mq mr ms mt b">nn.Module</code>类添加新方法来实现。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><p id="6afc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated"><code class="du mq mr ms mt b">fit</code>函数记录每个时期的验证损失和度量。它返回训练的历史，对调试&amp;可视化很有用。</p><p id="4eeb" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我们现在准备训练模型。让我们训练五个纪元，看看结果。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><h2 id="94b3" class="ly kz hh bd la lz ma mb le mc md me li jw mf mg lk ka mh mi lm ke mj mk lo ml bi translated">绘制损耗和精度图</h2><p id="55a9" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">虽然随着我们训练更多的历元，准确度会继续增加，但是随着每个历元的增加，改进会变得更小。让我们用一个线形图来形象化地展示这一点。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="mm mn l"/></div></figure><figure class="ix iy iz ja fd jb er es paragraph-image"><div class="er es nc"><img src="../Images/b75cbc2b4aeb18786e7d47d350c641d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:786/format:webp/1*9V44ATFiog0OF6Imka_piQ.png"/></div></figure><p id="85cc" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">从上面的图片中可以很清楚地看到，即使经过非常长时间的训练，该模型也很可能不会越过80%的准确率阈值。一个可能的原因是学习率可能太高。模型的参数可以在最低损失的最佳参数集附近“跳动”。我们可以尝试降低学习率，多训练几个纪元，看看有没有帮助。</p><p id="9e11" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">更有可能的原因是这个模型不够强大。有各种各样的技术来提高模型的性能，但这可能超出了本笔记本的范围。</p><h1 id="2cbe" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">摘要</h1><p id="b389" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">下面是本文的简要总结，以及我们在构建PyTorch逻辑回归模型时遵循的一步一步的过程。</p><ol class=""><li id="133a" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">我们简要了解了PyTorch框架和张量。</li><li id="7bfb" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">下载数据集并执行特征分析。</li><li id="b632" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">按照以下步骤构建模型<br/> i .设置数据加载器，并在训练和验证集中拆分数据。<br/>二。建立一个具有训练、测试、损耗和优化器的前馈网络。<br/>三世。定义了捕捉模型准确性的评估指标。<br/>四。我们开发了一个独立于问题的函数<code class="du mq mr ms mt b">fit</code>,它可以捕捉每个时期的验证损失和准确性。然后，我们以不同的学习速率训练该模型。六。最后，我们根据我们在培训期间运行的纪元，在捕获的<code class="du mq mr ms mt b">val_acc</code>上构建一个可视化。</li></ol><h1 id="d9a7" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">未来的工作</h1><p id="c264" class="pw-post-body-paragraph jn jo hh jp b jq lq ii js jt lr il jv jw ls jy jz ka lt kc kd ke lu kg kh ki ha bi translated">下面是一些可以扩展project的方法:</p><ol class=""><li id="7174" class="kj kk hh jp b jq jr jt ju jw kl ka km ke kn ki ko kp kq kr bi translated">尝试更新模型参数以进一步提高精确度。</li><li id="8173" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">建立多层前馈网络以验证模型性能。</li><li id="d4c1" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated">尝试实现经典的机器学习模型，如SVM，因为他们特别擅长集群，并评估其性能。</li></ol><h1 id="29ca" class="ky kz hh bd la lb lc ld le lf lg lh li in lj io lk iq ll ir lm it ln iu lo lp bi translated">参考</h1><ol class=""><li id="9be3" class="kj kk hh jp b jq lq jt lr jw lv ka lw ke lx ki ko kp kq kr bi translated">访问或执行完整的笔记本-<a class="ae jm" href="https://jovian.ai/hargurjeet/wheat-seeds-analysis-pytorch-blogs" rel="noopener ugc nofollow" target="_blank">https://jovian . ai/hargurjeet/wheat-seeds-analysis-py torch-blogs</a></li><li id="1d65" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">https://pytorch.org/</a></li><li id="09c9" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="https://pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html" rel="noopener ugc nofollow" target="_blank">https://py torch . org/docs/stable/generated/torch . nn . crossentropyloss . html</a></li><li id="4f95" class="kj kk hh jp b jq ks jt kt jw ku ka kv ke kw ki ko kp kq kr bi translated"><a class="ae jm" href="https://jovian.ai/learn/deep-learning-with-pytorch-zero-to-gans" rel="noopener ugc nofollow" target="_blank">https://jovian . ai/learn/deep-learning-with-py torch-zero-to-gans</a></li></ol><p id="169b" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">我真的希望你们能从这篇文章中学到一些东西。请随意给一个👏如果你喜欢你所学的。这让我保持动力。</p><p id="197a" class="pw-post-body-paragraph jn jo hh jp b jq jr ii js jt ju il jv jw jx jy jz ka kb kc kd ke kf kg kh ki ha bi translated">感谢阅读这篇文章。快乐学习😃</p></div></div>    
</body>
</html>