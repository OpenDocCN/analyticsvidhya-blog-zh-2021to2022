<html>
<head>
<title>Page Object Modeling with Python and Playwright</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python和剧作家进行页面对象建模</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/page-object-modeling-with-python-and-playwright-3cbf259eedd3?source=collection_archive---------2-----------------------#2021-02-08">https://medium.com/analytics-vidhya/page-object-modeling-with-python-and-playwright-3cbf259eedd3?source=collection_archive---------2-----------------------#2021-02-08</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="ff9b" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何构建有效的剧作家框架模型？</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/7bf8d9887b34cd64d6aa24691df77bc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UCTbZ8s5UrB2niDX"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">克里斯·里德在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><p id="1707" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">微软的剧作家在2020年5月悄悄发布。由最初编写木偶库的一群工程师编写，剧作家有意与木偶师相似。虽然微软在剧作家的文档中提供了一个page对象的例子，但是这个例子相当简单，没有深入研究page属性或helper方法的使用。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><h1 id="56ca" class="kr ks hi bd kt ku kv kw kx ky kz la lb io lc ip ld ir le is lf iu lg iv lh li bi translated">什么是页面对象？</h1><p id="0b84" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">页面对象是使用编程语言对网页的抽象。目的是表示代码中的所有页面，以便对特定元素采取行动。页面对象通常用于测试自动化领域，质量工程师创建对象和测试以测试应用程序用户旅程。</p><p id="a87c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">本教程将着重于为DemoQA书店应用程序登录页面构建一个页面对象。登录页面具有用户名输入、密码输入、登录按钮和新用户按钮。</p><h1 id="e7c1" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">入门指南</h1><p id="6d75" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">为了开始，我们需要安装我们的依赖项。应该安装以下软件包:</p><ul class=""><li id="bfcd" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated">pytest</li><li id="8343" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">pytest-剧作家</li><li id="d658" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">剧作家</li></ul><p id="4349" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">只需使用pip(或您选择的依赖管理器)安装以上程序。</p><p id="ae2f" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">包含了<code class="du mh mi mj mk b">pytest</code>库，因为它是Python最流行的测试运行程序。<code class="du mh mi mj mk b">pytest-playwright</code>包提供了在测试中使用的简单夹具，比如自动化浏览器设置的页面夹具。它也可以被配置成在失败时截屏，这有助于调试flakey或失败的测试。</p><h1 id="e0f6" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">抽象页面元素</h1><p id="6963" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">我们的第一个任务是创建一个表示登录页面的类对象，该页面在初始化时具有一个<code class="du mh mi mj mk b">page</code>属性。在创建属性和方法时，将使用<code class="du mh mi mj mk b">page</code>属性。</p><p id="fce6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">构建类对象的原因是它允许我们的代码在增加可重用性的同时保持有序。</p><pre class="iy iz ja jb fd ml mk mm mn aw mo bi"><span id="e64b" class="mp ks hi mk b fi mq mr l ms mt">class Login:<br/>    def __init__(self, page):<br/>        self.page = page</span></pre><p id="3a67" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">现在我们有了Login类，我们可以开始添加表示页面中元素的属性。我们使用<code class="du mh mi mj mk b">@property</code>内置装饰器，因为它使得在Python中使用getters和setters更加容易。</p><p id="f714" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">每个属性返回剧作家所说的<code class="du mh mi mj mk b">ElementHandle</code>。这是剧作家对DOM元素的表现。对象可以单独使用，也可以作为其他方法的参数。</p><pre class="iy iz ja jb fd ml mk mm mn aw mo bi"><span id="8828" class="mp ks hi mk b fi mq mr l ms mt">class Login:<br/>    def __init__(self, page):<br/>        self.page = page</span><span id="3809" class="mp ks hi mk b fi mu mr l ms mt">    @property<br/>    def new_user_button(self):<br/>        return self.user_form.wait_for_selector("#newUser")</span><span id="4a65" class="mp ks hi mk b fi mu mr l ms mt">    @property<br/>    def password_field(self):<br/>        return self.user_form.wait_for_selector("#password")</span><span id="d127" class="mp ks hi mk b fi mu mr l ms mt">    @property<br/>    def submit_button(self):<br/>        return self.user_form.wait_for_selector("#login")</span><span id="0fa6" class="mp ks hi mk b fi mu mr l ms mt">    @property<br/>    def user_form(self):<br/>        return self.page.wait_for_selector("#userForm")</span><span id="1f8f" class="mp ks hi mk b fi mu mr l ms mt">    @property<br/>    def username_field(self):<br/>        return self.user_form.wait_for_selector("#userName")</span></pre><p id="4f73" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">属性<code class="du mh mi mj mk b">username_field</code>是从<code class="du mh mi mj mk b">user_form</code>中调用的。这是因为用户名字段是DOM中用户表单的子元素。这是一个很好的实践，因为它将驱动程序的范围缩小到一个特定的区域，而不是整个页面。</p><p id="e4f6" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">剧作家的<code class="du mh mi mj mk b">wait_for_selector</code>方法允许我们安全地调用元素，因为它会等待元素在DOM中可见，直到达到超时限制。如果在超时限制内没有找到选择器，将引发错误。</p><p id="87f1" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated"><code class="du mh mi mj mk b">wait_for_selector</code>方法也可用于等待特定的元素状态，例如等待直到隐藏。但是，这超出了本指南的范围。</p><h1 id="3cca" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">编写助手方法</h1><p id="2d42" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">页面对象属性可用于构建助手方法。应该为经常重复的工作流构造助手方法。</p><pre class="iy iz ja jb fd ml mk mm mn aw mo bi"><span id="bd0d" class="mp ks hi mk b fi mq mr l ms mt">class Login:</span><span id="222a" class="mp ks hi mk b fi mu mr l ms mt">    def submit_login_form(self, user):<br/>        self.username_field.fill(user["username"])<br/>        self.password_field.fill(user["password"])<br/>        self.submit_button.click()</span><span id="1bfb" class="mp ks hi mk b fi mu mr l ms mt">    def navigate(self):<br/>        self.page.goto("https://www.demoqa.com/login")</span></pre><p id="67e2" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">上述方法允许页面导航和表单提交，这两个工作流在登录页面测试期间会经常使用。</p><h1 id="e796" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">编写和运行测试</h1><p id="58b1" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">现在我们有了一个用属性和助手方法构建的page对象，我们可以开始为用户之旅编写测试了。</p><pre class="iy iz ja jb fd ml mk mm mn aw mo bi"><span id="c78d" class="mp ks hi mk b fi mq mr l ms mt">from pages import Login</span><span id="0f69" class="mp ks hi mk b fi mu mr l ms mt">user = {<br/>    "username": "test",<br/>    "password": "password"<br/>}<br/></span><span id="336e" class="mp ks hi mk b fi mu mr l ms mt">class TestLogin:<br/>    def test_valid_login(self, page):<br/>        login_page = Login(page)<br/>        profile_page = Profile(page)</span><span id="4e97" class="mp ks hi mk b fi mu mr l ms mt">        login_page.navigate()<br/>        login_page.submit_login_form(user)</span><span id="ac50" class="mp ks hi mk b fi mu mr l ms mt">        visible = profile_page.username_value_field.is_visible()</span><span id="7759" class="mp ks hi mk b fi mu mr l ms mt">        assert visible and "profile" in page.url</span></pre><p id="6def" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">在上面的测试中，我们初始化了登录页面和测试断言中使用的配置文件页面(示例未显示)。我们导航到登录页面，然后使用<code class="du mh mi mj mk b">submit_login_form</code>助手方法输入用户信息。</p><p id="8cdd" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">提交表单后，我们检查Profile页面上是否显示了某个元素。然后我们在断言中使用这个检查，因为这个元素在成功登录后显示。</p><p id="da1d" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">要运行此测试，请在终端上输入以下命令之一:</p><ul class=""><li id="0fc0" class="lt lu hi jq b jr js ju jv jx lv kb lw kf lx kj ly lz ma mb bi translated">无头地跑</li><li id="74f9" class="lt lu hi jq b jr mc ju md jx me kb mf kf mg kj ly lz ma mb bi translated">精神饱满地奔跑</li></ul><h1 id="a057" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">项目目录</h1><p id="f56b" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">完成本教程后，您的目录应该如下所示:</p><pre class="iy iz ja jb fd ml mk mm mn aw mo bi"><span id="2e67" class="mp ks hi mk b fi mq mr l ms mt">pages<br/>    |__ __init__.py<br/>    |__ login.py</span><span id="cd73" class="mp ks hi mk b fi mu mr l ms mt">tests<br/>    |__ test_login.py</span><span id="7283" class="mp ks hi mk b fi mu mr l ms mt">.gitignore<br/>README.md<br/>requirements.txt</span></pre><h1 id="c389" class="kr ks hi bd kt ku lo kw kx ky lp la lb io lq ip ld ir lr is lf iu ls iv lh li bi translated">摘要</h1><p id="6354" class="pw-post-body-paragraph jo jp hi jq b jr lj ij jt ju lk im jw jx ll jz ka kb lm kd ke kf ln kh ki kj hb bi translated">使用页面对象模型编写测试相当快速和方便。使用Python和剧作家，我们可以毫不费力地将网页抽象成代码，同时自动等待元素。</p></div><div class="ab cl kk kl gp km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="hb hc hd he hf"><p id="534c" class="pw-post-body-paragraph jo jp hi jq b jr js ij jt ju jv im jw jx jy jz ka kb kc kd ke kf kg kh ki kj hb bi translated">Jonathan Thompson是一名高级质量工程师，专门研究测试自动化。他目前和妻子以及一只名叫温斯顿的金毛猩猩住在北卡罗来纳州的罗利。你可以在<a class="ae jn" href="https://www.linkedin.com/in/jonathanmnthompson/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上和他联系，也可以在Twitter(<a class="ae jn" href="https://twitter.com/jacks_elsewhere" rel="noopener ugc nofollow" target="_blank"><em class="mv">@ jacks _ where</em></a>)<em class="mv"/>或Github(<a class="ae jn" href="http://github.com/ThompsonJonM" rel="noopener ugc nofollow" target="_blank"><em class="mv">Thompson jonm</em></a>)上关注他。</p></div></div>    
</body>
</html>