<html>
<head>
<title>Accessing Fantasy Premier League data using Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Python访问梦幻超级联赛数据</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-fantasy-premier-league-data-56d3b9be8c32?source=collection_archive---------0-----------------------#2021-05-05">https://medium.com/analytics-vidhya/getting-started-with-fantasy-premier-league-data-56d3b9be8c32?source=collection_archive---------0-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="22a7" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">如何从FPL API访问数据</h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div class="er es ix"><img src="../Images/21f5bd4bd744b9885e9ebd557baa1b09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*-b5APwIdlY2J_cU9NmE5bA.png"/></div></figure><h1 id="b3ba" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">关于作者</h1><p id="6c6c" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我第一次玩<a class="ae kt" href="https://fantasy.premierleague.com/" rel="noopener ugc nofollow" target="_blank">梦幻英超</a> (FPL)是在2007年。我当时在上高中，并没有真正关注英超。然而，我的大多数朋友都这样做了，我厌倦了不能加入他们在教室后面的团队选择讨论中偷懒。我记得我选择了我的第一支球队，它的中场由法布雷加斯、杰拉德、兰帕德和克里斯蒂亚诺·罗纳尔多组成，然后是一群来自朴茨茅斯和维根等垫底俱乐部的后卫，因为他们是我剩余预算所能负担的最好的球队。</p><p id="c287" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">随着时间的推移，FPL提高了我对英超联赛的兴趣，而我从观看现场比赛中积累的知识也让我的FPL队受益匪浅。在接下来的几个赛季中，我发现自己一直在迷你联赛中名列前茅。在2015/16赛季，我距离前10公里只有一步之遥，但从全球总排名的角度来看，我很大程度上可以说我已经<em class="kz">好了</em>。</p><p id="50b4" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">在大学期间，我学会了使用Python编程，现在是一名数据科学家。我最近一直在想，我是否可以利用我的一些技能，以一种更加数据驱动的方式做出我的FPL决策。我偶然发现了一个<a class="ae kt" href="https://www.reddit.com/r/FantasyPL/comments/f8t3bw/cheatsheet_of_all_current_fpl_endpoints/" rel="noopener ugc nofollow" target="_blank"> Reddit帖子</a>，其中提到了一个FPL的API(应用程序编程接口),这篇文章将提供一个初学者如何使用Python访问这个API的指南。</p><h1 id="2e53" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">梦幻英超API</h1><p id="73a1" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">好消息是这个API是完全免费使用的(前提是你不用它来做任何赚钱的事情)。这个API由许多端点组成，这些端点一起可以为用户提供FPL游戏的全貌。端点基本上只是一个URL，在您向它发送HTTP请求后，它会用一些数据进行响应。</p><p id="1e3d" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">这些终点的总结如下:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="fc1f" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">引导-url</h1><p id="45fd" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">让我们从列表中的第一个端点开始；试着将它的端点(<a class="ae kt" href="https://fantasy.premierleague.com/api/bootstrap-static/" rel="noopener ugc nofollow" target="_blank">https://fantasy.premierleague.com/api/bootstrap-static/</a>)粘贴到你的浏览器地址栏中——你应该会得到一个看起来像这样的相当混乱的响应:</p><pre class="iy iz ja jb fd lc ld le lf aw lg bi"><span id="d84f" class="lh jg hi ld b fi li lj l lk ll">{"events":[{"id":1,"name":"Gameweek 1","deadline_time":"2020-09-12T10:00:00Z","average_entry_score":50,"finished":true,"data_checked":true,"highest_scoring_entry":4761681,"deadline_time_epoch":1599904800,"deadline_time_game_offset":0,"highest_score":142,"is_previous":false,"is_current":false,"is_next":false,"chip_plays":[{"chip_name":"bboost","num_played":112843},{"chip_name":"3xc","num_played":225426}],"most_selected":259,"most_transferred_in":12,"top_element":254,"top_element_info":{"id":254,"points":20},"transfers_made":0,"most_captained":4,"most_vice_captained":4},{"id":2,"name":"Gameweek 2","deadline_time":"2020-09-19T10:00:00Z","average_entry_score":59,"finished":true,"data_checked":true,"highest_scoring_entry":6234344,"deadline_time_epoch":1600509600,"deadline_time_game_offset":0,"highest_score":165,"is_previous":false,"is_current":false,"is_next":false,"chip_plays":[{"chip_name":"bboost","num_played":94615},{"chip_name":"freehit","num_played":111968},{"chip_name":"wildcard","num_played":494000},{"chip_name":"3xc","num_played":221133}],"most_selected":259,"most_transferred_in":302,"top_element":390,"top_element_info":{"id":390,"points":24},"transfers_made":14637421,"most_captained":4,"most_vice_captained":254} ...</span></pre><h2 id="9ead" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">JSON数据格式</h2><p id="0021" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">从API返回的响应是一种称为JSON的格式。它的应用非常广泛，尤其是在API领域，所以知道如何处理这种格式的数据是一项非常有用的技能。</p><p id="db6a" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">幸运的是，我们有一些Python库可以用来更容易地筛选这些数据，即<a class="ae kt" href="https://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank">请求</a>、<a class="ae kt" href="https://docs.python.org/3/library/json.html" rel="noopener ugc nofollow" target="_blank"> json </a>和<a class="ae kt" href="https://pandas.pydata.org/" rel="noopener ugc nofollow" target="_blank"> pandas </a>。</p><h2 id="d1da" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">使用请求库</h2><p id="889f" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">为了创建一个新的请求，我们使用了<code class="du lz ma mb ld b">requests.get()</code>函数。并对响应使用<code class="du lz ma mb ld b">.json()</code>方法来正确解析它。</p><p id="d08c" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">如果您试图打印响应的值，那么您的笔记本编辑器在试图呈现完整的单元格输出时会变得非常慢。在这个阶段，我们只对理解模式感兴趣，不需要看到每一条数据都打印到我们的屏幕上。<code class="du lz ma mb ld b">pprint</code>模块为这个问题提供了一个简洁的解决方案，我们将使用它来显示API响应中的顶级列。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">响应是JSON格式的，非常类似于嵌套的Python字典</figcaption></figure><p id="b710" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">现在我们可以看到这个端点包含一些嵌套字段。让我们仔细看看其中的一些字段。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="d504" class="jf jg hi bd jh ji mn jk jl jm mo jo jp io mp ip jr ir mq is jt iu mr iv jv jw bi translated">玩家数据</h1><p id="bb02" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated"><strong class="jz hj">元素</strong>字段包含FPL当前赛季每个英超球员的数据。我们可以访问这些数据，就像访问与字典中的一个键相关联的数据一样。响应是更多字典的列表——每个玩家一个。</p><p id="106e" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">让我们获取元素数据，然后显示列表中第一个玩家的信息:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">每个嵌套字典都包含关于特定玩家的信息</figcaption></figure><h2 id="e02e" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">更容易检查熊猫</h2><p id="f06d" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">在现阶段，如果这些数据是表格形式的，对我们会更有用。熊猫图书馆就是为此而建的。可以使用<code class="du lz ma mb ld b">json_normalize()</code>函数将JSON数据加载到数据帧中:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">熊猫数据框对于在一个视图中显示多个玩家很有用</figcaption></figure><p id="fe18" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">现在我们有了一个包含每个球员信息的表，但是我们不知道他们为哪个队效力，或者他们踢什么位置，因为我们只有这些列的数字ID值。</p><h2 id="3484" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">支持数据</h2><p id="ed25" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们可以通过将基本响应中的<strong class="jz hj">团队</strong>字段提取到一个数据帧中来获得团队的名称和实力评级:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">每支球队都有主客场进攻和防守的实力评级——这对分析即将到来的友谊赛很有用？</figcaption></figure><p id="da18" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">同样，对于球员位置，我们将使用<strong class="jz hj"> element_types </strong>字段:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="5d68" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">让我们将这三个表结合起来，得到一个玩家的单一视图。我们将使用<code class="du lz ma mb ld b">merge()</code> pandas函数来连接相关列上的表。玩家可以通过<code class="du lz ma mb ld b">players.team</code>和<code class="du lz ma mb ld b">teams.id</code>栏加入队伍:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">玩家及其各自团队的组合视图</figcaption></figure><p id="9361" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">然后我们也可以加入玩家的位置:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">球员、球队和位置的综合视图</figcaption></figure><blockquote class="ms mt mu"><p id="8cd3" class="jx jy kz jz b ka ku ij kc kd kv im kf mv kw ki kj mw kx km kn mx ky kq kr ks hb bi translated"><em class="hi">注意上面</em> <code class="du lz ma mb ld b"><em class="hi">merge</em></code> <em class="hi">功能的两种不同用法。既可以作为静态函数调用(如</em> <code class="du lz ma mb ld b"><em class="hi">pd.merge(left_df, right_df, on= ...)</em></code> <em class="hi">)，也可以作为现有数据帧上的方法调用(如</em> <code class="du lz ma mb ld b"><em class="hi">left_df.merge(right_df, on=</em></code> <em class="hi">)。</em></p></blockquote></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h2 id="7843" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">玩家游戏周历史</h2><p id="e962" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">现在我们有了一些球员、球队和位置的基本信息。让我们来看看当前赛季的gameweek积分。</p><p id="6bf4" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们可以通过两种方式做到这一点:</p><ol class=""><li id="8cc7" class="my mz hi jz b ka ku kd kv kg na kk nb ko nc ks nd ne nf ng bi translated">对于每个游戏周的GID，从<strong class="jz hj">https://fantasy.premierleague.com/api/event/{GID}/</strong>获取所有玩家数据</li><li id="2d6c" class="my mz hi jz b ka nh kd ni kg nj kk nk ko nl ks nd ne nf ng bi translated">对于每个玩家PID，从<strong class="jz hj">https://fantasy . premier league . com/API/element-summary/{ PID }/</strong>获取游戏周历史</li></ol><p id="7b79" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">因为我们已经在一个数据框架中包含了所有的玩家，所以让我们使用选项2，以每个玩家为基础获取数据。</p><p id="eeda" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated"><strong class="jz hj">元素摘要</strong>端点在顶层包含三个字段:</p><ol class=""><li id="6d78" class="my mz hi jz b ka ku kd kv kg na kk nb ko nc ks nd ne nf ng bi translated"><strong class="jz hj">夹具</strong>包含即将到来的夹具信息</li><li id="29be" class="my mz hi jz b ka nh kd ni kg nj kk nk ko nl ks nd ne nf ng bi translated"><strong class="jz hj">历史</strong>包含<strong class="jz hj"> </strong>历届gameweek玩家的分数</li><li id="967b" class="my mz hi jz b ka nh kd ni kg nj kk nk ko nl ks nd ne nf ng bi translated"><strong class="jz hj"> history_past </strong>提供了前几个赛季的总成绩</li></ol><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="9799" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">我们可以定义一个名为<code class="du lz ma mb ld b">get_gameweek_history()</code>的函数，它接受一个参数<code class="du lz ma mb ld b">player_id</code>，并返回他们之前所有比赛周的分数数据:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="520c" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">上面是一个调用函数来获取ID=4的球员皮埃尔-埃默里克·奥巴姆扬的历史记录的例子。我们可以看到他在赛季开始的前两场比赛中有一个进球和一次助攻，在此之前的三场比赛中没有任何进球贡献。</p><h2 id="07e0" class="lh jg hi bd jh lm ln lo jl lp lq lr jp kg ls lt jr kk lu lv jt ko lw lx jv ly bi translated">球员赛季历史</h2><p id="f49e" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们可以编写一个类似的函数来获得一个球员上个赛季的数据:</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><p id="dab6" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">上面我们可以看到，梅苏特厄齐尔最好的赛季是2015/16赛季，他拿到了200分。可悲的是，对于阿森纳球迷来说，他无法在以后的赛季复制这种形式。</p></div><div class="ab cl mg mh gp mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="hb hc hd he hf"><h1 id="095f" class="jf jg hi bd jh ji mn jk jl jm mo jo jp io mp ip jr ir mq is jt iu mr iv jv jw bi translated">将这一切结合在一起</h1><p id="6b5b" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">我们将通过创建一个<code class="du lz ma mb ld b">points</code>表来结束，该表包含本赛季游戏中所有玩家的所有gameweek积分。</p><p id="0ad3" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">首先，创建一个包含球员姓名、球队和位置的单一数据框架</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">创建一个包含位置和球队信息的球员数据框架</figcaption></figure><p id="0f45" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">接下来，使用pandas的<code class="du lz ma mb ld b">progress_apply()</code> dataframe方法将<code class="du lz ma mb ld b">get_gameweek_history()</code>函数应用到我们的<code class="du lz ma mb ld b">players</code> dataframe中的每一行。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div><figcaption class="mc md et er es me mf bd b be z dx translated">使用progress_apply()获取所有玩家的游戏周分数</figcaption></figure><p id="3945" class="pw-post-body-paragraph jx jy hi jz b ka ku ij kc kd kv im kf kg kw ki kj kk kx km kn ko ky kq kr ks hb bi translated">让我们使用新的数据框架来找出本赛季得分最高的5名球员。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="la lb l"/></div></figure><h1 id="a4be" class="jf jg hi bd jh ji jj jk jl jm jn jo jp io jq ip jr ir js is jt iu ju iv jv jw bi translated">接下来呢？</h1><p id="9d23" class="pw-post-body-paragraph jx jy hi jz b ka kb ij kc kd ke im kf kg kh ki kj kk kl km kn ko kp kq kr ks hb bi translated">希望这能为您自己的分析提供一个良好的起点。我将发表这篇文章的后续文章，完成后会在这里添加一个链接。</p></div></div>    
</body>
</html>