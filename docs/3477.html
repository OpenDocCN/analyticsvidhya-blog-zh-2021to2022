<html>
<head>
<title>Creating and Deploying a Cat-Dog Image Classifier using TensorFlow and Streamlit- Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TensorFlow和Streamlit创建和部署猫狗图像分类器-第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/creating-and-deploying-a-cat-dog-image-classifier-using-tensorflow-and-streamlit-part-1-2672fc184601?source=collection_archive---------1-----------------------#2021-07-03">https://medium.com/analytics-vidhya/creating-and-deploying-a-cat-dog-image-classifier-using-tensorflow-and-streamlit-part-1-2672fc184601?source=collection_archive---------1-----------------------#2021-07-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d2bd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一切都是从一个天真的问题开始的。我是看着很多卡通片长大的，包括Nickelodeon的喜剧节目《猫狗》。这个节目是基于一对双胞胎，他们分别是一只猫和一只狗(当我解释的时候听起来很傻，但是嘿，那时候我还是个孩子！)</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/34b82eb500a0ceb375f2855a8e907055.png" data-original-src="https://miro.medium.com/v2/resize:fit:954/format:webp/0*GsIXgH7OVoICZCyF.jpg"/></div></figure><div class="jk jl ez fb jm jn"><a href="https://www.imdb.com/title/tt0154061/" rel="noopener  ugc nofollow" target="_blank"><div class="jo ab dw"><div class="jp ab jq cl cj jr"><h2 class="bd hi fi z dy js ea eb jt ed ef hg bi translated">《猫狗》(电视剧1998-2005)——IMDb</h2><div class="ju l"><h3 class="bd b fi z dy js ea eb jt ed ef dx translated">一只猫和一只狗的生活和时代有一个独特的转折:它们是联系在一起的。他们和狗共用一个身体…</h3></div><div class="jv l"><p class="bd b fp z dy js ea eb jt ed ef dx translated">www.imdb.com</p></div></div><div class="jw l"><div class="jx l jy jz ka jw kb ji jn"/></div></div></a></div><p id="3665" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我试图回答的问题是:“如果我构建一个图像分类器，它会将我心爱的卡通人物分类为猫还是狗？”。在本文中，我们将回顾这个有趣项目的一些步骤，并回答我的问题:它是一只猫还是一只狗？</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="baa1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">入门:</strong></p><p id="7416" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">假设——本博客涵盖的材料假设读者对python有中级理解，并对ML概念有基本了解。</p><div class="jk jl ez fb jm jn"><a href="https://www.kaggle.com/tongpython/cat-and-dog" rel="noopener  ugc nofollow" target="_blank"><div class="jo ab dw"><div class="jp ab jq cl cj jr"><h2 class="bd hi fi z dy js ea eb jt ed ef hg bi translated">猫和狗</h2><div class="ju l"><h3 class="bd b fi z dy js ea eb jt ed ef dx translated">训练DL模型的猫狗数据集</h3></div><div class="jv l"><p class="bd b fp z dy js ea eb jt ed ef dx translated">www.kaggle.com</p></div></div><div class="jw l"><div class="kj l jy jz ka jw kb ji jn"/></div></div></a></div><p id="16f6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我从Kaggle上的一个数据集开始，它允许我在猫和狗的多个图像上训练我的模型。这是一个中等大小的数据集，分别有4000幅猫和狗的图像用于提供训练。尽管考虑到训练我们网络的样本量较小，这不是最好的数据集，但它是一个很好的起点。更多关于我后来如何处理较小的尺寸…</p><p id="d7e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们从观察一些图像开始，以便对这个项目有一个概念。这项练习不仅能让我们查看图像数据，还能让我们在举重前热身</p><p id="20aa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">基本库在</strong>前加载-</p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="0e14" class="kp kq hh kl b fi kr ks l kt ku">import pandas as pd<br/>import numpy as np<br/>import os<br/>import tensorflow as tf<br/>import cv2<br/>from tensorflow import keras<br/>from tensorflow.keras.models import Sequential, Model<br/>from  matplotlib import pyplot as plt<br/>import matplotlib.image as mpimg<br/>import random<br/>%matplotlib inline<br/>from matplotlib import image<br/>from matplotlib import pyplotimport PIL<br/>print('Pillow Version:', PIL.__version__)<br/><br/>from PIL import Image</span></pre><p id="409f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">开始接触一些猫狗- </strong></p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="6c22" class="kp kq hh kl b fi kr ks l kt ku">plt.figure(figsize=(20,20))<br/>test_folder=r'/kaggle/input/cat-and-dog/training_set/training_set/cats'<br/>for i <strong class="kl hi">in</strong> range(5):<br/>    file = random.choice(os.listdir(test_folder))<br/>    image_path= os.path.join(test_folder, file)<br/>    img=mpimg.imread(image_path)<br/>    print(img.shape)<br/>    ax=plt.subplot(1,5,i+1)<br/>    ax.title.set_text(file)<br/>    plt.imshow(img)</span></pre><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es kv"><img src="../Images/dacabe3044b47d09b75da653b1030c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X2WRYSzZtzi4tiwfHEJ0Rg.png"/></div></div></figure><p id="b119" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">同样，对于狗，结果如下-</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es la"><img src="../Images/5d660c7efb2366c1bfa40ba0d21cf386.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EGL5Duu4rtqijkZ_L5nEeg.png"/></div></div></figure><p id="03ef" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里需要注意的一点是，每个图像都有自己的维度。从这个观察中得到的一点是，我们需要固定图像的维度，以便我们可以在CNN中建立一个流线型的连续张量(矩阵的矩阵)。在这个例子中，我将尺寸固定为(200，200)</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="1713" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">数据摄取和处理</strong></p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="81a0" class="kp kq hh kl b fi kr ks l kt ku">IMG_WIDTH=200<br/>IMG_HEIGHT=200<br/>img_folder='/kaggle/input/cat-and-dog/training_set/training_set/'<br/><br/>def create_dataset(img_folder):<br/>   <br/>    img_data_array=[]<br/>    class_name=[]<br/>    <br/>    for dir1 <strong class="kl hi">in</strong> os.listdir(img_folder):<br/>        print("Collecting images for: ",dir1)<br/>        for file <strong class="kl hi">in</strong> os.listdir(os.path.join(img_folder, dir1)):<br/>       <br/>            image_path= os.path.join(img_folder, dir1,  file)<br/>            image= cv2.imread( image_path, cv2.COLOR_BGR2RGB)<br/>            try:<br/>                image=cv2.resize(image, (IMG_HEIGHT, IMG_WIDTH),interpolation = cv2.INTER_AREA)<br/>            except:<br/>                break<br/>            image=np.array(image)<br/>            image = image.astype('float32')<br/>            image /= 255 <br/>            img_data_array.append(image)<br/>            class_name.append(dir1)<br/>    return img_data_array, class_name<br/><em class="lb"># extract the image array and class name</em><br/>img_data, class_name =create_dataset('/kaggle/input/cat-and-dog/training_set/training_set/')</span></pre><p id="260f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里有很多东西要讲。让我们从基础开始:我们需要确保图像被作为数据处理，每个图像都有相同的高度和宽度，并且在调整大小的过程中图像质量没有被放弃。最后，我们需要整理那些图像(收集像素数据，咄！)放入一个大数组中，供我们的神经网络使用！</p><p id="9505" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我会讲一些可能会引起你注意的事情-</p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="a63d" class="kp kq hh kl b fi kr ks l kt ku">CV- OpenCV; an open source library for computer vision operations and algorithms</span><span id="3f88" class="kp kq hh kl b fi lc ks l kt ku">cv2.imread-This method loads an image from a destination</span><span id="e8cd" class="kp kq hh kl b fi lc ks l kt ku">cv2.COLOR_BGR2RGB- OpenCV reads images in BGR (Blue Green Red) colorspace ordering and we have to convert it back to RGB (Red Green Blue)</span><span id="8f18" class="kp kq hh kl b fi lc ks l kt ku">cv2.INTER_AREA- This method resizes the image. We need to ensure that the aspect ratio is maintained while image manipulations. Ene quick thumbrule to follow is this-<br/>If you are <strong class="kl hi">enlarging</strong> the image, you should prefer to use <em class="lb">INTER_LINEAR</em> or <em class="lb">INTER_CUBIC</em> interpolation. If you are <strong class="kl hi">shrinking</strong> the image, you should prefer to use <em class="lb">INTER_AREA</em> interpolation.</span><span id="1479" class="kp kq hh kl b fi lc ks l kt ku">image.astype('float32') - For all weights and neuron activations, if you are using a method based on backpropagation for training updates, then you need a data type that approximates real numbers, so that you can apply fractional updates based on differentiation. Best weight values are often going to be fractional, non-whole numbers. Non-linearities such as sigmoid are also going to output floats. So after the input layer you have matrices of float values anyway. Hence, We need to ensure here that the tensors are read as floats values</span><span id="de69" class="kp kq hh kl b fi lc ks l kt ku">image /= 255 - normalizing our input so that images are scaled between 0 and 1 (max pixel value is 255).</span></pre><p id="e48c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有一次，我为猫和狗准备了数组，是时候准备输出变量0和1了。我给狗选1，给猫选0(我只是更喜欢狗，仅此而已)</p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="9083" class="kp kq hh kl b fi kr ks l kt ku">def dog_cat_mapping(a):<br/>    if a=="dogs":<br/>        return 1<br/>    else:return 0<br/>class_name=list(map(dog_cat_mapping,class_name))<br/>class_name=np.array(class_name)</span></pre></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="785b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">模型构建</strong></p><p id="2273" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，我建立了模型。我不会详细讨论卷积层是如何工作的，因为它需要几(千)页以上的内容！</p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="9660" class="kp kq hh kl b fi kr ks l kt ku">def model():<br/>    from tensorflow.keras.models import Sequential<br/>    from tensorflow.keras.layers import Dense, Conv2D, Dropout, Flatten, MaxPooling2D<br/>    model=Sequential()<br/>    model.add(Conv2D(28, kernel_size=(3,3), input_shape=input_shape,activation='relu'))<br/>    model.add(Conv2D(64, kernel_size=(3,3),activation='relu'))<br/>    model.add(MaxPooling2D(pool_size=(2,2)))<br/>    model.add(Conv2D(128, kernel_size=(2,2),activation='relu'))<br/>    model.add(Conv2D(128, kernel_size=(2,2),activation='relu'))<br/>    model.add(Flatten())<br/>    model.add(Dense(256,activation='relu'))<br/>    model.add(Dropout(0.2))<br/>    model.add(Dense(1,activation='sigmoid'))<br/>    return model</span></pre><p id="8455" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里需要注意的重要一点是，你可以在图层上设置任意数量的滤镜。我选择了28、64、128和256，因为这些都是标准配置。此外，我决定使用3*3和2*2大小的特征地图。这些只是我们提取输入图像特征的过滤器。</p><p id="42d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦卷积操作完成，我们就可以开始并展平该层，以将数据输入到我们的神经网络中。我选择了0.2的dropout，这意味着一些数量(20%)的层输出被随机忽略或者“<em class="lb">被丢弃</em>”这可以防止过度拟合。</p><p id="5df0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，使用sigmoid函数来判断输入是猫(0)还是狗(1)。</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="9190" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">模型编译和评估</strong></p><p id="1fb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">模型编译花了很长时间。为了加快这个过程，我强烈建议切换到Kaggle的GPU模式。</p><pre class="jd je jf jg fd kk kl km kn aw ko bi"><span id="8541" class="kp kq hh kl b fi kr ks l kt ku">model=model()<br/>model.compile(optimizer='adam', <br/>              loss='binary_crossentropy', <br/>              metrics=['accuracy'])<br/>model.fit(x=img_data,y=class_name, epochs=10)</span></pre><p id="50ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仅仅用了10个纪元，我就能够达到99%的训练准确率。请注意，这里没有什么可变通的，在8000个样本大小的数据集上达到99%的准确率只是表明我们的模型过度拟合了数据。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="er es ld"><img src="../Images/625e2586a5ede37d19c6132a108405b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*271JHKkjcqLqGsYM5BWndA.png"/></div></div></figure><p id="7441" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种准确性也应该有所保留，因为训练准确性取决于我们神经网络中的初始权重分配(这是完全随机的)。如果我重新开始这个过程，我可以达到80%的准确率，而不是99%(因为初始权重很低)</p></div><div class="ab cl kc kd go ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ha hb hc hd he"><p id="0521" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结束的想法和进一步的步骤</strong></p><p id="036d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">测试准确度不是很高(这并不奇怪)。我能够在一个测试数据集上达到大约61%的准确率。至少这是个好的开始。我们的模型可以对猫和狗进行基本分类。然而，当它遇到这样的品种时，它就会遇到麻烦</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es le"><img src="../Images/547b99ecbbaf64f670dd67c4d583bdbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*kAuEYby1_0mg_vNOGchE9w.png"/></div><figcaption class="lf lg et er es lh li bd b be z dx translated">模型将其归类为“猫”</figcaption></figure><blockquote class="lj lk ll"><p id="0e15" class="ie if lb ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">接下来，我们将尝试将“迁移学习”纳入我们的模型。此外，我们将能够得到我们最初的问题的答案，“我心爱的卡通人物是一只猫还是一只狗？”</p></blockquote><p id="4446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里找到本系列<a class="ae lp" href="https://sakshamgulati123.medium.com/creating-and-deploying-a-cat-dog-image-classifier-using-tensorflow-and-streamlit-part-2-90159563e1e9" rel="noopener">的<strong class="ig hi">第二部</strong>。请在下面留下你的想法和评论。只有好心情！</a></p><p id="167e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">请在我的笔记本下面找到-</p><p id="8e26" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lp" href="https://www.kaggle.com/sakshamgulati/catdog/edit/run/66891234" rel="noopener ugc nofollow" target="_blank"> Kaggle链接</a></p><p id="3472" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lp" href="https://github.com/sakshamgulati/Kaggle/blob/master/CatDog.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub代码</a></p></div></div>    
</body>
</html>