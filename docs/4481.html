<html>
<head>
<title>Why it makes a difference how to standardize training and test set</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么如何标准化训练和测试集会有所不同</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/why-it-makes-a-difference-how-to-standardize-training-and-test-set-e95bf350bed3?source=collection_archive---------2-----------------------#2021-10-25">https://medium.com/analytics-vidhya/why-it-makes-a-difference-how-to-standardize-training-and-test-set-e95bf350bed3?source=collection_archive---------2-----------------------#2021-10-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/34e06ea3f2b37144cf6a524fa1f51723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*brBn5-PcThNA9PxI"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@callmefred?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">叫我弗雷德</a></figcaption></figure><p id="bf3e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博文中，我想简要说明为什么正确衡量你的训练和测试数据很重要。虽然我认为大多数机器学习实践者自动避免了不使用来自训练集的学习定标器标准化测试数据的谬误，但我认为许多实践者并不知道确切的原因。在这里，我将给出一个具体的例子，说明为什么您也需要为测试集使用来自训练集的scaler。</p><p id="5b55" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们首先创建一些虚拟数据。例如，我们可以假设以下是由三个变量描述的三个不同的用户。我们还创建目标，例如，我们可以考虑每个用户所属的不同集群:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/469818e1238e26b07db2507e05d31d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sy_nVBepCwZexUrJEZPIGw.png"/></div></div></figure><p id="07a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以看到在<em class="jy"> test_data </em>中，用户1和用户3完全一样。这是故意的。让我们创建两个标准缩放器，这意味着我们将减去平均值，然后除以方差。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/27d2167607552d3bfbba3616aab77df8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yBbKxJzQnvSAOjop27VYyA.png"/></div></div></figure><p id="7a5c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您已经可以看到这两种方法之间的差异。前两个<em class="jy"> scaled_data </em>是使用来自StandardScaler的fit_transform方法构建的，而最后一种方法使用来自trainset的“经过训练的”Scaler来缩放test_dataset。让我们来看看不同的均值和方差:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es ka"><img src="../Images/dde114f2a96a73c517c86e26742e8638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d1mHggvMbU8SjN0r6X4lg.png"/></div></div></figure><p id="aa1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是数据的样子:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div class="er es kb"><img src="../Images/e2b31062eb993beccf246b6b249d694d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/format:webp/1*0QD57qeMi0tBf_2-TH8SHQ.png"/></div></figure><p id="0519" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">乍一看，正确缩放的测试数据看起来是错误的，只是因为这些数字似乎太遥远了。然而，让我们看看当我们在训练集上拟合简单的线性回归并在测试集上进行预测时会发生什么:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jt"><img src="../Images/e2b2fd5eea7094feef168439878bbae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cy4C2dnjFegNwBmZvXQwLw.png"/></div></div></figure><p id="0b64" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">记住，在我们的测试集中，我们期望用户1和用户3分别被归类为2和0。</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kc"><img src="../Images/3b274de16a6f3c6d1d4c99cd3799047b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0RBzEb88BV9CjPgeeUhsJw.png"/></div></div></figure><p id="60f4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但这在这里根本没有发生。我们看到，第一个用户和第三个用户都没有被正确分类，尽管他们完全相同。让我们来看看使用我们列车组的定标器时会有什么结果:</p><figure class="ju jv jw jx fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es kd"><img src="../Images/4db4c840229d758c67d2446a6f89da41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w1bVXzWIei-HZjJb2xQ3yQ.png"/></div></div></figure><p id="c184" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这一次，线性模型正确地将用户1和用户3分类。所以你可以看到错误使用缩放会产生多大的差异。这就是为什么我们使用训练集的均值和方差来标准化测试集。</p><p id="e8c6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拉塞</p><p id="8a81" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jy">原载于2021年10月25日</em><a class="ae iu" href="https://lschmiddey.github.io/fastpages_/2021/04/10/DeepLearning_TabularDataAugmentation.html" rel="noopener ugc nofollow" target="_blank"><em class="jy">https://lschmiddey . github . io</em></a><em class="jy">。</em></p></div></div>    
</body>
</html>