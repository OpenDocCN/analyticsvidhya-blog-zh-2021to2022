<html>
<head>
<title>Building a TCP and UDP traces data pipeline and visualizing the senders and receivers using Neo4j</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Neo4j构建TCP和UDP跟踪数据管道并可视化发送方和接收方</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/building-a-tcp-and-udp-traces-data-pipeline-and-visualizing-the-senders-and-receivers-using-neo4j-fb0fdcd7aaaa?source=collection_archive---------13-----------------------#2021-02-22">https://medium.com/analytics-vidhya/building-a-tcp-and-udp-traces-data-pipeline-and-visualizing-the-senders-and-receivers-using-neo4j-fb0fdcd7aaaa?source=collection_archive---------13-----------------------#2021-02-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6b50" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated">他的项目是使用Python构建一个数据管道，将网络追踪从数据集移动到Neo4J数据存储。TCP和UDP上的每个跟踪及其子跟踪(ARP和ICMP)都需要建模并存储在Neo4J中。目的是将每个发送者和接收者可视化为节点，以及作为关系使用的协议类型。</p></div><div class="ab cl jl jm go jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="ha hb hc hd he"><h1 id="31ae" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">使用的库和包:</strong></h1><p id="b90e" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated"><strong class="ig hi"> PYPCAPFILE: </strong> Python库，用于处理、读取和解析来自pcap文件的包。</p><p id="ea53" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SCAPY: 一个Python程序，可以让用户发送、读取、解析和伪造网络数据包。“scapy”将与“pypcapfile”一起使用，以获得更大的灵活性和更好的结果。</p><p id="1135" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> PY2NEO: </strong>一个客户端库，用于在Python应用程序和命令行中使用Neo4Jj。我将使用这个库的API与我的Neo4j数据库(本地托管)进行交互，而不必手动编写Cypher SQL。相反，我将只对所有Cypher SQL操作使用Python代码。</p></div><div class="ab cl jl jm go jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="ha hb hc hd he"><h1 id="f01c" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">实施:</h1><p id="ca31" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">我将跟踪四个协议并将其存储在我的Neo4j本地数据库中:</p><p id="10e9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">传输控制协议:</strong>允许一台计算机通过发送/接收数据包与另一台计算机对话。数据包地址可以是IPv4 (32位IP地址)或IPv6 (128位IP地址)类型。</p><p id="06d7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">用户数据报协议:</strong>是一种替代的通信传输协议，主要用于在互联网上的应用程序之间建立低延迟和容错连接。</p><p id="38a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">互联网控制消息协议:</strong>是一种错误报告协议网络，用于在网络出现问题时向源IP地址生成错误消息。</p><p id="4bfa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">地址报告协议:</strong>是互联网协议使用的协议，用于将IP网络地址映射到数据链路协议使用的硬件地址。</p></div><div class="ab cl jl jm go jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="ha hb hc hd he"><p id="efa5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于这个项目，我使用了Jupyter Notebook，因为它允许更有组织的工作流，并使运行代码块和在每个步骤后可视化它们变得容易。我包括朱庇特笔记本”。ipynb“标准旁边的代码文件”。为了方便起见。</p><p id="e99f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我们使用“pip”安装所有的包:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es kv"><img src="../Images/a6049074ab208209f8d38537df84a70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a0144yxcl2OVQb7-RcfDYQ.png"/></div></div></figure><p id="b1a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然后，我们导入不同的包:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lh"><img src="../Images/8073faddd2bf9fb571cd3e059f3fdb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1378/format:webp/1*4lXQMW7lwDCula3QvWXAlA.png"/></div></figure><p id="d611" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“保存文件”模块允许读取和解析pcap文件。“以太网”和“ip”模块是“保存文件”使用的补充模块。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es li"><img src="../Images/c5329d2bcefccd463320d68f0bbafe93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1386/format:webp/1*TZ_KAnGtEpEfoP24vAstew.png"/></div></div></figure><p id="49fa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">“rdpcap”代表“读取pcap文件”，它类似于pcap file包中的“savefile”模块。然而，每个命令的读取格式和结果是不同的，我们将在后面看到原因。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lj"><img src="../Images/eeda4533aab6889a4231fcf881fd9d82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1388/format:webp/1*K1a0YGs2eIZMAQYnUrcD6w.png"/></div></figure><p id="a588" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们从“py2neo”包中导入“图形”、“节点”和“关系”模块，这将允许我们连接到Neo4j数据库，并创建节点以及它们之间的关系。接下来，我们读取二进制格式的pcapfile。我们可以看到，有1000个数据包被读取并加载到“capfile”变量中。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lk"><img src="../Images/be2dd691e00cfda499770d2a901c1859.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*LARbV-3fEW8vm5aTsuxEQw.png"/></div></figure><p id="2930" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，让我们使用探索性数据分析(EDA)来分析我们刚刚加载的数据。我们总共有601个TCP数据包、369个UDP数据包和30个ICMP数据包。</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ll"><img src="../Images/5ce8a0d91ed16b83f0b71aac1abc7757.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*7SB-MYNrfKK4SBwBVgOTUw.png"/></div></figure><p id="8c9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">另一个命令是显示数据摘要，显示我们正在处理的数据集的稍微详细的描述:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lm"><img src="../Images/71beff9777ef95a84554b485aeebf634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*orYauf93CRxbl1zD3TUBDw.png"/></div></figure><p id="671b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，它没有向我们显示TCP数据包下的地址类型是IPv4还是IPv6。为此，我们需要更深入地了解数据包:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es ln"><img src="../Images/0c26a612527d0649b6aedd5fa41c22c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*fB3KK0ee2mJgX24Mb5nUag.png"/></div></figure><p id="d055" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们将需要使用上述方法来识别数据包地址类型。然后，除此之外，我们将使用下面的方法来显示所使用的协议类型:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lo"><img src="../Images/f530ed98cd0cc01c23c5cc0ce94e0858.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*W83YPukf0LJaHPtIQXuYLg.png"/></div></figure><p id="1a36" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，在开始转换数据的代码之前，我们通过指定我创建的密码连接到我们的Neo4j数据库:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div class="er es lp"><img src="../Images/02eed4c66a8bd7ea1a6f554108fb77be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1382/format:webp/1*mN_uQXFVY2eNzBulB3FMGg.png"/></div></figure><p id="b4c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">大部分代码如下:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lq"><img src="../Images/7c34d8e3a0400c33fa0d1a0865a04598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_WeaoJfkYC7hSPcWu4deg.png"/></div></div></figure><p id="9305" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用枚举遍历packets.sessions字典来跟踪每个键和对值。然后，我们将数据包拆分(成一个字符串列表)。如前面的屏幕截图所示，数据包的类型总是出现在字符串的第一位。因此，我们需要在字符串的第一个索引中检查协议的类型。</p><p id="0351" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们创建两个“Host”类型的节点，一个用于发送方，一个用于接收方。如果两个IP相似，使用相同的协议，Neo4j不会存储。此外，节点的名称就是IP地址。对于TCP数据包，下一步是检查它是IPv4还是IPv6数据包。</p><p id="478d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们需要在数据包中更深入一层，如上面的两个截图所示。</p></div><div class="ab cl jl jm go jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="ha hb hc hd he"><h1 id="3dfb" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">结果在Neo4j </strong></h1><p id="2727" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">在运行Jupyter笔记本之后，我们得到了以下结果:这个截屏显示了产生的UDP节点和关系，限制为25个节点以避免延迟和滞后。使用的Cypher SQL语句是:</p><p id="5503" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lr">匹配p =()—【r:UDP】=&gt;()返回p限制25 </em> </strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es ls"><img src="../Images/8b278c0853eb6e1ac4a94b4c739a3e74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mkrye2_JAQWzxdPJoyj3iQ.png"/></div></div></figure><p id="9f4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，让我们看看ICMP节点和关系:</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lt"><img src="../Images/d19a671b1c0473d451e7fea26e252bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wLa-U__MNDqZ0nRcn6_iVQ.png"/></div></div></figure><p id="77ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，TCP — IPv4节点(我们的PCAP文件中没有任何IPv6数据包):</p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lu"><img src="../Images/de1fc0817764f32a72ed931bab622b84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z4MbuxjU2V0u2brIk1i6lQ.png"/></div></div></figure><p id="918f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，让我们使用下面的Cypher SQL查询来查看包含所有节点、关系和无显示限制的整个数据库:</p><p id="edb6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="lr">匹配(n:主机)返回n </em> </strong></p><figure class="kw kx ky kz fd la er es paragraph-image"><div role="button" tabindex="0" class="lb lc di ld bf le"><div class="er es lv"><img src="../Images/dbf1c6ec83dd2e362c8fe06afe48fcbb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocs31igRPlf32ZvQifGJWw.png"/></div></div></figure></div><div class="ab cl jl jm go jn" role="separator"><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq jr"/><span class="jo bw bk jp jq"/></div><div class="ha hb hc hd he"><h1 id="7fd1" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak">更多信息:</strong></h1><p id="cdaf" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">这个项目的源代码可以在:<a class="ae lw" href="https://github.com/mouadlasri/datapipeline-TCP-UDP-neo4j" rel="noopener ugc nofollow" target="_blank">mouadlasri/data pipeline-TCP-UDP-neo4j</a>获得</p><p id="7f8b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">项目运行的视频演示可在:<a class="ae lw" href="https://youtu.be/3c4H-Dagm3s" rel="noopener ugc nofollow" target="_blank">https://youtu.be/3c4H-Dagm3s</a>获得</p></div></div>    
</body>
</html>