# 哈希表入门

> 原文：<https://medium.com/analytics-vidhya/getting-started-with-hash-tables-3693f0809905?source=collection_archive---------17----------------------->

## *如何理解和编码哈希表*

![](img/36fbd6fcfb1046f66d9441554b8f7065.png)

由[沙哈达特拉赫曼](https://unsplash.com/@hishahadat?utm_source=medium&utm_medium=referral)在 [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral) 上拍摄的照片

## **简介**

据 [statista](https://www.statista.com/statistics/871513/worldwide-data-created/#:~:text=Amount%20of%20information%20globally%202010%2D2024&text=The%20total%20amount%20of%20data,ever%2Dgrowing%20global%20data%20sphere) 统计，2020 年全球数据总量等于 149 zettabytes。随着全球数据量如此之大，并且每年都在以更快的速度增长，很明显，高效存储数据的能力已经成为计算机科学的关键挑战之一。在本文中，我们将探索最常用的数据存储结构之一:哈希表。

## **什么是哈希表？**

哈希表是用于存储数据的数据结构[。最初，它看起来很像一个数组或一个列表，但它通过允许非常快速的数据检索而将自己与它们区分开来，不管有多少数据。](https://en.wikipedia.org/wiki/Data_structure)

哈希表通过使用哈希函数来实现这一点。这是一个将哈希表的索引映射到存储的数据值的函数。这意味着与其他数据结构相比，查找元素的时间复杂度总是等于 1。

让我们看一个与线性数组/列表相比的散列表的例子。最初这两个看起来完全一样。

![](img/93889cc3d2278d1eefe72cd892fcb270.png)

然而，如果我们想在这个例子中找到克里斯，这两者之间的区别将变得非常明显。在一个数组中，我们事先不知道克里斯存储在哪里。这意味着我们必须查看每个索引，直到它符合我们的搜索标准。

![](img/fd44f22c8087109567523e042cbbe362.png)

花了三次努力才找到克里斯。这可能看起来不多，但在更大的阵列中，这可能需要更长的时间。尤其是当我们要找的数据存储在数组的末尾时。这就是哈希表有用的地方。为了简单起见，让我们看一下与前面相同的例子。

![](img/7c5385ba230b5dad7bc2d92eda275099.png)

使用哈希表尝试了一次才找到克里斯。此外，在任何哈希表中查找任何元素总是需要一次尝试。这是因为*散列函数*，它根据元素的值显示元素的位置。

## **哈希函数**

前面的例子说明了哈希表的魔力来自哈希函数的魔力。有许多方法可以创建散列函数，但是一般的目标总是使用数据的值作为输入，并获得索引作为输出。在本例中，我们将把它用作哈希函数:

*index =* *((首字母的字母表值)— 1) % 5*

使用这个散列函数，我们可以创建一个散列表。请记住，*‘第一个字母的字母值’*与该字母在字母表中的位置有关。因此对于 *a* 该值为 1，对于 *b* 该值为 2，以此类推。

![](img/b54c0e26ec8b80a0abceb688f3c4bf68.png)

这个例子展示了如何使用 hash 函数填充哈希表。然而，这个例子也展示了一个哈希表，它被完美地填充，没有两个不同的哈希值是相同的。不幸的是，情况并非总是如此。事实上，两个不同的散列函数生成相同的索引是相当常见的。这被称为*碰撞*

## **碰撞**

冲突是指两个不同的哈希函数生成相同的索引。这是一个问题，因为一个索引不能保存多个值。有几种技术可以解决这个问题。

![](img/d335dfd2c8ef849730dd5c358e663ccd.png)

第一种可能的技术称为*开放寻址*。这种技术通过遍历数组搜索未使用的索引来解决冲突。有几种方法可以做到这一点，但最常用的一种叫做*线性探测*。这种技术使用线性搜索来查找空地址。

例如，如果我们想将“earl”添加到我们的哈希表中，那么在索引 4 上将会发生冲突。这可以使用线性探测来解决。使用这种技术，我们在索引 6 处找到一个空地址，因此我们可以在那里添加“earl”。

![](img/cd27eae2d6c49827b526f693fba69a0f.png)

请记住,' earl '的哈希函数仍然指向索引 4。这意味着，对于数据检索，您还需要在哈希之后执行线性搜索，以便在哈希表中找到“earl”。这降低了数据检索的速度，这是开放式寻址的一个缺点。

第二种技术称为*链接*(也称为封闭寻址)*。*这种技术本质上是将哈希表从一维数组转换成二维数组。通过这样做，每个索引可以保存多个值，这使得冲突不可能发生。

例如，如果我们想将“earl”添加到哈希表中，那么在索引 4 上就不会有冲突。这是因为(与前面的例子不同)索引 4 现在可以保存多个值。

![](img/6707862a3fad26a9b0af1a7bbfcf6bf0.png)

最后一个选择是调整哈希表的大小，给它比实际需要更多的地址。这减少了冲突的机会，因为对于需要存储的每一段数据，都有多个可用的地址。衡量这一点的一个好方法是*负载因子*，它是通过将需要存储的项目数除以哈希表的大小来计算的。

![](img/a5c30b382afda3385eb95794a0ca9727.png)

## **总之**

哈希表是存储数据的一种很好的方式，尤其是当您想要存储大量经常使用的数据时。然而，一个重要的附带说明是，哈希表、哈希函数和冲突管理的设计在这个数据结构的质量中起着很大的作用。

## **代号**

散列表很容易用 python 实现。在这个例子中，哈希表是使用面向对象的方法制作的。使用线性探测来处理冲突，线性探测是开放式寻址的一种变体。