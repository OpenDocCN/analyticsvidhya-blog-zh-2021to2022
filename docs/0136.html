<html>
<head>
<title>Scope in C++ , a tutorial ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">C++中的作用域，教程？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scope-in-c-a-tutorial-6e8c9d9db447?source=collection_archive---------19-----------------------#2021-01-05">https://medium.com/analytics-vidhya/scope-in-c-a-tutorial-6e8c9d9db447?source=collection_archive---------19-----------------------#2021-01-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="b936" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">什么是范围？</h1><p id="2811" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">作用域<strong class="je hi"> <em class="ka">是一个标识符被声明为</em> </strong> <em class="ka"> </em>的地方，它可以被认为包含了一个标识符列表。在<code class="du kb kc kd ke b">C++</code>中有多个作用域，因此有多个地方可以声明标识符。</p><p id="ee8f" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">标识符在同一个作用域内</em> </strong>只能定义一次。<code class="du kb kc kd ke b">C++</code>中的标识符只是一个名称，例如，可以给定一个名称空间、一个类、一个函数、一个变量...在不同的作用域中，可以定义同名的标识符。</p><p id="0174" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">有六个范围</em> </strong>，在<code class="du kb kc kd ke b">C++</code>。它们是，文件作用域也称为全局作用域；命名空间范围、类范围、块范围，也称为局部范围；函数范围和原型范围。所以在这些作用域中，可以声明标识符。范围可以相互嵌套。</p><p id="289b" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">名称查找</em> </strong>，是在不同的可访问范围内搜索一个标识符的行为。</p><h1 id="4420" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">文件范围或全局范围</h1><p id="243c" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">文件作用域，或全局作用域，也称为<strong class="je hi"> <em class="ka">翻译单元作用域</em> </strong>。翻译单元是在执行了预处理器指令(如<code class="du kb kc kd ke b">#include</code>或<code class="du kb kc kd ke b">#define</code>)后得到的源代码。</p><p id="2163" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">在翻译单元作用域或文件作用域<strong class="je hi"> <em class="ka">中声明的标识符在任何</em> </strong> <em class="ka">其他</em>作用域之外声明。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="1a8f" class="ks if hh ke b fi kt ku l kv kw">/* file :  myMath.h */</span><span id="51d4" class="ks if hh ke b fi kx ku l kv kw">int add(int a , int b ){<br/>  return a + b ;}</span><span id="220d" class="ks if hh ke b fi kx ku l kv kw">float add(float a, float b){<br/>  return a + b ;}<br/>/* add , is an identifier declared in <br/>   the file scope , for a function , <br/>   which is overloaded .*/</span><span id="a1f0" class="ks if hh ke b fi kx ku l kv kw">/* file :  myProg.cpp */</span><span id="927c" class="ks if hh ke b fi kx ku l kv kw">#include "myMath.h" <br/>/*Includes the file <br/>  myMath.h .<br/>  After preprocessing , <br/>  a single translation unit ,<br/>  or source code is created . <br/>  The global identifiers are : <br/>  add , var_i , var1_i , <br/>  var_f , var1_f , main .*/</span><span id="a884" class="ks if hh ke b fi kx ku l kv kw">int var_i  = 0;<br/>int var1_i = 1;</span><span id="7be6" class="ks if hh ke b fi kx ku l kv kw">float var_f = 1.0f;<br/>float var1_f = 3.0f;</span><span id="2666" class="ks if hh ke b fi kx ku l kv kw">int main(void ){<br/>  int var1_i = 3;<br/>  int result_i = add(var_i , var1_i );<br/>  /*add var_i which is equal to 0 , with<br/>    var1_i , which is equal to 3  ,<br/>    the result 3 , is stored , in result_i .*/</span><span id="9e0e" class="ks if hh ke b fi kx ku l kv kw">float var1_f = -1.0f;<br/>  float result_f = add(var_f , ::var1_f );<br/>  /*add var_f which has a value of 1.0f ,<br/>    to the variable  qualified <br/>    by the global scope var1_f .<br/>    ::var1_f has a value of 3.0f . <br/>    The result is 4.0f , and is stored in <br/>    var1_f .*/ }</span></pre><p id="8bb9" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">在全局作用域中声明的标识符<strong class="je hi"> <em class="ka">是可见的，可以从声明后的点开始从全局作用域或任何嵌套作用域中访问</em> </strong>。</p><p id="0d9d" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">例如，在前面的例子中，<code class="du kb kc kd ke b">var_i</code>在<code class="du kb kc kd ke b">void )</code>后的花括号所限定的范围内是可见的，因此在调用函数<code class="du kb kc kd ke b">add</code>时使用了它的值。</p><p id="890b" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">通常，父作用域中声明的标识符在嵌套作用域中是可见的。在名称查找中，首先搜索嵌套范围，同时也搜索父范围。<strong class="je hi"> <em class="ka">名称查找从使用标识符的作用域开始</em> </strong>。</p><p id="da49" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">所以在前面的例子中，<code class="du kb kc kd ke b">var1_i</code>的值是<code class="du kb kc kd ke b">3</code>，因为<code class="du kb kc kd ke b">var1_i</code>被用在<code class="du kb kc kd ke b">void ) </code>后的花括号所限定的范围内，在这里执行对<code class="du kb kc kd ke b">add</code>函数的调用，因此名字查找在这个范围内开始。</p><p id="c6f4" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">可以使用范围解析运算符<code class="du kb kc kd ke b">::</code>指定<strong class="je hi"> <em class="ka">在哪里执行名称查找</em> </strong>。当标识符由作用域限定时，仅在限定的作用域中搜索该标识符。</p><p id="988f" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">因此，在前面的例子中，<code class="du kb kc kd ke b">::var1_f</code>用全局作用域限定，在全局作用域中搜索标识符var 1 _ f。<code class="du kb kc kd ke b">::var1_f</code>的值为<code class="du kb kc kd ke b">3.0f</code>。</p><h1 id="d297" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">命名空间范围</h1><p id="16c3" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个<strong class="je hi"> <em class="ka">命名空间被用来</em> </strong> <em class="ka"> </em>创建作用域。作用域包含标识符声明，可以防止名称冲突。可以在不同的作用域中定义同名的标识符。范围定义可以扩展。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="b643" class="ks if hh ke b fi kt ku l kv kw">int xid_i = 1 ;</span><span id="933a" class="ks if hh ke b fi kx ku l kv kw">namespace OTHER_ID{<br/>  int xid_i = 5 ;}</span><span id="1a63" class="ks if hh ke b fi kx ku l kv kw">namespace OTHER_ID{<br/>  int zid_i = 5 ;}</span><span id="a21c" class="ks if hh ke b fi kx ku l kv kw">float tax(float money ){<br/>  return money * 0.15f ;}</span><span id="84e0" class="ks if hh ke b fi kx ku l kv kw">namespace irregular{<br/>  float tax(float money ){<br/>    return money * 0.20f ;}}</span><span id="e309" class="ks if hh ke b fi kx ku l kv kw">namespace discounted{<br/>  float tax(float money ){<br/>    return money * 0.10f ;}}</span><span id="270a" class="ks if hh ke b fi kx ku l kv kw">namespace {<br/>  char d_c = '1';<br/>  char l_c = 'u'; }</span><span id="ac36" class="ks if hh ke b fi kx ku l kv kw">int main(void ){</span><span id="24bd" class="ks if hh ke b fi kx ku l kv kw">char var_c = ::d_c;<br/>  /*The identifier d_c is<br/>    preceded with the global <br/>    scope operator :: .<br/>    d_c is declared in an unnamed <br/>    namespace . Identifiers in an<br/>    unnamed namespace belong as<br/>    accessible to the global scope . <br/>    Hence the value , of the <br/>    variable var_c , is the <br/>    character '1' .*/</span><span id="62dd" class="ks if hh ke b fi kx ku l kv kw">var_c  = l_c ; <br/>  /*The identifier l_c is used in<br/>    the current scope , a lookup<br/>    for the identifier l_c takes<br/>    place in the current scope .<br/>    It is not found , hence the enclosing<br/>    scope , which is the global scope ,<br/>    is searched . l_c is declared in<br/>    an unnamed namespace , as such it<br/>    belongs to the file scope as<br/>    accessible , hence the value of<br/>    the variable var_c is<br/>    the character 'u' .*/</span><span id="ba87" class="ks if hh ke b fi kx ku l kv kw">tax(20 );<br/>  /*tax is called without using the<br/>    scope operator . Hence  the scope<br/>    where the tax identifier is used ,<br/>    is first searched , and after that<br/>    other accessible scopes . <br/>    The tax function is defined in the global, <br/>    scope , hence the returned value is <br/>    3.0f .*/</span><span id="51ab" class="ks if hh ke b fi kx ku l kv kw">irregular::tax(20 );<br/>  /*tax is qualified , using the scope <br/>    operator :: by the namespace irregular , <br/>    the tax identifier is searched in ,<br/>    the namespace irregular . The <br/>    tax function defined in irregular , <br/>    is called . The result is 4.0f .*/</span><span id="8810" class="ks if hh ke b fi kx ku l kv kw">using irregular::tax ; <br/>  tax(20 );<br/>  /*The using declaration , <br/>    using irregular::tax is used .<br/>    The using declaration , adds the <br/>    tax identifier , to the current <br/>    scope . An identifier  with the same <br/>    name ,  must not exist in  the current<br/>    scope , or else this will <br/>    cause an error .<br/>    tax(20 ) is called , and the <br/>    scope operator  :: is not used , <br/>    hence the current scope , is <br/>    searched for the tax identifier . <br/>    The tax identifier is found in the <br/>    current scope, this is the identifier <br/>    added from the namespace irregular , <br/>    hence the tax function from irregular , <br/>    is called . The result is 4.0f .*/</span><span id="c5c3" class="ks if hh ke b fi kx ku l kv kw">using namespace discounted;<br/>  tax(20 );<br/>  /*The using directive , using namespace , <br/>    does not add the identifiers <br/>    in the namespace discounted , <br/>    to the current scope . They <br/>    are only  made accessible . When<br/>    calling tax , the current scope <br/>    is searched for the identifier tax .<br/>    The identifier tax is added , <br/>    by the using declaration , <br/>    using irregular::tax , precedingly , <br/>    to the current scope , hence what is<br/>    called is the  tax function from , <br/>    the irregular namespace , which <br/>    returns 4.0f , and not 2.0f .*/</span><span id="a895" class="ks if hh ke b fi kx ku l kv kw">using namespace OTHER_ID;<br/>  int varID_i = xid_i ;<br/>  /*This statement will cause , <br/>    a compiler error to occur . <br/>    The using directive , using namespace <br/>    , makes accessible all the identifiers <br/>    in the namespace OTHER_ID , in the <br/>    current scope .  The identifiers , <br/>    from the global scope , are also accessible<br/>    from the current scope . Hence ambiguity ,<br/>    to which identifier is meant arise .*/ }</span></pre><h1 id="35c1" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">类别范围</h1><p id="b0a9" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">标识符声明在一个类中，有<strong class="je hi"> <em class="ka">类作用域</em> </strong>。作用域操作符<code class="du kb kc kd ke b">::</code>可以用来访问作用域的成员。当与类一起使用时，它可用于访问或初始化静态变量。它也可以用来访问一个类的方法，以便提供一个定义。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="a13f" class="ks if hh ke b fi kt ku l kv kw">#include&lt;iostream&gt;</span><span id="f2e6" class="ks if hh ke b fi kx ku l kv kw">class Foo{<br/>  /*Declare The class<br/>    Foo .*/<br/>public :<br/>  int fct();<br/>  /*Declare Foo's public<br/>    method fct .*/<br/>private :<br/>  static int var;<br/>  /*Declare Foo's private<br/>    static variable var .*/};</span><span id="58a8" class="ks if hh ke b fi kx ku l kv kw">int Foo::var = -1;<br/>/*Initialize Foo private<br/>  static variable var .*/</span><span id="8f45" class="ks if hh ke b fi kx ku l kv kw">int Foo::fct(){<br/>  /*Define Foo function fct .*/<br/>  return var;}</span><span id="209e" class="ks if hh ke b fi kx ku l kv kw">int main(void ){<br/>  Foo foo;<br/>  std::cout &lt;&lt; foo.fct() &lt;&lt; std::endl;<br/>  /*Output :<br/>   -1 . */}</span></pre><h1 id="b6f0" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">本地范围</h1><p id="5e51" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">一个局部作用域，以花括号<code class="du kb kc kd ke b">{}</code>开始和结束。<strong class="je hi"> <em class="ka">局部范围</em> </strong>可以嵌套。定义函数时，函数参数是紧接在其参数列表之后的局部范围的一部分。for循环中的声明也是紧跟在for循环之后的局部范围的一部分。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="4721" class="ks if hh ke b fi kt ku l kv kw">#include&lt;iostream&gt;</span><span id="3637" class="ks if hh ke b fi kx ku l kv kw">int add(int x , int y );<br/>/*x , y belong to the function ,<br/>  prototype scope .*/</span><span id="6736" class="ks if hh ke b fi kx ku l kv kw">int main(){<br/>  std::cout &lt;&lt; add(1 , 3 ) &lt;&lt; std::endl;<br/>  std::cout &lt;&lt; add(3 , 1 ) &lt;&lt; std::endl ;<br/>/*Output :<br/>20<br/>2 .*/}</span><span id="6242" class="ks if hh ke b fi kx ku l kv kw">int add(int x , int y ){<br/>  int z = 10;<br/>  /*x , y , z belong to the <br/>    local scope created after<br/>    the function parameters <br/>    list .*/<br/>  if(x &lt; y ){<br/>  /*The curly brackets create a <br/>    nested local scope , <br/>    z belongs to the newly <br/>    create nested local<br/>    scope .*/<br/>     int z = 20 ; <br/>     return z ;<br/>     /*Returns 20 .*/}<br/>  else {<br/>    int i = 0 ;<br/>    /*i Belongs to another newly <br/>      create nested local<br/>     scope.*/<br/>    for(int i = 2 ; i &lt; 4 ; i ++ )<br/>    /*Creates another local scope , <br/>      i has a starting value of 2 .*/ <br/>      return i; /*returns 2 */ }}</span></pre><h1 id="d5e2" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">功能范围</h1><p id="743b" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">标签声明在一个函数内</em> </strong> <em class="ka">，</em>有一个函数作用域。这些是仅有的具有功能范围的实体。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="c98d" class="ks if hh ke b fi kt ku l kv kw">#include&lt;iostream&gt;<br/>void square_cube( int n ){<br/>  int i = 0 ;<br/> loop:{<br/>    if( i == n )<br/>      return ;<br/>    else if(i % 2  == 0 )<br/>      goto powerTwo;<br/>    else<br/>      goto powerThree;</span><span id="cd4a" class="ks if hh ke b fi kx ku l kv kw">powerTwo :<br/>    std::cout &lt;&lt; i * i &lt;&lt; std::endl;<br/>    i++;<br/>    goto loop;<br/>  powerThree:<br/>    std::cout &lt;&lt; i * i * i &lt;&lt; std::endl;<br/>    i++;<br/>    goto loop ;}}</span><span id="b4e9" class="ks if hh ke b fi kx ku l kv kw">int main(void ){<br/>  square_cube(5 ) ;}<br/>/*output <br/>0<br/>1<br/>4<br/>27<br/>16*/</span></pre><h1 id="c10b" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">原型范围</h1><p id="e3df" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">原型声明 中声明<strong class="je hi"> <em class="ka">的参数有原型作用域。</em></strong></p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="98e9" class="ks if hh ke b fi kt ku l kv kw">bool fit(float weight);<br/>/*weight , has prototype scope .*/</span></pre><h1 id="ca9c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">名称查找是如何发生的？</h1><p id="67c8" class="pw-post-body-paragraph jc jd hh je b jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ha bi translated">除非使用范围操作符<code class="du kb kc kd ke b">::</code>限定，否则在使用范围内，通过<strong class="je hi"> <em class="ka">可访问范围</em> </strong> <em class="ka"> </em>搜索标识符的起始点，如前几节所述。如果合格，则在合格范围中搜索标识符。</p><p id="4691" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated"><strong class="je hi"> <em class="ka">除了</em> </strong>之外，对于不合格的函数，如果在使用该函数的作用域或其他可访问的作用域中找不到该函数的名称，则进行参数相关的名称查找，也称为Koenig查找。</p><p id="5ba3" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated">基本上，在<strong class="je hi"> <em class="ka">类型的参数</em> </strong>的范围内搜索函数声明。</p><pre class="kk kl km kn fd ko ke kp kq aw kr bi"><span id="eb12" class="ks if hh ke b fi kt ku l kv kw">#include&lt;iostream&gt;</span><span id="b014" class="ks if hh ke b fi kx ku l kv kw">namespace nmspcFoo{<br/>  class ClassFoo{};</span><span id="39f7" class="ks if hh ke b fi kx ku l kv kw">  void printScopeName(ClassFoo arg ){<br/>    std::cout &lt;&lt; "nmspcFoo" &lt;&lt; std::endl; }}</span><span id="bda6" class="ks if hh ke b fi kx ku l kv kw">int main(void ){<br/>  nmspcFoo::ClassFoo fooVar ;<br/>  printScopeName(fooVar ) ;}<br/>/*Output <br/>nmspcFoo .*/</span></pre></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="66d6" class="pw-post-body-paragraph jc jd hh je b jf kf jh ji jj kg jl jm jn kh jp jq jr ki jt ju jv kj jx jy jz ha bi translated"><em class="ka">原载于2021年1月5日https://twiserandom.com</em><em class="ka">的</em> <a class="ae lf" href="https://twiserandom.com/cpp/scope-in-cpp-a-tutorial/" rel="noopener ugc nofollow" target="_blank"> <em class="ka">。</em></a></p></div></div>    
</body>
</html>