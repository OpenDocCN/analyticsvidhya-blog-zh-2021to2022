<html>
<head>
<title>A beginner’s guide to Big Data: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">大数据初学者指南:第1部分</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/a-beginners-guide-to-big-data-part-1-a24d3a7bbe6c?source=collection_archive---------9-----------------------#2021-03-13">https://medium.com/analytics-vidhya/a-beginners-guide-to-big-data-part-1-a24d3a7bbe6c?source=collection_archive---------9-----------------------#2021-03-13</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="9581" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近，我开始参加大学的大数据讲座，发现教授的每一句话都是我要破解的神秘代码。一句话中的许多技术术语对我来说毫无意义，直到我决定成为艾伦·图灵来破解句子中的信息，以免被发现在课堂上睡觉！除了笑话，今天的帖子讨论了人们需要熟悉的术语，以便在大数据方面有一个良好的开端。我会从简单的开始，这样你就不会回避这篇文章。</p><p id="d5d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">集群</strong></p><p id="838d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就像一群工作人员比一个工作人员用更少的时间完成一项工作一样，一群计算机比一个工作人员执行更快的计算。集群是一组计算机，称为节点(类似于图中的节点)，通过网络连接，由软件控制和调度。每台计算机/节点大部分时间都有相同的操作系统和硬件。然而，人类因打破他们制定的规则而臭名昭著。一组计算机，每个使用不同的操作系统，分布在不同的地理位置，被称为<strong class="ig hi">网格。</strong>就像一群工人有一个按照公司规则指导他们的主人一样，节点可以根据其执行的任务分为工人和主人或客户端和服务器。服务器管理任务，任务分布在客户机上完成。随着团队的成长，它变得更有效率，但很难管理。同样，随着群集中节点数量的增加，管理变得更加高效和复杂。你可以找到小的树莓派计算机集群到像IBM Sequoia这样的大集群。</p><div class="jc jd je jf fd ab cb"><figure class="jg jh ji jj jk jl jm paragraph-image"><img src="../Images/30751f06efd72beb2ef2e3c6fbeaff92.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*-PcA8kpUr7Wx4agJLcKRvQ.jpeg"/></figure><figure class="jg jh jp jj jk jl jm paragraph-image"><img src="../Images/2af5c696486851bb93d3ce2e2d3ce637.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*W1xNbELINwq6YTaKnfdvtg.jpeg"/><figcaption class="jq jr et er es js jt bd b be z dx ju di jv jw translated">左:树莓派集群右:IBM红杉</figcaption></figure></div><p id="9090" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">哈希和排序的双重性</strong></p><p id="38e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个术语还有一个我不熟悉的术语，Hash！在继续之前，我给你出个问题。对以下数组进行排序:9，2，3，6，7！我知道你跳到了合并排序。然而，还有一个更好的解决方案。创建一个长度为9的数组，该数组存储数组中元素的出现次数，现在从数组的开始处移动，打印值为非零的索引。请注意，这个技巧使用了(key，value)思想，其中键是数组中的元素，值是具体值。Hash只是一个将键映射到其值的函数。大多数情况下，它用于降低输入的维数。</p><p id="bc5b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">观察上面例子中的一些要点:对于这样一个小例子，hash排序方式需要大空间(长度为9的数组)和小计算量(<em class="jx"> O(n) </em>)。相比之下，归并排序需要的空间小，计算量大(<em class="jx"> O(nlogn) </em>)。</p><p id="37a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">散列和排序状态的二元性在输入/输出行为方面是等价的。越过头顶，对吗？？我来简化一下。在合并排序中，你有效地做的是划分数组，排序数组的每个部分，然后组合它，直到你得到排序后的数组。在散列过程中，将输入键分组到一个散列表中，对每个组进行排序，并输出每个组，得到排序后的数组。简而言之，两者互为镜像。</p><p id="bc92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">排序—划分、排序和组合</p><p id="e0e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">哈希—组合、排序和划分</p><figure class="jc jd je jf fd jh er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jy"><img src="../Images/31f0851f07e1baebe6d549bde0e77902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCntWRL8U5okbdnoPIc-9w.png"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">散列函数</figcaption></figure><p id="052d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">地图缩小</strong></p><p id="1683" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它是一种编程模型，使用并行分布式算法来利用集群的能力。想象一下在一个大的非结构化字典集中查找一个单词(其中单词没有按字典顺序排列)。如果你有四个朋友和一本字典，你会得到与个人搜索一个单词相同的数量。但是，如果你有四个相似的字典，你可以在朋友之间划分页面，以将搜索时间长度减少到以前的四分之一。没有并行化的分布式算法，就无法利用集群的能力。</p><p id="f3f3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">Map-reduce框架由三个步骤组成:</p><ol class=""><li id="7141" class="kd ke hh ig b ih ii il im ip kf it kg ix kh jb ki kj kk kl bi translated">Map-Map是一个用户定义的函数，它接受一系列键-值对，并处理每个键-值对以生成零个或多个键-值对。</li><li id="5062" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">无序播放和排序—无序播放映射函数的输出，以便将具有相同键的键值对组合在一起。</li><li id="3b40" class="kd ke hh ig b ih km il kn ip ko it kp ix kq jb ki kj kk kl bi translated">Reduce —组合每个组键值对以生成输出。</li></ol><p id="6dfb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下图总结了每个步骤的说明。</p><figure class="jc jd je jf fd jh er es paragraph-image"><div class="er es kr"><img src="../Images/7712c8272738a96d2613dd6fe4dddff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/0*1_IXn9pkcC2W9D1w.jpg"/></div><figcaption class="jq jr et er es js jt bd b be z dx translated">地图-洗牌-缩小</figcaption></figure><p id="471c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里重要的一点是，<em class="jx">减少</em>操作只有在所有<em class="jx">映射</em>操作完成后才开始。为此，map-reduce遵循<strong class="ig hi">屏障同步。</strong>为了理解障碍同步，想象你和你的朋友要去旅行。在到达机场之前，你们决定在一个地方见面。第二天，无论谁来到那个地方，都要等到其他人都到了。当你和你所有的朋友都在那里时，你就计划继续前进。所以你的旅行是由那个地方同步的，由于它限制了其他人进一步移动，直到所有人都到达，所以它被称为障碍同步。</p><p id="105d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">映射和缩减步骤都是无状态的，这意味着每个映射器和缩减器都是相互独立的。因此，如果其中一个映射失败，服务器可以分配另一个新的映射来执行任务。这是分而治之原则的典型例子。Map-reduce避免过多内存优化其可伸缩性。由于它的无状态操作，可以通过添加更多的机器(计算机)来扩展集群。它提供对每个节点的监控和状态更新。简而言之，它提供了自动并行化或简单的可伸缩性、容错和监控。</p><p id="534d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于深度视图:</p><figure class="jc jd je jf fd jh er es paragraph-image"><div class="er es ks"><img src="../Images/986a60b3fa5226642b310bd9324a3883.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*odzyVkCNWblLrIUh.jpg"/></div></figure><p id="5be5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">功能编程</strong></p><p id="d821" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">它是一种编程范式，其中函数定义是将值映射到其他值的表达式树，而不是更新程序运行状态的命令性语句序列。函数式编程中的一个关键概念是可以将函数作为参数传递，并将它们作为值返回。这个概念叫做一级函数。您经常在python中使用这种范式，其中使用了一级函数的概念。如果代码遵循这种范式，调试会更容易。</p><p id="3ebb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">大数据</strong></p><p id="8612" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，整个讨论中的首要项。我把它包括在讨论中的原因是我的教授给它下的定义。如果你在谷歌上搜索，你可能会发现，大数据是一个3v——容量、速度和多样性，或者是架构或技术。但是定义会随着时间的变化而变化，记住当前的时间，我们可以将大数据定义为遵循“所有数据、所有时间和所有方法”座右铭的设计原则。简而言之，获取在任何时间用任何方法产生的所有类型的数据。</p><p id="b0d2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望你喜欢这个帖子。觉得有用就分享一下。</p></div></div>    
</body>
</html>