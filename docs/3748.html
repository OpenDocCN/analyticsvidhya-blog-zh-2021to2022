<html>
<head>
<title>Kernels</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">核</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/kernels-e8fc0a51fc0a?source=collection_archive---------7-----------------------#2021-07-21">https://medium.com/analytics-vidhya/kernels-e8fc0a51fc0a?source=collection_archive---------7-----------------------#2021-07-21</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="5888" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这个看似过时的想法，是理解机器学习和控制它的数学的重要一步。</p><h1 id="2815" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">特征图:</strong></h1><p id="ca60" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">让y表示两个类(用红色和蓝色斑点表示)，我们的数据有两个属性X &amp; X。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/460eb541b3c8505e57fed494440cd8c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*7baL6PMVhho6CSKvR63Z5w.jpeg"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">线性可分的</figcaption></figure><p id="1b2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们可能有这样一种情况，我们的数据是线性可分的，我们可以清楚地画一条线来分隔这两个类。</p><p id="e110" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，我们也可能遇到这样的情况，那是不可能的。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kf"><img src="../Images/e148607abde6edd92ec5e03a05a174a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/format:webp/1*riql5YuPiOfKfLctbZL8VQ.jpeg"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">不可能线性分离</figcaption></figure><p id="7aea" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，没有一条线可以把这两个阶层分开。</p><p id="ff37" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这种情况下，我们将输入映射到一个新的“特征空间”,这样我们可以使用一个更高维的超平面来分离我们的类。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es kr"><img src="../Images/57aa0ddc5488d947a3cf517184bc4d5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CLFF1hF8Ahk7ho3C.png"/></div></div></figure><p id="954c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们定义一个函数，从R -&gt; R取输入点</p><p id="4c52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">应用这个转换后，我们的数据看起来像这样。</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es ky"><img src="../Images/9afd1eeb81eb4710885418e311d8f2ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jna93evW3UIb6K-7LCrVfQ.jpeg"/></div></div></figure><p id="6a52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，<strong class="ig hi">我们可以画一个平面来分隔数据</strong>。首先，我们可以看到这是如何工作的。唯一的区别是在第三维度。外圆的X和X值较大，导致z轴上的值较小。</p><h1 id="7ba9" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">内核:</strong></h1><p id="2dd2" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">通常，只要我们需要两个输入变量的乘积，并且我们已经将输入空间转换成特征图，我们就需要计算特征图的点积<strong class="ig hi">。计算或存储这些通常是非常昂贵的，这就是“内核技巧”的由来。</strong></p><p id="bce0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如在SVM，</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es kz"><img src="../Images/f8d0225421cf630cb38adb00c475bd62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1094/format:webp/1*meWHjsV86GWKCJGPDTie1w.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">SVM的优化问题<a class="ae la" href="http://web.mit.edu/6.034/wwwbob/svm-notes-long-08.pdf" rel="noopener ugc nofollow" target="_blank">参考</a></figcaption></figure><p id="a84b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一旦我们将Xi和Xj转换成Phi(Xi)和Phi(Xj)，我们需要计算点积的有效方法。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lb"><img src="../Images/31e2340747c474a0267ce3acac3814ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/0*maggmTwXb8-OK_so.png"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lb"><img src="../Images/3fff7927ed802a093f9165076cbeb02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*QL7Bt76x55vVUHzY31v8AA.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">SVM的优化问题<a class="ae la" href="http://web.mit.edu/6.034/wwwbob/svm-notes-long-08.pdf" rel="noopener ugc nofollow" target="_blank">参考</a></figcaption></figure><p id="4608" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们以一个非常常见的内核为例:</p><h1 id="f98b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">多项式核:</strong></h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lc"><img src="../Images/72ed7536c84dd3743aa8931c9fd6ab6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:706/format:webp/0*5bJ27ejE_BG8_rRs.png"/></div></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">二阶多项式核</figcaption></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ld"><img src="../Images/16d226813b4090eb6b3849ca77ba0824.png" data-original-src="https://miro.medium.com/v2/resize:fit:368/format:webp/0*lvLGzusk1n1-nrVt.png"/></div></figure><p id="32a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以这个内核所做的就是在两个d维向量之间取点积，然后求平方。这将花费<strong class="ig hi"> O(d)时间</strong>。</p><p id="c4ff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">更具体地说，让我们以<strong class="ig hi"> d=2为例。</strong></p><p id="f1dc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">K(X，Z)是多少？</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es le"><img src="../Images/7a2f9bd504b4301a86ffdca98474e236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yGNhzhjc4B-gNEcN.png"/></div></div></figure><p id="645e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">膨胀，</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="er es lf"><img src="../Images/7ebc3dd90e3b04845851d79ba36409d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d2n6NMow7C-csjQk.png"/></div></div></figure><p id="5cf9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果我们有一个如下的特征地图</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lg"><img src="../Images/491ea33fdf723b2b4ae3b2e991bee004.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/0*bav2511591sanO-q.png"/></div></figure><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lh"><img src="../Images/96ede99abf57c8221c47f950c0ad9a21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*NYv972ocm28KHxOW.png"/></div></figure><p id="6f1b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由此我们可以清楚地看到，上面两者的点积与核函数的输出是一样的</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es li"><img src="../Images/acc3c704480b9998a2637e1758fa3d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/0*jda1KbMvuydumQY9.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">我们的特征图的点积等于我们的内核</figcaption></figure><p id="5756" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们在没有内核的情况下计算Phi(X)和Phi(Z ),我们将不得不花费O(d)来进行变换&amp;随后的点积。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lj"><img src="../Images/497c3c280fd99e8038fd99ceea545a12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*ezCVixCbep_-ItXVT522vw.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">用我们的多项式核(3D近似)转换我们的原始圆数据</figcaption></figure><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="8f3c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在没有“核心技巧”的情况下，具有10个训练样本的1000维矩阵的输出时间大约为5.5秒</p><figure class="kg kh ki kj fd kk"><div class="bz dy l di"><div class="kw kx l"/></div></figure><p id="b9ae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于相同大小的矩阵，内核特技时间大约为0.05秒。</p><p id="125b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">主要提示:每当我们有单个输入属性向量的点积时，我们可以使用核来提高计算效率。T3】</p><h1 id="005d" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated"><strong class="ak">克矩阵:</strong></h1><p id="6833" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">实际上，如果我们有N个训练样本，我们形成一个<strong class="ig hi"> Gram矩阵(具有为一对样本计算的核值的矩阵)</strong>如下:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ll"><img src="../Images/172960bd7e9de67c02535222a839829b.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/0*z04fwbn9V5Y93_SQ.png"/></div><figcaption class="kn ko et er es kp kq bd b be z dx translated">训练样本</figcaption></figure><p id="a7f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">矩阵的第I行和第j列如下:</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lm"><img src="../Images/06dc6da459545fe2561026bd14881555.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/0*qQEGPLo7tuLS35VA.png"/></div></figure><p id="d398" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">有效内核的条件:</strong></p><p id="7bbd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为了使核有效，构造的矩阵必须是对称的(这应该是相当明显的，因为K[j，i] = K[i，j]，因为点积保持不变)。此外，它们必须是半正定的(特征值是非负的)。我们可以用“能量测试”来证明这一点，对于任何向量x，</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ln"><img src="../Images/351e0d35946bc7cfde85eadf9db33d9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:428/format:webp/0*ocC7jthLyHwB6xr0.png"/></div></figure></div></div>    
</body>
</html>