<html>
<head>
<title>How to return the response from an asynchronous call?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何从异步调用返回响应？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-return-the-response-from-an-asynchronous-call-2ef494308423?source=collection_archive---------0-----------------------#2021-04-25">https://medium.com/analytics-vidhya/how-to-return-the-response-from-an-asynchronous-call-2ef494308423?source=collection_archive---------0-----------------------#2021-04-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/78c1faca539d508b1ed9eddef4a0ee5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*phOb94Phj2vR331d.jpg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://www.teachhub.com/professional-development/2020/11/benefits-of-synchronous-vs-asynchronous-online-instruction/" rel="noopener ugc nofollow" target="_blank">https://www . teachhub . com/professional-development/2020/11/benefits-of-synchronous-vs-asynchronous-online-instruction/</a></figcaption></figure><p id="f2be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><a class="ae iu" href="https://en.wikipedia.org/wiki/Ajax_(programming)" rel="noopener ugc nofollow" target="_blank"> Ajax </a>中的<strong class="ix hj"> A </strong>代表<a class="ae iu" href="https://www.merriam-webster.com/dictionary/asynchronous" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj">异步</strong> </a>。这意味着发送请求(或者更确切地说是接收响应)被从正常的执行流程中去掉了。在您的示例中，<code class="du jt ju jv jw b">$.ajax</code>立即返回，下一条语句<code class="du jt ju jv jw b">return result;</code>在您作为<code class="du jt ju jv jw b">success</code>回调传递的函数被调用之前就被执行了。</p><p id="4f0c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里有一个类比，它有望使同步流和异步流之间的区别更加清晰:</p><h1 id="a8df" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">同步的</h1><p id="379d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">想象一下，你打电话给一个朋友，请他为你查找一些东西。虽然这可能需要一段时间，但你在电话旁等待，凝视着天空，直到你的朋友给你想要的答案。</p><p id="2f82" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当您进行包含“正常”代码的函数调用时，也会发生同样的情况:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="586e" class="li jy hi jw b fi lj lk l ll lm">function findItem() {<br/>    var item;<br/>    while(item_not_found) {<br/>        // search<br/>    }<br/>    return item;<br/>}</span><span id="6052" class="li jy hi jw b fi ln lk l ll lm">var item = findItem();</span><span id="6f32" class="li jy hi jw b fi ln lk l ll lm">// Do something with item<br/>doSomethingElse();</span></pre><p id="c7f6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">即使<code class="du jt ju jv jw b">findItem</code>可能需要很长时间来执行，任何在<code class="du jt ju jv jw b">var item = findItem();</code>之后的代码都必须等待<em class="lo">直到函数返回结果。</em></p><h1 id="1683" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">异步的</h1><p id="1825" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">你又因为同样的原因打电话给你的朋友。但是这次你告诉他你有急事，他应该用你的手机给你回电话。你挂断电话，离开家，做你计划要做的任何事情。一旦你的朋友给你回电话，你正在处理他给你的信息。</p><p id="81cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这正是当您执行Ajax请求时所发生的情况。</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="cb54" class="li jy hi jw b fi lj lk l ll lm">findItem(function(item) {<br/>    // Do something with the item<br/>});<br/>doSomethingElse();</span></pre><p id="5ddd" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">不再等待响应，而是立即继续执行，并执行Ajax调用后的语句。为了最终得到响应，您提供了一个一旦收到响应就调用的函数，一个<em class="lo">回调</em>(注意到什么了吗？<em class="lo">回电</em>？).该调用之后的任何语句都在回调被调用之前执行。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="1208" class="jx jy hi bd jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku bi translated">解决方案</h1><h2 id="a933" class="li jy hi bd jz mb mc md kd me mf mg kh jg mh mi kl jk mj mk kp jo ml mm kt mn bi translated">如果您没有在代码中使用jQuery，这个答案适合您</h2><p id="614c" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">您的代码应该是这样的:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="c82f" class="li jy hi jw b fi lj lk l ll lm">function foo() {<br/>    var httpRequest = new XMLHttpRequest();<br/>    httpRequest.open('GET', "/echo/json");<br/>    httpRequest.send();<br/>    return httpRequest.responseText;<br/>}</span><span id="8069" class="li jy hi jw b fi ln lk l ll lm">var result = foo(); // Always ends up being 'undefined'</span></pre><p id="544d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">拥抱JavaScript的异步本质！虽然某些异步操作提供了同步副本(Ajax也是)，但通常不鼓励使用它们，尤其是在浏览器环境中。</p><p id="13e7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你问为什么不好？</p><p id="eabc" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">JavaScript在浏览器的UI线程中运行，任何长时间运行的进程都会锁定UI，使其无响应。此外，JavaScript的执行时间有上限，浏览器会询问用户是否继续执行。</p><p id="2c1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">所有这些都是非常糟糕的用户体验。用户将无法判断一切是否正常。此外，对于连接速度较慢的用户，效果会更差。</p><p id="051e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下文中，我们将看看三种不同的解决方案，它们都是建立在彼此之上的:</p><ul class=""><li id="14bf" class="mo mp hi ix b iy iz jc jd jg mq jk mr jo ms js mt mu mv mw bi translated"><strong class="ix hj">承诺与</strong> <code class="du jt ju jv jw b"><strong class="ix hj">async/await</strong></code> (ES2017+，如果使用transpiler或regenerator，则在较旧的浏览器中可用)</li><li id="37e7" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><strong class="ix hj">回调</strong>(流行于节点)</li><li id="54e5" class="mo mp hi ix b iy mx jc my jg mz jk na jo nb js mt mu mv mw bi translated"><strong class="ix hj">Promises with</strong><code class="du jt ju jv jw b"><strong class="ix hj">then()</strong></code>(es 2015+，如果你使用众多promise库中的一个，可以在旧浏览器中使用)</li></ul><p id="fd85" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">目前的浏览器都有这三个，还有node 7+。</strong></p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="6e8c" class="jx jy hi bd jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku bi translated">ES2017+:与<code class="du jt ju jv jw b"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">async/await</a></code>的承诺</h1><p id="b97a" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">2017年发布的ECMAScript版本引入了对异步函数的<em class="lo">语法级支持</em>。在<code class="du jt ju jv jw b">async</code>和<code class="du jt ju jv jw b">await</code>的帮助下，你可以用“同步风格”写异步。代码仍然是异步的，但是更容易阅读/理解。</p><p id="b58e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">async/await</code>建立在承诺之上:一个<code class="du jt ju jv jw b">async</code>函数总是返回一个承诺。<code class="du jt ju jv jw b">await</code>“解包”一个承诺，如果该承诺被拒绝，则产生解决该承诺的值或抛出一个错误。</p><p id="8535" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">重要提示:</strong>你只能在<code class="du jt ju jv jw b">async</code>函数中使用<code class="du jt ju jv jw b">await</code>。现在，顶级的<code class="du jt ju jv jw b">await</code>还不被支持，所以你可能不得不创建一个async life(<a class="ae iu" href="https://en.wikipedia.org/wiki/Immediately_invoked_function_expression" rel="noopener ugc nofollow" target="_blank">立即调用函数表达式</a>)来启动一个<code class="du jt ju jv jw b">async</code>上下文。</p><p id="cfaa" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在MDN上阅读更多关于<code class="du jt ju jv jw b"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank">async</a></code>和<code class="du jt ju jv jw b"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank">await</a></code>的内容。</p><p id="12b5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个建立在上述延迟之上的示例:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="e5c8" class="li jy hi jw b fi lj lk l ll lm">// Using 'superagent' which will return a promise.<br/>var superagent = require('superagent')</span><span id="0f85" class="li jy hi jw b fi ln lk l ll lm">// This is isn't declared as `async` because it already returns a promise<br/>function delay() {<br/>  // `delay` returns a promise<br/>  return new Promise(function(resolve, reject) {<br/>    // Only `delay` is able to resolve or reject the promise<br/>    setTimeout(function() {<br/>      resolve(42); // After 3 seconds, resolve the promise with value 42<br/>    }, 3000);<br/>  });<br/>}<br/></span><span id="01a8" class="li jy hi jw b fi ln lk l ll lm">async function getAllBooks() {<br/>  try {<br/>    // GET a list of book IDs of the current user<br/>    var bookIDs = await superagent.get('/user/books');<br/>    // wait for 3 seconds (just for the sake of this example)<br/>    await delay();<br/>    // GET information about each book<br/>    return await superagent.get('/books/ids='+JSON.stringify(bookIDs));<br/>  } catch(error) {<br/>    // If any of the awaited promises was rejected, this catch block<br/>    // would catch the rejection reason<br/>    return null;<br/>  }<br/>}</span><span id="c4fa" class="li jy hi jw b fi ln lk l ll lm">// Start an IIFE to use `await` at the top level<br/>(async function(){<br/>  let books = await getAllBooks();<br/>  console.log(books);<br/>})();</span></pre><p id="414b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当前<a class="ae iu" href="https://kangax.github.io/compat-table/es2016plus/#test-async_functions" rel="noopener ugc nofollow" target="_blank">浏览器</a>和<a class="ae iu" href="http://node.green/#ES2017-features-async-functions" rel="noopener ugc nofollow" target="_blank">节点</a>版本支持<code class="du jt ju jv jw b">async/await</code>。你也可以在<a class="ae iu" href="https://github.com/facebook/regenerator" rel="noopener ugc nofollow" target="_blank">再生器</a>(或者使用再生器的工具，比如<a class="ae iu" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>)的帮助下，通过将你的代码转换成ES5来支持旧的环境。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="dbf9" class="jx jy hi bd jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku bi translated">让函数接受回调</h1><p id="5c22" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">回调是将函数1传递给函数2。函数2可以随时调用函数1。在异步流程的上下文中，每当异步流程完成时，都会调用回调。通常，结果被传递给回调。</p><p id="368a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在问题的例子中，您可以让<code class="du jt ju jv jw b">foo</code>接受一个回调，并将其用作<code class="du jt ju jv jw b">success</code>回调。所以这个</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="5ac6" class="li jy hi jw b fi lj lk l ll lm">var result = foo();<br/>// Code that depends on 'result'</span></pre><p id="a4de" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">成为</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="6c34" class="li jy hi jw b fi lj lk l ll lm">foo(function(result) {<br/>    // Code that depends on 'result'<br/>});</span></pre><p id="0e42" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们定义了“内联”函数，但是您可以传递任何函数引用:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="d27d" class="li jy hi jw b fi lj lk l ll lm">function myCallback(result) {<br/>    // Code that depends on 'result'<br/>}</span><span id="45a8" class="li jy hi jw b fi ln lk l ll lm">foo(myCallback);</span></pre><p id="26af" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">foo</code>本身定义如下:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="f53d" class="li jy hi jw b fi lj lk l ll lm">function foo(callback) {<br/>    $.ajax({<br/>        // ...<br/>        success: callback<br/>    });<br/>}</span></pre><p id="acb3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du jt ju jv jw b">callback</code>将引用我们传递给<code class="du jt ju jv jw b">foo</code>的函数，当我们调用它时，我们将它传递给<code class="du jt ju jv jw b">success</code>。也就是说，一旦Ajax请求成功，<code class="du jt ju jv jw b">$.ajax</code>将调用<code class="du jt ju jv jw b">callback</code>并将响应传递给回调(可以用<code class="du jt ju jv jw b">result</code>引用，因为这是我们定义回调的方式)。</p><p id="f275" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您也可以在将响应传递给回调之前对其进行处理:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="d365" class="li jy hi jw b fi lj lk l ll lm">function foo(callback) {<br/>    $.ajax({<br/>        // ...<br/>        success: function(response) {<br/>            // For example, filter the response<br/>            callback(filtered_response);<br/>        }<br/>    });<br/>}</span></pre><p id="b62b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用回调编写代码比看起来容易。毕竟，浏览器中的JavaScript是高度事件驱动的(DOM事件)。接收Ajax响应只不过是一个事件。当您必须使用第三方代码时，可能会出现困难，但是大多数问题都可以通过考虑应用程序流程来解决。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="8758" class="jx jy hi bd jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku bi translated">ES2015+:承诺与<a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> then() </a></h1><p id="2bd8" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated"><a class="ae iu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise API </a>是ECMAScript 6 (ES2015)的新特性，但它已经有很好的<a class="ae iu" href="http://caniuse.com/#feat=promises" rel="noopener ugc nofollow" target="_blank">浏览器支持</a>。还有许多库实现了标准的Promises API，并提供了额外的方法来简化异步函数的使用和组合(例如<a class="ae iu" href="https://github.com/petkaantonov/bluebird" rel="noopener ugc nofollow" target="_blank"> bluebird </a>)。</p><p id="4453" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">承诺是未来价值的容器。当promise收到值时(它是<em class="lo">解决的</em>)或者当它被取消时(<em class="lo">拒绝的</em>),它通知所有想要访问这个值的“监听器”。</p><p id="4135" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">与普通回调相比，它的优势在于允许你将代码解耦，并且更容易编写。</p><p id="8a12" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">下面是一个使用承诺的例子:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="ca6a" class="li jy hi jw b fi lj lk l ll lm">function delay() {<br/>  // `delay` returns a promise<br/>  return new Promise(function(resolve, reject) {<br/>    // Only `delay` is able to resolve or reject the promise<br/>    setTimeout(function() {<br/>      resolve(42); // After 3 seconds, resolve the promise with value 42<br/>    }, 3000);<br/>  });<br/>}</span><span id="2939" class="li jy hi jw b fi ln lk l ll lm">delay()<br/>  .then(function(v) { // `delay` returns a promise<br/>    console.log(v); // Log the value once it is resolved<br/>  })<br/>  .catch(function(v) {<br/>    // Or do something else if it is rejected<br/>    // (it would not happen in this example, since `reject` is not called).<br/>  });</span></pre><p id="7cf6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">应用到我们的Ajax调用中，我们可以使用这样的承诺:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="0379" class="li jy hi jw b fi lj lk l ll lm">function ajax(url) {<br/>  return new Promise(function(resolve, reject) {<br/>    var xhr = new XMLHttpRequest();<br/>    xhr.onload = function() {<br/>      resolve(this.responseText);<br/>    };<br/>    xhr.onerror = reject;<br/>    xhr.open('GET', url);<br/>    xhr.send();<br/>  });<br/>}</span><span id="6690" class="li jy hi jw b fi ln lk l ll lm">ajax("/echo/json")<br/>  .then(function(result) {<br/>    // Code depending on result<br/>  })<br/>  .catch(function() {<br/>    // An error occurred<br/>  });</span></pre><p id="d213" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">描述promise提供的所有优点超出了本答案的范围，但是如果您编写新代码，您应该认真考虑它们。它们为您的代码提供了很好的抽象和分离。</p><p id="ba5f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">关于承诺的更多信息:<a class="ae iu" href="http://www.html5rocks.com/en/tutorials/es6/promises/" rel="noopener ugc nofollow" target="_blank"> HTML5摇滚——JavaScript承诺</a></p><h1 id="671d" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">附注:jQuery的延迟对象</h1><p id="842c" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated"><a class="ae iu" href="https://stackoverflow.com/questions/4866721/what-are-deferred-objects" rel="noopener ugc nofollow" target="_blank">延迟对象</a>是jQuery对promises的自定义实现(Promise API标准化之前)。它们的行为几乎像是承诺，但公开的API略有不同。</p><p id="4ff6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">jQuery的每个Ajax方法都已经返回了一个“延迟对象”(实际上是一个延迟对象的承诺)，您可以从函数中返回它:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="6ce0" class="li jy hi jw b fi lj lk l ll lm">function ajax() {<br/>    return $.ajax(...);<br/>}</span><span id="8d1b" class="li jy hi jw b fi ln lk l ll lm">ajax().done(function(result) {<br/>    // Code depending on result<br/>}).fail(function() {<br/>    // An error occurred<br/>});</span></pre><h1 id="14ff" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">旁注:承诺抓住了你</h1><p id="3a7d" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">请记住，承诺和延期对象只是未来价值的容器，它们不是价值本身。例如，假设您有以下内容:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="c8b8" class="li jy hi jw b fi lj lk l ll lm">function checkPassword() {<br/>    return $.ajax({<br/>        url: '/password',<br/>        data: {<br/>            username: $('#username').val(),<br/>            password: $('#password').val()<br/>        },<br/>        type: 'POST',<br/>        dataType: 'json'<br/>    });<br/>}</span><span id="d4eb" class="li jy hi jw b fi ln lk l ll lm">if (checkPassword()) {<br/>    // Tell the user they're logged in<br/>}</span></pre><p id="571b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这段代码误解了上述异步问题。具体来说，<code class="du jt ju jv jw b">$.ajax()</code>在检查服务器上的“/password”页面时不会冻结代码——它向服务器发送一个请求，并在等待时立即返回一个jQuery Ajax延迟对象，而不是来自服务器的响应。这意味着<code class="du jt ju jv jw b">if</code>语句将总是获取这个延迟的对象，将其视为<code class="du jt ju jv jw b">true</code>，并像用户登录一样继续。不太好。</p><p id="b0a8" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">但是解决方法很简单:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="db4f" class="li jy hi jw b fi lj lk l ll lm">checkPassword()<br/>.done(function(r) {<br/>    if (r) {<br/>        // Tell the user they're logged in<br/>    } else {<br/>        // Tell the user their password was bad<br/>    }<br/>})<br/>.fail(function(x) {<br/>    // Tell the user something bad happened<br/>});</span></pre></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><h1 id="2643" class="jx jy hi bd jz ka lw kc kd ke lx kg kh ki ly kk kl km lz ko kp kq ma ks kt ku bi translated">不推荐:同步“Ajax”调用</h1><p id="4c76" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">正如我提到的，有些(！)异步操作有同步操作。我不提倡使用它们，但是为了完整起见，下面是您应该如何执行同步调用:</p><h1 id="9730" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">不使用jQuery</h1><p id="1df6" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">如果你直接使用一个<code class="du jt ju jv jw b"><a class="ae iu" href="https://xhr.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">XMLHttpRequest</a></code>对象，将<code class="du jt ju jv jw b">false</code>作为第三个参数传递给<code class="du jt ju jv jw b"><a class="ae iu" href="https://xhr.spec.whatwg.org/#the-open()-method" rel="noopener ugc nofollow" target="_blank">.open</a></code>。</p><h1 id="5e0a" class="jx jy hi bd jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku bi translated">jQuery</h1><p id="9abd" class="pw-post-body-paragraph iv iw hi ix b iy kv ja jb jc kw je jf jg kx ji jj jk ky jm jn jo kz jq jr js hb bi translated">如果使用<a class="ae iu" href="http://api.jquery.com/jQuery.ajax/" rel="noopener ugc nofollow" target="_blank"> jQuery </a>，可以将<code class="du jt ju jv jw b">async</code>选项设置为<code class="du jt ju jv jw b">false</code>。请注意，从jQuery 1.8开始，此选项<em class="lo">已被弃用</em>。然后，您可以继续使用<code class="du jt ju jv jw b">success</code>回调或者访问<a class="ae iu" href="http://api.jquery.com/jQuery.ajax/#jqXHR" rel="noopener ugc nofollow" target="_blank"> jqXHR对象</a>的<code class="du jt ju jv jw b">responseText</code>属性:</p><pre class="la lb lc ld fd le jw lf lg aw lh bi"><span id="7e9d" class="li jy hi jw b fi lj lk l ll lm">function foo() {<br/>    var jqXHR = $.ajax({<br/>        //...<br/>        async: false<br/>    });<br/>    return jqXHR.responseText;<br/>}</span></pre><p id="4a94" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果使用任何其他jQuery Ajax方法，比如<code class="du jt ju jv jw b">$.get</code>、<code class="du jt ju jv jw b">$.getJSON</code>等。，您必须将其更改为<code class="du jt ju jv jw b">$.ajax</code>(因为您只能将配置参数传递给<code class="du jt ju jv jw b">$.ajax</code>)。</p></div><div class="ab cl lp lq gp lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="hb hc hd he hf"><p id="9d52" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">抬头！</strong>不可能发出同步<a class="ae iu" href="https://stackoverflow.com/questions/2067472/please-explain-jsonp" rel="noopener ugc nofollow" target="_blank"> JSONP </a>请求。JSONP本质上总是异步的(这是不考虑这个选项的又一个原因)。</p></div></div>    
</body>
</html>