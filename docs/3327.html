<html>
<head>
<title>Variable Importance with Tree Models &amp; Random Forest — With Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">树模型和随机森林的可变重要性—使用Python</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/variable-importance-with-tree-models-random-forest-with-python-cb775d019977?source=collection_archive---------2-----------------------#2021-06-25">https://medium.com/analytics-vidhya/variable-importance-with-tree-models-random-forest-with-python-cb775d019977?source=collection_archive---------2-----------------------#2021-06-25</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="873b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树模型及其强大的衍生工具集成学习是数据解释和预测任务的强大技术。</p><p id="175d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi jc translated"><span class="l jd je jf bm jg jh ji jj jk di">在</span>统计机器学习中，模型是数据驱动的。我们所说的数据驱动主要是指在适应数据之前没有预先定义的数据模型或结构。这与经典的统计方法形成对比，在经典的统计方法中，假设一些模型和结构，并通过导出所需的参数来拟合数据。例如，在线性或逻辑回归中，假设基础数据分别遵循正态和伯努利分布。然而，在树模型或K-NN算法中，模型仅基于数据导出，而没有导出特定于模型的参数。因此，树有能力发现与数据中复杂交互相对应的隐藏模式。在本文中，我们旨在简要介绍用于数据解释和预测的树模型和集成学习。</p><p id="cc11" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树模型有两个吸引人的方面[1]:</p><ul class=""><li id="9998" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">树模型为探索数据提供了一个可视化工具，可以了解哪些变量是重要的，以及它们之间的关系。树可以捕捉预测变量之间的非线性关系。</li><li id="a69d" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">树模型提供了一组规则，可以有效地传达给非专家，用于实现或“销售”数据挖掘项目。</li></ul><h1 id="46b3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">树形模型</h1><p id="6504" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">树模型是描述数据的“if-then-else”规则的集合。树模型，也称为<em class="lc">分类和回归树</em> ( <em class="lc"> CART </em>)、3 <em class="lc">决策树</em>，或简称为<em class="lc">树</em>，是Leo Breiman等人在1984年首次开发的一种有效且流行的分类(和回归)方法[1]。由于其简单和易于理解的性质，树模型是与不一定熟悉分析的人交流的有效数据探索技术之一。为了练习树模型，我们将引导您使用Python对数据集应用树模型。我们将使用<a class="ae ld" href="https://www.kaggle.com/azeembootwala/titanic" rel="noopener ugc nofollow" target="_blank">泰坦尼克号数据集</a>将乘客分类为死亡或幸存。我们的目标是将<em class="lc"> Sci-kit Learn </em>用作python库<em class="lc">。此外，还增加了4栏，从姓名栏重新设计为标题<em class="lc"> 1到标题</em> 4，表示男性&amp;女性，取决于他们是否结婚(先生、夫人、主人、小姐)。一项额外的分析旨在看看已婚人士或换句话说有社会责任感的人是否有更多的生存本能&amp;这一趋势对男女来说是相似的。该数据集由15个预测因子组成，如性别、票价、p_class、家庭规模、…。</em>目标响应是<em class="lc">幸存。</em>请注意，取值有限的因子变量已经通过一键编码进行了转换。这篇文章的完整代码可以在这里找到。</p><p id="e083" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树模型的优势之一是它对预测值缩放不敏感，而预测值缩放是在更复杂的算法(如神经网络和逻辑回归)中要考虑的关键点。因此，在树模型中可以安全地跳过数据争论。</p><p id="44ce" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">开始之前，请注意，我们将使用<code class="du le lf lg lh b">dmba</code>库来可视化树模型决策。您可以通过<code class="du le lf lg lh b">pip3</code>命令安装软件包:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="f1ba" class="lq ka hh lh b fi lr ls l lt lu">#in jupyter notebook <br/>!pip3 install dmba</span><span id="9345" class="lq ka hh lh b fi lv ls l lt lu">#on terminal CLI<br/>pip3 install dmba</span></pre><h1 id="09b2" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">仅使用两个预测器</h1><p id="295c" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">出于可视化的目的，我们旨在仅使用两个预测器<code class="du le lf lg lh b">Age</code>和<code class="du le lf lg lh b">Fare</code>来预测幸存的乘客。我们从加载数据开始。数据看起来像:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="8d24" class="lq ka hh lh b fi lr ls l lt lu">train_df = pd.read_csv('train_data.csv')<br/>train_df.head(10)</span></pre><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es lw"><img src="../Images/f54bec0d381f4c398ed995b3b87c2dd8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZE4Lkl_LVIhRdBbe2qiwTA.png"/></div></div></figure><p id="789c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们删除了前两列，因为它们不包含任何有助于预测结果的信息<code class="du le lf lg lh b">Survived</code>。</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="0bb8" class="lq ka hh lh b fi lr ls l lt lu">train_df = train_df.drop(columns=['Unnamed: 0', 'PassengerId'])</span></pre><p id="a034" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">仅使用两个预测器<code class="du le lf lg lh b">Age</code>和<code class="du le lf lg lh b">Fare</code>，获得的树如下:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="4e05" class="lq ka hh lh b fi lr ls l lt lu">predictors = ['Age', 'Fare']<br/>outcome = 'Survived'</span><span id="674f" class="lq ka hh lh b fi lv ls l lt lu">X = train_df[predictors]<br/>y = train_df[outcome]</span><span id="4e67" class="lq ka hh lh b fi lv ls l lt lu">titanic_tree = DecisionTreeClassifier(random_state=1, criterion='entropy', min_impurity_decrease=0.003)</span><span id="77e3" class="lq ka hh lh b fi lv ls l lt lu">titanic_tree.fit(X, y)</span><span id="0956" class="lq ka hh lh b fi lv ls l lt lu">plotDecisionTree(titanic_tree, feature_names=predictors, class_names=titanic_tree.classes_)</span></pre><p id="c45a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树模型的规则可以看作是:</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es me"><img src="../Images/7685dd433ecbd4290fb3f26a9e9e30ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BpZP7-okh6D6XJAXFp1Log.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated"><em class="mj">一个简单的树模型的规则适合巨大的数据</em></figcaption></figure><p id="090a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看到，树是倒着画的，所以根在上面，叶子在下面。我们将<code class="du le lf lg lh b">min_impurity_decrease</code>设置为0.003。换句话说，如果这种分裂导致杂质减少大于或等于0.003，则阳极将被分裂。根树从查看一个预测阈值<code class="du le lf lg lh b">Fare &lt;= 0.02</code>开始，并尝试基于多数原则对结果进行分类。我们也可以通过<code class="du le lf lg lh b">dmba</code>库获得树的文本表示。代码如下:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="41ab" class="lq ka hh lh b fi lr ls l lt lu">print(textDecisionTree(titanic_tree))</span></pre><p id="0a2c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出将如下所示:</p><figure class="li lj lk ll fd lx er es paragraph-image"><div role="button" tabindex="0" class="ly lz di ma bf mb"><div class="er es mk"><img src="../Images/bdd935519cca08105d9550043a8a85a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TRW5kjqc0xTV3TeuqQGMXw.png"/></div></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">树模型的文本表示</figcaption></figure><p id="cb54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">树算法基于<a class="ae ld" href="https://en.wikipedia.org/wiki/Recursive_partitioning" rel="noopener ugc nofollow" target="_blank">递归分割</a>算法工作。它首先将数据空间划分为不重叠的区域，每个区域表示给定预测值的独特值集。然后选择区域，给我们相似结果的集合。换句话说，杂质最少的区域。</p><blockquote class="ml mm mn"><p id="498d" class="ie if lc ig b ih ii ij ik il im in io mo iq ir is mp iu iv iw mq iy iz ja jb ha bi translated">根据<em class="hh"> Gini杂质</em>或<em class="hh">熵信息来测量杂质。</em>基尼系数不可与<em class="hh">基尼系数</em>相混淆。它们代表相似的概念，但基尼系数仅限于二元分类问题，并与曲线下面积(AUC)指标相关[2]。</p></blockquote><h1 id="4a94" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">集成学习</h1><p id="ad0b" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">然而，就预测而言，利用多棵树的结果通常比只使用一棵树更有效。特别是，随机森林和提升树算法几乎总能提供卓越的预测准确性和性能。集合模型主要有两种变体:<em class="lc">装袋</em>和<em class="lc">助推</em>。在集合树模型的情况下，这些被称为<em class="lc">随机森林</em>模型和<em class="lc">增强树</em>模型【1】。</p><h2 id="2bdd" class="lq ka hh bd kb mr ms mt kf mu mv mw kj ip mx my kn it mz na kr ix nb nc kv nd bi translated">随机森林</h2><p id="d15a" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated"><em class="lc">随机森林</em>基于对决策树应用bagging，有一个重要的扩展:除了对记录进行采样，算法还对变量进行采样。Bagging类似于集成的基本算法，除了不是将各种模型拟合到相同的数据，而是将每个新模型拟合到bootstrap重采样。</p><p id="4cf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">随机森林的复杂性在于选择所用模型的数量。我们可以通过穷尽搜索不同数量的树来确定这一点，并选择给出最低误差的一个。由于在随机森林中，只有数据子集用于训练，剩下的数据可以用于错误验证。Python通过<em class="lc"> Scikit-learn </em>提供了一个工具来导出模型验证的out-of-bag (oob)错误。<em class="lc">出袋</em> ( <em class="lc"> OOB </em>)误差估计值是训练模型的误差率，应用于该树的训练集之外的数据。我们可以使用oob在森林树中选择合适数量的树模型。</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="3d03" class="lq ka hh lh b fi lr ls l lt lu">n_estimator = list(range(20, 510, 5))<br/>oobScores = []</span><span id="5c02" class="lq ka hh lh b fi lv ls l lt lu">for n in n_estimator:</span><span id="f76c" class="lq ka hh lh b fi lv ls l lt lu">rf = RandomForestClassifier(n_estimators=n, criterion='entropy',       max_depth=10, random_state=1, oob_score=True)<br/>rf.fit(X, y)<br/>oobScores.append(rf.oob_score_)</span><span id="474d" class="lq ka hh lh b fi lv ls l lt lu">df = pd.DataFrame({ 'n': n_estimator, 'oobScore': oobScores })<br/>df.plot(x='n', y='oobScore')</span></pre><p id="b433" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出将是:</p><figure class="li lj lk ll fd lx er es paragraph-image"><div class="er es ne"><img src="../Images/f779fa09981d69fe459dcc28839e1091.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*yaNZ4tZLlki-06YZ63_HHw.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">OOb作为估计量数量的函数</figcaption></figure><p id="d955" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看出，最大深度为10时，树的最佳数量大约为140。</p><h1 id="7fc3" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">可变重要性</h1><p id="f235" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">树模型可用于确定哪些预测因素在预测结果中起着关键作用。衡量变量重要性有两种方法[1]:</p><ul class=""><li id="bfaf" class="jl jm hh ig b ih ii il im ip jn it jo ix jp jb jq jr js jt bi translated">如果变量的值被随机置换(类型=1)，则模型的精度降低。随机改变数值会消除该变量的所有预测能力。准确性是根据袋外数据计算的(因此这种方法实际上是一种交叉验证的估计)。</li><li id="c2b0" class="jl jm hh ig b ih ju il jv ip jw it jx ix jy jb jq jr js jt bi translated">通过在一个变量(类型=2)上分割的所有节点的基尼不纯分数的平均减少。这衡量了包含该变量对节点纯度的改善程度。这种方法是基于训练集的，因此不如根据袋外数据计算的方法可靠。</li></ul><p id="0d4e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">变量importance的python实现如下:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="9e20" class="lq ka hh lh b fi lr ls l lt lu">predictors = ['Sex', 'Age', 'Fare', 'Pclass_1','Pclass_2', 'Pclass_3', 'Family_size', 'Title_1', 'Title_2', 'Title_3', 'Title_4', 'Emb_1', 'Emb_2', 'Emb_3']</span><span id="6cae" class="lq ka hh lh b fi lv ls l lt lu">outcome = 'Survived'</span><span id="7a4b" class="lq ka hh lh b fi lv ls l lt lu">X = train_df[predictors]<br/>y = train_df[outcome]</span><span id="8544" class="lq ka hh lh b fi lv ls l lt lu">rf_all = RandomForestClassifier(n_estimators=140, random_state=1)<br/>rf_all.fit(X, y)</span><span id="04fb" class="lq ka hh lh b fi lv ls l lt lu">rf_all_entropy = RandomForestClassifier(n_estimators=500, random_state=1, criterion='entropy')</span><span id="dea9" class="lq ka hh lh b fi lv ls l lt lu">rf = RandomForestClassifier(n_estimators=140)</span><span id="39c6" class="lq ka hh lh b fi lv ls l lt lu">scores = defaultdict(list)</span><span id="ad3a" class="lq ka hh lh b fi lv ls l lt lu"># crossvalidate the scores on a number of different random splits of the data</span><span id="ac41" class="lq ka hh lh b fi lv ls l lt lu">for _ in range(5):<br/>train_X, valid_X, train_y, valid_y = train_test_split(X, y, test_size=0.3)<br/>rf.fit(train_X, train_y)<br/>acc = metrics.accuracy_score(valid_y, rf.predict(valid_X))</span><span id="e2ad" class="lq ka hh lh b fi lv ls l lt lu">for column in X.columns:<br/>X_t = valid_X.copy() <br/>X_t[column] = np.random.permutation(X_t[column].values)<br/>shuff_acc = metrics.accuracy_score(valid_y, rf.predict(X_t))<br/>scores[column].append(np.abs(acc-shuff_acc)/acc)</span><span id="50ed" class="lq ka hh lh b fi lv ls l lt lu">print('Features sorted by their score:')</span><span id="2e3e" class="lq ka hh lh b fi lv ls l lt lu">print(sorted([(round(np.mean(score), 4), feat) for feat, score in scores.items()], reverse=True))</span></pre><p id="01ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">输出将是:</p><pre class="li lj lk ll fd lm lh ln lo aw lp bi"><span id="3c52" class="lq ka hh lh b fi lr ls l lt lu">Features sorted by their score: [(0.1243, 'Sex'), (0.0462, 'Title_1'), (0.0356, 'Age'), (0.0224, 'Pclass_1'), (0.0197, 'Family_size'), (0.0149, 'Fare'), (0.0148, 'Emb_3'), (0.0138, 'Pclass_3'), (0.0137, 'Emb_1'), (0.0128, 'Pclass_2'), (0.0096, 'Title_4'), (0.0053, 'Emb_2'), (0.0011, 'Title_3'), (0.0, 'Title_2')]</span></pre><p id="a021" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以通过<code class="du le lf lg lh b">matplotlib</code>将变量重要性形象化为</p><figure class="li lj lk ll fd lx er es paragraph-image"><div class="er es nf"><img src="../Images/3085b55c188e57d4e68ead20d4eef394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*jYHyNAjPhSymdc4W1qWQKA.png"/></div><figcaption class="mf mg et er es mh mi bd b be z dx translated">准确性下降，基尼系数下降</figcaption></figure><p id="8d8c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可以看出，从准确性的角度来看，<code class="du le lf lg lh b">sex</code>具有最高的重要性，因为它提高了13%的准确性，而一些变量是中性的。此外，包括一些变量可能会降低准确性。从基尼系数的下降来看，情况有所不同。请记住，精确的测量更可靠。然而，在计算复杂性很重要的情况下，例如在需要拟合数千个模型的生产环境中，额外的计算工作可能不值得。此外，基尼系数下降揭示了随机森林使用哪些变量来制定其分裂规则(回想一下，这些信息在简单的树中很容易看到，但在随机森林中实际上是丢失的)[1]。</p><h1 id="faeb" class="jz ka hh bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">参考</h1><p id="7ce0" class="pw-post-body-paragraph ie if hh ig b ih kx ij ik il ky in io ip kz ir is it la iv iw ix lb iz ja jb ha bi translated">[1]布鲁斯、彼得、安德鲁·布鲁斯和彼得·格德克。<em class="lc">数据科学家实用统计学:使用R和Python的50多个基本概念</em>。奥莱利媒体，2020。</p></div></div>    
</body>
</html>