<html>
<head>
<title>Data Acquisition: Design for Failure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据采集:故障设计</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-acquisition-design-for-failure-903693b0b4cb?source=collection_archive---------22-----------------------#2021-08-16">https://medium.com/analytics-vidhya/data-acquisition-design-for-failure-903693b0b4cb?source=collection_archive---------22-----------------------#2021-08-16</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="a185" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated">我明白为什么说数据现在是世界上最有价值的资源…</h2></div><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es iw"><img src="../Images/ca51b23dc189d84f1849fe51a5ce2347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aTs6EtCWEFWwZALsN9gXFg.png"/></div></div><figcaption class="ji jj et er es jk jl bd b be z dx translated">来自spaghetti.py失败g代码自动化的示例代码片段</figcaption></figure><h1 id="777a" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">世界上最宝贵的资源</h1><p id="9bd2" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">这不是我第一次尝试为3D打印创建一个基于计算机视觉的监控系统。去年夏天，当我第一次开始深入研究机器学习时，我实际上试图做与个人项目基本相同的事情。作为这个领域的新手，我在前进的道路上遇到了许多问题，包括几乎被谷歌云收取了900美元，因为不知不觉地使用了他们的服务。当然，作为一个一文不名的大学生，900美元的账单很可怕，但这是我可以相对快速解决的问题，我很容易就找到了新的开源平台，可以作为更好的替代方案。我最大的问题实际上是找到一个好的数据源，因为还没有收集打印失败的图片。这让我通过各种谷歌图片搜索来寻找图片，甚至在subreddit <a class="ae la" href="https://www.reddit.com/r/FixMyPrint/" rel="noopener ugc nofollow" target="_blank"> r/FixMyPrint </a>中梳理失败的照片。最初几天的搜索只产生了大约300个例子，前景越来越糟糕。问题是，大多数人似乎不想给自己的失败拍照——谁会想到呢？有了这次经历，我明白了为什么说数据现在是世界上最有价值的资源。由于这一切，我需要设计一个更好的方法来收集高质量的数据。</p><h1 id="ed63" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">quinly——海量数据收集的完美工具</h1><p id="c39b" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">在我第一次尝试这个项目时，我还没有接触到配备了<a class="ae la" href="https://www.3dque.com/" rel="noopener ugc nofollow" target="_blank">quilly</a>自动化的3D打印机。使用配备了Quinly系统的打印机被证明对这个项目至关重要，因为它允许我连续打印并记录不同打印故障的时间间隔，而不会遇到任何版权问题。在一台普通的3D打印机上尝试自己收集数据会非常耗时和乏味，这就是为什么我第一次甚至没有想到要尝试这样做。</p><h1 id="bc55" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">机器学习需要大量数据</h1><p id="82c2" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">正如你可能猜到的那样，机器学习严重依赖于大量数据。一般来说，好的机器学习模型需要数百个(如果不是数千个的话)有代表性的图像用于每一类物体。对于我们的特定模型，我们可能需要更多，因为每个打印的模型看起来都不一样。在大多数情况下，同一类中的对象会有所不同，但没有3D打印那么多。我们希望建立一个健壮的通用对象检测模型，以便它能够可靠地识别故障，而不管人们选择打印什么。这就是为什么我们必须不断努力，用新的数据集来改进我们的模型，以推动模型向前发展。</p><h1 id="e7e7" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">对象检测模型的数据考虑</h1><p id="7ba7" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">猫可以有不同的大小或颜色，但一般来说，他们的主要特征使他们很容易辨认。3D打印可以有非常不同的外观，这使得制作这个模型的任务更加困难。为了获得各种各样的数据，我们试图用一系列不同的参数来改变我们所获得的图像数据。当然，我们已经改变了不同类型的故障模式。一些额外的考虑包括图像背景和照明条件，以及打印尺寸、形状、颜色和在打印故障上的位置。</p><h1 id="a392" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">自动化数据收集</h1><p id="c97d" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">由于3DQue已经实现了3D打印作业的自动化，我们认为也应该通过自动化来进一步优化我们的数据收集流程。为了做到这一点，我创建了多个不同的脚本，这些脚本会在g代码中创建特定的故障，将文件上传到Quinly，并为每个打印作业创建一个延时。关于这些脚本如何工作的进一步解释可以在下面看到。</p><h1 id="4e03" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">故障脚本设计</h1><p id="93b6" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">为了自动化3D打印失败的创建，我创建了五个Python脚本，这些脚本将接收输入g代码文件并对其进行修改，以便输出具有特定失败类型的g代码。每个脚本针对一种特定类型的故障，如下所示:spaghetti.py、layer_shift.py、extrusion.py、detach.py和clog.py。我还创建了一个名为gcode.py的Python模型来存储和导入一些有用的函数，我将在每个主故障脚本中使用这些函数。</p><p id="916a" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">每个脚本的一般结构有四个主要部分:定义一个参数解析器、多个文件路径循环、一个故障层定位器以及插入或更改g代码。所有部分一起工作，允许脚本一次输入多个g代码文件，并指定或随机选择失败参数，如插入失败代码的位置和输出g代码的失败大小。</p><p id="e6ce" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">参数解析器允许脚本用户在运行程序时在命令行中为特定的打印失败定义特定的参数。通常，所有脚本都有目标、移除、层、最小层、最大层和迭代标志。根据特定的故障类型，还有更多特定的标志。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="e92b" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">每个脚本中有三个主要循环，以便能够运行多个输入g代码文件，并多次迭代每个文件。这允许在一次执行中转换大量的g代码，并且单个g代码文件具有每种类型故障的多种变化。这是通过使用最外层循环中的迭代标志定义一个范围来多次遍历文件来实现的。接下来，它输入一个“with”语句，该语句循环遍历输入目录中的文件，以定义那里有哪些文件。最后，它进入每个已定义的文件，并且只为带有。gcode作为它们的扩展。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="9ca7" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">我创建了几个函数来定位一个随机或指定的层，以插入修改后的g代码。这些在gcode.py文件中定义，并导入到每个特定的失败脚本中，因为每个脚本中都需要它。两个主要函数是check_layer_count()和find_layer()。</p><p id="6e61" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">check_layer_count()逐行查看输入g代码文件内容，以找到最大层数，并通过与最大层数进行比较来捕获和修复用户定义的参数错误。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="1559" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">已知层数，find_layer()将在g代码内容中查找行号。稍后，该行号可用作起始点，以确定何时插入下面的g代码。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><p id="7374" class="pw-post-body-paragraph ke kf hh kg b kh lb ii kj kk lc il km kn ld kp kq kr le kt ku kv lf kx ky kz ha bi translated">每个特定脚本中的具体步骤可能会有所不同，但本质上，使用find_layer()获取的起始行作为“for”循环中范围的开始，可以找到特定的g代码行。然后使用“if-else”语句来查找关键信息或插入g代码行。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="c16c" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">自动上传GCODE脚本</h1><p id="1a6c" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">为了自动上传“失败g代码”组，我创建了一个Bash脚本，它能够从Google Drive上传g代码文件到Quinly，并在Quinly上排队打印。这是通过使用一个名为rclone的程序和Quinly的API来完成的。本质上，rclone允许您将云服务连接到Raspberry Pi，然后可以使用它在云服务之间上传和下载文件。在这个脚本中，我使用rclone将这组GCODE文件从Google Drive下载到Raspberry Pi。一旦文件存储在本地，我就可以将它们上传到Quinly，然后使用两个Quinly函数分两步将它们排队。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="64a3" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">自动延时脚本</h1><p id="fc6c" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">就数据收集而言，最重要的脚本是我编写的timelapse.sh Bash脚本。该脚本在Raspberry Pi的后台持续运行，并在重新启动时启动，因为它被设置为cron作业(cron是一个调度程序，可以根据您设置的运行时间在后台执行脚本)。为了拍摄每次打印的延时，该脚本监控打印机的不同状态，以执行某些命令来启动、停止和上传延时。它还会给每组图片和视频一个特定的名称，包括g代码文件的名称，打印机的IP地址和日期/时间，这样你就可以获得同一文件的时间间隔，而不会覆盖任何以前的时间间隔。</p><figure class="ix iy iz ja fd jb"><div class="bz dy l di"><div class="lg lh l"/></div></figure><h1 id="b2ff" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">当前数据收集</h1><p id="3f91" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">统一使用这些脚本可以让我们在更短的时间内获得更多的数据。在这一点上，数据收集不再是瓶颈；现在大概是数据标注。因为我们从每一个时间推移中获得了如此多的数据，我们需要在能够进行注释之前筛选和清理这些数据。</p><figure class="ix iy iz ja fd jb er es paragraph-image"><div role="button" tabindex="0" class="jc jd di je bf jf"><div class="er es li"><img src="../Images/f29d6958f06d2227f5c462d76c1f71ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DeTzSuOJdXUigm8-ewYaJg.png"/></div></div></figure><h1 id="1feb" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">然后</h1><p id="7352" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">要更多地谈论我们使用注释的经验，本系列的下一篇文章是“注释:教导机器”。尽管机器变得越来越智能，但人工数据注释仍然用于训练大多数对象检测模型。与图像分类不同，在图像分类中，通常只需要通过将图像放入命名的文件夹中或添加到图像本身的名称中来完成标记，而对象检测注释需要额外的步骤。对于对象检测，每个图像必须具有对象的边界框和标签，并且每个图像可以具有多个框和标签。这当然使得该过程更加复杂和耗时。我们目前正在处理这一部分，同时我们对已经标注的图像进行训练，但我们正在寻找更好的方法来加快这个过程。在本文中，我将定义注释的一些重要方面，展示我用来注释的软件，并探索我们将来可能会用到的注释方法。</p><h1 id="55ab" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">TL；博士:</h1><p id="feeb" class="pw-post-body-paragraph ke kf hh kg b kh ki ii kj kk kl il km kn ko kp kq kr ks kt ku kv kw kx ky kz ha bi translated">本文是一个五部分系列的第三部分，描述了我创建一个对象检测机器学习模型的旅程，该模型将用于<a class="ae la" href="https://www.3dque.com/" rel="noopener ugc nofollow" target="_blank"> 3DQue </a>的Quinly软件。在这里，我解释一下我们如何通过使用几个Python脚本来创建“失败”g代码，并将这些文件上传到Quinly，让另一个Bash脚本自动记录每次打印的时间间隔，从而实现数据收集过程的自动化。如果你想帮助我们收集更多的数据，一定要给我们发一些你的3D打印失败的图片！</p><h1 id="02b6" class="jm jn hh bd jo jp jq jr js jt ju jv jw in jx io jy iq jz ir ka it kb iu kc kd bi translated">如果您错过了本系列的前两篇文章:</h1><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/the-path-to-autonomous-3d-printing-c1c0f40b461a"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">自主3D打印之路</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">如果3D打印机可以通过使用计算机视觉识别抽象的3D打印故障来监督自己，会怎么样？</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="lw l lx ly lz lv ma jg lm"/></div></div></a></div><div class="lj lk ez fb ll lm"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/classification-how-many-ways-can-a-print-fail-80e5715edff5"><div class="ln ab dw"><div class="lo ab lp cl cj lq"><h2 class="bd hi fi z dy lr ea eb ls ed ef hg bi translated">分类:印刷失败的方式有几种？</h2><div class="lt l"><h3 class="bd b fi z dy lr ea eb ls ed ef dx translated">通过机器学习，Quinly不仅可以控制你的3D打印机，还可以监督它。</h3></div><div class="lu l"><p class="bd b fp z dy lr ea eb ls ed ef dx translated">medium.com</p></div></div><div class="lv l"><div class="mb l lx ly lz lv ma jg lm"/></div></div></a></div></div></div>    
</body>
</html>