<html>
<head>
<title>Linear Regression Using PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用PyTorch进行线性回归</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/linear-regression-using-pytorch-be864e580a5?source=collection_archive---------23-----------------------#2021-05-14">https://medium.com/analytics-vidhya/linear-regression-using-pytorch-be864e580a5?source=collection_archive---------23-----------------------#2021-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4eb99523a77fa780a0fe33d40bbdecdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lGbruP6yrpkPmMhy9smww.jpeg"/></div></div></figure><p id="ef87" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">正如我们所知，线性回归是一种在机器学习中实现的统计模型，用于确定一个或多个解释变量的标量响应。使用程序员可用的各种各样的包，实现这样的模型变得更加容易。今天，我将向您展示如何使用PyTorch(一个python库)来实现线性回归模型。要了解PyTorch的更多信息，请点击<a class="ae jn" href="https://pytorch.org/" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="a547" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将使用Kaggle上的波士顿定价数据集进行演示。在我们开始编码我们的模型之前，让我们导入所需的包。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="904f" class="ke kf hh ka b fi kg kh l ki kj">import pandas as pd           #Package to work with DataFrames<br/>import numpy as np            #Package to work with Arrays<br/>import torch                  #Package to work with tensors <br/>import torch.nn as nn         #Package in which the model is present</span></pre><p id="91e6" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在，我们将波士顿住房数据集导入到数据框中。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="d427" class="ke kf hh ka b fi kg kh l ki kj">data = pd.read_csv(r'../input/bostonhoustingmlnd/housing.csv')</span></pre><p id="5df4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在让我们选择预测列和目标列。因为我们必须表示波士顿房子的价格，所以“MEDV”被作为代表中间值的目标列，而所有其他列都是预测值。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="ff2d" class="ke kf hh ka b fi kg kh l ki kj">inputs = data.drop('MEDV', axis = 1)   <br/>#The axis is given as 1 to demonstrate it as column<br/>targets = data['MEDV']</span></pre><p id="d506" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在有了预测所需的数据。但是，它是熊猫数据帧的形式，PyTorch要工作，我们需要将它们转换成张量。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="f625" class="ke kf hh ka b fi kg kh l ki kj">'''We are changing the type of data to float32 from the default double64 while converting them to tensors'''<br/>inputs = torch.tensor(inputs.values.astype(np.float32))<br/>targets = torch.tensor(targets.values.astype(np.float32))</span></pre><p id="8c7e" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">获得张量后，我们需要将它们添加到TensorDataset中，以便将输入数据分成训练和测试数据。这可以使用torch库来完成。DataLoader用于将整个数据集转换成批处理。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="6193" class="ke kf hh ka b fi kg kh l ki kj">from torch.utils.data import DataLoader, TensorData<br/>train_ds = TensorDataset(inputs, targets)    #TensorDataset<br/>batch_size = 10  #The dataset is divided into 10 parts</span><span id="adb5" class="ke kf hh ka b fi kk kh l ki kj">'''We now get the training dataset with 10 splits, "shuffle" is set to true to make sure that the dataset is shuffled before being split into batches'''</span><span id="9ce9" class="ke kf hh ka b fi kk kh l ki kj">train_dl = DataLoader(train_ds, batch_size, shuffle = True) </span></pre><p id="9b25" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">接下来，我们开始创建线性回归模型。调用线性模型后，我们传递两个参数，第一个是输入的数量，第二个是输出的数量。torch库使用randn方法设置权重和偏差，我们可以看到初始值。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="9b58" class="ke kf hh ka b fi kg kh l ki kj">model = nn.Linear(3, 1)<br/>print(model.weights, model.bias) #Initial values of weight and bias</span></pre><p id="6cc1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">现在已经建立了线性回归模型。我们现在可以针对不同的输入进行测试。训练数据作为用于预测的参数被传输，因为数据被分成批，并且模型将一直面对不同的数据集。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="3e45" class="ke kf hh ka b fi kg kh l ki kj">preds = model(inputs)</span></pre><p id="d294" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在需要优化模型以获得更好的结果。我们使用均方差来检验模型的误差，并使用标准梯度下降法进行优化。所需的方法可以在torch库中找到，实现如下所示。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="bb28" class="ke kf hh ka b fi kg kh l ki kj">import torch.nn.functional as F<br/>loss_function = F.mse_loss     <br/>loss = loss_function(preds, targets)<br/>opt = torch.optim.SGD(model.parameters(), lr = 1e-8)  <br/>#lr-Learning Rate</span></pre><p id="a025" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们现在创建一个函数，在需要时调用这个模型。backward()函数用于回溯变量的值，并找到它的导数。</p><pre class="jv jw jx jy fd jz ka kb kc aw kd bi"><span id="5170" class="ke kf hh ka b fi kg kh l ki kj">'''<br/>This function takes the number of iterations(epochs), the type of neural network(model), the loss function used to determine<br/>the accuracy(loss_fn), the optimzation factor(opt), and the training dataset(train_dl). After all the opertaions are done,<br/>it returns the predicted values with minimum loss. If the results are not yet accurate, alter minor values like epoch and opt.<br/>'''<br/>def fit(epochs, model, loss_fn, opt, train_dl):<br/>    for e in range(epochs):<br/>        for xb, yb in train_dl:<br/>            pred = model(xb)<br/>            loss = loss_fn(pred, yb)<br/>            loss.backward()<br/>            opt.step()<br/>            opt.zero_grad()<br/><em class="kl">        </em>if e % 10 == 0:<br/><em class="kl">            </em>print(loss)</span></pre><p id="63d8" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">恭喜您，您已经使用PyTorch成功构建了一个工作的线性回归模型。要在Kaggle上访问我的笔记本，请点击这里的<a class="ae jn" href="https://www.kaggle.com/thejaskiran/pytorch-linearregression" rel="noopener ugc nofollow" target="_blank"/>。</p></div></div>    
</body>
</html>