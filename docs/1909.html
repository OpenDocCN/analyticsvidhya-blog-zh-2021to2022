<html>
<head>
<title>Stack Overflow Automation tool : build this super helpful application under 10 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">堆栈溢出自动化工具:在10分钟内构建这个超级有用的应用程序</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/stack-overflow-auto-search-tool-automate-your-search-for-errors-f95548790d77?source=collection_archive---------11-----------------------#2021-03-25">https://medium.com/analytics-vidhya/stack-overflow-auto-search-tool-automate-your-search-for-errors-f95548790d77?source=collection_archive---------11-----------------------#2021-03-25</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="8395" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">停止复制粘贴，开始自动化！</h2></div><h2 id="350c" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">为什么要自动搜索错误？</h2><p id="3e2e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">你是一个初学编码的人吗？你是否花了很多时间从浏览器的代码中复制粘贴你的错误？你觉得有必要自动化多余的拷贝粘贴工作，并在浏览器中直接打开相关窗口吗？我也是！直到直到我开始通过运行一个脚本来自动化我的搜索。</p><h2 id="2e44" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">什么是堆栈溢出？</h2><p id="1823" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">Stack Overflow是所有编程调试、技术爱好者的一站式目的地，也是一个不断发展的共享编程知识、学习和支持他人的社区。“被错误卡住了？您检查堆栈溢出了吗？”会是显而易见的回答。所以你现在明白了。您在编码时面临的大多数查询可能已经有了关于堆栈溢出的答案。</p><h2 id="4c4f" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">掌握基本知识！</h2><p id="027e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">让我们弄清楚一些基础知识，以便真正了解项目的要点！我们将学习堆栈交换API。如果您已经了解这些概念，请随意跳到下一部分。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ko"><img src="../Images/93687278d8ea184f8ca992628ad9cf5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*cRmo-Vy-aQkr0pdcc1Rkfg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">在Python中，运行此脚本并查看错误。由于字符串s的长度为2，s[6]将导致<strong class="bd iz">索引超出范围错误。</strong></figcaption></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es la"><img src="../Images/fd968f0c01f1e3cb43b2c2ccce40b55d.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*G0uFII2b_syxdFKG1tHcHw.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">我们只需要错误字符串的最后一行(对于Python代码调试)给出错误类型和错误消息。</figcaption></figure><p id="5788" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">访问api.stackexchange.com的<a class="ae lg" href="https://api.stackexchange.com/" rel="noopener ugc nofollow" target="_blank">后，点击<strong class="jx hj">所有文档</strong>，进入<strong class="jx hj">搜索功能</strong>。</a></p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lh"><img src="../Images/7c5172159e1299b440cbc6a7dc19b188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EjDeZOSjc_xG3UEe63057w.png"/></div></div></figure><p id="1676" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">使用Try It部分调用REST API。在<strong class="jx hj">标记的</strong>部分填写您的源代码(在我的例子中为error.py)所用的语言(在我的例子中为Python ),在<strong class="jx hj">标题</strong>部分填写您的错误消息。点击运行！</p><p id="1373" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">您将发现一个包含项目列表的JSON响应。我们只需要条目列表中is_answered设置为true的那些对象。我们从这些对象中获取链接来打开各自的堆栈溢出线程。</p><h2 id="ec7e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">如何自动搜索？</h2><p id="f939" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">您选择的任何编程语言都可以实现自动化。我做过Python，C，C++错误调试。它可以很好地扩展到其他编程语言，如Java。所以让我们开始吧！</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lm"><img src="../Images/19642bfb2dd67bfa9d6affd95a55d1b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9SlofsxEiOVbvBCIoruOLQ.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">来源:<a class="ae lg" href="https://www.crio.do/projects/python-stackoveflow-auto-search/" rel="noopener ugc nofollow" target="_blank"> Crio项目</a></figcaption></figure><p id="9176" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我们首先创建一个包装器脚本，它将您希望运行的代码文件作为输入。如果没有发现错误:哇哦！代码中没有错误。拍一下你的肩膀。否则，我们提取错误消息，并使用堆栈交换API在web浏览器中打开3个(任意数量)最相关的线程。</p><p id="c498" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">为了简单起见，我们将整个代码分成3个步骤。我强烈建议你们先坐下来，从片段中理解代码。我还在最后附上了可以直接使用的完整代码。</p><h2 id="aa7a" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">1.从您希望运行的脚本中提取错误消息</h2><p id="0d8e" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">我们调用extracterror()方法，将源文件的名称作为输入。目前我只接受python文件作为输入。所以我传入了“error.py”作为输入。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es ln"><img src="../Images/b2548eb46ca8b486eb5db82f9b564009.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*38bUv-okfF786i7Lzdubyg.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">从main调用extracterror函数</figcaption></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lo"><img src="../Images/c48a4d2d24440a9a0bfe911c20fb303f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6lNW-SsWE0QjQe1_VeFbtg.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">提取错误的代码</figcaption></figure><p id="b226" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我们使用子流程模块来运行源文件。子进程模块允许您创建新的进程，连接到它们的输入/输出/错误管道，并获取它们的返回代码。这有助于您在app.py/wrapper脚本中将error.py作为子流程运行。您可以通过连接到它们的管道来提供输入、获取输出和错误。</p><p id="e2bb" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">stderr变量将包含所有错误。但它是二进制形式。你需要把它解码成UTF 8号。这将提供字符串形式的数据。我们从字符串中去掉任何新行字符，并删除不必要的细节，如文件名、行号等。通过使用splitlines()方法，我们只保留包含错误类型和错误消息的最后一行。</p><p id="dcec" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我们将错误字符串作为输入发送给sendreq方法以生成请求。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es lp"><img src="../Images/e0738435950081affd6488a9968608d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1032/format:webp/1*pL3iRPpgOZ1CRo0HILceig.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">提取的错误输出</figcaption></figure><h2 id="363e" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated"><strong class="ak"> 2。使用堆栈交换API的搜索功能生成请求</strong></h2><figure class="kp kq kr ks fd kt er es paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="er es lq"><img src="../Images/7d63dc42001cd2d2ee4b6c5575763610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AtDC32OTleACoxIqcOTa5g.png"/></div></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">进行REST API调用的代码</figcaption></figure><p id="2a64" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">sendreq方法将提取的错误字符串作为输入，并将其拆分到<strong class="jx hj">错误:</strong>上，以获得errortype &amp;错误消息。</p><p id="d7a0" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">如上所述，我们可以使用堆栈交换搜索API调用REST API来发送GET请求。我们使用python模块requests来发出请求。</p><p id="a324" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我们提出三个要求:</p><ol class=""><li id="dc41" class="lr ls hi jx b jy lb kb lc ji lt jm lu jq lv kn lw lx ly lz bi translated">使用错误类型和错误消息。</li><li id="f1af" class="lr ls hi jx b jy ma kb mb ji mc jm md jq me kn lw lx ly lz bi translated">仅使用错误类型。</li><li id="4e0e" class="lr ls hi jx b jy ma kb mb ji mc jm md jq me kn lw lx ly lz bi translated">仅使用错误消息。</li></ol><p id="8426" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">因为响应是JSON格式的，所以我们使用。json()方法来获取对象(即响应中的项目列表)。请注意，尽管该方法被命名为json()，但结果是<strong class="jx hj">而不是JSON </strong>，而是将JSON作为输入并解析它以产生一个对象的结果。</p><p id="fc9d" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">现在我们调用getlinks()方法来获取相关线程的链接。</p><h2 id="ebdb" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">3.使用网络浏览器模块在网络浏览器中打开提取的链接。</h2><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mf"><img src="../Images/4b18ab5c3dd1cdb634bcab21699da94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*yH43b7D9fI-GlJlA6W5i7Q.png"/></div></figure><p id="c1e8" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">最初，我们创建一个url_list来存储相关线程的链接。我们遍历列表并检查is_answered对于该对象是否为真。如果是真的，我们把链接附加到url_list。</p><p id="14d9" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我们不希望我们的浏览器显示成千上万的结果。那太疯狂了！所以我们可以将链接的数量限制为一个值。另一种可能是，我们已经穷尽了没有答案/链接的对象列表。是时候发布一个关于堆栈溢出的新问题了！在这些情况下，我们会打破循环。</p><p id="4c07" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">最后，我们使用python中的webbrowser模块，它的open方法在您的浏览器中打开url。你可以自定义它打开在新的窗口或新标签按照你的意愿。</p><p id="3fb3" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">将一切结合在一起！</p><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="mg mh l"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">整个包装脚本</figcaption></figure><h2 id="acb2" class="ix iy hi bd iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju bi translated">C，C++代码呢？</h2><p id="db1a" class="pw-post-body-paragraph jv jw hi jx b jy jz ij ka kb kc im kd ji ke kf kg jm kh ki kj jq kk kl km kn hb bi translated">当我尝试使用python中的包装器脚本编译和运行C、C++代码时；我在Windows操作系统中运行代码时遇到了困难。如果您是Linux用户，您可以尝试以下步骤来运行C /C++代码并生成错误消息。其余的步骤都是一样的。唯一的变化是:我们首先需要使用gcc编译器(g++用于C++)编译C代码。编译时本身可能会产生错误。我使用了子进程模块的调用函数，该函数在编译/运行成功时返回0。</p><p id="29f4" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">如果不是，那么将生成一个可执行(汇编输出)文件a.out。可能会出现运行时错误，如内存不足或被零除错误。也可以提取和搜索这些错误。</p><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mi"><img src="../Images/4dac9e5cc5812ae64e981c5f15132eca.png" data-original-src="https://miro.medium.com/v2/resize:fit:892/format:webp/1*ZRebyoTHC6Q8ZjJw3dHqdA.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">error.cpp</figcaption></figure><figure class="kp kq kr ks fd kt"><div class="bz dy l di"><div class="mg mh l"/></div></figure><figure class="kp kq kr ks fd kt er es paragraph-image"><div class="er es mj"><img src="../Images/5624dcf98883e4f0589581323db1c15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1050/format:webp/1*Xj6EkjIkmoZ8WOWOLrCyTQ.png"/></div><figcaption class="kw kx et er es ky kz bd b be z dx translated">提取错误</figcaption></figure><p id="a6bc" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">这可以很好地扩展到Java和您选择的其他语言。抓住你的编码鞋！开始吧:)</p><p id="5d91" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">我真的很感谢Crio项目在他们的项目中心有这个美妙的项目想法。此外，我参加了Pranav Dar举办的Analytics Vidya速成课程，该课程内容丰富，令人大开眼界，见解深刻，对我帮助很大。感谢你的努力。</p><p id="0e63" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">完整的代码可以访问:<a class="ae lg" href="https://github.com/kamatvedita99/Python-Mini-Projects" rel="noopener ugc nofollow" target="_blank">https://github.com/kamatvedita99/Python-Mini-Projects</a></p><p id="795b" class="pw-post-body-paragraph jv jw hi jx b jy lb ij ka kb lc im kd ji ld kf kg jm le ki kj jq lf kl km kn hb bi translated">对于任何疑问/澄清，你可以留下评论或写信给我在kamatvedita99@gmail.com。</p></div></div>    
</body>
</html>