<html>
<head>
<title>How To The Count Number Of Ways That A List Of Items Can Be Partitioned Into Identical Sized Sub-Sets Ignoring Ordering Of Elements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何计算忽略元素顺序将一个项目列表划分成相同大小的子集的方法</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-the-count-number-of-ways-that-a-list-of-items-can-be-partitioned-into-identical-sized-8be50c2757ae?source=collection_archive---------1-----------------------#2022-02-05">https://medium.com/analytics-vidhya/how-to-the-count-number-of-ways-that-a-list-of-items-can-be-partitioned-into-identical-sized-8be50c2757ae?source=collection_archive---------1-----------------------#2022-02-05</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="d1fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也就是组合学的乐趣…</p><p id="09d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这篇文章最初是想并入我写的另一篇关于婚礼座位问题的文章。</p><div class="jc jd ez fb je jf"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/building-a-wedding-seating-plan-using-probabilistic-methods-simulated-annealing-8f31d8987026"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">使用概率方法和模拟退火建立婚礼座位计划</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">本文涵盖了婚礼座位计划问题，这是一个组合难题，如何最好地分配客人…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">medium.com</p></div></div><div class="jo l"><div class="jp l jq jr js jo jt ju jf"/></div></div></a></div><p id="f538" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，数学变得有点多，我想放一篇小文章的标题，准确地描述这是如何帮助其他有同样问题的人轻松找到解决方案的。</p><p id="40eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所以问题陈述是“有多少种方法可以将一个M项的列表划分成大小为N的均匀大小的集合？”我应用这一方法的实际例子是，计算出给定客人名单和设定的桌子大小可能有多少座位安排(在我们允许空座位的条件下，即如果我们有45人和8人/桌，我们将需要6张桌子和3个空座位)</p><p id="f46b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对堆栈溢出的快速检查给了我一些接近的东西，但并不完全是我想要的</p><div class="jc jd ez fb je jf"><a href="https://stackoverflow.com/questions/312443/how-do-you-split-a-list-into-evenly-sized-chunks" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">如何将一个列表分割成大小相等的块？</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">我有一个任意长度的列表，我需要把它分成大小相等的块并对其进行操作。有一些…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">stackoverflow.com</p></div></div><div class="jo l"><div class="jv l jq jr js jo jt ju jf"/></div></div></a></div><p id="07f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">起初这听起来很简单，但在尝试用纸和笔“推理”之后，我意识到我高中的组合数学可能有点生疏了。</p><p id="f1e1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我不得不后退一步，从计算元素在给定的一组约束条件下的组合方式的角度，挑选一些基本的构建模块…</p><div class="jc jd ez fb je jf"><a href="https://towardsdatascience.com/combinatorics-permutations-combinations-and-dispositions-46604da34882" rel="noopener follow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">组合学:排列、组合和处置</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">组合学是数学的一个领域，主要研究对一个或多个集合中的元素进行计数。它可以…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">towardsdatascience.com</p></div></div><div class="jo l"><div class="jw l jq jr js jo jt ju jf"/></div></div></a></div><p id="0477" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上面的文章很好地涵盖了这些。TLDR的版本是，对于排列-顺序很重要，在组合中-它们不重要(即[A，B，C]被认为与[C，B，A]相同，与[B，A，C]相同)(现在让我们忽略那些只是<em class="jx">排列的排列，其中我们想要挑选的对象的数量少于对象的总数</em>)</p><p id="d5a1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，如果这只是一个简单的问题，问你有多少种方法可以安排一张桌子的座位(例如，nCr，其中n=45人，r=每张桌子8人)，我们可以忽略座位顺序(即，客人坐在桌子的哪个座位无关紧要)，我们可以这样计算</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="ccbd" class="kh ki hh kd b fi kj kk l kl km">import math</span><span id="db8d" class="kh ki hh kd b fi kn kk l kl km">def nCr(n,r):<br/>    f = math.factorial<br/>    return f(n) / f(r) / f(n-r)</span><span id="ba9f" class="kh ki hh kd b fi kn kk l kl km">nCr(n,r)</span></pre><p id="ca93" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，在最新版本的数学库(Python 3.8以后)中，这变得非常简单，其中已经有一个预构建的函数math.comb做同样的事情。</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="680a" class="kh ki hh kd b fi kj kk l kl km">math.comb(n,r)</span></pre><p id="b81f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在的问题是，当你得到一个大的数字时，这种计算往往需要很长时间，所以Quora上的这位用户建议使用对数来加速计算过程</p><div class="jc jd ez fb je jf"><a href="https://www.quora.com/What-are-the-method-to-calculate-nCr-in-Python-for-large-values-of-r-and-n" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">对于r和n的大值，Python中计算nCr的方法有哪些？</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">回答(第1题，共2题):这取决于你是需要确切的数字(即知道每个位置的数字)还是仅仅…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">www.quora.com</p></div></div><div class="jo l"><div class="ko l jq jr js jo jt ju jf"/></div></div></a></div><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="fab2" class="kh ki hh kd b fi kj kk l kl km">def log_fact(n):</span><span id="f839" class="kh ki hh kd b fi kn kk l kl km">    return sum(math.log10(i) for i in range(1, n+1))</span><span id="8b24" class="kh ki hh kd b fi kn kk l kl km">def big_nCr(n, r):</span><span id="54f1" class="kh ki hh kd b fi kn kk l kl km">    a, b, c = log_fact(n), log_fact(r), log_fact(n-r)</span><span id="77c1" class="kh ki hh kd b fi kn kk l kl km">    return 10**(a-b-c)</span><span id="5572" class="kh ki hh kd b fi kn kk l kl km">big_nCr(n,r)</span></pre><p id="a4c3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这一切都很好，但不幸的是，对于手头的问题，这不仅仅是估计一张桌子可能的组合，而是我们有多少种方法可以让所有不同的客人坐在所有不同的桌子上。</p><p id="bed5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">进一步的挖掘让我想到了有趣的斯特林数(第二类)的概念，这是将一组<em class="jx"> n </em>对象划分为<em class="jx"> k </em>非空子集的方法的数量，用S(n，k)表示</p><div class="jc jd ez fb je jf"><a href="https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">第二类斯特灵数-维基百科</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">在数学中，特别是在组合学中，第二类斯特林数(或斯特林分割数)是…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">en.wikipedia.org</p></div></div><div class="jo l"><div class="kp l jq jr js jo jt ju jf"/></div></div></a></div><p id="edb8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">啊哈！就是这个！不幸的是，这个公式并不简单，而且涉及到递归函数。谢天谢地，也有一些关于如何使用Python计算英镑数字的在线实现<a class="ae kq" href="https://www.geeksforgeeks.org/count-number-of-ways-to-partition-a-set-into-k-subsets/" rel="noopener ugc nofollow" target="_blank"/></p><p id="082d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">不幸的是，看着它产生的结果，感觉有点不对劲——如果你有6个条目(1，2，3，4，5，6)和2个分区(即每个分区每个应该是3个字符)，斯特林数(第二种)达到31，感觉太多了…</p><p id="8301" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我发现了一段<a class="ae kq" href="https://codereview.stackexchange.com/questions/1526/finding-all-k-subset-partitions" rel="noopener ugc nofollow" target="_blank">代码，它列举了</a>所有可能的集合，这时我意识到大小不均匀的子集也包括在计数中。</p><figure class="jy jz ka kb fd ks er es paragraph-image"><div class="er es kr"><img src="../Images/6b5e90d7515668a77eddafac821c2bd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1284/format:webp/1*qi8i76qlec0ayUVGcCdB-A.png"/></div><figcaption class="ku kv et er es kw kx bd b be z dx translated">S(6，2)的第二类Stirling数—我只是在寻找红色，它是31中的10</figcaption></figure><p id="ab61" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我所追求的原则上应该更简单，因为我只是在寻找那些大小均匀的。</p><p id="2da1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">首先，我想看看能不能写一个脚本来过滤掉所有其他没有相同大小分区的集合，但是我很幸运地发现了这篇StackOverflow文章:</p><div class="jc jd ez fb je jf"><a href="https://stackoverflow.com/questions/14559946/producing-all-groups-of-fixed-length-combinations" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">产生所有组的固定长度组合</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">我在寻找一种算法和/或Python代码来生成所有可能的方式分割成一组n个元素…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">stackoverflow.com</p></div></div><div class="jo l"><div class="ky l jq jr js jo jt ju jf"/></div></div></a></div><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="bed0" class="kh ki hh kd b fi kj kk l kl km">from itertools import combinations</span><span id="5efc" class="kh ki hh kd b fi kn kk l kl km">def partitions(s, r):<br/>    s = set(s)<br/>    assert(len(s) % r == 0)<br/>    if len(s) == 0:<br/>        yield ()<br/>        return<br/>    first = next(iter(s))<br/>    rest = s.difference((first,))<br/>    for c in combinations(rest, r - 1):<br/>        first_subset = (first,) + c<br/>        for p in partitions(rest.difference(c), r):<br/>            yield (first_subset,) + p</span></pre><p id="6ca8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，利用这一点，我所要做的就是</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="e774" class="kh ki hh kd b fi kj kk l kl km">NoOfArrangements=len(list(partitions(s,r)))</span></pre><p id="73c9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">唯一不好的一点是它不能很好地扩展——如果你在做S=6，r=3这样的事情，它可以很好地工作，但是如果你有200个客人和10张桌子，那么它将永远需要<strong class="ig hi">运行，因为它试图枚举所有可能的安排。</strong></p><p id="c0f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我在这里找到了另一个解决方案，它不需要列举答案，只需要计算集合排列方式的总数</p><div class="jc jd ez fb je jf"><a href="https://math.stackexchange.com/questions/507681/problem-permutation-and-combination-in-how-many-ways-can-we-divide-12-studen" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">问题:排列组合:我们可以用多少种方法将12名学生分成几组…</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">从n个项目中选择r个项目的组示例:有多少种方法可以从6个学生中选择两个项目的组…</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">math.stackexchange.com</p></div></div><div class="jo l"><div class="kz l jq jr js jo jt ju jf"/></div></div></a></div><p id="06d6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因为它在数学堆栈交换上，所以它不是Python，但基本思想是答案将由这个等式给出:-</p><p id="4021" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">n！/ ((n/k)！*(k！**(不适用))</p><p id="f062" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">把它变成Python…</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="add8" class="kh ki hh kd b fi kj kk l kl km">NoOfCombinations=math.factorial(noOfElements)/((math.factorial(noOfElements/r))*(math.factorial(r)**(noOfElements/r)))</span></pre><p id="f33e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种方法的问题是，当数字变得太大时，它仍然会“中断”，例如200，20，因为我得到了一个“<strong class="ig hi"> OverflowError </strong> : int太大，无法转换为float”</p><p id="88e0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我试图找到另一种方法，并发现我可以使用下面的逻辑来估计相同的数字</p><p id="12ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于n，k (n个元素和k个大小的分区)</p><p id="188b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">安排数量</p><p id="346a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">= nCr(n-k*(n/k)，k) x nCr(n-k*(n/k-1)，k)…。x nCr(k，k) / (n/k)！</p><p id="57d3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用12，3的数字算出来</p><p id="6b52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">nCr(12，3) x nCr(9，3) x nCr(6，3) x nCr(3，3) / (12/3)！= 15400</p><p id="3642" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">基本原理是，对于第一个隔间，您有12个元素可供选择来填充3个槽，在第二个隔间中，您还有9个元素来填充3个槽，依此类推直到结束。我们除以12/3！以消除重复的安排。</p><p id="ebc8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">用代码写出来会给出:-</p><pre class="jy jz ka kb fd kc kd ke kf aw kg bi"><span id="e93f" class="kh ki hh kd b fi kj kk l kl km">noOfElements=240<br/>r=12</span><span id="992f" class="kh ki hh kd b fi kn kk l kl km">list_for_nCr=[]<br/>for i in range(0,int(noOfElements/r)):<br/>    list_for_nCr.append(noOfElements-i*r)</span><span id="0e7c" class="kh ki hh kd b fi kn kk l kl km">list_of_nCr_vals=[]<br/>for element in list_for_nCr:<br/>    list_of_nCr_vals.append(big_nCr(element,r))</span><span id="ba59" class="kh ki hh kd b fi kn kk l kl km">NoOfArrangements=<br/>np.prod(list_of_nCr_vals)/math.factorial(noOfElements/r)</span></pre><p id="6222" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在下面的这款Google Colab笔记本上亲自尝试一下吧</p><div class="jc jd ez fb je jf"><a href="https://colab.research.google.com/drive/1yq9B-aoSCWUzvPm4hWf6QwyJdUvduId4?usp=sharing" rel="noopener  ugc nofollow" target="_blank"><div class="jg ab dw"><div class="jh ab ji cl cj jj"><h2 class="bd hi fi z dy jk ea eb jl ed ef hg bi translated">谷歌联合实验室</h2><div class="jm l"><h3 class="bd b fi z dy jk ea eb jl ed ef dx translated">编辑描述</h3></div><div class="jn l"><p class="bd b fp z dy jk ea eb jl ed ef dx translated">colab.research.google.com</p></div></div><div class="jo l"><div class="la l jq jr js jo jt ju jf"/></div></div></a></div><p id="e5eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">就这样……(我说过这将是一个简短的……)</p></div></div>    
</body>
</html>