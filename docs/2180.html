<html>
<head>
<title>Image Simplification through binarization in OpenCV</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenCV中的二值化图像简化</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-simplification-through-binarization-in-opencv-1292d91cae12?source=collection_archive---------0-----------------------#2021-04-11">https://medium.com/analytics-vidhya/image-simplification-through-binarization-in-opencv-1292d91cae12?source=collection_archive---------0-----------------------#2021-04-11</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="45d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用最简单的术语来说，图像二值化意味着您将图像转换为黑白格式。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/19f89a7d102e06f53320c0ef5a7375d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WsPe3Wlbdjlr6nQmb0H7Hg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">原始图像(c)灰度图像(b)和二值图像(a)</figcaption></figure><p id="3f41" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">大多数计算机视觉程序都是从将图像转换成二进制格式开始的(相信我，在每个计算机视觉应用程序中，你的第一步都是将图像二进制化)。图像越原始，计算机就越容易处理它并理解图像的底层特征(这对正常人的眼睛来说可能相当容易理解)。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="b0db" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">在OpenCV中执行图像二值化的不同方法</h1><p id="27cd" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">可能有多个因素决定如何进行二值化。我不会涵盖所有的技术，但这里是最常见的:</p><ol class=""><li id="36cf" class="ld le hi ih b ii ij im in iq lf iu lg iy lh jc li lj lk ll bi translated">Canny边缘检测</li><li id="5460" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">阈值处理</li><li id="03e2" class="ld le hi ih b ii lm im ln iq lo iu lp iy lq jc li lj lk ll bi translated">分段(你可以用它来创建更多的分段，而不仅仅是2个黑白分段，但我们将把重点放在二值化上)</li></ol><blockquote class="lr ls lt"><p id="fa2c" class="if ig lu ih b ii ij ik il im in io ip lv ir is it lw iv iw ix lx iz ja jb jc hb bi translated">注意:本文没有深入讨论这些算法是如何工作的。相反，重点是如何在OpenCV和python中实际完成事情。然而，如果你想看这些算法的基本工作原理，我会放上链接和参考。</p></blockquote></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="429d" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">Canny边缘检测</h1><p id="0fef" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">顾名思义，这种探测器可以探测图像的边缘。该过程检测到的边缘是白色的，而其他所有的都是黑色的。Canny边缘检测算法使用5个步骤来实现它:<br/>降噪、梯度计算、非最大值抑制、双阈值、滞后边缘跟踪。要查看这些步骤的更多细节，请查看第<a class="ae ly" href="https://towardsdatascience.com/canny-edge-detection-step-by-step-in-python-computer-vision-b49c3a2d8123" rel="noopener" target="_blank">页</a>。</p><p id="3b52" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在来看如何在open-cv中使用它的主要部分。这就是精明方法对你的要求。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="33c9" class="me kb hi ma b fi mf mg l mh mi">cv2.Canny(image, lowerThreshold, upperThreshold, apertureSize, L2gradient)</span></pre><p id="1b97" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你只需要提供你的<strong class="ih hj">原始图像</strong> (RGB很好，因为OpenCV的canny方法在内部将其转换为灰度)，一个<strong class="ih hj">下限</strong>和<strong class="ih hj">上限阈值</strong>值。这3个参数对于继续使用canny方法来说已经足够了。我将简要解释最后两个参数的作用，但是你很难改变它们，它们是可选的。</p><p id="ffdf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">apertureSize:是用于Sobel过滤器的内核大小。该滤波器的工作方式与CNN中的卷积滤波器非常相似。默认值为3X3。</p><p id="adb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">L2Gradient:这指定了寻找梯度大小的方程式。L2gradient为布尔类型，默认值为False。</p><p id="dfba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我解释一下<strong class="ih hj">下限和上限阈值</strong>是什么意思。这非常重要，会影响你的输出结果</p><p id="5da7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阈值由Canny算法中的步骤4(阈值)使用。请注意，这些不是像素值，而是最小和最大梯度值。</p><p id="ca06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lu">例如，如果阈值为[0.1±0.15]，则考虑高于上限(0.15)的边缘像素，并丢弃低于阈值(0.1)的边缘像素。现在，你可能会有一个问题“上下阈值之间的像素怎么办”？只有当它们连接到上阈值中的像素时才被考虑。因此我们得到一个清晰的边缘。</em></p><p id="072b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">坦率地说，我很难理解这些价值观。但是这些实际上是一些试着改变的值，你可以在你的代码中根据具体情况进行更新。没有适用于所有人的标准价值观。我看过一些文章，他们说高值应该是小值的3倍，但这并不普遍。大多数情况下，我看到人们使用75，200。你可以试一试，看看是否有帮助，但你总是可以自由地使用给你带来最佳结果的值。但是如果您仍然不确定，您可以使用下面的代码片段(shoutout to pyimagesearch for this)来自动为您计算值:</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="8601" class="me kb hi ma b fi mf mg l mh mi">median = np.median(image)<br/>lower = int(max(0, (1.0 - sigma) * median))<br/>upper = int(min(255, (1.0 + sigma) * median))<br/>#lower sigma--&gt;tighter threshold(default value of sigma can be 0.33)</span></pre><p id="2246" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以最后，这就是你的代码在python中的样子。这不是很简单却很有效吗？</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="62fb" class="me kb hi ma b fi mf mg l mh mi">import cv2</span><span id="282f" class="me kb hi ma b fi mj mg l mh mi">image = cv2.imread("3.jpg")<br/>edge_image= cv2.Canny(image, lower, upper)<br/>cv2.imshow("edgeDetection", edge_image)<br/>cv2.waitKey(0)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mk"><img src="../Images/211a15ee6f34cb026804d627dae8f212.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-KwYQVKxhp1sBlHBc5f5g.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">原始图像(右)，锐利边缘(左)</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="7f1c" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">阈值处理</h1><p id="b556" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">一种非常简单的技术，其中所有低于阈值的像素将被标记为黑色，而高于阈值的像素将被标记为白色。阈值处理实际上是分割的一个子集(将在下一节讨论)。</p><p id="42bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="lu">阈值分割是图像分割的一种更简单的形式，它是一种基于对原始图像的像素强度设置阈值来创建二值图像的方法。</em></p><p id="ac3e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设您想要基于绿色像素对图像进行阈值处理。因此，您将阈值设置为绿色像素。因此，所有绿色像素在经过阈值处理的图像中将变成白色，其余的则变成黑色。这将被称为您的分段1(基于绿色像素)。</p><p id="65d0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，如果您仍然决定基于红色像素创建另一个分段，您可以继续将阈值设置为红色像素并应用阈值处理。输出将被称为段2。这就是为什么我们称阈值分割为更简单的分割形式，因为您可以应用多个阈值，这与应用分割技术类似。</p><p id="50ba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">点击查看阈值与分割检查<a class="ae ly" href="https://www.youtube.com/watch?v=8TkligJJCAQ" rel="noopener ugc nofollow" target="_blank">。仅仅介绍部分就足够了，不要进入代码，因为它不是必需的。</a></p><p id="a671" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在实践中，你会使用更多的分段，而不是阈值。所以在这篇文章中，我将更多地强调细分。但是为了告诉您在OpenCV中这是多么简单，我给你一个简单的代码片段</p><p id="fd0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du ml mm mn ma b">ret, thresh_image <strong class="ih hj">= </strong>cv2.threshold(img, 120, 255, cv2.THRESH_BINARY)</code></p><p id="6f22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">阈值是120和255。如果你想深入探究，请查看<a class="ae ly" href="https://www.geeksforgeeks.org/python-thresholding-techniques-using-opencv-set-1-simple-thresholding/" rel="noopener ugc nofollow" target="_blank">这个非常好的解释</a>。此外，请注意<em class="lu">自适应阈值</em>将是最常用的情况。所以你可以更仔细地检查一下。</p></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="c23a" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">分割</h1><p id="26bb" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">如果你浏览了这段youtube视频，你可能会看到这张图片</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mo"><img src="../Images/f020f509bcde0d2bce2755eaa520d1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5CZSlKhjd2qQojIX-eES_w.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">(左起)1。假设你有一个图像，你想二值化它的基础上红点2。使用阈值技术3基于红点对该图像进行二值化。您可以根据不同的阈值重复多个阈值处理，以获得类似于此图的效果。图2中已经创建了黄色部分。</figcaption></figure><p id="f38b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以应用分割技术来获得不同的片段，而不是在原始图像上应用多个阈值。这就是细分的意义所在。但是因为我们在本文中关注的主要话题是二值化，所以我们计划只创建一个段。这1个分段可以使用阈值技术来创建，但是如果我们有更强大的分段技术，为什么要这样做呢？</p><p id="5d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">理论讲得够多了，但这不是我们在这里的原因。所以还是从代码开始吧。在进行分割时，我们将图像转换为HSV图像。我们有BGR，我们的图像RGB编码，以类似的方式，我们有HSV编码。</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="4401" class="me kb hi ma b fi mf mg l mh mi">hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)</span></pre><p id="f840" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们将HSV图像传递给cv2.inRange函数，以获得分割的图像。这很简单</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="210c" class="me kb hi ma b fi mf mg l mh mi">seg_image= cv2.inRange(hsv, np.array([-10, 50, 100]), np.array([50, 150, 225]))<br/>cv2.imshow("segmentation", seg_image)</span></pre><p id="a3d6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们传递给函数的两个数组是什么？这些是最小和最大分割或阈值。但最重要的是，这些值是在HSV格式，而不是RGB或BGR格式。所以你会问我们如何得到HSV值。拯救你的另一个片段:</p><pre class="je jf jg jh fd lz ma mb mc aw md bi"><span id="9280" class="me kb hi ma b fi mf mg l mh mi">#get rgb values from here: https://imagecolorpicker.com/en<br/>rgbColor = np.uint8([[[92,113,165]]])<br/>hsvColor = cv2.cvtColor(rgbColor, cv2.COLOR_BGR2HSV)<br/><br/>upper = np.array([hsvColor[0][0][0] + 10, hsvColor[0][0][1] + 10, hsvColor[0][0][2] + 40])<br/>lower = np.array([hsvColor[0][0][0] - 10, hsvColor[0][0][1] - 10, hsvColor[0][0][2] - 40])</span></pre><p id="3654" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用这个<a class="ae ly" href="https://imagecolorpicker.com/en" rel="noopener ugc nofollow" target="_blank"> URL </a>获取图像部分的BGR值。如果你已经知道你的细分市场颜色的BGR值，你不需要这个网址。您将该值替换为[92，113，165](它是BGR而不是RGB)。代码的其余部分自动给出HSV中的最小值和最大值，这些值必须在inRange函数中使用。我已经使用了+-10，+-10，+-40来获得一些大概的最小值和最大值，但是你肯定要改变最终获得的HSV值来适应你的需要(<em class="lu">个人经验提示:</em>我从最小数组做-10，从所有最大数组做+10，看输出。如果分段是完美的，否则通过+或-10来更新值)。我再强调一下<strong class="ih hj"> <em class="lu">选择正确的阈值是这里最重要也是最棘手的部分，所以不要只满足于1个值，要多尝试。</em>T11】</strong></p><p id="9e6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦一切就绪，您将得到一个分段的图像，输出如下所示:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mp"><img src="../Images/fecc0b5bdc57f4c029a486f64ea44322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRi3q5lcNLxHUMQPcQ4BIQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">左:原始图像，右:分段图像</figcaption></figure></div><div class="ab cl jt ju gp jv" role="separator"><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy jz"/><span class="jw bw bk jx jy"/></div><div class="hb hc hd he hf"><h1 id="0943" class="ka kb hi bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">用哪个？</h1><p id="107e" class="pw-post-body-paragraph if ig hi ih b ii ky ik il im kz io ip iq la is it iu lb iw ix iy lc ja jb jc hb bi translated">如果你已经到达这里，你会想知道哪一个最适合你。在计算机视觉和深度学习中，永远没有确定的赢家。你尝试所有的方法，什么能给你带来最好的结果，你就去做吧。所以试一试，然后再决定。但是如果你认为你可以跳过计算机视觉中的图像二值化，事情很快就会变得很困难。</p></div></div>    
</body>
</html>