<html>
<head>
<title>Transfer learning</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迁移学习</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/transfer-learning-995134cc8cd3?source=collection_archive---------17-----------------------#2021-01-29">https://medium.com/analytics-vidhya/transfer-learning-995134cc8cd3?source=collection_archive---------17-----------------------#2021-01-29</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/4ab875b914d2c581217a75e7c4658576.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t3kZYBK6TNjwQkBT"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">凯利·西克玛在<a class="ae it" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上的照片</figcaption></figure><p id="7939" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">大家好。在这篇博客文章中，我们将了解迁移学习的概念。深度学习很牛逼。它为计算机视觉和物体检测/分类插上了翅膀。然而，我们需要大量的数据来训练一个好的检测模型，这可能并不容易获得。在这篇文章中，我将演示如何使用迁移学习在较少的数据上训练一个模型，并且仍然可以得到很好的结果。先说文章。</p><p id="4745" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">人类倾向于从一项任务中获取知识，并将其应用到另一项任务中。例如，从骑自行车中学到的知识被用来骑踏板车。</p><p id="4446" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">迁移学习是将从一项任务中获得的知识用于解决另一项任务的过程。在迁移学习中，我们使用别人为他们的问题创建的预先存在的模型，这些模型在各种GPU上训练了几周，并经历了痛苦的超参数优化。因此，通过使用迁移学习，我们可以通过使用预先存在的模型的权重来有效地初始化我们的模型，因此，它可以优化模型的性能。迁移学习可用于我们的问题只有小数据集的情况，我们使用在相对较大的数据集上训练的现有模型，从而获得良好的结果。</p><p id="00a5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有两种使用迁移学习的方法</p><p id="bebd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">a)特征提取器:-在这种方法中，我们冻结现有模型的所有层，并根据新任务替换最后一层(分类层)。</p><p id="338f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">b)微调:-在神经网络中，网络的较低层和中间层提取一般特征，而顶层特定于任务。在这种方法中，我们解冻模型的顶层，并联合训练分类器和模型的顶层，以便使它们与特定任务相关。</p><p id="6fba" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">迁移学习的实施</strong></p><p id="7e4a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">数据收集:- </strong></p><p id="8b26" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">为了进行实验，我从Kaggle下载了一个数据集(https://www . ka ggle . com/dans Becker/urban-and-rural-photos)。数据集分为训练集(城市和农村场景各36幅图像)和验证集(各10幅图像)。我们将在给定的问题中使用<strong class="iw hi"> ResNet-50 </strong>模型，实验在Google Colab上进行。</p><ol class=""><li id="774a" class="kb kc hh iw b ix iy jb jc jf kd jj ke jn kf jr kg kh ki kj bi translated"><strong class="iw hi">在Google drive中上传数据集，并在Google colab中安装驱动器</strong></li></ol><p id="5a4e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第一步是读取数据集。为此，我们将在Google drive中上传数据集，并在Google Colab中挂载该驱动器。安装驱动器的步骤如下所示:-</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kk"><img src="../Images/566e1f30b6415ed8ba9e25afc52cfeed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BC_MsUK0_LoCCoE40UtpJQ.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kp"><img src="../Images/a02a8dbaf2d6e6de2fbf3ae243a042f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fJWbhuEEXK6q2V8PGX-wOQ.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kq"><img src="../Images/64793b57b2d53491db97b0d9252e4fba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XFZBHCKA8IUxaX765UjwnA.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/86a7ede7a8f71f52f1d71ce204840470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BmoA1ODISMHHhExdDRPgVA.png"/></div></div></figure><p id="4664" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 2。模型构建</strong></p><p id="7e6a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">第二步是建模。这个问题用的是ResNet50型号。这里，weights='imagenet '由于我想用' imagenet '权重初始化模型，include_top=False以不包括模型中的最后一层。我在ResNet-50模型中添加了全局平均池和密集输出层。模型.层[0]。因为我们不想训练模型的第一层，所以可训练被设置为假。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ks"><img src="../Images/ea5fddeed818383b7ad4e7d9a71219df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ymNUxH008JOWiwqkYovoFg.png"/></div></div></figure><p id="a644" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 3。型号摘要</strong></p><p id="ddd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该模型的概要如下所示</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kt"><img src="../Images/4817ff8ebd7515b26bf55ae5eb567776.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*phCNea4VDTGHtydFBnK3sg.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ku"><img src="../Images/73f9bddd88b0b6338ccfa71d1aa1e8ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9feu74YdcEuSonf8B_50BQ.png"/></div></div></figure><p id="f7f9" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 4。编译模型</strong></p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kv"><img src="../Images/b948bea0d2ea397de63f32ad429d9f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4d96cnyIgJSoG4GeC0KyQ.png"/></div></div></figure><p id="1be1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这里，损失参数被指定为<strong class="iw hi">‘二元_交叉熵’</strong>。度量参数设置为<strong class="iw hi">“准确性”</strong>，最后我们使用<strong class="iw hi"> adam </strong>优化器来训练网络。</p><p id="24e2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 5。拟合模型</strong></p><p id="ca72" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">现在，我们已经准备好将图像传送到网络。这些图像从Google drive中读取并经过预处理。一旦我们训练了模型，我们可以可视化训练/验证的准确性和损失。所有训练/验证准确性和损失都存储在历史变量中。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kw"><img src="../Images/99d12af2ea5b7fac30d47b189b794cae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34QiER7EJCIsEJa76FI2Ew.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kx"><img src="../Images/2ceb21a959c284cf49848bac17b459d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RmsMKCwKa_akJw6-PWCv9w.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ky"><img src="../Images/96934bb74204baebd1dda48fab378058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOl6gj1cU009iFNJHFAtKA.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ky"><img src="../Images/bbff20e48a1903ebe0eb78d47e10ab5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uEAyZfWl2UJBeNh8fAhu6g.png"/></div></div></figure><p id="b6e3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 6。测试型号</strong></p><p id="93dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">验证集的准确率为85%。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kz"><img src="../Images/39502f6c892e7bf030449dd6eba397e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sdwy2d2lk58QeQxM9JtHgg.png"/></div></div></figure><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es la"><img src="../Images/96e5e5831c133cb695f1fb9255942ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bENlNG3rhMplIF2nxV64nA.png"/></div></div></figure><p id="1195" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi"> 7。绘制训练和验证损失和准确度图</strong></p><figure class="kl km kn ko fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es lb"><img src="../Images/9f7729c49a4a4a5b4d843cd76b74d6cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4Xb3jt2WWWSY5QHROVfQlg.png"/></div></div></figure><p id="5336" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在这里，我将使用matplotlib可视化训练/验证准确性和损失。</p><figure class="kl km kn ko fd ii er es paragraph-image"><div class="er es lc"><img src="../Images/17c967ccec215ebf575547374740b530.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*AGzEJ4Bnx6zZZ4Ikscu9gw.png"/></div></figure><p id="ed61" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">在上述实验中，我们对72幅图像进行了模型训练，取得了85%的准确率。</strong></p><p id="e394" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">非常感谢！</p><p id="f155" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">参考文献</strong></p><ul class=""><li id="dfc0" class="kb kc hh iw b ix iy jb jc jf kd jj ke jn kf jr ld kh ki kj bi translated">克拉斯</li><li id="4876" class="kb kc hh iw b ix le jb lf jf lg jj lh jn li jr ld kh ki kj bi translated">tensorflow.org</li><li id="c13d" class="kb kc hh iw b ix le jb lf jf lg jj lh jn li jr ld kh ki kj bi translated">machinelearningmastery.com</li></ul></div></div>    
</body>
</html>