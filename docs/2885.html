<html>
<head>
<title>HISTOGRAM EQUALIZATION</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">直方图均衡</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/histogram-equalization-4552f2ac1e8d?source=collection_archive---------10-----------------------#2021-05-22">https://medium.com/analytics-vidhya/histogram-equalization-4552f2ac1e8d?source=collection_archive---------10-----------------------#2021-05-22</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="b645" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上一个教程中，我们学习了图像处理中的直方图及其工作原理，这一次我们将升级并看看它在特征提取技术中的实现，以及这种简单的技术如何提升你的游戏！</p><p id="ba85" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">考虑下面的图像，该图像具有不规则的光照条件，这使得难以检测图像中的对象。因此，您可以应用一种称为直方图均衡化的简单技术来改善检测结果或改善此图像中的照明。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/a2d85ae3e2d33eebdad766b959954f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CO4V5u41u9Xt8Nxd"/></div></div></figure><p id="bf9b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看如何在python中做到这一点！让我们从导入这些包开始。如果您没有在下面的代码块<br/>中安装任何软件包，只需进入终端并键入<em class="jo"> pip install package-name。</em></p><pre class="jd je jf jg fd jp jq jr js aw jt bi"><span id="a9ba" class="ju jv hh jq b fi jw jx l jy jz">import cv2</span><span id="f060" class="ju jv hh jq b fi ka jx l jy jz">import argparse</span><span id="6c10" class="ju jv hh jq b fi ka jx l jy jz">import numpy as np</span><span id="55b9" class="ju jv hh jq b fi ka jx l jy jz">import matplotlib.pyplot as plt</span></pre><p id="2046" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">幸运的是，OpenCV为我们提供了默认的直方图均衡方法，你所要做的就是:</p><ol class=""><li id="f7da" class="kb kc hh ig b ih ii il im ip kd it ke ix kf jb kg kh ki kj bi translated">加载图像</li><li id="86ef" class="kb kc hh ig b ih kk il kl ip km it kn ix ko jb kg kh ki kj bi translated">将其转换为灰度</li><li id="c606" class="kb kc hh ig b ih kk il kl ip km it kn ix ko jb kg kh ki kj bi translated">应用<em class="jo">cv2 . equalize hist(gray _ scale _ image)</em></li></ol><p id="37b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看它的作用！</p><pre class="jd je jf jg fd jp jq jr js aw jt bi"><span id="d969" class="ju jv hh jq b fi jw jx l jy jz">ap = argparse.ArgumentParser()<br/>ap.add_argument('-i', '--image', required=True, help='image to be prcoessed')<br/>args = vars(ap.parse_args())</span><span id="3bd0" class="ju jv hh jq b fi ka jx l jy jz">image = cv2.imread(args['image'])<br/>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><span id="6b90" class="ju jv hh jq b fi ka jx l jy jz">equalized_image = cv2.equalizeHist(gray)</span><span id="81d1" class="ju jv hh jq b fi ka jx l jy jz">cv2.imshow("original gray", gray)<br/>cv2.imshow("Equalized image", equalized_image)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="ccae" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">结果是这样的:</p><div class="jd je jf jg fd ab cb"><figure class="kp jh kq kr ks kt ku paragraph-image"><img src="../Images/1f011aeb21e334175308bf2078526eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*uXytv8CuoNGtqdGd334Y-Q.jpeg"/></figure><figure class="kp jh kq kr ks kt ku paragraph-image"><img src="../Images/4db883840f5ab33bf0bbf28505ac0212.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*XcPv0sXOz5SY406HtxMuBQ.jpeg"/><figcaption class="kv kw et er es kx ky bd b be z dx kz di la lb translated">原始图像与均衡图像</figcaption></figure></div><p id="cc9d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，正如你所看到的，虽然我们可以看到背景中的物体，如右边看起来像“A”的物体，或者你现在可以清楚看到的椅子，或者壁炉顶部的物体，但一些噪声也被放大了！这是因为整个图像上的图像照明一次均衡，这过度放大了图像噪声，因此，为了解决这个问题，我们可以使用自适应直方图均衡，即逐块应用直方图均衡，也可以说逐窗口应用直方图均衡。</p><p id="dbf7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在这被称为CLAHE(对比度受限的自适应直方图均衡化)。</p><p id="6185" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是如何工作的:</p><p id="2b0c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">自适应直方图均衡化不是计算图像中的一个而是几个直方图，每个直方图属于图像的不同部分，并且使用这些直方图来重新分布该图像的照明条件。现在，这种方法提高了局部对比度，改善了边缘清晰度。</p><p id="901d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">然而，仅应用AHE实际上会过度放大图像中相对均匀区域的噪声。</p><p id="92a5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，正常的直方图均衡化在整个图像中使用单个变换函数，但是自适应直方图均衡化实际上在图像的每个局部邻域中使用不同类型的变换函数。<br/>该变换函数与邻域像素值的<em class="jo">累积分布函数(CDF) </em>成正比。<br/>现在，仅应用AHE，实际上会过度放大相对同质区域中的噪声，因此为了解决这个问题，CLAHE出现了:<br/>在CLAHE中，给定像素值附近的对比度放大由变换函数的斜率给出。<br/>现在这个变换函数与邻域累积分布函数(CDF)的斜率成正比。CLAHE通过在计算CDF之前将直方图削波到预定值来限制噪声的放大。这限制了CDF的斜率，从而限制了变换函数的斜率，进而限制了噪声的过度放大。</p><p id="3bd4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">一般来说，这个限幅值在3-5之间。</p><p id="50a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看实际情况！</p><pre class="jd je jf jg fd jp jq jr js aw jt bi"><span id="c551" class="ju jv hh jq b fi jw jx l jy jz">ap = argparse.ArgumentParser()<br/>ap.add_argument('-i', '--image', required=True, help='image to be processed')<br/>ap.add_argument('-c', '--clip', default=2.0, help='clip size for CLAHE')<br/>ap.add_argument('-t', '--tile', default=8, help='tile size for CLAHE')</span><span id="f1d3" class="ju jv hh jq b fi ka jx l jy jz">args = vars(ap.parse_args())</span></pre><p id="3359" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这里，剪辑是我们上面讨论过的剪辑限制，平铺是邻域大小，大小为8意味着我们将在(8×8)邻域中划分该图像。</p><pre class="jd je jf jg fd jp jq jr js aw jt bi"><span id="5a60" class="ju jv hh jq b fi jw jx l jy jz">image = cv2.imread(args['image'])<br/><br/>(b, g, r) = cv2.split(image)<br/>gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><span id="975e" class="ju jv hh jq b fi ka jx l jy jz">clahe = cv2.createCLAHE(<br/>    clipLimit=args['clip'], tileGridSize=(args['tile'], args['tile']))<br/>equalized_imageb = clahe.apply(b)<br/>equalized_imageg = clahe.apply(g)<br/>equalized_imager = clahe.apply(r)</span><span id="793c" class="ju jv hh jq b fi ka jx l jy jz">merged = cv2.merge([equalized_imageb, equalized_imageg, equalized_imager])</span><span id="5f62" class="ju jv hh jq b fi ka jx l jy jz">cv2.imshow(‘Original Image’, image)<br/>cv2.imshow(‘Equalized Image’, merged)<br/>cv2.waitKey(0)<br/>cv2.destroyAllWindows()</span></pre><p id="e1c8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在让我们看看结果，</p><div class="jd je jf jg fd ab cb"><figure class="kp jh kq kr ks kt ku paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><img src="../Images/c14c1a2ea55159a4a3eeb365b0dcbf33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*R5K1m8YFg9nCP9cLecCpag.jpeg"/></div></figure><figure class="kp jh kq kr ks kt ku paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><img src="../Images/9f9d377889f9ad6a06f240aee0a688a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*G_GXgSzxSOura6G-dBTswg.jpeg"/></div><figcaption class="kv kw et er es kx ky bd b be z dx kz di la lb translated">原始与均衡(CLAHE)</figcaption></figure></div><p id="20ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，在这两幅图像中，您可以看到，在均衡图像中，对比度实际上得到显著增强，这种方法通常会产生优势，同时执行某些计算机视觉任务。</p><p id="840b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你可以在这里找到完整的代码。</p><p id="c1e2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下次见，我们将讨论直方图匹配和颜色检测。</p><p id="0faa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">参考资料:</p><p id="78ec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae lc" href="https://www.pyimagesearch.com/" rel="noopener ugc nofollow" target="_blank">PyimageSearch.com</a>T10<a class="ae lc" href="https://en.wikipedia.org/wiki/Adaptive_histogram_equalization" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></div></div>    
</body>
</html>