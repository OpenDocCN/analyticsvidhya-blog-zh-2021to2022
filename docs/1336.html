<html>
<head>
<title>Mocking External APIs in Django</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Django中模仿外部API</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mocking-external-apis-in-django-4a2b1c9e3025?source=collection_archive---------5-----------------------#2021-02-24">https://medium.com/analytics-vidhya/mocking-external-apis-in-django-4a2b1c9e3025?source=collection_archive---------5-----------------------#2021-02-24</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><figure class="hh hi ez fb hj hk er es paragraph-image"><div role="button" tabindex="0" class="hl hm di hn bf ho"><div class="er es hg"><img src="../Images/d550e5580745b70202a919fac7a22178.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hBsmjgZPhtoyYL_Tik_bFg.jpeg"/></div></div><figcaption class="hr hs et er es ht hu bd b be z dx translated">照片由<a class="ae hv" href="https://unsplash.com/@kylejglenn?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">凯尔·格伦</a>在<a class="ae hv" href="https://unsplash.com/s/photos/does-not-exist?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><div class=""/><p id="cccf" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">您阅读的大多数文章和帖子都建议在运行您的测试时，使用</em> <code class="du ju jv jw jx b"><em class="jt">unitest</em></code> <em class="jt">库中的</em> <code class="du ju jv jw jx b"><em class="jt">Mock</em></code> <em class="jt">和</em> <code class="du ju jv jw jx b"><em class="jt">patch</em></code> <em class="jt">特性来模拟API调用。但是，如果您试图在本地机器或任何其他受控环境中手动测试流，该怎么办呢？</em></p><p id="b9e8" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在为web应用程序构建后端服务时，经常会遇到必须与外部服务集成并使用其API的情况。</p><h1 id="c579" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">设置场景</h1><p id="4596" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">考虑一个案例，我们正在构建一个电子商务应用程序。我们的应用程序旨在处理市场，我们必须与联邦快递等第三方服务集成，以处理运输和物流。</p><p id="b089" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设联邦快递服务为我们提供了2个API</p><ol class=""><li id="3c20" class="lb lc hy ix b iy iz jc jd jg ld jk le jo lf js lg lh li lj bi translated">创建发运API:创建新的发运订单。</li><li id="9e53" class="lb lc hy ix b iy lk jc ll jg lm jk ln jo lo js lg lh li lj bi translated">发运状态API:检查发运的状态。</li></ol><p id="4100" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">出于本文的考虑，我将假设我们使用适配器模式来构建与第三方服务的接口。因此，我们最终得到了一个服务类，它有两个方法，如下所示，这两个方法调用了联邦快递服务的实际API。</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="f729" class="lx jz hy jx b fi ly lz l ma mb">class FedexService:<br/>    """Service class for interfacing with FedEx Service."""</span><span id="b438" class="lx jz hy jx b fi mc lz l ma mb">    def create_shipment(self, shipment_details: dict):<br/>        """Create the shipment."""<br/>        # Call the API to create shipment<br/>    <br/>    def check_status(self, shipment_id: str):<br/>        """Check the status of the shipment by the id."""<br/>        # Call the API to check the status</span></pre><p id="06a1" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">然而，出于测试的目的，我们希望避免调用FedEx服务API，而是调用另一个实现相同方法的服务，但会返回一个预先确定的/受控的响应。</p><p id="08f3" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以实现如下所示的模拟服务</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="8cbb" class="lx jz hy jx b fi ly lz l ma mb">class MockShippingService:<br/>    """Mock service class for shipping."""</span><span id="f433" class="lx jz hy jx b fi mc lz l ma mb">    def create_shipment(self, shipment_details: dict):<br/>        """Create the shipment."""<br/>        return {<br/>            'shipping_id': str(uuid.uuid4()),<br/>            'created_at': datetime.datetime.isoformat(),<br/>            'charges': '100.10'<br/>        }<br/>    <br/>    def check_status(self, shipment_id: str):<br/>        """Check the status of the shipment by the id."""<br/>        return {<br/>            'status': 'delivered',<br/>            'updated_at': datetime.now().isoformat()<br/>        }</span></pre><h1 id="c4c5" class="jy jz hy bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">无缝切换的诀窍</h1><p id="1d46" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">一旦我们实现了实际的和模拟的服务类，剩下的唯一事情就是在需要时在这些类之间进行切换。其诀窍在于实现一个多路复用器:</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="66ca" class="lx jz hy jx b fi ly lz l ma mb">@apiplexer<br/>class ShippingService:<br/><br/>    api_settings = 'SHIPPING_SERVICE'</span></pre><p id="c485" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这个类充当接口，应用程序的其余部分使用它来调用运输服务。例如:</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="dcd9" class="lx jz hy jx b fi ly lz l ma mb">def create_shipment(self, order_details: dict):<br/>    """Create the shipment for the order."""<br/>    # Do something to create the shipment_details<br/>    shipment = ShippingService().create_shipment(shipment_details)<br/>    # Do something to handle the shipment</span></pre><p id="a921" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><code class="du ju jv jw jx b">apiplexer</code>装饰器是在服务类之间切换的关键。装饰器可以实现为:</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="fc01" class="lx jz hy jx b fi ly lz l ma mb">from django.conf import settings<br/>from django.utils.module_loading import import_string</span><span id="75d0" class="lx jz hy jx b fi mc lz l ma mb">def apiplexer(cls):<br/>    """Load the classes based on their names."""<br/>    return import_string(getattr(settings, cls.api_settings))</span></pre><p id="3897" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">那么实际的切换是如何工作的呢？为此，我们在设置文件中指定要使用的类。</p><p id="8fc4" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du ju jv jw jx b">settings/local.py</code>我们插入</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="ffd7" class="lx jz hy jx b fi ly lz l ma mb">SHIPPING_SERVICE = 'shipping.service.MockShippingService'</span></pre><p id="46c5" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<code class="du ju jv jw jx b">settings/production.py</code>中，我们添加了</p><pre class="lp lq lr ls fd lt jx lu lv aw lw bi"><span id="3414" class="lx jz hy jx b fi ly lz l ma mb">SHIPPING_SERVICE = 'shipping.service.FedexService'</span></pre><p id="27ba" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">当加载Django应用程序时，将根据该环境设置中提供的<code class="du ju jv jw jx b">SHIPPING_SERVICE</code>值导入要使用的适当运输服务类。</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><h1 id="5c45" class="jy jz hy bd ka kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv bi translated">随你便吧</h1><p id="93d1" class="pw-post-body-paragraph iv iw hy ix b iy kw ja jb jc kx je jf jg ky ji jj jk kz jm jn jo la jq jr js hb bi translated">根据传递给它的方法的值，<code class="du ju jv jw jx b">MockShippingService</code>可以进一步扩展以处理许多不同的情况。它可以返回带前缀的值；或者从数据库中获取和返回值，或者甚至调用一个模拟API服务器。</p><p id="90e2" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">使用这种方法的目的是有一种与第三方服务交互的方式，而不必实际与它通信。这使得在本地或分段环境中进行手动测试变得更加容易，只需要最少的外部依赖和资源。</p><p id="7ebd" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">开心嘲讽！</p></div><div class="ab cl md me gp mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="hb hc hd he hf"><p id="a91f" class="pw-post-body-paragraph iv iw hy ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="jt">感谢您的阅读。请在下面留下您的评论，告诉我们您是如何发现这篇文章有用的，或者您已经/将要如何以不同的方式或更好的方式实现这篇文章。干杯！</em></p></div></div>    
</body>
</html>