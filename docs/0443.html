<html>
<head>
<title>IOU (Intersection over Union)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">并集交集</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/iou-intersection-over-union-705a39e7acef?source=collection_archive---------0-----------------------#2021-01-17">https://medium.com/analytics-vidhya/iou-intersection-over-union-705a39e7acef?source=collection_archive---------0-----------------------#2021-01-17</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="28da" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">借据是什么，用在什么地方？</strong></p><ul class=""><li id="0069" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj"> IOU </strong>(交集超过并集)是一个用来描述两个盒子重叠程度的术语。重叠区域越大，IOU就越大。</li><li id="3ab2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">IOU主要用于与对象检测相关的应用中，在这些应用中，我们训练一个模型来输出一个完全适合对象的方框。例如在下图中，我们有一个绿色的盒子和一个蓝色的盒子。绿框代表正确的框，蓝框代表我们模型的预测。该模型的目的是不断改进其预测，直到蓝框和绿框完全重叠，即两个框之间的IOU等于1。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es jr"><img src="../Images/c99a525fa019f62ce3fe98e51e2c1d36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*VuAsK1Wwa_mOxW2nK2UovQ.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图13:对象检测任务的描述</figcaption></figure><ul class=""><li id="e1db" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">IOU也用于非最大抑制，用于根据哪个框具有更高的可信度来消除围绕同一对象的多个框。我将在下一篇文章中详细讨论非最大抑制。</li></ul><p id="ab74" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">计算欠条:</strong></p><p id="ca30" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">假设盒子1由[x1，y1，x2，y2]表示，盒子2由[x3，y3，x4，y4]表示。(我们稍后将使用这个约定来计算面积。)</p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kd"><img src="../Images/3a6926757ecaaec99b23a0dfabae84ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:718/format:webp/1*cNLP-dEczo7oXxEXLzAzQQ.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图1:两个盒子的交集</figcaption></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ke"><img src="../Images/d8d1ea84cc8334569f3b2a07d8c98b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*-yS1RREVZYbQLAyBEegcrQ.png"/></div></figure><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kf"><img src="../Images/4a8900d1e1f6c73557ce141ebbbe5113.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*r0o3vX-x979Q84_lbJWS_g.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图IOU计算公式的图示</figcaption></figure><ol class=""><li id="4f1c" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc kg jj jk jl bi translated"><strong class="ih hj">计算方框相交的面积</strong></li></ol><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kh"><img src="../Images/4bcd07b46949aafde52a8c649e87a01c.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*dgrpv4eygfybsijkvu06CQ.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图3:盒子可以以许多不同的方式相交，甚至完全相互重叠</figcaption></figure><ul class=""><li id="5051" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">让我们将相交矩形的坐标表示为<br/> [x_inter1，y_inter1，x_inter2，y_inter2 ]，以表示交叉点的左上和右下坐标。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ki"><img src="../Images/1783e5e2f54e1a9bd00dc154457e28b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:554/format:webp/1*OyWv2-kmXW5ZT8BMZLexrw.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图4:命名需要计算的坐标</figcaption></figure><ul class=""><li id="21ea" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">让我们从定义参考坐标系开始。我们使用计算机图形惯例，X轴向右移动，Y轴向下移动。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kj"><img src="../Images/bd80d5a469100af17818fd6cb68035b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:370/format:webp/1*sjUSZawTujR26QO2OjnmVg.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图5:参考坐标轴</figcaption></figure><ul class=""><li id="8f50" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">为了计算交叉点的左上角，我们比较每个方框的左上角。从上面的例子中我们可以看出，可以通过查看哪个盒子的左上角更靠右来找到<strong class="ih hj"> x_inter1 </strong>。类似地<strong class="ih hj"> y_inter1 </strong>可以通过查看哪个框的左上角比另一个低来找到。数学上，它们可以计算为:</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kk"><img src="../Images/f2eccd7e9f1541df8ee7437821d088ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:442/format:webp/1*XNolgIbbeCw3C_xX3ttXew.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图6:计算交叉点的左上角</figcaption></figure><ul class=""><li id="f3d8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">为了计算交叉点的右下角，我们比较每个方框的右下角。<strong class="ih hj"> x_inter2 </strong>可以通过查看哪个方框的右下角更靠左来找到。类似地<strong class="ih hj"> y_inter2 </strong>可以通过查看哪个盒子的右下角比另一个盒子高来找到。数学上，它们可以计算为:</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kl"><img src="../Images/49845704497ec133ab9b233e8b8a3b3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:436/format:webp/1*7VqDuCCWWY3Z6EajN3cwgQ.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图7:计算交叉点的底部右角</figcaption></figure><ul class=""><li id="0591" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">例如，图4中的框完全重叠，或者对于特定的坐标具有相同的值。在这种情况下，将一个值与其自身进行比较的最小值或最大值运算就是该值本身。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es km"><img src="../Images/91794a006773fc9c4f2f2c61d5d224cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:286/format:webp/1*NBop1PgOPl9AuF5LuxtTgg.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图8:比较具有相同坐标值的方框的例子</figcaption></figure><ul class=""><li id="2c48" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">现在我们有了交点的坐标，交点的面积就是所形成的矩形的面积。(在实践中，我们将取宽度和高度的模数，以确保即使盒子的顺序改变，宽度和高度仍然是正的；也就是说，如果x_inter1&gt;x_inter2，我们仍然会得到宽度的正值)</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kn"><img src="../Images/0122e98583051a4695be605c8c28b7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/format:webp/1*lStHBv9NJXpazBrxKDuQGA.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图8:计算交叉点的面积</figcaption></figure><p id="4bbe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">2.<strong class="ih hj">计算盒子并集的面积</strong></p><ul class=""><li id="aa79" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如图2所示，两个框的结合是两个框覆盖的总面积。</li><li id="bea1" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">为了计算总面积，我们首先计算各个盒子的面积。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ko"><img src="../Images/93be0e577c1fd84f8322d62e7788c641.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*1Ro5ToxRgQco5z3Tjj2LUg.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图9:计算两个盒子的面积</figcaption></figure><ul class=""><li id="7036" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">如果我们观察两个框所覆盖的总面积，我们会发现两个框都覆盖了相交的部分，即相交的面积同时包含在<strong class="ih hj"> area_box1 </strong>和<strong class="ih hj"> area_box2中。</strong></li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kp"><img src="../Images/4a5397d5914c7189c6bd51cd6b830ee1.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*aDM3JsjMNgZCwrjL9s3DZg.jpeg"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图10:描绘了两个框中覆盖的相交区域。</figcaption></figure><ul class=""><li id="f7b1" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">由于我们只想计算一次公共相交面积，所以我们可以从两个盒子的总面积中减去我们计算的相交面积。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kq"><img src="../Images/bbd635fdd04aa417e350c70a8191583d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*5yKBoxwgM1z6hU3FotsAWw.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图11:盒子联合的区域</figcaption></figure><p id="5ad5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">3.<strong class="ih hj">计算欠条</strong></p><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es kr"><img src="../Images/22102858794d226c86d75252bccab286.png" data-original-src="https://miro.medium.com/v2/resize:fit:364/format:webp/1*hStjEFR6573ocDAthW4NUw.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图12:计算IOU的公式</figcaption></figure><p id="043c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">借据可以有哪些取值范围？</strong></p><ul class=""><li id="aff2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">两个盒子的IOU可以有0到1之间的任何值。</li><li id="0fa2" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果有两个盒子不相交，它们相交的面积将是0，因此IOU也将是0。</li><li id="ee38" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如果有两个盒子完全重叠，那么交集的面积将等于并集的面积，因此IOU将为1。</li></ul><p id="5b8f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">用python编写IOU函数:</strong></p><ul class=""><li id="04d2" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">对于上面显示的同一幅图像，让我们用python编写一个函数来计算绿色和蓝色方框的IOU。</li></ul><figure class="js jt ju jv fd jw er es paragraph-image"><div class="er es ks"><img src="../Images/c619e6236a811be3b9f8d103a1267b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:910/format:webp/1*QIp7ueG_EVH8AAKJWR-Mnw.png"/></div><figcaption class="jz ka et er es kb kc bd b be z dx translated">图14:python中实现IOU的函数</figcaption></figure><ul class=""><li id="6b0e" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">函数IOU接受两个框，即框1和框2作为输入。每个框中的数据是一个包含[x1，y1，x2，y2]的列表，它是左上角和右下角的坐标。</li><li id="994e" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">如前所述，我们先求出交集的面积，然后求出并集的面积。</li><li id="8eb0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">abs函数是python中的内置函数，用于计算模数。这确保我们永远不会以负的宽度或高度结束。</li><li id="81ea" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">返回的IOU是float类型的值，介于0和1之间。</li><li id="d0cc" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">我写了一个代码，可以让我们看到在借据上改变边框的效果。完整代码的链接是<a class="ae kt" href="https://github.com/vineeth2309/IOU" rel="noopener ugc nofollow" target="_blank">这里是</a></li></ul></div></div>    
</body>
</html>