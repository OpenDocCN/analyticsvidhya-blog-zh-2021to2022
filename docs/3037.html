<html>
<head>
<title>Data Warehouse — Separation of Cloud and Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据仓库—云和存储的分离</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/data-warehouse-separation-of-cloud-and-storage-85a7b92415a6?source=collection_archive---------14-----------------------#2021-05-30">https://medium.com/analytics-vidhya/data-warehouse-separation-of-cloud-and-storage-85a7b92415a6?source=collection_archive---------14-----------------------#2021-05-30</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="566c" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">越来越需要云数据仓库来分离计算和存储。有些数据库还处于云托管阶段，只是把原来的架构迁移到云主机上，利用云资源。一些数据库已经进入云原生阶段，基于云平台IAAS层的基础设施，构建弹性、无服务器、数据共享等能力。</p><p id="286b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">分离存储和计算资源的优势在于，您可以独立规划存储和计算资源的规格和容量。这样计算资源的扩充、缩减、释放都可以相对较快的完成，并且不会带来额外的数据重定位成本。存储和计算也可以更好地结合各自的特点，选择更适合自己的资源规格和设计。</p><h2 id="229a" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">让我们看看阿里云的原生数据仓库AnalyticDB MySQL，因为它在过去几年中增强了灵活性。</h2><p id="c9c6" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">AnalyticDB最初是基于AWS RedShift这样的传统大规模并行处理(MPP)架构构建的。最近，AnalyticDB推出了一种灵活的模型，具有独立的计算和存储架构。AnalyticDB弹性模型分为访问层、计算层和存储层。访问层兼容MySQL协议，包括访问控制、优化器、元数据、查询调度等模块，负责实时数据写入和查询。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es kc"><img src="../Images/052dee6078941ba23b61a487529659f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*40T-u54j7j3je0HSUqrUbw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">分析数据库当前架构</figcaption></figure><h2 id="3d33" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">存储层</h2><p id="2777" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在弹性架构下，存储层负责实时数据写入、索引构建、数据扫描、下推谓词计算(过滤、列裁剪、分区裁剪等。)，并且不再负责查询计算任务。存储层中的数据仍然由MPP组织。</p><p id="0ff8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据以散列和随机的方式均匀分布在分区(碎片)中。分片方法可以轻松实现实时数据写入的强一致性。扫描时可以实现分片级并发读取，保证并发。同时，存储层提供集成的冷、热分层存储能力。</p><p id="4484" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据可以以热表的形式存储在本地SSD中，以冷表的形式存储在底层DFS中，或者以冷热混合表的形式存储来实现冷热数据自动迁移的实现，详见文章《数据仓库分层存储技术的秘密》。</p><h2 id="d1d5" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">计算层</h2><p id="2cbb" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在柔性模式下，计算层由若干个计算节点组成，计算节点负责接收接入层下发的物理执行计划，并根据物理执行计划转换成相应的操作符。</p><p id="3768" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">计算层采用矢量化执行模型，操作符之间的数据以流水线方式交互。几行(一般几千行)数据组成一个批次，批次内部数据以列存储的形式组织。</p><p id="d9d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，根据查询计划动态生成代码以加快计算速度，包括表达式计算、排序和类型比较。将规划好的模式作为缓存动态生成代码的关键，从而降低交互查询下动态生成代码的成本。</p><h2 id="6cc6" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">执行计划</h2><p id="3c1e" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">由于计算和存储容易分离，因此可以在计算层添加一个新的重散列操作符。操作员负责从存储层加载数据。在批处理和列存储中，数据在存储层和计算层之间传输。单个请求会传输多批数据，一般不大于32MB。</p><p id="5af2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于存储层仍然保留MPP数据预分区方法，优化器将在生成执行计划时，基于此分布特性减少连接和聚合操作期间不必要的数据重新分区。</p><p id="3212" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">此外，优化器还会确定查询中的过滤器是否可以使用存储层索引，并尝试将存储层可以识别的过滤器下推到存储层并使用索引来加速过滤，减少与计算层的数据传输。不能下推的过滤器留在计算层进行过滤。</p><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es ks"><img src="../Images/0043fb980b494704c64901724d630f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8qlJx_mZoA1ognXfQhQ7g.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">执行计划示例</figcaption></figure><h2 id="e2da" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">数据加载优化</h2><p id="bb26" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">计算和存储的分离相比原来的架构多了一个远程数据访问，会对查询的延迟和吞吐量产生更大的影响。</p><ul class=""><li id="8781" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">通过合并连接，减少了小数据查询的网络交互次数，并减少了查询延迟。</li><li id="1268" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">批量数据基于列存储格式进行压缩，减少了网络带宽的消耗，有效提高了重散列算子的加载吞吐量。</li><li id="23fc" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">网络模块异步加载，将数据放入缓冲区，重共享操作符从缓冲区获取数据，这样CPU和网络IO完全并行。</li></ul><h2 id="313e" class="jc jd hh bd je jf jg jh ji jj jk jl jm ip jn jo jp it jq jr js ix jt ju jv jw bi translated">动态分区重新分配</h2><p id="f0e1" class="pw-post-body-paragraph ie if hh ig b ih jx ij ik il jy in io ip jz ir is it ka iv iw ix kb iz ja jb ha bi translated">在重排操作符和扫描操作符之间，碎片根据以下原则重新分配:</p><ul class=""><li id="425f" class="kt ku hh ig b ih ii il im ip kv it kw ix kx jb ky kz la lb bi translated">来自同一存储节点的多个分区应该尽可能分散到不同的计算节点。</li><li id="a9fc" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在同一查询中，不同表的相同分区将被映射到同一计算节点。</li><li id="37e8" class="kt ku hh ig b ih lc il ld ip le it lf ix lg jb ky kz la lb bi translated">在不同的查询之间，相同的分区被随机分配给不同的计算节点。</li></ul><figure class="kd ke kf kg fd kh er es paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="er es lh"><img src="../Images/8fbe0eeb9d361b217d563497c6970bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pajcgmcXYnv2o42Q.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">再射击演示</figcaption></figure><p id="82f4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">与雪花和红移不同，计算节点和分区之间没有固定的映射关系</strong>，因为计算节点没有本地缓存，数据访问的加速完全依赖于存储层的SDD和内存缓存。这种动态再分配方式可以大大缓解分区不均匀、分区内数据偏斜等问题，并且不会对固定计算节点造成热点。</p><p id="e70f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">从阿里云Native AnalyticDB的例子可以看出，计算资源池、按需弹性功能有更大的机会，使企业能够大幅扩展和缩减。共享存储可以独立于计算层扩展其功能。通过这些弹性能力，可以更好地满足客户对云数据仓库的需求，进一步降低客户的使用成本。展望云数据仓库技术的未来发展。</p><blockquote class="li lj lk"><p id="1a31" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">R <!-- -->引用</p><p id="c12c" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">雪花<a class="ae lp" href="https://www.snowflake.com/" rel="noopener ugc nofollow" target="_blank">https://www.snowflake.com/</a></p><p id="1a4c" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">雪花vs红移<a class="ae lp" href="https://levelup.gitconnected.com/snowflake-vs-redshift-ra3-the-need-for-more-than-just-speed-52e954242715" rel="noopener ugc nofollow" target="_blank">https://level up . git connected . com/雪花vs红移-ra3-the-need-for-than-just-speed-52e 954242715</a></p><p id="7ca5" class="ie if ll ig b ih ii ij ik il im in io lm iq ir is ln iu iv iw lo iy iz ja jb ha bi translated">data bricks<a class="ae lp" href="https://databricks.com/session/taking-advantage-of-a-disaggregated-storage-and-compute-architecture" rel="noopener ugc nofollow" target="_blank">https://data bricks . com/session/taking-advantage-a-decomposited-storage-and-compute-architecture</a></p></blockquote></div></div>    
</body>
</html>