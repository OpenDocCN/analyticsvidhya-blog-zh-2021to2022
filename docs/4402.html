<html>
<head>
<title>Type Classes for ad-hoc Polymorphism in Scala</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala中特定多态性的类型类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/type-classes-for-ad-hoc-polymorphism-in-scala-70ec31d0265d?source=collection_archive---------7-----------------------#2021-10-05">https://medium.com/analytics-vidhya/type-classes-for-ad-hoc-polymorphism-in-scala-70ec31d0265d?source=collection_archive---------7-----------------------#2021-10-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/a78b20aa6c66fcbd1661312e0a27c236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ylDP4SUvy1dgqVVUcheyXA.jpeg"/></div></div></figure><p id="7fa9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Scala有一套丰富的多态技术，通过使用<strong class="is hj">特征</strong>、<strong class="is hj">抽象类、</strong>，当然，有时还会使用<strong class="is hj"> case对象</strong>和<strong class="is hj"> case类</strong>，来实现代码的可重用性。</p><p id="6651" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">假设我们希望基于我们操作的类型实现equals(自定义equals方法)的通用功能，这可以是<strong class="is hj"> Int </strong>、<strong class="is hj"> Double </strong>、<strong class="is hj"> Person(case class) </strong>，或者scala生态系统中的任何其他类型以及用户定义的类型。</p><p id="950b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">我们能想到的一个解决方案是创建泛型代码块并对其进行操作，但这里的问题是，对于每种类型，我们可能最终会有n个对象创建来实现equals方法的功能。我们希望实现这样一个目标:只有一个对象被引用来操作不同的类型</p><p id="1d2b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这里的问题是我们如何实现这一目标？T25】</p><blockquote class="jp jq jr"><p id="020b" class="iq ir jo is b it iu iv iw ix iy iz ja js jc jd je jt jg jh ji ju jk jl jm jn hb bi translated">这就是类型类概念可以拯救我们的地方，我们经常称之为特别多态</p></blockquote><p id="951d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们可以跳转来解决这个问题，下面是我们尝试实现<code class="du jv jw jx jy b">isEqual</code>方法的简单方法。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="ee2f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在我们已经准备好了包含isEqual方法的trait，我们将看到如何进一步扩展它，以利用类型类和特别多态性的功能。</p><p id="84c8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">但在此之前，让我给隐式的一行程序，这是理解整个概念的先决条件:</p><p id="daab" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果你想让编译器替你做出决定，来推断被标记为使用隐式的代码块的底层执行的值，隐式就扮演了一个重要的角色。</p><p id="d4c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们为上面的trait创建一个伴随对象，并使用implicit来实例化<code class="du jv jw jx jy b">trait Equality[T]</code>的对象。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="0e32" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们看到上面的代码片段，我们可以看到，为了实现第2行的<code class="du jv jw jx jy b">def isEqual[T]</code>的功能，我们将传递的值调用到隐式等式对象<code class="du jv jw jx jy b">(implicit equality:Equality[T]</code>的isEqual。</p><p id="3d58" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">现在让我们看看如何使用这个伴随对象来覆盖不同类型的isEqual方法。首先，我们来看看<code class="du jv jw jx jy b">Int</code></p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="d2a1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">好的，我们正在扩展并利用隐式对象，这样在运行时编译器将决定并选择合适的助手对象来推断实际的实现，我们也在扩展<code class="du jv jw jx jy b">Equality[Int]</code>，我们可以用类似的方式为其他类型和实现做这件事，这完全与我们无关。</p><p id="bbc6" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果我们想检查一个用户定义的类型，可能是用户类，我们可以这样做。</p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="b70c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">以上是仅基于年龄的平等，我们可以说这里我们只关心年龄平等。</p><p id="40a3" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">关于代码有很多讨论，但最后的问题是我们应该引用哪个主要对象调用isEqual，答案是<code class="du jv jw jx jy b">Equality.isEqual(...)</code></p><figure class="jz ka kb kc fd ij"><div class="bz dy l di"><div class="kd ke l"/></div></figure><p id="bf86" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">因此，如果我们注意到，基于我们传递到<code class="du jv jw jx jy b">Equality</code>的<code class="du jv jw jx jy b">isEqual</code>中的类型，对象试图在运行时找到并执行底层逻辑，这也是1、2进入<code class="du jv jw jx jy b">IntEquality</code>而第二个进入<code class="du jv jw jx jy b">UseEqualilty</code>块的原因。</p><p id="90e0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">希望这有所帮助:)<br/>完整的代码可以在<a class="ae kf" href="https://gist.github.com/amitprasad119/cfac1a84aab7e7c563fc3ab55b4e6454" rel="noopener ugc nofollow" target="_blank">这里找到</a></p></div></div>    
</body>
</html>