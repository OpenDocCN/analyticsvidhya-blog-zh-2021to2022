<html>
<head>
<title>Use Oscillator of RSI to predict Stock Return (accuracy over 70%!)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用RSI的振荡指标预测股票收益(准确率70%以上！)</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/use-oscillator-of-rsi-in-machine-learning-prediction-of-stock-return-8de6b9543315?source=collection_archive---------5-----------------------#2021-01-20">https://medium.com/analytics-vidhya/use-oscillator-of-rsi-in-machine-learning-prediction-of-stock-return-8de6b9543315?source=collection_archive---------5-----------------------#2021-01-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="000a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">刚从<a class="ae jc" rel="noopener" href="/swlh/the-oscillator-of-moving-average-coding-and-using-it-in-trading-73e0f9bde1cc">帖</a>学了均线(OsMA)和RSI的震荡器。RSI是趋势和动量的有用指标。受此启发，我想尝试使用它作为机器学习功能来预测未来的股票回报。</p><h1 id="e55d" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">RSI及其OsMA的计算</h1><p id="336b" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">相对强度(RS)和相对强度指标(RSI)可以通过历史正价差(%)的移动平均线(MA)除以负价差(%)的移动平均线(MA)来计算。</p><blockquote class="kg kh ki"><p id="3f5f" class="ie if kj ig b ih ii ij ik il im in io kk iq ir is kl iu iv iw km iy iz ja jb ha bi translated">RS =(正差MA)/(负差MA)</p><p id="39b4" class="ie if kj ig b ih ii ij ik il im in io kk iq ir is kl iu iv iw km iy iz ja jb ha bi translated">RSI = 100–100/(1+RS)</p></blockquote><p id="2bed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是Julia的计算代码。我们使用<a class="ae jc" href="https://juliastats.org/TimeSeries.jl/latest/" rel="noopener ugc nofollow" target="_blank"> Julia包时间序列</a>。</p><ul class=""><li id="e85a" class="kn ko hh ig b ih ii il im ip kp it kq ix kr jb ks kt ku kv bi translated">percentchange(price_ts)是计算lag-1价格的价格差异百分比的函数。</li><li id="f776" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">时间序列“涨”和“跌”是通过设置相反符号值0而产生的正价差(%)和负价差(%)。</li><li id="3349" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">up_roll和down_roll是“回环”期间正差和负差的移动平均值。</li><li id="71b9" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">f_rsi是应用于时间序列的每个元素的函数，用于计算RSI = 100-(100/1+向上滚动/向下滚动)</li><li id="812c" class="kn ko hh ig b ih kw il kx ip ky it kz ix la jb ks kt ku kv bi translated">TimeSeries.map用于对时间序列的每个元素应用函数f_rsi。对于时序操作，通常使用映射函数而不是循环。</li></ul><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="dc6f" class="lk je hh lg b fi ll lm l ln lo">using TimeSeries<br/>function toRSI(price_ts,loopback)<br/>    pct = percentchange(price_ts)<br/>    upidx = findall(pct["Close"] .&gt; 0)<br/>    downidx = findall(pct["Close"] .&lt; 0)<br/>    up = map( (timestamp, values) -&gt; (timestamp, if values &lt; 0 ; 0 ; else ;values ;end), pct)<br/>    down = map( (timestamp, values) -&gt; (timestamp, if values &lt; 0 ; abs(values) ; else ;0 ;end), pct)<br/>    up_roll = moving(mean, up, loopback)<br/>    down_roll = moving(mean, down, loopback)<br/>    function f_rsi(values)<br/>        x = values[1]<br/>        y = values[2]<br/>        rsi = 100 - (100 / (1 + x/y) )<br/>        [rsi,0]<br/>    end<br/>    updown = TimeSeries.rename(TimeSeries.merge(up_roll,down_roll), [:up,:down])<br/>    rsi_ts = TimeSeries.rename(TimeSeries.map((timestamp, values) -&gt; (timestamp, f_rsi(values)), updown)[:up],Symbol("RSI-",loopback))<br/>    return rsi_ts<br/>end</span></pre><p id="51ba" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">RSI的移动平均值可以很容易地通过函数“移动(平均值…)”来计算。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="68d3" class="lk je hh lg b fi ll lm l ln lo">rsi_ma = TimeSeries.rename(moving(mean,rsi_ts,j),Symbol("RSIMA-",i,"-",j))</span></pre><h1 id="25ff" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">特征工程</h1><p id="9493" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">RSI的移动平均值的振荡器(OsRSI)可以用作模型特征。对于每个OsRSI计算，有2个移动平均线:(1)在<em class="kj">向上滚动</em>和<em class="kj">向下滚动</em>的计算中的均线，和(2)RSI的均线。对于每个毫安，我们需要指定回送周期，设其为<em class="kj"> i </em>和<em class="kj"> j，</em>，定义如下:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="b4bf" class="lk je hh lg b fi ll lm l ln lo">rsi_ts = toRSI(price_ts,i)<br/>rsi_ma = moving(mean,rsi_ts,j)</span><span id="1ff2" class="lk je hh lg b fi lp lm l ln lo">orsi = rsi_ts .- rsi_ma</span></pre><p id="c622" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">借助计算机自动化的杠杆作用，我们可以在一个范围内循环使用<em class="kj"> i </em>和<em class="kj"> j </em>的值，而不是在分析中仅基于回送的单个值。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="ba1c" class="lk je hh lg b fi ll lm l ln lo">for i in day0:day1<br/>        rsi_ts = toRSI(price_ts,i)<br/>        result_rsi = merge(result_rsi,rsi_ts,method=:inner)<br/>        for j in day0:day1<br/>            rsi_ma = TimeSeries.rename(moving(mean,rsi_ts,j),Symbol("RSIMA-",i,"-",j))<br/>            orsi = TimeSeries.rename(rsi_ts .- rsi_ma , Symbol("ORSI-",i,"-",j) )<br/>            result_orsi = merge(result_orsi,orsi,method=:inner)<br/>        end<br/>    end</span></pre><p id="e8bb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">所有这些<em class="kj"> OsRMI(i，j) </em>会形成一个矩阵。该矩阵可以被馈送到卷积神经网络(CNN)用于模式识别。我使用当天和之前(<em class="kj"> seqlen </em>)天的OsRSI矩阵来形成矩阵序列，作为CNN层的输入。然后，叠加2-GRU，最后的密集层，得到第二天的预测收益率。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="88d0" class="lk je hh lg b fi ll lm l ln lo">function build_reg_model(Nh,seqlen)<br/>    a = floor(Int8,Nh)<br/>    return Chain(<br/>    x -&gt; Flux.unsqueeze(x,4),<br/># First convolution<br/>    Conv((2, 2), seqlen=&gt;a, pad=(1,1), relu),<br/>    MaxPool((2,2)),</span><span id="dcb0" class="lk je hh lg b fi lp lm l ln lo"># Second convolution<br/>    Conv((2, 2), a=&gt;Nh, pad=(1,1), relu),<br/>    MaxPool((2,2)),</span><span id="788a" class="lk je hh lg b fi lp lm l ln lo"># Third convolution<br/>    Conv((2, 2), Nh=&gt;Nh, pad=(1,1), relu),<br/>    MaxPool((2,2)),</span><span id="4552" class="lk je hh lg b fi lp lm l ln lo">    Flux.flatten,<br/>    Dropout(0.1),<br/>    (x-&gt;transpose(x)),</span><span id="1a3d" class="lk je hh lg b fi lp lm l ln lo">    GRU(1,Nh),<br/>    GRU(Nh,Nh),<br/>    (x -&gt; x[:,end]),<br/>    Dense(Nh, 1),<br/>    (x -&gt; x[1])<br/>    )<br/>end</span></pre><p id="dda1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">与我之前的<a class="ae jc" href="https://iwasnothing.medium.com/time-series-prediction-feat-introduction-of-julia-78ed6897910c" rel="noopener">帖子</a>类似，为了平滑波动，我使用收盘价收益率的5天移动平均值作为目标变量。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="6e18" class="lk je hh lg b fi ll lm l ln lo">function toReturn(price_ts)<br/>    pct = TimeSeries.rename(percentchange(price_ts),[:return])<br/>    pct = moving(mean,pct,5)<br/>    return TimeSeries.map((timestamp, values) -&gt; (timestamp, 100*values), pct)<br/>end</span></pre><h1 id="61a6" class="jd je hh bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结果评估</h1><p id="de2d" class="pw-post-body-paragraph ie if hh ig b ih kb ij ik il kc in io ip kd ir is it ke iv iw ix kf iz ja jb ha bi translated">我用2840.HK 3年的数据进行训练和测试。我拿出最后150个看不见的数据点进行测试。训练的周期数是25。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f7e3" class="lk je hh lg b fi ll lm l ln lo"><a class="ae jc" href="http://twitter.com/epochs" rel="noopener ugc nofollow" target="_blank">@epochs</a> num_epoch Flux.train!(mse_loss,Flux.params(m),train_loader,RMSProp(lr,mm))</span></pre><p id="fe2a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这是红线预测值(y1)和蓝线实际值(y2)的曲线图。</p><figure class="lb lc ld le fd lr er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lq"><img src="../Images/818e37eb37ab0e87fd44212f4824d9b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wJegf7U3CJHgFSF7-DHF-A.png"/></div></div></figure><p id="58b9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在实际交易中，预测上涨或下跌(正/负回报)的准确性在损益中比值的实际拟合更关键。我还计算了准确度和混淆矩阵。准确率77%！这比我以前的型号要好。</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="0905" class="lk je hh lg b fi ll lm l ln lo">accuracy:0.77</span><span id="8a0f" class="lk je hh lg b fi lp lm l ln lo">Confusion Matrix:<br/>[0.27, 0.093]<br/>[0.13, 0.5]</span></pre><p id="2336" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">以下是上述测试运行的超参数:</p><pre class="lb lc ld le fd lf lg lh li aw lj bi"><span id="f4e8" class="lk je hh lg b fi ll lm l ln lo">seqlen=8<br/>Nh=20<br/>lr=0.000129<br/>mm=0.75<br/>day0=8<br/>day1=8+20</span></pre><p id="15b7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">总之，OsRSI在股票预测中是一个很好的特征。完整的Julia笔记本可以在我的<a class="ae jc" href="https://github.com/iwasnothing/JuliaConvGRU/blob/main/OsRSI.ipynb" rel="noopener ugc nofollow" target="_blank"> Github </a>中找到。</p></div></div>    
</body>
</html>