<html>
<head>
<title>Plant Disease Detection Using Convolutional Neural Networks with PyTorch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于PyTorch卷积神经网络的植物病害检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/plant-disease-detection-using-convolutional-neural-networks-and-pytorch-87c00c54c88f?source=collection_archive---------2-----------------------#2021-03-17">https://medium.com/analytics-vidhya/plant-disease-detection-using-convolutional-neural-networks-and-pytorch-87c00c54c88f?source=collection_archive---------2-----------------------#2021-03-17</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="a26e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">机器学习、深度学习、人工智能是未来。我们几乎在每个领域都使用这些技术。在农业领域，我们还可以将这项技术用于整地、添加肥料、播种、灌溉、杂草保护、收获、疾病预测等。</p><p id="6ef7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">阅读全文博客<a class="ae jc" href="http://analyticsvidhya.com/blog/2020/11/artificial-intelligence-in-agriculture-using-modern-day-ai-to-solve-traditional-farming-problems/#:~:text=Precision%20Farming%20and%20Predictive%20Analytics,be%20grown%2C%20optimum%20planting%2C%20pest" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">艾在农。</strong>T3】</a></p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/80a5749b8a73fee22f47cfe37414131a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFa8Fg7n_JYX7fiHGS2lUg.jpeg"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">学分:Unsplash</figcaption></figure><blockquote class="jt ju jv"><p id="3d74" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">概述:</strong></p></blockquote><p id="64a2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们正在使用深度学习来基于植物叶子的图像进行植物疾病检测。我们使用深度学习来完成这项任务，因为我们正在处理图像数据。深度学习有一个卷积神经网络，用于从植物的叶子中寻找特征。</p><blockquote class="jt ju jv"><p id="5a90" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">先决条件:</strong></p></blockquote><p id="1ed5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">PyTorch</p><p id="a13d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">卷积神经网络</p><p id="df05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从这里学习py torch:</strong></p><p id="15b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(1)阿拉丁人Youtube播放列表</p><p id="0c02" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(2) <a class="ae jc" href="https://www.youtube.com/watch?v=EMXfZB8FVUA&amp;list=PLqnslRFeH2UrcDBWF5mfPGpqQDSta6VK4" rel="noopener ugc nofollow" target="_blank"> Python工程师Youtube播放列表</a></p><p id="e4a9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">从这里学习CNN:</strong></p><p id="080f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(1) <a class="ae jc" href="https://www.youtube.com/watch?v=YRhxdVk_sIs" rel="noopener ugc nofollow" target="_blank">由Deeplizard解释的卷积神经网络</a></p><p id="0a44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(2) <a class="ae jc" href="https://www.youtube.com/watch?v=zfiSAzpy9NM" rel="noopener ugc nofollow" target="_blank">用CodeBasics简单解释卷积神经网络</a></p><blockquote class="jt ju jv"><p id="5771" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">数据集:</strong></p></blockquote><p id="2450" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个数据集中，有39种不同种类的植物叶片和背景图像。该数据集包含61，486幅图像。我们使用了六种不同的扩充技术来增加数据集的大小。这些技术是图像翻转、伽马校正、噪声注入、PCA颜色增强、旋转和缩放。</p><p id="fb92" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们必须使用CNN模型来预测总共39个类别。</p><p id="ff58" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://data.mendeley.com/datasets/tywbtsjrjv/1" rel="noopener ugc nofollow" target="_blank"> <strong class="ig hi">下载数据集。</strong> </a> <strong class="ig hi"> </strong> ( <em class="jw">植物村数据集</em>)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ka"><img src="../Images/7971fd4735ffd54167e2b54c981bd8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*imREJgan5SXx30gZ_gEm5Q.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><strong class="bd kb">演职员表:</strong>T30】https://www.crowdai.org/challenges/1</figcaption></figure><blockquote class="jt ju jv"><p id="5d2c" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">代码实现:</strong></p></blockquote><p id="6d9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">导入依赖关系:</strong></p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="2673" class="kh ki hh kd b fi kj kk l kl km"># General<br/>import numpy as np<br/>import pandas as pd<br/>import matplotlib.pyplot as plt</span><span id="6011" class="kh ki hh kd b fi kn kk l kl km"># Torch<br/>import torch<br/>from torchvision import datasets, transforms # datsets  , transforms<br/>from torch.utils.data.sampler import SubsetRandomSampler<br/>import torch.nn as nn<br/>import torch.nn.functional as F<br/>from datetime import datetime</span></pre><p id="a336" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">变换用于数据扩充，如裁剪图像、调整图像大小、将图像转换为张量、旋转图像等等。变换充当所有图像的过滤器。我们使用下面的代码来转换图像。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="307d" class="kh ki hh kd b fi kj kk l kl km">transform = transforms.Compose(<br/>    [transforms.Resize(255), transforms.CenterCrop(224), transforms.ToTensor()]<br/>)</span></pre><p id="2637" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">datasets类用于创建或导入数据集。在数据集方面，它有许多著名的数据集，如MNIST，CIFAR-10，CIFAR-100，KMNIST等。</p><p id="ba18" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">点击查看所有数据集列表<a class="ae jc" href="https://pytorch.org/vision/stable/datasets.html" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="4192" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用数据集从图像中创建我们自己的数据集，为此我们从数据集使用ImageFolder方法。</p><p id="099e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我存储所有图像的文件夹名为“数据集”。我们还将变换应用于所有图像。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="56d6" class="kh ki hh kd b fi kj kk l kl km">dataset = datasets.ImageFolder("Dataset", transform=transform)</span></pre><p id="266e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">列车试运行:</strong></p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="d71d" class="kh ki hh kd b fi kj kk l kl km">indices = list(range(len(dataset)))</span><span id="0a15" class="kh ki hh kd b fi kn kk l kl km">split = int(np.floor(0.85 * len(dataset)))  # train_size</span><span id="a929" class="kh ki hh kd b fi kn kk l kl km">validation = int(np.floor(0.70 * split))  # validation</span><span id="cb29" class="kh ki hh kd b fi kn kk l kl km">np.random.shuffle(indices)</span><span id="8a4a" class="kh ki hh kd b fi kn kk l kl km">train_indices, validation_indices, test_indices = (<br/>    indices[:validation],<br/>    indices[validation:split],<br/>    indices[split:],<br/>)</span></pre><p id="f258" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在上面的代码中，我们首先获取索引，然后将数据分为训练、测试和验证数据。总共36584个用于训练，15679个用于验证，其余图像用于测试。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="151f" class="kh ki hh kd b fi kj kk l kl km">train_sampler = SubsetRandomSampler(train_indices)<br/>validation_sampler = SubsetRandomSampler(validation_indices)<br/>test_sampler = SubsetRandomSampler(test_indices)</span></pre><p id="d07e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">SubsetRandomSampler用于对我们的数据进行采样。在这里，我们创建一个SubsetRandomSampler对象，稍后我们将在训练数据加载器和测试数据加载器中使用此采样器。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="77c6" class="kh ki hh kd b fi kj kk l kl km">batch_size = 64</span><span id="662d" class="kh ki hh kd b fi kn kk l kl km">train_loader = torch.utils.data.DataLoader(<br/>    dataset, batch_size=batch_size, sampler=train_sampler<br/>)</span><span id="397a" class="kh ki hh kd b fi kn kk l kl km">test_loader = torch.utils.data.DataLoader(<br/>    dataset, batch_size=batch_size, sampler=test_sampler<br/>)</span><span id="3c2e" class="kh ki hh kd b fi kn kk l kl km">validation_loader = torch.utils.data.DataLoader(<br/>    dataset, batch_size=batch_size, sampler=validation_sampler<br/>)</span></pre><p id="633e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">正如我们所讨论的，我们将train_sampler用于train-loader，反之亦然。</p><p id="b4d4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们的数据集已经准备好进行训练和测试了！！</p><p id="a906" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">模型创建:</strong></p><p id="c3a8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们使用卷积神经网络来创建模型。我们创建模型层，如下图所示。我们还指定了Conv层和游泳池层的过滤器大小和每个层的形状。</p><p id="5e1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">形状=(通道，高度，宽度)</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ko"><img src="../Images/28f0cd3f231f9bc12ff0c03d68e4f367.png" data-original-src="https://miro.medium.com/v2/resize:fit:966/format:webp/1*8e5ZigPh3MlVz-JDMNB6Zw.jpeg"/></div></figure><p id="a392" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在PyTorch中，形状不是自动计算的，我们必须手动处理每一层的形状。在第一个全连接层，我们必须根据卷积层的形状提到输出大小。这种计算也被称为<strong class="ig hi">卷积运算。</strong></p><p id="48b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">卷积运算的等式如下:</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es kp"><img src="../Images/65a6ee14e56f624ee648888b3d0389a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2O18xyA5g-8UPrRP8Y94eA.jpeg"/></div></div></figure><p id="ef12" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个项目中，膨胀= 0。</p><p id="1141" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">关于型号代码，请查看我的Github repo <a class="ae jc" href="https://github.com/manthan89-py/Plant-Disease-Detection" rel="noopener ugc nofollow" target="_blank">这里</a></p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="1cc2" class="kh ki hh kd b fi kj kk l kl km">model = CNN(targets_size) # targets_size = 39</span></pre><p id="8918" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这里，我们必须将图像分为39个类别，这就是为什么我们使用<strong class="ig hi">分类交叉熵</strong>作为损失和adam优化器。在模型中，我们使用ReLU作为激活，但对于最后一层，我们必须使用<strong class="ig hi"> Softmax </strong>激活。在PyTorch中，我们有一个交叉熵损失，它是softmax和类别交叉熵损失的混合。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="eab1" class="kh ki hh kd b fi kj kk l kl km">criterion = nn.CrossEntropyLoss()  <br/>optimizer = torch.optim.Adam(model.parameters())</span></pre><p id="cbc4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">批量梯度下降:</strong></p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="03c2" class="kh ki hh kd b fi kj kk l kl km">def batch_gd(model, criterion, train_loader, test_laoder, epochs):<br/>    train_losses = np.zeros(epochs)<br/>    test_losses = np.zeros(epochs)</span><span id="8091" class="kh ki hh kd b fi kn kk l kl km">for e in range(epochs):<br/>        t0 = datetime.now()<br/>        train_loss = []<br/>        for inputs, targets in train_loader:<br/>            inputs, targets = inputs.to(device), targets.to(device)</span><span id="a737" class="kh ki hh kd b fi kn kk l kl km">optimizer.zero_grad()</span><span id="3cb5" class="kh ki hh kd b fi kn kk l kl km">output = model(inputs)</span><span id="8179" class="kh ki hh kd b fi kn kk l kl km">loss = criterion(output, targets)</span><span id="d792" class="kh ki hh kd b fi kn kk l kl km">train_loss.append(loss.item())  # torch to numpy world</span><span id="5d87" class="kh ki hh kd b fi kn kk l kl km">loss.backward()<br/>            optimizer.step()</span><span id="885c" class="kh ki hh kd b fi kn kk l kl km">train_loss = np.mean(train_loss)</span><span id="4ad5" class="kh ki hh kd b fi kn kk l kl km">validation_loss = []</span><span id="ebeb" class="kh ki hh kd b fi kn kk l kl km">for inputs, targets in validation_loader:</span><span id="3171" class="kh ki hh kd b fi kn kk l kl km">inputs, targets = inputs.to(device), targets.to(device)</span><span id="23a4" class="kh ki hh kd b fi kn kk l kl km">output = model(inputs)</span><span id="9f68" class="kh ki hh kd b fi kn kk l kl km">loss = criterion(output, targets)</span><span id="7fc9" class="kh ki hh kd b fi kn kk l kl km">validation_loss.append(loss.item())  # torch to numpy world</span><span id="1830" class="kh ki hh kd b fi kn kk l kl km">validation_loss = np.mean(validation_loss)</span><span id="f690" class="kh ki hh kd b fi kn kk l kl km">train_losses[e] = train_loss<br/>        validation_losses[e] = validation_loss</span><span id="78cc" class="kh ki hh kd b fi kn kk l kl km">dt = datetime.now() - t0</span><span id="d68f" class="kh ki hh kd b fi kn kk l kl km">print(<br/>            f"Epoch : {e+1}/{epochs} Train_loss:{train_loss:.3f} Test_loss:{validation_loss:.3f} Duration:{dt}"<br/>        )</span><span id="897d" class="kh ki hh kd b fi kn kk l kl km">return train_losses, validation_losses</span></pre><p id="5eaa" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如你所见，上面的函数用于批量梯度下降。batch_gd()是所有学习发生的函数。</p><pre class="je jf jg jh fd kc kd ke kf aw kg bi"><span id="6971" class="kh ki hh kd b fi kj kk l kl km">def accuracy(loader):<br/>    n_correct = 0<br/>    n_total = 0</span><span id="cb24" class="kh ki hh kd b fi kn kk l kl km">for inputs, targets in loader:<br/>        inputs, targets = inputs.to(device), targets.to(device)</span><span id="b332" class="kh ki hh kd b fi kn kk l kl km">outputs = model(inputs)</span><span id="5e09" class="kh ki hh kd b fi kn kk l kl km">_, predictions = torch.max(outputs, 1)</span><span id="d185" class="kh ki hh kd b fi kn kk l kl km">n_correct += (predictions == targets).sum().item()<br/>        n_total += targets.shape[0]</span><span id="675c" class="kh ki hh kd b fi kn kk l kl km">acc = n_correct / n_total<br/>    return acc</span><span id="bc74" class="kh ki hh kd b fi kn kk l kl km">train_acc = accuracy(train_loader)<br/>test_acc = accuracy(test_loader)<br/>validation_acc = accuracy(validation_loader)</span></pre><p id="a691" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">上述函数用于确定模型的准确性。理解代码非常简单。你可以在我的<a class="ae jc" href="https://github.com/manthan89-py/Plant-Disease-Detection" rel="noopener ugc nofollow" target="_blank"> Github </a>查看完整代码。</p><p id="24cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过使用当前的模型，我们获得了准确性</p><p id="1c49" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">列车数据上<strong class="ig hi"> 87 % </strong>，验证数据上<strong class="ig hi"> 84 </strong> <strong class="ig hi"> % </strong>，测试数据上<strong class="ig hi"> 83 </strong> %。</p><p id="6bc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">为此，我们使用测试数据作为全新的数据。我们没有使用任何阶段的测试数据，这些数据仅用于最终测试。</p><blockquote class="jt ju jv"><p id="2454" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">模型工作:</strong></p></blockquote><p id="dd05" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你知道CNN的工作，那么你就会明白我在这个项目中所做的事情。这一节是给那些不明白的人看的。基本上，首先我们将每张图片的大小调整为224 x 224。之后，这个图像输入到卷积神经网络。我们饲料彩色图像，所以它有3个通道RGB。第一conv层，我们应用32个滤波器大小或输出通道。这意味着32个不同的过滤器应用于图像，并试图找到特征，然后使用32个特征，我们创建了一个具有通道32的特征图。所以从3 x 224 x 224会变成32 x 222 x 222。之后，我们应用<strong class="ig hi"> ReLU </strong>激活函数来消除非线性，之后我们应用<strong class="ig hi">批量标准化</strong>来标准化神经元的权重。在此之后，我们将该图像馈送到最大池层，该层仅获取最相关的特征，因此我们得到形状为32 x 112 x 112的输出图像。之后，我们将此图像馈送到下一个<strong class="ig hi">卷积层</strong>，其过程与上面提到的相同。最后，我们展平最终的最大池层输出，并馈送到下一个线性层，该线性层也被称为<strong class="ig hi">全连接层</strong>，最后，作为最终层，我们预测39个类别。因此，作为模型输出，我们得到张量1x39大小。从张量中，我们得到张量中最大值的索引。那个特定的指数是我们的主要预测。这就是一切运作的方式...！！</p><p id="aee6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">希望你能理解…👍🏻😊</p><blockquote class="jt ju jv"><p id="e984" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">烧瓶网络App : </strong></p></blockquote><p id="93f9" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在创建了这个模型之后，我们在flask上创建了一个web应用程序，并将其部署在heroku云服务器上。</p><p id="2a89" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">flask框架的编码也可以在我的github repo <a class="ae jc" href="https://github.com/manthan89-py/Plant-Disease-Detection" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="je jf jg jh fd ji"><div class="bz dy l di"><div class="kq kr l"/></div></figure><p id="a742" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><a class="ae jc" href="https://plant-disease-detection-ai.herokuapp.com" rel="noopener ugc nofollow" target="_blank">Plant-Disease-Detection-AI.Herokuapp.com</a></p><blockquote class="jt ju jv"><p id="48f9" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">代码:</strong></p></blockquote><div class="ks kt ez fb ku kv"><a href="https://github.com/manthan89-py/Plant-Disease-Detection" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hi fi z dy la ea eb lb ed ef hg bi translated">man than 89-py/植物病害检测</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">基于叶片图像，我们试图使用卷积神经网络来预测植物疾病。PyTorch实现…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div><div class="le l"><div class="lf l lg lh li le lj jn kv"/></div></div></a></div><blockquote class="jt ju jv"><p id="c320" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">领英:</strong></p></blockquote><div class="ks kt ez fb ku kv"><a href="https://www.linkedin.com/in/manthanbhikadiya" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hi fi z dy la ea eb lb ed ef hg bi translated">印度古吉拉特邦苏拉特曼丹·比卡第亚-查罗特科技大学|…</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">查看Manthan Bhikadiya在世界上最大的职业社区LinkedIn上的个人资料。Manthan有一份工作列在…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">www.linkedin.com</p></div></div></div></a></div><blockquote class="jt ju jv"><p id="8f24" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">结论:</strong></p></blockquote><p id="6472" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这种模式在没有迁移学习的情况下非常有效。但是我会用迁移学习等很多方法来提高模型的准确性。</p><p id="984e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望你喜欢这个项目🙏。</p><blockquote class="jt ju jv"><p id="428a" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">更多博客和项目:</strong></p></blockquote><p id="b019" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jw">项目:</em> </strong></p><div class="ks kt ez fb ku kv"><a href="https://github.com/manthan89-py" rel="noopener  ugc nofollow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hi fi z dy la ea eb lb ed ef hg bi translated">manthan89-py -概述</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">对AI、深度学习、机器学习、计算机视觉、区块链、Flutter感兴趣😇。做一些竞争性的…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">github.com</p></div></div><div class="le l"><div class="lk l lg lh li le lj jn kv"/></div></div></a></div><p id="b871" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> <em class="jw">博客:</em> </strong></p><div class="ks kt ez fb ku kv"><a href="https://manthan-bhikadiya.medium.com/" rel="noopener follow" target="_blank"><div class="kw ab dw"><div class="kx ab ky cl cj kz"><h2 class="bd hi fi z dy la ea eb lb ed ef hg bi translated">曼丹·比卡第亚·🖋-中等</h2><div class="lc l"><h3 class="bd b fi z dy la ea eb lb ed ef dx translated">机器学习、深度学习、人工智能是未来。我们几乎在每个领域都使用这些技术…</h3></div><div class="ld l"><p class="bd b fp z dy la ea eb lb ed ef dx translated">manthan-bhikadiya.medium.com</p></div></div><div class="le l"><div class="ll l lg lh li le lj jn kv"/></div></div></a></div><blockquote class="jt ju jv"><p id="84b8" class="ie if jw ig b ih ii ij ik il im in io jx iq ir is jy iu iv iw jz iy iz ja jb ha bi translated"><strong class="ig hi">最终注释:</strong></p></blockquote><p id="dcc2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">感谢阅读！如果你喜欢这篇文章，请点击</strong>👏<strong class="ig hi">尽可能多次按下按钮。这将意味着很多，并鼓励我继续分享我的知识。如果你喜欢我的内容，请在medium上关注我，我会尽可能多地发布博客。</strong></p></div></div>    
</body>
</html>