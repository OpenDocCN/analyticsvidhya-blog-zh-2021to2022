<html>
<head>
<title>Function Programming with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python进行函数编程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/function-programming-with-python-7726493fbedd?source=collection_archive---------13-----------------------#2021-04-20">https://medium.com/analytics-vidhya/function-programming-with-python-7726493fbedd?source=collection_archive---------13-----------------------#2021-04-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/27470dd1e9967e0fca4ee196cadddecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*zlgyJt3bUoH-C3fF8hJsSw.jpeg"/></div></figure><h2 id="41d0" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">什么是函数式编程？</strong></h2><p id="b1ad" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">函数式编程语言是专门为处理符号计算和列表处理应用而设计的。函数式编程基于数学函数。一些流行的函数式编程语言包括:Lisp、Python、Erlang、Haskell、Clojure等。</p><p id="b3f1" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">最近，函数式编程的使用越来越多。因此，许多传统的命令式语言，如Java和Python已经开始支持函数式编程技术。在本文中，假设您对函数式编程有基本的了解，我将向您介绍其中的一些技术。如果你不熟悉基本函数编程，可以查看这篇关于<a class="ae kj" rel="noopener" href="/@yannickdot/functional-programming-101-6bc132674ec5">函数编程</a>的文章。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h2 id="f763" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak">一级功能</strong></h2><p id="1ac0" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">Python函数是第一类对象。因此，我们可以将它们赋给变量，将它们作为参数传递给其他函数，将它们存储在字典等其他数据结构中，并将它们用作其他函数的返回值。</p><p id="1758" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">在下面的例子中，我们将函数赋给一个变量。这个赋值没有调用函数。它接受由shout引用的函数对象，并创建指向它的第二个名称Tell。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="5570" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi"><em class="le">def</em></strong> Show(<em class="le">Text</em>):</span><span id="ef51" class="il im hh kw b fi lf lb l lc ld">    return Text.upper()</span><span id="e519" class="il im hh kw b fi lf lb l lc ld"><strong class="kw hi">print</strong>(Show("Hello World"))</span><span id="890c" class="il im hh kw b fi lf lb l lc ld">Tell = Show</span><span id="3838" class="il im hh kw b fi lf lb l lc ld"><strong class="kw hi">print</strong>(Tell("Hello World"))</span><span id="0c20" class="il im hh kw b fi lf lb l lc ld"><strong class="kw hi">OUTPUT<br/></strong>HELLO WORLD<br/>HELLO WORLD</span></pre><p id="951c" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">由于函数是对象，我们可以将函数<code class="du lg lh li kw b">Show</code>赋给任何变量，然后调用该变量来引用函数。例如，我们可以将它赋给变量<code class="du lg lh li kw b">Tell.</code></p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="47bf" class="lj im hh bd in lk ll lm ir ln lo lp iv lq lr ls iz lt lu lv jd lw lx ly jh lz bi translated">数据结构中的函数</h1><p id="43e4" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">与其他对象一样，函数也可以存储在数据结构中。例如，我们可以创建一个从<code class="du lg lh li kw b">int</code>到<code class="du lg lh li kw b">func.</code>的映射字典，这在<code class="du lg lh li kw b">int</code>是要执行的过程的简写时很有用。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="35c9" class="il im hh kw b fi la lb l lc ld"><em class="le">#INITIALIZING DICTIONARY<br/>dict = {<br/>    </em>0<em class="le">: func1,<br/>   </em><strong class="kw hi"><em class="le"> </em></strong>1<strong class="kw hi"><em class="le">: </em></strong><em class="le">func2<br/>}<br/></em>x = input() <em class="le">#GET INTEGER VALUE FROM USER</em><br/>dict[x]() <em class="le">#CALL THE FUNCTION RETURNED BY DICTIONARY ACCESS</em></span></pre></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="ebe3" class="lj im hh bd in lk ll lm ir ln lo lp iv lq lr ls iz lt lu lv jd lw lx ly jh lz bi translated">用作参数和返回值</h1><p id="51c8" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">一个函数可以有多个参数，这些参数可以是对象、变量(相同或不同的数据类型)和函数。</p><p id="1191" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">函数也可以作为其他函数的参数和返回值。接受或返回函数的函数称为<a class="ae kj" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank"> <em class="le">高阶函数</em> </a> <em class="le"> </em>，是函数式编程的重要组成部分。</p><p id="57b7" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">高阶函数非常强大。正如在雄辩的JavaScript 上深入解释的<a class="ae kj" href="https://eloquentjavascript.net/05_higher_order.html" rel="noopener ugc nofollow" target="_blank">:</a></p><p id="1f84" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">考虑一个例子。</p><p id="c67a" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">假设我们想要遍历一个条目列表并按顺序打印它们。我们可以很容易地构建一个<code class="du lg lh li kw b">iterate</code>函数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="e091" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi">def</strong> iterate(list_of_items):<br/>    for item in list_of_items:<br/>       <strong class="kw hi"> print</strong>(item)</span></pre><p id="76d6" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这可能看起来很酷，但这只是抽象的一个层次。如果我们想在遍历列表时做一些不同的事情(而不是打印)呢？</p><p id="5597" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这就是高阶函数的用武之地。我们可以创建一个函数<code class="du lg lh li kw b">iterate_custom</code>,它接受一个要迭代的列表和一个要应用于每个项目的函数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="abcb" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi">def</strong> iterate_custom(list_of_items, custom_func):<br/><strong class="kw hi">   for</strong> item <strong class="kw hi">in</strong> list_of_items:<br/>        custom_func(item)</span></pre><p id="1eb1" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">虽然这看起来微不足道，但它非常强大。</p><p id="4c09" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们已经提升了一个抽象层，使我们的代码更加可重用。现在，我们不仅可以在想要打印列表时调用该函数，还可以对列表做任何涉及顺序迭代的事情。</p><p id="3951" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">函数也可以被返回以使事情更简单。就像我们如何在<code class="du lg lh li kw b">dict</code>中存储函数一样，我们也可以使用函数作为控制流来决定合适的函数。例如:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="9bcc" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi">def</strong> add(x, y):<br/>    <strong class="kw hi">return</strong> x + ydef sub(x, y):<br/>   <strong class="kw hi"> return</strong> x - ydef mult(x, y):<br/>    <strong class="kw hi">return</strong> x * ydef calculator(opcode):<br/>    <strong class="kw hi">if </strong>opcode == 1:<br/>       <strong class="kw hi">return</strong> add<br/>   <strong class="kw hi"> elif</strong> opcode == 2:<br/>       <strong class="kw hi">return</strong> sub<br/>    <strong class="kw hi">else</strong>:<br/>      <strong class="kw hi"> return</strong> mult my_calc = calculator(2) #MY CALC IS A SUBSTRACOTR<br/>my_calc(5, 4) #RETURNS 5 - 4 = 1 <br/>my_calc = calculator(9) #MY CALC IS A MULTIPLLIER<br/>my_calc(5, 4) #returns 5 x 4 = 20.</span></pre></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="7a39" class="lj im hh bd in lk ll lm ir ln lo lp iv lq lr ls iz lt lu lv jd lw lx ly jh lz bi translated">嵌套函数</h1><p id="f02a" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">函数也可以在其他函数内部定义，这些函数被恰当地称为<em class="le">内部函数。这些对于制作<em class="le">辅助函数</em>特别有用——小的、可重用的函数，支持主函数作为子模块。</em></p><p id="09d8" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">当一个问题需要一个特定的函数定义(参数类型或顺序)时，Helper函数是很方便的，但是不遵循约定更容易解决问题。一个很好的例子来自<a class="ae kj" href="http://www-inst.eecs.berkeley.edu/~cs61a/sp12/lectures/lect4-2x3.pdf" rel="noopener ugc nofollow" target="_blank">这张讲座幻灯片</a>。</p><p id="c35d" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">假设你想定义一个斐波那契函数，<code class="du lg lh li kw b">fib(n)</code>，它有一个参数，<code class="du lg lh li kw b">n</code>，我们必须返回<code class="du lg lh li kw b">nth</code>斐波那契数。</p><p id="5f31" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">定义这种函数的一种可能方式是使用跟踪斐波纳契数列的前两项的辅助函数(因为斐波纳契数只是前两个斐波纳契数的和)。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="ae7a" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi">def</strong> fib(n):<br/>   <strong class="kw hi"> def</strong> fib_helper(fk1, fk, k):<br/>        <strong class="kw hi">if</strong> n == k:<br/>         <strong class="kw hi">  return</strong> fk<br/>        <strong class="kw hi">else</strong>:<br/>           <strong class="kw hi">return</strong> fib_helper(fk, fk1+fk, k+1)    if n &lt;= 1:<br/>       <strong class="kw hi">return</strong> n<br/>  <strong class="kw hi">  else</strong>:<br/>      <strong class="kw hi"> return</strong> fib_helper(0, 1, 1)</span></pre><p id="ea30" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">将计算从函数体转移到函数参数是非常强大的，因为它减少了递归方法中可能出现的冗余计算。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="133e" class="lj im hh bd in lk ll lm ir ln lo lp iv lq lr ls iz lt lu lv jd lw lx ly jh lz bi translated">λ表达式(单一表达式函数)</h1><p id="5522" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated">我们如何定义一个函数而不给它起任何名字？我们可以应用lambda函数来定义短函数和在线函数，如下所示。</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="af3b" class="il im hh kw b fi la lb l lc ld">add = <strong class="kw hi">lambda</strong> x, y: x + y<br/>add(1, 2) <em class="le">#RETURNS 2</em></span></pre><p id="461e" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这个<code class="du lg lh li kw b">add</code>的行为与前面使用传统的<code class="du lg lh li kw b">def</code>关键字定义的行为完全相同。</p><p id="93de" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">请注意，lambda函数必须是一行程序，并且不能包含程序员编写的返回语句。</p><p id="3eb8" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">事实上，它们总是有一个隐式的return语句(在上面的例子中，它会说<code class="du lg lh li kw b">return x + y</code>，但是我们省略了lambda函数的显式return语句)。</p><p id="9f1f" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">lambda函数更加强大和简洁，因为我们还可以构造匿名函数——没有名字的函数:</p><p id="fadf" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated"><code class="du lg lh li kw b">(<strong class="jl hi">lambda</strong> x, y: x * y)(9, 10) #RETURNS 90</code></p><p id="930f" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这是一个方便的方法，只要我们只需要一次函数，以后就不用了。例如，在填写字典时:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="98a6" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi">import</strong> collections<br/>pre_fill = collections.<strong class="kw hi">defaultdict</strong>(lambda: (0, 0))<br/>#all dictionary keys and values are set to 0</span></pre><p id="586c" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">我们现在可以看看地图，过滤，并减少欣赏λ更多。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><h1 id="ba68" class="lj im hh bd in lk ll lm ir ln lo lp iv lq lr ls iz lt lu lv jd lw lx ly jh lz bi translated">映射、过滤和减少</h1><h2 id="8160" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated"><strong class="ak"> 1。地图</strong></h2><p id="cb9b" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated"><code class="du lg lh li kw b">map</code>是一个函数，它接受一组输入，并根据指定的函数将它们转换成另一组输入。这与<code class="du lg lh li kw b">iterate_custom</code>功能相同。例如:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="cbe5" class="il im hh kw b fi la lb l lc ld"><strong class="kw hi"><em class="le">def</em></strong> substract_1(<em class="le">x</em>):</span><span id="29df" class="il im hh kw b fi lf lb l lc ld">  <strong class="kw hi">  return</strong> x - 1<br/>scores = [10, 9, 8, 7, 6, 5]<br/>new_scores = <strong class="kw hi"><em class="le">list</em></strong>(map(substract_1, scores))<br/>#NEW SCORES ARE NOW [9, 8, 7, 6, 5, 4]<br/><strong class="kw hi">print</strong>(new_scores)</span></pre><p id="b126" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">在Python 3中，<code class="du lg lh li kw b">map</code>函数返回一个<code class="du lg lh li kw b">map</code>对象，可以将其类型转换为<code class="du lg lh li kw b">list</code>供我们使用。现在，我们可以定义一个<code class="du lg lh li kw b">lambda</code>表达式，而不是显式定义<code class="du lg lh li kw b">multiply_by_four</code>函数:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="d19d" class="il im hh kw b fi la lb l lc ld">new_scores = list(map(lambda x: X-4, scores))</span></pre><h2 id="1942" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">2.过滤器</h2><p id="7234" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated"><code class="du lg lh li kw b">filter</code>顾名思义，就是帮助“过滤”掉不需要的项目的功能。例如，我们可能想过滤掉所有来自<code class="du lg lh li kw b">scores</code>的奇数。我们可以使用<code class="du lg lh li kw b">filter</code>来实现:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="3d88" class="il im hh kw b fi la lb l lc ld">even_scores = <strong class="kw hi">list</strong>(filter(<strong class="kw hi">lambda</strong> x: (x % 2 == 0), scores))<br/>#even_scores = [6, 8]</span></pre><p id="4c1c" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">因为提供给<code class="du lg lh li kw b">filter</code>的函数根据具体情况决定是否接受一个项目，所以该函数必须返回一个<code class="du lg lh li kw b">bool</code>值(如上面的lambda函数所示)，并且必须是一元的(接受一个输入参数)。</p><h2 id="e0a1" class="il im hh bd in io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji bi translated">3.减少</h2><p id="155a" class="pw-post-body-paragraph jj jk hh jl b jm jn jo jp jq jr js jt iw ju jv jw ja jx jy jz je ka kb kc kd ha bi translated"><code class="du lg lh li kw b">reduce</code>是一个对一组数据进行“汇总”或“概括”的功能。例如，如果我们想计算所有分数的总和，我们可以使用<code class="du lg lh li kw b">reduce</code>:</p><pre class="kr ks kt ku fd kv kw kx ky aw kz bi"><span id="1d91" class="il im hh kw b fi la lb l lc ld">sum_scores = <strong class="kw hi">reduce</strong>((<strong class="kw hi">lambda</strong> x, y: x + y), scores)<br/>#sum_scores = 32</span></pre><p id="1194" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">这比写循环简单多了。注意，提供给<code class="du lg lh li kw b">reduce</code>的函数需要两个参数:一个代表当前被检查的项目，一个是应用操作的累积结果。</p><p id="49f2" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">请注意，以上只是让您开始使用Python进行函数式编程，尽管是彻底地开始。</p></div><div class="ab cl kk kl go km" role="separator"><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp kq"/><span class="kn bw bk ko kp"/></div><div class="ha hb hc hd he"><p id="4975" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">此外，您可以在这个<a class="ae kj" href="https://www.hackerrank.com/domains/fp" rel="noopener ugc nofollow" target="_blank">黑客等级</a>模块中练习和探索这些概念。</p><p id="346b" class="pw-post-body-paragraph jj jk hh jl b jm ke jo jp jq kf js jt iw kg jv jw ja kh jy jz je ki kb kc kd ha bi translated">感谢阅读，如果觉得有用可以考虑clap。</p></div></div>    
</body>
</html>