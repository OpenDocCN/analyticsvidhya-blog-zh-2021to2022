<html>
<head>
<title>Generation of a concatenated Confusion Matrix in cross-validation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉验证中级联混淆矩阵的生成</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/generation-of-a-concatenated-confusion-matrix-in-cross-validation-912485c4a972?source=collection_archive---------2-----------------------#2021-03-07">https://medium.com/analytics-vidhya/generation-of-a-concatenated-confusion-matrix-in-cross-validation-912485c4a972?source=collection_archive---------2-----------------------#2021-03-07</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c1914f36f32b274cced6e73fef0eeda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sJfpB0tlabQL9Xjn83vBKA.jpeg"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated"><a class="ae iu" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上<a class="ae iu" href="https://unsplash.com/@petalz_r/" rel="noopener ugc nofollow" target="_blank"> Petalz_R </a>的照片</figcaption></figure><p id="92e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在我们预处理数据和开发模型之后，我们需要评估模型的有效性。考虑到这一点，混淆矩阵是一个评估指标，我们可以在其中评估我们的模型在机器学习中的性能。然而，当我们执行交叉验证(例如:留一交叉验证、k倍交叉验证)以将数据集归纳为独立数据时，我们可能需要生成平均准确度或混淆矩阵。因此，这篇博客的主要目的是在使用交叉验证的同时生成一个串联的混淆矩阵。</p><h1 id="9c0f" class="jt ju hi bd jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq bi translated">虹膜数据集</h1><p id="8696" class="pw-post-body-paragraph iv iw hi ix b iy kr ja jb jc ks je jf jg kt ji jj jk ku jm jn jo kv jq jr js hb bi translated">我们将使用IRIS数据集来实现。这是一个关于三种花的简单数据集，如鸢尾、杂色鸢尾和海滨鸢尾。</p><p id="101f" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将首先加载数据集并研究属性。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="3e36" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">import</strong> <strong class="lb hj">itertools</strong><br/><br/><strong class="lb hj">import</strong> <strong class="lb hj">matplotlib.pyplot</strong> <strong class="lb hj">as</strong> <strong class="lb hj">plt</strong><br/><strong class="lb hj">import</strong> <strong class="lb hj">numpy</strong> <strong class="lb hj">as</strong> <strong class="lb hj">np</strong><br/><strong class="lb hj">from</strong> <strong class="lb hj">sklearn</strong> <strong class="lb hj">import</strong> svm, datasets<br/><strong class="lb hj">from</strong> <strong class="lb hj">sklearn.metrics</strong> <strong class="lb hj">import</strong> confusion_matrix<br/><strong class="lb hj">from</strong> <strong class="lb hj">sklearn.model_selection</strong> <strong class="lb hj">import</strong> KFold</span><span id="af28" class="lf ju hi lb b fi lk lh l li lj"><em class="ll"># import IRIS dataset to play with</em><br/>iris = datasets.load_iris()</span><span id="7e9a" class="lf ju hi lb b fi lk lh l li lj">data = iris.data<br/>target = iris.target</span><span id="2cf0" class="lf ju hi lb b fi lk lh l li lj">class_names = iris.target_names<br/>class_names</span><span id="2874" class="lf ju hi lb b fi lk lh l li lj">labels, counts = np.unique(target, return_counts=<strong class="lb hj">True</strong>)</span></pre><p id="8f1b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以通过下面的代码片段检索数据集的统计信息。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0bc9" class="lf ju hi lb b fi lg lh l li lj">print(iris.DESCR)</span></pre><p id="83c7" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将通过10倍的<a class="ae iu" href="https://en.wikipedia.org/wiki/Cross-validation_(statistics)" rel="noopener ugc nofollow" target="_blank"> <strong class="ix hj"> K倍交叉验证</strong> </a> <strong class="ix hj"> </strong>来评估我们的模型。下面的代码将我们的数据集分成训练和测试折叠，并将评估我们的模型性能10次。</p><blockquote class="lm ln lo"><p id="8c18" class="iv iw ll ix b iy iz ja jb jc jd je jf lp jh ji jj lq jl jm jn lr jp jq jr js hb bi translated">诡计！！！<br/>在每个fold中，我们将得到每个fold中的实际测试标签(<strong class="ix hj"> <em class="hi"> test_y </em> </strong>)和预测标签(<strong class="ix hj"><em class="hi">predicted _ labels</em></strong>)，并将它们分别追加到数组<strong class="ix hj"><em class="hi"/></strong>和<strong class="ix hj"><em class="hi">predicted _ targets</em></strong>中。</p></blockquote><p id="09e2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这里我们将通过<a class="ae iu" href="https://en.wikipedia.org/wiki/Support-vector_machine" rel="noopener ugc nofollow" target="_blank">支持向量机</a>来拟合我们的数据集。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="1f93" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">def</strong> evaluate_model(data_x, data_y):<br/>    k_fold = KFold(10, shuffle=<strong class="lb hj">True</strong>, random_state=1)<br/><br/>    predicted_targets = np.array([])<br/>    actual_targets = np.array([])<br/><br/>    <strong class="lb hj">for</strong> train_ix, test_ix <strong class="lb hj">in</strong> k_fold.split(data_x):<br/>        train_x, train_y, test_x, test_y = data_x[train_ix], data_y[train_ix], data_x[test_ix], data_y[test_ix]<br/><br/>        <em class="ll"># Fit the classifier</em><br/>        classifier = svm.SVC().fit(train_x, train_y)<br/><br/>        <em class="ll"># Predict the labels of the test set samples</em><br/>        predicted_labels = classifier.predict(test_x)<br/><br/>        predicted_targets = np.append(predicted_targets, predicted_labels)<br/>        actual_targets = np.append(actual_targets, test_y)<br/><br/>    <strong class="lb hj">return</strong> predicted_targets, actual_targets</span></pre><p id="76f2" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在下面的代码中，我们将把我们生成的<strong class="ix hj"><em class="ll">actual _ targets</em></strong>和<strong class="ix hj"><em class="ll">predicted _ targets</em></strong>数组馈送给<strong class="ix hj">plot _ confusion _ matrix()</strong>函数。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="0211" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">def</strong> plot_confusion_matrix(predicted_labels_list, y_test_list):<br/>    cnf_matrix = confusion_matrix(y_test_list, predicted_labels_list)<br/>    np.set_printoptions(precision=2)<br/><br/>    <em class="ll"># Plot non-normalized confusion matrix</em><br/>    plt.figure()<br/>    generate_confusion_matrix(cnf_matrix, classes=class_names, title='Confusion matrix, without normalization')<br/>    plt.show()<br/><br/>    <em class="ll"># Plot normalized confusion matrix</em><br/>    plt.figure()<br/>    generate_confusion_matrix(cnf_matrix, classes=class_names, normalize=<strong class="lb hj">True</strong>, title='Normalized confusion matrix')<br/>    plt.show()</span></pre><p id="167b" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们下面的代码负责生成规范化或非规范化的混淆矩阵。</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="7925" class="lf ju hi lb b fi lg lh l li lj"><strong class="lb hj">def</strong> generate_confusion_matrix(cnf_matrix, classes, normalize=<strong class="lb hj">False</strong>, title='Confusion matrix'):<br/>    <strong class="lb hj">if</strong> normalize:<br/>        cnf_matrix = cnf_matrix.astype('float') / cnf_matrix.sum(axis=1)[:, np.newaxis]<br/>        print("Normalized confusion matrix")<br/>    <strong class="lb hj">else</strong>:<br/>        print('Confusion matrix, without normalization')<br/><br/>    plt.imshow(cnf_matrix, interpolation='nearest', cmap=plt.get_cmap('Blues'))<br/>    plt.title(title)<br/>    plt.colorbar()<br/><br/>    tick_marks = np.arange(len(classes))<br/>    plt.xticks(tick_marks, classes, rotation=45)<br/>    plt.yticks(tick_marks, classes)<br/><br/>    fmt = '.2f' <strong class="lb hj">if</strong> normalize <strong class="lb hj">else</strong> 'd'<br/>    thresh = cnf_matrix.max() / 2.<br/><br/>    <strong class="lb hj">for</strong> i, j <strong class="lb hj">in</strong> itertools.product(range(cnf_matrix.shape[0]), range(cnf_matrix.shape[1])):<br/>        plt.text(j, i, format(cnf_matrix[i, j], fmt), horizontalalignment="center",<br/>                 color="white" <strong class="lb hj">if</strong> cnf_matrix[i, j] &gt; thresh <strong class="lb hj">else</strong> "black")<br/><br/>    plt.tight_layout()<br/>    plt.ylabel('True label')<br/>    plt.xlabel('Predicted label')<br/><br/>    <strong class="lb hj">return</strong> cnf_matrix</span></pre><p id="a380" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">代码执行如下:</p><pre class="kw kx ky kz fd la lb lc ld aw le bi"><span id="4eb8" class="lf ju hi lb b fi lg lh l li lj">predicted_target, actual_target = evaluate_model(data, target)<br/>plot_confusion_matrix(predicted_target, actual_target)</span></pre><p id="7431" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们的代码将通过交叉验证来考虑每个折叠中测试数据的预测，从而输出以下连接的混淆矩阵。</p><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es ls"><img src="../Images/d76c35f57f8ebe4c829c062f027da0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1300/format:webp/1*LA0SeXqD3fLsMsAINRGPtg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">无归一化的混淆矩阵</figcaption></figure><figure class="kw kx ky kz fd ij er es paragraph-image"><div class="er es lt"><img src="../Images/8d1b13ddfc30cd7b3254e6208c2ed43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1308/format:webp/1*vVVkh970QTUueeu0CnVvow.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">归一化混淆矩阵</figcaption></figure><p id="1d1d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我希望这篇文章能为你提供串联混淆矩阵的一些基本实现。</p><p id="bd2e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">如果你认为它有价值，请随意在任何平台上分享这个博客。</p><p id="68b6" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">你可以在这里找到我的完整代码。</p><p id="db76" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">快乐学习！！</p><p id="10a3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">您可以通过以下方式联系到我:</p><p id="d824" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">领英:【https://www.linkedin.com/in/rukshanisomarathna/ T2】</p><p id="3781" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">GitHub:【https://github.com/Rukshani T4】</p></div></div>    
</body>
</html>