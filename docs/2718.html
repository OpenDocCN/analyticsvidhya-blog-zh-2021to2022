<html>
<head>
<title>Slicing Through Sequences In Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的序列切片</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/slicing-through-sequences-in-python-e74a53b685e5?source=collection_archive---------15-----------------------#2021-05-14">https://medium.com/analytics-vidhya/slicing-through-sequences-in-python-e74a53b685e5?source=collection_archive---------15-----------------------#2021-05-14</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c4078bea8314e3f6986f8d672cc1ecd3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8TWORUuj1Xt8S1ppCxBmQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">使用<a class="ae it" href="https://www.canva.com/" rel="noopener ugc nofollow" target="_blank"> canva </a>创建</figcaption></figure><p id="aa63" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">在Python中，从iterable中提取元素子集的最简单的方法之一是应用切片的概念。在这篇文章中，让我们来了解一下如何分割任何可迭代的对象，比如字符串、列表或元组，以便分割出一个子集！</p><p id="08b8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在开始之前，让我们重温一下Python中索引的工作原理。</p><p id="7267" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们声明一个包含从<code class="du kb kc kd ke b">0</code>到<code class="du kb kc kd ke b">9</code>的所有整数的列表。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="5f02" class="kn ko hh ke b fi kp kq l kr ks">num_list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><p id="3881" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">由于Python遵循基于零的索引，为了访问列表的第一个元素，我们通过传入索引<code class="du kb kc kd ke b">0</code>来使用<code class="du kb kc kd ke b">index operator ([])</code>。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="1c04" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[0])</span></pre><p id="32cf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="7481" class="kn ko hh ke b fi kp kq l kr ks">0</span></pre><p id="de6c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在我们的列表中有<code class="du kb kc kd ke b">10</code>元素，范围从索引<code class="du kb kc kd ke b">0</code>到<code class="du kb kc kd ke b">9</code>，如果我们试图使用<code class="du kb kc kd ke b">num_list[10]</code>打印第10个索引处的元素，我们会得到以下错误:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="48e6" class="kn ko hh ke b fi kp kq l kr ks">IndexError: list index out of range</span></pre><p id="b435" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Python还允许通过从列表末尾开始计数，使用负索引来访问序列中的元素。</p><p id="fdd5" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，<code class="du kb kc kd ke b">num_list[-1]</code>访问列表末尾的第一个元素，即<code class="du kb kc kd ke b">9</code>。</p><p id="b2f8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这意味着:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="5104" class="kn ko hh ke b fi kp kq l kr ks">num_list[0] == num_list[-10] # or 0 in the list</span><span id="26ae" class="kn ko hh ke b fi kt kq l kr ks">num_list[1] == num_list[-9] # or 1 in the list</span><span id="2c73" class="kn ko hh ke b fi kt kq l kr ks">num_list[2] == num_list[-8] # or 2 in the list</span><span id="ead7" class="kn ko hh ke b fi kt kq l kr ks">num_list[3] == num_list[-7] # or 3 in the list</span><span id="cf59" class="kn ko hh ke b fi kt kq l kr ks">num_list[4] == num_list[-6] # or 4 in the list</span><span id="adb1" class="kn ko hh ke b fi kt kq l kr ks">num_list[5] == num_list[-5] # or 5 in the list</span><span id="43f2" class="kn ko hh ke b fi kt kq l kr ks">num_list[6] == num_list[-4] # or 6 in the list</span><span id="7070" class="kn ko hh ke b fi kt kq l kr ks">num_list[7] == num_list[-3] # or 7 in the list</span><span id="ed15" class="kn ko hh ke b fi kt kq l kr ks">num_list[8] == num_list[-2] # or 8 in the list</span><span id="475b" class="kn ko hh ke b fi kt kq l kr ks">num_list[9] == num_list[-1] # or 9 in the list</span></pre><p id="b89d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，对于长度为<code class="du kb kc kd ke b">n</code>的序列<code class="du kb kc kd ke b">s</code>，可以将<code class="du kb kc kd ke b">s</code>的第<code class="du kb kc kd ke b">i</code>个元素作为，</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="ac54" class="kn ko hh ke b fi kp kq l kr ks">s[i] <strong class="ke hi">or</strong> s[i - n]</span></pre><p id="c714" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">既然我们已经更新了对Python中序列如何索引的理解，我们可以扩展这一知识，使用以下符号从序列<code class="du kb kc kd ke b">s</code>中分割出子序列:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="2215" class="kn ko hh ke b fi kp kq l kr ks">s[start:stop:step]</span></pre><p id="1311" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上述符号中，</p><ol class=""><li id="8081" class="ku kv hh iw b ix iy jb jc jf kw jj kx jn ky jr kz la lb lc bi translated"><code class="du kb kc kd ke b">start</code>代表<code class="du kb kc kd ke b">s</code>中我们应该开始切片的索引。<code class="du kb kc kd ke b">start</code>的默认值为<code class="du kb kc kd ke b">0</code>。</li><li id="2934" class="ku kv hh iw b ix ld jb le jf lf jj lg jn lh jr kz la lb lc bi translated"><code class="du kb kc kd ke b">stop</code>代表<code class="du kb kc kd ke b">s</code>中我们应该切片到(但不包括)的指数。<code class="du kb kc kd ke b">stop</code>的默认值是<code class="du kb kc kd ke b">n - 1</code>，其中<code class="du kb kc kd ke b">n</code>是序列的长度。</li><li id="9386" class="ku kv hh iw b ix ld jb le jf lf jj lg jn lh jr kz la lb lc bi translated"><code class="du kb kc kd ke b">step</code>代表从<code class="du kb kc kd ke b">start</code>到<code class="du kb kc kd ke b">stop</code>时，我们应该增加的索引值。<code class="du kb kc kd ke b">step</code>的默认值为1。</li></ol><p id="ff81" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们对包含<code class="du kb kc kd ke b">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>的<code class="du kb kc kd ke b">num_list</code>执行切片操作，而没有为<code class="du kb kc kd ke b">start</code>、<code class="du kb kc kd ke b">stop</code>和<code class="du kb kc kd ke b">step</code>提供值，那么切片操作将分别为这三个变量使用默认值<code class="du kb kc kd ke b">0</code>、<code class="du kb kc kd ke b">9</code>和<code class="du kb kc kd ke b">1</code>。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="1647" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[::])</span></pre><p id="e871" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="1092" class="kn ko hh ke b fi kp kq l kr ks">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></pre><p id="fa54" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">乍一看，好像是<code class="du kb kc kd ke b">num_list</code>印的。但是我们需要记住切片操作总是返回一个新的列表。在这种情况下，因为我们的子序列的<code class="du kb kc kd ke b">start</code>、<code class="du kb kc kd ke b">stop</code>和<code class="du kb kc kd ke b">step</code>的值与原始序列相同(因为我们使用默认值)，所以我们得到一个新的列表，它包含与原始列表相同的元素。</p><p id="c611" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">接下来，让我们看看可以从<code class="du kb kc kd ke b">num_list</code>中以升序提取包含所有偶数的子序列的不同方法。</p><h1 id="750f" class="li ko hh bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">1.提供开始、停止和步进</h1><p id="39b6" class="pw-post-body-paragraph iu iv hh iw b ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr ha bi translated">为此，让我们确定我们的<code class="du kb kc kd ke b">start</code>、<code class="du kb kc kd ke b">stop</code>和<code class="du kb kc kd ke b">step</code>变量:</p><ol class=""><li id="847f" class="ku kv hh iw b ix iy jb jc jf kw jj kx jn ky jr kz la lb lc bi translated">我们列表中的第一个偶数是<code class="du kb kc kd ke b">0</code>，它位于从列表开始的索引<code class="du kb kc kd ke b">0</code>处，因此我们可以将索引<code class="du kb kc kd ke b">start</code>设置为<code class="du kb kc kd ke b">0</code></li><li id="13dd" class="ku kv hh iw b ix ld jb le jf lf jj lg jn lh jr kz la lb lc bi translated">我们列表中的最后一个偶数是<code class="du kb kc kd ke b">8</code>，它位于从列表开始的索引<code class="du kb kc kd ke b">8</code>处，所以我们可以将<code class="du kb kc kd ke b">stop</code>索引设置为<code class="du kb kc kd ke b">9</code>(这样我们可以切片到序列中第<code class="du kb kc kd ke b">9</code>索引处的元素，但不包括它)</li><li id="6824" class="ku kv hh iw b ix ld jb le jf lf jj lg jn lh jr kz la lb lc bi translated">从起始索引开始，我们列表中的每一个备选数字都是偶数，所以我们可以将<code class="du kb kc kd ke b">step</code>设置为<code class="du kb kc kd ke b">2</code>，在每一步中递增<code class="du kb kc kd ke b">2</code>。</li></ol><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="ce3d" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[0:9:2])</span></pre><p id="3b99" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们运行此代码时，从<code class="du kb kc kd ke b">0-9</code>开始按升序排列的偶数列表将作为输出打印出来:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="6046" class="kn ko hh ke b fi kp kq l kr ks">[0, 2, 4, 6, 8]</span></pre><h1 id="b65d" class="li ko hh bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">2.提供开始和步骤</h1><p id="15f1" class="pw-post-body-paragraph iu iv hh iw b ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr ha bi translated">因为我们的子序列的<code class="du kb kc kd ke b">stop</code>索引的默认值已经是<code class="du kb kc kd ke b">9</code> ( <code class="du kb kc kd ke b">len(num_list) - 1</code>)，所以我们可以得到与上面相同的偶数列表，而不需要像这样为我们的片提供一个<code class="du kb kc kd ke b">stop</code>索引:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="9dea" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[0::2])</span></pre><h1 id="208d" class="li ko hh bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">3.提供停止和步进</h1><p id="45ca" class="pw-post-body-paragraph iu iv hh iw b ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr ha bi translated">类似地，由于我们的子序列的<code class="du kb kc kd ke b">start</code>索引的默认值已经是<code class="du kb kc kd ke b">0</code>，我们可以得到相同的偶数列表，而不需要像这样向切片提供<code class="du kb kc kd ke b">start</code>索引:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="0a46" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[:9:2])</span></pre><h1 id="420c" class="li ko hh bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">4.仅提供一步</h1><p id="4bde" class="pw-post-body-paragraph iu iv hh iw b ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr ha bi translated">最后，由于我们的子序列的<code class="du kb kc kd ke b">start</code>和<code class="du kb kc kd ke b">stop</code>索引的默认值与第一种方法中提供的相同，我们可以通过将<code class="du kb kc kd ke b">step</code>变量设置为<code class="du kb kc kd ke b">2</code>来获得偶数列表:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="0e82" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[::2])</span></pre><h1 id="a666" class="li ko hh bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">其他方式:</h1><p id="69ca" class="pw-post-body-paragraph iu iv hh iw b ix mf iz ja jb mg jd je jf mh jh ji jj mi jl jm jn mj jp jq jr ha bi translated">我们甚至可以使用负指数来获得相同的结果，如下所示:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="e0f1" class="kn ko hh ke b fi kp kq l kr ks"># 1:  <br/>print(num_list[0:-1:2]) # setting stop index to -1 to access the first element from the end<br/># or<br/>print(num_list[:-1:2]) # using the default value for start index</span><span id="640d" class="kn ko hh ke b fi kt kq l kr ks"># 2:<br/>print(num_list[-10:9:2]) # setting start index to -1 to access the last element from the end <br/># or <br/>print(num_list[-10::2]) # using the default value for stop index</span><span id="c42e" class="kn ko hh ke b fi kt kq l kr ks"># 3:<br/>print(num_list[-10:-1:2]) # using negative start and stop indices</span></pre></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="3daf" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">侧栏:</p><p id="0b13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在上面提到的例子中，我们总是为<code class="du kb kc kd ke b">step</code>提供一个值，因为它帮助我们从开始索引到结束增加两步，以便找到所有的偶数。</p><p id="2562" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果我们只需要从<code class="du kb kc kd ke b">num_list</code>的开始提取前三个数字，我们不需要为<code class="du kb kc kd ke b">step</code>传递一个值，因为我们将递增<code class="du kb kc kd ke b">1</code>，这是默认的<code class="du kb kc kd ke b">step</code>值。</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="fdc2" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[0:3])</span></pre><p id="9bff" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="3568" class="kn ko hh ke b fi kp kq l kr ks">[0, 1, 2]</span></pre></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="e026" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">常见应用:</p><p id="c06e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">切片的一个非常常见的应用是反转序列。</p><p id="614c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，如果我们想要反转<code class="du kb kc kd ke b">num_list</code>，我们可以通过将<code class="du kb kc kd ke b">step</code>变量设置为-1来实现:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="c0d7" class="kn ko hh ke b fi kp kq l kr ks">print(num_list[::-1])</span></pre><p id="6b82" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="2b01" class="kn ko hh ke b fi kp kq l kr ks">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></pre><p id="857f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当我们将<code class="du kb kc kd ke b">step</code>设置为<code class="du kb kc kd ke b">-1</code>时，Python在内部交换了<code class="du kb kc kd ke b">start</code>和<code class="du kb kc kd ke b">stop</code>索引，从而给我们一个颠倒的列表。</p><p id="d4f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，如果要求您在不使用Python内置的<code class="du kb kc kd ke b">reverse</code>方法的情况下反转字符串<code class="du kb kc kd ke b">"hello"</code>，您可以通过运行以下代码行使用切片来完成此操作:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="ed9e" class="kn ko hh ke b fi kp kq l kr ks">print("hello"[::-1])</span></pre><p id="5907" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">输出:</p><pre class="kf kg kh ki fd kj ke kk kl aw km bi"><span id="94a4" class="kn ko hh ke b fi kp kq l kr ks">"olleh"</span></pre></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="7964" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><em class="mr">最后，问你一个问题:</em></p><p id="7877" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">你能想出不同的方法从<code class="du kb kc kd ke b">num_list</code>中提取奇数列表，并按降序排列吗？</p></div><div class="ab cl mk ml go mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ha hb hc hd he"><p id="5b13" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">本帖原载<a class="ae it" href="https://www.vasudhajha.com/post/slicing-in-python/" rel="noopener ugc nofollow" target="_blank">此处</a>。如果你想阅读更多关于Python基础的帖子，你可以在这里找到它们。</p><p id="7309" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>