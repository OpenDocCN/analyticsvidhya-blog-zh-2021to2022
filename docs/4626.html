<html>
<head>
<title>JSONField Schema Validation in Django Rest Framework using Insomnia</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Django Rest框架中使用失眠症的JSONField模式验证</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/jsonfield-schema-validation-in-django-rest-framework-using-insomnia-a743923a5c0?source=collection_archive---------0-----------------------#2021-12-02">https://medium.com/analytics-vidhya/jsonfield-schema-validation-in-django-rest-framework-using-insomnia-a743923a5c0?source=collection_archive---------0-----------------------#2021-12-02</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="ae50" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在熟悉可以用来验证DJANGO Rest框架中jsonfields的方法之前，人们不禁会注意到，除了其他非json字段之外，在POST-ing中，是否包含以下内容并不重要:</p><ol class=""><li id="e2ab" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">空的jsonfield或</li><li id="ba2d" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">具有各种类型值的已填充jsonfield</li></ol><p id="a807" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们考虑下面的例子来理解上面的内容:</p><p id="4799" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">models.py:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="c890" class="ka kb hi jw b fi kc kd l ke kf">from django.db import models</span><span id="0dbe" class="ka kb hi jw b fi kg kd l ke kf">class Student(models.Model):<br/>    student_name=models.CharField(max_length=100)<br/>    roll_no=models.IntegerField()<br/>    detailed_data=models.JSONField()</span></pre><p id="3508" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">serializers.py:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="0fc6" class="ka kb hi jw b fi kc kd l ke kf">from rest_framework import serializers<br/>from studentapp.models import Student</span><span id="15fa" class="ka kb hi jw b fi kg kd l ke kf">class StudentSerializer(serializers.ModelSerializer):<br/>    class Meta:<br/>        model=Student<br/>        fields='__all__'</span></pre><p id="df6c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">views.py:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="c840" class="ka kb hi jw b fi kc kd l ke kf">from studentapp.serializers import StudentSerializer<br/>from rest_framework.views import APIView<br/>from rest_framework.response import Response<br/>from django.http import JsonResponse,HttpResponse<br/>from rest_framework import status</span><span id="c0b0" class="ka kb hi jw b fi kg kd l ke kf">class StudentView(APIView):<br/>    def post(self,request):<br/>        serializer=StudentSerializer(data=request.data)<br/>        if serializer.is_valid():<br/>            serializer.save()<br/>            return   Response(serializer.data,status=status.HTTP_201_CREATED)#inside if serializer.is_valid()<br/>        return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST) #when serializer is not valid</span></pre><p id="fb2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">urls.py</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="6421" class="ka kb hi jw b fi kc kd l ke kf">from django.contrib import admin<br/>from django.urls import path,include<br/>from studentapp.views import StudentView</span><span id="f5c2" class="ka kb hi jw b fi kg kd l ke kf">urlpatterns = [ <br/>    path('student/',StudentView.as_view()),<br/>]</span></pre><p id="6003" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从上面的学生模型中可以看出，我们有3个字段:一个是字符字段，另一个是整数字段，最后是jsonfield。借助下面的截图，我们将看到开头提到的两点是如何发挥作用的。</p><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kh"><img src="../Images/9acee078575034d6dfac49d21f8620f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xk293NH9PIk0ExG9Xo3YCQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">在JSON field“detailed _ data”中输入空值时</figcaption></figure><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kt"><img src="../Images/1ba51111499eefdc0d326db2447e9384.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0ZSVqTAH2V5vEDEdw4713g.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">当将键值对输入到out jsonfield中时</figcaption></figure><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es ku"><img src="../Images/a784b2869b51d9da04206e63611dfc7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7rJhnbhKF8aJYyaYHTctQ.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">当输入词典列表时</figcaption></figure><p id="a4b0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的JSONField字段“detailed_data”似乎没有遵循定义的结构。这就是关键词“模式”发挥作用的地方。Schema是JSONField字段需要遵循的大纲或结构。如果我们在失眠中输入到“详细数据”中的数据/值符合结构(模式)，那么我们可以说“详细数据”的验证是成功的，但是，如果为“详细数据”中的字段输入的值的类型不同于模式中定义的类型，或者如果“详细数据”中的任何字段缺失；这意味着我们遇到了验证错误。让我们通过深入学生模型中的“detailed_data”字段来理解这一点。</p><p id="18b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们按照下面的“detailed _ data”JSON field中的字段布局:</p><ol class=""><li id="53b8" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated">加入日期—日期格式</li><li id="615a" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">母亲的名字—字符类型</li><li id="34aa" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">父亲的名字—字符类型</li><li id="2fe0" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">教师信息—字典包括:姓名、出生日期、部门、加入日期</li><li id="7034" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第一学期科目——字典列表，每个字典包括:科目名称、分数</li><li id="e01f" class="jd je hi ih b ii jm im jn iq jo iu jp iy jq jc ji jj jk jl bi translated">第二学期主题——另一份字典列表，其结构和子领域与第三学期相同。</li></ol><p id="49ef" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">鉴于上述情况，我们的目标是首先检查序列化(关于“学生姓名”和“学生编号”)是否有效(通过基本序列化检查)，然后通过与模式进行比较来检查“详细数据”内容的有效性。您可以执行以下任一操作:手动编写模式(或)使用JSONModels。推荐使用后者，因为它可以自动生成模式，但是为了了解模式的样子，让我们来看一下这两种方法:</p><ol class=""><li id="760f" class="jd je hi ih b ii ij im in iq jf iu jg iy jh jc ji jj jk jl bi translated"><strong class="ih hj">手动编写模式</strong></li></ol><p id="20bd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">前面提到的布局模式如下:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="38a4" class="ka kb hi jw b fi kc kd l ke kf">{   "type":"object",<br/>    "properties": {<br/>     "date_of_joining": {"type":     "string","pattern":'^[0-9]{2}-[0-9]{2}-[0-9]{4}$'},<br/>     "mother_name":{"type":"string"},<br/>     "father_name":{"type":"string"},<br/>     "teacher_information": {<br/>                "type":"object",<br/>                "properties":{<br/>                   "name": {"type": "string"},<br/>                   "date_of_birth": {"type":"string","pattern":'^[0-9]{2}-[0-9]{2}-[0-9]{4}$'},<br/>                   "department":{"type":"string"},<br/>                   "joining_date":{"type":"string","pattern":'^[0-9]{2}-[0-9]{2}-[0-9]{4}$'}<br/>                        },<br/>                 "required":["name","date_of_birth","department","joining_date"],  --(1)<br/>                        "additionalProperties": False<br/>                    },<br/>     "semester_1_subjects":{<br/>                 "type":"array",<br/>                 "items":{<br/>                      "type":"object",<br/>                      "properties":{<br/>                           "subject_name":{"type":"string"},<br/>                           "professor":{"type":"string"},<br/>                           "score":{"type":"integer"}<br/>                            },<br/>                       "required":["subject_name","professor","score"],                 --(2)<br/>                       "additionalProperties":False<br/>                        }<br/>                    },<br/>     "semester_2_subjects":{<br/>                 "type":"array",<br/>                 "items":{<br/>                     "type":"object",<br/>                     "properties":{<br/>                         "subject_name":{"type":"string"},<br/>                         "professor":{"type":"string"},<br/>                         "score":{"type":"integer"}<br/>                        },<br/>                      "required":["subject_name","professor","score"],                --(3)<br/>                      "additionalProperties":False<br/>                        }<br/>                    }<br/>                },<br/>                "required":["date_of_joining","mother_name","father_name","teacher_information","semester_1_subjects","semester_2_subjects"],       --(4)<br/>                "additionalProperties":False<br/>            }</span></pre><p id="e7cd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在(1)中作为“必需”键的“值”的字段列表意味着必须包括那些字段(在teacher_information中),如果它们中的任何一个被遗漏，就会产生验证错误。这同样适用于第(2)和第(3)行。然而,( 4)处理的是场的外层。(1)、(2)和(3)处理在“教师信息”、“学期1 _科目”和“学期2 _科目”中包含字段的强制，(4)处理除了整体上包含上述字段之外的相同情况。</p><p id="dbff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在让我们将我们的模式包含在views.py中，并使用Draft7Validator将我们输入的内容与定义的模式进行比较。</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="2f27" class="ka kb hi jw b fi kc kd l ke kf">import jsonschema<br/>from jsonschema import Draft7Validator</span><span id="8b43" class="ka kb hi jw b fi kg kd l ke kf">class StudentView(APIView):<br/>    def post(self,request):<br/>        data=request.data<br/>        serializer=StudentSerializer(data=request.data)<br/>        if serializer.is_valid():<br/>            myschema= #insert above defined schema here<br/>            v=Draft7Validator(myschema)<br/>            if len(list(v.iter_errors(data["detailed_data"])))!=0:<br/>                return Response({"error":str(list(v.iter_errors(data["detailed_data"])))})<br/>            else:<br/>                serializer.save()<br/>                return Response(serializer.data,status=status.HTTP_201_CREATED)<br/>       else:<br/>         return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST)</span></pre><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kv"><img src="../Images/6a2b670550d4b59214ba47bfc53e87ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qlb_z1mrCyO7CqK-SliI3A.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">数据发布的正确类型示例</figcaption></figure><p id="7b8a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在上面的图像中，您可以观察到所有字段的值都与模式中写入的类型完全相同，此外，完全没有丢失字段，这导致特定条目被保存，没有任何验证错误。让我们尝试在中做一些更改，看看验证错误是如何显示的。我们不要在“学期_ 2 _科目”中包含第一个“教授”键-值对，对于“学期_ 1 _科目”中的第二个“科目_名称”也是如此。让我们为“教师信息”中的“部门”写一个整型值，为“加入日期”写一个错误的模式。</p><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kw"><img src="../Images/534f5bd9d73f5a3f1a5b5aa5d24929cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKnAyXdncbfSN38ggArv3w.png"/></div></div><figcaption class="kp kq et er es kr ks bd b be z dx translated">验证错误消息的显示</figcaption></figure><p id="f1ec" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">至此，我们已经涵盖了各种类型的验证错误。</p><p id="5cba" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这种方法需要我们手动编写模式，但是如果您不希望自己编写模式，而是希望有人为您代劳，该怎么办呢？这就是JSON模型发挥作用的地方。</p><p id="761c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj"> 2。使用JSON模型</strong></p><p id="f232" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了能够生成前面的模式，我们需要在models.py中添加以下内容</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="986b" class="ka kb hi jw b fi kc kd l ke kf">from jsonmodels import models as m1,fields</span><span id="55f2" class="ka kb hi jw b fi kg kd l ke kf">class teacherField(m1.Base):<br/>    name=fields.StringField(required=True)<br/>    date_of_birth=fields.DateField(required=True)<br/>    department=fields.StringField(required=True)<br/>    joining_date=fields.DateField(required=True)</span><span id="94fe" class="ka kb hi jw b fi kg kd l ke kf">class sem1Field(m1.Base):<br/>    subject_name=fields.StringField(required=True)<br/>    professor=fields.StringField(required=True)<br/>    score=fields.IntField(required=True)</span><span id="a5db" class="ka kb hi jw b fi kg kd l ke kf">class sem2Field(m1.Base):<br/>    subject_name=fields.StringField(required=True)<br/>    professor=fields.StringField(required=True)<br/>    score=fields.IntField(required=True)</span><span id="e26a" class="ka kb hi jw b fi kg kd l ke kf">class detailed_data_field(m1.Base):<br/>    date_of_joining=fields.DateField(required=True)<br/>    mother_name=fields.StringField(required=True)<br/>    father_name=fields.StringField(required=True)<br/>    teacher_information=fields.EmbeddedField(teacherField)<br/>    semester_1_subjects=fields.EmbeddedField(sem1Field)<br/>    semester_2_subjects=fields.EmbeddedField(sem2Field)</span></pre><p id="ce96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的新观点. py:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="5fa0" class="ka kb hi jw b fi kc kd l ke kf">class StudentView(APIView):<br/>    def post(self,request):<br/>        data=request.data<br/>        serializer=StudentSerializer(data=request.data)<br/>        if serializer.is_valid():<br/>            data1=detailed_data_field()<br/>            myschema=data1.to_json_schema()<br/>            print(myschema)<br/>            v=Draft7Validator(myschema)<br/>            if len(list(v.iter_errors(data["detailed_data"])))!=0:<br/>                return Response({"error":str(list(v.iter_errors(data["detailed_data"])))})<br/>            else:<br/>                serializer.save()<br/>                return Response(serializer.data,status=status.HTTP_201_CREATED)<br/>        else:<br/>            return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST)</span></pre><p id="eebd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">生成的架构:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="acaf" class="ka kb hi jw b fi kc kd l ke kf">{<br/>    "type": "object",<br/>    "additionalProperties": False,<br/>    "properties": {<br/>        "date_of_joining": {"type": "string"},<br/>        "father_name": {"type": "string"},<br/>        "mother_name": {"type": "string"},<br/>        "semester_1_subjects": {<br/>            "type": "object",<br/>            "additionalProperties": False,<br/>            "properties": {<br/>                "professor": {"type": "string"},<br/>                "score": {"type": "number"},<br/>                "subject_name": {"type": "string"},<br/>            },<br/>            "required": ["professor", "score", "subject_name"],<br/>        },<br/>        "semester_2_subjects": {<br/>            "type": "object",<br/>            "additionalProperties": False,<br/>            "properties": {<br/>                "professor": {"type": "string"},<br/>                "score": {"type": "number"},<br/>                "subject_name": {"type": "string"},<br/>            },<br/>            "required": ["professor", "score", "subject_name"],<br/>        },<br/>        "teacher_information": {<br/>            "type": "object",<br/>            "additionalProperties": False,<br/>            "properties": {<br/>                "date_of_birth": {"type": "string"},<br/>                "department": {"type": "string"},<br/>                "joining_date": {"type": "string"},<br/>                "name": {"type": "string"},<br/>            },<br/>            "required": ["date_of_birth", "department", "joining_date", "name"],<br/>        },<br/>    },<br/>    "required": ["date_of_joining", "father_name", "mother_name"],<br/>}</span></pre><p id="c593" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">据我所知，关于Josn模型必须提供的不同类型的字段，没有一个能为模式中的指定字段生成“type”:“array”。例如，当我们需要type:array时，我们的“学期_1_subjects”和“学期_2_subjects”字段在模式中有一个type:object。让我们将第一种方法模式中的学期1科目部分与上面模式中的进行比较</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="3524" class="ka kb hi jw b fi kc kd l ke kf"># FROM NEW SCHEMA </span><span id="d2f6" class="ka kb hi jw b fi kg kd l ke kf">"semester_1_subjects": {<br/>            "type": "object",<br/>            "additionalProperties": False,<br/>            "properties": {<br/>                "professor": {"type": "string"},<br/>                "score": {"type": "number"},<br/>                "subject_name": {"type": "string"},<br/>            },<br/>            "required": ["professor", "score", "subject_name"],<br/>        }</span><span id="26f2" class="ka kb hi jw b fi kg kd l ke kf">#FROM OLDER SCHEMA</span><span id="82c3" class="ka kb hi jw b fi kg kd l ke kf">"semester_1_subjects":{<br/>            "type":"array",<br/>            "items":{<br/>                    "type":"object",<br/>                    "properties":{<br/>                           "subject_name":{"type":"string"},<br/>                           "professor":{"type":"string"},<br/>                           "score":{"type":"integer"}<br/>                            },<br/>                    "required":["subject_name","professor","score"],                 <br/>                    "additionalProperties":False<br/>                        }<br/>                    }</span></pre><p id="1573" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们需要使学期_ 1 _科目的新模式看起来像旧的模式。学期_ 2 _科目字段也是如此。为此，我们在视图中做了一些更改，以便稍微操作新的自动生成的模式，使其看起来像旧的模式。在新的模式中，我们可以看到最后一个“必填”字段中没有“学期_ 1 _科目”、“学期_ 2 _科目”和“教师_信息”，并且与日期相关的字段没有任何约束，如格式等。，它只有“类型”:“字符串”。让我们通过在JSON模型的帮助下对交给我们的模式进行操作来纠正所有这些问题。</p><p id="f485" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的更新视图. py:</p><pre class="jr js jt ju fd jv jw jx jy aw jz bi"><span id="f454" class="ka kb hi jw b fi kc kd l ke kf">class StudentView(APIView):<br/>    def post(self,request):<br/>        data=request.data<br/>        serializer=StudentSerializer(data=request.data)<br/>        if serializer.is_valid():<br/>            data1=detailed_data_field()<br/>            myschema=data1.to_json_schema()<br/>            myfields=['semester_1_subjects','semester_2_subjects']<br/>            for i in myfields:<br/>                d={}<br/>                d["items"]=myschema["properties"][i]<br/>                myschema["properties"][i]=d<br/>                myschema["properties"][i]["type"]="array"<br/>                 #end of loop<br/>myschema["required"].extend(["teacher_information","semester_1_subjects","semester_2_subjects"])<br/>            myschema["properties"]["date_of_joining"]["pattern"]='^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}$'<br/>            myschema["properties"]["teacher_information"]["date_of_birth"]='^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{6}$'<br/>            v=Draft7Validator(myschema)<br/>            if len(list(v.iter_errors(data["detailed_data"])))!=0:<br/>                return Response({"error":str(list(v.iter_errors(data["detailed_data"])))})<br/>            else:<br/>                serializer.save()<br/>                return Response(serializer.data,status=status.HTTP_201_CREATED)<br/>        else:<br/>            return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST)</span></pre><p id="6f4f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们像以前一样检查无效的值输入和字段缺失，以检查有效性验证。</p><figure class="jr js jt ju fd ki er es paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="er es kx"><img src="../Images/66bf67ea3d97a33c7714fbd1bf1f7f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ijmdHTXhEOfCpOnqsfdeIw.png"/></div></div></figure><p id="f9d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它工作得很好！jsonmodels中可能有字段，它将嵌入式字段与一个特性结合起来，构成了一个“类型”:“数组”，但就我目前所知，没有任何字段。如果有什么有助于实现同样的目标，请在评论区告诉我们吧！</p></div></div>    
</body>
</html>