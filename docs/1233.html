<html>
<head>
<title>3D Surface generation from video using OpenCV and numpy.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OpenCV和numpy从视频生成三维表面。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/3d-surface-generation-from-video-using-opencv-and-numpy-b4e068e054b5?source=collection_archive---------4-----------------------#2021-02-21">https://medium.com/analytics-vidhya/3d-surface-generation-from-video-using-opencv-and-numpy-b4e068e054b5?source=collection_archive---------4-----------------------#2021-02-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><h1 id="9545" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">介绍</h1><p id="8795" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我最近开始探索计算机视觉领域，它吸引了我。可能性只受到我们想象力(和技能)的限制。随着深度学习和神经网络的进步，计算机视觉应用飞速发展。这是我在计算机视觉领域写一个新故事的尝试。由于我是这个领域的新手，请原谅我的错误，但我鼓励你在这个帖子上评论它们。我没有详细解释代码，因为我认为这个概念更重要。</p></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><h1 id="971f" class="if ig hi bd ih ii ki ik il im kj io ip iq kk is it iu kl iw ix iy km ja jb jc bi translated">灵感</h1><p id="4542" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">立体视觉和深度感知一直是计算机视觉领域的研究热点之一。作为一名机械工程师，从物理零件创建3D模型是一项挑战。在这篇文章中解释的技术是一种比现有的其他先进系统更便宜的替代方案。虽然，我不确定这种技术是否已经可用或者已经被研究过了。所以让我们深入了解这个概念。</p><h1 id="b888" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">概念</h1><p id="092a" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">假设一个光源在一个表面上投射一条直线，光源垂直于该表面。从某个角度观察时，它看起来会像下面这样:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es kn"><img src="../Images/17eb1daebf3bf404c5d9d32e4307f793.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*Kg7T5Oj83eB1KtUS-mY6HA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">没有对象的概念设置</figcaption></figure><p id="4615" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">如果将一个物体放在平面上，光线会从物体上反射，看起来会像这样:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es le"><img src="../Images/f5c866b627ae94427681c8127b1197d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*VtHonLqIGZlYjCeQRawjLA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">带有对象的概念设置</figcaption></figure><p id="bce1" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">当从一个角度看时，从光源投射的直线会看起来是断开的。两条虚线之差与物体的深度(或高度)成正比。如果我们有连续的图像帧，我们可以在每一帧创建一个贴图，并将其堆叠在一起，以创建对象的3D贴图。</p><p id="9360" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">为了沿着物体长度的不同距离创建连续的图像帧，光源沿着长度向前(或向后)移动。为了保持图像的比例不变，观察者(在我们的例子中是照相机)必须在相同的方向上移动相同的距离。下面的视频将使它变得容易理解:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lf"><img src="../Images/7432a34dcb92897ac1ae4a9885de33df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*EACDtj-Ja6YyN1JUoZIS0A.gif"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">概念设置</figcaption></figure><h1 id="d3cb" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">设置和排列</h1><p id="8d13" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">为了进行这个实验的设置，我使用了我的GoPro工具包和自行车上使用的激光发射器的部件。我尽我所能利用现有的资源，发现了一些有趣的结果。我建造的复杂(双关语)设备如下所示:</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lf"><img src="../Images/9786fa84fd4187cfbe593ef0c10cb0cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*dZuD2_t-pd9mZCm3Wc-Iog.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">灯光和摄像机布置</figcaption></figure><p id="8f5c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">这种设置是手动推送的，因此视频记录是不稳定的，但它们仍然可以证明这个概念。我将尝试通过使用更好的光源，专用相机和电动动作来改善这一点。</p><h1 id="9d65" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">最终视频记录</h1><p id="bd60" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">该视频是在手机上录制的，然后被剪切到以下分辨率。视频中的物体是一个门楔。你可以看到物体的高度逐渐增加，虚线之间的间隙也是如此。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lf"><img src="../Images/331504e1731f109177f298cf092422bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*XVeHi6cpYQWwqgq0Q7Q1TA.gif"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">裁剪视频记录</figcaption></figure><p id="375a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">将需要的Python库:</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="102c" class="ll ig hi lh b fi lm ln l lo lp">import cv2<br/>import numpy as np<br/>import matplotlib.pyplot as plt<br/>import math<br/>import os<br/>import itertools<br/>from stl import mesh</span></pre><h1 id="a0fe" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">计算深度(高度)</h1><p id="db4b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">虚线之间的间隙与深度(或高度)成正比。我们需要根据差距计算出准确的深度。为了计算实际距离，我们将使用简单的三角学。下图中，<em class="lq"> A </em>为<em class="lq">实际距离</em>，<em class="lq"> P </em>为<em class="lq">在相机平面上的投影距离</em>。摄像机与水平线成一个角度<em class="lq"> θ </em>。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lr"><img src="../Images/322a787491b218b30345396e24d70d54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lrvuk9uS7tr_keqQWxA7_w.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">相机平面上的投影</figcaption></figure><p id="265a" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">如下图所示，实际距离(A)可以通过将投影距离(P)除以角度(90- <em class="lq"> θ </em>)的<em class="lq">余弦</em>来计算。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lw"><img src="../Images/152dfeda75dc12d984ca3a8f3ca01f82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*jL5RGd9wSj86DagBX4uDGQ.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">实际距离公式</figcaption></figure><p id="083b" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">让我们做一个函数，当给定投影距离和摄像机角度时，它会给出实际距离。</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="f017" class="ll ig hi lh b fi lm ln l lo lp">def inc_str(x, angle_a):<br/>    #x is the distance or number of row<br/>    #angle_a is the angle of camera<br/>    cos_val = math.cos(math.radians(90-angle_a))<br/>    x_depth = x / cos_val<br/>    return(x_depth)</span></pre><h1 id="8533" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">图像预处理和创建数组</h1><p id="00fd" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我们将从图像帧中去除噪声。噪声将包括除光的直线以外的一切。我使用了一些阈值，掩蔽和一些基本的形态变换。每一帧一个接一个地堆叠起来，形成一个三维阵列，如下所示。其中Z是帧数。数字Z起着重要的作用，因为它定义了将要生成的3D模型的长度。可以通过调节光源和摄像机移动的速度来控制帧数。但是因为我是手动操作的，所以我尽了最大努力来得到一个看起来不错的模型。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lx"><img src="../Images/ddda9e7b8e76f974d552f0a824a9c064.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*JWG_kw3U0kJpGbGfZcHiTA.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">堆叠图像的Numpy数组</figcaption></figure><p id="32ab" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此步骤的代码:</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="f6c1" class="ll ig hi lh b fi lm ln l lo lp">cap = cv2.VideoCapture('sample5_cropped.mp4')<br/>image_3D =[]<br/>counter=0 #counter will help us keep the size if the final output<br/>lower_red = np.array([168,120,70])<br/>upper_red = np.array([210,255,255])<br/>kernel = np.ones((3, 3), np.uint8)<br/>length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))</span><span id="665e" class="ll ig hi lh b fi ly ln l lo lp">for i in range(length):<br/>    ret, img = cap.read()<br/>    if counter%1==0:<br/>        #dilate and erode to make the light continous<br/>        #img = cv2.flip(img, 0)<br/>        img = cv2.dilate(img, kernel = kernel, iterations = 8)<br/>        img = cv2.erode(img, kernel = kernel, iterations = 8)<br/>        #convert to HSV for masking<br/>        img_hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)<br/>        #create mask 1<br/>        mask1 = cv2.inRange(img_hsv, lower_red, upper_red)<br/>        res = cv2.bitwise_and(img,img, mask= mask1)<br/>        #dilate and erode to remove sharp edges<br/>        res = cv2.erode(res, kernel, iterations = 4)<br/>        res = cv2.dilate(res, kernel, iterations=5)<br/>        #convert res to gray and thresholding<br/>        res = cv2.cvtColor(res, cv2.COLOR_BGR2GRAY)<br/>        ret, res = cv2.threshold(res, 0, 255, cv2.THRESH_BINARY)<br/>        #create mask 2<br/>        mask2 = cv2.bitwise_not(res)<br/>        #apply mask 2 on original image<br/>        result = cv2.bitwise_and(img, img, mask = mask2)<br/>        result = cv2.cvtColor(result, cv2.COLOR_BGR2GRAY)<br/>        ret, thresh = cv2.threshold(result, 100, 255, cv2.THRESH_BINARY)<br/>        thresh = cv2.bitwise_not(thresh)<br/>        new_row_lenght = round(inc_str(thresh.shape[0], 40))<br/>        new_array = np.full((new_row_lenght, thresh.shape[1]), 254, dtype='uint8')<br/>        for i in range(thresh.shape[1]):<br/>            for j in range(thresh.shape[0]):<br/>                new_j = round(inc_str(j, 39.940))<br/>                new_array[new_j, i] = thresh[j, i]<br/>        ret, new_array = cv2.threshold(new_array, 254, 255, cv2.THRESH_BINARY)<br/>        new_array = cv2.dilate(new_array, kernel)<br/>        new_array[721,:] = 0 # this will create a black line at the end of every image. this will act like a base line for the 3D model<br/>        #print('new image shape: ',new_array.shape)<br/>        image_3D.append(new_array)<br/>    else:<br/>        pass<br/>    counter+=1</span><span id="7dc7" class="ll ig hi lh b fi ly ln l lo lp">image_3D = np.array(image_3D)</span></pre><h1 id="f62a" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">提取曲面的顶点</h1><p id="7508" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">一旦我们有了堆叠的框架数组，我们必须提取将用于创建表面的顶点。对创建表面有用的顶点是位于直线上的顶点。我们将找到3D数组中的顶点，并将它们添加到一个单独的列表中。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es lf"><img src="../Images/3c85b659256ca0dd5895bd51d7edf9d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*WA_ewTJwYwO5R0idbSNGIw.gif"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">提取表面所需的顶点</figcaption></figure><p id="ad0c" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此步骤的代码:</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="91c5" class="ll ig hi lh b fi lm ln l lo lp">vertices_list = []</span><span id="c132" class="ll ig hi lh b fi ly ln l lo lp">for i, k in itertools.product(range(image_3D.shape[0]), range(image_3D.shape[2])):<br/>    for j in range(image_3D.shape[1]):<br/>        if image_3D[i][j][k]==0:<br/>            vertix = [i,j,k]<br/>            vertices_list.append(vertix)<br/>            break<br/>vertices_list = np.array(vertices_list)</span></pre><h1 id="803b" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用顶点创建面:第一部分</h1><p id="e20d" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">现在我们有了所有帧的所有顶点。但是这些顶点是列表的形式，我们必须将它们排列成一个2X2的表格，这样我们就可以从它们创建面。为此，我们将创建一个shape (Y，Z)的空数组。其中Z是帧的数量(参见图<em class="lq">图像堆叠的Numpy数组</em>), Y是帧的宽度。我们将用之前提取的顶点填充这个空数组，这样形状(Z，X，Y)的3D数组现在被压缩成形状(Y，Z)的2D数组。下图可能有助于理解这一点。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es lz"><img src="../Images/3e964a12c72f51b647041a3d70b00ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMltB4YTV_VClGtbKOtQ9w.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">从顶点创建数组</figcaption></figure><p id="1328" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此步骤的代码:</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="25ef" class="ll ig hi lh b fi lm ln l lo lp">ncol = image_3D.shape[0]<br/>nrow = image_3D.shape[2]<br/>ndepth = image_3D.shape[0]</span><span id="3d2b" class="ll ig hi lh b fi ly ln l lo lp">new_array = np.zeros((ndepth, nrow, 3))</span><span id="6e07" class="ll ig hi lh b fi ly ln l lo lp">for x in range(vertices_list.shape[0]):<br/>    i = vertices_list[x][0]<br/>    j = vertices_list[x][1]<br/>    k = vertices_list[x][2]<br/>    <br/>    new_array[i][k] = vertices_list[x]</span></pre><h1 id="0e82" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用顶点创建面:第二部分</h1><p id="e26b" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">要定义一个面(表面),我们至少需要3个点。我们将使用3个顶点创建三角形面，然后使用numpy stl将它们网格化。如下图所示，将使用2X2顶点块创建2组面。这个过程将在整个2D阵列(Y，Z)上循环。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es ma"><img src="../Images/692e7b07a7400b91f0952afa40880aee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*uIayYdB2B-wJphdL8XiZJw.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">将用于创建面的3个点</figcaption></figure><p id="5f4f" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">此步骤的代码:</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="5b36" class="ll ig hi lh b fi lm ln l lo lp">faces = []</span><span id="2bd3" class="ll ig hi lh b fi ly ln l lo lp">for x in range(0,ncol-1):<br/>    for y in range(0, nrow-1):<br/>        #for traingular face 1<br/>        if np.all(new_array[x][y]!=0):<br/>            v1 = new_array[x][y]<br/>            v2 = new_array[x+1][y]<br/>            v3 = new_array[x+1][y+1]<br/>            face1 = np.array([v1, v2, v3])</span><span id="cc71" class="ll ig hi lh b fi ly ln l lo lp">            #for traingular face 2<br/>            v1 = new_array[x][y]<br/>            v2 = new_array[x][y+1]<br/>            v3 = new_array[x+1][y+1]</span><span id="52c1" class="ll ig hi lh b fi ly ln l lo lp">            face2 = np.array([v1, v2, v3])</span><span id="3882" class="ll ig hi lh b fi ly ln l lo lp">            faces.append(face1)<br/>            faces.append(face2)<br/>        else:<br/>            pass<br/>face_array = np.array(faces)</span></pre><h1 id="b158" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">使用numpy stl网格化面</h1><p id="d9d6" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">最后一步是将我们之前创建的面和顶点传递给numpy stl网格，等待它发挥它的魔力。</p><pre class="ko kp kq kr fd lg lh li lj aw lk bi"><span id="7a10" class="ll ig hi lh b fi lm ln l lo lp">surface = mesh.Mesh(np.zeros(face_array.shape[0], dtype = mesh.Mesh.dtype))</span><span id="9e5a" class="ll ig hi lh b fi ly ln l lo lp">for i, f in enumerate(faces):<br/>    for j in range(3):<br/>        surface.vectors[i][j] = face_array[i][j]</span><span id="1668" class="ll ig hi lh b fi ly ln l lo lp">#to save the stl file of the surface<br/>surface.save('surface5_1.stl')</span></pre><h1 id="f958" class="if ig hi bd ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc bi translated">结果</h1><p id="d354" class="pw-post-body-paragraph jd je hi jf b jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka hb bi translated">我在上面显示的视频上尝试了代码(<em class="lq">剪辑视频记录</em>)。视频中的物体是一个简单的门楔，看起来像这样。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div role="button" tabindex="0" class="ls lt di lu bf lv"><div class="er es mb"><img src="../Images/05e05ce432b42c74ed4caa66386485a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aZ2BSMSVf7VT_nSkHbaEgQ.png"/></div></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">用于试验的门楔</figcaption></figure><p id="9125" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">下面是使用本文中解释的代码和概念创建的stl文件的图像。</p><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mc"><img src="../Images/63e1245179d2fe57e41b3af0908fe6fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*8X4RxxfQ9qK8KXfpsx3ZlQ.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">结果</figcaption></figure><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es md"><img src="../Images/2d298cabb6c04bf4c5166384a01b2ea5.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*pQv1h4YDgZcPyjbgcPIzgQ.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">结果</figcaption></figure><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es me"><img src="../Images/305c1284b6fd496425eba13b1afe498e.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*4PYEo9HHwLK1jXzsH014Sg.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">结果</figcaption></figure><figure class="ko kp kq kr fd ks er es paragraph-image"><div class="er es mf"><img src="../Images/4752b2019aaee9e32298ec270141a56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*cG-tY7q8Ks2Zy8ppbJtlEQ.png"/></div><figcaption class="kv kw et er es kx ky bd b be z dx translated">结果</figcaption></figure></div><div class="ab cl kb kc gp kd" role="separator"><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg kh"/><span class="ke bw bk kf kg"/></div><div class="hb hc hd he hf"><p id="d310" class="pw-post-body-paragraph jd je hi jf b jg kz ji jj jk la jm jn jo lb jq jr js lc ju jv jw ld jy jz ka hb bi translated">感谢你阅读这篇文章。请做评论，我真的很感谢你的投入和建议。</p></div></div>    
</body>
</html>