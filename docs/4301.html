<html>
<head>
<title>This is how a neural network learns to add, multiply and compare handwritten digits</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这就是神经网络如何学习手写数字的加法、乘法和比较</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/this-is-how-a-neural-network-learns-to-add-multiply-and-compare-handwritten-digits-b041198c9759?source=collection_archive---------2-----------------------#2021-09-20">https://medium.com/analytics-vidhya/this-is-how-a-neural-network-learns-to-add-multiply-and-compare-handwritten-digits-b041198c9759?source=collection_archive---------2-----------------------#2021-09-20</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><h1 id="daef" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">却不知道他们的价值观！</h1><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/1fd85e52046a545e747613a4c59b9ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OD8Ga5An-xLm3TkcqGhjVA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">dl png[<a class="ae js" href="https://dlpng.com/png/6906777" rel="noopener ugc nofollow" target="_blank">https://dlpng.com/png/6906777</a>提供</figcaption></figure><p id="022d" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">我在<a class="ae js" href="https://jovian.ai/outlink?url=https%3A%2F%2Fblog.jovian.ai%2Fhow-to-train-supervised-machine-learning-algorithms-without-labeled-data-6ebddc01a00f" rel="noopener ugc nofollow" target="_blank">之前的一篇文章</a>中描述过，自动编码器在自动贴标中有多有用。这些网络的主要特性是它们能够学习数据中的特征/模式。事实上，这不是自动编码器特有的，可以使用其他无人监管的技术来实现，主要是<strong class="jv hi"> PCA </strong>。<br/>检测和学习数据特征的能力可以用于其他领域。</p><p id="ccaa" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">在这篇文章中，我将展示一个自动编码器的应用。这将通过两个步骤实现:</p><ul class=""><li id="d04e" class="kr ks hh jv b jw jx ka kb ke kt ki ku km kv kq kw kx ky kz bi translated">首先，卷积自动编码器将在MNIST数据上被训练。</li><li id="9c99" class="kr ks hh jv b jw la ka lb ke lc ki ld km le kq kw kx ky kz bi translated">在编码器和解码器的训练之后，我们将冻结它们的权重，并使用它们和附加的密集层来“学习”算术运算，即加法、乘法和比较。</li></ul><p id="2dd6" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">诀窍是<em class="lf">永远不要</em>明确地将<strong class="jv hi"> MNIST </strong>数据集中的手写数字与它们各自的标签相关联。我们将会看到，神经网络仍然能够在所有情况下对看不见的数据达到97%以上的准确度。</p><p id="1992" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">下图描述了设计的第一步:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lg"><img src="../Images/1ad4b25e06bec922eecf88f5faafc822.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dSUtcXUdGxCA4-2-JKgD0A.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">明斯特自动编码器[图片由作者提供]</figcaption></figure><p id="f1b6" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">第二步，我们将使用与密集层串联的编码器来执行算术运算。我们将只训练密集层权重，并将操作结果作为标签提供。请注意，我们不会提供数字(标签)的值。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lh"><img src="../Images/89a9d99c8b69fb0363821f3aa4beeaf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRan9JHCAlXZXqQWEzHFjA.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">训练网络学习算术运算[图片由作者提供]</figcaption></figure><h1 id="7400" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">在MNIST数据上训练自动编码器</h1><p id="5792" class="pw-post-body-paragraph jt ju hh jv b jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km lm ko kp kq ha bi translated">类似于<a class="ae js" href="https://blog.jovian.ai/how-to-train-supervised-machine-learning-algorithms-without-labeled-data-6ebddc01a00f" rel="noopener ugc nofollow" target="_blank">上一篇文章</a>，我们将在这个实验中使用MNIST数据。自动编码器将使用60000个训练样本来学习手写数字特征。我们使用KERAS库导入MNIST。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="197b" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">我们必须缩放范围<code class="du lp lq lr ls b">[0,1]</code>中的数据，并将其整形为图像的<em class="lf"> KERAS </em>格式(NBR _ samples x width x height x channels)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="f0eb" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">autoencoder架构基于一系列卷积层，它会逐渐将28x28x1图像(784像素)编码为100个元素的阵列，并将该表示解码回原始格式。训练后的结果图像有望与原始图像相似。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="5998" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">然后使用编码器和解码器创建自动编码器:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="868f" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">每个自动编码器输出将被训练为每个像素的二进制分类器。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9246" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">提前停止将防止自动编码器过拟合训练数据。有两种方法可以检查网络性能。首先，我们可以评估测试数据的损失函数。我们期望它接近训练数据上的损失值。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="65d7" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">两个数据集的值非常接近。验证自动编码器的另一种方法是从测试数据中检查随机样本的重构。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="6144" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">一张图胜过千言万语！很明显，重建的<strong class="jv hi">非常接近</strong>原始图像。</p><p id="2f0a" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">既然我们已经有了一个训练有素的编码器和解码器，让我们来关注一下<em class="lf">编码器</em>。对于每幅图像，编码器都会生成一个表示，以捕捉最“有趣”或“重要”的特征。这种表示应该足以使用解码器重构图像。这是我们之前使用的示例图像的表示:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="7b08" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">解码器使用这100个数字，将生成28×28的图像(784像素)。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8d6c" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">这里是<em class="lf">有趣部分</em>开始的地方！使用低维表示，让我们做一些数学计算。</p><h1 id="595c" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">学习手写数字的算术运算</h1><p id="18e0" class="pw-post-body-paragraph jt ju hh jv b jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km lm ko kp kq ha bi translated">这个想法很简单。使用两个图像的表示，我们训练一个神经网络来计算它们的和、它们的积并比较它们。我们将<strong class="jv hi">不提供</strong>每个数字的值，但是我们将在训练步骤中提供<strong class="jv hi">结果</strong>。<br/>我们将对[0–9]范围内的数字执行加法和乘法运算。结果将分别在[0–18]和[0–81]范围内。因此，将使用多个输出对输出进行编码:<br/> 1-总和<strong class="jv hi">单位</strong>，多类输出【0，1，2，3，4，5，6，7，8，9】<br/>2-总和<strong class="jv hi">十位</strong>，二进制输出【0，1】<br/>3-乘法<strong class="jv hi">单位</strong>，多类输出【0，1，2，3，4，5，6，7，8，9】<br/>4-乘法<strong class="jv hi"/></p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es lt"><img src="../Images/6ee7305683e5297d1be733f2f59a74c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dm3hArhmvjZSOsCAFJpE6Q.png"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">模型表示[图片由作者提供]</figcaption></figure><p id="6fb2" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">使用KERAS中的功能API，我们定义了网络架构。首先，我们导入编码器<em class="lf">两次</em>并冻结其权重:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="07b9" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">使用编码器的输出，我们构建模型:</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="8c44" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">该模型有两个输入(两个手写数字图像)和五个输出(和与积加上比较结果的单位和十位)。由于输出的性质，我们将使用两种不同的损耗。请注意，有一个1000个单元的公共隐藏层，然后是五个分支(每个输出一个)。我们需要创建数据集来训练和测试我们的模型。输入将是手写数字的随机组合。输出将是每个组合的预期结果。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="9d3e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">现在我们准备训练我们的模型！</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="744e" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">在训练结束时，所有输出的准确度都相当好(9x%)。让我们先看看模型在测试数据上的表现。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="cbe8" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">结果仍在95%以上的范围内。让我们展示一个模型预测的随机样本。</p><figure class="jd je jf jg fd jh"><div class="bz dy l di"><div class="ln lo l"/></div></figure><p id="4812" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">瞧啊。我们可以通过在更多随机样本上训练模型(增加<code class="du lp lq lr ls b">train_size</code>值)或调整模型架构来提高准确性。也就是说，我们设法建立了一个神经网络，它能够解决手写数字<em class="lf">的基本算术运算，而不需要</em>显式计算它们的值。任务完成。</p><h1 id="e337" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">结论和未来工作</h1><p id="3c35" class="pw-post-body-paragraph jt ju hh jv b jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km lm ko kp kq ha bi translated">在这篇文章中，我们介绍了一个基于MNIST图像的自动编码器。在自动编码器训练期间，<strong class="jv hi">编码器</strong>部件学习图像的最重要特征，以便稍后通过<strong class="jv hi">解码器</strong>重建它们。这些特征用于进一步的操作(通过密集或循环层)。我们训练了一个密集的神经网络，与自动编码器串联来学习算术运算。该模型在所有输出上都达到了95%以上的准确率。</p><p id="cdf6" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">自动编码器是无监督学习的一部分。我们仍在触及这些令人惊叹的深度学习技术的表面。我将继续探索这一领域，特别是使用递归神经网络及其在自然语言处理和时间序列中的应用。</p><h1 id="c769" class="ie if hh bd ig ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb bi translated">参考</h1><p id="d1a9" class="pw-post-body-paragraph jt ju hh jv b jw li jy jz ka lj kc kd ke lk kg kh ki ll kk kl km lm ko kp kq ha bi translated">笔记本[<a class="ae js" href="https://jovian.ai/kara-mounir/mnist-autoencoder" rel="noopener ugc nofollow" target="_blank">https://jovian.ai/kara-mounir/mnist-autoencoder</a></p><p id="9448" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">杰森·布朗利[<a class="ae js" href="https://jovian.ai/outlink?url=https%3A%2F%2Fmachinelearningmastery.com" rel="noopener ugc nofollow" target="_blank">https://machinelearningmastery.com</a>]的机器学习大师博客</p><p id="a105" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">我的Github[<a class="ae js" href="https://jovian.ai/outlink?url=https%3A%2F%2Fgithub.com%2Fzaitrik" rel="noopener ugc nofollow" target="_blank">https://github.com/zaitrik</a></p><p id="1649" class="pw-post-body-paragraph jt ju hh jv b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq ha bi translated">我的LinkedIn[<a class="ae js" href="https://jovian.ai/outlink?url=https%3A%2F%2Fwww.linkedin.com%2Fin%2Fmounir-kara-zaitri-a01a00208%2F" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/mounir-kara-zaitri-a01a00208/</a></p></div></div>    
</body>
</html>