<html>
<head>
<title>Classifying CIFAR-10 using a simple CNN</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用简单的CNN对CIFAR-10进行分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classifying-cifar-10-using-a-simple-cnn-4e9a6dd7600b?source=collection_archive---------2-----------------------#2021-08-09">https://medium.com/analytics-vidhya/classifying-cifar-10-using-a-simple-cnn-4e9a6dd7600b?source=collection_archive---------2-----------------------#2021-08-09</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="fa68" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这篇文章中，我们将简单地讨论什么是深度学习，什么是卷积神经网络(CNN)，以及我们如何制作一个简单的CNN模型。本文假设你对人工智能、机器学习和Python编程有一定的基础知识。</p><h1 id="bc32" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">什么是深度学习？</h1><p id="15c9" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">深度学习是机器学习和人工智能的子集之一。深度学习方法试图模仿人类大脑处理数据并在其中寻找模式的功能。深度学习既可以用于监督学习，也可以用于非监督学习。深度学习使用人工神经网络来执行不同的任务，人工神经网络的设计考虑了大脑中神经元的功能。深度学习方法被用于许多不同的领域，例如图像分类、文本生成和天气预报。</p><p id="5d45" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在本文中，我们将创建一个卷积神经网络来分类一些图像。</p><h1 id="c82b" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">卷积神经网络；</h1><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es kf"><img src="../Images/57361ec050803df5d6c64510675c2751.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pvBIhkKTPCtjMEV2"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><a class="ae kv" href="https://www.analyticssteps.com/blogs/convolutional-neural-network-cnn-graphical-visualization-code-explanation" rel="noopener ugc nofollow" target="_blank">来源</a></figcaption></figure><p id="b4e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">卷积神经网络或CNN是一种深度学习方法，通常用于图像分类和特征提取。为了理解CNN是如何工作的，我们首先需要理解一些概念:</p><ul class=""><li id="6daf" class="kw kx hh ig b ih ii il im ip ky it kz ix la jb lb lc ld le bi translated"><strong class="ig hi">图像数据</strong></li><li id="1c46" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><strong class="ig hi">卷积层</strong></li><li id="af76" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><strong class="ig hi">汇集层</strong></li><li id="ce88" class="kw kx hh ig b ih lf il lg ip lh it li ix lj jb lb lc ld le bi translated"><strong class="ig hi">密集层</strong></li></ul><p id="1d1a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">图像数据</strong>:每幅图像由3部分组成:高度、宽度、通道。通道的数量代表图像的深度，并与创建图像时使用的颜色相关。例如，RGB图像有3个通道，每个通道对应一种用于创建图像的原色。因此，对于每个像素，我们有3个(通道数)值，每个值都在0到255之间。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lk"><img src="../Images/b741409315e2a6edc05582f6488f1aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jdRSjJ5_3pe1VCJe"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><a class="ae kv" href="https://www.google.com/url?q=https://www.kdnuggets.com/2019/12/convert-rgb-image-grayscale.html&amp;sa=D&amp;source=editors&amp;ust=1628492555932000&amp;usg=AOvVaw3227oejgIbf8Gqwr93vM1H" rel="noopener ugc nofollow" target="_blank"> 3通道图像</a></figcaption></figure><p id="e452" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">密集层:</strong>密集层是神经网络中的全连接层。密集层中的每个神经元接收来自前一层中所有神经元的信息。密集层是神经网络中最常用的层。具有M个神经元的密集层的输出是M维向量。这种类型的层通常用于神经网络的末端，以确定图像属于哪一类。</p><p id="0294" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">卷积层:</strong>每个卷积神经网络由一个或多个卷积层组成。这些层是CNN的主要构建组件，其任务是在图像中寻找可用于图像分类的模式。密集层用于在图像上寻找全局特征，而卷积层用于检测局部模式。当我们有一个密集连接的层时，该层中的每个节点都可以看到前一层的所有数据。这意味着这一层查看所有的信息，并且只能在全局范围内分析数据。卷积层使用滤波器来实现这种局部模式检测。每个卷积层由几个大小相同的滤波器组成，每个滤波器寻找图像内部的不同信息。滤镜是我们在图像中寻找的m x n像素模式。卷积层的输出深度等于该层中使用的滤波器数量。如果你想了解更多关于过滤器及其工作原理的知识，你可以看看<a class="ae kv" href="https://www.saama.com/different-kinds-convolutional-filters/" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ll"><img src="../Images/79b2e97bf28045c3ea3239667a5a1eea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nQLRQDR8z7ZZT0ig"/></div></div><figcaption class="kr ks et er es kt ku bd b be z dx translated"><a class="ae kv" href="https://www.google.com/url?q=https://indoml.com/2018/03/07/student-notes-convolutional-neural-networks-cnn-introduction/&amp;sa=D&amp;source=editors&amp;ust=1628492588302000&amp;usg=AOvVaw0XinMPijit38Y6G5M31FPX" rel="noopener ugc nofollow" target="_blank">卷积层滤波器的例子</a></figcaption></figure><p id="d286" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">汇集层:</strong>汇集层用于对卷积层的输出进行下采样，并降低其维数。有3种类型的池:最大池，最小池，平均池。池化通常使用步长为2的2x2窗口来完成，这将输出的大小减少了2倍。</p><p id="755b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在我们已经熟悉了卷积神经网络的构建组件，我们可以讨论它的架构以及如何创建它。</p><h1 id="dd29" class="jc jd hh bd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz bi translated">创建模型:</h1><p id="6a91" class="pw-post-body-paragraph ie if hh ig b ih ka ij ik il kb in io ip kc ir is it kd iv iw ix ke iz ja jb ha bi translated">我们将在本文中使用Keras和Tensorflow来创建我们自己的图像分类器。该图像分类器将把<a class="ae kv" href="https://www.cs.toronto.edu/~kriz/cifar.html" rel="noopener ugc nofollow" target="_blank"> Cifar图像数据集</a>中的图像分类到10个可用类别中的一个。该数据集包括60000个32×32的图像，每个类有6000个图像。这些类别的标签是:飞机、汽车、鸟、猫、鹿、狗、青蛙、马、船、卡车。</p><p id="0569" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如上所述，我们将使用Keras和Tensorflow来创建我们的模型。您可以将Keras和Tensorflow安装到您自己的设备中，也可以使用Google Colaboratory等平台为您的模型编写和运行代码。</p><p id="4446" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果你像我一样使用Google Colab笔记本，你必须做的第一件事就是在笔记本内部启用GPU硬件加速。这允许你的模型在训练和测试阶段使用GPU，从而大大加快了这个过程。要激活硬件加速，请单击屏幕顶部的编辑菜单，然后单击笔记本设置，并在新窗口中选择GPU作为硬件加速器。如果您之前运行了笔记本中的任何内容，您需要重置并重新运行代码。</p><p id="f25f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要检查Tensorflow是否连接到GPU，您可以在笔记本中运行下面的代码片段。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lm"><img src="../Images/52eabb8c720c6df1521d6e7a67617500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2CySSR7uomyMNBsPvkVCbA.png"/></div></div></figure><p id="1fd8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现在，我们将加载我们的数据集。为此，我们将使用Keras API来加载Cifar-10数据集。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es ln"><img src="../Images/2ada68db6fb73fe4941049e60f4f13bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sW3oK9XEvvOL4uDPUq6xJA.png"/></div></div></figure><p id="25ac" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">通过运行上面的代码，我们已经下载了Cifar-10数据集，并将其分成训练和测试部分。训练部分用于训练模型，而数据的测试部分用于评估我们模型的准确性。要查看数据集中的实际内容，您可以运行下面的代码来绘制数据集中的一些图像。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lo"><img src="../Images/03882bc40910d3b28c87b25065f4a078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L39Z9_Ciu7znQ-yLxYFeDQ.png"/></div></div></figure><p id="b45b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您应该得到这样的输出，显示每个类中的数据图片。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lp"><img src="../Images/11934d38098abadaa59c1e219861d6f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1146/0*NR1GW2q_55WmS_FZ"/></div></figure><p id="132b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于Cifar-10数据集中的图像为32x32，因此输出图像的质量不高。在创建模型并将数据集作为输入之前，我们最好做的另一件事是将图像的像素值归一化到0和1之间。我们这样做是为了在反向传播阶段，我们不会在校正神经元的权重时过度/不足补偿。</p><p id="9a96" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">准备好要处理的数据集后，我们将从头开始创建一个简单的CNN来处理这些数据。如前所述，我们将使用Keras来创建这个模型。Keras作为Tensorflow机器学习库的接口，使得模型的开发变得更快更简单。我们将在这里使用Keras创建的是一个顺序模型。顺序模型基本上是层的线性堆叠。首先，我们从keras库中导入层和模型。然后，我们创建一个新的顺序模型，并定义模型中的不同层。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lq"><img src="../Images/b16254ddfde55419912f1bcb64c95ee0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oRzi4oruS0U3Sp80fX19mg.png"/></div></div></figure><p id="66a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">让我们看看代码的每一部分是做什么的。如您所见，我们创建了一个顺序模型，并添加了几个层。第一个添加的层是2D卷积层。该层中的第一个参数是我们希望该卷积层具有的滤波器数量，下一个参数(3，3)定义了这些滤波器的大小。<em class="lr"> input_shape </em>仅用于顺序模型的第一层，定义输入数据的形状，在本例中为3通道32x32图像。最后，我们有层的激活函数。激活函数用于确定层内每个节点或神经元的输出。要了解激活函数是做什么的，有哪些不同的激活函数，你可以阅读<a class="ae kv" rel="noopener" href="/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0">这篇文章</a>。野兔，我们将使用ReLU作为这一层的激活功能。</p><p id="b5ee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">接下来，我们有一个池层来减少卷积层输出的大小和维度。我们将使用一个大小为2x2的<em class="lr"> MaxPooling2D </em>层，在它的输入的每个2x2窗口中选择最大的数字。在这个模型中，我们还有2个卷积层和1个池层。最后一个卷积层的输出是1x1x64。我们将把这个输出展平成一个64值的1D输入，用于它之后的下一个密集层。最后一层是另一个10码的致密层。这一层基本上是模型的分类器，确定输入图像属于10个类别中的哪一个。通过使用<em class="lr"> model.summary() </em>行，我们可以看到我们刚刚创建的模型的架构。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es ls"><img src="../Images/3bb0e290bd146f89d1f9c1d94a5dd3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/0*8uierOXUHPMHZu2D"/></div></figure><p id="697a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以看到每一层对数据形状的影响，以及每一层中有多少可训练的参数。既然我们已经定义了模型的架构，我们需要编译并运行它。为了编译模型，我们运行下面的代码行。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lt"><img src="../Images/211000bb80b8066072e7553c4ef7c816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZAgH6NG0JcciYRar_f1uWA.png"/></div></div></figure><p id="0f16" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">优化器是在我们的模型中用来最小化误差损失函数的方法。优化器有助于了解如何改变神经网络的权重和学习速率，以减少损失。激活函数有很多，最常用的是“Adam”。我们在这里使用稀疏分类交叉熵作为我们的损失函数。我们还选择了一个在训练和测试过程中由模型评估的指标列表。我们的模型准备好了。我们现在要做的就是在我们的训练和测试数据集上运行它，看看它对图像的分类有多好。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="er es lu"><img src="../Images/60f137742ac4f2c961668b2d8ece1e77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EunT4T_5o7nL19A2BNwqEQ.png"/></div></div></figure><p id="70b0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在这个函数中，<em class="lr"> epochs </em>决定了我们希望整个数据集通过模型的次数。太多的时期会导致过度拟合，而太少的时期可能不会让模型达到其最佳精度。你应该得到大约70%的准确率，对于这样一个简单的模型来说，这已经很不错了。</p><figure class="kg kh ki kj fd kk er es paragraph-image"><div class="er es lv"><img src="../Images/c1c048fb1fd69ef21a06c0efbcd2134c.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/0*BidBtXPw2mdtUjzs"/></div></figure><p id="f42b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">您可以更改层中的激活函数、优化器和时期数，以查看最终结果会发生什么。</p><p id="4818" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我希望这篇文章能够帮助你学习和理解这些概念。</p></div></div>    
</body>
</html>