<html>
<head>
<title>Automatic time series description using Gaussian Processes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用高斯过程的自动时间序列描述</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automatic-time-series-description-using-gaussian-processes-b9bf09f6d0ce?source=collection_archive---------9-----------------------#2021-04-26">https://medium.com/analytics-vidhya/automatic-time-series-description-using-gaussian-processes-b9bf09f6d0ce?source=collection_archive---------9-----------------------#2021-04-26</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="1660" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们可以使用高斯过程以人类可以理解的方式自动描述时间序列会怎么样？</p><h1 id="b455" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">什么是高斯过程？</h1><p id="05ef" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">(多元)高斯过程是一组函数的分布。它们完全由它们的平均向量来描述:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es kg"><img src="../Images/1e1cc54a948194c3c2419d60f7a33e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*NMsbf6JVR5DeBYm2JOGASg.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">平均</figcaption></figure><p id="e758" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">和他们的协方差函数:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/5a8c4f4c2d7e666e7fd65db4bcfaf193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*avaOccuYweROCwf0Ib5ZqQ.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">协方差函数</figcaption></figure><p id="b04d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">协方差函数的作用是描述点之间的相关性。它存在几个协方差函数。它们通常描述了我们对训练点的先验知识。我们在这篇文章中要关注的是线性核，周期核和平方指数核。</p><div class="kh ki kj kk fd ab cb"><figure class="kx kl ky kz la lb lc paragraph-image"><img src="../Images/f3cec13fb631deb4a44885a60e9d9f5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*CyowDWcNGb-zZEiL1nnU6A.png"/></figure><figure class="kx kl ld kz la lb lc paragraph-image"><img src="../Images/b4594107285e9e1242276f20482da096.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*dJOVrbjrsPbOr5bW1UWetg.png"/></figure><figure class="kx kl le kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/45901fc8a904e831dbe939aa46c1e6a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*J-yqBRpyG2yCDlD78EUfTQ.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx lf di lg lh translated">从左到右，线性、周期和平方指数核</figcaption></figure></div><p id="415a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦定义了这些内核，我们就能够计算如下的协方差矩阵(它们在这里显示为热图)。</p><div class="kh ki kj kk fd ab cb"><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/95d62a9439716e05b7536e5146ae38af.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*Z01gV4bDcVfT0T42OFeXZw.png"/></div></figure><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/72cc17ef566894ced6ace1ab22d01cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*qal_OShudSieaZ6OhMMwEw.png"/></div></figure><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/8f911e5f55c7468946973247ab0c38ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*1WYl1oir7dUdWYoINSr-Ow.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx lj di lk lh translated">协方差矩阵的热图，从左到右，使用周期、线性和平方指数核</figcaption></figure></div><p id="7c05" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦计算出协方差矩阵，我们就定义了一个函数空间，在这里我们可以对一些项目进行采样，如下所示:</p><div class="kh ki kj kk fd ab cb"><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/9341daba4cbe8e58f467124558bfe56f.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*8EV38EkfqvjR15zUzP55ZQ.png"/></div></figure><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/3587f7f605aee33a78deba40fba7d52d.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*I7-gXlKwEfuQLBRV8-PKYA.png"/></div></figure><figure class="kx kl li kz la lb lc paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><img src="../Images/45501a95c9332fb0b4fd8b8b12358e27.png" data-original-src="https://miro.medium.com/v2/resize:fit:668/format:webp/1*EQGbI8Apk3d4BXCP7sC6lw.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx lj di lk lh translated">来自由上述协方差矩阵定义的函数空间的采样函数(假设零均值向量)分别使用线性、周期和平方指数核</figcaption></figure></div><p id="990c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如我们所看到的，不同的模式由不同的内核编码，我们可以为内核参数应用其他值，以查看它们在函数行为中产生的变化。</p><p id="8836" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦选择了协方差函数，就可以计算协方差矩阵。然后，我们可以用矩阵形式重写所有内容:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ll"><img src="../Images/bf2160d01ed4a4c0ace39c7145729b11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LrJQu4KTGRR0_DfpVvBu8Q.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">矩阵表示</figcaption></figure><p id="84a0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">与任何参数化模型一样，我们需要在训练过程中学习参数。这里的目的是最大化边际似然p(Y |数据，参数)。这相当于在高斯过程定义的无限函数集合中选择一个函数。通过取后验对数，微积分得出:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lm"><img src="../Images/0410d6d16ef3afe1104209fc6a0c421a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hM22QVOsKgOGz8N16PBlIQ.png"/></div></div></figure><p id="a273" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦选定，我们可以使用我们的函数来推断下一个值。如果我们有f∫由未来点定义的函数，我们想通过推断得出，那么我们可以写为:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ln"><img src="../Images/ae4914aa45383a876f2c7b37d3816aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kqw6GdNfQK16fM4yHC3B3g.png"/></div></div></figure><p id="e0a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，我们可以根据以下公式从均值函数μ和协方差矩阵K推断新点f∫的值:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es lo"><img src="../Images/87800e89481157a3b6a372783990c03b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1G1oLDV-9qnIUfa4Nfz3HA.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">预测公式</figcaption></figure><p id="8889" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所有的证明都超出了本文的范围，但是可以在[2]中找到。</p><h1 id="c51c" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">如何找到更好的内核？</h1><p id="7cc0" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">这里的主要挑战是找到最好的内核，最好地描述我们的训练数据。这是一个困难的过程，需要很多内核选择方面的专业知识。这就是戴维·杜文瑙德和詹姆斯·劳埃德在[1]中要解决的困难。为了找到内核的最佳组合，他们引入了一个自动框架。</p><p id="649a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了组合内核，允许三种操作:</p><ul class=""><li id="91de" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc lu lv lw lx bi translated">加法k = k1+k2</li><li id="ff01" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">乘法k =k1*k2</li><li id="b143" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">互换k=k '</li></ul><p id="4756" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，它们递归地搜索组合核的空间。每一步都保留了最佳模型。最佳模型是指具有较高BIC的模型:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es md"><img src="../Images/d26e37a122671862c646969d4e831878.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*zsQp3zPDeNsz0CF5NTdM_w.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">贝叶斯信息准则</figcaption></figure><p id="f4bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中第一项是边际可能性，第二项惩罚参数的数量。之后，他们创建了一个完整的字典，用人类可以理解的句子来翻译内核。所有的过程都在Duvenaud的论文中有描述。简而言之(<strong class="ih hj">一定要阅读论文以获得完整的描述</strong>)，每个内核都有一个特定的描述，当与其他内核结合时，它会发展。</p><h1 id="ad93" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">履行</h1><p id="4936" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">我在这里的目标是使用Tensorflow来利用它的计算能力。幸运的是，大部分的微积分可以用矩阵的形式来完成(张量流中的张量)。唯一的修改是将核函数重写为矩阵运算。这可以简单地通过增加向量的维数来获得我们需要的差分矩阵。这里以线性内核的实现为例。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">示例实现线性核</figcaption></figure><p id="6b54" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦我们的内核实现了，我们需要实现搜索框架中允许的三个操作。为了简化整个过程，内核将被视为python列表，以便能够简单地添加、交换和相乘。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">示例实现添加操作</figcaption></figure><p id="76fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步将是编码训练步骤。首先，我们需要实现公式(7)，这将是我们的目标函数最小化。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">损失函数实现</figcaption></figure><p id="683b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第15行到第39行是为了从核列表中获得协方差矩阵，但是有趣的是函数的结尾。事实上，公式(7)使用矩阵求逆，这在计算上是昂贵的，并且在数值上是不稳定的。相反，我们可以使用cholesky分解来提高稳定性和复杂性。所有的细节都可以在<a class="ae me" href="https://www.cs.ubc.ca/~nando/540-2013/lectures/l6.pdf" rel="noopener ugc nofollow" target="_blank">这门有趣的课程</a>中找到。</p><p id="cf72" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以实施我们的培训流程了。尝试的第一种方法是梯度下降，但是这种方法有一些缺点:</p><ul class=""><li id="fba2" class="lp lq hi ih b ii ij im in iq lr iu ls iy lt jc lu lv lw lx bi translated">它引入了新的超参数，比如我们需要调整的学习速率和迭代次数。</li><li id="2e12" class="lp lq hi ih b ii ly im lz iq ma iu mb iy mc jc lu lv lw lx bi translated">对于我们已经计算量很大的程序来说，它需要大量的迭代。</li></ul><p id="c0a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们将使用L-BFGS-B(BFGS的优化和约束版本)。该求解器来自拟牛顿(使用二阶导数)方法族，因此需要较少的迭代来收敛。我们将使用scipy的优化器，而不是tensorflow中实现的优化器，因为它是受约束的，并且测试表明，不受约束的超参数倾向于收敛到由损失函数定义的空间边界。</p><p id="9886" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为此，我们需要创建一个函数来链接scipy和tensorflow。这个函数是一个包装器，它返回一个函数，能够返回损失值和超参数的梯度(对应于scipy.optimizer函数所期望的)。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="6636" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，我们可以实施我们的培训步骤:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="a2c1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">define_boundaries函数只是强制参数为正，因为负参数在这里没有意义。</p><p id="87f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们现在可以实现预测步骤(公式(9)和(10)):</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">预言；预测；预告</figcaption></figure><p id="5aa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">一旦实施了BIC公式，最后一步将是实施语言。我们基于[1]的(<strong class="ih hj">非常简化的</strong>)语言可以使用regex和前面显示的内核名称列表来实现。</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="806a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，许多步骤并没有包含在本文中。但是完整的节目可以在<a class="ae me" href="https://github.com/gregoritoo/ABCDflow" rel="noopener ugc nofollow" target="_blank">这里</a>找到。它可以作为包含以下代码的包使用:</p><figure class="kh ki kj kk fd kl"><div class="bz dy l di"><div class="mf mg l"/></div></figure><p id="f728" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是现在让我们看看最重要的:结果！</p><h1 id="ed04" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">结果</h1><p id="5a03" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">预测(具有精确的置信区间，与深度学习技术相反) :</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div class="er es mh"><img src="../Images/f45bbd3f6285983b00b73340e1bab3e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*AWxq9rwsNBHO71e1mqKZpQ.png"/></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">时间序列分解</figcaption></figure><p id="e8dc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">解释:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mi"><img src="../Images/5d3c009bd42a71b8b1b2afadd1dacaf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0KN1R2jCwJadwqOohpORdw.png"/></div></div><figcaption class="ko kp et er es kq kr bd b be z dx translated">说明</figcaption></figure><p id="222e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">分解:</p><figure class="kh ki kj kk fd kl er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es mj"><img src="../Images/99a60d569853fa444e32ad7867177327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2F-so9A4zunIMTMLkqSEQ.png"/></div></div></figure><h1 id="e20e" class="jd je hi bd jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka bi translated">参考</h1><p id="516a" class="pw-post-body-paragraph if ig hi ih b ii kb ik il im kc io ip iq kd is it iu ke iw ix iy kf ja jb jc hb bi translated">[1]戴维·杜文瑙、詹姆斯·劳埃德、罗杰·格罗斯、约书亚·特南鲍姆和格拉马尼·邹斌。基于组合核搜索的非参数回归结构发现。Sanjoy Dasgupta和DavidMcAllester，编辑，第30届机器学习国际会议论文集，机器学习研究论文集第28卷，第1166-1174页，美国佐治亚州亚特兰大，2013年6月17-19日。PMLR。</p><p id="b26f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]c . e . Rasmussen &amp; c . k . I . Williams,《机器学习的高斯过程》,麻省理工学院出版社，2006年，ISBN 026218253 x . c 2006 Technology.www.GaussianProcess.org/gpml麻省理工学院</p></div></div>    
</body>
</html>