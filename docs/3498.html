<html>
<head>
<title>I programmed a tic tac toe game with Minimax Algorithm, but how does it work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用极大极小算法编程了一个井字游戏，但它是如何工作的？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/i-programmed-a-tic-tac-toe-game-with-minimax-algorithm-but-how-does-it-work-8c689842c9ee?source=collection_archive---------2-----------------------#2021-07-05">https://medium.com/analytics-vidhya/i-programmed-a-tic-tac-toe-game-with-minimax-algorithm-but-how-does-it-work-8c689842c9ee?source=collection_archive---------2-----------------------#2021-07-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><div class=""><h2 id="abe3" class="pw-subtitle-paragraph if hh hi bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">极大极小算法介绍，用Python编程</h2></div><p id="93fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">导师:尼古拉斯·格雷夫斯</p><p id="2fa1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在本文中，你将了解到<strong class="iz hj">极大极小算法</strong>，以及这个人工智能代理如何让你的<strong class="iz hj">井字游戏</strong>无与伦比。在下文中，我将介绍极大极小的概念和实现极大极小的python代码。(完整代码，请访问底部的GitHub链接。)</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es jt"><img src="../Images/c85777f3c95524cb36c3e076be15ef88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lODC4NvdBW7DjUZhkv8tCA.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">人类(X)对极小极大代理人(O)</figcaption></figure><p id="66a8" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">概要</strong>:</p><ul class=""><li id="7182" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated"><a class="ae ks" rel="noopener" href="/p/8c689842c9ee#540a">井字游戏</a></li><li id="b592" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ko kp kq kr bi translated"><a class="ae ks" rel="noopener" href="/p/8c689842c9ee#62ad">极大极小算法</a></li></ul><p id="0c16" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">— <a class="ae ks" rel="noopener" href="/p/8c689842c9ee#29a3">最小值</a></p><p id="e4f3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">— <a class="ae ks" rel="noopener" href="/p/8c689842c9ee#19b9">最大值</a></p><ul class=""><li id="74e5" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js ko kp kq kr bi translated"><a class="ae ks" rel="noopener" href="/p/8c689842c9ee#8112">极小极大的Python代码</a></li><li id="e732" class="kj kk hi iz b ja kt jd ku jg kv jk kw jo kx js ko kp kq kr bi translated"><a class="ae ks" rel="noopener" href="/p/8c689842c9ee#c38f">下一步是什么</a></li></ul></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="cefd" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated"><strong class="ak">井字游戏:</strong></h1><p id="4132" class="pw-post-body-paragraph ix iy hi iz b ja lx ij jc jd ly im jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">井字游戏是一种游戏，两个游戏者轮流完成一行、一列或一条对角线，在九个正方形的格子中画三个O或三个X。</p><p id="5639" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">考虑下面的井字游戏场景:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mc"><img src="../Images/dddf07d96929331ccf12495547e6fdd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0omrZIv76Gr62FRNttpXQ.jpeg"/></div></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="1b57" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated"><strong class="ak">极大极小算法:</strong></h1><p id="29a3" class="pw-post-body-paragraph ix iy hi iz b ja lx ij jc jd ly im jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">你将和一台有极大极小算法的电脑玩井字游戏，如果正确执行，它永远不会输。现在，到底什么是极大极小算法，为什么要用它？极大极小是人工智能、博弈论、决策理论等中使用的决策规则。极大极小很有用，因为它利用了计算机评估指数增长的一系列可能场景的能力。展望未来的未来。至于游戏，Minimax常用于对抗性游戏。有两个效用值，称为最小<strong class="iz hj">和最大</strong>值，帮助人工智能代理决定下一步的最佳行动。在这种情况下，代理优先考虑最大值为10的移动，然后选择最小值-10。(代理人更想赢而不是阻止它的对手赢)如果没有任何最小或最大值大于或小于10的移动，它选择最小加最大值的绝对值最高的移动。再次，极小极大假设它的对手发挥最佳。</p><p id="38ec" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="md"> —最小值</em></p><p id="6a0b" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是人工智能代理寻求<strong class="iz hj">最小化</strong>最坏情况<strong class="iz hj">的可能损失</strong>的值。对于棋盘位置上的每个水平、垂直、对角线通道，如果3个位置都没有你的移动，则每个通道的最小值-1。然后，每多一个对手在一条道上移动，你-1(除非你没有在那条道上移动)。但是，如果有2个对手移动，你的最小值变成-10(如果你不阻挡那个位置，你的敌人就会赢！).</p><p id="09d4" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设你是玩家(X)，考虑以下棋盘场景:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es me"><img src="../Images/359c074f92a85ad673a3fcce01d0cfdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Je8fl5wWHx7qmzwr4bNmLA.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">最小实用板</figcaption></figure><p id="19b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于板位置1，在其行(水平通道)和列(垂直通道)上没有X。这意味着通过在那里放置一个X，你消除了O获胜的2条可能路线。此外，在那一行(水平通道)，除了-2之外还有一个O，所以你-1。我们没有从对角线通道中减分，因为它包含一个X，即使有一个o。对于棋盘位置6，最小值是-10，因为它的列(垂直通道)有2个o。</p><p id="6ab3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">— <em class="md">最大值</em></p><p id="9cf5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这是人工智能寻求<strong class="iz hj">最大化<strong class="iz hj">最佳情况</strong>的可能收益</strong>的值。对于棋盘位置上的每一条水平、垂直、对角线的道，如果这3个位置没有你对手的移动，你每道+1。然后，你在这条路上每多走一步，你就再+1(前提是你的敌人在这条路上没有走任何一步)。然而，如果你有2步棋，你的最大值变成+10(你在那里走一步就赢了！).</p><p id="6f44" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">假设你是玩家(X)，考虑以下棋盘场景:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mf"><img src="../Images/a8bc274ad033ff773e78aa31cef527cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nVTQ8meecpHjQEPw6r62PQ.jpeg"/></div></div><figcaption class="kf kg et er es kh ki bd b be z dx translated">最大效用板</figcaption></figure><p id="7bd5" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">对于棋盘位置1，在它的列(垂直通道)和对角线通道上没有对手(O)移动，你加2。此外，您在对角线上移动了(X ),因此您将最大值加1，得到3。对于纸板位置8，最大值为10，因为您在其列(垂直通道)上移动了2次(X)。把你的棋放在8号位，你就赢了。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="a17d" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated"><strong class="ak">极小极大的Python代码:</strong></h1><p id="1958" class="pw-post-body-paragraph ix iy hi iz b ja lx ij jc jd ly im jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">让我们看看生成最小值和最大值的代码！</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mg mh l"/></div></figure></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><ol class=""><li id="83b7" class="kj kk hi iz b ja jb jd je jg kl jk km jo kn js mi kp kq kr bi translated"><strong class="iz hj">第1–7行</strong></li></ol><p id="27fe" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">已导入库副本。定义了一个名为Cell的类，将第9行上传递的棋盘上的每个位置转换为单独的对象，存储4项:位置、该位置的2D指数、最大值和最小值，以便于访问。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="41b1" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 2。第9–19行</strong></p><p id="34b9" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义了一个名为generate_cells的函数，它接受Tictactoe板(应该是二维的)的输入，并为板上的每个位置返回一个实用板。实用板是一个2D列表，每个位置是一个包含3个项目的列表:它的位置，最大值和最小值。该函数通过调用第15–16行的max_val函数(<strong class="iz hj">第21行</strong>)和min_val函数(<strong class="iz hj">第32行</strong>)生成最大值和最小值。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="f0b3" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 3。第21–30行</strong></p><p id="68be" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义了一个名为max_val的函数，它接收电路板位置及其2D指数，并返回一个最大值。在<strong class="iz hj">行24 </strong>上，check_horizontal函数通过检查位置的水平通道生成最大值。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="212e" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="iz hj">第25 </strong>行，check_vertical函数通过检查位置的垂直通道生成最大值。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="afa6" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在第27 行<strong class="iz hj">上，left_diagonal函数通过检查位置的左上到右下对角线生成最大值。</strong></p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="7909" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在<strong class="iz hj">第28 </strong>行，right_diagonal函数通过检查位置的右上到左下对角线生成最大值。</p><figure class="ju jv jw jx fd jy"><div class="bz dy l di"><div class="mg mh l"/></div></figure><p id="d90d" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj"> 4。第32–40行</strong></p><p id="1d28" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">定义了一个名为min_val的函数，它接收电路板位置及其2D指数，并返回一个最小值。在<strong class="iz hj">行35 </strong>上，check_horizontal函数通过检查位置的水平通道生成最小值。在<strong class="iz hj">行36 </strong>上，check_vertical函数通过检查位置的垂直通道生成最小值。在<strong class="iz hj">第37行</strong>上，left_diagonal函数通过检查位置的左上到右下对角线生成最小值。在<strong class="iz hj">第38行</strong>上，right_diagonal函数通过检查位置的右上到左下对角线生成最小值。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><h1 id="3067" class="lf lg hi bd lh li lj lk ll lm ln lo lp io lq ip lr ir ls is lt iu lu iv lv lw bi translated"><strong class="ak">接下来是什么:</strong></h1><p id="5407" class="pw-post-body-paragraph ix iy hi iz b ja lx ij jc jd ly im jf jg lz ji jj jk ma jm jn jo mb jq jr js hb bi translated">现在你应该能够理解极大极小背后的一般概念。我的程序相对简单，可以通过实现更高级的概念来进一步优化，比如<strong class="iz hj">效用树</strong>和<strong class="iz hj"> alpha-beta修剪</strong>。</p><p id="5164" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="md">效用树</em>:基本上是一个决策树，包含给定电路板的可能电路板状态，用最小值和最大值评估。考虑下面的例子:</p><figure class="ju jv jw jx fd jy er es paragraph-image"><div role="button" tabindex="0" class="jz ka di kb bf kc"><div class="er es mj"><img src="../Images/325a1c8da65c999bdcd7d8bdaafd9683.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NPylZF1ofcd5_gEBwdVblA.jpeg"/></div></div></figure><p id="efb0" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><em class="md"> alpha-beta剪枝:一种</em>搜索算法，旨在减少搜索树中由minimax算法评估的节点数量，以提高程序的时间效率。</p></div><div class="ab cl ky kz gp la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="hb hc hd he hf"><p id="b065" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="iz hj">注</strong>:Minimax算法适用于井字游戏，人工智能代理使这款游戏不可战胜。然而，井字游戏没有充分利用Minimax的潜力，而象棋游戏可能是更好的代表。国际象棋充分操纵Minimax的力量:完美操纵计算机的力量，有完美的回忆，有完美的记忆，没有场景是无法计算的，比一个人类提前生成了大量可能的场景。与国际象棋相比……Tictactoe在3乘3棋盘的情况下，计算机能想出的可能场景更少。</p><p id="1928" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">python代码在GitHub上:<a class="ae ks" href="https://github.com/729557989/MiniMax-Algorithm-with-tictactoe-optimized" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/729557989/MiniMax-Algorithm-with-tictactoe-optimized</a></p><p id="d92c" class="pw-post-body-paragraph ix iy hi iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">有问题吗？评论？您的问题或意见对于帮助我们双方学习非常重要！请在评论区留下您的评论或反馈。感谢您阅读本文！</p></div></div>    
</body>
</html>