<html>
<head>
<title>Python &amp; Django optimization tools and process</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python &amp; Django优化工具和流程</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python-django-optimization-tools-and-process-b59a4d807d4b?source=collection_archive---------5-----------------------#2021-05-29">https://medium.com/analytics-vidhya/python-django-optimization-tools-and-process-b59a4d807d4b?source=collection_archive---------5-----------------------#2021-05-29</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="651f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Django是一个很好的工具(不是最好的，但足够好)来尽快创建web应用程序，它包括许多有用的电池，允许在几天内启动生产就绪的MVP。但是如果你要改进你的应用程序，你需要关注它的性能。我想介绍3个工具，它们有助于衡量性能指标，并使优化过程更加明显。<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools" rel="noopener ugc nofollow" target="_blank">在这里</a>你可以找到<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/optimization_tools/settings.py" rel="noopener ugc nofollow" target="_blank">已经配置</a>使用这个调试工具的演示项目。</p><h2 id="3150" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated"><strong class="ak">在</strong>中需要注意哪些指标</h2><p id="b7e0" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">当我们谈论web应用程序时，重要的衡量标准是从浏览器获得响应的时间。它包括几个步骤:</p><ol class=""><li id="a407" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated">从浏览器向服务器发送请求。</li><li id="a21e" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">用python代码准备请求对象，并在函数的控制器类中接收它。</li><li id="345d" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">处理请求(提取数据，转到数据库/第三方服务，可能以某种方式计算它，准备响应)。</li><li id="1d59" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">将响应发送回服务器。</li></ol><p id="b260" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们列出可以使这些步骤更有效的指标(减少步骤所用的时间):</p><ul class=""><li id="9e19" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc ks kk kl km bi translated">从浏览器发送到服务器并返回的数据量—影响第1步和第4步</li><li id="3882" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc ks kk kl km bi translated">从数据库/第三方服务获取的数据量—影响第三方并间接影响第四方</li><li id="0598" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc ks kk kl km bi translated">接收/保存数据的数据库/第三方查询计数—影响第三方</li><li id="d3ad" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc ks kk kl km bi translated">使用从数据库/第三方服务(业务逻辑)接收的数据进行计算—影响第三方</li><li id="896c" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc ks kk kl km bi translated">RAM使用—影响第三、第二、第四。</li></ul><p id="0bbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有什么工具来衡量它们？哪个指标对请求-响应周期中的总时间影响最大？哪些指标对我们的应用不那么重要？让我们试着弄清楚。</p><h2 id="b616" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">工具概述</h2><p id="8aa7" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们将考虑我推荐经常使用的3种工具，使用它们你将编写更快的代码。</p><p id="36b1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/jazzband/django-silk" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj">姜戈-丝</strong> </a></p><p id="5bc7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是我最喜欢的，它有助于检查执行了哪些SQL查询，准备响应花了多少时间(2-4步)，数据库查询花了多少时间，还可以在代码的任何部分使用CProfile并可视化结果。</p><p id="e67e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们试一试。您可以在<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools" rel="noopener ugc nofollow" target="_blank">演示项目</a>中使用它。它包含一个简单的Django项目，包含两个模型— <code class="du kt ku kv kw b">Author</code>和它们的<code class="du kt ku kv kw b">Publication</code>、数据夹具和<a class="ae jd" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> Postman </a>集合，以提供对已有API的快速访问。</p><p id="1053" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">克隆<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools" rel="noopener ugc nofollow" target="_blank">演示</a>并经历几个步骤:</p><ol class=""><li id="9d3a" class="ke kf hi ih b ii ij im in iq kg iu kh iy ki jc kj kk kl km bi translated"><a class="ae jd" href="https://docs.python.org/3/library/venv.html#creating-virtual-environments" rel="noopener ugc nofollow" target="_blank">创建</a>虚拟环境并激活它。</li><li id="ec21" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">安装所需的库<code class="du kt ku kv kw b">pip install -r requirements.txt</code>。</li><li id="1119" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">设置数据库<code class="du kt ku kv kw b">python manage.py migrate</code>。</li><li id="e0b8" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">用数据填充数据库<code class="du kt ku kv kw b">python manage.py loaddata data.json</code></li><li id="5444" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">创建超级用户来访问站点的管理部分<code class="du kt ku kv kw b">python manage.py createsuperuser</code></li><li id="49f7" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">运行app <code class="du kt ku kv kw b">python manage.py runserver</code>。</li><li id="5001" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">打开Postman并从存储库中导入<code class="du kt ku kv kw b">collection.json</code>文件。</li><li id="8cf5" class="ke kf hi ih b ii kn im ko iq kp iu kq iy kr jc kj kk kl km bi translated">使用导入集合中的“出版物列表”请求，在Postman中转至<a class="ae jd" href="http://127.0.0.1:8000/api/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/API/</a>。</li></ol><p id="5ee9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有一个由不同作者创作的出版物列表，数据由fixture准备。正如您所看到的，django-silk已经打开，所以它会写入关于服务器收到的所有HTTP查询的元信息。让我们看看发生了什么，在浏览器中打开<a class="ae jd" href="http://127.0.0.1:8000/silk/." rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/silk/。</a></p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es kx"><img src="../Images/55b01c6b8d07716bb9aca694a9ce55d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sv14dGeUCf4d88jLSgPyXw.png"/></div></div></figure><p id="acd4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是django-silk记录的元信息，点击有200个GET请求的块，你将被重定向到这个特定的请求信息——数据库查询的数量、标题、主体参数。</p><p id="b382" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">单击顶部栏选项卡中的SQL，您将看到在请求-响应周期的第三步中执行的所有数据库查询的列表。每个记录都有计时信息和查询中执行的连接数量。如果单击任何，您将看到详细信息——执行了哪条SQL，在哪里从python代码调用了它。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lj"><img src="../Images/cf7070a27c76ae8dae475e3f414eff77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7EntUHjmIumieAHQfAobVw.png"/></div></div></figure><p id="c98a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们来看看那些出版物被访问次数最多的作者。打开Postman，转到“访问量排名靠前的作者(DB)”并发送请求。<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L15" rel="noopener ugc nofollow" target="_blank">这里</a>我们使用数据库聚合来统计每个作者对出版物的访问。之后，转到“访问量排名靠前的作者(PY)”并再次发送请求以获得相同的结果，但在python代码中<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L22" rel="noopener ugc nofollow" target="_blank">计算访问量</a>。</p><p id="9c32" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在打开silk页面<a class="ae jd" href="http://127.0.0.1:8000/silk/requests/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:8000/silk/requests/</a>，您会看到两个新请求返回了相同的响应，但在内部它们是不同的——第一个只做了2个查询，第二个做了5个查询(尝试找出它们不同的原因，答案在帖子的末尾，#1)。这就是django-silk如何让无效的queryset用法变得显而易见。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><p id="ba1a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">使用django-silk的另一种方法是调用CProfile来检查是否有阻塞，这需要花费很多时间来执行一些应用程序逻辑。<br/>看看第三个请求所用的时间，它几乎是第二个请求的300倍！让我们试着了解一下原因，点击它并转到Profiling选项卡。</p><p id="f6e8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里你可以看到所有被分析的块，它们都用silk_profiler decorator或context manager标记，点击“top-authors-py”。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lr"><img src="../Images/8b6c075e68c09c2855c1a5aeb80a3f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PMMU9OjU9D9HD80cmfzAVA.png"/></div></div></figure><p id="dc2a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在分析页面上，您可以看到<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L14" rel="noopener ugc nofollow" target="_blank">装饰器</a> / <a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L24" rel="noopener ugc nofollow" target="_blank">上下文管理器</a>被调用的位置、分析图和cProfile表。看图表，这是最明显的。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es ls"><img src="../Images/557ad74a5f86eaadda4162099123f7c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ImicfEylFSIIRpa6oJ2j8Q.png"/></div></div></figure><p id="ca80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这只是一个可视化的轮廓。它根据块花费的时间来给块着色——红色是最慢的函数和类，黄色、绿色是最快的。</p><p id="eef9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">正如你所看到的，通过访问来响应作者，我们调用了模糊函数<code class="du kt ku kv kw b">do_long_action()</code>，它花费了66%的执行时间。</p><p id="d5e0" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">添加这个函数是为了演示django-silk的可视化如何方便地帮助查找速度慢的函数和类，使用它您可以快速定位并修复它们。</p><p id="3a7b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">删除<code class="du kt ku kv kw b">do_long_action()</code> <a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L26" rel="noopener ugc nofollow" target="_blank">调用</a>再次提出请求。会发生什么？会不会存在另一个性能问题？尝试改进“按访问量排名的顶级作者(PY)”视图。</p><p id="4991" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Django-silk还有另一个有用的特性，更多的例子你可以在它的<a class="ae jd" href="https://github.com/jazzband/django-silk" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p><p id="5e0c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://github.com/jmcarp/nplusone" rel="noopener ugc nofollow" target="_blank"><strong class="ih hj"/></a></p><p id="ef9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在开发过程中寻找N+1查询的简单而强大的工具——当您不从相关模型中预取数据而是访问它们时，通常是通过点。</p><p id="fcfd" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">nplusone已经安装在演示项目中，让我们试试吧。去邮差那里提出“有作者的出版物”的请求。每个出版物都有id、标题和作者姓名作为响应。这么简单的要求可能有什么问题？如果您查看运行Django的控制台输出，您会发现<code class="du kt ku kv kw b">Potential n+1 query</code>消息:</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es lt"><img src="../Images/aa130bcdcc5bd0934cdee1433bdcc59e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZ6pAnTrxSTewpa20PfwuQ.png"/></div></div></figure><p id="4bee" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">nplusone告诉我们，使用<code class="du kt ku kv kw b">Publication</code>模型时，我们没有预取作者信息，尝试找到并修复(在帖子末尾回答，第2条)。仅此而已。<br/>Django文档中的<code class="du kt ku kv kw b">prefetch_related()</code>和<code class="du kt ku kv kw b">select_related()</code> <a class="ae jd" href="https://docs.djangoproject.com/en/3.2/ref/models/querysets/#select-related" rel="noopener ugc nofollow" target="_blank">主题</a>中描述了关于预取数据的更多详细信息。</p><p id="5b5d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><a class="ae jd" href="https://django-debug-toolbar.readthedocs.io/en/latest/index.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ih hj"> Django调试工具栏</strong> </a></p><figure class="ky kz la lb fd lc er es paragraph-image"><div class="er es lu"><img src="../Images/8e9939f9a60cead1f4b2a587372278f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*coQuesjl7crRmBP8u9NsVw.png"/></div></figure><p id="4a9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有助于您查看项目中设置的大量信息，如中间件、已安装的应用程序、已注册的信号等，而且它还包括一些特定于请求的数据，例如渲染模板列表、标题、请求数据、请求-响应周期中执行的sql等。</p><p id="242a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个工具提供了非常有用的信息，但是它只能处理HTML呈现的响应，因为工具栏不能为JSON呈现，因为它需要HTML页面上的一些地方来放置它的标签。因此，如果您在浏览器中访问演示项目的任何URL，除了普通的JSON响应，您将什么也看不到。要查看该工具栏的外观，您可以打开管理站点<a class="ae jd" href="http://127.0.0.1/admin/" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1/admin/</a>，在那里您将看到面板，单击其中任何一个面板，您都可以浏览有关您项目的详细信息。</p><p id="9db5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">另一个使用than库的方便方法是<code class="du kt ku kv kw b">debugsqlshell</code>命令，我通常用它来弄清楚函数或类如何产生SQL。</p><p id="5b57" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">尝试在演示项目中运行<code class="du kt ku kv kw b">python manage.py debugsqlshell</code>，并在解释器shell中执行以下代码行:</p><pre class="ky kz la lb fd lv kw lw lx aw ly bi"><span id="6fb0" class="je jf hi kw b fi lz ma l mb mc">&gt;&gt;&gt; from app.views import get_authors_db<br/>&gt;&gt;&gt; get_authors_db()</span></pre><p id="450a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您将在输出的最后一行看到直接结果，即作者列表。但是在此之前，你可以找到一些SQL，这就是<code class="du kt ku kv kw b">get_authors_db()</code>函数从数据库中获取数据的方式。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es md"><img src="../Images/f62861e44400d1a3e1d2cbfb6a637024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*90k9fstX8DnCLYeM13oKlg.png"/></div></div></figure><p id="f393" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这个管理命令非常方便测试一些函数或类，而不需要运行整个请求-响应周期。</p><h2 id="c166" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">利弊</h2><p id="4c92" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated">我们认为有3种工具可以帮助开发人员理解他们的代码在使用数据库和python代码的环境中是如何工作的。下面你可以看到对比表，我试图总结我们所谈论的一切。</p><figure class="ky kz la lb fd lc er es paragraph-image"><div role="button" tabindex="0" class="ld le di lf bf lg"><div class="er es me"><img src="../Images/8d6bd6e7f53491c9accaad3a2db2ddac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j2D6DMZns4u_KtcJtum_fg.png"/></div></div></figure><p id="1307" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当然，这个表并不详尽，但是它提供了一些选择更符合您需求的工具的观点。无论如何，至少有两种工具(silk和debug-toolbar)是自带电池的大型调试系统，所以请随意深入研究，发现如何使用它来跟踪性能问题并改进您的项目。</p><p id="a372" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在评论中分享你知道并每天使用哪些工具来调试和测量你的python和Django代码。</p></div><div class="ab cl lk ll gp lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hb hc hd he hf"><h2 id="ebdb" class="je jf hi bd jg jh ji jj jk jl jm jn jo iq jp jq jr iu js jt ju iy jv jw jx jy bi translated">帖子中问题的答案</h2><p id="0596" class="pw-post-body-paragraph if ig hi ih b ii jz ik il im ka io ip iq kb is it iu kc iw ix iy kd ja jb jc hb bi translated"># 1<br/>d b-request只对数据库做了两次请求的原因是，我们<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L19" rel="noopener ugc nofollow" target="_blank">在一次额外的查询中使用</a> <code class="du kt ku kv kw b">prefetch_related()</code>来填充作者的出版物，这是在对<code class="du kt ku kv kw b">Author</code>的表进行查询之后完成的。与此不同，我们<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/services.py#L25" rel="noopener ugc nofollow" target="_blank">没有请求<code class="du kt ku kv kw b">get_authors_python()</code>中的</a>作者相关表，所以当我们构造输出时，Django在单独的查询中为每个作者找到<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/contexts.py#L29" rel="noopener ugc nofollow" target="_blank">出版物。</a></p><p id="28f3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">#2 <br/>在有作者的出版物中，当我们<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/views.py#L31" rel="noopener ugc nofollow" target="_blank">构造输出</a>时，我们调用<code class="du kt ku kv kw b">Publication.author</code>字段，因此Django转到之前没有填充的每个出版物的<code class="du kt ku kv kw b">author</code>属性，并对<code class="du kt ku kv kw b">Author</code>的表进行一次额外的查询。与#1解决方案一样，只需将<code class="du kt ku kv kw b">prefetch_related</code>添加到<a class="ae jd" href="https://gitlab.com/DariaPlotnikova/demodebuggingtools/-/blob/master/app/views.py#L29" rel="noopener ugc nofollow" target="_blank"> publications queryset </a>中。</p></div></div>    
</body>
</html>