<html>
<head>
<title>Python3: Mutable, Immutable… everything is an object!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python3:可变的，不可变的…一切都是对象！</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/python3-mutable-immutable-everything-is-an-object-31ee65736ad6?source=collection_archive---------27-----------------------#2021-05-28">https://medium.com/analytics-vidhya/python3-mutable-immutable-everything-is-an-object-31ee65736ad6?source=collection_archive---------27-----------------------#2021-05-28</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/87fc706b9f6e24ad496bf2482fb6d1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DQreX4AK-0j_uJfiRcEC8Q.png"/></div></div></figure><div class=""/><p id="5af4" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">你肯定已经看到在Python中一切都是对象，你在这里是为了更好地理解这些对象在这种语言中的行为。你必须知道什么是可变的和不可变的对象，以及它们是如何工作的，这样你在执行你的程序时就不会有任何意外。</p><p id="b467" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，让我们弄清楚变量包含类(对象)的实例，当一个对象被初始化时，它接收一个唯一的Id。此ID一旦分配就不能更改，但某些对象的状态可以修改。这意味着可变对象可以在创建后保留其Id进行修改，而不可变对象则不能，在想要修改的情况下，要做的是重新分配包含该对象的变量的值。</p><p id="e0a6" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">为了更清楚地理解这一点，不至于迷路，我们将看到两个函数，id()和type()，它们将帮助我们确认我们在哪里。</p><p id="0c0d" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht"> Id() &amp;类型()</strong></p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es jn"><img src="../Images/94a4784d6490e369ff2d4c30c12c20de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*dIRFSoi1PggM48dTb8yqQQ.png"/></div></figure><p id="a9f7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">Id()和type()是内置的python函数。Id()返回对象的标识号，以保证它在同时存在的对象中是唯一的。这个数字是十进制格式的。Type()返回对象的类型。在python3中，它不再被称为类型，而是被称为类。</p><p id="4916" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">不可变对象</strong></p><p id="de6b" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不可变对象是那些不改变id就不能被修改的对象，这意味着通过改变包含不可变对象的变量的值，我们正在重新分配一个新值。不可变对象是int、str、float、bool、Unicode和tuple。</p><p id="e345" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们会看到一些例子，关于整数。如果我们给一个值添加一些东西，原始对象不会被修改，但是变量现在保存了最终值的id。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es jn"><img src="../Images/e8a127b1eac78f1242d6087ac79e352f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*ppLQliW3Wf9UUPu3TmxFJQ.png"/></div></figure><p id="aae2" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果我们给另一个变量赋一个X开始时的值，它就会有原来的地址。这里我想澄清一下，python缓存了从-5到256赋值的所有数字；这就是为什么Y会有X的第一个地址，如果我们把相同的值赋给Z，这意味着两个变量指向同一个对象。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es js"><img src="../Images/fbd6faca9ddc35c944da690f90e2353f.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*RYeb7U3SlmyV7QNuyAfrwQ.png"/></div></figure><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es jt"><img src="../Images/9930046ef6e1ac85335448cdd61c3f19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1336/format:webp/1*n_h4viw_jI_69bTijeZkCw.png"/></div></figure><p id="66f5" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">同样的事情也发生在字符串上，我们可以尝试修改字符串中的一个字符，但是会抛出一个错误；然后要修改它们，我们要做的是重新分配变量，使它指向一个新的字符串。</p><p id="c872" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，元组是不可变的，但它们可以包含不可变和可变的对象，这意味着如果您有一个整数元组和一个列表，您可以在列表中进行内部更改。</p><p id="150f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">可变对象</strong></p><p id="aa92" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">可变对象是那些可以被修改但仍然保留其id的对象。对于可变对象，我们有列表、字节数组、集合和字典。</p><p id="9b07" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">让我们看一个列表的例子，在这里我们将添加更多的值；您可以看到id得到了保留:</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es js"><img src="../Images/d83fd43835b89e0d5a38063ac8c9e8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*0_-kDkLA5LJs1kSj8il1UQ.png"/></div></figure><p id="f6f7" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">不使用"+ = "或" append()"方法，而是使用" = "方法，你将重新分配一个具有各自ID的新对象。</p><p id="3fb0" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">为什么这很重要，Python对待可变和不可变对象的方式有多不同</strong></p><p id="7c43" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">记住这一点很重要，以免混淆行为并产生意外的结果，因为在C、Java和其他语言中，原始变量的副本是在函数中处理的。如果有一个变量引用一个可变对象，然后将第一个变量的值赋给一个新变量，它们将被同等地修改。但是如果你用相同的可变对象创建两个变量，这并不意味着它们引用同一个对象，所以它们将被分别修改。与我们在整数例子中看到的非常不同。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es jv"><img src="../Images/55ca06ee8f2480de787f2f8398041169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1RQUYv5VMN2IRHPV-BgkA.png"/></div></div></figure><p id="386a" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><strong class="ir ht">参数如何传递给函数，这对可变和不可变对象意味着什么</strong></p><p id="bb53" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在python中，所有的变量都作为对函数的引用来传递，也就是说，在函数内部，它将具有相同的id。作为参数传递给函数的对象的行为取决于它是可变的还是不可变的。在对该参数执行改变其值的操作时，可变变量修改了超出函数范围的变量的原始值。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es js"><img src="../Images/d83fd43835b89e0d5a38063ac8c9e8f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:888/format:webp/1*0_-kDkLA5LJs1kSj8il1UQ.png"/></div></figure><p id="c04f" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我再举一个同样的例子，我们通过打印函数前后的id来修改函数的列表，函数保持不变，但是列表被修改了。</p><figure class="jo jp jq jr fd hj er es paragraph-image"><div class="er es jw"><img src="../Images/805175f1d87bde0f30e7e030e6bcc23d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1206/format:webp/1*4yULDLOOAWYmsqwcy-wcew.png"/></div></figure><p id="5428" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">另一方面，不可变的也接收相同的引用，但是当操作它的值时，分配新id的行为将与重新分配相同。</p></div><div class="ab cl jx jy go jz" role="separator"><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc kd"/><span class="ka bw bk kb kc"/></div><div class="ha hb hc hd he"><p id="7c21" class="pw-post-body-paragraph ip iq hs ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated"><em class="ju">原载于</em><a class="ae ke" href="https://www.linkedin.com/pulse/python3-mutable-immutable-everything-object-hern%25C3%25A1ndez-morales" rel="noopener ugc nofollow" target="_blank"><em class="ju">https://www.linkedin.com</em></a><em class="ju">。</em></p></div></div>    
</body>
</html>