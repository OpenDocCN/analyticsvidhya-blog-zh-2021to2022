<html>
<head>
<title>Recursion — A dream within a dream</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">递归——梦中的梦</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/recursion-a-dream-within-a-dream-6a8dd2a5a775?source=collection_archive---------11-----------------------#2021-02-03">https://medium.com/analytics-vidhya/recursion-a-dream-within-a-dream-6a8dd2a5a775?source=collection_archive---------11-----------------------#2021-02-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/c4e644db6b06cfe3dd49e297e40014a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u_3SeZ-PTg3uBPoefsaD5Q.jpeg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">照片由<a class="ae it" href="https://unsplash.com/@jaakkok?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">雅克·肯帕宁</a>在<a class="ae it" href="https://unsplash.com/s/photos/spiral-staircase?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="2f17" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">有一个关于递归的厚颜无耻的笑话我忍不住用在这里“要理解递归，你必须先理解递归”。</p><p id="9d76" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这可能是正确的，但有一个警告:像俄罗斯娃娃一样，递归<strong class="iw hi">不应该永远继续下去，当基本情况满足时，它必须结束。</strong></p><p id="6dd0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">基本情况是什么？</p><p id="fb38" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">好吧，让我们重新开始。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="87d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">什么是递归？</p><p id="cfc0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">递归是函数调用自己，直到它不调用为止。</strong></p><p id="e378" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在计算机科学中，递归函数是由</p><ol class=""><li id="c0e8" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">一个<strong class="iw hi">递归case </strong>，意思是一个case调用自身的一个<strong class="iw hi">更小的</strong>版本，直到它到达…</li><li id="13f7" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">…一个<strong class="iw hi">基础案例</strong>。基本情况是满足停止递归函数的条件。</li></ol><p id="d1c3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果没有基本情况，函数将无限循环，并且不会满足递归定义。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="109f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">迭代vs递归</strong></p><p id="eb65" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在编码中，所有的增量问题都可以通过for和while循环迭代解决。然而，在某些情况下，迭代方法的复杂性可能是压倒性的，它的递归版本将使它更具可读性。</p><p id="3c74" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">树和图的遍历是递归最适合的例子。</p><p id="e89f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">根据<em class="kn">破解编码采访</em>“所有递归算法都可以迭代实现…”。</p><p id="13be" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">这两种方法完成了同样的事情，但是递归似乎更清晰，更容易理解和维护。</p><p id="96bd" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，使用递归并不会带来性能上的好处。甚至，有时循环在这方面更好。递归增加了每次递归调用的内存使用。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="4957" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">让我们看一个例子。</p><p id="8f2b" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下面是一个递归函数的幂函数x^y.</p><p id="2377" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事实上，它已经:</p><ol class=""><li id="baa9" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated">一种<strong class="iw hi">递归情况</strong>:如果y为正，它调用y的较小版本(如果y为负，则调用较大版本)，直到…</li><li id="0099" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated">… y达到0，这是<strong class="iw hi">基本情况</strong>，功能终止。</li></ol><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ko"><img src="../Images/0a08c44d7e829433edb8627dafdfb541.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nRabeQQUCrRh6hms9PfYNg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">幂函数的递归算法</figcaption></figure><p id="e97d" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">例如，为了计算<code class="du kt ku kv kw b">_pow_recursion(2, 3)</code>，递归函数执行以下步骤:</p><ol class=""><li id="9796" class="jz ka hh iw b ix iy jb jc jf kb jj kc jn kd jr ke kf kg kh bi translated"><code class="du kt ku kv kw b">_pow_recursion(2, 3) = 2 * _pow_recursion(2, 2)</code></li><li id="94e6" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><code class="du kt ku kv kw b">_pow_recursion(2, 2) = 2 * _pow_recursion(2, 1)</code></li><li id="0a48" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><code class="du kt ku kv kw b">_pow_recursion(2, 1) = 2 * _pow_recursion(2, 0)</code></li><li id="163e" class="jz ka hh iw b ix ki jb kj jf kk jj kl jn km jr ke kf kg kh bi translated"><code class="du kt ku kv kw b">_pow_recursion(2, 0) = 1</code></li></ol><p id="f62f" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个递归调用都会添加到递归堆栈中。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="df76" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">递归堆栈</strong></p><p id="c2b1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">栈是LIFO(后进先出)对象，这意味着任何添加的项都被“<em class="kn">”推到栈顶。并且每个“<em class="kn">弹出的</em>动作都会移除栈顶的项目。</em></p><p id="cfd2" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">使用堆栈是一种对执行操作进行排序的方法。堆栈跟踪函数调用。</p><p id="5b6c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">下图显示了堆栈在计算递归程序时的样子。</p><p id="301a" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每个连续的函数调用都被推到栈顶，下面的函数等待上面的函数返回。</p><p id="e42e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">每次调用递归函数时，都会生成一个新的堆栈帧，这样每一组局部变量都不会干扰任何其他组。</p><p id="0f46" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从底部开始，它添加<code class="du kt ku kv kw b">2 * _pow_recursion(2, 3 — 1)</code>等等，直到到达最顶部的基本情况/退出条件，这是<code class="du kt ku kv kw b">_pow_recursion(2, 1 — 1)</code>。在堆栈的这一点上，它最终可以通过向下堆栈来计算待定乘法:</p><figure class="kp kq kr ks fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kx"><img src="../Images/b48b29c31b0e851ade440c69b4e695f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PIiJUqUzarVz_7WuYZPWQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">2的堆栈操作</figcaption></figure><p id="c3d3" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">从堆栈顶部，它退出并向下到<code class="du kt ku kv kw b">2 * 2</code>，即<code class="du kt ku kv kw b">4</code>。现在它持有<code class="du kt ku kv kw b">4</code>，但是不能返回，直到它因为一个挂起的乘法而下降，以此类推，直到它到达堆栈的最后，在那里它返回它持有的东西；也就是<code class="du kt ku kv kw b">8</code>。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="c851" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hi">时间复杂度大</strong></p><p id="84d1" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">嵌套调用的最大数量(包括第一个)称为<em class="kn">递归深度</em>。在我们的例子中，它将是<code class="du kt ku kv kw b">y</code>。这个函数在到达基本情况之前被递归地调用<code class="du kt ku kv kw b">y</code>次，所以根据大O符号，它的时间复杂度是<code class="du kt ku kv kw b">O(y)</code>，通常被称为<strong class="iw hi">线性</strong>。</p><p id="0de8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果不满足基本情况退出条件，将发生<strong class="iw hi">堆栈溢出</strong>。</p></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="f9d6" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">在西方艺术史中，mise en abyme是一种正式的技术，在这种技术中，一幅图像包含其自身的一个较小的副本，其顺序似乎无限重现。</p><figure class="kp kq kr ks fd ii"><div class="bz dy l di"><div class="ky kz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">Mise en abyme，不是递归</figcaption></figure></div><div class="ab cl js jt go ju" role="separator"><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx jy"/><span class="jv bw bk jw jx"/></div><div class="ha hb hc hd he"><p id="2254" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">快乐，无限，读书！</p></div></div>    
</body>
</html>