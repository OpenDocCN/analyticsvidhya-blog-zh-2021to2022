<html>
<head>
<title>Object detection on public webcam with OpenCV and YOLOv4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于OpenCV和YOLOv4的公共摄像头目标检测</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/object-detection-on-public-webcam-with-opencv-and-yolov4-9ed51d5896a9?source=collection_archive---------2-----------------------#2021-04-15">https://medium.com/analytics-vidhya/object-detection-on-public-webcam-with-opencv-and-yolov4-9ed51d5896a9?source=collection_archive---------2-----------------------#2021-04-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/7bafeffc7f616732ac2501bbc2bb19a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Umr6Rfhw8FYlEBYkwHb7pw.jpeg"/></div></div></figure><p id="609c" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我已经用Tensorflow和OpenCV写了几篇关于对象检测的文章。现在我想尝试用Tensorflow和OpenCV在<strong class="ir hi">公共网络摄像头</strong>上<strong class="ir hi">检测人</strong>。<br/>嗯，结果令人失望。我尝试了来自Tensorflow模型动物园的三种不同的模型，但由于网络摄像头上的人太少，它们都不起作用。这些模型几乎检测不到任何远离相机的东西。<br/>以前我看过很多视频，在这些视频中，YOLO、v3或v4都能成功检测出离摄像机很远的人，所以我决定现在试一试。</p><h1 id="ed8d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用CUDA和cuDNN支持GPU加速，从源代码构建OpenCV</h1><p id="fae5" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我有一个英伟达RTX 2080 GPU，所以我想确保OpenCV上的GPU支持加快了对象检测。<br/>默认情况下，当您安装OpenCV for Python时，它不支持GPU和CUDA。您可以在Python解释器中使用以下命令轻松检查这一点:</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es kr"><img src="../Images/860dcb7f79132bd5a71862e219ec7299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FbH0PEH7FLi00qwJCyd2CA.png"/></div></div></figure><p id="2049" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你想在OpenCV中使用带有CUDA的GPU，你必须在本地机器上从头开始构建OpenCV。老实说，这是整个YOLO经历中最困难的部分。<br/>我有一台Windows 10机器，所以我按照【TheCodingBug频道的这个惊人的循序渐进教程从源代码构建OpenCV。在找到这个视频之前，我努力让它工作。<br/>我只是总结了下面的步骤，如需进一步参考，请查看上面链接的视频。</p><h2 id="0f14" class="kw jp hh bd jq kx ky kz ju la lb lc jy ja ld le kc je lf lg kg ji lh li kk lj bi translated">先决条件</h2><p id="790f" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从头开始构建OpenCV需要以下先决条件:</p><ul class=""><li id="7fa3" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">安装了蟒蛇</li><li id="828c" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><a class="ae jn" href="https://visualstudio.microsoft.com/downloads/" rel="noopener ugc nofollow" target="_blank"> Visual Studio 2019 </a>安装了C++的桌面开发</li><li id="638d" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><a class="ae jn" href="https://developer.nvidia.com/cuda-downloads?" rel="noopener ugc nofollow" target="_blank">安装CUDA </a>和<a class="ae jn" href="https://developer.nvidia.com/cudnn" rel="noopener ugc nofollow" target="_blank"> cuDNN </a></li><li id="a846" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated"><a class="ae jn" href="https://cmake.org/download/" rel="noopener ugc nofollow" target="_blank"> CMake GUI </a>已安装</li></ul><h2 id="8ac6" class="kw jp hh bd jq kx ky kz ju la lb lc jy ja ld le kc je lf lg kg ji lh li kk lj bi translated">构建OpenCV的步骤</h2><p id="7727" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">从OpenCV github页面下载最新稳定版本的代码。我们将使用可以下载的4.5.1版本<a class="ae jn" href="https://github.com/opencv/opencv/tree/4.5.1" rel="noopener ugc nofollow" target="_blank">这里</a>为. zip文件。</p><p id="1226" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">我们将需要一些额外的模块，也必须从源构建，下载为。来自opencv_contrib github库的zip文件。请确保您下载的版本与您为OpenCV下载的版本相同。现在我们将在这里也使用4 . 5 . 1<a class="ae jn" href="https://github.com/opencv/opencv_contrib/tree/4.5.1" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="fad0" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">创建一个名为<em class="ly"> opencv </em>的新目录，在这里提取<em class="ly"> opencv </em>和<em class="ly"> opencv_contrib </em>。另外，在同一个文件夹中创建一个名为<em class="ly"> build </em>的新的空文件夹。这是开始构建OpenCV之前的样子。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div class="er es lz"><img src="../Images/8be14a96674989f42f11450326d124b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*eV8HyuZrsTRlIv3z-MLS4g.png"/></div></figure><p id="e9ef" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">打开CMake GUI，按照上面创建的方式设置正确的路径</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ma"><img src="../Images/200ef55ed1b25c179b3e49b46be75ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ydUn_vgocTXHL5BrCT9oww.png"/></div></div></figure><p id="0eb9" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当您第一次点击configure时，CMake会询问生成器平台。确保为Windows 10机器选择x64。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mb"><img src="../Images/684f8bae12a7dc2ce3d7fc5c2347d34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EwaMlL2OUMrd_h4DQZRjsw.png"/></div></div></figure><p id="7212" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当生成完成时，检查Python 3部分是否出现在控制台输出中，<strong class="ir hi">，否则OpenCV将无法在Python中工作</strong>。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mc"><img src="../Images/1208fdf9bc62be7f1a890c75b884d5b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j4tnwwM4fbnN0jdw3I32CQ.png"/></div></div></figure><blockquote class="md me mf"><p id="43fb" class="ip iq ly ir b is it iu iv iw ix iy iz mg jb jc jd mh jf jg jh mi jj jk jl jm ha bi translated">如果不存在，可能有多种原因。我面对两个。第一:Anaconda没有在您的系统中注册为默认的Python解释器。解决方案:我必须在安装过程中勾选正确的复选框来重新安装Anaconda。二:numpy版本与要构建的OpenCV版本不匹配。这对我来说有点神奇，为什么OpenCV 4.5.1必须安装1.19.5 numpy版本，但在那之后它就工作了。<br/>此时您所做的任何更改，都必须重新开始整个过程，直到Python 3部分出现。重新开始之前，请确保按下文件/删除缓存。</p></blockquote><p id="fb06" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">您必须设置以下配置选项并点击<em class="ly">配置</em>:</p><ul class=""><li id="7843" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">使用_CUDA</li><li id="1115" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">OPENCV_DNN_CUDA</li><li id="75bd" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">启用_快速_数学</li><li id="d393" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">OPENCV _ EXTRA _ MODULES _ PATH =<opencv-contrib directory="" path="">/模块</opencv-contrib></li></ul><p id="3b18" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">当配置发生时，在维基百科页面中找到适合你的GPU的计算能力版本。2080年的RTX是7.5。<br/>配置完成后，设置以下配置选项并再次点击配置:</p><ul class=""><li id="a68b" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">CUDA _快速_数学</li><li id="eea5" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">CUDA_ARCH_BIN= <compute capability="" version="" e.g.="" remove="" the="" rest.=""/></li></ul><p id="2d29" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">配置完成后，控制台看起来没有错误，按下<em class="ly">生成</em>按钮。它将在<em class="ly"> build </em>文件夹中生成在Visual Studio中构建OpenCV所需的文件。</p><p id="d678" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">生成完成后，在Visual Studio <em class="ly">中打开<em class="ly"> build/OpenCV.sln </em>。</em></p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mj"><img src="../Images/5b42b21c03ac4a8263ddc3763f676296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2uFfIn024GR-nIRPYaSXEA.png"/></div></div></figure><p id="0844" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先，在菜单栏中将解决方案配置<strong class="ir hi">从Debug改为Release </strong>。然后在解决方案浏览器中，右击CMakeTargets/ALL_BUILD并点击<em class="ly"> Build </em>。<strong class="ir hi">建造这个项目</strong>至少需要30分钟。构建完成且没有错误后，右键单击CMakeTargets/INSTALL并点击<em class="ly"> Build </em>。</p><p id="508b" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">以上步骤将为<em class="ly">基础</em> conda环境安装OpenCV <strong class="ir hi">。如果要使用不同的环境，请确保在开始整个过程之前更改以下配置选项:</strong></p><ul class=""><li id="697a" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">PYTHON3 _可执行文件</li><li id="0d79" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">PYTHON3 _ INCLUDE _目录</li><li id="e088" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">PYTHON3 _库</li><li id="6770" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">PYTHON3_NUMPY_INCLUDE_DIRS</li><li id="30e6" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">PYTHON3_PACKAGES_PATH</li></ul><h2 id="c586" class="kw jp hh bd jq kx ky kz ju la lb lc jy ja ld le kc je lf lg kg ji lh li kk lj bi translated">验证OpenCV构建成功</h2><p id="3d90" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">要验证OpenCV是否可以在您的conda环境中使用Python并支持GPU，请在您的环境中运行与上面相同的命令。您应该看到有1个支持CUDA的设备可用</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mk"><img src="../Images/d423307fd1ae84ffb93298c1f2e35244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m-kKsL8YYA6r74CE9Vz6cg.png"/></div></div></figure><h1 id="ef41" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated">使用YOLOv4进行对象检测</h1><h2 id="7bf4" class="kw jp hh bd jq kx ky kz ju la lb lc jy ja ld le kc je lf lg kg ji lh li kk lj bi translated">准备预训练模型</h2><p id="3a8e" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">现在有趣的部分来了，物体检测本身。</p><p id="dca1" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">在你的机器上的任何地方创建一个文件夹，姑且称之为<em class="ly">模型</em>。该文件夹将包含对象检测所需的所有文件。</p><p id="6293" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">首先从<a class="ae jn" href="https://github.com/AlexeyAB/darknet/tree/master/data" rel="noopener ugc nofollow" target="_blank"> darknet github页面</a>下载<em class="ly"> coco.names </em>。这个文件包含YOLOv4可以检测到的类名。将该文件复制到<em class="ly">模型</em>文件夹中。<br/>在同一个github存储库上从<a class="ae jn" href="https://github.com/AlexeyAB/darknet#pre-trained-models" rel="noopener ugc nofollow" target="_blank">预训练模型部分</a>下载<em class="ly"> yolov4.cfg </em>和<em class="ly"> yolov4.weights </em>文件并复制到<em class="ly">模型</em>文件夹中。</p><h2 id="d7ff" class="kw jp hh bd jq kx ky kz ju la lb lc jy ja ld le kc je lf lg kg ji lh li kk lj bi translated">使用公共网络摄像头进行检测</h2><p id="b783" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">我最初的想法是检测网络摄像机直播流中的物体，因为在正在发生的事情上实时展示这一点非常壮观。</p><p id="0c29" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">所有公共网络摄像机都以某种视频流格式发布它们的视频。我最初感兴趣的网络摄像机使用的是<a class="ae jn" href="https://en.wikipedia.org/wiki/M3U#M3U8" rel="noopener ugc nofollow" target="_blank"> M3U8 </a>格式，但也有其他可用的格式。</p><blockquote class="md me mf"><p id="eca3" class="ip iq ly ir b is it iu iv iw ix iy iz mg jb jc jd mh jf jg jh mi jj jk jl jm ha bi translated">事实上，我发现的大多数网络摄像头都使用Youtube直播功能，这需要稍微不同的方法。我将在随后的文章中讨论这个问题。</p></blockquote><p id="813f" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">幸运的是，OpenCV可以轻松处理这些格式。</p><p id="9dab" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如果你到了这一步，你可能想从我的github库下载用于对象检测的Python代码，并开始使用它。<br/>为了在不理解底层逻辑的情况下进行尝试，您需要做的只是提供四个参数:</p><ul class=""><li id="baff" class="lk ll hh ir b is it iw ix ja lm je ln ji lo jm lp lq lr ls bi translated">网络摄像机流url</li><li id="79fa" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">一个可选的<em class="ly"> frame_size </em>参数，以防视频分辨率对您的显示器来说太高。如果原始尺寸适合您的显示器，请保持无。</li><li id="0077" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">检测的置信阈值。它将显示置信度高于该阈值的那些对象的边界框</li><li id="9cca" class="lk ll hh ir b is lt iw lu ja lv je lw ji lx jm lp lq lr ls bi translated">控制重叠边界框行为的重叠阈值</li></ul><pre class="ks kt ku kv fd ml mm mn mo aw mp bi"><span id="c4ae" class="kw jp hh mm b fi mq mr l ms mt">video_url = "https://cdn-004.whatsupcams.com/hls/hr_pula01.m3u8"<br/>frame_width = 1200<br/>confidence_threshold = 0.6<br/>overlapping_threshold = 0.1</span><span id="07ef" class="kw jp hh mm b fi mu mr l ms mt">if __name__ == '__main__':<br/>    get_yolo_preds(net, video_url, confidence_threshold, overlapping_threshold, labels,frame_width)</span></pre><p id="55c4" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">就是这样！您现在可以执行Python脚本，如果您正确地遵循了上面的说明，一个新的窗口应该会出现，检测您最喜欢的公共网络摄像头流中的对象。<br/>我正在试验的是克罗地亚普拉市的一个公共网络摄像头。</p><figure class="ks kt ku kv fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/a3993a2e02a7eed98beec32a711fc02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UPNpwKmehleH-VNfTBot9A.jpeg"/></div></div><figcaption class="mv mw et er es mx my bd b be z dx translated">YOLOv4在公共网络摄像头上检测到的对象</figcaption></figure><p id="ba79" class="pw-post-body-paragraph ip iq hh ir b is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm ha bi translated">如你所见，模型没有检测到几个人。如果我们想要改进检测并确保成功检测到场景中的大多数人，我们需要定制模型并为自己训练我们的模型。这是我将在下一篇文章中做的。</p></div><div class="ab cl mz na go nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ha hb hc hd he"><h1 id="895f" class="jo jp hh bd jq jr ng jt ju jv nh jx jy jz ni kb kc kd nj kf kg kh nk kj kk kl bi translated">结论</h1><p id="1540" class="pw-post-body-paragraph ip iq hh ir b is km iu iv iw kn iy iz ja ko jc jd je kp jg jh ji kq jk jl jm ha bi translated">感谢您通读我的文章。总结一下我目前为止对YOLOv4的体验:我发现预先训练的模型相当不准确，屏幕上有很多分类错误或未检测到的对象。这些对于人类来说非常容易检测，但对于通用的预训练模型来说显然不那么容易。为了达到更高的精度，我们必须在我们自己的对象类上训练我们自己的模型。这正是我在下一篇文章中要做的。</p></div></div>    
</body>
</html>