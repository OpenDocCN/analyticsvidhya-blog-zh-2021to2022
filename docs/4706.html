<html>
<head>
<title>Mergesort &amp; Quicksort: a simple Python implementation.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Mergesort &amp; Quicksort:简单的Python实现。</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/most-famous-ready-to-use-sorting-algorithms-in-python-7f0e5dfca975?source=collection_archive---------1-----------------------#2022-01-11">https://medium.com/analytics-vidhya/most-famous-ready-to-use-sorting-algorithms-in-python-7f0e5dfca975?source=collection_archive---------1-----------------------#2022-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/d36e0ac157cbbcc5e533c48712109166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T9MhUglvUb5uR8yN34IbGg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">图片来自<a class="ae it" href="https://www.crio.do/blog/top-10-sorting-algorithms/" rel="noopener ugc nofollow" target="_blank"> Crio。做</a></figcaption></figure><p id="1946" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我知道你现在在想什么:使用<code class="du js jt ju jv b">sort()</code> Python方法是一个如此快速简单的选择。为什么我要从头开始实现排序算法？</p><p id="1c8c" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">如果你是一名计算机科学的学生，或者如果你只是想学习编程，没有比把手弄脏更好的理解代码的方法了。你越是尝试自己的实现，它的功能就越会留在你的脑海中。算法对你来说将不再有秘密。</p><p id="83f0" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">然而，作为一个有7年研究算法经验的计算机科学家，我知道从头开始编写自己的代码一点也不容易。出于这个原因，在本文中我想推荐一些最著名的<strong class="iw hi">排序算法的最简单的实现(用Python)。</strong>对于每一个，我首先介绍伪代码(作为一个开始的框架，以防你喜欢用其他编程语言构建自己的实现)，然后我推荐一个现成的Python代码，你可以立即复制和测试。</p><div class="jw jx ez fb jy jz"><a href="https://replit.com/@DILETTAGOGLIA/Sorting-algorithm-for-RAM-models" rel="noopener  ugc nofollow" target="_blank"><div class="ka ab dw"><div class="kb ab kc cl cj kd"><h2 class="bd hi fi z dy ke ea eb kf ed ef hg bi translated">排序算法(适用于RAM型号)</h2><div class="kg l"><h3 class="bd b fi z dy ke ea eb kf ed ef dx translated">DILETTAGOGLIA回复的Python</h3></div><div class="kh l"><p class="bd b fp z dy ke ea eb kf ed ef dx translated">replit.com</p></div></div><div class="ki l"><div class="kj l kk kl km ki kn in jz"/></div></div></a></div><blockquote class="ko"><p id="012c" class="kp kq hh bd kr ks kt ku kv kw kx jr dx translated">⬆⬆⬆:这是我的repl的链接，在这里你可以找到并尝试本文中所有的实现！</p></blockquote></div><div class="ab cl ky kz go la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ha hb hc hd he"><p id="0cbe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我真的希望这对你理解和体验编码有所帮助。</p><p id="6698" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们开始吧！</p><h1 id="4c5c" class="lf lg hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">前提:符号和辅助功能。</h1><ul class=""><li id="5285" class="md me hh iw b ix mf jb mg jf mh jj mi jn mj jr mk ml mm mn bi translated"><strong class="iw hi"> <em class="mo"> V </em> </strong>是要排序的数组</li><li id="50dc" class="md me hh iw b ix mp jb mq jf mr jj ms jn mt jr mk ml mm mn bi translated"><strong class="iw hi"> <em class="mo"> n </em> </strong>是数组中的项数</li><li id="5d53" class="md me hh iw b ix mp jb mq jf mr jj ms jn mt jr mk ml mm mn bi translated"><strong class="iw hi"> <em class="mo"> l </em> </strong>和<strong class="iw hi"> <em class="mo"> r </em> </strong>分别是左右指针</li><li id="0ace" class="md me hh iw b ix mp jb mq jf mr jj ms jn mt jr mk ml mm mn bi translated"><strong class="iw hi"> <em class="mo"> swap </em> </strong>是将数组<strong class="iw hi"><em class="mo"/></strong><em class="mo"/>中的两个项目<strong class="iw hi"> <em class="mo"> i </em> </strong>和<strong class="iw hi"> <em class="mo"> j </em> </strong>互换(即同时赋值两个值)的辅助程序，定义如下:</li></ul><figure class="mu mv mw mx fd ii"><div class="bz dy l di"><div class="my mz l"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">辅助程序“交换”</figcaption></figure><h1 id="0c9c" class="lf lg hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">1.合并排序</h1><figure class="mu mv mw mx fd ii er es paragraph-image"><div class="er es na"><img src="../Images/4300dee9f0581fef7cba45352ba7de79.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*opwN0BhtH4zvPF697fPlow.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">维基百科中的GIF合并排序</figcaption></figure><h2 id="cdd8" class="nb lg hh bd lh nc nd ne ll nf ng nh lp jf ni nj lt jj nk nl lx jn nm nn mb no bi translated">伪代码:</h2><figure class="mu mv mw mx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es np"><img src="../Images/749cc8d41132177b0503fdf9b906599b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-9tAICmCmoN_d5YUVQvuPw.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">按作者合并排序伪代码</figcaption></figure><p id="99dc" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Mergesort是一个基于<a class="ae it" href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="noopener ugc nofollow" target="_blank"> <strong class="iw hi">除法&amp;征服</strong>范式</a>的<strong class="iw hi">递归</strong>算法。</p><p id="3fc8" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">步骤1检查要排序的数组是否至少包含两项，否则它已经被排序，不需要做任何事情。如果条目至少有两个，它将输入数组<em class="mo"> S </em>分成两半，然后在每一部分上递归。当递归结束时，两半<em class="mo"> S[l，m -1] </em>和<em class="mo"> S [m，r] </em>被排序，以便步骤5通过调用过程<code class="du js jt ju jv b">merge</code>在<em class="mo"> S[l，r] </em>中融合它们。这个合并步骤需要一个大小为<em class="mo"> n </em>的辅助数组(在我们的实现中我们称之为<code class="du js jt ju jv b">temp</code>),因此<strong class="iw hi"> MergeSort不是一个就地排序算法</strong>(不像Heapsort和Quicksort)而是需要O( <em class="mo"> n </em>)的额外工作空间。假设，在每次递归调用时，我们将待排序的输入数组的大小减半，那么<strong class="iw hi">递归调用的总数为O(log <em class="mo"> n </em> ) </strong>。</p><p id="f023" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">通过使用两个指针<em class="mo"> i </em>和<em class="mo"> j </em>，可以在O( <em class="mo"> r - l+1 </em>)时间内执行<code class="du js jt ju jv b">merge</code>过程，这两个指针开始于两个半部分<em class="mo">S【l，m-1】</em>和<em class="mo">S【m，r】</em>的开始处。然后将<em class="mo"> S[i] </em>与<em class="mo"> S[j] </em>进行比较，在融合序列中写出较小者，并将其指针前移。假设每次比较前进一个指针，总步数的上限是指针前进的总步数，上限是<em class="mo"> S[l，r] </em>的长度。所以MergeSort( <em class="mo"> S，1，n </em>)的<strong class="iw hi">时间复杂度</strong>可以通过递推关系T(<em class="mo">n</em>)= 2T(<em class="mo">n</em>/2)+O(<em class="mo">n</em>)= O(<em class="mo">n</em>log<em class="mo">n</em>)来建模。</p><h2 id="552b" class="nb lg hh bd lh nc nd ne ll nf ng nh lp jf ni nj lt jj nk nl lx jn nm nn mb no bi translated">实施:</h2><figure class="mu mv mw mx fd ii"><div class="bz dy l di"><div class="my mz l"/></div></figure><h1 id="3fad" class="lf lg hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">2.快速排序</h1><figure class="mu mv mw mx fd ii er es paragraph-image"><div class="er es na"><img src="../Images/9ef858c84361b7c5bda3a22e4882fc95.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/1*QlYf6-SE1Eq0_V-vKm1vtg.gif"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">维基共享的快速排序GIF</figcaption></figure><h2 id="62d7" class="nb lg hh bd lh nc nd ne ll nf ng nh lp jf ni nj lt jj nk nl lx jn nm nn mb no bi translated">伪代码:</h2><figure class="mu mv mw mx fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nq"><img src="../Images/718258a2fc8242b1d4447ce107b9df29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17UgL-9obPVtxun3QMdD_A.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">作者的快速排序伪代码</figcaption></figure><p id="844e" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关键思想是<strong class="iw hi">将</strong>输入数组<em class="mo"> S[i，j] </em>分成两部分，使得其中一部分包含的项目小于(或等于)后一部分包含的项目。这种划分是保序的，因为在两次递归调用后，不需要后续步骤来重新组合有序片段。通常，通过选择一个输入项作为中枢，并根据所有其他输入项是否小于/大于中枢，将它们分配到两个子数组中，来实现分区。与轴心相等的项目可以存储在任何地方。在伪代码中，为了简单起见，强制主元大约出现在要排序的数组的中间(步骤4)。</p><p id="34fe" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请注意，为了实现快速排序的执行效率，我们应该注意两个形成的片段的大小之间的比率，因为它们越平衡，快速排序就越接近Mergesort <br/>，从而接近O( <em class="mo"> n </em> log <em class="mo"> n </em>)的<strong class="iw hi">最优时间复杂度</strong>。在完全不平衡分区的<strong class="iw hi">(最坏)情况</strong>下，其中一个块可能为空(即<em class="mo"> p </em> = <em class="mo"> i </em>或<em class="mo"> p </em> = <em class="mo"> j </em>)，快速排序的时间复杂度为O( <em class="mo"> n </em>)。</p><h2 id="7388" class="nb lg hh bd lh nc nd ne ll nf ng nh lp jf ni nj lt jj nk nl lx jn nm nn mb no bi translated">实施:</h2><figure class="mu mv mw mx fd ii"><div class="bz dy l di"><div class="my mz l"/></div></figure><p id="46c7" class="pw-post-body-paragraph iu iv hh iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我真的希望这对你有所帮助。如果你喜欢这篇文章，请支持我👏🏻。谢谢，享受你的算法之旅！</p><h1 id="b348" class="lf lg hh bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">参考资料:</h1><ul class=""><li id="8574" class="md me hh iw b ix mf jb mg jf mh jj mi jn mj jr mk ml mm mn bi translated">页（page的缩写）费拉吉娜，<em class="mo">算法的魔力！</em>，比萨大学，2020年</li><li id="2de5" class="md me hh iw b ix mp jb mq jf mr jj ms jn mt jr mk ml mm mn bi translated">F.Romani，<em class="mo">Elementi di algoritimica con esercizi svolti ed esempi in Phyton，</em> <strong class="iw hi"> </strong>第二版，比萨大学出版社，2017年</li><li id="cfe6" class="md me hh iw b ix mp jb mq jf mr jj ms jn mt jr mk ml mm mn bi translated">托马斯·h·科尔曼，查尔斯·e·莱瑟森，罗纳德·L·李维斯特，克利福德·斯坦，<a class="ae it" href="https://mitpress.mit.edu/books/introduction-algorithms-third-edition" rel="noopener ugc nofollow" target="_blank"><em class="mo"/></a>算法导论，第三版，麻省理工学院出版社，2009年</li></ul></div></div>    
</body>
</html>