<html>
<head>
<title>ScaNN: Faster vector similarity search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ScaNN:更快的向量相似性搜索</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scann-faster-vector-similarity-search-69af769ad474?source=collection_archive---------3-----------------------#2021-09-06">https://medium.com/analytics-vidhya/scann-faster-vector-similarity-search-69af769ad474?source=collection_archive---------3-----------------------#2021-09-06</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/556297a374985926359eb4d60c29a959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SDGlOx00ZufqiOfg48G1mg.jpeg"/></div></div></figure><p id="2608" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi jo translated">研究永远是人类生活的一部分，每当有人遇到阻碍或困难时，他们总会寻找解决方法。如今，随着世界的发展，计算机技术发展得令人难以置信，但我们将永远寻找高效和优化的方法。最近TensorFlow发布了ScaNN，这是一个快速高效的向量相似性搜索库，可以托管在您的机器上。已经证明，在相同的准确度下，它比大多数相似性搜索库的性能高出2倍。请在他们的博客上读一读</p><p id="0ea7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">概述:</strong></p><p id="013e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">ScaNN使用不同的方法处理数据中嵌入的量化，而不是通常的直接量化数据集中数据点的方法。例如:假设<em class="jx"> x1 </em>和<em class="jx"> x2 </em>是数据库中的两组嵌入，我们想要从<em class="jx"> x1 </em>和<em class="jx"> x2之一中找到与<em class="jx"> q </em>最相似的向量。</em>传统方法通过计算<em class="jx"> c1 </em>和<em class="jx"> c2 </em>在<em class="jx"> q、</em>上的投影(内积),发现<em class="jx">C1</em>和<em class="jx">C2</em>是<em class="jx"> x1 </em>和<em class="jx"> x2 </em>的量化版本，但是利用<a class="ae jy" href="https://pypi.org/project/scann/" rel="noopener ugc nofollow" target="_blank">扫描<strong class="is hj">扫描</strong>扫描</a>试图计算它们在<em class="jx"> q </em>的垂直向量上的投影，从而已经证明减少了延迟并提高了相似性得分的准确性。下面的图像描述了相同的。</p><figure class="ka kb kc kd fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es jz"><img src="../Images/279bb99b59f11cb70e696c3cd4a119a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5Nb962XWzRBWEyRHBoRsg.png"/></div></div></figure><p id="357b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">正如你在上面看到的，我们左边的方法(传统的)实际上离q更远，即(x2实际上比x1更类似于q，但是它计算出相反的q.c2 &gt; q.c1)，而我们右边的方法(<strong class="is hj"> ScaNN </strong>)计算得更快更精确，即(x2比x1更类似于q，所以q.x2 &lt; q.x1)。请多读读上面的博客，以便更好地理解它。</p><p id="4b51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">要点记住:</strong></p><p id="cd10" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们尝试一些场景，我们可以使用ScaNN来加快和优化我们的搜索解决方案，并与其他库进行比较。</p><p id="3c91" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用ScaNN库创建搜索器时，请记住这些要点。</p><ul class=""><li id="fc46" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">如果我们有更少的数据点，我们应该尝试使用暴力评分方法，而不是不对称散列方法</li><li id="a53a" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">要创建的叶子数量接近数据点数量的平方根</li><li id="d5dd" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">训练样本大小应该总是大于创建的叶/簇的数量</li></ul><p id="fe0f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">更多优化指针可用<a class="ae jy" href="https://github.com/google-research/google-research/blob/master/scann/docs/algorithms.md" rel="noopener ugc nofollow" target="_blank"> <em class="jx">此处</em> </a> <em class="jx">。</em></p><p id="f4a8" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">实现:</strong></p><p id="c61c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">对于这个例子，我采用了在Kaggle开源的FIFA 20数据集。这个例子的目的是找到与被查询的特定玩家相似的玩家集合。我做了简单的预处理，如特征选择、文本分析，并将特征集缩小到相关的数量。让我们看看如何使用ScaNN和sklearn度量中的余弦相似性来实现类似的玩家搜索解决方案。数据集如下图所示。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><ul class=""><li id="d65b" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated">在搜索器中使用数据集之前对其进行规范化。</li><li id="e9b4" class="ke kf hi is b it kn ix ko jb kp jf kq jj kr jn kj kk kl km bi translated">按照上面定义的参数构建搜索器</li></ul><p id="f80f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在我们的例子中，因为玩家的数量大约是18000，所以叶子的数量大约是135，要搜索的叶子应该少于135，并且在每个叶子中创建的训练样本也应该少于18000。要将所有内容放入搜索器功能中，我们需要执行以下操作:</p><p id="f9c7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">此外，下面的代码片段涵盖了使用sklearn的实现。</p><figure class="ka kb kc kd fd ij"><div class="bz dy l di"><div class="ks kt l"/></div></figure><p id="9743" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结果:</strong></p><ul class=""><li id="913a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated"><strong class="is hj"> ScaNN结果:</strong>玩家姓名和相似度得分以及所用时间相同。</li></ul><p id="0f4f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">布卡约·萨卡人:</p><pre class="ka kb kc kd fd ku kv kw kx aw ky bi"><span id="5a33" class="kz la hi kv b fi lb lc l ld le">Wall time: 803 µs</span><span id="ce88" class="kz la hi kv b fi lf lc l ld le">9896       bukayo saka  1.000000<br/>14031      aitor lorea  0.997321<br/>5872    héctor fertoli  0.997269<br/>8875       jacob brown  0.997254<br/>1622   justin kluivert  0.997196<br/>5743   tomás chancalay  0.997161<br/>10078      hilary gong  0.997085<br/>13294    leo bengtsson  0.997068<br/>13278  jerome sinclair  0.997060<br/>999      matías vargas  0.996918</span></pre><p id="b3b7" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约翰·斯通斯:</p><pre class="ka kb kc kd fd ku kv kw kx aw ky bi"><span id="95e6" class="kz la hi kv b fi lb lc l ld le">Wall time: 725 µs</span><span id="d7bd" class="kz la hi kv b fi lf lc l ld le">172           john stones  1.000000<br/>56      marcos marquinhos  0.998611<br/>774           nico elvedi  0.998170<br/>1305          rob holding  0.997904<br/>246      presnel kimpembe  0.997853<br/>4914        kévin n'doram  0.997837<br/>84        clément lenglet  0.997836<br/>755           declan rice  0.997756<br/>2268       alexander hack  0.997624<br/>414   andreas christensen  0.997615</span></pre><p id="da62" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">麦克托米内:</p><pre class="ka kb kc kd fd ku kv kw kx aw ky bi"><span id="49cc" class="kz la hi kv b fi lb lc l ld le">Wall time: 434 µs</span><span id="0ac7" class="kz la hi kv b fi lf lc l ld le">1028     scott mctominay  1.000000<br/>1961  younousse sankharé  0.998196<br/>601         tomáš souček  0.998192<br/>1808       lukas lerager  0.998001<br/>996         marko grujić  0.997909<br/>2582      diego gonzález  0.997841<br/>2286         lucas silva  0.997767<br/>79         rodrigo rodri  0.997743<br/>338             emre can  0.997738<br/>818       soualiho meïté  0.997732</span></pre><ul class=""><li id="007a" class="ke kf hi is b it iu ix iy jb kg jf kh jj ki jn kj kk kl km bi translated"><strong class="is hj">使用Sklearn </strong></li></ul><p id="29b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">布卡约·萨卡人</p><pre class="ka kb kc kd fd ku kv kw kx aw ky bi"><span id="c45e" class="kz la hi kv b fi lb lc l ld le">Wall time: 4.4 s</span><span id="0661" class="kz la hi kv b fi lf lc l ld le">2431       bojan jokič  0.842173<br/>1724   tomasz kędziora  0.842173<br/>1808     lukas lerager  0.842173<br/>1802  nicolás castillo  0.842173<br/>1799   nicolae stanciu  0.842173<br/>1793     robin quaison  0.842173<br/>1791  dimitrios pelkas  0.842173<br/>1790         tom rogić  0.842173<br/>7616      池忠国 zhongguo  0.842173<br/>1761     ryan christie  0.842173</span></pre><p id="7e70" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">约翰·斯通斯</p><pre class="ka kb kc kd fd ku kv kw kx aw ky bi"><span id="ee4a" class="kz la hi kv b fi lb lc l ld le">Wall time: 4.36 s</span><span id="ef90" class="kz la hi kv b fi lf lc l ld le">2431       bojan jokič  0.842173<br/>1724   tomasz kędziora  0.842173<br/>1808     lukas lerager  0.842173<br/>1802  nicolás castillo  0.842173<br/>1799   nicolae stanciu  0.842173<br/>1793     robin quaison  0.842173<br/>1791  dimitrios pelkas  0.842173<br/>1790         tom rogić  0.842173<br/>7616      池忠国 zhongguo  0.842173<br/>1761     ryan christie  0.842173</span></pre><p id="b65f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">从上述结果的比较中我们可以看出，就结果的精确度和获得所需结果的低延迟而言，ScaNN是一种有效的工具。两种方法的差异在10的数量级，甚至结果的精度似乎也支持ScaNN实现。如果需要的话，在你的任务中试试ScaNN，因为它是向量相似性搜索的一个很好的工具。如果你喜欢，请鼓掌。感谢您的宝贵支持，再见，下次再见。</p></div></div>    
</body>
</html>