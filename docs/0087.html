<html>
<head>
<title>How to deal with missing values in a data set ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理一个数据集中的缺失值？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-deal-with-missing-values-in-data-set-8e8f70ecf155?source=collection_archive---------8-----------------------#2021-01-04">https://medium.com/analytics-vidhya/how-to-deal-with-missing-values-in-data-set-8e8f70ecf155?source=collection_archive---------8-----------------------#2021-01-04</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="7eff" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">现实世界的数据集由缺失值组成，数据科学家花费大量时间进行数据准备，包括数据清理。缺少值可能是未记录的观察结果或数据损坏的结果。</p><p id="0be6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">缺失数据的类型</strong></p><ul class=""><li id="7897" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">随机缺失(MAR)-这意味着缺失值的比例与观察数据之间存在关系。例如，在下图中，我们看到里程列中缺失值的比例与汽车的制造年份相关。因此，可以使用其他特征来预测数据集中这种类型的缺失值。</li></ul><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es jl"><img src="../Images/48a20b28a421702d164503c3411e9e4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:794/format:webp/1*n1VyaGsR05HRINsyafm5GA.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated">缺失值百分比与汽车制造年份的关系。</figcaption></figure><ul class=""><li id="6bd3" class="jc jd hh ig b ih ii il im ip je it jf ix jg jb jh ji jj jk bi translated">完全随机缺失(means这意味着缺失值的比例与数据中的任何观察无关。例如，电子秤电池没电了，因此会丢失一些数据。</li><li id="57af" class="jc jd hh ig b ih jx il jy ip jz it ka ix kb jb jh ji jj jk bi translated">非随机缺失(MNAR)-这意味着缺失的数据与我们未知的因素有关。例如，称重秤机械装置可能会随着时间的推移而磨损，从而随着时间的推移产生更多的缺失值，但我们可能不会注意到同样的情况。如果我们有MNAR丢失机制，我们需要理解为什么数据丢失，而不是直接归咎于它们。</li></ul><p id="3d87" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">在Python中检测缺失值</strong></p><p id="283b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">缺失值的形式可以是空字符串、NA、N/A或None。python中的Pandas将数据中的所有NA或空白值标识为NaN值。但是，它不识别na，？可使用<strong class="ig hi"> df.isnull() </strong>命令检测数据集中的NA或空白值格式。当数据中存在缺失值时，此方法返回布尔响应True。</p><p id="1c3f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是，有时可能会出现数据中缺失值的格式不同的情况。例如，某一列缺少n/a、_ _或na格式的值。在导入数据时，pandas检测数据集中非标准格式的缺失值的一个简单方法是将所有类型的缺失值作为一个列表。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="0fd9" class="kh ki hh kd b fi kj kk l kl km">missing_values = ["n/a", "na", " _ _"]<br/>df = pd.read_csv("loan data.csv", na_values = missing_values)</span></pre><p id="5c0a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在数据集中<strong class="ig hi"> df.isnull()。sum() </strong>命令用于查找数据中每个特征缺失值的总数。</p><p id="76dd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">在Python中可视化缺失值</strong></p><p id="61f2" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">可视化缺失值使分析师能够很好地理解数据集中NaN值的分布。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="1c77" class="kh ki hh kd b fi kj kk l kl km"># Import the library<br/>pip install missingno<br/>import missingno as msno<br/># Visualize the missing values using a matrix <br/>msno.matrix(df)</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div class="er es kn"><img src="../Images/fe3b6125d1a98efa6cfaf78729449a67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1148/format:webp/1*-EnUsrJ0eH2MNEC1oJCdWg.png"/></div><figcaption class="jt ju et er es jv jw bd b be z dx translated"><code class="du ko kp kq kd b">AAWhiteSt-4</code>和<code class="du ko kp kq kd b">SulphidityL-4 columns</code>的失踪模式相似</figcaption></figure><p id="5f32" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">每列中缺失值的计数用条形图表示。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="7012" class="kh ki hh kd b fi kj kk l kl km"># Visualize missing values as a bar chart</span><span id="9110" class="kh ki hh kd b fi kr kk l kl km">msno.bar(df)</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/b07466d5bddcff1b28506459c1d0fc97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*5CW2zDzIK-Lr66xR.png"/></div></div></figure><p id="cccc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">热图表示每列中缺失值之间的相关性。<br/>对应于-1的值表示数据集中的变量A导致其变量b中的值缺失</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="6222" class="kh ki hh kd b fi kj kk l kl km">msno.heatmap(df)</span></pre><figure class="jm jn jo jp fd jq er es paragraph-image"><div role="button" tabindex="0" class="kt ku di kv bf kw"><div class="er es ks"><img src="../Images/16e1d6d5f0f9870786a8f26ad726f129.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*p4gKj91muQpW_JbG.png"/></div></div></figure><p id="fc3e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">处理缺失值的方法</strong></p><p id="7155" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 1删除包含缺失值的列和行</strong></p><p id="fb6d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">删除MCAR数据中包含缺失值的列和行。然而，这种方法的问题是信息的丢失。如果数据中缺失值的数量超过70–75 %,建议删除特定的列。此外，当我们有大型数据集时，我们可以删除包含空值的行。但是，如果数据集中缺失值的百分比大于30 %,则不建议这样做。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="2477" class="kh ki hh kd b fi kj kk l kl km">#Drop the rows with at least one element missing<br/>df.dropna(inplace = True)</span><span id="050a" class="kh ki hh kd b fi kr kk l kl km"># Drop the rows with all the elements missing<br/>df.dropna(how='all',inplace = True)</span><span id="9557" class="kh ki hh kd b fi kr kk l kl km"># Drop the rows with missing values greater than two<br/>df.dropna(thresh=2, inplace = True)</span><span id="6258" class="kh ki hh kd b fi kr kk l kl km"># Drop the rows with at least one missing value in the columns specified in the subset function<br/>df.dropna(subset=['age', 'fare'])</span><span id="c8a7" class="kh ki hh kd b fi kr kk l kl km"># Drop the columns with at least one missing value<br/>df.dropna(axis= 1 , inplace = True)</span><span id="59f4" class="kh ki hh kd b fi kr kk l kl km"># Drop the columns containing all the elements missing<br/>df.dropna(axis= 'columns',how = 'all', inplace = True)</span></pre><p id="0f1d" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 2用平均值、中值和众数输入数据中的缺失值</strong></p><p id="23c1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们可以用特定特征的平均值、中值或众数来替换数据集中的缺失值，但这种方法会导致低估方差，并会增加数据中的偏差。当数据量很小时，这种方法是理想的，因为它有助于防止信息丢失，但在python中进行均值或中值插补时，它没有考虑变量之间的相关性，因为它是一种单变量方法。</p><p id="328b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">例如，在包含“年龄”和“费用”列的数据集中，年龄特征中有缺失值。如果我们用平均年龄来估算缺失值，那么由于年龄和票价特征之间的正相关，可能会导致偏差增加。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="a296" class="kh ki hh kd b fi kj kk l kl km">from sklearn.impute import SimpleImputer<br/>mean_imp = SimpleImputer( strategy='mean') <br/># For Mode replace strategy with most_frequent<br/># For Median replace strategy with Medianmean_imp.fit(train)<br/>train_df = mean_imp.transform(train)</span></pre><p id="b925" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">如果我们希望数据首先被处理为缺失值，然后由我们的模型使用，那么我们可以使用管道，因为这可以防止数据泄漏。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="08d0" class="kh ki hh kd b fi kj kk l kl km">from sklearn.pipeline import Pipeline<br/>from sklearn.impute import SimpleImputer<br/>from sklearn.discriminant_analysis import LinearDiscriminantAnalysis<br/>from sklearn.model_selection import KFold<br/>from sklearn.model_selection import cross_val_score<br/># define the imputer<br/>imputer = SimpleImputer(strategy='mean')<br/># define the model<br/>lda = LinearDiscriminantAnalysis()<br/># define the modeling pipeline<br/>pipeline = Pipeline(steps=[('imputer', imputer),('model', lda)])<br/># define the cross validation procedure<br/>kfold = KFold(n_splits=3, shuffle=True, random_state=1)<br/># evaluate the model<br/>result = cross_val_score(pipeline, X, y, cv=kfold, scoring='accuracy')</span></pre><p id="3476" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 3使用k-NN的插补</strong></p><p id="a560" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kx"> k </em>最近邻是一种算法，其中新点根据其与训练数据集中的点的相似性被分配一个值。这种方法可以通过与缺失数据相邻的非缺失值来估算每个特征的缺失值。根据数据集的不同，它可以提供比众数、中位数或平均数插补更准确的结果。然而，这种方法在计算上是昂贵的，因为整个训练数据集被存储在存储器中，并且与SVM不同，它对数据中的异常值敏感。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="ff9f" class="kh ki hh kd b fi kj kk l kl km">from sklearn.impute import KNNImputer<br/># define imputer<br/>imputer = KNNImputer(n_neighbors=5, weights='uniform', metric='nan_euclidean')<br/># fit on the data set<br/>imputer.fit(X)<br/># fit on the data set<br/>imputer.fit(X)<br/># transform the data set<br/>Xtrans = imputer.transform(X)</span></pre><p id="e9e5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi"> 4链式方程多重插补(小鼠)</strong></p><p id="a1e6" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">MICE是一种多重插补技术，用MAR缺失机制来代替数据集中的缺失值。它使用数据中的其他特征为每个缺失值做出最佳预测。在该算法中，每个缺失值都是根据数据中的观察值建模的。要了解关于MICE算法的更多信息，请查看“<a class="ae ky" rel="noopener" href="/swlh/mice-algorithm-to-impute-missing-values-in-a-dataset-c55d555b6fbe"> <em class="kx"> MICE算法以估算数据集中的缺失值</em> </a>”。该算法可以使用Scikit-learn迭代估算器来实现。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="3a7b" class="kh ki hh kd b fi kj kk l kl km">from sklearn.experimental import enable_iterative_imputer<br/>from sklearn.impute import IterativeImputer</span></pre><p id="7b99" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在此之后，我们将发现X中的值是如何相互关联的，以决定使用哪种算法来估算空值。</p><pre class="jm jn jo jp fd kc kd ke kf aw kg bi"><span id="ecc2" class="kh ki hh kd b fi kj kk l kl km">X.corr()<br/>lr  = LinearRegression()<br/>imp = IterativeImputer(estimator = lr ,verbose = 2 ,max_iter = 30,tol = 1e-10,order = 'roman')<br/>imp.fit(X)<br/>imp.transform(X)</span></pre><p id="1f22" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">结论</strong></p><p id="ac91" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于缺少完整的信息，缺失数据可能会导致无效的结果。它们被处理为在由缺失值组成的数据集上训练ML模型会导致错误，因为python库(包括Scikit learn)不支持它们。<br/>点击💚如果你喜欢这篇文章。有问题可以写在下面的评论区，我会尽力解答。</p></div></div>    
</body>
</html>