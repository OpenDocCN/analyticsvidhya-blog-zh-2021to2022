<html>
<head>
<title>Naughts and Crosses with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Python画十字</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/automated-naughts-and-crosses-with-python-93770fcbb58?source=collection_archive---------4-----------------------#2021-04-03">https://medium.com/analytics-vidhya/automated-naughts-and-crosses-with-python-93770fcbb58?source=collection_archive---------4-----------------------#2021-04-03</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="d42e" class="pw-subtitle-paragraph if hg hh bd b ig ih ii ij ik il im in io ip iq ir is it iu iv iw dx translated">随着技术的进步，一种非常常见的井字游戏——naughts and crosses已经从纸质游戏转移到了我们的笔记本电脑上。这是使用<em class="ie"> Python </em>进行相同设计的一次尝试。</h2></div><p id="ce12" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">对于初学者来说，Python是一门很好的语言。一旦掌握了基本语法，最好开始制作自己的项目。项目是一种很好的学习方式，因为它提供了一个应用所学知识的机会，否则就很难保持同样的知识。</p><p id="b8d7" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">我学习Python已经有一段时间了。作为我的第一个迷你项目，我设计了一个简单的井字游戏。这是一个常见的双人游戏，一个玩家玩crosses ),另一个玩家玩naughts(O ),每个玩家轮流玩。在棋盘上获得三个标记的玩家获胜。如果两个玩家都不能得到这个，游戏就以平局结束。使用一些基本功能在<em class="jt"> Python </em>上创建这个游戏的步骤将在后续步骤中描述。</p><h2 id="f189" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated"><strong class="ak">第一步:格栅板设计</strong></h2><p id="415b" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">通过定义<code class="du ku kv kw kx b">display_board()</code>函数开始制作井字格，该函数将在打印时以网格格式显示</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="0a2b" class="ju jv hh kx b fi lg lh l li lj">def display_board(board):<br/>    print(board[7]+"|"+board[8]+"|"+board[9])<br/>    print("-|-|-")<br/>    print(board[4]+"|"+board[5]+"|"+board[6])<br/>    print("-|-|-")<br/>    print(board[1]+"|"+board[2]+"|"+board[3])<br/>    print("-|-|-")<br/>testing_board=[" "]*10<br/>display_board(testing_board)</span></pre><p id="1af9" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这是纸板的印刷方式</p><figure class="ky kz la lb fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lk"><img src="../Images/e541977fce69994eadbfb497f2a2ad4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*XVaaF7ptZN3ODaTO39iRmw.gif"/></div></div></figure><h2 id="47cb" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">步骤2:选择每个玩家的标记</h2><p id="2601" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">接下来，通过使用<em class="jt">创建<code class="du ku kv kw kx b">player_input()</code>函数来制作玩家标记，同时循环</em>让玩家1选择他/她的标记；一旦玩家1选择了标记，则使用<em class="jt"> if </em>功能将替代标记自动分配给玩家2。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="efbf" class="ju jv hh kx b fi lg lh l li lj">def player_input():<br/>    marker=" "<br/>    while marker !="x" or marker !="o":<br/>        marker= input("player 1 choose x,o: ")</span><span id="74a4" class="ju jv hh kx b fi ls lh l li lj">if marker=="o":<br/>            return("o","x")<br/>        elif marker=="x":<br/>            return ("x","o")<br/>        else:<br/>            return("Please choose appropriate marker")<br/>player_input()</span></pre><figure class="ky kz la lb fd ll er es paragraph-image"><div class="er es lt"><img src="../Images/0fe4a51f2f26303149ce2dc9a08f97cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1368/1*U7vMUudgcwjTjWBlhMpQAQ.gif"/></div></figure><h2 id="b93f" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第三步:决定第一步</h2><p id="8715" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">导入<em class="jt">随机库</em>决定哪个玩家开始游戏。它是<em class="jt"> Python中的一个内置库，</em>用于在两个给定的数字之间生成随机数。定义一个函数<code class="du ku kv kw kx b">first_move()</code>来产生一个随机数，用函数<code class="du ku kv kw kx b">random_randint()</code>在0和1之间决定哪个玩家先开始。如果随机数等于1，那么玩家1将开始游戏。如果是0，那么2号玩家将开始游戏。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="9ede" class="ju jv hh kx b fi lg lh l li lj">import random</span><span id="3cca" class="ju jv hh kx b fi ls lh l li lj">def first_move():<br/>    if random.randint(0,1)==0:<br/>        return "player 2 will start the game"<br/>    else:<br/>        return "player 1 will start the game"</span></pre><h2 id="e8ac" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">步骤4:决定将标记移动到哪里</h2><p id="57d1" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">为了将标记放置在给定的位置，定义一个函数<code class="du ku kv kw kx b">handle_turn()</code>，其中传递3个参数；黑板，记分员和位置。这块板上是井字游戏的格子。标记将是X和o。位置将是标记放置在板上的点。使标记与板上的位置相等。</p><p id="c867" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">可以使用计算机键盘上的数字1-9将标记放置在网格上。设计灵感来自键盘上的数字键盘。</p><figure class="ky kz la lb fd ll er es paragraph-image"><div class="er es lu"><img src="../Images/ce2269b4b1f16154a7bf043fa9f34ee7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*VmqLKmBy_R0omUp0K2L7HA.png"/></div><figcaption class="lv lw et er es lx ly bd b be z dx translated">微软数字键盘</figcaption></figure><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="29ec" class="ju jv hh kx b fi lg lh l li lj">def handle_turn(board,marker,position):<br/>    board[position]=marker<br/>handle_turn(testing_board,"x",5)<br/>display_board(testing_board)</span></pre><figure class="ky kz la lb fd ll er es paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="er es lz"><img src="../Images/40b4b500e2a9fcc458b173c4a9c26df2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*S-MJBNqPLhoeCb0h7mYwqA.gif"/></div></div></figure><h2 id="cb88" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第五步:为下一步行动腾出空间</h2><p id="33f9" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">下一步是检查空闲空间，即板上的空位置。在自由空间中，检查板上的任何特定位置是否是自由可用的。定义<code class="du ku kv kw kx b">space_free()</code>函数，其中板和位置将作为参数传递，如果该位置的板等于<em class="jt">空字符串</em>，则返回布尔值true。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="aaea" class="ju jv hh kx b fi lg lh l li lj">def space_free(board,position):<br/>    return board[position]==" "</span></pre><h2 id="e9d0" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第六步:全面检查</h2><p id="9bd7" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">进行全面的棋盘检查，以确定棋盘上的所有位置是否都有人。在<code class="du ku kv kw kx b">fullboadcheck()</code>功能中将板卡作为参数传递。将<em class="jt">用于循环</em>，循环用于范围1到10的<code class="du ku kv kw kx b">i</code>，其中<code class="du ku kv kw kx b">i</code>是板上所有可能的位置。使用<em class="jt"> if </em>函数声明，如果<code class="du ku kv kw kx b">i</code>在棋盘上的任意给定位置为空，则棋盘未满，返回false。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="b310" class="ju jv hh kx b fi lg lh l li lj">def fullboardcheck(board):<br/>    for i in range(1,10):<br/>        if space_free(board, i):<br/>            return False<br/>    return True</span></pre><h2 id="b33f" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第七步:下一步</h2><p id="1dfc" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">接下来使用<code class="du ku kv kw kx b">player_choice()</code>函数，该函数将接受玩家的输入，即如果是自由位置，则在棋盘上的下一个移动位置放置标记。如果玩家给出的位置号已经被占用，例如，如果玩家1选择了位置5，并且在下一轮中玩家2也试图在相同的位置放置标记，那么玩家2将被要求选择未被占用的不同位置。这可以通过使用一个<em class="jt"> while循环</em>来完成，该循环将检查玩家是否输入了错误的数字或不在1到9范围内的位置数字中的任何字母。它还检查该位置空间是否仍然可用。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="ce53" class="ju jv hh kx b fi lg lh l li lj">def player_choice(board):<br/>    position = 0<br/>    <br/>    while position not in range(1,10)or not space_free(board, position):<br/>        position = int(input('Choose your next position: (1-9) '))<br/>    return position</span></pre><h2 id="6b96" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">7 .赢家</h2><p id="ca8f" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">下一次检查获胜。使<code class="du ku kv kw kx b">check_win()</code>函数将板和标记作为参数传递，该函数将检查板的行方向、列方向和对角线方向是否赢。赢是指玩家棋盘上的三个标记垂直、水平或对角对齐。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="659c" class="ju jv hh kx b fi lg lh l li lj">def check_win(board, mark):<br/>    return ((board[7]==mark and board[8]==mark and board[9]==mark)or<br/>    (board[4]==mark and board[5]==mark and board[6]==mark)or<br/>    (board[1]==mark and board[2]==mark and board[3]==mark)or<br/>    (board[7]==mark and board[4]==mark and board[1]==mark)or<br/>    (board[8]==mark and board[5]==mark and board[2]==mark)or<br/>    (board[9]==mark and board[6]==mark and board[3]==mark)or<br/>    (board[7]==mark and board[5]==mark and board[3]==mark)or<br/>    (board[9]==mark and board[5]==mark and board[1]==mark))</span></pre><h2 id="4083" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第八步:重播</h2><p id="d8f1" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">为此，创建一个函数让游戏重启。定义<code class="du ku kv kw kx b">replay()</code>函数，该函数将接受玩家的输入来决定是否再次播放。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="fbb0" class="ju jv hh kx b fi lg lh l li lj">def replay():<br/>    return input('Do you want to play again? Enter Yes or No: ')</span></pre><h2 id="5cf5" class="ju jv hh bd jw jx jy jz ka kb kc kd ke jg kf kg kh jk ki kj kk jo kl km kn ko bi translated">第九步:将所有内容结合在一起</h2><p id="73d9" class="pw-post-body-paragraph ix iy hh iz b ja kp ij jc jd kq im jf jg kr ji jj jk ks jm jn jo kt jq jr js ha bi translated">将上述所有功能整合在一起，创建游戏。从<code class="du ku kv kw kx b">while</code>循环开始，它创建了一个无限循环，只要给定的布尔条件为真，代码就会继续执行。设置棋盘，指定<code class="du ku kv kw kx b">player1_marker</code>和<code class="du ku kv kw kx b">player2_marker</code>为<code class="du ku kv kw kx b">player_input()</code>，玩家决定他们的标记，指定<code class="du ku kv kw kx b">first_move()</code>为<code class="du ku kv kw kx b">turn</code>，决定哪个玩家先走。开始游戏，接受玩家的输入。如果准备好了，输入是或否。如果玩家输入是，那么游戏开始。玩家被问及他们想标记哪个位置等等。一旦游戏结束，他们可以选择是否要重玩。</p><pre class="ky kz la lb fd lc kx ld le aw lf bi"><span id="5c1f" class="ju jv hh kx b fi lg lh l li lj">while True:<br/>    theBoard = [' '] * 10<br/>    player1_marker, player2_marker = player_input()<br/>    turn = first_move()<br/>    print (turn + " and will go first")<br/>    <br/>   #game play <br/>    play_game = input('Are you ready to play? Enter Yes or No.')</span><span id="32d7" class="ju jv hh kx b fi ls lh l li lj">if play_game == ("Yes"):<br/>        game_is_on = True<br/>    else:<br/>        game_is_on = False</span><span id="34b0" class="ju jv hh kx b fi ls lh l li lj">while game_is_on: <br/>        if turn=="player 1":<br/>            display_board(theBoard)<br/>            print ("player 1")<br/>            position=player_choice(theBoard)<br/>            handle_turn(theBoard,player1_marker,position)<br/>            <br/>            if check_win(theBoard,player1_marker):<br/>                display_board(theBoard)<br/>                print('Congratulations! player 1 has won the game!')<br/>                game_is_on=False<br/>            else:<br/>                if fullboardcheck(theBoard):<br/>                    display_board(theBoard)<br/>                    print('The game is a draw!')<br/>                    break<br/>                else:<br/>                    turn = 'player 2'</span><span id="5f49" class="ju jv hh kx b fi ls lh l li lj">else:<br/>            display_board(theBoard)<br/>            print ("player 2")<br/>            position = player_choice(theBoard)<br/>            handle_turn(theBoard, player2_marker, position)</span><span id="7317" class="ju jv hh kx b fi ls lh l li lj">if check_win(theBoard, player2_marker):<br/>                display_board(theBoard)<br/>                print('Player 2 has won the game!')<br/>                game_is_on=False</span><span id="939f" class="ju jv hh kx b fi ls lh l li lj">else:<br/>                if fullboardcheck(theBoard):<br/>                    display_board(theBoard)<br/>                    print('The game is a draw!')<br/>                    break<br/>                else:<br/>                    turn = 'player 1'<br/>                    <br/>    if not replay():<br/>        break</span></pre><p id="c170" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">这就是一个人如何玩自己的游戏</p><figure class="ky kz la lb fd ll er es paragraph-image"><div class="er es ma"><img src="../Images/74610071be8151b664c45651759428db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1316/1*JkKZ2f0ZwQ7TWK_5_hql0g.gif"/></div></figure><p id="12fe" class="pw-post-body-paragraph ix iy hh iz b ja jb ij jc jd je im jf jg jh ji jj jk jl jm jn jo jp jq jr js ha bi translated">如需进一步了解代码，请点击<a class="ae mb" href="https://github.com/yashnab/Tic-Tac-Toe" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></div></div>    
</body>
</html>