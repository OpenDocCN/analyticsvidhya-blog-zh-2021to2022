<html>
<head>
<title>OSEMN is AWESOME</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OSEMN很牛逼</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/osemn-is-awesome-3c9e42c3067d?source=collection_archive---------13-----------------------#2021-01-08">https://medium.com/analytics-vidhya/osemn-is-awesome-3c9e42c3067d?source=collection_archive---------13-----------------------#2021-01-08</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="790f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于数据科学家来说，为了完成他们的工作，有许多受欢迎的流程要经历，目前该领域中最受欢迎的流程之一是一个名为OSEMN(与awesome押韵)的策略。今天我们将讨论OSEMN的五个步骤，以及为什么它对数据科学家来说是如此有用的工具。在这篇博文中，我们将重点讨论线性回归作为我们的模型类型。</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="ji jj di jk bf jl"><div class="er es jc"><img src="../Images/b2fd930d82e5b5f44e08c7b72729db08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ilde8UAPtypM9htj.jpeg"/></div></div><figcaption class="jo jp et er es jq jr bd b be z dx translated">(由Chanin Nantasenamat绘制)</figcaption></figure><h1 id="65b2" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><strong class="ak"> O —获取数据</strong></h1><p id="9adc" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">可以通过多种方式获得数据。根据你为哪家公司工作，他们可能会为你提供数据，如果不是，你很可能需要网络搜集，使用API，或者熟悉SQL。一旦获得了数据，看一看您已经获得了什么并熟悉您的数据集是很重要的。一些有用的策略如下:</p><p id="6dec" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.head()</code> -提供数据帧的前五行。</p><p id="a79f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.info()</code> -显示列中是否有任何缺失条目，识别数据类型，并提供列数。</p><p id="8179" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.describe()</code> -给出每列的计数、平均值、标准差、最小值、25%、50%、75%和最大值。</p><h1 id="befd" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">S —擦除数据</h1><p id="b58a" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">清理数据是数据科学家职业生涯中最耗时的工作之一。然而，将数据转换成更易于使用的格式是至关重要的。在大多数获得的数据中，会有一些缺失或错误。要注意的常见项目是空值、异常数字、符号或必须转换的数据类型。识别空值时，决定如何处理它们是很重要的。下面列出了常用于处理空值的代码:</p><p id="2b0b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.isna().sum()</code> -允许您查看数据框中每列的空值数量。</p><p id="d4ed" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.unique()</code> -允许您查看每列的独特项目。</p><p id="eda3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.nunique()</code> -计算你的独特物品的总数。</p><p id="53b5" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">是用其他东西填充或替换你的空值的好工具。</p><p id="9bad" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.drop()</code> -如果您想删除一整行或一整列的过多空值。</p><p id="39d0" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">要切换数据类型:</p><p id="e6fe" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">df.col = df.col.astype('new_data_type')</code></p><p id="a653" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">清理数据时要寻找的其他项目是分类变量(有时这在探索步骤中完成)。</p><p id="de21" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">cat_cols = df.select_dtypes('object').columns</code> -识别作为对象列出的任何类别。您必须熟悉您的数据集，以查看是否有任何类别被列为数字列；常见的例子有邮政编码、年龄组和教育水平。</p><p id="9983" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><strong class="ig hi">线性回归模型</strong>的额外清理</p><p id="df08" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">检查多重共线性:</em></p><ol class=""><li id="7230" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kv kw kx ky b">data = df.iloc[:, 1:20]</code> -选择要检查多重共线性的列，然后删除任何相关值。</li><li id="fad9" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">data.corr()</code></li><li id="ceb0" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">abs(data.corr()0 &gt; .75</code>——看一看相关性超过. 75</li></ol><p id="f3be" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">接下来的步骤使用vif策略来处理多重共线性。这种方法在数据科学家领域越来越常用。</em></p><ol class=""><li id="dae1" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kv kw kx ky b">from statsmodels.stats.outliers_influence import variance_inflation_factor</code></li><li id="1ea8" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">X = data.drop('dependent_col', axis=1)</code> <code class="du kv kw kx ky b">X = sm.add_constant(X)</code> <code class="du kv kw kx ky b">X.shape</code></li><li id="6bc1" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">vif = [variance_inflaction_factor{X.values, i) for i in range(X.shape[1])]</code></li><li id="03d4" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">vif_results = pd.Series(dict(zip(X.columns, vif)))</code>T9】</li><li id="b85d" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">接下来，我们将寻找阈值超过6的任何vif。数字6是多重共线性的分界点。</li><li id="5ed1" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">threshold = 6</code><code class="du kv kw kx ky b">bad_vif = list(vif_results[vif_results&gt;threshold].index)</code>` if ' const ' in bad _ Vif:<code class="du kv kw kx ky b"> </code>bad _ Vif . remove(' const ')<code class="du kv kw kx ky b"> </code>bad Vif `中</li><li id="67ad" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">然后从您的数据框中删除坏的vif列。</li></ol><p id="952f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">根据偏好，运行多个模型以查看整个工作流程中的R2和多重共线性变化是非常常见的。在处理数据时，可能需要多次检查多重共线性。接下来，我们将介绍如何规范化您的数据。两种流行的方法是使用z值或数据的IQR。我将在下面模拟IQR方法:</p><ol class=""><li id="1cfe" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kv kw kx ky b">Q1 = data['dependent_col'].quantile(0.25)</code> <code class="du kv kw kx ky b">Q3 = data['dependent_col'].quantile(0.75)</code> <code class="du kv kw kx ky b">IQR = Q3-Q1</code> <code class="du kv kw kx ky b">print(IQR)</code></li><li id="2659" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">test = df_ohe[~((df_ohe['price'] &lt; (Q1 - 1.5 * IQR)) |(df_ohe['price'] &gt; (Q3 + 1.5 * IQR)))]</code><code class="du kv kw kx ky b">print(df_out.shape)</code>——保存一个新的数据帧，除了你的离群值。~符号的意思是的反义词，所以通过加上这个，我们保存了除离群值之外的所有内容。</li></ol><h1 id="2e38" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">探索</h1><p id="93ed" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">Explore是数据科学家执行EDA(探索性数据分析)的地方，这是数据科学家在建模之前进行可视化以更好地理解数据的另一种方式。探索步骤中包含的可视化通常是散点图、核密度估计、散点图和QQ图(在创建QQ图之前必须创建OLS回归)。数据科学家应该在探索步骤中检查线性。在OSEMN流程中，经常会出现擦洗和探索重叠。就是在这一步，numpy，seaborn，pandas，scipy派上了用场。</p><p id="04cc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">距离图:<code class="du kv kw kx ky b">sns.distplot(data)</code></p><p id="19f7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">散点图:<code class="du kv kw kx ky b">sns.scatterplot(data)</code></p><p id="8829" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">联合图(结合散点图和散点图):<code class="du kv kw kx ky b">sns.jointplot(data=df, x='col', y='dependent_col', kind='reg')</code></p><p id="6e56" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">QQ图:<code class="du kv kw kx ky b">sm.graphics.qqplot(model.resid, fit=True, line='45')</code></p><p id="01e7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">内核密度估计:<code class="du kv kw kx ky b">sns.kdeplot(data)</code></p><p id="7d54" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="kz">查看我的另一篇博文“数据可视化:何时和如何”,了解OSEMN探索部分的更多细节。</em></p><h1 id="3dcc" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">模型</h1><p id="92c9" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">根据您试图解决的任务，有许多不同的建模方式。在这篇博文中，我将使用推理或预测来模拟线性回归。推论是在问“X如何影响Y？”而预测会问“我如何用X来预测Y？”在你的工作流程中可能会有许多模型被完成，但是这是你最终模型应该被放置的地方。下面我将向你展示如何创建一个OLS模型。</p><p id="54cd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><code class="du kv kw kx ky b">import statsmodels.formula.api as smf</code></p><ol class=""><li id="18bd" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kv kw kx ky b">target = dependent_col</code></li><li id="1801" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">features = '+'.join(data.drop(columns = 'dependent_col').columns)</code></li><li id="f75b" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">formula = target + '~' + features</code>T9】</li></ol><p id="8f52" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">运行最终模型后，您将需要使用sklearn的train_test_split执行回归模型验证。</p><pre class="jd je jf jg fd lo ky lp lq aw lr bi"><span id="255e" class="ls jt hh ky b fi lt lu l lv lw">import sklearn.model_selection <br/>import train_test_split<br/>from sklearn.metrics import r2_score</span></pre><ol class=""><li id="343c" class="la lb hh ig b ih ii il im ip lc it ld ix le jb lf lg lh li bi translated"><code class="du kv kw kx ky b">df_train, df_test = train_test_split(data)</code></li><li id="5b28" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">df_train.shape, df_test.shape</code> -检查形状</li><li id="01e8" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated">使用列车数据运行OLS模型</li><li id="9b38" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">y_train_pred = model.predict(df_train)</code> -对y_test_pred进行同样的操作</li><li id="8e11" class="la lb hh ig b ih lj il lk ip ll it lm ix ln jb lf lg lh li bi translated"><code class="du kv kw kx ky b">r2_train = r2_score(df_train['dependent_col'], y_train_pred)</code> -对r2_test进行同样的操作</li></ol><p id="e329" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">目标是让你的训练成绩和测试成绩非常接近！</p><h1 id="c3f7" class="js jt hh bd ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated">N =解释</h1><p id="bdca" class="pw-post-body-paragraph ie if hh ig b ih kq ij ik il kr in io ip ks ir is it kt iv iw ix ku iz ja jb ha bi translated">在这里，您将解释您的最终模型，并根据数据集确定3个以上可行的见解作为建议。确保这些数据以一种非技术型受众能够理解的方式呈现，并记住要经常说谢谢。</p></div></div>    
</body>
</html>