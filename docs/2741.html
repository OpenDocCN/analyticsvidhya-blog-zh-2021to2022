<html>
<head>
<title>Multi-tasking your way in Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Python中的多任务处理方式</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/multi-tasking-your-way-in-python-795ced176d9d?source=collection_archive---------7-----------------------#2021-05-15">https://medium.com/analytics-vidhya/multi-tasking-your-way-in-python-795ced176d9d?source=collection_archive---------7-----------------------#2021-05-15</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><figure class="hg hh ez fb hi hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es hf"><img src="../Images/4e349dd2edf7754581ad4083b2497fe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T7HyW8Bwbv6fBhaY"/></div></div><figcaption class="hq hr et er es hs ht bd b be z dx translated">由<a class="ae hu" href="https://unsplash.com/@marcsm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">马克·森德拉·马托雷尔</a>在<a class="ae hu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><div class=""/><p id="968c" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi js translated">ython以其易用性和几乎不存在的学习曲线而闻名，但今天我将分享python多处理库的一个实现，作为一个客户端服务器架构。在开始编写代码之前，让我们先了解一些基础知识。</p><p id="f600" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">什么是GIL，它是如何工作的？</strong></p><p id="f11f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">简单地说，就像任何公共淋浴一样，当你使用它时，它是你的，在你用完之后，其他人使用它。在Cpython中，为了使其实现更简单，python解释器的锁被提供给每个线程来执行，一旦线程的执行完成，一个新的线程就锁定python解释器。Python的设计考虑了单线程执行，这增加了它的简单性。</p><p id="3e96" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">关于GIL更详细的解释可以在<a class="ae hu" href="https://realpython.com/python-gil/" rel="noopener ugc nofollow" target="_blank">这里</a>找到</p><h1 id="b9bb" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">当我使用多核系统时，如何获得最佳性价比？</strong></h1><p id="9678" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">最流行的方法是使用多处理方法，即使用多个进程代替线程。由于每个进程都有自己的Python解释器和内存空间，因此GIL不会成为问题。</p><p id="ea77" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>包提供了本地和远程并发，通过使用子进程而不是线程，有效地避开了<a class="ae hu" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">全局解释器锁</a> (GIL)。因此，<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>模块允许程序员充分利用给定机器上的多个处理器。它可以在Unix和Windows上运行。</p><h1 id="440d" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">客户机-服务器体系结构</h1><p id="c0fb" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">为此，我们将创建一个管理器类和一个工作器类，工作器将由管理器根据系统中可用的内核数量进行初始化。</p><p id="cc19" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">因此，员工可以以并行方式承担您需要他们完成的任务。让我们来研究一下代码。</p><figure class="li lj lk ll fd hj"><div class="bz dy l di"><div class="lm ln l"/></div></figure><p id="837f" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">不知所措？，如果是的话，对我来说也是如此，但是让我们把代码分解成更小的部分以便于理解</p><p id="7698" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">队列</strong>—<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue" rel="noopener ugc nofollow" target="_blank">Queue</a> </code>是模仿Python 2.5+中引入的标准库中的<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/queue.html#queue.Queue" rel="noopener ugc nofollow" target="_blank">queue.Queue</a></code>类的多生产者、多消费者FIFO队列。</p><p id="48f0" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">Queue.put和Queue.get_no_wait顾名思义，将对象放入队列并从队列中移除和获取对象，get_no_wait方法在生成异常queue之前不会等待任何时间。队列为空时引发空返回异常</p><blockquote class="lo lp lq"><p id="b9a9" class="iu iv lr iw b ix iy iz ja jb jc jd je ls jg jh ji lt jk jl jm lu jo jp jq jr ha bi translated"><code class="du le lf lg lh b">Note — <a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>使用通常的<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/queue.html#queue.Empty" rel="noopener ugc nofollow" target="_blank">queue.Empty</a></code>和<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/queue.html#queue.Full" rel="noopener ugc nofollow" target="_blank">queue.Full</a></code>异常来发出超时信号。它们在<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing" rel="noopener ugc nofollow" target="_blank">multiprocessing</a></code>名称空间中不可用，因此您需要从<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/queue.html#module-queue" rel="noopener ugc nofollow" target="_blank">queue</a></code>中导入它们。</p></blockquote><p id="ae04" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated"><strong class="iw hy">事件</strong> —所以我们正在操作多个线程，我们需要一种机制来通信或发送信号，比如暂停或终止线程的执行，事件类的救援，这有助于我们进行线程间通信。</p><p id="6dba" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">事件对象使用一个内部标志，称为事件标志，使用set()方法将其设置为True，并可以使用clear()方法将其重置为false。</p><ul class=""><li id="cc5b" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hy"> isSet() — </strong>当且仅当内部标志为true时，此方法返回true</li><li id="5ca2" class="lv lw hx iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><strong class="iw hy"> set() — </strong>当对任何事件对象调用该方法时，内部标志被设置为真。并且一旦为任何事件调用set()方法，所有等待它的线程都会被唤醒。</li></ul><h1 id="dccc" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">经理类</strong></h1><p id="a88a" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">好吧，这位经理既刻薄又无情，但他能让员工完成工作。他的任务是计划和分配工人需要完成的任务。</p><p id="3b5d" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">初始化时，管理器类初始化队列、事件和工作者类。工人数量取决于系统的处理能力。我将1个核心分配给经理，其余分配给工人。因此，请确保将计算强度较低的进程分配给管理器类。我班有两种方法。</p><ul class=""><li id="4176" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hy"> add_jobs() </strong> —现在manager的主要任务是给工人分配他们各自的任务，这是使用该类的add_jobs()方法来完成的，当这个方法被调用时，它开始将作业添加到队列中，为了简单起见，我将10个整数添加到我的队列中。</li></ul><pre class="li lj lk ll fd mj lh mk ml aw mm bi"><span id="2a9e" class="mn kc hx lh b fi mo mp l mq mr">####################################################################                               #                  Task addition on queue starts                                ####################################################################                                                       for i in range(10):<br/>    self.task_queue.put(i) # Assigns the job in queue<br/>    time.sleep(0.1) ####################################################################                               #                 Task addition on queue ends                                ####################################################################</span></pre><ul class=""><li id="b6a6" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><strong class="iw hy"> terminate() </strong> —该方法调用stop_event对象的set方法，使其事件标志为True，从而通知可怜的工人不会有任何额外的任务，一旦现有任务完成，他们就可以回家了。这是在add_jobs()方法完成执行后调用的</li></ul><pre class="li lj lk ll fd mj lh mk ml aw mm bi"><span id="1141" class="mn kc hx lh b fi mo mp l mq mr">def terminate(self):<br/>    '''Sets terminate event when called'''<br/>    self.stop_event.set()</span></pre><h1 id="8df6" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">工人阶级</h1><p id="d40d" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">这里的工人天真、听话、勤劳。他们毫无怨言地完成了严格的经理分配给他们的所有任务，因此除了一个核心外，所有可用的核心都被分配到这个类别。因此，为员工规划计算密集型任务</p><p id="9c09" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">该类继承自<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank">Process</a></code>类并覆盖run方法，查看大量官方文档深入了解<code class="du le lf lg lh b"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank">Process</a></code>类。</p><p id="e8fa" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">您希望您的工人执行的任务放在<strong class="iw hy"> run </strong>方法中。在我的实现中，代码从while循环开始，一直运行到两个条件都满足，即</p><ul class=""><li id="9a3b" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">队列仍有项目</li><li id="af00" class="lv lw hx iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">未设置停止事件</li></ul><pre class="li lj lk ll fd mj lh mk ml aw mm bi"><span id="8119" class="mn kc hx lh b fi mo mp l mq mr">while not self.task_queue.empty() or not self.stop_event.is_set():</span><span id="f574" class="mn kc hx lh b fi ms mp l mq mr">    try:<br/>        job = self.task_queue.get_nowait()                                                                             ####################################################################                                       #                  Processing tasks starts                                        ####################################################################</span><span id="dbe4" class="mn kc hx lh b fi ms mp l mq mr">        # Random operation below <br/><br/>        random_operation = sum([(job)^i for i in range(500000)]) <br/>        time.sleep(2)                                       <br/>                                      ####################################################################                                       #                  Processing tasks ends                                        ####################################################################</span><span id="63b9" class="mn kc hx lh b fi ms mp l mq mr">    except q.Empty: pass</span></pre><ul class=""><li id="e505" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated">当且仅当队列为空并且设置了停止事件时，代码才会退出循环。因此，如果经理没有及时分配一些项目，工人会被指示耐心等待，只有当管道为空且经理通过设置stop_event指示他们回家时才打包。无情的经理对吗？生活是艰难的。</li><li id="3064" class="lv lw hx iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">self.task_queue.get_nowait()根据FIFO(先进先出)获取队列中的下一个可用项，在获取项后可以开始处理作业。它抛出<strong class="iw hy">队列。空的</strong>异常如果没有条目，我们已经处理了异常。</li></ul><h1 id="de87" class="kb kc hx bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated"><strong class="ak">结果</strong></h1><p id="cfc1" class="pw-post-body-paragraph iu iv hx iw b ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn ld jp jq jr ha bi translated">现在是最后的结论，它的性能如何，性能是主观的，我使用的是Macbook pro- Intel Core i7处理器，它有12个内核，我使用其中的11个用于工作，因为执行是并行的，每个线程都使用自己的python解释器，所以不存在资源竞争，一个线程不会等待其他线程完成执行才开始，下面是我的终端上的截图，显示了同样的情况。</p><figure class="li lj lk ll fd hj er es paragraph-image"><div role="button" tabindex="0" class="hk hl di hm bf hn"><div class="er es mt"><img src="../Images/b12b70e4aaa77944eb6a652f931a7f73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0rRtbtL33YbuYZqBDVCxg.png"/></div></div></figure><p id="173e" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">我们已经执行了10个进程，每个进程大约需要2秒钟，使用普通解决方案需要20多秒钟，但是同时执行10个不同的进程，其中一个内核没有使用，整个过程只需要大约3秒钟。</p><p id="82ed" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">当您在通常为多核的虚拟机上部署生产代码时，您可以获得巨大的性能提升。</p><p id="5558" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">请在下面的评论中告诉我你的想法和建议。</p><p id="b836" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">注意安全，你比你想象的要坚强。</p></div><div class="ab cl mu mv go mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ha hb hc hd he"><p id="e3ee" class="pw-post-body-paragraph iu iv hx iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr ha bi translated">参考文献—</p><ul class=""><li id="2d78" class="lv lw hx iw b ix iy jb jc jf lx jj ly jn lz jr ma mb mc md bi translated"><a class="ae hu" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Process" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/library/multi processing . html #多重处理。流程</a></li><li id="d792" class="lv lw hx iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated"><a class="ae hu" href="https://docs.python.org/3/glossary.html#term-global-interpreter-lock" rel="noopener ugc nofollow" target="_blank">https://docs . python . org/3/glossary . html # term-global-interpreter-lock</a></li><li id="4b11" class="lv lw hx iw b ix me jb mf jf mg jj mh jn mi jr ma mb mc md bi translated">【https://realpython.com/python-gil/ T4】</li></ul></div></div>    
</body>
</html>