<html>
<head>
<title>Classifying Images of Clothing Using TensorFlow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于张量流的服装图像分类</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/classifying-images-of-clothing-using-tensorflow-39ec3c1cb8b7?source=collection_archive---------7-----------------------#2021-04-12">https://medium.com/analytics-vidhya/classifying-images-of-clothing-using-tensorflow-39ec3c1cb8b7?source=collection_archive---------7-----------------------#2021-04-12</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="b5b4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如何在TensorFlow中使用卷积神经网络训练深度学习模型对服装图像进行分类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es jd"><img src="../Images/6d69f990be0234a75d9805f76ef8672e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNLB2jtcfb_xTqgQd9ntJA.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">Zalando的时尚MNIST样品</figcaption></figure><p id="1414" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">深度学习是机器学习的一个子领域，它使用多层神经网络从数据中提取模式。我在这个项目中的目标是介绍如何将深度学习概念应用于图像分类问题。为此，我们将使用Python中的TensorFlow库训练一个卷积神经网络(CNN)来对服装数据集进行分类。</p><p id="a97b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在过去的几年里，卷积神经网络已经在一些复杂的视觉任务上实现了超人的性能。它们为图像搜索服务、无人驾驶汽车、自动视频分类系统等提供动力<em class="ju">。</em></p><p id="da5f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你对这个项目的源代码感兴趣，请查看我的<a class="ae jt" href="https://github.com/hugoplm/computer-vision/blob/main/Classifying_Images_of_Clothing/Classifying_Clothing_TensorFlow.ipynb" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="e5c5" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">探索数据集</strong></h1><p id="ce26" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">我们将使用<a class="ae jt" href="https://github.com/zalandoresearch/fashion-mnist" rel="noopener ugc nofollow" target="_blank">时尚MNIST </a>数据集，该数据集包含10个类别的70，000张灰度图像。这些图像以28 x 28像素的分辨率表示个人服装。</p><p id="7637" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个图像在范围[0，9]中有一个单独的类。我们可以在下表中看到数据集中的类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lf"><img src="../Images/41d127f374f472105fd09b34c1e492c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/format:webp/1*ZlLjA7xXYR4cXC120kmggQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按作者分类的时尚MNIST数据集。</figcaption></figure><p id="4fbc" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像只是一个数字矩阵，在我们的问题中是一个28×28的矩阵。每个值都在范围[0，255]内，该范围定义了每个像素的颜色和强度。</p><p id="2ddf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这里，我们可以看到训练数据集的第一个样本中的前5行。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lg"><img src="../Images/1968b5da7055a41b49f9d78bc3c06204.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PORKlgyDvpv7w0OhWD5tdQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者提供的部分图像数组示例。</figcaption></figure><p id="d8c9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们画出这张图片。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es lh"><img src="../Images/4c577adfce70980cff27fc41caa713df.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*Ou7EYajxy_h6u7ef2sY_Lg.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者提供的踝靴类图片示例。</figcaption></figure><p id="04d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以从我们的训练数据集中显示一些带有相应类的例子。绘制前24个样本，可以看到每个类别至少有一个示例</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es li"><img src="../Images/6c89ae25a215da832e150619e8f69c7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YNuL4xo2zwbQxMc_kCK7bQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按作者分类的图片示例。</figcaption></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="9c72" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">预处理数据</h1><p id="12d1" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">正常化</strong></p><p id="aed9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图像中每个像素的值是一个范围在[0，255]内的整数，需要对其进行归一化，模型才能正常工作。我们可以创建一个函数，将每个值除以255.0。当将该函数应用于我们的数据集时，我们将获得范围[0，1]内的归一化值。</p><p id="d1df" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重塑图像</strong></p><p id="d903" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">卷积神经网络期望4个维度作为输入:样本数(60，000)、像素(28 x 28)和颜色通道。因为我们处理的是灰度图像，所以只有一个通道。然而，正如我们之前看到的，我们的X_train数据集的形状是(6000，28，28)，我们需要(6000，28，28，1)作为输入。因此，我们需要重塑我们的数据集。</p><p id="f5f9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">一键编码</strong></p><p id="b38b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们的类数据有范围为[0，9]的标签，称为<em class="ju">整数编码</em>。但是，标签和相应的类之间没有顺序关系。</p><p id="13b7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这种情况下，使用整数编码允许模型假设类别之间的自然排序，这可能导致性能不佳或深度学习模型的意外结果。为了解决这个问题，我们可以使用一位热编码，它为每个唯一整数值创建一个新的二进制变量。</p><p id="23f2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们检查一下我们的标签数据。每个标签从单个值变为在相应位置具有值“1”的向量。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lj"><img src="../Images/8ebd07c25a0352185be8fdefccf4b6f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KgXsEZuySgzQVKZd6elFMQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者应用一键编码前后的类标签数组。</figcaption></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="a9e5" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">创建模型</h1><p id="b039" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">建造各层</strong></p><p id="7de3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">创建模型的第一步是定义网络的层次。CNN至少有一个卷积层，还包括其他类型的层，如池层和全连接层(密集)。对于这个项目，我们将使用典型的CNN架构，如下图所示。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lk"><img src="../Images/0c8b6424d87ea0d8326d6cc793928429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCzB-uZyxgiyCcflu6ioBg.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated"><em class="ll">典型CNN架构，作者</em> Géron，Aurélien (2019)。</figcaption></figure><p id="9fbb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如图所示，我们将包括一个卷积层和一个池层，然后是另一个卷积层和池层。然后，我们将添加一个扁平化层来转换我们的二维阵列图像为一维阵列，并添加一些密集层。我们可以添加一些下降层来减少过度拟合。对于最后一层，我们添加了一个密集层，其中包含问题中的类的数量(10)和一个softmax激活，它为每个类创建了概率分布。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="4cd3" class="lr kd hi ln b fi ls lt l lu lv">model = keras.models.Sequential([</span><span id="5fca" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Conv2D(filters=64, kernel_size=3, activation='relu',</span><span id="cf87" class="lr kd hi ln b fi lw lt l lu lv">                      padding='same', input_shape=[28, 28, 1]),</span><span id="fc8d" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.MaxPool2D(pool_size=2),</span><span id="a856" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Conv2D(filters=128, kernel_size=3, activation='relu',</span><span id="4ea5" class="lr kd hi ln b fi lw lt l lu lv">                      padding='same'),</span><span id="4c31" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.MaxPool2D(pool_size=2),</span><span id="7cfa" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Flatten(),</span><span id="478d" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Dense(units=128, activation='relu'),</span><span id="2312" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Dropout(0.25),</span><span id="615a" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Dense(units=64, activation='relu'),</span><span id="50a0" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Dropout(0.25),</span><span id="2bff" class="lr kd hi ln b fi lw lt l lu lv">  keras.layers.Dense(units=10, activation='softmax'),</span><span id="5a68" class="lr kd hi ln b fi lw lt l lu lv">])</span></pre><p id="ee33" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">编译模型</strong></p><p id="1b9e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">下一步是编译模型。这里我们传递优化器，它调整权重以最小化损失，损失函数，它测量真实值和预测值之间的差异，以及度量，一个用于测量模型性能的函数。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="7bdb" class="lr kd hi ln b fi ls lt l lu lv">model.compile(optimizer='adam', loss='categorical_crossentropy',         metrics=['accuracy'])</span></pre><p id="d771" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">训练模型</strong></p><p id="0b96" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后一步是训练我们的模型。这里，我们需要传递输入数据、目标数据和历元数，这定义了训练数据集的完整迭代次数。我们还将传递一个参数来将我们的数据分为训练(70%)和验证(30%)两部分，传递一个参数来定义batch_size，即每次传递的训练样本数。</p><p id="fd88" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将把我们的训练结果保存在变量<em class="ju"> model_history </em>中。</p><pre class="je jf jg jh fd lm ln lo lp aw lq bi"><span id="6222" class="lr kd hi ln b fi ls lt l lu lv">model_history = model.fit(X_train, y_train, batch_size=50, epochs=10, validation_split=0.3)</span></pre><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lx"><img src="../Images/92ceed737f4143d51aa2e345cc4fea45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y_S2NiKjb9priFadwLkang.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者的训练时代的历史。</figcaption></figure><p id="7ff1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">评估损失</strong></p><p id="8257" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">fit方法返回一个历史对象，其中包含每个时期的结果。我们可以绘制一个图表，显示训练和验证数据集的损失和准确性。从该图中，可以看出损耗如何随着时间的推移而下降，精度如何随着时间的推移而上升。该图表还用于识别过度拟合和拟合不足的证据。对于我们的模型，似乎我们没有这些问题的有力证据。因此，让我们继续，用我们的测试数据集做一些预测。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es ly"><img src="../Images/daa9fca05165debcd98eb65afd5a73e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:872/format:webp/1*GuLDpA_0TaQONQakIz10ow.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按作者划分的训练和验证数据集的准确性和损失图。</figcaption></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="4965" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">进行预测并评估结果</h1><p id="5df1" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated"><strong class="ih hj">评估测试数据集中的准确性</strong></p><p id="61ed" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们看看模型在测试数据集上的表现。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es lz"><img src="../Images/88d3570f0daa949ab0295dfc269b6375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D26mNSyCK-SynoWXSHm29A.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者测试数据集的模型准确性和损失。</figcaption></figure><p id="124b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">训练数据集的精度小于测试和验证数据集的精度。然而，这仍然是一个91.55%准确率的好结果。</p><p id="0d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">做预测</strong></p><p id="e957" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们可以使用我们的模型为测试数据库中的每个例子预测一个类。</p><p id="92d4" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们从测试数据集中绘制一些带有真实和预测标签的图像。当模型预测正确时，文本将显示为蓝色，如果预测错误，将显示为红色。此外，还会显示预测类别的计算概率。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es ma"><img src="../Images/66910ff66e5850decf2510eee5e360cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kh-46HB7JsGgP80Jp-S1FQ.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">作者的真实类别和预测类别的图像示例。</figcaption></figure><p id="a2d5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">从这20个例子可以看出，我们的模型对一件外套和一件衬衫做出了错误的预测。但是，使用此图分析10，000个示例的预测是不可行的。因此，让我们绘制一个交叉表来分析我们的模型对每个类的正确和错误的预测。</p><p id="e874" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">交叉表</strong></p><p id="ca78" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">通过分析我们的交叉表，我们可以注意到凉鞋分类的准确率最高(99.1%)，而衬衫分类的准确率最低(76.9%)。交叉表提供了一种很好的方式来可视化我们的模型为每个类预测的数量。例如，我们可以很容易地看到，它在74个例子中预测衬衫为t恤/上衣，或者它没有预测任何包为踝靴。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div role="button" tabindex="0" class="jj jk di jl bf jm"><div class="er es mb"><img src="../Images/c292bb3bd40c8dce2d4b6951d1c06954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8wMGKZHeTuNKJ_FpRJmFug.png"/></div></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按作者划分的模型预测交叉表。</figcaption></figure><p id="e59f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">分类报告</strong></p><p id="d8d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，让我们使用scikit-learn库中的分类报告，绘制每个类的精度、召回率和f1分数的摘要。这里可以看出，我们没有考虑到任何类的精确度和召回率之间的差异。正如我们在交叉表中注意到的，我们最差的结果是衬衫类。</p><figure class="je jf jg jh fd ji er es paragraph-image"><div class="er es mc"><img src="../Images/f821a05e7b2cf4695439208990f6c1e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1184/format:webp/1*ALfG2XoXtbjqYyxRScIRqQ.png"/></div><figcaption class="jp jq et er es jr js bd b be z dx translated">按作者分类的模型预测报告。</figcaption></figure></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="f8e5" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">结论</h1><p id="a93f" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">在这个项目中，介绍了如何使用TensorFlow和Keras训练一个卷积神经网络来对来自时尚MNIST数据集的服装图像进行分类。使用该模型，我们在测试数据集中获得了91.55%的总体准确率，这是一个不错的结果。然而，具体到我们的<em class="ju">衬衫</em>类，我们得到的准确率只有76.90%。我们可以尝试使用一些数据增强技术来提高这个类的准确性。此外，如果您想获得更高精度的模型，您可以尝试更改一些超参数或使用不同的网络架构。</p><p id="6959" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您对这个项目有任何问题或反馈，请随时通过<a class="ae jt" href="https://www.linkedin.com/in/hugoplm/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>联系我。</p></div><div class="ab cl jv jw gp jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="hb hc hd he hf"><h1 id="acca" class="kc kd hi bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated">参考</h1><p id="ef11" class="pw-post-body-paragraph if ig hi ih b ii la ik il im lb io ip iq lc is it iu ld iw ix iy le ja jb jc hb bi translated">[1]: Géron，Aurélien (2019)。使用Scikit-Learn、Keras和TensorFlow进行机器学习(第二版。).塞瓦斯托波尔，加利福尼亚州:奥莱利媒体公司。</p><p id="3435" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">[2]:布朗利，杰森(2020，6月30日)。机器学习中为什么要一次性编码数据？。检索自<a class="ae jt" href="https://machinelearningmastery.com/why-one-hot-encode-data-in-machine-learning/" rel="noopener ugc nofollow" target="_blank">https://machine learning mastery . com/why-one-hot-encode-data-in-machine-learning/</a></p></div></div>    
</body>
</html>