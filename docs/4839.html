<html>
<head>
<title>Mini-Max</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">迷你-最大</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/mini-max-acc8d6b88cb1?source=collection_archive---------2-----------------------#2022-03-21">https://medium.com/analytics-vidhya/mini-max-acc8d6b88cb1?source=collection_archive---------2-----------------------#2022-03-21</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="6911" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当有人谈到人工智能时，人们只会想到一些像回归模型或分类技术这样的与机器学习最相关的方法。但是正如我在以前的文章中提到的，假设这些方法是人工智能的总簇是不明智的。有许多不同的方法、算法、模型需要或不需要训练数据集，甚至像人工智能学科中的余弦相似性这样的基本数学公式。机器学习课上一般不会提到的这些算法之一就是<em class="jd"> Mini-Max </em>算法。这种算法不仅用于人工智能，还用于其他领域，如博弈论、决策理论、统计学，甚至哲学。在这篇文章中，我从人工智能和博弈论的角度举例说明。</p><h1 id="758d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">定义</h1><p id="664b" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">如果你想了解什么是<em class="jd"> Mini-Max </em>算法，你可以在一个游戏板上定义它，两个对手在比赛，其中一个想最大化总得分，另一个试图最小化总得分。对于玩家P1来说，在棋盘上抓住对手的<em class="jd">主教</em>可以赢得100分。她的对手P2可能会失去-100分，如果他从他这边做出同样的举动。重要的一点是，P2满足于丢分，因为他想最小化总分，而P1试图最大化总分。在这种情况下，价值的积极或消极并不意味着价值的巨大，但它标志着玩家的一面。</p><h1 id="811d" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">得分</h1><p id="17f7" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">仅使用一种评分方法不是强制性的。您还可以添加其他得分层，不仅可以捕捉棋子，还可以捕捉棋子在棋盘上的位置，以及棋盘上每个方块的值。在国际象棋比赛中，有时玩家会牺牲自己的棋子以获得未来更好的收益。在这种情况下，如果你打算在下一回合拿下对手的<em class="jd">皇后</em>，失去一个<em class="jd">主教</em>可能不是最糟糕的情况。因此，在这种情况下，您可以使用棋盘上棋子位置的值矩阵来为模型提供这种智能。有一些网站解释了棋盘中每个方格的重要性值，它们共享一个基于每个棋子重要性分数的值矩阵，如图1所示。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kh"><img src="../Images/251999025f922efc01d7bcd67850f06d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbrAae0UQSFsGxUKbbP1fg.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图1:每个棋子的棋盘价值矩阵。此图片是从<a class="ae kx" href="https://www.freecodecamp.org/news/simple-chess-ai-step-by-step-1d55a9266977/" rel="noopener ugc nofollow" target="_blank">【s<em class="ky">source】</em></a><em class="ky">检索而来，仅用于教育目的。</em></figcaption></figure><p id="5f2d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">您可以使用图1中的精确矩阵或其他矩阵。你甚至不需要使用它。您可能更喜欢使用另一个评分层。例如，不使用位置矩阵，你可以直接使用棋子的值列表，比如一个<em class="jd">棋子</em>值1分，一个<em class="jd">皇后</em>值10分。但是这一次你的人工智能模型专注于捕捉棋子而忽略了位置。在这种情况下，你可以看到一个<em class="jd">国王</em>移动到棋盘的中央，只是为了抓住一个<em class="jd">棋子。但是在大多数时候，将你的<em class="jd">王</em>放在一个更安全的区域(而不是中心)是更明智的选择。正如你所看到的，人工智能模型可能会根据你在算法中的选择而表现不同。你改变模型的<em class="jd">智能</em>(或<em class="jd">特征</em>)。这就是人工智能的美妙之处。</em></p><p id="035b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你必须通过考虑主要目的来仔细指定算法的需求。在国际象棋的例子中，捕获对手的棋子是一个目的。但这不是主要目的。主要目的是用将死击败你的对手。捕捉一块是较低的焦点。因此，我认为在你的评分层中添加一个职位值矩阵，而不是直接使用一个计件值列表，是一个更好的解决问题的方法。</p><h1 id="9446" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">深度</h1><p id="8aa5" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">对于任何使用<em class="jd"> Mini-Max </em>算法的游戏，都有一个名为<em class="jd">‘depth’</em>的参数，这个参数大部分是由游戏的角色用户声明的。当轮到你出牌，到了人工智能模型出牌的时候，模型会为每个合法的走法模拟游戏。对于每次移动，它都会计算该移动对模型的输出值。它还会在对手可能的移动后为对手方不断模拟游戏。然后它假设两个招式(AI一个，对手一个)后，模拟第三个招式(这次是AI)。不断重复此过程，直到达到参数<em class="jd">深度</em>为止。然后从<em class="jd">最深</em>开始计算棋盘各状态的分数。如果模型是博弈的最大化方，它认为它需要为对手的移动取最小值(如果模型是最大化方，那么它的对手是最小化方)和最大值。你可以把它想象成模型的<em class="jd">假设</em>模拟。</p><p id="1627" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">增加模型的深度会导致复杂度以对数方式增加。因此，将深度增加到严肃的数字是一个艰难的决定。因为由于计算部分增长巨大，你需要确保你有一台计算机可以在几秒钟内处理这个过程，否则你可能要等上几个小时才能从模型中移出。此外，很高兴知道在一场国际象棋比赛中，3步后共有8，902个位置，而在围棋比赛中，这个数字会急剧增加。在一个典型的深度为150步的围棋游戏中，大约有250个⁵⁰，或者10个⁶⁰可能的走法。详细信息可以查看<a class="ae kx" href="https://www.chess.com/forum/view/general/i-need-a-math-genius-to-explain-how-many-chess-positions-there-are#:~:text=There%20are%205%2C362%20distinct%20chess,and%20two%20moves%20for%20Black)." rel="noopener ugc nofollow" target="_blank">环节1 </a>和<a class="ae kx" href="https://www.scientificamerican.com/article/how-the-computer-beat-the-go-master/#:~:text=But%20go's%20complexity%20is%20bigger,or%2010360%20possible%20moves." rel="noopener ugc nofollow" target="_blank">环节2 </a>。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es kz"><img src="../Images/566be2392ea29ec6115f5a02fe0297d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-psF35HAUtbnyIRU4CPvnQ.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图2:白方第一步棋棋盘的可能状态。此图片来自<a class="ae kx" href="https://www.freecodecamp.org/news/simple-chess-ai-step-by-step-1d55a9266977/" rel="noopener ugc nofollow" target="_blank">【源】 </a> <em class="ky">仅供教育之用。</em></figcaption></figure><p id="0e6d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以像图3中一样说明<em class="jd">最小-最大</em>算法。请记住，在最大化步骤中，模型选择在最小化步骤中给出最大数量和最小数量的节点。最后，它根据所选节点的状态进行移动。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es la"><img src="../Images/9627e3205a8023ab03e6f7695f955f3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*f9Jh277FKOWoVfKi.png"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图3:最小最大算法的图示。此图片是从<a class="ae kx" href="https://neelshelar.com/minimax-algorithm-alpha-beta-pruning-adversarial-search/" rel="noopener ugc nofollow" target="_blank">【s<em class="ky">source】</em></a><em class="ky">检索而来，仅用于教育目的。</em></figcaption></figure><h1 id="a6ca" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">阿尔法-贝塔剪枝</h1><p id="51cf" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">当一个模型模拟<em class="jd"> Mini-Max </em>算法的场景时，它可能必须进行巨大的计算，尤其是当<em class="jd">深度</em>非常高的时候。并且观察到，即使保证不选择，该模型也计算状态。通过将同一行最小化(或最大化)状态中的当前节点的值与前一个上层节点的决策进行比较，您可以确定计算是不必要的，该上层节点通过在其子节点之间选择一个数字来声明该值。</p><p id="54cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在图4中，有一个<em class="jd"> Alpha-Beta剪枝</em>方法的图示。首先，<em class="jd"> Mini-Max </em>模型执行的计算是计算节点d下左侧节点的值。其值计算为3。第二步是计算节点D下的右节点，其值为5。所以节点D的值是5，因为它是最大化节点，并且数字3和5之间的最大值是5。下一步是计算节点E下左侧节点的值，其值计算为6。因此，模型知道节点E的任何值必须大于或等于6，因为节点E是另一个最大化节点，并且它已经有一个值为6的子节点。未来节点B要在节点D和节点e之间选择一个值，由于节点B是极小节点，所以需要选择值5或6≥。现在节点B的选择是5，节点B的值是5。如你所见，由于<em class="jd"> Alpha-Beta修剪</em>，该模型没有计算E下右边节点的值。让我们想象一个场景，其中没有使用这种方法，模型计算每一步，而不管是否需要这样做。此外，在这种情况下,<em class="jd">深度</em>很高。这两个因素的结合导致处理时间如此之长。</p><figure class="ki kj kk kl fd km er es paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="er es lb"><img src="../Images/50259f3a46e89147278ef273fe6a10b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ddddKEdKwDy-INul.jpg"/></div></div><figcaption class="kt ku et er es kv kw bd b be z dx translated">图4:Alpha-Beta修剪方法的图示。此图片是从<a class="ae kx" href="https://www.geeksforgeeks.org/minimax-algorithm-in-game-theory-set-4-alpha-beta-pruning/" rel="noopener ugc nofollow" target="_blank">【s<em class="ky">source】</em></a><em class="ky">检索而来，仅用于教育目的。</em></figcaption></figure><h1 id="35b6" class="je jf hi bd jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb bi translated">摘要</h1><p id="702f" class="pw-post-body-paragraph if ig hi ih b ii kc ik il im kd io ip iq ke is it iu kf iw ix iy kg ja jb jc hb bi translated">你可以在本文中找到关于<em class="jd"> Mini-Max </em>算法和<em class="jd"> Alpha-Beta修剪</em>的基本信息。你也可以有一个基本的理解，以便在你完整地阅读完这篇文章之后，实现一个在任何编程语言中使用这些方法的模型。</p><p id="272e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">查看我的Github repos，在那里你可以通过使用链接或卡片找到<a class="ae kx" href="https://github.com/yesyigitcan/Minimax-Chess" rel="noopener ugc nofollow" target="_blank">象棋游戏</a>和<a class="ae kx" href="https://github.com/yesyigitcan/MiniMax-TicTacToe" rel="noopener ugc nofollow" target="_blank"> TicTacToe游戏</a>上<em class="jd"> Mini-Max </em>和<em class="jd"> Alpha-Beta修剪</em>的代码实现。</p><div class="lc ld ez fb le lf"><a href="https://github.com/yesyigitcan/Minimax-Chess" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">GitHub——yesyigitcan/Minimax-Chess:在国际象棋游戏中使用……</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="lp l lq lr ls lo lt kr lf"/></div></div></a></div><div class="lc ld ez fb le lf"><a href="https://github.com/yesyigitcan/MiniMax-TicTacToe" rel="noopener  ugc nofollow" target="_blank"><div class="lg ab dw"><div class="lh ab li cl cj lj"><h2 class="bd hj fi z dy lk ea eb ll ed ef hh bi translated">GitHub——yesyigitcan/MiniMax-TIC tactoe:在一个井字游戏上的智能实现模型</h2><div class="lm l"><h3 class="bd b fi z dy lk ea eb ll ed ef dx translated">通过使用最小最大算法在一个井字游戏上实现模型智能你在你的终端上玩游戏…</h3></div><div class="ln l"><p class="bd b fp z dy lk ea eb ll ed ef dx translated">github.com</p></div></div><div class="lo l"><div class="lu l lq lr ls lo lt kr lf"/></div></div></a></div></div></div>    
</body>
</html>