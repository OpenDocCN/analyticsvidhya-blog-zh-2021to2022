<html>
<head>
<title>Scala , yet another programming language ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Scala，又一种编程语言？</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/scala-yet-another-programming-language-aa99a9015661?source=collection_archive---------10-----------------------#2021-07-18">https://medium.com/analytics-vidhya/scala-yet-another-programming-language-aa99a9015661?source=collection_archive---------10-----------------------#2021-07-18</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div class="er es ie"><img src="../Images/10f47f651892ce6bbb72112cba4cc46b.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/0*xYZ4rJ1hOUONqo-z"/></div></figure><p id="c3ed" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Scala并不是一个新东西，但是在最近几年里，它已经引起了开发者的极大兴趣。它在大数据生态系统中的广泛采用无疑凸显了它的存在，并使它成为一件著名的事情，并在少数最著名的程序员中获得一席之地。理解这一点很重要，不是scala公开的特性是新的，也不是其他替代方案提供的，而是scala让你在代码中执行这些事情的方式。</p><p id="3c07" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">进化是不可避免的，这在编程语言的世界中没有什么不同。对编程语言的标准最低期望不再与我们在第三代编程语言的圣经中读到的一样。互操作性和可重用性等方面已经变得不同于我们之前对它们的理解，这是有原因的。冗长实际上不再是代码可读性的折衷。我们多年的朋友，Java因过于冗长而臭名昭著。</p><h1 id="da5c" class="jj jk hh bd jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg bi translated">里面有什么功能？</h1><p id="9660" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">最近，我们经常听说所有的现代编程语言都在向函数式范式发展。这实际上意味着什么？这是一种用纯函数创建代码的方式，它让你不用共享状态和可变数据，而在面向对象的世界里，我们一直在处理这些数据。重点是结果是什么，而不是实现的过程。一切都是它的功能。理论是让一切都像数学表达式一样使用条件表达式，以便计算并达到一个状态。</p><h2 id="1773" class="km jk hh bd jl kn ko kp jp kq kr ks jt iw kt ku jx ja kv kw kb je kx ky kf kz bi translated">反编译，在JVM中</h2><p id="5934" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">Scala已经在非常有名的Java虚拟机上实现了。是的，你猜对了，Scala编译成Java字节码。Scala的源代码由编译器解释以产生高效的JVM字节码。这是它取得巨大成功的主要原因之一。将通常的编译分解成三层——前端构建AST树并增强它。中间端做一些平台无关的优化，称为<em class="la">尾调用</em>，后端为CPU做优化并生成汇编文件。另一方面，Scala编译器的组织方式几乎没有什么不同，例如CPU特定的优化被委托给JVM。</p><blockquote class="lb lc ld"><p id="988e" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">一棵<strong class="in hi">抽象语法树</strong>——也称为AST——是编译器如何解释代码的表示。它由解析器和词法分析器(一些常见的编译器组件)的编译阶段创建。AST保留代码中的所有操作和值。</p></blockquote></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h1 id="0343" class="jj jk hh bd jl jm lo jo jp jq lp js jt ju lq jw jx jy lr ka kb kc ls ke kf kg bi translated">编译和构建块的阶段</h1><figure class="lu lv lw lx fd ii er es paragraph-image"><div class="er es lt"><img src="../Images/16200b80f8c978d262d46d2658140929.png" data-original-src="https://miro.medium.com/v2/resize:fit:700/format:webp/0*bZVqo1Mv7RdXrD-q.jpg"/></div></figure><blockquote class="lb lc ld"><p id="6254" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">Scala总共有25个编译阶段，让我们来谈谈最重要的几个</p></blockquote><p id="52de" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">解析</strong> —第一阶段，使用解析器和扫描器创建非类型化AST。这是抛出语法错误的地方。</p><p id="724c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">类型检查器</strong> —推断类型，检查类型是否匹配，类型检查引用和违规。</p><p id="8ea6" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">擦除</strong> —这种类型擦除是一种JVM特性，它是用Java 5的泛型创建的，以实现向后兼容性。当使用泛型或者在代码中创建值类时，它们在这个阶段会被删除。</p><p id="d60e" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">隐式转换</strong> —这是一组在引用错误类型的对象时应用的方法。它允许编译器自动从一种类型转换到另一种类型。</p><p id="d336" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在两种情况下需要隐式转换:</p><ul class=""><li id="eea0" class="ly lz hh in b io ip is it iw ma ja mb je mc ji md me mf mg bi translated">如果A和S类型的表达式与预期的b类型的表达式不匹配。</li><li id="093c" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji md me mf mg bi translated">在类型A的表达式e的选择e. m中，如果选择器m不表示A的成员。</li></ul><p id="70bd" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">对List[Int]类型的两个列表xa和ya的操作是合法的</p><pre class="lu lv lw lx fd mm mn mo mp aw mq bi"><span id="2305" class="km jk hh mn b fi mr ms l mt mu">xa = ya</span></pre><p id="16ac" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">给定的隐式方法listorder和intorder在作用域中定义如下:</p><blockquote class="lb lc ld"><p id="19ab" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">隐式def listorder[A](x: List[A]) <br/>(隐式elemorder: A = &gt;有序[A]):有序[List[A]] = <br/>新有序[List[A]] { /*..*/}<br/>implicit def into order(x:Int):Ordered[Int]=<br/>new Ordered[Int]{/*..*/ }</p></blockquote><p id="7768" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">模式匹配</strong> —模式匹配是一种检查给定令牌序列是否存在特定模式的方法。这是Scala中使用最广泛的特性。</p><p id="58cb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">"<strong class="in hi"> match </strong>"关键字被用来代替switch语句。“匹配”是在Scala的根类中定义的，以使其对所有对象可用。这可以包含一系列的选择。每个备选项将从<strong class="in hi"> case </strong>关键字开始。每个case语句都包括一个模式和一个或多个表达式，如果指定的模式匹配，就会计算这些表达式。为了将模式与表达式分开，使用了<strong class="in hi">箭头符号(= &gt; ) </strong></p><blockquote class="lb lc ld"><p id="7f27" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b"><strong class="in hi">object</strong></code> <code class="du mv mw mx mn b">Pattern {</code></p><p id="93e6" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">【T2<code class="du mv mw mx mn b">main(args<strong class="in hi">:</strong></code><code class="du mv mw mx mn b">Array[String]) {</code></p><p id="e0e8" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">println(print(1));</code></p><p id="e82a" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">}</code></p><p id="a3c7" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b"><strong class="in hi">def</strong></code> <code class="du mv mw mx mn b">print(x<strong class="in hi">:</strong>Int)<strong class="in hi">:</strong></code> <code class="du mv mw mx mn b">String <strong class="in hi">=</strong></code> <code class="du mv mw mx mn b">x <strong class="in hi">match</strong></code> <code class="du mv mw mx mn b">{</code></p><p id="fe77" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// if value of x is 0,</code></p><p id="b172" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// this case will be executed</code></p><p id="e8aa" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b"><strong class="in hi">case</strong></code><code class="du mv mw mx mn b">0</code><code class="du mv mw mx mn b"><strong class="in hi">=&gt;</strong></code>T3】</p><p id="3f94" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// if value of x is 1,</code></p><p id="a3f2" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// this case will be executed</code></p><p id="b059" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b"><strong class="in hi">case</strong></code> <code class="du mv mw mx mn b">1</code> <code class="du mv mw mx mn b"><strong class="in hi">=&gt;</strong></code> <code class="du mv mw mx mn b">"Hello again"</code></p><p id="aeb3" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// if x doesnt match any sequence,</code></p><p id="654f" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">// then this case will be executed</code></p><p id="e8c4" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b"><strong class="in hi">case</strong></code>T13<code class="du mv mw mx mn b"><strong class="in hi">=&gt;</strong></code>T15】</p><p id="f4ca" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">}</code></p><p id="d305" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated"><code class="du mv mw mx mn b">}</code></p></blockquote><p id="4d06" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">输出—再次问候</p><p id="2f3f" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">优化阶段和尾部调用</strong>—<em class="la">尾部调用</em>阶段优化了尾部递归:在字节码中，它被替换为跳转调用，因此在字节码中，它看起来像一个普通的for循环。在Scala中，只优化对当前函数的直接递归调用。这个概念有时优于头递归，以避免深度递归时的堆栈溢出错误。<em class="la">示例JVM将所有调用保存在其内部堆栈中。内部堆栈的内存有限。所以如果我们试着求阶乘的值(10000)。这将导致堆栈溢出错误，因为递归深度太深，JVM无法处理。</em></p><blockquote class="lb lc ld"><p id="58cd" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">Scala编译器在优化代码方面做得很好，当实现不是尾递归时，它会警告我们。</p><p id="9f32" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">为什么编译Scala代码需要这么长时间——嗯，最长的阶段是typer阶段——类型检查。Scala有一个丰富复杂的类型系统，需要大量的时间来处理。此外，像Shapeless这样的库是基于隐式和宏的，非常耗时。</p></blockquote></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="340d" class="km jk hh bd jl kn ko kp jp kq kr ks jt iw kt ku jx ja kv kw kb je kx ky kf kz bi translated">λ表达式</h2><p id="21d5" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated"><strong class="in hi">λ表达式</strong>是使用<a class="ae my" href="https://www.geeksforgeeks.org/anonymous-functions-in-scala/" rel="noopener ugc nofollow" target="_blank"> <strong class="in hi">匿名函数</strong> </a>代替变量或值的表达式。它们在Scala中也被称为<strong class="in hi"><em class="la">curry</em></strong>。当我们在某个地方使用一个简单的函数时，Lambda表达式是很方便的。这些表达式比定义一个完整的函数更快，表达能力更强，这增强了函数的可读性。Lambda表达式可以在任何类型的转换中重用。它可以迭代对象集合，并对它们执行某种转换。</p><p id="5a0c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">val name =(名称变量:类型)=&gt;Todo_Expression</p><p id="fe9c" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">val输出= (x:Int) =&gt; x+ 100</p><blockquote class="lb lc ld"><p id="689a" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">object get cube {<br/>val cube =(x:Int)=&gt;x * x * x</p><p id="01f5" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">def main(args:Array[String]){<br/>var x = 2；<br/> printf("的立方"+ x +"是"+ cube(x)) <br/> } <br/> }</p></blockquote><p id="7e3d" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">输出-2的立方是8</p><p id="6433" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">Scala还支持<strong class="in hi"> <em class="la">部分函数— </em> </strong>当一个函数不能为提供给它的每个变量输入数据产生一个返回时，那么这个函数就被称为<strong class="in hi">部分函数</strong>。它只能确定某些实际输入的子集的输出。它只能部分应用于指定的输入。</p><blockquote class="lb lc ld"><p id="4b33" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">部分功能是一个特征，需要两种方法来实现，即<strong class="in hi">在</strong>中定义和<strong class="in hi">在</strong>中应用。它可以通过使用case语句来解释。</p></blockquote></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="72cf" class="km jk hh bd jl kn ko kp jp kq kr ks jt iw kt ku jx ja kv kw kb je kx ky kf kz bi translated">Scala中的并发性</h2><p id="12ef" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">Scala并发是建立在Java并发模型之上的。在JVM上，通过IO密集型负载，我们可以在一台机器上运行数千个线程。</p><p id="d3bb" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一个线程接受一个可运行的。你必须在一个线程上调用<code class="du mv mw mx mn b">start</code>来运行Runnable。</p><pre class="lu lv lw lx fd mm mn mo mp aw mq bi"><span id="bafe" class="km jk hh mn b fi mr ms l mt mu">scala&gt; val x = new Thread(new Runnable {<br/>  def run() {<br/>    println("Scala")<br/>  }<br/>})<br/>x: java.lang.Thread = Thread[Thread-3,5,main]<br/><br/>scala&gt; x.start<br/>Scala</span></pre><p id="e963" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi">期货</strong> — A <code class="du mv mw mx mn b">Future</code>是异步计算。你可以在将来包装你的计算，当你需要结果的时候，你可以简单地调用一个阻塞的<code class="du mv mw mx mn b">Await.result()</code>方法。一个<code class="du mv mw mx mn b">Executor</code>返回一个<code class="du mv mw mx mn b">Future</code>。</p><p id="463a" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">一个<code class="du mv mw mx mn b">FutureTask</code>是可运行的，并且被设计成由一个<code class="du mv mw mx mn b">Executor. </code>来运行，Futures是一个以高效和无阻塞的方式运行并行程序的好方法</p><pre class="lu lv lw lx fd mm mn mo mp aw mq bi"><span id="9ad4" class="km jk hh mn b fi mr ms l mt mu">val future = new FutureTask[String](new Callable[String]() {<br/>  def call(): String = {<br/>    searcher.search(something);<br/>}})<br/>executor.execute(future) }</span><span id="0742" class="km jk hh mn b fi mz ms l mt mu">//<br/>val blockingOutput = Await.result(future)</span></pre><blockquote class="lb lc ld"><p id="0300" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">在scala中安全处理线程类似于java，有同步、可变、原子引用、读写锁、倒计时锁和原子数据类型等选项。</p></blockquote><p id="2379" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">期货允许我们在主线程之外运行值，并通过回调映射来处理正在后台运行或尚未执行的值。</p><p id="4140" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">如果你来自Java背景，你可能会意识到<code class="du mv mw mx mn b">java.util.concurrent.Future</code>。使用它有几个挑战:</p><ul class=""><li id="66e0" class="ly lz hh in b io ip is it iw ma ja mb je mc ji md me mf mg bi translated">线程在访问值时总是被阻塞。</li><li id="79d0" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji md me mf mg bi translated">等待，直到计算完成。</li><li id="9382" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji md me mf mg bi translated"><code class="du mv mw mx mn b">GET</code>是检索值的唯一方法。</li></ul><p id="51d1" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">这不是编写并发代码的好方法。Scala通过<code class="du mv mw mx mn b">Scala.concurrent.Future</code>提供了更好的特性。借助Scala Futures，我们可以实现:</p><ol class=""><li id="9df0" class="ly lz hh in b io ip is it iw ma ja mb je mc ji na me mf mg bi translated">实时无阻塞计算。</li><li id="454d" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji na me mf mg bi translated">对<code class="du mv mw mx mn b">onComplete</code>(成功或失败)的回调，将来的值是Try子句的实例。</li><li id="22ab" class="ly lz hh in b io mh is mi iw mj ja mk je ml ji na me mf mg bi translated">多重未来的映射。</li></ol><p id="b678" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">期货本质上是不可变的，并且被内部缓存。一旦一个值或异常被赋值，未来就不能被修改/覆盖(很难实现参照透明性)。</p><p id="a5d9" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated"><strong class="in hi"> <em class="la">执行上下文</em> </strong>，有了期货无论回调到什么点都要执行，这是要确定在哪个线程上从池中得到执行。执行上下文决定了这一点。默认的是ExecutionContext.global，它使用全局池中的线程，线程的数量取决于有多少个CPU内核。这使用线程池中的默认fork join在后台运行线程。</p></div><div class="ab cl lh li go lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ha hb hc hd he"><h2 id="07a3" class="km jk hh bd jl kn ko kp jp kq kr ks jt iw kt ku jx ja kv kw kb je kx ky kf kz bi translated"><strong class="ak">懒评</strong></h2><p id="fb14" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">编译器不会立即评估一个<em class="la">惰性值</em>的绑定表达式。它只在第一次访问时计算变量。<br/>初始访问时，编译器评估表达式，并将结果存储在<em class="la">惰性值</em>中。每当我们在后面的阶段访问这个<em class="la"> val </em>时，没有执行发生，编译器返回结果。</p><blockquote class="lb lc ld"><p id="edf1" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">惰性求值或按需调用是一种求值策略，其中表达式直到第一次使用时才求值，即推迟求值直到需要时。</p></blockquote><p id="1129" class="pw-post-body-paragraph il im hh in b io ip iq ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji ha bi translated">在急切计算时，我们可能会浪费我们的操作(CPU计算),当我们编写更复杂和更大的代码时，这可能是非常昂贵的。在这里，惰性求值帮助我们优化过程，只在需要的时候求值，避免不必要的开销。</p><blockquote class="lb lc ld"><p id="f387" class="il im la in b io ip iq ir is it iu iv le ix iy iz lf jb jc jd lg jf jg jh ji ha bi translated">然而，这并不总是好的——因为程序员无法控制程序的执行，所以发现bug可能很棘手。</p></blockquote><h2 id="2e66" class="km jk hh bd jl kn ko kp jp kq kr ks jt iw kt ku jx ja kv kw kb je kx ky kf kz bi translated">结论</h2><p id="ef39" class="pw-post-body-paragraph il im hh in b io kh iq ir is ki iu iv iw kj iy iz ja kk jc jd je kl jg jh ji ha bi translated">很明显，Scala并不是一种新的做事方式，而是一种稍微不同的或功能性的做事方式，这是我们在Java中一直在做的事情。它与JVM无缝交互，这有助于发挥其最大优势。像类型检查器这样的状态可能有时会让人觉得编译时间是痛苦的，但是像避免冷编译、hydra GC检查以及宏和隐式可以节省在键入阶段花费的大量时间。</p></div></div>    
</body>
</html>