<html>
<head>
<title>How To Estimate Optimal Stock Portfolio Weights Using Monte Carlo Simulations &amp; Modern Portfolio Theory</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用蒙特卡罗模拟和现代投资组合理论估计最优股票投资组合权重</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/how-to-estimate-optimal-stock-portfolio-weights-using-monte-carlo-simulations-modern-portfolio-d27d534e8a1a?source=collection_archive---------4-----------------------#2021-01-19">https://medium.com/analytics-vidhya/how-to-estimate-optimal-stock-portfolio-weights-using-monte-carlo-simulations-modern-portfolio-d27d534e8a1a?source=collection_archive---------4-----------------------#2021-01-19</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><figure class="ev ex if ig ih ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es ie"><img src="../Images/651033bdfddc74520df06230335c6085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*yxaA6h7KAtyv8ShY.jpg"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">20世纪20年代的福特汽车工厂(与主题一致，因为后面的示例投资组合都是美国汽车行业的股票)</figcaption></figure><h1 id="24fb" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">摘要</h1><blockquote class="jr"><p id="83ef" class="js jt hh bd ju jv jw jx jy jz ka kb dx translated">在这篇文章中，我简要地解释了如何将现代投资组合理论与蒙特卡洛模拟结合使用，以估计给定股票投资组合的最佳权重，从而实现“最佳”风险回报权衡</p></blockquote><figure class="kc kd ke kf kg ii"><div class="bz dy l di"><div class="kh ki l"/></div></figure><p id="759d" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">这是我上一篇文章的延续，在那篇文章中，我分享了我开发的一个python <a class="ae lg" href="https://www.stonksforecast.online/" rel="noopener ugc nofollow" target="_blank"> web应用</a>，它允许用户使用几何布朗运动(GBM)或Bootstrap采样来模拟未来的股票价格运动。</p><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/building-a-monte-carlo-method-stock-price-simulator-with-geometric-brownian-motion-and-bootstrap-e346ff464894"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">用几何布朗运动和Bootstrap建立蒙特卡罗方法股票价格模拟器</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">警告！我不是任何类型的投资大师，所以我强烈建议你不要把这篇文章作为(唯一的)…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="lu l lv lw lx lt ly in lk"/></div></div></a></div><p id="85c2" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">然而，在上一篇文章的结尾，我留下了一个悬而未决的问题:<strong class="kl hi">对于一个给定的股票投资组合，我们如何知道我们选择了“最佳”权重？</strong></p><p id="6af7" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated"><strong class="kl hi"> <em class="lz">【警告！我不是任何类型的投资大师，所以我强烈建议你不要把这篇文章作为你投资决策的(唯一)来源。考虑到MPT和有效前沿模型的一些局限性，这一点尤其重要，正如本文后面所讨论的]</em></strong></p><h1 id="f273" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">概述</h1><ul class=""><li id="02e6" class="ma mb hh kl b km mc kq md ku me ky mf lc mg kb mh mi mj mk bi translated"><a class="ae lg" href="#d00d" rel="noopener ugc nofollow">现代投资组合理论&amp;有效前沿</a></li><li id="e2e6" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated"><a class="ae lg" href="#4d72" rel="noopener ugc nofollow">投资组合绩效指标—夏普&amp;排序比率</a></li><li id="e50c" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated"><a class="ae lg" href="#79b9" rel="noopener ugc nofollow">用Python代码实现</a></li><li id="2720" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated"><a class="ae lg" href="#c94d" rel="noopener ugc nofollow">结论</a></li></ul><div class="lh li ez fb lj lk"><a href="https://github.com/ZhijingEu/StockSimulatorFlaskApp" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">ZhijingEu/StockSimulatorFlaskApp</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">这是一个股票分析Python Flask web应用程序，它允许你使用…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">github.com</p></div></div><div class="lt l"><div class="mq l lv lw lx lt ly in lk"/></div></div></a></div><h1 id="d00d" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">现代投资组合理论与有效前沿</h1><p id="f3bb" class="pw-post-body-paragraph kj kk hh kl b km mc ko kp kq md ks kt ku mr kw kx ky ms la lb lc mt le lf kb ha bi translated">MPT是由诺贝尔奖获得者Harry Markowitz博士在20世纪50年代发明的，它是一种确定投资组合“最优”权重的方法，该方法使收益最大化(由投资组合的预期收益表示)，同时风险最小化(由收益的标准差反映)</p><div class="lh li ez fb lj lk"><a href="https://www.guidedchoice.com/video/dr-harry-markowitz-father-of-modern-portfolio-theory/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">哈里·马科维茨的现代投资组合理论【有效前沿】</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">世上没有完美的投资，但精心策划一个能提供高回报和相对低成本的策略…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.guidedchoice.com</p></div></div><div class="lt l"><div class="mu l lv lw lx lt ly in lk"/></div></div></a></div><p id="90f8" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">乍一看，天真的解决方案可能是将所有资金投资于平均回报率最高、标准差最低的股票，但推动投资组合整体“风险”水平的是股票回报率的联动(GBM和Bootstrap抽样方法都试图对此建模)。股票收益之间的较低协方差导致较低的整体投资组合标准差。换句话说，<strong class="kl hi"> <em class="lz">多样化一般会降低风险</em> </strong>。</p><p id="deef" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">可视化不同权重投资组合表现的一个有用方法是绘制每个投资组合回报的平均值和标准差，这将导致一个看起来有点像下图的图表</p><figure class="mw mx my mz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es mv"><img src="../Images/50fcb69397906e8c03eb366dd8311283.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oUEnDEYqAOYew4kgPexZQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">来源:https://en.wikipedia.org/wiki/Efficient_frontier<a class="ae lg" href="https://en.wikipedia.org/wiki/Efficient_frontier" rel="noopener ugc nofollow" target="_blank"/></figcaption></figure><p id="0fd5" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">根据现代投资组合理论，有一个投资组合权重的“有效边界”，它由“C”曲线的左上部分反映，因为它为给定的标准差提供了最高的回报。还有“无风险”资产的概念，即给你回报但标准差为零的资产。这通常是政府短期国库券(<em class="lz">注:不幸的是，在实践中通常没有完全零标准差的项目)</em></p><p id="c22f" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">如果我们画一条穿过“无风险利率”回报的线到曲线的切线，这给出了具有最高斜率的资本分配线(CAL ),位于切线上的投资组合是具有“最佳”风险回报比的投资组合。</p><h2 id="4d72" class="na iu hh bd iv nb nc nd iz ne nf ng jd ku nh ni jh ky nj nk jl lc nl nm jp nn bi translated"><strong class="ak">投资组合绩效指标—夏普比率&amp;索提诺比率</strong></h2><p id="b1eb" class="pw-post-body-paragraph kj kk hh kl b km mc ko kp kq md ks kt ku mr kw kx ky ms la lb lc mt le lf kb ha bi translated">有许多不同的投资组合业绩指标，但我们现在只关注两个相对简单的指标:夏普比率和索蒂诺比率。</p><p id="b4e3" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated"><strong class="kl hi">夏普比率</strong></p><p id="0b91" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">夏普比率本质上可以被认为是资本分配线的斜率，而<em class="lz">描述了你在经历额外波动时获得的“无风险”资产的超额回报。</em>它由以下等式表示:</p><figure class="mw mx my mz fd ii er es paragraph-image"><div class="er es no"><img src="../Images/90ab5739f3058a88c1fbe7d960468e1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*OLPEj3ba9PXjBre7vBjZJg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">来源:<a class="ae lg" href="https://www.investopedia.com/articles/07/sharpe_ratio.asp" rel="noopener ugc nofollow" target="_blank">https://www.investopedia.com/articles/07/sharpe_ratio.asp</a></figcaption></figure><div class="lh li ez fb lj lk"><a href="https://www.investopedia.com/articles/07/sharpe_ratio.asp" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">了解夏普比率</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">自从1966年威廉·夏普创立夏普比率以来，它一直是最受关注的风险/回报…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.investopedia.com</p></div></div><div class="lt l"><div class="np l lv lw lx lt ly in lk"/></div></div></a></div><p id="7cd6" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">利用这一点，我们可以估计具有最高夏普比率的投资组合，该比率反映了给出“最佳”风险回报剖面的投资组合。</p><p id="75b0" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">夏普比率的典型值范围为:</p><ul class=""><li id="39a2" class="ma mb hh kl b km kn kq kr ku nq ky nr lc ns kb mh mi mj mk bi translated">小于1: <strong class="kl hi">坏</strong></li><li id="7108" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated">1–1.99:<strong class="kl hi">充足/良好</strong></li><li id="f821" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated">2–2.99:<strong class="kl hi">非常好</strong></li><li id="dba5" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated">大于3: <strong class="kl hi">优秀</strong></li></ul><p id="cd18" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">来源:<a class="ae lg" href="https://corporatefinanceinstitute.com/resources/knowledge/finance/sharpe-ratio-definition-formula/" rel="noopener ugc nofollow" target="_blank">CorpFinanceInstitute.com</a></p><p id="0115" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated"><strong class="kl hi">排序比</strong></p><p id="5f09" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">夏普比率的一个缺点是，它假设上涨和下跌的可变性同等重要(即标准偏差只是整个收益分布的标准偏差，不管收益是+ve还是-ve)。</p><p id="72b8" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">如果回报分布相当对称，即正回报与负回报的天数相等，夏普比率就是“风险”的合理反映。然而，如果这不是真的，并且假设我们更担心不利因素而不是有利因素，我们需要另一个衡量标准<em class="lz">，特别是在比较不同的投资</em>时，因为它们可能有相似的总体标准差，但可能有不同的不利因素。</p><figure class="mw mx my mz fd ii er es paragraph-image"><div class="er es nt"><img src="../Images/4d949854edc31f5072a27e1bbfd705f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:778/format:webp/1*dnGR3gvhdiVrMIz5Ge0fNg.png"/></div><figcaption class="ip iq et er es ir is bd b be z dx translated">资料来源:Investopedia.com</figcaption></figure><p id="2a8b" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">从上面的公式中可以看出，Sortino比率是Sharpe比率的略微调整版本，其中标准偏差仅基于下行值。</p><div class="lh li ez fb lj lk"><a href="https://www.investopedia.com/ask/answers/010815/what-difference-between-sharpe-ratio-and-sortino-ratio.asp" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">夏普比率和索提诺比率之间的差异</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">夏普比率和索蒂诺比率都是对投资回报的风险调整评估。夏普比率…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.investopedia.com</p></div></div><div class="lt l"><div class="nu l lv lw lx lt ly in lk"/></div></div></a></div><figure class="mw mx my mz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es nv"><img src="../Images/98ef5aaedb4fe8b8b20a9d628aa07619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foRCrXJdMjcp5WZc6130Eg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">当比较这两种股票时，GM股票的“波动性”(假设对数回报的标准差是风险的良好代表)高出34%(即0.0266/0.0204)。然而，如果你使用收益的整个分布，但如果你只使用负收益，只有大约29%</figcaption></figure><h1 id="79b9" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated"><strong class="ak">用Python代码实现</strong></h1><p id="f8d4" class="pw-post-body-paragraph kj kk hh kl b km mc ko kp kq md ks kt ku mr kw kx ky ms la lb lc mt le lf kb ha bi translated">这里的一些代码将引用之前的文章，我已经描述了一些函数，这些函数使用几何布朗运动和Bootstrap采样从Yahoo Finance中提取_prices，计算_returns并预测未来价格，我将在下面再次引用这些函数。</p><p id="84e1" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">以前，对未来回报(以及价格)的蒙特卡洛模拟是使用用户定义的投资组合权重进行的。</p><p id="a77e" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">这一次，我们将使用随机生成的投资组合权重来运行它们，而不是科技公司股票的投资组合，我想我会在2018年至2020年的3年时间里使用汽车行业的股票(通用汽车-通用汽车，Tesla特斯拉，福特，赛车-法拉利)。</p><p id="25a4" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">要根据历史结果计算有效边界，只需提取过去的回报并选择一个合适的无风险利率。</p><p id="fe56" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">在代码中，它看起来像这样:</p><pre class="mw mx my mz fd nw nx ny nz aw oa bi"><span id="9628" class="na iu hh nx b fi ob oc l od oe">def EfficientPortfolioHistorical(start_date,end_date,symbols,portfolioValue,NoOfIterationsMC,AnnualRiskFreeRate,imagecounter,targetfolder):<br/>    <br/>    RiskFreeRate=(1+AnnualRiskFreeRate)**(1/252)-1<br/>    #Effective rate for period = (1 + annual rate)**(1 / # of periods) – 1<br/>    <br/>    for symbol in symbols:<br/>        dfprices = data.DataReader(symbols, start=start_date, end=end_date, data_source='yahoo')<br/>        dfprices = dfprices[['Adj Close']]<br/>    dfprices.columns=[' '.join(col).strip() for col in dfprices.columns.values]<br/>    <br/>    priceAtEndDate=[]<br/>    for symbol in symbols:<br/>        priceAtEndDate.append(dfprices[[f'Adj Close {symbol}']][-(1):].values[0][0])<br/>    <br/>    symbolsWPortfolio=symbols+["Portfolio"]<br/>    <br/>    ResultsTable=[]<br/>    <br/>    for i in range(0,NoOfIterationsMC):<br/>        <br/>        dfprices_inner=dfprices<br/>        portfolioWeightsRandom=list(np.random.dirichlet(np.ones(len(symbols)),size=1)[0])<br/>        <br/>        noOfShares=[]<br/>        portfolioValPerSymbol=[x * portfolioValue for x in portfolioWeightsRandom]<br/>        for j in range(0,len(symbols)):<br/>            noOfShares.append(portfolioValPerSymbol[j]/priceAtEndDate[j])<br/>        noOfShares=[round(element, 5) for element in noOfShares]<br/>        listOfColumns=dfprices_inner.columns.tolist()   <br/>        dfprices_inner["Adj Close Portfolio"]=dfprices_inner[listOfColumns].mul(noOfShares).sum(1)</span><span id="70d3" class="na iu hh nx b fi of oc l od oe">dfreturns ,df_mean_stdev=calc_returns(dfprices_inner,symbols)<br/>        <br/>        mu=np.array(df_mean_stdev["Mean Log Daily Return"].values.tolist())<br/>        sigma=np.array(df_mean_stdev["StdDev Log Daily Return"].values.tolist())<br/>             <br/>        IterationStdDev=df_mean_stdev.tail(1).values[0][2]<br/>        IterationMean=df_mean_stdev.tail(1).values[0][1]<br/>            <br/>        negativereturnsonly=pd.DataFrame(dfreturns.iloc[:,len(dfreturns.columns)-1])<br/>        negativereturnsonly=negativereturnsonly[negativereturnsonly['Log Daily Returns Adj Close Portfolio']&lt;0]<br/>        IterationNegativeReturnsStdDev=negativereturnsonly['Log Daily Returns Adj Close Portfolio'].std()<br/>        <br/>        # Note to go from LOG returns to Simple returns , I used simple returns =exp(log returns)−1 <br/>        IterationSharpeRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationStdDev)-1),3)<br/>        <br/>        IterationSortinoRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationNegativeReturnsStdDev)-1),3)<br/>        <br/>        X=[portfolioWeightsRandom,IterationStdDev,IterationMean,IterationSharpeRatio,IterationSortinoRatio]<br/>        <br/>        ResultsTable.append(X)<br/>        <br/>        dfprices_inner.drop('Adj Close Portfolio',inplace=True, axis=1)<br/>    <br/>    FinalResultsTable=pd.DataFrame(ResultsTable,columns=["Weights","Std Dev","Mean","Sharpe Ratio","Sortino Ratio"])<br/>    <br/>    historical_dfreturns ,historical_df_mean_stdev=calc_returns(dfprices,symbols)<br/>    <br/>    historical_df_mean_stdev=historical_df_mean_stdev[['Stock','StdDev Log Daily Return','Mean Log Daily Return']]<br/>    historical_df_mean_stdev.columns=['Stock','Std Dev','Mean']<br/>    <br/>    fig, ax = plt.subplots(figsize=(10, 5))<br/>    <br/>    FinalResultsTable.plot.scatter(x="Std Dev",y='Mean',ax=ax)<br/>    historical_df_mean_stdev.plot.scatter(x="Std Dev",y='Mean',c='r',marker='x',ax=ax)</span><span id="d51f" class="na iu hh nx b fi of oc l od oe">SharpeStdDev=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Std Dev'].values[0]<br/>    SharpeMean=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Mean'].values[0]<br/>    Sharperoundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Weights'].values[0]]<br/>    Sharpeweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sharpeweightstring.append([symbols[i]+":",Sharperoundedweights[i]])<br/>    SharpeLabel="Optimal Sharpe Ratio"<br/>    SharpeDetail='Optimal Sharpe Ratio: '+str(FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Sharpe Ratio'].values[0])+" with Weights "+str(Sharpeweightstring)</span><span id="5919" class="na iu hh nx b fi of oc l od oe">SortinoStdDev=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Std Dev'].values[0]<br/>    SortinoMean=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Mean'].values[0]<br/>    Sortinoroundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sortino Ratio'])['Weights'].values[0]]<br/>    Sortinoweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sortinoweightstring.append([symbols[i]+":",Sortinoroundedweights[i]])<br/>    SortinoLabel='Optimal Sortino Ratio'<br/>    SortinoDetail='Optimal Sortino Ratio: '+str(FinalResultsTable.nlargest(1,['Sortino Ratio'])['Sortino Ratio'].values[0])+" with Weights "+str(Sortinoweightstring)<br/>    <br/>    SharpeSortino=pd.DataFrame(zip([SharpeStdDev,SortinoStdDev],[SharpeMean,SortinoMean]),index=['Optimal Sharpe','Optimal Sortino'],columns=['Std Dev','Mean'])<br/>    SharpeSortino.plot.scatter(x="Std Dev",y='Mean',c='g',marker='x',ax=ax)<br/>    <br/>    txt=list(historical_df_mean_stdev['Stock'])+[SharpeLabel,SortinoLabel]<br/>    z=list(historical_df_mean_stdev['Std Dev'])+[SharpeStdDev,SortinoStdDev]<br/>    y=list(historical_df_mean_stdev['Mean'])+[SharpeMean,SortinoMean]</span><span id="bd30" class="na iu hh nx b fi of oc l od oe">for i, text in enumerate(txt):<br/>        ax.annotate(text, (z[i], y[i]))<br/>    <br/>    plt.title("Mean vs Std Dev Of Log Returns For "+str(NoOfIterationsMC)+" Different Portfolio Weights")<br/>    plt.savefig(f'static/{targetfolder}/{imagecounter}_efficientportfolio.png')<br/>    print(SharpeDetail)<br/>    print(SortinoDetail)<br/>    <br/>    FinalResultsTable['Log Returns Std Dev']=FinalResultsTable['Std Dev']<br/>    FinalResultsTable['Log Returns Mean']=FinalResultsTable['Mean']<br/>    FinalResultsTable=FinalResultsTable[['Weights','Log Returns Std Dev','Log Returns Mean','Sharpe Ratio','Sortino Ratio']]<br/>    <br/>    return FinalResultsTable, SharpeDetail, SortinoDetail</span></pre><figure class="mw mx my mz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es og"><img src="../Images/17db379a20324c28ed06a807d6157bd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PsNl9dnbml2zpf5a7g8LEA.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">黄色突出显示反映了有效边界</figcaption></figure><p id="214b" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">未来的结果会变得更有趣。我采用的概念方法是使用蒙特卡罗模拟生成一组随机的投资组合权重，然后对每个投资组合使用几何布朗运动或自助抽样来预测整体投资组合回报的未来回报，并计算夏普和索蒂诺比率。然后对所有这些单个投资组合进行排名，以找到具有“最佳”夏普和索蒂诺比率的投资组合权重。</p><p id="f21b" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">我第一次尝试实现它时，看起来如下</p><pre class="mw mx my mz fd nw nx ny nz aw oa bi"><span id="5369" class="na iu hh nx b fi ob oc l od oe">def EfficientPortfolioWRONGFuture(start_date,end_date,symbols,portfolioValue,T,N,NoOfIterationsMC,AnnualRiskFreeRate,SimMethod,imagecounter,targetfolder):<br/>    <br/>    RiskFreeRate=(1+AnnualRiskFreeRate)**(1/252)-1<br/>    #Effective rate for period = (1 + annual rate)**(1 / # of periods) – 1<br/>    <br/>    for symbol in symbols:<br/>        dfprices = data.DataReader(symbols, start=start_date, end=end_date, data_source='yahoo')<br/>        dfprices = dfprices[['Adj Close']]<br/>    dfprices.columns=[' '.join(col).strip() for col in dfprices.columns.values]<br/>    <br/>    priceAtEndDate=[]<br/>    for symbol in symbols:<br/>        priceAtEndDate.append(dfprices[[f'Adj Close {symbol}']][-(1):].values[0][0])<br/>    <br/>    symbolsWPortfolio=symbols+["Portfolio"]<br/>    <br/>    ResultsTable=[]<br/>    <br/>    for i in range(0,NoOfIterationsMC):<br/>        <br/>        dfprices_inner=dfprices<br/>        portfolioWeightsRandom=list(np.random.dirichlet(np.ones(len(symbols)),size=1)[0])<br/>        <br/>        noOfShares=[]<br/>        portfolioValPerSymbol=[x * portfolioValue for x in portfolioWeightsRandom]<br/>        for j in range(0,len(symbols)):<br/>            noOfShares.append(portfolioValPerSymbol[j]/priceAtEndDate[j])<br/>        noOfShares=[round(element, 5) for element in noOfShares]<br/>        listOfColumns=dfprices_inner.columns.tolist()   <br/>        dfprices_inner["Adj Close Portfolio"]=dfprices_inner[listOfColumns].mul(noOfShares).sum(1)</span><span id="3b91" class="na iu hh nx b fi of oc l od oe">dfreturns ,df_mean_stdev=calc_returns(dfprices_inner,symbols)<br/>        <br/>        S0=np.array(dfprices.tail(1).values.tolist()[0])<br/>        mu=np.array(df_mean_stdev["Mean Log Daily Return"].values.tolist())<br/>        sigma=np.array(df_mean_stdev["StdDev Log Daily Return"].values.tolist())<br/>        <br/>        if SimMethod=="GBM":<br/>            if len(symbols)==1:<br/>                stocks, time = GBMsimulatorUniVar(S0, mu, sigma, T, N)<br/>                prediction=pd.DataFrame(stocks)<br/>                prediction=prediction.T<br/>                prediction.columns=dfprices.columns</span><span id="abf1" class="na iu hh nx b fi of oc l od oe">else:<br/>                Cov=create_covar(dfreturns)<br/>                stocks, time = GBMsimulatorMultiVar(S0, mu, sigma, Cov, T, N)<br/>                prediction=pd.DataFrame(stocks)<br/>                prediction=prediction.T<br/>                prediction.columns=dfprices.columns<br/>     <br/>            IterationReturn,Iteration_Mean_Stdev=calc_returns(prediction,symbols)<br/>            IterationStdDev=Iteration_Mean_Stdev.tail(1).values[0][2]<br/>            IterationMean=Iteration_Mean_Stdev.tail(1).values[0][1]<br/>            <br/>            IterationMeanComponentStocks=Iteration_Mean_Stdev.T.loc["Mean Log Daily Return"][:-1].values.tolist()<br/>            IterationStdDevComponentStocks=Iteration_Mean_Stdev.T.loc["StdDev Log Daily Return"][:-1].values.tolist()<br/>            <br/>            negativereturnsonly=pd.DataFrame(IterationReturn.iloc[:,len(IterationReturn.columns)-1])<br/>            negativereturnsonly=negativereturnsonly[negativereturnsonly['Log Daily Returns Adj Close Portfolio']&lt;0]<br/>            IterationNegativeReturnsStdDev=negativereturnsonly['Log Daily Returns Adj Close Portfolio'].std()<br/>        <br/>        elif SimMethod=="Bootstrap":<br/>            <br/>            prediction=bootstrapforecast(dfreturns,T)<br/>            IterationStdDev=prediction.iloc[:,0].std()<br/>            IterationMean=prediction.iloc[:,0].mean()<br/>            negativereturnsonly=prediction[prediction['Log Daily Returns Adj Close Portfolio']&lt;0].iloc[:,0]<br/>            IterationNegativeReturnsStdDev=negativereturnsonly.std()<br/>        <br/>        # Note to go from LOG returns to Simple returns , I used simple returns =exp(log returns)−1 <br/>        IterationSharpeRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationStdDev)-1),3)<br/>        <br/>        IterationSortinoRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationNegativeReturnsStdDev)-1),3)<br/>        <br/>        X=[portfolioWeightsRandom,IterationStdDev,IterationMean,IterationSharpeRatio,IterationSortinoRatio,\<br/>           IterationStdDevComponentStocks,IterationMeanComponentStocks]<br/>        <br/>        ResultsTable.append(X)<br/>        <br/>        dfprices_inner.drop('Adj Close Portfolio',inplace=True, axis=1)<br/>    <br/>    FinalResultsTable=pd.DataFrame(ResultsTable,columns=["Weights","Std Dev","Mean",\<br/>                                                         "Sharpe Ratio","Sortino Ratio","Components Log Returns Std Dev","Components Log Returns Mean"])<br/> <br/>    historical_dfreturns ,historical_df_mean_stdev=calc_returns(dfprices,symbols)<br/>    <br/>    historical_df_mean_stdev=historical_df_mean_stdev[['Stock','StdDev Log Daily Return','Mean Log Daily Return']]<br/>    historical_df_mean_stdev.columns=['Stock','Std Dev','Mean']<br/>    <br/>    fig, ax = plt.subplots(figsize=(10, 5))<br/>    <br/>    FinalResultsTable.plot.scatter(x="Std Dev",y='Mean',ax=ax)<br/>    historical_df_mean_stdev.plot.scatter(x="Std Dev",y='Mean',c='r',marker='x',ax=ax)</span><span id="7260" class="na iu hh nx b fi of oc l od oe">SharpeStdDev=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Std Dev'].values[0]<br/>    SharpeMean=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Mean'].values[0]<br/>    Sharperoundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Weights'].values[0]]<br/>    Sharpeweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sharpeweightstring.append([symbols[i]+":",Sharperoundedweights[i]])<br/>    SharpeLabel="Optimal Sharpe Ratio"<br/>    SharpeDetail='Optimal Sharpe Ratio: '+str(FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Sharpe Ratio'].values[0])+" with Weights "+str(Sharpeweightstring)</span><span id="de1a" class="na iu hh nx b fi of oc l od oe">SortinoStdDev=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Std Dev'].values[0]<br/>    SortinoMean=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Mean'].values[0]<br/>    Sortinoroundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sortino Ratio'])['Weights'].values[0]]<br/>    Sortinoweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sortinoweightstring.append([symbols[i]+":",Sortinoroundedweights[i]])<br/>    SortinoLabel='Optimal Sortino Ratio'<br/>    SortinoDetail='Optimal Sortino Ratio: '+str(FinalResultsTable.nlargest(1,['Sortino Ratio'])['Sortino Ratio'].values[0])+" with Weights "+str(Sortinoweightstring)<br/>    <br/>    SharpeSortino=pd.DataFrame(zip([SharpeStdDev,SortinoStdDev],[SharpeMean,SortinoMean]),index=['Optimal Sharpe','Optimal Sortino'],columns=['Std Dev','Mean'])<br/>    SharpeSortino.plot.scatter(x="Std Dev",y='Mean',c='g',marker='x',ax=ax)<br/>    <br/>    txt=list(historical_df_mean_stdev['Stock'])+[SharpeLabel,SortinoLabel]<br/>    z=list(historical_df_mean_stdev['Std Dev'])+[SharpeStdDev,SortinoStdDev]<br/>    y=list(historical_df_mean_stdev['Mean'])+[SharpeMean,SortinoMean]</span><span id="8114" class="na iu hh nx b fi of oc l od oe">for i, text in enumerate(txt):<br/>        ax.annotate(text, (z[i], y[i]))<br/>    <br/>    plt.title("Mean vs Std Dev Of P50 Log Returns For "+str(NoOfIterationsMC)+" Different Portfolio Weights Simulated Using "+SimMethod)<br/>    plt.savefig(f'static/{targetfolder}/{imagecounter}_efficientportfolio.png')<br/>    print(SharpeDetail)<br/>    print(SortinoDetail)<br/>    <br/>    FinalResultsTable['Log Returns Std Dev']=FinalResultsTable['Std Dev']<br/>    FinalResultsTable['Log Returns Mean']=FinalResultsTable['Mean']<br/>    FinalResultsTable=FinalResultsTable[['Weights','Log Returns Std Dev','Log Returns Mean','Sharpe Ratio','Sortino Ratio',"Components Log Returns Std Dev","Components Log Returns Mean"]]<br/>     <br/>    return FinalResultsTable, SharpeDetail, SortinoDetail</span></pre><p id="4de3" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">如果你能遵循上面的逻辑，你可能会注意到我<strong class="kl hi"> <em class="lz">犯了一个错误</em></strong>…这是因为对于每个随机的投资组合权重，上面的代码将<strong class="kl hi">只运行一次迭代来预测潜在的未来回报。</strong>最终结果是你得到一个看起来有点像这样的形状:-</p><figure class="mw mx my mz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oh"><img src="../Images/a9142d3b894cc861662a1116deb166e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LGkXPg2h-Z7Bhi028DedkQ.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">对每个投资组合的未来回报仅运行单一预测时的结果</figcaption></figure><p id="801f" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">这创造了一个“圆形椭圆气泡”形状，看起来有点奇怪，因为我根据理论预期了一个“更弯曲”的形状。更重要的是，如果你看看所谓的“最佳”夏普或索蒂诺比率，它是<strong class="kl hi"> <em class="lz">古怪地</em> </strong>建议加大对法拉利股票的投资。这没有意义，因为历史上“最佳”投资组合的权重主要是特斯拉股票。</p><p id="9017" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">然后我意识到，这是因为每组投资组合权重需要多次迭代未来回报，因为每个投资组合的未来回报的单次迭代并不能很好地反映可能的未来回报。因此，“代码的固定版本”如下所示:</p><pre class="mw mx my mz fd nw nx ny nz aw oa bi"><span id="61b1" class="na iu hh nx b fi ob oc l od oe">def EfficientPortfolioFuture(start_date,end_date,symbols,portfolioValue,T,N,NoOfIterationsMC,NoOfIterationsInnerLoop,AnnualRiskFreeRate,SimMethod,imagecounter,targetfolder):<br/>    <br/>    symbolsWPortfolio=symbols+["Portfolio"]</span><span id="cf4b" class="na iu hh nx b fi of oc l od oe">RiskFreeRate=(1+AnnualRiskFreeRate)**(1/252)-1<br/>    #Effective rate for period = (1 + annual rate)**(1 / # of periods) – 1<br/>    <br/>    for symbol in symbols:<br/>        dfprices = data.DataReader(symbols, start=start_date, end=end_date, data_source='yahoo')<br/>        dfprices = dfprices[['Adj Close']]<br/>    dfprices.columns=[' '.join(col).strip() for col in dfprices.columns.values]<br/>    <br/>    priceAtEndDate=[]<br/>    for symbol in symbols:<br/>        priceAtEndDate.append(dfprices[[f'Adj Close {symbol}']][-(1):].values[0][0])<br/>    <br/>    symbolsWPortfolio=symbols+["Portfolio"]<br/>    <br/>    ResultsTable=[]<br/>    <br/>    for i in range(0,NoOfIterationsMC):<br/>        <br/>        dfprices_inner=dfprices<br/>        portfolioWeightsRandom=list(np.random.dirichlet(np.ones(len(symbols)),size=1)[0])<br/>        <br/>        noOfShares=[]<br/>        portfolioValPerSymbol=[x * portfolioValue for x in portfolioWeightsRandom]<br/>        for j in range(0,len(symbols)):<br/>            noOfShares.append(portfolioValPerSymbol[j]/priceAtEndDate[j])<br/>        noOfShares=[round(element, 5) for element in noOfShares]<br/>        listOfColumns=dfprices_inner.columns.tolist()   <br/>        dfprices_inner["Adj Close Portfolio"]=dfprices_inner[listOfColumns].mul(noOfShares).sum(1)</span><span id="b5f1" class="na iu hh nx b fi of oc l od oe">dfreturns ,df_mean_stdev=calc_returns(dfprices_inner,symbols)<br/>        <br/>        S0=np.array(dfprices.tail(1).values.tolist()[0])<br/>        mu=np.array(df_mean_stdev["Mean Log Daily Return"].values.tolist())<br/>        sigma=np.array(df_mean_stdev["StdDev Log Daily Return"].values.tolist())<br/>        <br/>        if SimMethod=="GBM":</span><span id="5607" class="na iu hh nx b fi of oc l od oe">forecastresults=pd.DataFrame()<br/>            percentiles=pd.DataFrame()<br/>            <br/>            for x in range(1,int(NoOfIterationsInnerLoop)):      <br/>                <br/>                Cov=create_covar(dfreturns)<br/>                stocks, time = GBMsimulatorMultiVar(S0, mu, sigma, Cov, T, N)<br/>                prediction=pd.DataFrame(stocks)<br/>                prediction=prediction.T<br/>                prediction.columns=dfprices.columns<br/>                forecastresults=pd.concat([forecastresults,prediction], axis=1, sort=False)<br/>    <br/>            for y in range(0,len(symbolsWPortfolio)):<br/>                percentiles["P50_"+symbolsWPortfolio[y]]=forecastresults.filter(regex=symbolsWPortfolio[y]).quantile(0.5,1) <br/>     <br/>            IterationReturn,Iteration_Mean_Stdev=calc_returns(percentiles,symbols)<br/>            IterationStdDev=Iteration_Mean_Stdev.tail(1).values[0][2]<br/>            IterationMean=Iteration_Mean_Stdev.tail(1).values[0][1]<br/>            IterationMeanComponentStocks=Iteration_Mean_Stdev.T.loc["Mean Log Daily Return"][:-1].values.tolist()<br/>            IterationStdDevComponentStocks=Iteration_Mean_Stdev.T.loc["StdDev Log Daily Return"][:-1].values.tolist()<br/>            <br/>            negativereturnsonly=pd.DataFrame(IterationReturn.iloc[:,len(IterationReturn.columns)-1])<br/>            negativereturnsonly=negativereturnsonly[negativereturnsonly[negativereturnsonly.columns[0]]&lt;0]            <br/>            IterationNegativeReturnsStdDev=negativereturnsonly[negativereturnsonly.columns[0]].std()<br/>                        <br/>        elif SimMethod=="Bootstrap":<br/>            <br/>            forecastresults=pd.DataFrame()<br/>            returnspercentiles=pd.DataFrame()<br/>            <br/>            for x in range(1,int(NoOfIterationsInnerLoop)):  <br/>            <br/>                prediction=bootstrapforecast(dfreturns,T)<br/>                prediction=prediction.add_prefix('Iter_'+str(x)+'_')<br/>                forecastresults=pd.concat([forecastresults,prediction], axis=1, sort=False)<br/>                    <br/>            for y in range(0,len(symbolsWPortfolio)):<br/>                returnspercentiles["P50_"+symbolsWPortfolio[y]]=forecastresults.filter(regex=symbolsWPortfolio[y]).quantile(0.5,1)<br/>            <br/>            IterationMeanComponentStocks=[]<br/>            IterationStdDevComponentStocks=[]<br/>            <br/>            for y in range(0,int(len(returnspercentiles.columns)-1)):<br/>                IterationMeanComponentStocks.append(returnspercentiles[returnspercentiles.columns[y]].mean())<br/>                IterationStdDevComponentStocks.append(returnspercentiles[returnspercentiles.columns[y]].std())<br/>            <br/>            IterationStdDev=returnspercentiles[returnspercentiles.columns[-1]].std()<br/>            IterationMean=returnspercentiles[returnspercentiles.columns[-1]].mean()<br/>            <br/>            negativereturnsonly=returnspercentiles[returnspercentiles[returnspercentiles.columns[-1]]&lt;0]          <br/>            IterationNegativeReturnsStdDev=negativereturnsonly[negativereturnsonly.columns[0]].std()<br/>            <br/>        # Note to go from LOG returns to Simple returns , I used simple returns =exp(log returns)−1 <br/>        IterationSharpeRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationStdDev)-1),3)<br/>        <br/>        IterationSortinoRatio=round(((np.exp(IterationMean)-1)-RiskFreeRate)/(np.exp(IterationNegativeReturnsStdDev)-1),3)<br/>        <br/>        X=[portfolioWeightsRandom,IterationStdDev,IterationMean,IterationSharpeRatio,IterationSortinoRatio,\<br/>           IterationStdDevComponentStocks,IterationMeanComponentStocks]<br/>        <br/>        ResultsTable.append(X)<br/>        <br/>        dfprices_inner.drop('Adj Close Portfolio',inplace=True, axis=1)<br/>    <br/>    FinalResultsTable=pd.DataFrame(ResultsTable,columns=["Weights","Std Dev","Mean",\<br/>                                                         "Sharpe Ratio","Sortino Ratio","Components Log Returns Std Dev","Components Log Returns Mean"])</span><span id="3db5" class="na iu hh nx b fi of oc l od oe">SharpeStdDev=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Std Dev'].values[0]<br/>    SharpeMean=FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Mean'].values[0]<br/>    Sharperoundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Weights'].values[0]]<br/>    Sharpeweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sharpeweightstring.append([symbols[i]+":",Sharperoundedweights[i]])<br/>    SharpeLabel="Optimal Sharpe Ratio"<br/>    SharpeDetail='Optimal Sharpe Ratio: '+str(FinalResultsTable.nlargest(1,['Sharpe Ratio'])['Sharpe Ratio'].values[0])+" with Weights "+str(Sharpeweightstring)<br/>    <br/>    SortinoStdDev=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Std Dev'].values[0]<br/>    SortinoMean=FinalResultsTable.nlargest(1,['Sortino Ratio'])['Mean'].values[0]<br/>    Sortinoroundedweights=[round(num, 4) for num in FinalResultsTable.nlargest(1,['Sortino Ratio'])['Weights'].values[0]]<br/>    Sortinoweightstring=[]<br/>    for i in range(0,len(symbols)):<br/>        Sortinoweightstring.append([symbols[i]+":",Sortinoroundedweights[i]])<br/>    SortinoLabel='Optimal Sortino Ratio'<br/>    SortinoDetail='Optimal Sortino Ratio: '+str(FinalResultsTable.nlargest(1,['Sortino Ratio'])['Sortino Ratio'].values[0])+" with Weights "+str(Sortinoweightstring)<br/>       <br/>    SharpeSortino=pd.DataFrame(zip([SharpeStdDev,SortinoStdDev],[SharpeMean,SortinoMean]),index=['Optimal Sharpe','Optimal Sortino'],columns=['Std Dev','Mean'])<br/>  <br/>    SharpeRatio_Best=pd.DataFrame(FinalResultsTable.nlargest(1,['Sharpe Ratio'])["Components Log Returns Mean"].values[0],index=symbols,columns=["Mean Log Daily Return"])<br/>    SharpeRatio_Best["StdDev Log Daily Return"]=FinalResultsTable.nlargest(1,['Sharpe Ratio'])["Components Log Returns Std Dev"].values[0]<br/>    SharpeRatio_Best<br/>    <br/>    fig, ax = plt.subplots(figsize=(10, 5))<br/>    <br/>    SharpeSortino.plot.scatter(x="Std Dev",y='Mean',c='g',marker='x',ax=ax)<br/>  <br/>    FinalResultsTable.plot.scatter(x="Std Dev",y='Mean',ax=ax)<br/>    SharpeRatio_Best.plot.scatter(x="StdDev Log Daily Return",y='Mean Log Daily Return',c='r',marker='x',ax=ax)</span><span id="6943" class="na iu hh nx b fi of oc l od oe">txt=list(SharpeRatio_Best.index)+[SharpeLabel,SortinoLabel]<br/>    z=list(SharpeRatio_Best['StdDev Log Daily Return'])+[SharpeStdDev,SortinoStdDev]<br/>    y=list(SharpeRatio_Best['Mean Log Daily Return'])+[SharpeMean,SortinoMean]</span><span id="c48c" class="na iu hh nx b fi of oc l od oe">for i, text in enumerate(txt):<br/>        ax.annotate(text, (z[i], y[i]))</span><span id="4101" class="na iu hh nx b fi of oc l od oe">plt.title("Mean vs Std Dev Of P50 Log Returns For "+str(NoOfIterationsMC)+" Different Portfolio Weights Simulated Using "+SimMethod+" over "+str(NoOfIterationsInnerLoop)+" Iters")<br/>    plt.savefig(f'static/{targetfolder}/{imagecounter}_efficientportfolio.png')<br/>    print(SharpeDetail)<br/>    print(SortinoDetail)<br/>    <br/>    FinalResultsTable['Log Returns Std Dev']=FinalResultsTable['Std Dev']<br/>    FinalResultsTable['Log Returns Mean']=FinalResultsTable['Mean']<br/>    FinalResultsTable=FinalResultsTable[['Weights','Log Returns Std Dev','Log Returns Mean','Sharpe Ratio','Sortino Ratio',"Components Log Returns Std Dev","Components Log Returns Mean"]]<br/>    <br/>    return FinalResultsTable, SharpeDetail, SortinoDetail</span></pre><p id="ec86" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">在纠正代码并对1000个不同投资组合权重迭代中的每一个运行100次未来回报迭代，然后提取每个投资组合的<strong class="kl hi">对应P50回报后，均值-标准差图开始看起来更像理论形状，并且“最佳”投资组合符合我们的直觉预期，即更多投资于特斯拉(假设其在2018-2020年的良好表现持续到2021年)</strong></p><figure class="mw mx my mz fd ii er es paragraph-image"><div role="button" tabindex="0" class="ij ik di il bf im"><div class="er es oi"><img src="../Images/733fdf9380fc5853659faa39deef84c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jhu1mDFGF9XM3mY-MMmwhg.png"/></div></div><figcaption class="ip iq et er es ir is bd b be z dx translated">运行100次迭代以生成每个投资组合未来回报的P50预测时的结果</figcaption></figure><p id="d960" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">老实说，我自己仍在尝试这种方法，但一个关键的收获是，历史“最佳投资组合”并不总是与未来预测的“最佳投资组合”完全一致。根据上面的例子，它建议我抛售一些TSLA股票，买入更多的赛车股票(这很令人惊讶，因为在历史“最佳夏普比率”投资组合中，权重最大的股票是通用汽车)</p><p id="c07c" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">但是请注意，由于结果在本质上是随机的，答案每次都会有一点变化，这也取决于你选择预测未来多长时间的回报。</p><h1 id="c94d" class="it iu hh bd iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq bi translated">结论</h1><p id="b82e" class="pw-post-body-paragraph kj kk hh kl b km mc ko kp kq md ks kt ku mr kw kx ky ms la lb lc mt le lf kb ha bi translated">我希望你喜欢这篇文章。如果你想自己尝试一下，我已经将代码更新到了Web应用程序中，但请注意，这是一个计算量很大的过程——运行1000次迭代(针对不同的投资组合权重)X 100次迭代(针对未来回报)，大约需要25分钟，这只是P50的值。</p><p id="c0df" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated"><em class="lz">(因此，在web应用程序中，为了避免服务器超时错误，我对其进行了“硬编码”,以便用户只能为不同的投资组合权重定义迭代次数，但每个投资组合都被“硬编码”为仅运行10次迭代来生成P50未来回报——我建议您使用我在Github链接</em> 中设置的 <a class="ae lg" href="https://github.com/ZhijingEu/StockSimulatorFlaskApp/blob/master/MonteCarloEfficientFrontier.ipynb" rel="noopener ugc nofollow" target="_blank"> <em class="lz">单独的ipynb笔记本文件)</em></a></p><p id="0a3e" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">最后，值得一提的是，在概念层面上，这种使用MPT来估计最佳投资组合权重的方法有其局限性。下面这篇文章值得一读，但我的重点是:-</p><div class="lh li ez fb lj lk"><a href="https://www.institutionalinvestor.com/article/b150q9c8vhc1r0/efficient-frontier-models-dangerous-toys" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">高效前沿模型:危险的玩具</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">有一种误解，认为分配投资组合只是运行投资组合优化软件…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.institutionalinvestor.com</p></div></div><div class="lt l"><div class="oj l lv lw lx lt ly in lk"/></div></div></a></div><ul class=""><li id="c81f" class="ma mb hh kl b km kn kq kr ku nq ky nr lc ns kb mh mi mj mk bi translated">有效前沿模型假设股票收益可以用正态分布来精确表示，在正态分布中，收益和波动性通常是不变的(实际上两者可能都不正确)</li><li id="47fd" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated">有效前沿模型估计对输入的微小变化高度敏感，因此预期未来回报的微小变化(由于不同的历史数据范围或预测方法，甚至只是随机噪声)会导致最优分配的巨大变化</li><li id="526d" class="ma mb hh kl b km ml kq mm ku mn ky mo lc mp kb mh mi mj mk bi translated">在有效前沿模型中,“最佳”投资组合仅根据狭义的市场风险来判断，市场风险由回报的波动性来表示。但是，可能存在波动性(如期限风险和违约风险)和其他非风险因素(如投资组合中各组成公司的市值规模)未能捕捉到的风险因素</li></ul><p id="9110" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">因此，如果你打算用它来做你的投资计划——考虑你自己的预先警告！</p><p id="7d65" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">如果你觉得这很有趣，请访问这个网站，在下面给我留言，让我知道你想让我讨论什么话题！</p><div class="lh li ez fb lj lk"><a href="https://www.stonksforecast.online/" rel="noopener  ugc nofollow" target="_blank"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">z的股票模拟器</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">图片来源:KnowYourMeme.com嗨！我是Z，这是一个简单的股票价格预测网络应用程序，我是为了好玩而开发的…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">www.stonksforecast.online</p></div></div><div class="lt l"><div class="ok l lv lw lx lt ly in lk"/></div></div></a></div><p id="3e4b" class="pw-post-body-paragraph kj kk hh kl b km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf kb ha bi translated">接下来——上面的文章介绍了如何优化投资组合中一组给定股票的权重，但首先你该如何选择将哪些股票放入投资组合呢？如果你想知道怎么做，请点击我的下一篇文章的链接，这篇文章准确地回答了这个问题:</p><div class="lh li ez fb lj lk"><a rel="noopener follow" target="_blank" href="/analytics-vidhya/building-a-simple-stock-ranking-screening-tool-7bc10049e85"><div class="ll ab dw"><div class="lm ab ln cl cj lo"><h2 class="bd hi fi z dy lp ea eb lq ed ef hg bi translated">建立一个简单的股票排名和筛选工具</h2><div class="lr l"><h3 class="bd b fi z dy lp ea eb lq ed ef dx translated">配料:一杯要素投资原则；从雅虎网上新收集的一些股票指数…</h3></div><div class="ls l"><p class="bd b fp z dy lp ea eb lq ed ef dx translated">medium.com</p></div></div><div class="lt l"><div class="ol l lv lw lx lt ly in lk"/></div></div></a></div></div></div>    
</body>
</html>