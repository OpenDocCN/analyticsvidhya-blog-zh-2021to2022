<html>
<head>
<title>The new modern Workload on vSphere</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">vSphere上新的现代工作负载</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/the-new-modern-workload-on-vsphere-fed63d57ff8d?source=collection_archive---------5-----------------------#2021-05-05">https://medium.com/analytics-vidhya/the-new-modern-workload-on-vsphere-fed63d57ff8d?source=collection_archive---------5-----------------------#2021-05-05</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es im"><img src="../Images/1a84f891807af2e4679ae668b7713903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nCpSijuqy0Fw9tQsy1RPSg.jpeg"/></div></div></figure><h1 id="8443" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">介绍</h1><p id="b909" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">vSphere 7 with Tanzu正在改变人们实现内部应用交付现代化的方式。随着Kubernetes在平台中的本机集成，在vSphere环境中提供新应用程序堆栈的大门已经打开。您只能在vSphere平台内部署虚拟机的日子已经一去不复返了。随着Tanzu的集成，您现在可以在虚拟机旁边本地部署新对象，如<strong class="jy hj"> pods </strong>、<strong class="jy hj">负载平衡器</strong>、<strong class="jy hj"> Kubernetes集群</strong>。随着期待已久的虚拟机操作员功能(7.0u2a版)的发布，DevOps角色甚至可以利用标准Kubernetes流程和CLI来部署虚拟机和pod。在本文中，我将通过一个简单的例子来讨论DevOps角色如何利用他们选择的Kubernetes工具来部署由Kubernetes集群、虚拟机、pod、注册表和负载平衡器组成的应用程序堆栈。</p><h1 id="f239" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">新的工作负载概念</h1><p id="7b1b" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">如前所述，几年前，开发人员要求为应用程序部署调配虚拟机。vSphere管理员部署虚拟机，然后将控制权移交给开发人员，开发人员在这些虚拟机上部署应用程序。整个过程需要几天到几周的时间，基础设施的每一层都被当成宠物。这导致了虚拟机部署的自动化。</p><p id="8fb2" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">随着Kubernetes的引入，运营团队负责建立和管理Kubernetes集群。DevOps角色(在某些情况下，同一组人)将在这些Kubernetes集群上部署容器化的应用程序。在大多数情况下，通过容器化，应用程序已经变成了牛，但不幸的是，底层基础设施仍然被当作宠物对待。这带来了自身的一系列挑战。</p><p id="e7a7" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">随着流程的成熟，运营团队也开始寻找将Kubernetes基础设施视为牲畜的选择。Cluster API是帮助减轻日常Kubernetes集群生命周期管理负担的开创性项目之一。现在，DevOps角色可以创建和管理他们的Kubernetes基础设施，就像管理他们的应用程序部署一样。</p><p id="a843" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">当我们开始应用程序现代化旅程的下一阶段时，我们发现下一组应用程序相当棘手或复杂。它们有许多交互点，单一的有状态VM交互导致容器化极其困难。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es kz"><img src="../Images/5d55f791e8553614a5de3788931f71ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:806/format:webp/1*EgrdwPC8venRLw5y07RvjQ.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">挂钩多个基础设施组件的示例应用程序。</figcaption></figure><p id="0cab" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">我们如何使这样的应用程序现代化？我们如何将整个设置视为牲口，并拥有一个声明性的YAML来部署和维护所述应用程序的期望状态？</p><h1 id="74b7" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">vSphere携手Tanzu助您一臂之力</h1><p id="f3b2" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">vSphere的现有客户和新客户可以从现已本机集成到vCenter中的新功能中受益匪浅。网上有许多文章总结和详细介绍了vSphere中Kubernetes、Cluster API、Harbor和其他CNCF技术的本机集成如何为客户带来价值。只需点击一个按钮(嗯，可能是一个简短的向导)，vSphere管理员现在就可以将现有的vSphere集群转换为理解Kubernetes语言的<strong class="jy hj"> Supervisor集群</strong>。这个主管集群可以直接交付大量云原生服务，供DevOps角色使用。其中一些服务是—</p><ul class=""><li id="548f" class="le lf hi jy b jz ku kd kv kh lg kl lh kp li kt lj lk ll lm bi translated">集装箱注册使用<a class="ae ln" href="https://goharbor.io/" rel="noopener ugc nofollow" target="_blank">港</a></li><li id="f3cf" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">使用<a class="ae ln" href="https://cluster-api.sigs.k8s.io/introduction.html" rel="noopener ugc nofollow" target="_blank">集群AP </a> I的Kubernetes集群LCM</li><li id="f7a2" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">负载平衡器服务</li><li id="600d" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">认证服务</li><li id="70a2" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">能够在ESXi中本地运行容器</li><li id="ffe0" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">命名空间和资源管理</li><li id="4cf9" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">使用<a class="ae ln" href="https://github.com/vmware-tanzu/vm-operator-api" rel="noopener ugc nofollow" target="_blank"> VMOperator </a>的虚拟机LCM</li><li id="5df6" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">还会有更多。</li></ul><p id="a933" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">现在让我们看看DevOps角色如何利用这些服务和特性，使用简单的声明性配置文件来部署复杂的应用程序。</p><h1 id="b4c8" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">方案</h1><p id="097c" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">我们将使用一个简单的例子，如果对它的部署标准施加多种限制，这个例子很快就会变得复杂。</p><p id="cdc6" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">让我们将标准的<a class="ae ln" href="https://kubernetes.io/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/" rel="noopener ugc nofollow" target="_blank"> Kubernetes WordPress部署</a>用于我们的示例应用程序。在本例中，MySQL pod是使用持久卷部署的(从Dockerhub中的映像),并通过服务公开。部署了一个WordPress pod(使用Dockerhub中的映像)来访问MySQL DB服务。WordPress应用程序通过用户可以访问的端口80上的负载平衡器服务公开。</p><p id="d8b7" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">让我们假设DevOps团队受到一些常见的限制。</p><ul class=""><li id="0ec0" class="le lf hi jy b jz ku kd kv kh lg kl lh kp li kt lj lk ll lm bi translated">vSphere团队不希望DevOps团队超出共享基础架构环境中的资源配额。</li><li id="8cbc" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">DevOps团队需要安全地管理Kubernetes环境的LCM。</li><li id="39b4" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">由于安全限制，用户不允许从Dockerhub下载图像。</li><li id="7c57" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">MySQL数据库非常大，并且/或者需要大量的计算资源。</li><li id="50b2" class="le lf hi jy b jz lo kd lp kh lq kl lr kp ls kt lj lk ll lm bi translated">由于这些或其他一些安全限制，容器化MySQL数据库可能不是一个选项。</li></ul><p id="c387" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">这些是您在任何IT组织中都会遇到的一些常规限制和要求，它们会很快使应用程序的架构模式变得复杂。</p><p id="f4d2" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">现在，DevOps团队负责部署他们的Kubernetes集群。他们需要提供一个内部容器注册表。他们的数据库需要驻留在虚拟机上，虚拟机的生命周期需要得到安全管理。所有这些组件都需要安全地驻留在它们的边界内，而不超过分配的配额。所有这些能不能用简单的YAML文件来管理，让团队以GitOps的方式操作？答案是肯定的。</p><h1 id="5694" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">解决办法</h1><h2 id="40d9" class="lt iz hi bd ja lu lv lw je lx ly lz ji kh ma mb jm kl mc md jq kp me mf ju mg bi translated">平台设置</h2><p id="7d7a" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">旅程从vSphere admin在vSphere 7 U2a或更高版本的环境中启用工作负载管理开始。这将启用我们之前在<strong class="jy hj">集群</strong>上讨论过的所有特性。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es mh"><img src="../Images/e86950c9e2034bbc0be38d8ecb814acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*O-UUpa9zCCGSW5cke4YiUg.png"/></div></figure><p id="5b72" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">vSphere管理员还会创建所需的内容库，以便开发运维用户可以在其命名空间内使用虚拟机映像。它们的内容创建者通过订阅的内容库提供这些映像，例如，Vmware为<a class="ae ln" href="https://wp-content.vmware.com/v2/latest/lib.json" rel="noopener ugc nofollow" target="_blank"> Tanzu Kubernetes集群映像</a>和<a class="ae ln" href="https://marketplace.cloud.vmware.com/" rel="noopener ugc nofollow" target="_blank">虚拟机映像</a>提供映像。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mi"><img src="../Images/903ab86e5c8fa82231f65bbe1445aa5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dc7GFqqvyGvX_EWcdy3BUw.png"/></div></div></figure><p id="28d9" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">接下来，vSphere admin在Supervisor集群上启用Harbor registry服务。如果您使用NSX作为网络堆栈，则此功能可用。(对于不基于NSX的网络堆栈，可以使用虚拟机操作员启用类似的解决方案)。如下图所示，此过程在ESXi服务器上安装了几个单元，并配置了可供终端用户使用的Harbor端点。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mj"><img src="../Images/e345fb1d3d31df92db171deb2a64a580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3wSpbouMTh4tWOgQAS0DQ.png"/></div></div></figure><p id="144f" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">vSphere管理员还可以使用kubectl CLI查看这些对象，因为这些只是驻留在Supervisor集群上的Kubernetes对象。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="d9f3" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl vsphere login --server wcp.navlab.io --vsphere-username administrator@vsphere.local --insecure-skip-tls-verify</span><span id="845c" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl get svc -n vmware-system-registry-756328614                              <br/>NAME                                 TYPE           CLUSTER-IP    EXTERNAL-IP      PORT(S)             AGE<br/>harbor-756328614                     LoadBalancer   10.96.0.109   192.168.10.163   443:31012/TCP       11m<br/>harbor-756328614-harbor-core         ClusterIP      10.96.0.202   &lt;none&gt;           80/TCP              10m<br/>...</span><span id="59c2" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl get pods -n vmware-system-registry-756328614 -o wide                     <br/>NAME                                                 READY   STATUS    RESTARTS   AGE   IP            NODE               NOMINATED NODE   READINESS GATES<br/>harbor-756328614-harbor-core-74dc84785-jhw54         1/1     Running   0          16m   10.244.0.24   watson.navlab.io   &lt;none&gt;           &lt;none&gt;<br/>harbor-756328614-harbor-database-0                   1/1     Running   0          16m   10.244.0.18   watson.navlab.io   &lt;none&gt;           &lt;none&gt;</span></pre><p id="41c8" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">最后，vSphere admin在Supervisor集群上启用自助命名空间。通过这个选项，管理员可以对每个DevOps用户可以在Supervisor集群上创建和使用的未来名称空间的资源和访问进行模板化。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mu"><img src="../Images/48ed54641cb0d89b3bb56a4420e4f24c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xT9qV0W0Jm32HZXhcm2qCg.png"/></div></div></figure><p id="885f" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">这就是需要做的所有前期准备。现在，基础架构被移交给DevOps团队，以便在此环境中部署他们的应用程序。</p></div><div class="ab cl if ig gp ih" role="separator"><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik il"/><span class="ii bw bk ij ik"/></div><div class="hb hc hd he hf"><h2 id="f093" class="lt iz hi bd ja lu lv lw je lx ly lz ji kh ma mb jm kl mc md jq kp me mf ju mg bi translated">应用程序部署</h2><p id="22d4" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">DevOps用户现在可以使用登录到Supervisor集群，并开始与它进行交互，以使用Kubernetes API/CLI创建对象。第一步是创建应用程序将驻留的名称空间。创建的命名空间继承了上一步中在模板内实施的所有配额、限制和RBAC。如果设置了integrated Harbor registry(见上文),那么名称空间的创建会自动触发在Harbor环境中创建具有关联RBAC的项目。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="2182" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl vsphere login --server wcp.navlab.io --vsphere-username nverma@vsphere.local --insecure-skip-tls-verify</span><span id="c237" class="lt iz hi ml b fi mt mq l mr ms">$ cat ns.yaml</span><span id="ff95" class="lt iz hi ml b fi mt mq l mr ms">---<br/>apiVersion: v1<br/>kind: Namespace<br/>metadata:<br/>  name: demo1</span><span id="551b" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl create -f ns.yaml<br/>namespace/demo1 created</span></pre><p id="85c3" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">接下来的两个步骤是手动的(希望由vSphere产品团队自动完成)。新创建的名称空间需要绑定一组VMclasses和内容库。这目前可以通过中央界面实现。</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mv"><img src="../Images/3bd4223226802f8270050c93011f7684.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lu7Lkxdhxe0AShVWNgmv6A.png"/></div></div></figure><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="4653" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl get virtualmachineclassbinding -n demo1                                  <br/>NAME                 VIRTUALMACHINECLASS   AGE<br/>best-effort-large    best-effort-large     4m56s<br/>best-effort-medium   best-effort-medium    4m56s<br/>best-effort-small    best-effort-small     4m56s<br/>best-effort-xsmall   best-effort-xsmall    4m55s</span><span id="e736" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl get contentsourcebindings -n demo1                                       <br/>NAME                                   CONTENTSOURCE<br/>9c54ca6c-fdf3-4ed8-b628-1a622641ebb7   9c54ca6c-fdf3-4ed8-b628-1a622641ebb7<br/>9f4c1210-2c9b-46d2-81ad-f8f5139e4e74   9f4c1210-2c9b-46d2-81ad-f8f5139e4e74</span></pre><p id="a5da" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">下一步是部署将在CentOS虚拟机上运行的MySQL数据库(在撰写本文时，VMware为使用VMOperator的虚拟机部署提供了基于CentOS的OVA。这是通过云市场实现的。在他们的网站上可以找到关于如何通过内容库消费市场图像的文档。第一步是构建一个cloud-init.yaml文件。关于如何构建cloud-init文件的文档可以参考<a class="ae ln" href="https://cloudinit.readthedocs.io/en/latest/" rel="noopener ugc nofollow" target="_blank">这里的</a>。MySQL自动化的一个示例文件可能与此类似—</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="70ba" class="lt iz hi ml b fi mp mq l mr ms">#cloud-config<br/>chpasswd:<br/>    list: |<br/>      centos:password<br/>    expire: false<br/>groups:<br/>  - docker<br/>users:<br/>  - default<br/>  - name: centos<br/>    ssh-authorized-keys:<br/>      - ssh-rsa AAAAB3Nz...m50YwPyUFoUAUOXaqM6J8sXJd1THHFXBd/9jmnI60abFj50hqNuk62cN9kHW55HSO/L/Llz/PZyuk0wTbfqzc8BRA3Z0YiLo+I/LIc0= nverma@bastion0<br/>    sudo: ALL=(ALL) NOPASSWD:ALL<br/>    groups: sudo, docker<br/>    shell: /bin/bash<br/># Enable password based authentication if needed<br/># ssh_pwauth: True<br/>network:<br/>  version: 2<br/>  ethernets:<br/>      ens192:<br/>          dhcp4: true<br/>package_update: true<br/>packages:<br/>  - mysql-server<br/>  - net-tools<br/>runcmd:<br/>  - systemctl enable mysqld<br/>  - systemctl start mysqld<br/>  - sudo mysql -e "CREATE DATABASE wordpress;"<br/>  - sudo mysql -e "CREATE USER 'wordpress_user'@'%' IDENTIFIED BY 'password';"<br/>  - sudo mysql -e "GRANT ALL ON wordpress.* TO 'wordpress_user'@'%'"<br/>  - sudo mysql -e "FLUSH PRIVILEGES;"<br/>  - sed -i '$abind-address=0.0.0.0' /etc/my.cnf.d/mysql-server.cnf<br/>  - systemctl restart mysqld<br/>  - firewall-offline-cmd --add-port=3306/tcp<br/>  - firewall-cmd --reload</span></pre><p id="71b8" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">base64编码的cloud-init.yaml值[ <em class="mw">猫cloud-init . YAML | base64-w0；echo </em>文件被添加到虚拟机部署配置文件中。VMware网站上提供了有关如何构建规范文件的详细信息。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="6d11" class="lt iz hi ml b fi mp mq l mr ms"># vm.yml<br/>---<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: mysql-pvc<br/>  namespace: demo1<br/>spec:<br/>  accessModes:<br/>  - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 4Gi<br/>  storageClassName: nav-gold-policy<br/>  volumeMode: Filesystem<br/>---<br/>apiVersion: vmoperator.vmware.com/v1alpha1<br/>kind: VirtualMachine<br/>metadata:<br/>  labels:<br/>    vm-selector: mysql-centosvm<br/>  name: mysql-centosvm<br/>  namespace: demo1<br/>spec:<br/>  imageName: centos-stream-8-vmservice-v1alpha1-1619529007339<br/>  className: best-effort-small<br/>  powerState: poweredOn<br/>  storageClass: nav-gold-policy<br/>  networkInterfaces:<br/>  - networkType: nsx-t<br/>    networkName: ""<br/>  volumes:<br/>  - name: my-centos-vol<br/>    persistentVolumeClaim:<br/>      claimName: mysql-pvc<br/>  readinessProbe:<br/>    tcpSocket:<br/>      port: 22<br/>  vmMetadata:<br/>    configMapName: centos-cloudinit<br/>    transport: OvfEnv<br/>---<br/>apiVersion: v1<br/>kind: ConfigMap<br/>metadata:<br/>    name: centos-cloudinit<br/>    namespace: demo1<br/>data:<br/>  user-data: [insert your base64 encoded cloud-init.yaml value here]  <br/>  hostname: centos-mysql<br/>---<br/>apiVersion: vmoperator.vmware.com/v1alpha1<br/>kind: VirtualMachineService<br/>metadata:<br/>  name: mysql-vmservices<br/>spec:<br/>  ports:<br/>  - name: ssh<br/>    port: 22<br/>    protocol: TCP<br/>    targetPort: 22<br/>  - name: mwsql<br/>    port: 3306<br/>    protocol: TCP<br/>    targetPort: 3306<br/>  selector:<br/>    vm-selector: mysql-centosvm<br/>  type: LoadBalancer</span></pre><p id="a63c" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">MySQL VM及其相关组件已经部署。在虚拟机可以使用之前，部署、启动和执行云初始化流程大约需要3到4分钟。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="c854" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl apply -f vm.yml -n demo1                                               <br/>persistentvolumeclaim/mysql-pvc created<br/>virtualmachine.vmoperator.vmware.com/mysql-centosvm created<br/>configmap/centos-cloudinit created<br/>virtualmachineservice.vmoperator.vmware.com/mysql-vmservices created</span><span id="4037" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl get svc -n demo1                                                         NAME               TYPE           CLUSTER-IP    EXTERNAL-IP      PORT(S)                       AGE<br/>mysql-vmservices   LoadBalancer   10.96.0.147   192.168.10.162   22:31887/TCP,3306:30863/TCP   14m</span></pre><p id="e300" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">验证— <br/>要验证MySQL VM是否已成功创建并可访问，您可以从其RSA密钥在cloud-init中共享的主机进行ssh。yaml。登录虚拟机，验证MySQL是否成功监听端口3306。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="eb76" class="lt iz hi ml b fi mp mq l mr ms">$ ssh centos@192.168.10.162                                                                          </span><span id="d49a" class="lt iz hi ml b fi mt mq l mr ms">[centos@centos-mysql ~]$ netstat -an<br/>Active Internet connections (servers and established)<br/>Proto Recv-Q Send-Q Local Address           Foreign Address         State<br/>tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN<br/>tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN<br/>...</span></pre><p id="e039" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">厉害！！现在我们需要部署WordPress应用程序。在此之前，我们需要创建一个Kubernetes集群。使用在管理集群上运行的Cluster-API，这也是一个简单的操作。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="c2e9" class="lt iz hi ml b fi mp mq l mr ms"># cluster.yaml<br/>---<br/>apiVersion: run.tanzu.vmware.com/v1alpha1<br/>kind: TanzuKubernetesCluster<br/>metadata:<br/>  name: workload-vsphere-tkg1<br/>  namespace: demo1<br/>spec:<br/>  distribution:<br/>    version: v1.18.15<br/>  topology:<br/>    controlPlane:<br/>      count: 1<br/>      class: best-effort-medium<br/>      storageClass: nav-gold-policy<br/>      volumes:<br/>        - name: etcd<br/>          mountPath: /var/lib/etcd<br/>          capacity:<br/>            storage: 4Gi<br/>    workers:<br/>      count: 2<br/>      class: best-effort-medium<br/>      storageClass: nav-gold-policy<br/>      volumes:<br/>        - name: containerd<br/>          mountPath: /var/lib/containerd<br/>          capacity:<br/>            storage: 30Gi<br/>  settings:<br/>    network:<br/>      services:<br/>        cidrBlocks: ["198.51.100.0/24"]<br/>      pods:<br/>        cidrBlocks: ["192.0.2.0/22"]<br/>    storage:<br/>      classes: ["nav-gold-policy"]<br/>      defaultClass: nav-gold-policy</span></pre><p id="933e" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">使用上述文件创建集群。根据请求的节点数量，完成群集创建可能需要5-10分钟。出于自动化的目的，您可以观察Tanzu Kubernetes集群(tkc)对象的状态，以验证Kubernetes集群是否启动并准备好使用。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="bf65" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl apply -f cluster1.yaml -n demo1                                          tanzukubernetescluster.run.tanzu.vmware.com/workload-vsphere-tkg1 created</span><span id="778f" class="lt iz hi ml b fi mt mq l mr ms">$kubectl get tkc -n demo1                                                                                                 <br/>NAME                    CONTROL PLANE   WORKER   DISTRIBUTION                      AGE   PHASE     TKR COMPATIBLE   UPDATES AVAILABLE<br/>workload-vsphere-tkg1   1               2        v1.18.15+vmware.1-tkg.1.600e412   13h   running   True             [1.19.7+vmware.1-tkg.1.fc82c41]</span></pre><p id="cbef" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">一旦集群准备好了，我们现在准备将WordPress应用程序部署到集群中。如先决条件中所述，我们不能直接从Dockerhub中提取WordPress图片。我们需要将映像托管在私有Harbor注册表中，该注册表设置为直接在ESXI服务器上运行的vSphere pods(见上文)。从一个可以访问互联网的跳转主机上，下载WordPress图片，用Harbor注册表名称标记它，然后按照下面的示例命令将它上传到注册表</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="a783" class="lt iz hi ml b fi mp mq l mr ms">$ docker login <a class="ae ln" href="https://192.168.10.163" rel="noopener ugc nofollow" target="_blank">https://192.168.10.163</a>                                   Username: nverma@vsphere.local<br/>Password:<br/>WARNING! Your password will be stored unencrypted in /home/nverma/.docker/config.json.<br/>Configure a credential helper to remove this warning. See<br/><a class="ae ln" href="https://docs.docker.com/engine/reference/commandline/login/#credentials-store" rel="noopener ugc nofollow" target="_blank">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</a></span><span id="8318" class="lt iz hi ml b fi mt mq l mr ms">Login Succeeded</span><span id="8ff5" class="lt iz hi ml b fi mt mq l mr ms">$ docker pull wordpress:5.7-apache                                              5.7-apache: Pulling from library/wordpress<br/>f7ec5a41d630: Pull complete<br/>...<br/>Status: Downloaded newer image for wordpress:5.7-apache<br/>docker.io/library/wordpress:5.7-apache</span><span id="1fc2" class="lt iz hi ml b fi mt mq l mr ms">$ docker images<br/>docker images                                                             REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE<br/>wordpress                         5.7-apache          7fda6c241024        4 days ago          551MB<br/>...</span><span id="5031" class="lt iz hi ml b fi mt mq l mr ms">$ docker tag 7fda6c241024 192.168.10.163/demo1/wordpress:5.7-apache<br/># Note the IP address of the Harbor registry is the same as the one in the screenshot above.<br/># A project called demo1 was automatically created when the namespace was deployed. This is the project where we will be uploading the image</span><span id="47f0" class="lt iz hi ml b fi mt mq l mr ms">$ docker push 192.168.10.163/demo1/wordpress                                    <br/>The push refers to repository [192.168.10.163/demo1/wordpress]<br/>623e5ea375d9: Pushed<br/>...<br/>5.7-apache: digest: sha256:ff25d3a299dc7778cdc51793f899f4a5a745cc78a00632fb466f59d96cbf83b5 size: 4709</span></pre><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es mx"><img src="../Images/29c8f01c030ee295793dae5a50be7296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*USSO9ES0N7n5VxfZm1vQrw.png"/></div></div><figcaption class="la lb et er es lc ld bd b be z dx translated">显示Wordpress上传图片的港口界面。</figcaption></figure><p id="292b" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">既然图像已经上传到本地Harbor存储库，我们可以使用标准的Kubernetes方法来部署WordPress应用程序。首先，我们登录到新部署的Kubernetes集群，并修改Kubeconfig活动上下文。还创建了一个包含私有注册中心凭证的秘密对象。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="c2aa" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl vsphere login --server wcp.navlab.io --vsphere-username nverma@vsphere.local --insecure-skip-tls-verify --tanzu-kubernetes-cluster-name workload-vsphere-tkg1 --tanzu-kubernetes-cluster-namespace demo1</span><span id="9ae9" class="lt iz hi ml b fi mt mq l mr ms">...</span><span id="206e" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl config use-context workload-vsphere-tkg1<br/>Switched to context "workload-vsphere-tkg1".</span><span id="49de" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl create secret docker-registry regcred --docker-server=192.168.10.163 --docker-username=nverma@vsphere.local --docker-password="my vsphere.local password" --docker-email=nverma@vsphere.local</span></pre><p id="377d" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">如果这是第一次连接到TKC，您可能希望根据您的要求放宽pod安全策略。这在Vmware的网站上有记录。下面显示了DevOps将用来部署WordPress的示例YAML(引用自Kubernetes文档，并根据当前需求进行了修改)。该应用程序通过端口80上的服务类型负载平衡器公开。请注意MySQL服务(在上一步中运行在虚拟机上)是如何被MYSQLDB_SERVICE_HOST环境变量引用的。MYSQLDB服务被配置为无选择器服务，以直接访问前面步骤中公开的虚拟机的负载平衡器服务。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="aa3c" class="lt iz hi ml b fi mp mq l mr ms"># wordpress.yaml<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: wordpress<br/>  labels:<br/>    app: wordpress<br/>spec:<br/>  ports:<br/>    - port: 80<br/>  selector:<br/>    app: wordpress<br/>    tier: frontend<br/>  type: LoadBalancer<br/>---<br/>apiVersion: v1<br/>kind: PersistentVolumeClaim<br/>metadata:<br/>  name: wp-pv-claim<br/>  labels:<br/>    app: wordpress<br/>spec:<br/>  accessModes:<br/>    - ReadWriteOnce<br/>  resources:<br/>    requests:<br/>      storage: 20Gi<br/>---<br/>apiVersion: apps/v1<br/>kind: Deployment<br/>metadata:<br/>  name: wordpress<br/>  labels:<br/>    app: wordpress<br/>spec:<br/>  selector:<br/>    matchLabels:<br/>      app: wordpress<br/>      tier: frontend<br/>  strategy:<br/>    type: Recreate<br/>  template:<br/>    metadata:<br/>      labels:<br/>        app: wordpress<br/>        tier: frontend<br/>    spec:<br/>      containers:<br/>      - image: 192.168.10.163/demo1/wordpress:5.7-apache<br/>        name: wordpress<br/>        env:<br/>        - name: WORDPRESS_DB_HOST<br/>          value: "$(MYSQLDB_SERVICE_HOST)"<br/>        - name: WORDPRESS_DB_PASSWORD<br/>          value: "password"<br/>        - name: WORDPRESS_DB_USER<br/>          value: "wordpress_user"<br/>        ports:<br/>        - containerPort: 80<br/>          name: wordpress<br/>        volumeMounts:<br/>        - name: wordpress-persistent-storage<br/>          mountPath: /var/www/html<br/>      volumes:<br/>      - name: wordpress-persistent-storage<br/>        persistentVolumeClaim:<br/>          claimName: wp-pv-claim<br/>      imagePullSecrets:<br/>      - name: regcred<br/>---<br/>apiVersion: v1<br/>kind: Service<br/>metadata:<br/>  name: mysqldb<br/>spec:<br/>  ports:<br/>  - name: mysql<br/>    port: 3306<br/>    protocol: TCP<br/>---<br/>apiVersion: v1<br/>kind: Endpoints<br/>metadata:<br/>  name: mysqldb<br/>subsets:<br/>- addresses:<br/>  - ip: 192.168.10.162<br/>  ports:<br/>  - name: mysql<br/>    port: 3306<br/>    protocol: TCP</span></pre><p id="30d7" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">一旦您应用了上面的YAML，并让应用程序在新的集群上启动，WordPress应用程序将可以在端口80上访问。</p><pre class="in io ip iq fd mk ml mm mn aw mo bi"><span id="c478" class="lt iz hi ml b fi mp mq l mr ms">$ kubectl apply -f wordpress.yaml                     <br/>service/wordpress created<br/>persistentvolumeclaim/wp-pv-claim created<br/>deployment.apps/wordpress created<br/>service/mysqldb created<br/>endpoints/mysqldb created</span><span id="8e5a" class="lt iz hi ml b fi mt mq l mr ms">$ kubectl get svc -A                                 <br/>NAMESPACE     NAME         TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                  AGE<br/>default       mysqldb      ClusterIP      198.51.100.47    &lt;none&gt;           3306/TCP                 3m57s<br/>default       wordpress    LoadBalancer   198.51.100.230   192.168.10.165   80:32379/TCP             3m57s<br/>...</span></pre><p id="a6a1" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">在网络浏览器的端口80上访问我们的应用程序，我们得到我们熟悉的WordPress管理页面！！！</p><figure class="in io ip iq fd ir er es paragraph-image"><div role="button" tabindex="0" class="is it di iu bf iv"><div class="er es my"><img src="../Images/83e7396b7e307f87b4ca2b69b95c48dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6NvVcf6VS2WiCebHPCpQDQ.png"/></div></div></figure><h1 id="1679" class="iy iz hi bd ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv bi translated">结论</h1><p id="e1f7" class="pw-post-body-paragraph jw jx hi jy b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt hb bi translated">正如本文开头所讨论的，使用Kubernetes与vSphere的新概念和更紧密的集成，我们可以在vSphere和Tanzu环境中交付复杂的工作负载。下图展示了我们新建筑的外观。请注意，为了保持本文的简短，我们没有引入VM应用程序的额外集成点(以灰色显示)。这可以通过类似于如何部署数据库虚拟机的概念轻松实现。整个设置包含在<code class="du mz na nb ml b">demo1</code>名称空间中，因此遵守了对名称空间的所有约束。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es nc"><img src="../Images/b9be04a78b75ad06e54a2e1ad6d6e730.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*2LBLkfaGxqLggZztWcXQ9w.png"/></div></figure><p id="395f" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">由于运营团队在建立整个应用程序堆栈时几乎不需要做任何准备工作，因此开发人员的权力得到了释放。他们可以使用标准的CICD工具，通过原生Kubernetes集成，在vSphere平台内自动处理如此复杂的工作负载。</p><p id="d0e1" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">作为参考，请参见下图，该图是中心环境的带注释的屏幕截图，展示了vCenter server上现在可用的所有对象。</p><figure class="in io ip iq fd ir er es paragraph-image"><div class="er es nd"><img src="../Images/f42c96f87e574742dabc7c975e254b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*NVb6cQuMJmPqnnfjrpUWSw.png"/></div></figure><p id="a6cb" class="pw-post-body-paragraph jw jx hi jy b jz ku kb kc kd kv kf kg kh kw kj kk kl kx kn ko kp ky kr ks kt hb bi translated">Github链接到本博客中引用的文件—<a class="ae ln" href="https://github.com/papivot/the-new-modern-workload-on-vSphere" rel="noopener ugc nofollow" target="_blank">https://github . com/papi vot/the-new-modern-workload-on-VSP here</a></p></div></div>    
</body>
</html>