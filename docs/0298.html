<html>
<head>
<title>Getting Started with Hash Tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">哈希表入门</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/getting-started-with-hash-tables-3693f0809905?source=collection_archive---------17-----------------------#2021-01-11">https://medium.com/analytics-vidhya/getting-started-with-hash-tables-3693f0809905?source=collection_archive---------17-----------------------#2021-01-11</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><div class=""><h2 id="f688" class="pw-subtitle-paragraph ie hg hh bd b if ig ih ii ij ik il im in io ip iq ir is it iu iv dx translated"><em class="iw">如何理解和编码哈希表</em></h2></div><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es ix"><img src="../Images/36fbd6fcfb1046f66d9441554b8f7065.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5Cuo1HvRhkiRhrVv"/></div></div><figcaption class="jj jk et er es jl jm bd b be z dx translated">由<a class="ae jn" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">沙哈达特拉赫曼</a>在<a class="ae jn" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</figcaption></figure><h2 id="fc7a" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">简介</strong></h2><p id="07a5" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">据<a class="ae jn" href="https://www.statista.com/statistics/871513/worldwide-data-created/#:~:text=Amount%20of%20information%20globally%202010%2D2024&amp;text=The%20total%20amount%20of%20data,ever%2Dgrowing%20global%20data%20sphere" rel="noopener ugc nofollow" target="_blank"> statista </a>统计，2020年全球数据总量等于149 zettabytes。随着全球数据量如此之大，并且每年都在以更快的速度增长，很明显，高效存储数据的能力已经成为计算机科学的关键挑战之一。在本文中，我们将探索最常用的数据存储结构之一:哈希表。</p><h2 id="4ceb" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">什么是哈希表？</strong></h2><p id="0e94" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">哈希表是用于存储数据的数据结构<a class="ae jn" href="https://en.wikipedia.org/wiki/Data_structure" rel="noopener ugc nofollow" target="_blank">。最初，它看起来很像一个数组或一个列表，但它通过允许非常快速的数据检索而将自己与它们区分开来，不管有多少数据。</a></p><p id="1b26" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">哈希表通过使用哈希函数来实现这一点。这是一个将哈希表的索引映射到存储的数据值的函数。这意味着与其他数据结构相比，查找元素的时间复杂度总是等于1。</p><p id="0db0" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">让我们看一个与线性数组/列表相比的散列表的例子。最初这两个看起来完全一样。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/93889cc3d2278d1eefe72cd892fcb270.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sBHBxj1FEZIVUU9N"/></div></div></figure><p id="2a9d" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">然而，如果我们想在这个例子中找到克里斯，这两者之间的区别将变得非常明显。在一个数组中，我们事先不知道克里斯存储在哪里。这意味着我们必须查看每个索引，直到它符合我们的搜索标准。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/fd44f22c8087109567523e042cbbe362.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RdbrgZMVGBo8vuxT"/></div></div></figure><p id="ca21" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">花了三次努力才找到克里斯。这可能看起来不多，但在更大的阵列中，这可能需要更长的时间。尤其是当我们要找的数据存储在数组的末尾时。这就是哈希表有用的地方。为了简单起见，让我们看一下与前面相同的例子。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/7c5385ba230b5dad7bc2d92eda275099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jVxmQOjGn5OAiS-s"/></div></div></figure><p id="6d9e" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">使用哈希表尝试了一次才找到克里斯。此外，在任何哈希表中查找任何元素总是需要一次尝试。这是因为<em class="ll">散列函数</em>，它根据元素的值显示元素的位置。</p><h2 id="42e7" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">哈希函数</strong></h2><p id="4907" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">前面的例子说明了哈希表的魔力来自哈希函数的魔力。有许多方法可以创建散列函数，但是一般的目标总是使用数据的值作为输入，并获得索引作为输出。在本例中，我们将把它用作哈希函数:</p><p id="e179" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated"><em class="ll"> index = </em> <em class="ll">((首字母的字母表值)— 1) % 5 </em></p><p id="2e8e" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">使用这个散列函数，我们可以创建一个散列表。请记住，<em class="ll">‘第一个字母的字母值’</em>与该字母在字母表中的位置有关。因此对于<em class="ll"> a </em>该值为1，对于<em class="ll"> b </em>该值为2，以此类推。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/b54c0e26ec8b80a0abceb688f3c4bf68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uc_AtK_kb3r1OORn"/></div></div></figure><p id="cabc" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">这个例子展示了如何使用hash函数填充哈希表。然而，这个例子也展示了一个哈希表，它被完美地填充，没有两个不同的哈希值是相同的。不幸的是，情况并非总是如此。事实上，两个不同的散列函数生成相同的索引是相当常见的。这被称为<em class="ll">碰撞</em></p><h2 id="f22d" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">碰撞</strong></h2><p id="59bf" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">冲突是指两个不同的哈希函数生成相同的索引。这是一个问题，因为一个索引不能保存多个值。有几种技术可以解决这个问题。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/d335dfd2c8ef849730dd5c358e663ccd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hus-9eIEE-6f-lcE"/></div></div></figure><p id="fdb2" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">第一种可能的技术称为<em class="ll">开放寻址</em>。这种技术通过遍历数组搜索未使用的索引来解决冲突。有几种方法可以做到这一点，但最常用的一种叫做<em class="ll">线性探测</em>。这种技术使用线性搜索来查找空地址。</p><p id="15f7" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">例如，如果我们想将“earl”添加到我们的哈希表中，那么在索引4上将会发生冲突。这可以使用线性探测来解决。使用这种技术，我们在索引6处找到一个空地址，因此我们可以在那里添加“earl”。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/cd27eae2d6c49827b526f693fba69a0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GMvR_AwzTa8f6idF"/></div></div></figure><p id="2fa3" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">请记住,' earl '的哈希函数仍然指向索引4。这意味着，对于数据检索，您还需要在哈希之后执行线性搜索，以便在哈希表中找到“earl”。这降低了数据检索的速度，这是开放式寻址的一个缺点。</p><p id="e4dc" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">第二种技术称为<em class="ll">链接</em>(也称为封闭寻址)<em class="ll">。</em>这种技术本质上是将哈希表从一维数组转换成二维数组。通过这样做，每个索引可以保存多个值，这使得冲突不可能发生。</p><p id="98b3" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">例如，如果我们想将“earl”添加到哈希表中，那么在索引4上就不会有冲突。这是因为(与前面的例子不同)索引4现在可以保存多个值。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/6707862a3fad26a9b0af1a7bbfcf6bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*82_8QpQjixUf-d3I"/></div></div></figure><p id="872b" class="pw-post-body-paragraph km kn hh ko b kp lf ii kr ks lg il ku jz lh kw kx kd li kz la kh lj lc ld le ha bi translated">最后一个选择是调整哈希表的大小，给它比实际需要更多的地址。这减少了冲突的机会，因为对于需要存储的每一段数据，都有多个可用的地址。衡量这一点的一个好方法是<em class="ll">负载因子</em>，它是通过将需要存储的项目数除以哈希表的大小来计算的。</p><figure class="iy iz ja jb fd jc er es paragraph-image"><div role="button" tabindex="0" class="jd je di jf bf jg"><div class="er es lk"><img src="../Images/a5c30b382afda3385eb95794a0ca9727.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Evgeh2IV1-SK_Mqp"/></div></div></figure><h2 id="f729" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">总之</strong></h2><p id="19ac" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">哈希表是存储数据的一种很好的方式，尤其是当您想要存储大量经常使用的数据时。然而，一个重要的附带说明是，哈希表、哈希函数和冲突管理的设计在这个数据结构的质量中起着很大的作用。</p><h2 id="3bcd" class="jo jp hh bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl bi translated"><strong class="ak">代号</strong></h2><p id="558c" class="pw-post-body-paragraph km kn hh ko b kp kq ii kr ks kt il ku jz kv kw kx kd ky kz la kh lb lc ld le ha bi translated">散列表很容易用python实现。在这个例子中，哈希表是使用面向对象的方法制作的。使用线性探测来处理冲突，线性探测是开放式寻址的一种变体。</p><figure class="iy iz ja jb fd jc"><div class="bz dy l di"><div class="lm ln l"/></div></figure></div></div>    
</body>
</html>