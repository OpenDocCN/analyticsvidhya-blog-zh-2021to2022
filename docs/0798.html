<html>
<head>
<title>Spirals, benchmarks, and Java</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">螺旋、基准和Java</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/spirals-benchmarks-68f5bf283e5?source=collection_archive---------19-----------------------#2021-01-31">https://medium.com/analytics-vidhya/spirals-benchmarks-68f5bf283e5?source=collection_archive---------19-----------------------#2021-01-31</a></blockquote><div><div class="ds gv gw gx gy gz"/><div class="ha hb hc hd he"><div class=""/><p id="6149" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最近，我在一个友好的Java服务器上接受了提高代码速度的挑战。代码是关于生成螺旋矩阵的:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/137c4e907dcc18aa4f635761d544c3ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*57O2ESZaeExBCsOjgKN70w.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">螺旋矩阵图案，油漆制成的❤</figcaption></figure><p id="dfb4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">由于我目前正在阅读机械同情和相关的东西，我发现这是一个很好的实验CPU友好的方法的例子。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="4243" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">首次实施和瓶颈</h1><p id="5147" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我想到的第一个算法反映了一个简单的递归思想。我们首先在自相似矩阵上循环，对于每个矩阵，我们遍历顶部标题行，4乘4地填充条目:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/7128a979028ccb2c9a9b6079a39bf74d.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*QIDFKghLikYLI2YtwqLolw.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">外部边界上的首次迭代</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/850c4662db45fdea4ce0ff7b55c5336a.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*wUE_0sYRNs-9W-KcYoD7fg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">外部边界的第二次迭代</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/f8a352032cbd9858d0c16bb1401aaaa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*RNZO2EVkrq2VsTwcB7QFcQ.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">外部边界上的第三次迭代</figcaption></figure><figure class="jd je jf jg fd jh er es paragraph-image"><div class="er es jc"><img src="../Images/d1c98450f27250329468be78ff2c09c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:576/format:webp/1*fhqTn2oQRbdWqTJrx4Y_vg.png"/></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">外部边界上的第四次迭代</figcaption></figure><p id="9dee" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在完全填充了外部矩阵的边界后，我们放大并聚焦于未被触及的内部矩阵。完整的代码如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es ky"><img src="../Images/657663b4dc932e7e8e7d1fb40210b9ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UBqf4JW62LlYPkvAhJKKLw.png"/></div></div></figure><p id="3a0f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">(别问为什么，<code class="du ld le lf lg b">n</code>是矩阵维数，作为单独的参数。)我对这段代码不满意，因为它违反了机械同情。事实上，让它在<code class="du ld le lf lg b">n = 1 &lt;&lt; 14</code>上运行使它在大约4.5秒内运行。</p><p id="8ee7" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated"><em class="lh">剧透警告:</em>我尝试的第二个实现让算法在300毫秒内完成。</p><h2 id="799e" class="li jw hh bd jx lj lk ll kb lm ln lo kf ip lp lq kj it lr ls kn ix lt lu kr lv bi translated">机械同情:背景</h2><p id="d250" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">在介绍优化方法之前，让我们回顾一些非常基础的东西。</p><p id="6a4b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">我们目前正在处理一个双整数数组。</p><p id="5356" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在Java中，整数的大小是32位，也就是4个字节。引用的大小是64位，即8个字节。</p><p id="c9a3" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于一个维度为<code class="du ld le lf lg b">1 &lt;&lt; n</code>(2^n的位风格)的矩阵，我们需要的总数据存储量至少是</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="3b58" class="li jw hh lg b fi ma mb l mc md">(2^n * 8) + 2^n * (2^n * 4) ~&gt;~ 2^(2n + 2)</span></pre><p id="d384" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于规模来说，1gb大约是<code class="du ld le lf lg b">1 &lt;&lt; 30</code>。在我现在使用的电脑上，它仍然略低于2g(无可奉告)。因此，我应该在<code class="du ld le lf lg b">2n + 2 &gt; 30</code>时就离开内存，因此在<code class="du ld le lf lg b">n = 14</code>附近……事实上，在<code class="du ld le lf lg b">OutOfMemoryError</code>时超过那个点会严重失败，低于或相同是可以的。</p><p id="1d43" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">但是RAM大小不是我应该考虑的唯一关键点。通过Windows任务管理器查看我的计算机，我看到我的一级CPU缓存为256千字节。这大约是<code class="du ld le lf lg b">1 &lt;&lt; 18</code>字节。</p><p id="20fd" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">有趣的是，L1缓存通常分为两部分:一半用于存储指令，另一半用于存储数据。因此，我的缓存可以处理的整数数量大约是<code class="du ld le lf lg b">1 &lt;&lt; (7+8) </code>(大小除以2(因为拆分)，再除以4(因为int的大小))。</p><h2 id="fe5c" class="li jw hh bd jx lj lk ll kb lm ln lo kf ip lp lq kj it lr ls kn ix lt lu kr lv bi translated">机械同情:冲击</h2><p id="4399" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">以上关于我的硬件的背景强调了几个事实。</p><p id="bd65" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">数据存储在堆中，访问RAM大约需要50个CPU周期(快)。像我在算法中使用的局部变量很可能存储在寄存器中，其访问大约是1个周期(便宜)。另一方面，访问L1缓存大约需要5个周期(超级事实)。所以我真的应该努力让CPU尽可能多的放在那个地方。</p><p id="dd86" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">重要的是要知道，当我的CPU工作时，它试图预见哪些数据将在即将到来的指令中使用。我的实现中的数据访问模式是完全可预测的。一个天真的判断(我必须承认，这是我第一眼看到的)可能会认为它是“缓存友好的”，因为我的CPU应该能够很容易地预见到哪些数据将被提取到缓存中。</p><p id="a9f1" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">坏消息是:CPU不会提取“矩阵的单个条目”。通常，它获取块:缓存行；连续的记忆片段。这正是我的问题所在！对行进行迭代是可以的，因为CPU将获取连续的数据。每当我们处理一行时，数据都可能来自缓存，这很快。然而，相同的缓存行策略也用于列，产生实际上没有完全使用的信息提取。最坏的情况:获取那些无用的数据会使相关的数据离开缓存，增加缓存缺失的可能性。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="b893" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">解药</h1><p id="df7d" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">我就这样用一种(我的！)电脑。正如我之前说过的，我的L1缓存大约是<code class="du ld le lf lg b">1 &lt;&lt; 15</code> ints，适合2个<code class="du ld le lf lg b">1 &lt;&lt; 14</code>整数的矩阵行。(我在这里可能过于近似，但这是第一次优化试验，可能不是完全有效，但目前已经足够了。)</p><p id="56a4" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">因此，我打算进行重构，一次处理2行，并且只处理行。完整的代码如下所示:</p><figure class="jd je jf jg fd jh er es paragraph-image"><div role="button" tabindex="0" class="kz la di lb bf lc"><div class="er es me"><img src="../Images/36bf752ffe7b6ac1ebfcb36162ea3369.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEq3CISA6MrBADcrV-U3rw.png"/></div></div><figcaption class="jk jl et er es jm jn bd b be z dx translated">完全更好优化的代码</figcaption></figure><p id="6d41" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下面，我们描述代码的基本思想。如果您真的不在乎，并且想进入基准测试部分，请随意跳过它！</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><p id="df81" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第一个while循环及其两个后续指令旨在填充自顶向下和自底向上的三角形。下面是这次在<code class="du ld le lf lg b">n=7</code>上封杀的结果:</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="d8b7" class="li jw hh lg b fi ma mb l mc md"><em class="lh">1     2     3     4     5     6     7     <br/>0     25    26    27    28    29    0     <br/>0     0     41    42    43    0     0     <br/>0     0     0     0     0     0     0     <br/>0     0     47    46    45    0     0     <br/>0     37    36    35    34    33    0     <br/>19    18    17    16    15    14    13</em></span></pre><p id="486e" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">下一个for循环将填充矩阵的左侧，首先填充底部的行，然后填充顶部的行。底线被重新组合使用一个周长像诡计，从邻居运行回螺旋。</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="cbc6" class="li jw hh lg b fi ma mb l mc md"><em class="lh">1     2     3     4     5     6     7     <br/>24    25    26    27    28    29    0     <br/>23    40    41    42    43    0     0     <br/>0     0     0     0     0     0     0     <br/>21    38    47    46    45    0     0     <br/>20    37    36    35    34    33    0     <br/>19    18    17    16    15    14    13 </em></span></pre><p id="0b66" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">第二个内部for循环使用左边的内容重新组合右边的内容。同样，使用了螺旋反向运行技巧:</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="c292" class="li jw hh lg b fi ma mb l mc md"><em class="lh">1     2     3     4     5     6     7     <br/>24    25    26    27    28    29    8     <br/>23    40    41    42    43    30    9     <br/>0     0     0     0     0     0     0     <br/>21    38    47    46    45    32    11    <br/>20    37    36    35    34    33    12    <br/>19    18    17    16    15    14    13 </em></span></pre><p id="c2eb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">最后，在相关的情况下，使用顶部的一行或底部的一行重新组合中间的一行:</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="07b7" class="li jw hh lg b fi ma mb l mc md"><em class="lh">1     2     3     4     5     6     7     <br/>24    25    26    27    28    29    8     <br/>23    40    41    42    43    30    9     <br/>22    39    48    49    44    31    10    <br/>21    38    47    46    45    32    11    <br/>20    37    36    35    34    33    12    <br/>19    18    17    16    15    14    13</em></span></pre><p id="1031" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在每个迭代阶段，改进只是使用了2行，不会更多。我想我会时不时地再次错过缓存，因为我的极端用例<code class="du ld le lf lg b">n = 1 &lt;&lt; 14</code>有点模糊，正好填满了我的L1缓存。然而，这种现象不应该像以前那样频繁出现。</p><p id="3d9a" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">补充说明:正如你所看到的，在第二个实现中，我没有试图完全优化计算或局部变量的使用；因为我其实不在乎(目前)。</p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="3833" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">结果呢</h1><p id="c347" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">以下是我为简单实现和优化实现所做的基准测试(JMH，平均时间，1次热身):</p><pre class="jd je jf jg fd lw lg lx ly aw lz bi"><span id="c31a" class="li jw hh lg b fi ma mb l mc md"><strong class="lg hi"><em class="lh">1 &lt;&lt; 14</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt     Score      Error<br/>SpiralMatrix.naiveFillBenchmark      avgt    5  4778,838 ± 1116,666<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5   302,008 ±   27,536 <br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 13</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt    Score    Error<br/>SpiralMatrix.naiveFillBenchmark      avgt    5  525,858 ± 18,257<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5   68,188 ±  3,068<br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 12</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt    Score   Error<br/>SpiralMatrix.naiveFillBenchmark      avgt    5  111,950 ± 3,625<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5   18,343 ± 6,507<br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 9</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt  Score   Error<br/>SpiralMatrix.naiveFillBenchmark      avgt    5  0,679 ± 0,005<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5  0,277 ± 0,002<br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 8</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt  Score   Error<br/>SpiralMatrix.naiveFillBenchmark      avgt    5  0,101 ± 0,001<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5  0,068 ± 0,002<br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 7 </em></strong><em class="lh"> (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt  Score    Error  <br/>SpiralMatrix.naiveFillBenchmark      avgt    5  0,013 ±  0,001  <br/>SpiralMatrix.optimizedFillBenchmark  avgt    5  0,016 ±  0,001 <br/><br/></em><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 6</em></strong><em class="lh">  (milliseconds/op)<br/><br/>Benchmark                            Mode  Cnt  Score    Error  <br/>SpiralMatrix.naiveFillBenchmark      avgt    5  0,003 ±  0,001<br/>SpiralMatrix.optimizedFillBenchmark  avgt    5  0,004 ±  0,001</em></span><span id="4d45" class="li jw hh lg b fi mf mb l mc md"><strong class="lg hi"><em class="lh">n = 1 &lt;&lt; 2 (microseconds/op!)</em></strong><em class="lh"><br/><br/>Benchmark                            Mode  Cnt  Score    Error  <br/>SpiralMatrix.naiveFillBenchmark      avgt    5  0,024 ±  0,001  <br/>SpiralMatrix.optimizedFillBenchmark  avgt    5  0,030 ±  0,001 </em></span></pre><p id="34fc" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">对于大型矩阵，您应该可以看到原始版本和优化版本之间的数量级差异。差异在<code class="du ld le lf lg b">1 &lt;&lt; 7</code>消失。回想一下，我的L1缓存是<code class="du ld le lf lg b">1 &lt;&lt; 15</code> ints，所以这种情况是所有数据进入缓存的(大约)<em class="lh">最高的情况！此外，优化版本明显优于原始版本10倍，这也是RAM和L1缓存访问之间的数量级差异所预期的。</em></p></div><div class="ab cl jo jp go jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="ha hb hc hd he"><h1 id="1e2c" class="jv jw hh bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">外卖食品</h1><p id="221e" class="pw-post-body-paragraph ie if hh ig b ih kt ij ik il ku in io ip kv ir is it kw iv iw ix kx iz ja jb ha bi translated">如果要我总结以上实验，我至少会说:<em class="lh">你在一个方法中进行的局部变量和局部计算的数量不会成为你的代码变慢的原因。</em></p><p id="3ebb" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">这些似乎通常很便宜，并且依赖于寄存器(看看最后一个<code class="du ld le lf lg b">1 &lt;&lt; 2</code>的例子，其中的差别是纳秒量级的！)</p><p id="756b" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">你的代码的真正瓶颈更可能是硬件误解。</p><p id="e454" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">事实上，正如人们经常告诉你的那样，遍历列实际上并不是问题。事实上，问题在于高速缓存行及其存在的必然结果。</p><p id="4692" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">当然，这种有趣的事实可能不会成为整个应用程序的瓶颈，它可能处理IO操作或垃圾收集。您知道更改线程会引发上下文切换，并且预计会破坏缓存吗？为了更好地优化必要的东西(IO、线程、GC等等)而不在不必要的东西上浪费时间，更好地理解硬件及其对代码的影响从来都不是浪费时间。</p><p id="a9d8" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">在做这个实验之前，我从来没有打赌第二个实现会比第一个实现好得多，因为我总是被告知… <em class="lh">像在许多其他领域(例如安全性)一样，没有测量就谈论性能是绝对没有意义的。</em>这个例子证明了一切。下次有人问你这个问题时，明智地回答。</p><p id="6d44" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">也许最后一点是:我们在这里为数据所做的，在概念上也适用于指令。还记得L1高速缓存被一分为二吗？<em class="lh">所以保持你的方法简短</em>:这样，它们将更好地适应缓存，并且从存储它们的地方更快地获取。(这里再次强调:以事实为基准，不要盲目相信你在媒体上读到的东西！)</p><p id="4d5f" class="pw-post-body-paragraph ie if hh ig b ih ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb ha bi translated">干杯！</p></div></div>    
</body>
</html>