<html>
<head>
<title>Read your network of friends in Facebook by scraping with Python</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Python阅读你在脸书的朋友网络</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/read-your-network-of-friends-in-facebook-by-scraping-with-python-a012adabb713?source=collection_archive---------7-----------------------#2021-08-16">https://medium.com/analytics-vidhya/read-your-network-of-friends-in-facebook-by-scraping-with-python-a012adabb713?source=collection_archive---------7-----------------------#2021-08-16</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><p id="4ab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">注</strong>:你可以在一个<a class="ae jd" href="https://www.kaggle.com/rubchume/read-your-network-of-friends-in-facebook" rel="noopener ugc nofollow" target="_blank"> Kaggle笔记本</a>中访问本文的所有代码。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es je"><img src="../Images/973f76d1e896a24bc6e50abe1fa481d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PLzq_I0yXifxDu_a"/></div></div><figcaption class="jq jr et er es js jt bd b be z dx translated">照片由<a class="ae jd" href="https://unsplash.com/@alinnnaaaa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">阿丽娜·格鲁布尼亚</a>在<a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="4a8e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在数学中<a class="ae jd" href="https://en.wikipedia.org/wiki/Graph_theory" rel="noopener ugc nofollow" target="_blank">图</a>是<em class="ju">数学结构，用于建模对象</em>(根据维基百科)<em class="ju">。</em></p><p id="841e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">用通俗的话来说，就是抽象的表示一组元素以及它们之间的联系。例如，它可以用来表示城市是如何通过铁路连接起来的。在最简单的形式中，如果我们想要表示一个连接，一个图可以由一组表示元素(或图命名法中的节点)的圆和连接这些圆的线(或边)来直观地表示。</p><p id="4a69" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">例如，这是一个图表:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/e77806deb13943dc9f194c012a9d77af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*I9rHk91y_NKD6cF3.png"/></div></div></figure><p id="a3cb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">6号元素/节点连接到4号元素/节点，4号元素/节点连接到5号元素和3号元素，依此类推。</p><p id="0498" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">图形也可以用来模拟社会网络，也就是人的网络。如果每一个节点都是一个人，每一条边都代表他们是否是朋友，那么我们可以用一个图来建模一个友谊网络，并如上图用圆圈和线条来可视化。</p><p id="751e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们将要做的。但是，我们要用什么样的社交网络来做呢？嗯，我们将使用你们自己的脸书网络。</p><p id="1534" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脸书是一个巨大的社交网络。你不可能知道整个脸书网络的结构。有几千几百万用户。你无法访问它，也没有计算资源来处理所有这些信息。但是，您可以访问该网络的一个子集。怎么会？</p><p id="44fa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你不能接触到所有的信息，但你可以接触到一些。首先，你在脸书(我猜，否则这篇文章对你没有多大意义)。所以，你知道你是网络的一个节点。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/476b5c3e5b9760356bcd45f70d65bd38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FTwS2gjnKhbjRce4.png"/></div></div></figure><p id="0c7f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你还知道什么？你了解你的朋友。它们也是图/网络的节点。你知道你和他们是朋友，所以你和他们之间有边缘/联系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/2c94566e60d2c4be92c2334d272e0347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WwJGx7iTktoUHljB.png"/></div></div></figure><p id="1c80" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你还知道什么？你了解你的朋友。它们也是图/网络的节点。你知道你和他们是朋友，所以你和他们之间有边缘/联系。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/c128eb1e93eb736e1ffa54094263045a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nzT6RbXTgtFXMKpz.png"/></div></div></figure><p id="e28f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">所以，你可以知道你的脸书网络！它不是整个网络，但它是整个网络的一个子集。这确实是您可能最感兴趣的子集。</p><p id="17a9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，这个网络有一条我们并不真正感兴趣的信息，因为它是多余的。你已经知道你是所有剩余节点的朋友。所以，你作为一个节点，你和其他节点之间的所有边都是噪音。如果我们删除它们，留给我们的是一个只包含新信息的网络。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jw"><img src="../Images/80d06d14f15f27ad20b71ba8ab388c9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ZpGM-gZCqRgMdbg8.png"/></div></div></figure><p id="3205" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这就是我们感兴趣的网络。</p><p id="9868" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在这篇文章中，我将向你展示如何获取必要的信息来构建这个图表。这些信息一方面是你的朋友列表，另一方面是他们之间的联系。我们将通过抓取Facebooks网页来做到这一点，即每次登录时从下载到浏览器的html代码中获取信息。</p><p id="d1ad" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将要使用的主要工具是<a class="ae jd" href="https://www.selenium.dev/" rel="noopener ugc nofollow" target="_blank"> Selenium </a>，这是一个用于这类项目的强大Python库。</p><p id="bd9b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们得到所有这些信息时，我将在下一篇文章中教你如何可视化那个图:<a class="ae jd" href="https://rubchume.medium.com/organize-your-wedding-with-social-network-analysis-in-python-aeab9d8814b3" rel="noopener">用Python中的社交网络分析组织你的婚礼</a>。</p><p id="61a3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果你只是想做，但对学习如何做不感兴趣，你也可以下载一个我用Django开发的web应用程序来做所有这些。从GitHub <a class="ae jd" href="https://github.com/rubchume/FacebookFriendNetworkAnalyzer" rel="noopener ugc nofollow" target="_blank">库</a>下载它，并遵循<code class="du jx jy jz ka b">Readme.md</code>文件中的说明。</p><p id="318e" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">开始吧！！！</p><p id="e21b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><strong class="ih hj">重要提示</strong></p><p id="7f4c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">脸书经常改变它的网页设计。这意味着，在您阅读本文时，我在这里提出的解决方案可能不起作用。</p><p id="cf77" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是不要难过。我在这里介绍的过程实际上是有用的，但是您必须找到的特定按钮或<code class="du jx jy jz ka b">&lt;div&gt;</code>元素可能是不同的，所以您应该修改我在更新的脸书设计中使用的CSS选择器。</p><h1 id="be7e" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">安装Selenium</h1><p id="5751" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">Selenium是一个软件工具，允许自动使用网络浏览器。简而言之，我们可以执行普通网络用户用鼠标和键盘就能完成的动作，但是我们可以通过编写代码来定义它们，从而自动化它们，安排它们，非常快速地重复它们，等等。用途由你决定。</p><p id="4839" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这有什么用？比方说，你的朋友整周都在恳求你喜欢她在Instagram上的所有新照片。那是一项乏味的任务。你没那么喜欢Instagram，你甚至不喜欢她的图片，她用了那么多滤镜都认不出来了。你甚至不知道为什么你们还是朋友…但那不关我的事，让我们集中注意力好吗。</p><p id="4dc6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你可以使用Selenium自动完成这项任务，而不是每个周末都在她所有的照片上点击“喜欢”按钮。你只需要写一些代码，Selenium就会连接到，比如说，谷歌Chrome，来喜欢你朋友所有的照片。</p><p id="ebfa" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它可以在很多编程语言中使用，当然也有一个用于Python 的<a class="ae jd" href="https://selenium-python.readthedocs.io/" rel="noopener ugc nofollow" target="_blank"> API。</a></p><p id="61d7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">安装Selenium通常不会产生太多问题，但有时会很麻烦。有关说明，请参考前面的链接。</p><p id="d8d2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你需要一些基本的东西。首先，从安装Python包开始:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="673d" class="li kc hi ka b fi lj lk l ll lm">pip install selenium</span></pre><p id="0102" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然后，您需要选择允许Selenium使用的浏览器。我选择了谷歌浏览器，因为它是我一直使用的。</p><p id="9230" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">为了允许Selenium和Chrome之间的通信，您需要为Selenium提供一个web驱动程序。如果你想像我一样使用Chrome，你可以在这个<a class="ae jd" href="https://sites.google.com/a/chromium.org/chromedriver/downloads" rel="noopener ugc nofollow" target="_blank">链接</a>中下载与你的Chrome版本对应的web驱动。下载。根据您的操作系统，提取该文件并将其放在您要执行代码的同一个文件夹中。</p><p id="50a2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">最后，导入Python中的库并实例化web驱动程序:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="ecbc" class="li kc hi ka b fi lj lk l ll lm">from selenium import webdriver<br/>from webdriver_manager.chrome import ChromeDriverManager</span><span id="7315" class="li kc hi ka b fi ln lk l ll lm">driver = webdriver.Chrome()</span></pre><p id="1681" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果您将它放在其他文件夹中，也可以提供路径:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="b16a" class="li kc hi ka b fi lj lk l ll lm">driver = webdriver.Chrome(“path/to/chromedriver.exe”)</span></pre><p id="9d06" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">然而，对我来说最简单的选择是使用一个叫做<a class="ae jd" href="https://pypi.org/project/webdriver-manager/" rel="noopener ugc nofollow" target="_blank"> webdriver_manager </a>的工具，它为你处理驱动程序下载并保存在缓存中以备将来使用。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="0d4c" class="li kc hi ka b fi lj lk l ll lm">from webdriver_manager.chrome import ChromeDriverManager </span><span id="2a6a" class="li kc hi ka b fi ln lk l ll lm">driver = webdriver.Chrome(ChromeDriverManager().install())</span></pre><p id="4e29" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">当我们执行上面提到的三个选项中的任何一个时(我个人更喜欢最后一个)，就会出现一个Chrome窗口。您可能会得到稍微不同的视图，并且您将看到的文本可能是您的语言。我是西班牙人，所以我看到西班牙语文本。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/6760d9709094be75f18e832c6b35d581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sels3sMDLn_MHswq.png"/></div></div></figure><p id="b6a6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果顺利的话，我们可以从娱乐开始。</p><h1 id="925f" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">登录Faceboo</h1><p id="f50b" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">获得我们的朋友脸书网络的第一步是登录脸书。我们必须首先访问页面。这很简单:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="243a" class="li kc hi ka b fi lj lk l ll lm">driver.get(“https://www.facebook.com/")</span></pre><p id="e08c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将看到这样一个屏幕:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/a14d2fe4a2a9a6068c39c7e344424b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*snPKr3hhsepYLSnv.png"/></div></div></figure><p id="6466" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">它要求我们接受cookies，因为我们不在我们通常的Chrome实例中，我们已经登录，并且我们可以访问所有的cookies。这是一个新会话，没有用户登录，因此从脸书的角度来看，我们是一个未知用户。</p><p id="fdff" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">要接受cookies，我们必须找到“接受全部”按钮，然后点击它，但不是用鼠标，而是用代码。</p><p id="6004" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是由于页面不会立即加载，我们必须告诉Selenium等待几秒钟，直到按钮被加载，也就是说，直到html代码中出现。</p><p id="a5ea" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将使用一个<a class="ae jd" href="https://www.w3schools.com/cssref/css_selectors.asp" rel="noopener ugc nofollow" target="_blank"> CSS选择器</a>来找到按钮，同样的方法将在文章的其余部分使用。要查看CSS选择器会找到每个按钮或任何其他元素，您可以使用一些Chrome扩展或只打开Chrome开发工具(Ctrl + Shift + I)并浏览页面的html代码。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="9468" class="li kc hi ka b fi lj lk l ll lm">from selenium.webdriver.support.wait import WebDriverWait<br/>from selenium.webdriver.support import expected_conditions as EC<br/>from selenium.webdriver.common.by import By<br/><br/>accept_cookies_button = WebDriverWait(driver, 10).until(<br/>    EC.element_to_be_clickable(<br/>        (By.CSS_SELECTOR, "button[data-testid='cookie-policy-dialog-accept-button']")<br/>    )<br/>)<br/><br/>accept_cookies_button.click()</span></pre><p id="feaf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">很好！你按了第一个按钮！恭喜你。让我们继续前进。</p><p id="3d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以用我们的用户和密码填充登录字段。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="a408" class="li kc hi ka b fi lj lk l ll lm">user_css_selector = "input[name='email']"<br/>password_css_selector = "input[name='pass']"<br/><br/>username_input = WebDriverWait(driver, 10).until(<br/>    EC.element_to_be_clickable((By.CSS_SELECTOR, user_css_selector))<br/>)<br/>password_input = WebDriverWait(driver, 10).until(<br/>    EC.element_to_be_clickable((By.CSS_SELECTOR, password_css_selector))<br/>)<br/><br/>username_input.clear()<br/>username_input.send_keys("myuser@blablabla.com")<br/>password_input.clear()<br/>password_input.send_keys("myPassword1232345345")</span></pre><p id="e662" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">或者，如果您将您的用户和密码保存在一个`. env '文件中，我推荐您这样做，您可以使用` dotenv '来加载它们:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="7237" class="li kc hi ka b fi lj lk l ll lm">from dotenv import dotenv_values<br/><br/>config = dotenv_values(".env")<br/><br/>username_input.clear()<br/>username_input.send_keys(config["user"])<br/>password_input.clear()<br/>password_input.send_keys(config["password"])</span></pre><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lo"><img src="../Images/907c6c887c6e49f8978bb9af8a42b272.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vGn_kdxEAihqWz5G.png"/></div></div></figure><p id="6247" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，只需点击登录按钮。你能从上面的例子中猜出怎么做吗？</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="815e" class="li kc hi ka b fi lj lk l ll lm">WebDriverWait(driver, 2).until(<br/>    EC.element_to_be_clickable((By.CSS_SELECTOR, "button[type='submit']"))<br/>).click()</span></pre><p id="41fe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们登录了！！！是不是感觉很强大。</p><p id="7b67" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们不要这么早庆祝。我们继续。我们现在想做什么？我们想得到我们的朋友名单。然后我们必须进入相应的页面。但首先，等待几秒钟，以便脸书页面可以正确加载。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="fc17" class="li kc hi ka b fi lj lk l ll lm">import time<br/><br/>time.sleep(2)<br/>driver.get("https://www.facebook.com/friends/list")</span></pre><h1 id="b93c" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">阅读朋友列表</h1><p id="a673" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">现在我们进入了混乱的水域。我们想得到我们所有朋友的名单。这里有两种方法。一种，是手动向下滚动所有朋友的面板。另一种方法是利用GraphQL API以更高效、更优雅的方式完成这项工作。我选择了第二种方式，因为我觉得它更有趣。</p><p id="fab3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">想法是这样的。当您向下滚动friends面板时，后面发生的事情是您的浏览器正在向服务器发送http请求，请求JSON格式的新一批朋友(接下来的10个朋友将在屏幕上可见)信息。</p><p id="2e35" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">因此，我们不做滚动，只是模拟相同的http请求，使用<a class="ae jd" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>。你不需要知道GraphQL是什么，不用担心。我也不太了解。如果你不想花时间研究它，就认为它是一套在后端和前端之间共享信息的规则。这是一种设计web APIs的改进方法。</p><p id="0f76" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们将用来发出http请求的库是<a class="ae jd" href="https://docs.python-requests.org/en/master/" rel="noopener ugc nofollow" target="_blank">请求</a>。我创建请求所做的只是使用Chrome开发工具(网络选项卡)来检查交换了哪些请求，并查看发送到<code class="du jx jy jz ka b">graphql/</code>端点的请求使用了哪些头部和主体:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/9d924bbcf63ec3bf7078229699042fed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XwmoW5WVY6qsfxA8.png"/></div></div></figure><p id="6bb5" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我不打算详细描述请求和响应的头部和主体，主要是因为它可能会随时间而改变，可能会早于晚。</p><p id="912d" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">亲爱的读者，这对你来说是个坏消息，因为这意味着你必须修改代码，我将向你展示。无论如何，您必须遵循的推导正确的标题和正文的过程与我遵循的过程相同。</p><p id="ddf2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我发现的是。为了让后端向你提供你所要求的信息，它必须确保你就是你所说的那个人。它通过两种方式做到这一点。首先，你应该为会话设置与Chrome实例使用的相同的cookies。其次，您必须在http请求数据中发送一个名为“fb_dtsg”的字段。我不是web开发人员，所以我不打算假装我理解GraphQL是如何工作的，有哪些约定，或者为什么脸书除了cookies之外还需要这个“fb_dtsg”字段来识别用户。无论如何，这两个值是我需要设置的，这样我就可以得到我想要的信息。</p><p id="2afe" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">cookies问题很容易解决。您可以使用Selenium驱动程序轻松访问cookie字段，并将它们分配给请求会话:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="d8eb" class="li kc hi ka b fi lj lk l ll lm">import requests<br/><br/>session = requests.session()<br/>session.cookies.update({<br/>    cookie["name"]: cookie["value"]<br/>    for cookie <strong class="ka hj">in</strong> driver.get_cookies()<br/>})</span></pre><p id="2030" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">可以通过在好友列表页面的html源代码中找到一个模式来找到<code class="du jx jy jz ka b">fb_dtsg</code>标记:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="907c" class="li kc hi ka b fi lj lk l ll lm">import json<br/>import re<br/><br/>pattern = r'\["DTSGInitData",\[\],{"token":"\S+","async_get_token":"\S+?"},\d+\]'</span><span id="5f6b" class="li kc hi ka b fi ln lk l ll lm">match = re.search(pattern, driver.page_source)<br/>fb_dtsg_token = json.loads(match.group())[2]["token"]</span></pre><p id="3beb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们准备询问我们第一批朋友的信息:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="9d89" class="li kc hi ka b fi lj lk l ll lm">import urllib<br/><br/>url = 'https://www.facebook.com/api/graphql/'<br/><br/>headers = {<br/>    "accept": "*/*",<br/>    "accept-language": "es-ES,es;q=0.9",<br/>    "content-type": "application/x-www-form-urlencoded",<br/>    "sec-ch-ua": "<strong class="ka hj">\"</strong> Not;A Brand<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>99<strong class="ka hj">\"</strong>, <strong class="ka hj">\"</strong>Google Chrome<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>91<strong class="ka hj">\"</strong>, <strong class="ka hj">\"</strong>Chromium<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>91<strong class="ka hj">\"</strong>",<br/>    "sec-ch-ua-mobile": "?0",<br/>    "sec-fetch-dest": "empty",<br/>    "sec-fetch-mode": "cors",<br/>    "sec-fetch-site": "same-origin",<br/>    "x-fb-friendly-name": "FriendingCometFriendsListPaginationQuery",<br/>    "referrer": "https://www.facebook.com/friends/list",<br/>    "referrerPolicy": "strict-origin-when-cross-origin",<br/>}<br/><br/>response = session.post(<br/>    url,<br/>    headers=headers,<br/>    data=urllib.parse.urlencode(<br/>        {<br/>            "fb_dtsg": fb_dtsg_token,<br/>            "fb_api_req_friendly_name": "FriendingCometFriendsListPaginationQuery",<br/>            "variables": json.dumps(<br/>                {<br/>                    "count": 30,<br/>                    "cursor": None,<br/>                    "scale": 1,<br/>                }<br/>            ).replace(" ", ""),<br/>            "doc_id": 4268740419836267,<br/>        }<br/>    )<br/>)</span></pre><p id="7d5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">有两件事要提一下。第一，不要担心那些你不知道是什么意思的字段。就像我一样设置它们。其中一个你必须注意的是<code class="du jx jy jz ka b">doc_id</code>。当你用Chrome开发者工具检查请求数据时，这是一个出现在请求数据中的数字。和以前一样，我不打算假装它是用来做什么的或者为什么是必要的。包括它就行了。否则，这是行不通的。</p><p id="1470" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我认为这是一个识别你所要求的数据类型的数字。我观察到这个数字经常变化，但是，只要你使用你观察到的人，它就会起作用。至少，它对我有用。这意味着可能有多个有效的doc _ ids，这是个好消息。上面那个是对我有效的。我不知道它们是通用的还是必须为每个用户定制的。</p><p id="accf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们继续。我们用朋友的数据得到了一个http响应。让我们把它解析成一个Python字典:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="4e25" class="li kc hi ka b fi lj lk l ll lm">response_dict = json.loads(response.content)<br/>friend_objects = response_dict["data"]["viewer"]["all_friends"]["edges"]<br/><br/>friends = [<br/>    dict(<br/>        user_id=str(friend["node"]["id"]),<br/>        name=friend['node']['name'],<br/>        link=friend['node']['url'],<br/>        gender=friend['node']['gender']<br/>    )<br/>    for friend <strong class="ka hj">in</strong> friend_objects<br/>    if friend["node"]["__typename"] == "User"<br/>]<br/><br/>print(f"Number of friends: <strong class="ka hj">{</strong>len(friends)<strong class="ka hj">}</strong>")</span><span id="bbaa" class="li kc hi ka b fi ln lk l ll lm"># Output:<br/>Number of friends: 30</span></pre><p id="80c6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你会注意到两件事。一是反应的结构相当复杂。同样，它与GraphQL中信息的格式化方式有关。但是一旦找到相关信息的途径，就很容易处理了。有很多信息，但我发现唯一相关的字段是用户id、姓名和配置文件链接。我也存了性别，因为我很好奇我的男性朋友多还是女性朋友多。</p><p id="0201" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">第二件应该引起你注意的事情是只有30个朋友。这是怎么回事？我以为我会更受欢迎一点😭。</p><p id="7d7c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">实际上，我有300多个朋友。为什么名单上只有30个？嗯，我们告诉它这样做。如果你注意请求数据中的字段<code class="du jx jy jz ka b">count</code>，我们请求了30个朋友，这就是我们得到的。为什么我们不邀请300个朋友呢？我试过了，但没用。</p><p id="d7bb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">原因是后端只给浏览器发送面板上可见好友的信息。向下滚动时，浏览器会依次请求下一批好友，直到到达列表的末尾。</p><p id="8c22" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">在第一个请求中，我们只有30个朋友，因为这是目前唯一相关的信息。想象一下，每当你只想和你最好的朋友聊天的时候，下载你所有的朋友列表会是多么的低效。这是对带宽的浪费。由于这是普通用户的预期行为，他们必须设置每个请求30个好友的限制。</p><p id="de60" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是我们如何要求下一批朋友呢？嗯，有一个“秘密”。当我们得到响应时，会有一个字段告诉我们是否有更多可用的信息。而且，在这种情况下，它还告诉我们下一个朋友的<code class="du jx jy jz ka b">cursor</code>是什么。</p><p id="467a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><code class="du jx jy jz ka b">cursor</code>？那是什么？似乎当请求您的朋友列表时，每个朋友都有一个字母数字长代码(一个<code class="du jx jy jz ka b">cursor</code>)与之相关联。因此，在我们得到的响应中，它在告诉我们:“嘿，有更多的朋友可用，列表中的下一个朋友就是有这个光标的朋友”。</p><p id="3537" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">你是怎么得到这些信息的？像这样:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="8506" class="li kc hi ka b fi lj lk l ll lm">page_info = response_dict[“data”][“viewer”][“all_friends”][“page_info”]</span></pre><p id="96cf" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">字段<code class="du jx jy jz ka b">page_info</code>是具有两个字段的对象:<code class="du jx jy jz ka b">has_next_page</code>和<code class="du jx jy jz ka b">end_cursor</code>。<code class="du jx jy jz ka b">has_next_page</code>是一个布尔值，它告诉我们是否有更多的朋友需要添加，或者是否已经到了列表的末尾。在有更多的情况下，<code class="du jx jy jz ka b">end_cursor</code>是下一个朋友的光标。例如:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="9b24" class="li kc hi ka b fi lj lk l ll lm">{<br/>    'has_next_page': True,<br/>    'end_cursor': 'VeryLongRandomAlphanumericSequence-x9QpwrV7w2xv2QS6DlDOOKQIIfWJAQropRaZvQUz'<br/>}</span></pre><p id="4f82" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们用这个做什么？当发送一个新的请求时，如果它与前一个相同，后端将向我们发送相同的信息。我们必须告诉它，我们希望下一个朋友序列从光标等于我们得到的<code class="du jx jy jz ka b">end_cursor</code>值的用户开始。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="9c32" class="li kc hi ka b fi lj lk l ll lm">response = session.post(<br/>    url,<br/>    headers=headers,<br/>    data=urllib.parse.urlencode(<br/>        {<br/>            "fb_dtsg": fb_dtsg_token,<br/>            "fb_api_req_friendly_name": "FriendingCometFriendsListPaginationQuery",<br/>            "variables": json.dumps(<br/>                {<br/>                    "count": 30,<br/>                    "cursor": page_info["end_cursor"],<br/>                    "scale": 1,<br/>                }<br/>            ).replace(" ", ""),<br/>            "doc_id": 4268740419836267,<br/>        }<br/>    )<br/>)<br/><br/>response_dict = json.loads(response.content)<br/>friend_objects = response_dict["data"]["viewer"]["all_friends"]["edges"]<br/><br/>friends += [<br/>    dict(<br/>        user_id=str(friend["node"]["id"]),<br/>        name=friend['node']['name'],<br/>        link=friend['node']['url'],<br/>        gender=friend['node']['gender']<br/>    )<br/>    for friend <strong class="ka hj">in</strong> friend_objects<br/>    if friend["node"]["__typename"] == "User"<br/>]<br/><br/>print(f"Number of friends: <strong class="ka hj">{</strong>len(friends)<strong class="ka hj">}</strong>")</span><span id="d096" class="li kc hi ka b fi ln lk l ll lm"># Output:<br/>Number of friends: 60</span></pre><p id="c408" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如你所见，现在我们又多了30个朋友。你可以这样做，直到没有朋友了:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="fac1" class="li kc hi ka b fi lj lk l ll lm">page_info = dict(has_next_page=True, end_cursor=None)<br/><br/>url = 'https://www.facebook.com/api/graphql/'<br/><br/>headers = {<br/>    "accept": "*/*",<br/>    "accept-language": "es-ES,es;q=0.9",<br/>    "content-type": "application/x-www-form-urlencoded",<br/>    "sec-ch-ua": "<strong class="ka hj">\"</strong> Not;A Brand<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>99<strong class="ka hj">\"</strong>, <strong class="ka hj">\"</strong>Google Chrome<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>91<strong class="ka hj">\"</strong>, <strong class="ka hj">\"</strong>Chromium<strong class="ka hj">\"</strong>;v=<strong class="ka hj">\"</strong>91<strong class="ka hj">\"</strong>",<br/>    "sec-ch-ua-mobile": "?0",<br/>    "sec-fetch-dest": "empty",<br/>    "sec-fetch-mode": "cors",<br/>    "sec-fetch-site": "same-origin",<br/>    "x-fb-friendly-name": "FriendingCometFriendsListPaginationQuery",<br/>    "referrer": "https://www.facebook.com/friends/list",<br/>    "referrerPolicy": "strict-origin-when-cross-origin",<br/>}<br/><br/>friends = []<br/><br/>while page_info["has_next_page"]:<br/>    response = session.post(<br/>        url,<br/>        headers=headers,<br/>        data=urllib.parse.urlencode(<br/>            {<br/>                "fb_dtsg": fb_dtsg_token,<br/>                "fb_api_req_friendly_name": "FriendingCometFriendsListPaginationQuery",<br/>                "variables": json.dumps(<br/>                    {<br/>                        "count": 30,<br/>                        "cursor": page_info["end_cursor"],<br/>                        "scale": 1,<br/>                    }<br/>                ).replace(" ", ""),<br/>                "doc_id": 4268740419836267,<br/>            }<br/>        )<br/>    )<br/>    <br/>    response_dict = json.loads(response.content)<br/>    friend_objects = response_dict["data"]["viewer"]["all_friends"]["edges"]<br/><br/>    friends += [<br/>        dict(<br/>            user_id=str(friend["node"]["id"]),<br/>            name=friend['node']['name'],<br/>            link=friend['node']['url'],<br/>            gender=friend['node']['gender']<br/>        )<br/>        for friend <strong class="ka hj">in</strong> friend_objects<br/>        if friend["node"]["__typename"] == "User"<br/>    ]<br/>    <br/>    page_info = response_dict["data"]["viewer"]["all_friends"]["page_info"]<br/>    <br/>print(f"Number of friends: <strong class="ka hj">{</strong>len(friends)<strong class="ka hj">}</strong>")</span></pre><p id="de00" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们有完整的朋友名单！！！恭喜你，伙计，你成功了一半！休息一会儿，等你准备好了再回来。</p><h1 id="6dbd" class="kb kc hi bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky bi translated">找到你所有朋友的共同朋友</h1><p id="abc4" class="pw-post-body-paragraph if ig hi ih b ii kz ik il im la io ip iq lb is it iu lc iw ix iy ld ja jb jc hb bi translated">这是最繁琐的部分，抱歉。但是现在你已经在这里了，不要放弃，当你得到你的结果时，你会满意的。</p><p id="9ea1" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们要做的是得到网络的边(连接圆的线)。我们将用我能想到的最简单原始的方法来做。我们将一个接一个地访问您的每个朋友的个人资料，转到“共同的朋友”部分，向下滚动，直到所有朋友都出现，最后阅读并保存它们。</p><blockquote class="lp lq lr"><p id="fa52" class="if ig ju ih b ii ij ik il im in io ip ls ir is it lt iv iw ix lu iz ja jb jc hb bi translated">为什么不再使用GraphQL API呢？</p></blockquote><p id="eaa9" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这是一个合理的问题。答案是我已经尝试过了，而且我成功了(在短短几秒钟内我就下载了所有的信息)，但是脸书会知道你有可疑的行为，并会阻止你的帐户的一些功能至少几个小时，这是非常不方便的。但是不要抱怨。这个政策很有意义，因为脸书不知道是你用Python做了一些网页抓取练习，还是一个恶意软件未经你同意使用了你的浏览器。因此，脸书以这种方式保护我们的数据实际上是一个好消息。</p><p id="0af8" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">无论如何，我最终使用的解决方法是假装我们是一个普通用户访问他朋友的个人资料。直到现在我的账户还没有被封。</p><p id="daa2" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">让我们从简单的步骤开始，然后把所有的东西放在一起。我们需要做的第一件事是什么？转到我们朋友的个人资料。为此，我们需要该页面的URL。这很棘手，因为当涉及到用户资料时，有两种类型的URL。</p><p id="cc66" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">其中一些，我猜是旧的，有这种形式(id是一个不存在的例子):</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="63e0" class="li kc hi ka b fi lj lk l ll lm"><a class="ae jd" href="https://www.facebook.com/profile.php?id=123456789014389713490753713" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/profile.php?id=123456789014389713490753713</a></span></pre><p id="d3e7" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">但是它们中的大多数都有这样的形式:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="4489" class="li kc hi ka b fi lj lk l ll lm"><a class="ae jd" href="https://www.facebook.com/barack.obama.or.something" rel="noopener ugc nofollow" target="_blank">https://www.facebook.com/barack.obama.or.something</a></span></pre><p id="ec47" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">根据我们拥有的不同，共同好友页面的URL略有不同。在第一种情况下，它是一个查询参数。在第二种情况下，它是路径的一部分。让我们以我们的第一个朋友为例:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="0f96" class="li kc hi ka b fi lj lk l ll lm">friend = friends[0]<br/><br/>profile_link = friend["link"]<br/><br/>url_parsed = urllib.parse.urlparse(profile_link)<br/><br/>if url_parsed.path == "/profile.php":<br/>    mutual_friends_link =  f"<strong class="ka hj">{</strong>profile_link<strong class="ka hj">}</strong>&amp;sk=friends_mutual"<br/>else:<br/>    mutual_friends_link = f"<strong class="ka hj">{</strong>profile_link<strong class="ka hj">}</strong>/friends_mutual"<br/>    <br/>driver.get(mutual_friends_link)<br/>time.sleep(1.5)</span></pre><p id="a1b3" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Booom！干得好。</p><p id="8c18" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们在页面上。但是，即使我们等了一段时间让它加载，它很可能还没有完全加载，而且无论你等多久都不会加载。</p><p id="8c2b" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">记住:如果用户不向下滚动，脸书不会加载所有信息，否则会浪费资源。所以，如果你和你的朋友有很多共同的朋友，他们不会显示在屏幕上，直到你不向下滚动。</p><p id="149f" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们怎么知道所有东西都装上了吗？我们必须寻找表示更多朋友正在加载的<code class="du jx jy jz ka b">&lt;div&gt;</code>元素:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/b4f282a41476d3f69a9f922e638be0bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*EkIkYESJdck1FmF7.png"/></div></div></figure><p id="9a46" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们找到该元素，那么我们将向下滚动。如果我们再次找到它，我们将再次向下滚动，直到它消失，即，直到所有的朋友都已被加载。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="f824" class="li kc hi ka b fi lj lk l ll lm">from selenium.webdriver.common.keys import Keys<br/><br/>loading_mutual_friends_panel_class = "lzcic4wl j83agx80 btwxx1t3 lhclo0ds i1fnvgqd"<br/>loading_mutual_friends_panel_selector = f"div[class='<strong class="ka hj">{</strong>loading_mutual_friends_panel_class<strong class="ka hj">}</strong>'][data-visualcompletion='loading-state']"<br/><br/>loading_element = driver.find_elements_by_css_selector(<br/>    loading_mutual_friends_panel_selector<br/>)<br/><br/>while len(loading_element) &gt; 0:<br/>    driver.find_element_by_xpath('//body').send_keys(Keys.END)<br/>    time.sleep(0.5)<br/>    loading_element = driver.find_elements_by_css_selector(<br/>        loading_mutual_friends_panel_selector<br/>    )</span></pre><p id="a17a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在我们可以确定所有共同好友都已加载。剩下的部分就是去读它们。先找有共同好友的面板。</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/6e5d4bf92bccaf02aa48a4a4426439b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wCPGNsptRX9QdROO.png"/></div></div></figure><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="2e0f" class="li kc hi ka b fi lj lk l ll lm">mutual_friends_panel_selector = "div[data-pagelet='ProfileAppSection_0']"<br/><br/>mutual_friends_pannel = driver.find_element_by_css_selector(<br/>    mutual_friends_panel_selector<br/>)</span></pre><p id="6d37" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个共同的好友都会出现在自己的“卡片”中，他或她的名字是一个<code class="du jx jy jz ka b">&lt;a&gt;</code>元素:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es jv"><img src="../Images/307d1983e7022530cb15c0ef549dca9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rDWh-C51QvziUxJ9.png"/></div></div></figure><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="3fe0" class="li kc hi ka b fi lj lk l ll lm">mutual_friend_link_class = (<br/>    "oajrlxb2 g5ia77u1 qu0x051f esr5mh6w e9989ue4 r7d6kgcz rq0escxv"<br/>    " nhd2j8a9 nc684nl6 p7hjln8o kvgmc6g5 cxmmr5t8 oygrvhab hcukyx3x"<br/>    " jb3vyjys rz4wbd8a qt6c0cv9 a8nywdso i1ao9s8h esuyzwwr f1sip0of lzcic4wl gmql0nx0 gpro0wi8"<br/>)<br/><br/>mutual_friend_link_selector = f"a[class='<strong class="ka hj">{</strong>mutual_friend_link_class<strong class="ka hj">}</strong>']"<br/><br/>mutual_friend_links = mutual_friends_pannel.find_elements_by_css_selector(<br/>    mutual_friend_link_selector<br/>)<br/><br/>print(f"Number of mutual friends with <strong class="ka hj">{</strong>friend['name']<strong class="ka hj">}</strong>: <strong class="ka hj">{</strong>len(mutual_friend_links)<strong class="ka hj">}</strong>")</span></pre><p id="c118" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">每个链接都有两条有用的信息。一方面是文本，这是共同朋友的名字。另一个是它重定向到的URL，这是他或她的个人资料链接。</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="8a50" class="li kc hi ka b fi lj lk l ll lm">mutual_friends = []<br/>for link <strong class="ka hj">in</strong> mutual_friend_links:<br/>    name = link.text<br/>    link = link.get_attribute("href")<br/>    mutual_friends.append(<br/>        dict(<br/>            name=name,<br/>            link=link<br/>        )<br/>    )</span></pre><p id="5e44" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">Goooood！我们快到了。</p><p id="7787" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们知道有问题。嗯，这只是个人喜好。我想使用<code class="du jx jy jz ka b">user_id</code>作为每个人的唯一标识符。我可以使用简介链接<code class="du jx jy jz ka b">link</code>，这可能是独一无二的，但我只是更喜欢<code class="du jx jy jz ka b">user_id</code>。</p><p id="2c5a" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">链接中没有直接提供，但是我们可以从我们的好友列表中获取。因此，我们将把前面的循环改为:</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="fc9a" class="li kc hi ka b fi lj lk l ll lm">def get_friend_by_link(link):<br/>    for friend <strong class="ka hj">in</strong> friends:<br/>        if friend["link"] == link:<br/>            return friend<br/>        <br/>    return None<br/><br/><br/>mutual_friends = []<br/>for link <strong class="ka hj">in</strong> mutual_friend_links:<br/>    name = link.text<br/>    link = link.get_attribute("href")<br/>    <br/>    friend = get_friend_by_link(link)<br/>    user_id = friend["user_id"]<br/>    gender = friend["gender"]<br/>    <br/>    mutual_friends.append(<br/>        dict(<br/>            user_id = user_id,<br/>            name=name,<br/>            link=link,<br/>            gender = gender,<br/>        )<br/>    )</span></pre><p id="7725" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">如果我们把这些放在一起，为你所有的朋友做这个手术会怎么样？</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="de4d" class="li kc hi ka b fi lj lk l ll lm">loading_mutual_friends_panel_class = "lzcic4wl j83agx80 btwxx1t3 lhclo0ds i1fnvgqd"</span><span id="c73b" class="li kc hi ka b fi ln lk l ll lm">loading_mutual_friends_panel_selector = f"div[class='<strong class="ka hj">{</strong>loading_mutual_friends_panel_class<strong class="ka hj">}</strong>'][data-visualcompletion='loading-state']"</span><span id="bce1" class="li kc hi ka b fi ln lk l ll lm">mutual_friends_panel_selector = "div[data-pagelet='ProfileAppSection_0']"</span><span id="1a8e" class="li kc hi ka b fi ln lk l ll lm">mutual_friend_link_class = (<br/>    "oajrlxb2 g5ia77u1 qu0x051f esr5mh6w e9989ue4 r7d6kgcz rq0escxv"<br/>    " nhd2j8a9 nc684nl6 p7hjln8o kvgmc6g5 cxmmr5t8 oygrvhab hcukyx3x"<br/>    " jb3vyjys rz4wbd8a qt6c0cv9 a8nywdso i1ao9s8h esuyzwwr f1sip0of lzcic4wl gmql0nx0 gpro0wi8"<br/>)</span><span id="eede" class="li kc hi ka b fi ln lk l ll lm">mutual_friend_link_selector = f"a[class='<strong class="ka hj">{</strong>mutual_friend_link_class<strong class="ka hj">}</strong>']"<br/><br/><br/>def visit_mutual_friends_page(friend):<br/>    profile_link = friend["link"]<br/>    url_parsed = urllib.parse.urlparse(profile_link)<br/><br/>    if url_parsed.path == "/profile.php":<br/>        mutual_friends_link =  f"<strong class="ka hj">{</strong>profile_link<strong class="ka hj">}</strong>&amp;sk=friends_mutual"<br/>    else:<br/>        mutual_friends_link = f"<strong class="ka hj">{</strong>profile_link<strong class="ka hj">}</strong>/friends_mutual"<br/><br/>    driver.get(mutual_friends_link)<br/>    time.sleep(1.5)<br/>    <br/>    <br/>def wait_for_every_friend_to_load():<br/>    loading_element = driver.find_elements_by_css_selector(<br/>        loading_mutual_friends_panel_selector<br/>    )<br/><br/>    while len(loading_element) &gt; 0:<br/>        driver.find_element_by_xpath('//body').send_keys(Keys.END)<br/>        time.sleep(0.5)<br/>        loading_element = driver.find_elements_by_css_selector(<br/>            loading_mutual_friends_panel_selector<br/>        )<br/><br/>def get_friend_by_link(link):<br/>    for friend <strong class="ka hj">in</strong> friends:<br/>        if friend["link"] == link:<br/>            return friend<br/>        <br/>    return None<br/><br/><br/>mutual_friends_all = {}<br/>num_friends = len(friends)<br/>for i, friend <strong class="ka hj">in</strong> enumerate(friends, start=1):<br/>    print(f"Reading mutual friends with <strong class="ka hj">{</strong>friend['name']<strong class="ka hj">}</strong>. (<strong class="ka hj">{</strong>i<strong class="ka hj">}</strong> of <strong class="ka hj">{</strong>num_friends<strong class="ka hj">}</strong>)")<br/>    <br/>    visit_mutual_friends_page(friend)<br/><br/>    wait_for_every_friend_to_load()<br/>    <br/>    mutual_friends_pannel = driver.find_element_by_css_selector(<br/>        mutual_friends_panel_selector<br/>    )<br/>    <br/>    mutual_friend_links = mutual_friends_pannel.find_elements_by_css_selector(<br/>        mutual_friend_link_selector<br/>    )<br/>    <br/>    mutual_friends = []<br/>    for link <strong class="ka hj">in</strong> mutual_friend_links:<br/>        link = link.get_attribute("href")<br/><br/>        friend = get_friend_by_link(link)<br/><br/>        mutual_friends.append(<br/>            dict(<br/>                user_id=friend["user_id"],<br/>                name=friend["name"],<br/>                link=link,<br/>                gender=friend["gender"],<br/>            )<br/>        )<br/>    <br/>    mutual_friends_all[friend["user_id"]] = mutual_friends</span></pre><p id="dc9c" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">这并不容易，但我们做到了。在您的笔记本电脑电池耗尽之前保存它！</p><pre class="jf jg jh ji fd le ka lf lg aw lh bi"><span id="0334" class="li kc hi ka b fi lj lk l ll lm">with open("my_friends_network", "w") as outfile:<br/>    json.dump(<br/>        dict(<br/>            friend_list=friends,<br/>            mutual_friends=mutual_friends_all,<br/>        ),<br/>        outfile<br/>    )</span></pre><p id="2fb6" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我们做到了！！！！！🥳🥳🥳</p><p id="21eb" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">现在，我们可以使用它以不同的方式可视化网络，甚至可以找到不同的用户群，如下图所示:</p><figure class="jf jg jh ji fd jj er es paragraph-image"><div role="button" tabindex="0" class="jk jl di jm bf jn"><div class="er es lv"><img src="../Images/aba97df2deaa5e50e510f094ecc1e74b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SUnq1H7hSdlN9CAL.png"/></div></div></figure><p id="1751" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated">我将在下一篇文章中教你如何做:<a class="ae jd" href="https://rubchume.medium.com/organize-your-wedding-with-social-network-analysis-in-python-aeab9d8814b3" rel="noopener">用Python中的社交网络分析来组织你的婚礼</a>。</p></div><div class="ab cl lw lx gp ly" role="separator"><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb mc"/><span class="lz bw bk ma mb"/></div><div class="hb hc hd he hf"><p id="cf85" class="pw-post-body-paragraph if ig hi ih b ii ij ik il im in io ip iq ir is it iu iv iw ix iy iz ja jb jc hb bi translated"><em class="ju">原载于</em><a class="ae jd" href="https://www.listeningtothedata.com/posts/read-your-network-of-friends-in-facebook-by-scraping-with-python/" rel="noopener ugc nofollow" target="_blank"><em class="ju"/></a><em class="ju">。</em></p></div></div>    
</body>
</html>