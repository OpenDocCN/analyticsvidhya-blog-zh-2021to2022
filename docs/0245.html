<html>
<head>
<title>Improving Elasticsearch Query Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高弹性搜索查询性能</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/improving-elasticsearch-query-performance-3b59c6b15a97?source=collection_archive---------2-----------------------#2021-01-10">https://medium.com/analytics-vidhya/improving-elasticsearch-query-performance-3b59c6b15a97?source=collection_archive---------2-----------------------#2021-01-10</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/c99525b6bd453a2214437d9423c63577.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B_LkCNig-0qvI0q-QihDKw.jpeg"/></div></div></figure><p id="0c71" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">简介</strong></p><p id="c9d5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Elasticsearch是一个基于Apache Lucene的分布式查询处理系统，用于构建搜索和分析系统。这是一个基于java的实现，它读取一个JSON请求，并用JSON响应有效载荷进行响应。它为调用查询接口提供了API，并在行业中广泛用于对大量数据进行更快的分析搜索。ELK stack提供了广泛的功能，并展示了一个完整的生态系统，用于存储、处理、查询和转换大量的事务日志，并提供了对数据集的出色监控和可视化功能。Elasticsearch集群中的数据管理部分不同于其他数据持久化和搜索替代方案。Elasticsearch在结构化文档上创建索引，而不是将数据保存为表格</p></div><div class="ab cl jo jp gp jq" role="separator"><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt ju"/><span class="jr bw bk js jt"/></div><div class="hb hc hd he hf"><p id="ff6d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">让我们在一个非常高的层次上理解elasticsearch数据管理的构造块，以供以后参考。</p><p id="0771" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jv">文档</em> </strong>:最基本的实体，可以比作数据库中的一行，这就是你要搜索的内容，可以是任何编码的结构化数据格式。</p><p id="380a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jv">倒排索引</em> </strong>:基于搜索查询的具有相似属性的文档组。它可以被理解为类似于一个数据库，其中保存着与一个模式连接在一起的记录，这些记录具有共同的特征，并且在逻辑上是相关的。这是一种hashmap类型的表示，有助于从单词中找到文档。作用于<strong class="is hj"> TFIDF </strong>，简称<strong class="is hj">词频-逆文档频率</strong></p><blockquote class="jw jx jy"><p id="67bb" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated"><em class="hi"> tfidf(t，D，D) = tf(t，D)。idf(t，D) </em></p></blockquote><p id="dea2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj"> <em class="jv">碎片</em> </strong>:碎片是跨越elasticsearch集群中各个节点的索引的分割。它们是托管在一个节点上的独立索引。</p><blockquote class="jw jx jy"><p id="a9b2" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">根据我最近在扩展具有近实时处理需求的搜索系统方面的一些经验，这里有一些技巧可以帮助加速elasticsearch集群中的搜索和索引吞吐量。</p></blockquote><p id="c9b4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">配置堆</strong></p><p id="9390" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">使用elasticsearch，需要将MAX_HEAP和MIN_HEAP配置为相同的值，以避免在运行时调整大小，这是一个致命的操作。</p><blockquote class="jw jx jy"><p id="d74d" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated"><code class="du kc kd ke kf b"><em class="hi">ES_HEAP_SIZE</em></code>可以使用环境变量来进行设置，而不是显式配置-Xms和-Xmx值。</p></blockquote><p id="fcd0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">堆不是万能的，给Lucene足够的资源</strong></p><p id="41ca" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">如果我们不这样做，本质上意味着我们配置了一个太大的堆，这有其自身的缺点，不用说在弹性搜索中，这可能是一场性能灾难。Lucene的性能依赖于这种与操作系统的交互。但是如果你把所有可用的内存都给了Elasticsearch的堆，就不会有任何剩余给Lucene了。这可能会严重影响性能。</p><p id="c27c" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">另一方面，Lucene被设计成利用底层操作系统来缓存内存数据结构。Lucene片段存储在不可变的单独文件中，所以这些文件永远不会改变。这使得它们对缓存非常友好，底层操作系统会很高兴地将热段驻留在内存中以实现更快的访问。这些段包括倒排索引(用于全文搜索)和doc值(用于聚合)。</p><blockquote class="jw jx jy"><p id="91ba" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">一般建议将可用内存的1/2给Elasticsearch heap，而将剩余的1/2留作空闲。相信我，它不会闲置的；Lucene会更好地利用它。</p></blockquote><p id="7cbc" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果不能完全消除交换，就减少交换</strong></p><p id="7a20" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">交换主内存会降低系统性能。确保您有足够的资源来降低交换的需求，这违背了提高内存操作速度的目的。交换时间通常会比实际的内存获取时间多几倍。编辑/etc/fstab以永久禁用它。另一种方法是降低<code class="du kc kd ke kf b">swappiness</code>。该值控制操作系统尝试交换内存的力度。这阻止了正常情况下的交换，但仍然允许操作系统在内存意外情况下交换。</p><blockquote class="jw jx jy"><p id="a5a9" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">或者，您可以让JVM锁定它的内存空间，不允许操作系统交换内存。这可以通过在elasticsearch属性文件中设置<strong class="is hj"><em class="hi">bootstrap . mlockall:true</em></strong>来实现。</p></blockquote><p id="2bb0" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">反规范化文档</strong></p><p id="843e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">尽可能限制连接，嵌套查询会显著降低搜索查询性能。设计数据模型时，要使数据在很大程度上可以反规范化，从而消除一些不需要的连接。</p><p id="2c60" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">在步进时将多个字段复制到单个字段</strong></p><p id="a3aa" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">这是为了避免创建具有多个查询字段的搜索查询，这会严重降低搜索性能。或者，在创建索引时，使用copy_to指令将多个字段的值复制到单个字段中。</p><p id="b403" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">大量使用数据的预索引</strong></p><p id="6e43" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">为了避免在搜索期间进行昂贵的范围聚合，最好将范围预先索引到索引中。</p><p id="ecc1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">急切指定热点区域进行缓存</strong></p><p id="4b48" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在文件系统重新启动时，默认情况下，系统缓存将根据查询的热门搜索创建热区域的缓存，但建议尽快让系统知道要缓存什么，以实现更快的搜索响应时间并预热系统。这一过程称为缓存预加载，此时操作系统会被指示急切地将数据加载到文件系统缓存中。</p><p id="88f1" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">正确选择副本数量</strong></p><p id="0db9" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">副本有助于增强所有系统的弹性和可用性，但是将副本数量增加到一定数量后就没有什么用了，而且可能会降低系统性能。</p><blockquote class="jw jx jy"><p id="ada4" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">我怎么计算呢？嗯，如果您有一个包含<code class="du kc kd ke kf b"><em class="hi">N</em></code>个节点的集群，总共有<code class="du kc kd ke kf b"><em class="hi">P</em></code>个主碎片，并且如果您希望最多一次处理<code class="du kc kd ke kf b"><em class="hi">F</em></code>个节点故障，那么正确的副本数量是<code class="du kc kd ke kf b"><em class="hi">max(F, ceil(N / P) - 1)</em></code></p></blockquote><p id="048e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">缓存</strong></p><p id="de51" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为一个支持搜索的系统，弹性搜索中的读取应该明显更快，因此频繁读取的结果应该总是在文件系统的热点区域，为了实现这一点，需要有大量的物理内存可用于缓存数据。通常建议分配一半的可用集群内存用于缓存。</p><p id="0a2d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">更新是成本密集型的</strong></p><p id="95be" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">作为默认行为，elasticsearch将每秒刷新所有索引的索引，其中查询负载至少为每30秒1个查询。对于负载较高的系统，建议将刷新率提高到更高的间隔值，以避免刷新过程的开销更频繁，并提高索引吞吐量。</p><p id="31b5" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">初始加载时不加载副本</strong></p><p id="e919" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在生成新的弹性搜索集群和索引数据时，最好不要在启用复制的情况下加载数据，一旦加载数据，就会增加副本数量，并且一旦发生刷新过程，副本就会扩大。这实质上意味着，您应该始终对正在读取的数据进行持久备份，因为数据负载是以0复制系数发生的，任何停机都意味着数据丢失。</p><p id="bc09" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">为步进设置正确的缓冲区大小</strong></p><p id="399e" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">拥有足够大的缓冲区对于快速执行繁重的索引过程非常重要。确保<strong class="is hj"><em class="jv">indexes . memory . index _ buffer _ size</em></strong><em class="jv"/>为每个碎片设置了正确的值，通常每个碎片可以达到512 mb，进一步增加通常没有帮助<em class="jv">。</em></p><blockquote class="jw jx jy"><p id="3f86" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">假设您有40GB的JVM内存，它将为索引缓冲区提供4GB(10%),这对于大量索引的8个碎片来说足够了。</p></blockquote><p id="7ee4" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">如果不需要，禁用再平衡</strong></p><p id="4b79" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">切换<strong class="is hj">cluster . routing . rebalance . enable</strong>设置以启用/禁用重新平衡。Elasticsearch有时会重新平衡碎片，这会降低搜索查询的性能。</p><p id="090d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">分片上浆</strong></p><p id="b9c2" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">分片允许与分布式架构并行执行，因此，它允许水平扩展。有两种类型的碎片，主碎片负责读写操作，如索引、重建索引、删除等，副本碎片负责高可用性和读取吞吐量。</p><p id="6a1a" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">优化分片值得考虑的点是分片的大小、分片中每个片段的大小、一个节点中有多少个活动片段。</p><p id="367f" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">副本碎片对于扩展搜索吞吐量很重要，如果硬件适合这种情况，可以小心地增加副本碎片的数量。</p><blockquote class="jw jx jy"><p id="c4fc" class="iq ir jv is b it iu iv iw ix iy iz ja jz jc jd je ka jg jh ji kb jk jl jm jn hb bi translated">通常，每个节点的碎片越少，性能越好，因为文件系统缓存在节点间的分布会更有效。</p></blockquote><p id="2e24" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">解耦索引和搜索</strong></p><p id="c26b" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">在单个集群中，索引和搜索都会相互竞争资源。通过设置双集群并配置<a class="ae kg" href="https://www.elastic.co/guide/en/elasticsearch/reference/master/xpack-ccr.html" rel="noopener ugc nofollow" target="_blank">跨集群复制</a>将数据从一个集群复制到另一个集群，并将所有搜索定向到具有跟随者索引的集群，搜索活动将不再争夺托管领导者索引的集群上的索引资源。</p><p id="1b15" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated"><strong class="is hj">结论</strong></p><p id="a03d" class="pw-post-body-paragraph iq ir hi is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hb bi translated">Elasticsearch提供了广泛的配置支持，可以对属性进行调整，以实现有助于实现业务目标的最佳设置。应充分考虑系统的存储、转换、分析和处理需求，以确定最佳方案。基于Lucene的系统的一些最好的特性伴随着非常高的资源权衡，因此过度的工程设计可能是危险的。</p></div></div>    
</body>
</html>