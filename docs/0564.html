<html>
<head>
<title>Image Shifting using NumPy from Scratch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从头开始使用NumPy进行图像移位</h1>
<blockquote>原文：<a href="https://medium.com/analytics-vidhya/image-shifting-using-numpy-from-scratch-8bd52663da52?source=collection_archive---------3-----------------------#2021-01-22">https://medium.com/analytics-vidhya/image-shifting-using-numpy-from-scratch-8bd52663da52?source=collection_archive---------3-----------------------#2021-01-22</a></blockquote><div><div class="ds gw gx gy gz ha"/><div class="hb hc hd he hf"><div class=""/><figure class="ev ex ig ih ii ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es if"><img src="../Images/03b3a7fb8bf5fac40f42d94c05fa16f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s8_o7ZPBH3R3C1mW"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">照片由<a class="ae iu" href="https://unsplash.com/@jamesplewis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">詹姆斯·刘易斯</a>在<a class="ae iu" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄</figcaption></figure><p id="f37e" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">图像移动只是将图像的每个像素移动到一个新的位置。这是数码相机中用于产生超分辨率图像的像素移位方法。我们可以把一个像素看作是坐标轴上的一个点，可以向任意方向移动。当我们在图像的所有像素上实现这一点时，我们可以说图像发生了偏移。</p><p id="dfed" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">在这篇博客文章中，当我们使用NumPy操作完全移动坐标轴上的点时，我们将尝试移动图像。图像总是被认为是一个<code class="du jt ju jv jw b">2D</code>平面，因此我们也将考虑一个以<code class="du jt ju jv jw b">X</code>为横轴、<code class="du jt ju jv jw b">Y</code>为纵轴的<code class="du jt ju jv jw b">2D</code>坐标轴。坐标轴分为<code class="du jt ju jv jw b">4</code>象限，即-</p><ul class=""><li id="aa66" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated"><strong class="ix hj"> Q1 </strong> →象限<code class="du jt ju jv jw b">X</code>和<code class="du jt ju jv jw b">Y</code>都为正。</li><li id="417e" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated"><strong class="ix hj"> Q2 </strong> →象限，其中<code class="du jt ju jv jw b">X</code>为负，<code class="du jt ju jv jw b">Y</code>为正。</li><li id="0458" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated"><strong class="ix hj"> Q3 </strong> →象限<code class="du jt ju jv jw b">X</code>和<code class="du jt ju jv jw b">Y</code>均为负。</li><li id="28af" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated"><strong class="ix hj"> Q4 </strong> →象限，其中<code class="du jt ju jv jw b">X</code>为正，<code class="du jt ju jv jw b">Y</code>为负。</li></ul><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/df388995123c8a9abdd64b72748545b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*DPGzkyc6P-7TX7n0LDqV3Q.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="1c74" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们假设我们的原始图像在原点，即(0，0)。为了形象化这一点，我们可以想象如下的东西</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/a575076d919231511c4c321c1de15d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*6L-5nddtSw_0jnogUOf-yg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="7c07" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在，假设我们想在坐标(3，4)处移动图像。基本上，图像的原点必须从(0，0)移动到(3，4)，如下所示</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es kl"><img src="../Images/0723a247fe35257a818084be13bea94b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*-dRGDg5v3i-keWZNATJsNg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="653d" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">同样，基于坐标点，我们需要移动图像。让我们从一个<code class="du jt ju jv jw b">2D</code>矩阵开始，使用模块NumPy从头开始理解和实现，因为图像只是大矩阵。</p><h1 id="df13" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">编码时间到了</h1><p id="e329" class="pw-post-body-paragraph iv iw hi ix b iy lo ja jb jc lp je jf jg lq ji jj jk lr jm jn jo ls jq jr js hb bi translated">我们主要使用的软件包有:</p><ul class=""><li id="ff44" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated">NumPy</li><li id="4732" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">Matplotlib</li><li id="ee8f" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">OpenCV →它仅用于读取图像(在本文中)。</li></ul><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es lt"><img src="../Images/18305c130ac5255d7e7a39a385ec518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Nm7Ec_i9OjDnCPM59Nkdg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><h1 id="e5dd" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><code class="du jt ju jv jw b">Import</code>包装</h1><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><h1 id="141c" class="kq kr hi bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated"><code class="du jt ju jv jw b">2D</code>矩阵</h1><pre class="km kn ko kp fd lw jw lx ly aw lz bi"><span id="23cd" class="ma kr hi jw b fi mb mc l md me">&gt;&gt;&gt; import random<br/>&gt;&gt;&gt; <br/>&gt;&gt;&gt; mat = [[random.randint(5, 100) for i in range(5)] for j in range(5)]<br/>&gt;&gt;&gt; mat = np.matrix(mat)<br/>&gt;&gt;&gt; print(mat)<br/>[[ 46  13  68  54  12]<br/> [  7  68  32  46  26]<br/> [ 46  43  58  27 100]<br/> [ 64  59  76 100  41]<br/> [ 35  62  56  44   7]]<br/>&gt;&gt;&gt;</span></pre><p id="ea9a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">例如，让我们假设我们在<code class="du jt ju jv jw b">Q1</code>移动图像，确定图像必须向左侧向<code class="du jt ju jv jw b">X</code>轴移动，向顶部向<code class="du jt ju jv jw b">Y</code>轴移动。在这种情况下，图像的大小会增加。基本上，我们根据<code class="du jt ju jv jw b">x</code>坐标深度填充图像左侧，根据<code class="du jt ju jv jw b">y</code>坐标深度填充图像底部。当我们在剩余的象限<code class="du jt ju jv jw b">Q2</code>、<code class="du jt ju jv jw b">Q3</code>和<code class="du jt ju jv jw b">Q4</code>中移动图像时，必须重复同样的操作。</p><p id="70f3" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">为此，我们需要使用NumPy方法创建一个填充函数。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="4aa4" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">上述函数用于填充图像。使用的参数如下:</p><ol class=""><li id="1766" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js mf kd ke kf bi translated"><strong class="ix hj">向量</strong> →填充完成的矩阵。</li><li id="e710" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js mf kd ke kf bi translated"><strong class="ix hj">如何进行</strong> →这需要四个值来决定图像需要移动的象限。</li><li id="c415" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js mf kd ke kf bi translated"><strong class="ix hj">深度</strong> →衬垫的深度。</li></ol><ul class=""><li id="45a9" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated">下部或底部</li><li id="1bf3" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">上部或顶部</li><li id="796d" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">正确</li><li id="6ca2" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">左边的</li></ul><p id="f459" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">4.<strong class="ix hj">常量值</strong> →表示<code class="du jt ju jv jw b">black</code>颜色，<code class="du jt ju jv jw b">0</code>为默认值。</p><p id="fdd5" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">注意—对于右填充和左填充，我们使用方法<code class="du jt ju jv jw b">hstack()</code>。同样，对于填充顶部和填充底部，我们使用方法<code class="du jt ju jv jw b">vstack()</code>。这两个是NumPy方法。</p><ul class=""><li id="a327" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated"><strong class="ix hj"> hstack() </strong> →水平堆叠</li><li id="e009" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated"><strong class="ix hj"> vstack() </strong> →垂直堆栈</li></ul><p id="36cb" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">首先，我们创建一个值为零的填充矩阵。基于移动的方向，我们使用这些方法。</p><p id="2aaf" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们来测试一下上面的函数。</p><pre class="km kn ko kp fd lw jw lx ly aw lz bi"><span id="3f89" class="ma kr hi jw b fi mb mc l md me">&gt;&gt;&gt; pmat = pad_vector(vector=mat, how='left', depth=3)<br/>&gt;&gt;&gt; print(pmat)<br/>[[  0   0   0  46  13  68  54  12]<br/> [  0   0   0  7   68  32  46  26]<br/> [  0   0   0  46  43  58  27 100]<br/> [  0   0   0  64  59  76 100  41]<br/> [  0   0   0  35  62  56  44   7]]<br/>&gt;&gt;&gt;</span></pre><p id="ec38" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们可以清楚地看到，该函数用深度级别<code class="du jt ju jv jw b">3</code>填充了矩阵左侧。如果我们绘制相同的图形(将填充的矩阵转换成图像)，我们会得到-</p><pre class="km kn ko kp fd lw jw lx ly aw lz bi"><span id="5ab0" class="ma kr hi jw b fi mb mc l md me">&gt;&gt;&gt; plt.axis("off")<br/>&gt;&gt;&gt; plt.imshow(pmat, cmap='gray')<br/>&gt;&gt;&gt; plt.show()</span></pre><figure class="km kn ko kp fd ij er es paragraph-image"><div role="button" tabindex="0" class="ik il di im bf in"><div class="er es mg"><img src="../Images/9a8990fbce10e01f6575281ad6984d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:698/format:webp/1*U_tUwnDD0npshE3wKB9Crg.png"/></div></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="0c31" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">而原始图像是-</p><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mh"><img src="../Images/636ae91e2e358c088a1f2a959f3693c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*dMt--FqPFnOMwZijzms_7A.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="da05" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">这样，我们可以断定图像向<code class="du jt ju jv jw b">X</code>轴的左侧移动，坐标为<code class="du jt ju jv jw b">x</code>3。同样的技术也适用于真实图像。让我们尝试复制同样的图像。</p><p id="708a" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我们将有一个函数来读取灰度和RGB格式的图像。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="33b0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">让我们制作另一个名为<code class="du jt ju jv jw b">shifter()</code>的函数，它实际上沿着<code class="du jt ju jv jw b">Y</code>轴移动图像，而不考虑象限。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="7b9c" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在我们有了<code class="du jt ju jv jw b">shifter()</code>函数，我们将需要在另一个函数中使用它，这个函数可以在坐标轴的任何地方移动。这里，我们考虑<code class="du jt ju jv jw b">X</code>和<code class="du jt ju jv jw b">Y</code>轴。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><ul class=""><li id="69c6" class="jx jy hi ix b iy iz jc jd jg jz jk ka jo kb js kc kd ke kf bi translated">当<code class="du jt ju jv jw b">x</code>和<code class="du jt ju jv jw b">y</code>坐标大于0时，填充图像左侧和底部。</li><li id="4111" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">当<code class="du jt ju jv jw b">x</code>大于0且<code class="du jt ju jv jw b">y</code>小于0时，填充图像左侧和顶部。</li><li id="d4ea" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">当<code class="du jt ju jv jw b">x</code>小于0且<code class="du jt ju jv jw b">y</code>大于0时，填充图像右侧和底部。</li><li id="6d82" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">当<code class="du jt ju jv jw b">x</code>和<code class="du jt ju jv jw b">y</code>坐标小于0时，填充图像右侧和顶部。</li><li id="775f" class="jx jy hi ix b iy kg jc kh jg ki jk kj jo kk js kc kd ke kf bi translated">当<code class="du jt ju jv jw b">x</code>和<code class="du jt ju jv jw b">y</code>坐标正好等于0时，不要干扰图像。</li></ul><p id="51d0" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">还有一个问题是要转换或移动图像。图像有两种类型—灰度和彩色。对于灰度，不会有任何问题。但是对于彩色图像，我们需要分离RGB像素，应用移位函数，然后最终合并像素。因此有了下面的函数。</p><figure class="km kn ko kp fd ij"><div class="bz dy l di"><div class="lu lv l"/></div></figure><p id="d2be" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">现在一切都设置好了，让我们测试上面的函数:</p><p id="78b9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对于彩色图像</strong></p><pre class="km kn ko kp fd lw jw lx ly aw lz bi"><span id="b29f" class="ma kr hi jw b fi mb mc l md me">translate_this(<br/>    image_file='lena_original.png',<br/>    at=(60, 60),<br/>    with_plot=True<br/>)</span></pre><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/27a50f4753f8050045954471d8f3049a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*8DDB1lAMDUH8iZlY0mbNKg.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="d9d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，图像被移动到原点(60，60)，即在第一象限(Q1)。</p><p id="e1ce" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated"><strong class="ix hj">对于灰度图像</strong></p><pre class="km kn ko kp fd lw jw lx ly aw lz bi"><span id="0983" class="ma kr hi jw b fi mb mc l md me">translate_this(<br/>    image_file='lena_original.png',<br/>    at=(-60, -60),<br/>    with_plot=True,<br/>    gray_scale=True<br/>)</span></pre><figure class="km kn ko kp fd ij er es paragraph-image"><div class="er es mi"><img src="../Images/533ddaf4f49e95e43b4ecaab057a65e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1144/format:webp/1*UPgNtHrIZjNfhMeFlczAKw.png"/></div><figcaption class="iq ir et er es is it bd b be z dx translated">作者图片</figcaption></figure><p id="73d9" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">显然，图像移动到原点(-60，-60)，即第三象限(Q3)。</p></div><div class="ab cl mj mk gp ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="hb hc hd he hf"><p id="3b70" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">好了，这篇文章就到这里。由此，我们试图理解图像移动过程是如何完成的。</p><p id="59e1" class="pw-post-body-paragraph iv iw hi ix b iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js hb bi translated">我告辞了。如果你喜欢它，考虑访问我的个人资料，阅读更多关于图像处理。请务必在这里为我买咖啡，或者点击下面的按钮。</p><figure class="km kn ko kp fd ij er es paragraph-image"><a href="https://www.buymeacoffee.com/msameeruddin"><div class="er es mq"><img src="../Images/6d60b235fcc46a4bd696b90e886419ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:340/format:webp/1*Dpw8-hNGI2fDmosV4E8DVQ.png"/></div></a><figcaption class="iq ir et er es is it bd b be z dx translated">支持我</figcaption></figure></div></div>    
</body>
</html>